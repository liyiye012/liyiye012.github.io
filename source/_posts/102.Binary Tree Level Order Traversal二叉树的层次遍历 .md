---
title: 102.Binary Tree Level Order Traversal二叉树的层次遍历
date: 2018-10-4 19:14:32    
categories: 2018年10月
tags: [LeetCode,Tree,Breadth-first Search]

---

给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。

<!-- more -->

例如:

		给定二叉树: [3,9,20,null,null,15,7],

		    3
		   / \
		  9  20
		    /  \
		   15   7
返回其层次遍历结果：

	[
	  [3],
	  [9,20],
	  [15,7]
	]

## 思路1:递归

	/**
	 * Definition for a binary tree node.
	 * struct TreeNode {
	 *     int val;
	 *     TreeNode *left;
	 *     TreeNode *right;
	 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
	 * };
	 */
	class Solution {
	public:
	    vector<vector<int>> levelOrder(TreeNode* root) {
	        vector<vector<int>> res;
	        leveltravel(res,0,root);
	        return res;
	    }
	    void leveltravel(vector<vector<int>> &res,int depth,TreeNode * root){
	         if(!root) return ;
	        vector<int> temp;
	        if(res.size()==depth) res.push_back(temp);
	        res[depth].push_back(root->val);
	        leveltravel(res,depth+1,root->left);
	        leveltravel(res,depth+1,root->right);
	        return;
	    }
	};


## 非递归

在做的过程中注意队列的大小会随时变化，因此需要将q.size()保存为一个变量

	/**
	 * Definition for a binary tree node.
	 * struct TreeNode {
	 *     int val;
	 *     TreeNode *left;
	 *     TreeNode *right;
	 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
	 * };
	 */
	class Solution {
	public:
	    vector<vector<int>> levelOrder(TreeNode* root) {
	        queue<TreeNode *> q;
	        vector<vector<int>> res;
	        if(root) {
	            q.push(root);
	        }
	        while(!q.empty()){
	         vector<int> temp;  
	         int len=q.size();
	         for(int i=0;i<len;i++){
	            TreeNode *cur;
	            cur=q.front();
	            temp.push_back(cur->val);
	            q.pop();
	             //cout<<"i="<<i<<"   cur->val="<<cur->val<<endl;
	            if(cur->left) q.push(cur->left);
	            if(cur->right) q.push(cur->right);
	            }
	            //cout<<"  *********"<<endl;
	            res.push_back(temp);
	        }
	    return res;
	    }
	};
