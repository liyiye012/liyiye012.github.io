---
title: C++基础概念I
date: 2018-08-21 09:58:44
categories: 2018年8月
tags: [C++]

---
# C++基础概念I

总结C++基础概念
## 1.C++面向对象的三大特征


<!-- more -->

### (1)封装:

将客观事物封装成抽象的类,并且设计者可以对类的成员进行访问控制权限控制. 这样一方面可以做到数据的隐藏,保护数据安全;另一方面,封装可以修改类的内部实现而不用修改调用了该类的用户的代码.同时封装还有利于代码的 方便复用；

### (2)继承:
#### a.
继承具有这样一种功能,它可以使用现有类的所有功能；并且可以在不重新编写原有类的情况下对类的功能进行扩展.继承的过程是一般到特殊的过程,即是它们是is-a的关系;基类或父类是一般,而子类或派生类是基类的特殊表现;要实现继承可以通过继承和组合来实现;

#### b.
广义上的继承分成三大类:实现继承:使用基类的属性和方法而无需额外编码的能力;接口继承:接口继承是指仅使用基类的属性和方法的名称,而具体的实现子类必须自己完成的能力;可视继承:子窗体(类)使用父窗体(类)的外观和实现代码的能力;

### (3)多态:
#### a.
多态的实现分成两种,一种是编译时的多态,主要是通过函数重载和运算符重

另外一种是运行时多态,主要是通过函数覆盖来实现的,它需要满足3个条件:基类函数必须是虚函数,并且基类的指针或引用指向子类的时候,当子类中对原有的虚函数进行重新定义之后形成一个更加严格的重载版本的时候,就会形成多态;它是通过动态联编实现的;

#### b.
运行时的多态可以让基类的指针或引用指向不同的对象的时候表现出来不同的特性;

## 2.简述C/C++程序编译时的内存分配情况

### (1)一般一个c/c++程序编译的时候内存布局如下(地址从低到高的顺序)

#### a.代码区:
存放程序的二进制代码.

#### b.常量区:
这个区和代码区的距离很近,主要存放一些非局部常量值和字符串字面值,一般不允许修改,程序结束由系统释放;具有常属性并且初始化的全局和静态变量也放在这个区.

#### c.数据区:
赋过初值的且不具有常属性的静态和全局变量在数据区.它和BSS段统称为静态区;程序结束后由系统释放;

#### d.BSS段:
没有初始化的静态和全局变量;进程一旦被加载这个区所有的数据都被清0;

#### e.堆区:
   动态分配的内存;由程序员分配和释放,程序结束的时候如果没有释放,则由OS回收;

#### f.栈区:
   由编译器自动分配和释放,不使用的时候会自动的释放.主要用来存放非静态的局部变量,函数的参数和返回值, 临时变量等.

#### g.命令行参数和环境变量区;

下面是对应一段经典的代码:

	#include <stdio.h>
	#include <stdlib.h>
	#include <unistd.h>  //unix下的头文件
	const int const_global = 10; //常全局变量
	int init_global = 10;        //初始化的全局变量
	int uninit_global;           //未初始化的全局变量
	
	int main(int argc,char * argv[])
	{
	    const static int const_static = 10;//常属性的静态变量，不可以被赋值，初始化
	    static int init_static = 10;    //初始化静态变量
	    static int uninit_static;       //未初始化静态变量
	    const int const_local = 10;    // 常属性的局部变量
	    int  prev_local = 1;//前局部变量
	    int  next_local = 5;//后局部变量
	    int* prev_heap = malloc(sizeof(int));//前面分配的堆变量
	    int* next_heap = malloc(sizeof(int));//后面分配的堆变量
	    const char* literal = "literal";      //字符串字面值，字面值常量
	    extern char** environ;               // 环境变量
	
	    printf("----地址最高断命令行参数和环境变量-------\n");
	    printf("        环境变量:%p\n",environ);
	    printf("      命令行参数:%p\n",argv);
	    printf("---------------栈区-----------------------\n");
	    printf("      常局部变量:%p\n",&const_local);
	    printf("      前局部变量:%p\n",&prev_local);
	    printf("      后局部变量:%p\n",&next_local);
	    printf("--------------------堆--------------------\n");
	    printf("        前堆变量:%p\n",prev_heap);
	    printf("        后堆变量:%p\n",next_heap);
	    printf("--------------------BSS--------------------\n");
	    printf("未初始化全局变量:%p\n",&uninit_global);
	    printf("未初始化静态变量:%p\n",&uninit_static);
	    printf("----------------数据------------------------\n");
	    printf("  初始化全局变量:%p\n",&init_static);
	    printf("  初始化全局变量:%p\n",&init_global);
	    printf("----------------代码区----------------------\n");
	    printf("     常静态变量:%p\n",&const_static);
	    printf("     字面值常量:%p\n",&literal);
	    printf("     常全局变量:%p\n",&const_global);
	    printf("           函数:%p\n",main);
	    return 0;
	}
### (2)从上面可以看出c/c++的内存分配方式主要有三种

#### a.从静态存储区域分配:
   内存在程序编译时已经分配好,这块内存在程序的整个运行期间都存在.速度快,不容易出错.因为由系统会善后.

#### b.在栈上分配内存:
   在执行函数的时候,函数内非静态局部变量的存储单元都是在栈上创建,函数执行结束的时候这些存储单元自动被释放.栈内存分配内置于处理器的指令集中,效率很高但是分配的内容有限.

#### c.从堆中分配内存:
即是动态分配内存.程序在运行的时候使用malloc/new申请任意大小的内存,程序员自己负责在何时用free/delete释放内存.动态内存的生存期由程序员决定,使用非常的灵活.如果在堆上分配了内存,就有责任去回收它,否则运行程序会出现内存泄漏,另外频繁的分配和释放不同大小的堆空间将会产生堆内碎片.不易管理;
### (3)堆和栈之间的主要的区别是什么?

#### a.管理方式不同:
栈是由编译器自动分配和释放,使用方便;而对于堆来说,分配和释放都必须由程序员来手动完成,不易管理,容易造成内存泄漏和内存碎片.

#### b.可用内存空间不同:
对于栈来说,它可用的内存空间比较小;而对于堆来说它可以使用的空间比栈要大的多.

#### c.能否产生碎片不同:
由于栈采用的是后进先出的机制,所以栈空间没有内存碎片的产生;而对于堆来说,由于频繁的使用new/delete势必会造成内存空间分配的不连续,从而造成大量的碎片,使程序的效率降低.

#### d.生长方向不同: 
对于堆来说,它一般是向上的;即是向着地址增加的方向增长;对于栈来说,它一般是向下的,即向着地址减小的方向增长.

#### e.分配的方式不同:
对于堆来说,它只能是动态分配的;而对于栈来说,它分为静态分配和动态分配;静态分配由编译器来进行管理,而动态分配的栈和堆也是不一样的,动态分配的栈由编译器进行释放,无需我们程序员来释放.

#### f.分配的效率不同:
栈是机器系统提供的数据结构,计算机会在底层对栈提供支持:为栈分配专门的寄存器.压栈和出栈都由专门的指令进行.因此它的效率会很高;而堆则是由c/c++库函数实现的,机制是非常的负责的;例如要分配一块内存的时候,库函数会利用特定的算法在堆内存中搜索可用大小的内存空间;如果没有足够大的内存空间,就会调用系统功能去增加数据段的内存空间.这样才能得到足够大的可用的内存空间,因此堆内存的分配的效率比栈要低得多. 

### (4)new/malloc以及free/delete之间的区别
#### a.运算符和库函数的区别
new/delete是运算符,只能在C++中使用,它可以重载;mallloc/free是C的标准库函数,在C/C++中都可以使用.

#### b.
对于非内部的数据类型的对象而言,光用malloc/free是无法满足动态对象的要求的.对象在创建的时候需要执行构造函数,对象在消亡之前需要执行析构函数.而molloc/free是库函数而不是运算符,不在编译器的控制范围之内,编译器不能将执行构造函数和析构函数的任务强加给malloc/free.因此C++需要一个能够完成动态分配内存和初始化的new,以及一个能够完成清理和释放内存的运算符delete.

#### c.
new的返回值是指定类型的指针,可以自动的计算所需要分配的内存大小.而malloc的返回值是一个void类型的指针,我们在使用的时候要进行强制类型转换,并且分配的大小也要程序员手动的计算.

#### d.
new/delete完全覆盖了malloc/free的功能,只所以还要保留malloc/free,是因为我们的C++程序有时要调用用C编写的而C中又没有new/delete,只能使用malloc/free.

## 3.指针和引用之间的区别和联系
### 联系:

#### a.
指针和引用本质上都是地址的概念,引用在内部其实是用const指针来实现的.

#### b.
给函数传递参数的时候,一级指针和引用作为函数参数的时候可以达到相同的效果.

#### c.
指针的大部分效果都可以通过引用来实现。

#### d.
二级指针作为参数的时候就是希望在函数的内部修改指针的指向.这个时候利用指针的引用可以达到同样的效果.

### 区别:

#### a.
定义引用的时候必须初始化,定义指针的时候可以不初始化.

#### b.
引用不能引用空,但是指针可以指向空.

#### c.
引用的关系一旦确定,就无法改变;引用永远指向的是用来对它初始化的对象;而非常属性的指针是可以改变指向的.

#### d.
指针是一个实体变量,在32位操作系统上面都是4个字节.而引用只是一个别名,其大小和其应用的对象的类型有关系.

#### e.
有指向指针的指针,但是没有引用引用的引用;因为引用一旦建立,它就表示初始化它的对象.

#### f.
有引用指针的引用,但是没有指向引用的指针；

#### g.
有指针数组,但是没有引用数组,但是有数组的引用.
下面是一段代码非常的全面:

	#include <iostream>
	using namespace std;
	void foo(int a[3])/*这个地方传递的是数组的首地址*/
	{
	     cout << sizeof(a)/sizeof(a[0]) << endl;
	}
	void bar(int (&a)[3])/*这里传参的时候就是数组的整体*/
	{
	     cout << sizeof(a)/sizeof(a[0]) << endl;
	}
	int main(void)
	{
	     int a;
	     int* p = &a;
	     int** pp = &p;/*存在指向指针的指针*/
	     int& r  = a;
	     int&& rr = r;/*error没有引用引用的引用*/
	     int*&  rp = p; /*有引用指针的引用(指针引用)*/
	     int&* pr = &r; /*没有指向引用的指针(引用指针)*/
	     int x, y, z;
	     int* pa[] = {&x,&y,&z};/*指针数组*/
	     int& ra[] = {x,y,z};/*引用数组是不存在的因为引用不是一个实体*/
	     int arr[3] = {0};
	     int (&ar)[3] = arr;/*数组引用(先近后远,先右后左)*/
	     foo(arr);/*这里传递的是数组的第一个元素的首地址*/
	     cout << sizeof(arr)/sizeof(arr[0]) << endl;
	     /*这里的数组名代表的是真个数组*/
	     int (*parr)[3] = &arr;/*对数组名取地址得到的是一个数组指针
	                             这个时候arr代表的是数组的整体;*/
	     bar(arr);/*这里传递的就是数组的整体*/
	     return 0;
	}
## 4.类和结构体的区别

结构体在默认情况下的成员都是public的,而类在默认情况下的成员是private的。

结构体和类都必须使用new创建，struct保证成员按照声明顺序在内存在存储，而类不保证。

C++结构体的继承默认是public，而c++类的继承默认是private。

## 5.C++和C定义结构体区别

C++中的结构和类其实具备几乎一样的功能，结构体内也是可以声明函数，C++的结构体和类默认具有不一样的访问属性

## 6.const常量与define宏定义的区别
### (1) 编译器处理方式不同。
define宏是在预处理阶段展开，生命周期止于编译期。只是一个常数、一个命令中的参数，没有实际的存在。#define常量存在于程序的代码段。const常量是编译运行阶段使用，const常量存在于程序的数据段.
### (2)类型和安全检查不同。
define宏没有类型，不做任何类型检查，仅仅是展开。const常量有具体的类型，在编译阶段会执行类型检查。
### (3)存储方式不同。
define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。const常量会在内存中分配(可以是堆中也可以是栈中)

## 7.memset ,memcpy 和strcpy 的根本区别

memset用来对一段内存空间全部设置为某个字符，一般用在对定义的字符串进行初始化为' '或''；


它对较大的结构体或数组进行清零操作的一种最快方法。

	char temp[30];     memset(temp,'\0',sizeof(temp));


char temp[30]只是分配了一定的内存空间给该字符数组，但并未初始化该内存空间，即数组。所以，需要使用memset()来进行初始化。


memcpy用来做内存拷贝，你可以拿它拷贝任何数据类型的对象，可以指定拷贝的数据长度；


strcpy就只能拷贝字符串了，它遇到'\0'就结束拷贝；例如：
	char a[100],b[50];strcpy(a,b);


## 8.虚函数和纯虚函数的区别

定义为虚函数是为了允许用基类的指针来调用子类的这个函数。
定义一个函数为纯虚函数，才代表函数没有被实现。

**C++纯虚函数**
### 一、定义
　纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”

	　virtual void funtion1()=0
### 二、引入原因
1、为了方便使用多态特性
我们常常需要在基类中定义虚拟函数。

2、在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。

为了解决上述问题，引入了纯虚函数的概念，**将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;）**，则编译器要求在派生类中必须予以重写以实现多态性。**同时含有纯虚拟函数的类称为抽象类，它不能生成对象。**这样就很好地解决了上述两个问题。
声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。
纯虚函数最显著的特征是：它们必须在继承类中重新声明函数（不要后面的＝0，否则该派生类也不能实例化），而且它们在抽象类中往往没有定义。
定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。

纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。

### 抽象类的介绍
抽象类是一种特殊的类，它是为了抽象和设计的目的为建立的，它处于继承层次结构的较上层。
（1）抽象类的定义：  称带有纯虚函数的类为抽象类。

（2）抽象类的作用：
抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。所以派生类实际上刻画了一组子类的操作接口的通用语义，这些语义也传给子类，子类可以具体实现这些语义，也可以再将这些语义传给自己的子类。

（3）使用抽象类时注意：
•   抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。
•   抽象类是不能定义对象的。

### 总结：
1、**纯虚函数声明如下： virtual void funtion1()=0;** 纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。

2、虚函数声明如下：virtual ReturnType FunctionName(Parameter)；虚函数必须实现，如果不实现，编译器将报错，错误提示为：
error LNK****: unresolved external symbol "public: virtual void __thiscall ClassName::virtualFunctionName(void)"

3、对于虚函数来说，父类和子类都有各自的版本。由多态方式调用的时候动态绑定。

4、实现了纯虚函数的子类，该纯虚函数在子类中就编程了虚函数，子类的子类即孙子类可以覆盖该虚函数，由多态方式调用的时候动态绑定。

5、虚函数是C++中用于实现多态(polymorphism)的机制。核心理念就是通过基类访问派生类定义的函数。

6、在有动态分配堆上内存的时候，析构函数必须是虚函数，但没有必要是纯虚的。

7、友元不是成员函数，只有成员函数才可以是虚拟的，因此友元不能是虚拟函数。但可以通过让友元函数调用虚拟成员函数来解决友元的虚拟问题。

8、析构函数应当是虚函数，将调用相应对象类型的析构函数，因此，如果指针指向的是子类对象，将调用子类的析构函数，然后自动调用基类的析构函数。

有纯虚函数的类是抽象类，不能生成对象，只能派生。他派生的类的纯虚函数没有被改写，那么，它的派生类还是个抽象类。
定义纯虚函数就是为了让基类不可实例化化
因为实例化这样的抽象数据结构本身并没有意义。
或者给出实现也没有意义

实际上我个人认为纯虚函数的引入，是出于两个目的
1、为了安全，因为避免任何需要明确但是因为不小心而导致的未知的结果，提醒子类去做应做的实现。
2、为了效率，不是程序执行的效率，而是为了编码的效率。