title: 324. 摆动排序 II

date: 2020-8-24 16:40:12

categories: 2020年8月

tags: [Leetcode,Sort]

---

给定一个无序的数组 nums，将它重新排列成 nums[0] < nums[1] > nums[2] < nums[3]... 的顺序。

<!-- more -->


示例 1:

    输入: nums = [1, 5, 1, 1, 6, 4]
    输出: 一个可能的答案是 [1, 4, 1, 5, 1, 6]
示例 2:

    输入: nums = [1, 3, 2, 2, 3, 1]
    输出: 一个可能的答案是 [2, 3, 1, 3, 1, 2]
说明:
你可以假设所有输入都会得到有效的结果。

进阶:
你能用 O(n) 时间复杂度和 / 或原地 O(1) 额外空间来实现吗？

这道题比较简单,主要说一下思想:         
## 有一个数组[a1,a2,...,an]，我们怎么把它排成摇摆序列呢？

由摇摆序列的定义:`nums[0] < nums[1] > nums[2] < nums[3]...`，我们知道了可以分成较大一部分的数和较小一部分数，然后互相穿插即可。比如一个数组排序后为：`A=[a1,a2,...,an]` `(a1<=a2<=....<=an)`，然后分成较小和较大的两部分`[a1,a2,...,a(n/2)]`，`[a(n/2+1),...,an]`（数组长度为奇数时不影响），再进行穿插操作。

## 那是不是穿插成[a1,a(n/2+1),a2,a(n/2+2),...,an]就行了呢？

其实不对，可以验证特殊情况：n比较小时且为偶数时，穿插后的序列需要满足`a(n/2+1)>a2`，如果`a1<a2<=a(n/2+1)<an`，`a(n/2+1)`正好是`a2`的后一项且与`a2`相等呢？即如果是`[4,5,5,6]`的情况呢？
那就分成了`[4,5]`，`[5,6]`两部分，之后穿插成的是`[4,5,5,6]`并不是摇摆序列。

## 应该怎样排列呢？

1. 把较小和较大的两部分`[a1,a2,...,a(n/2)]`，`[a(n/2+1),...,an]`翻转成`[a(n/2),...,a1]`，`[an,...,a(n/2+1)]`
2. 排列成`B=[a(n/2),a(n),a(n/2-1),a(n-1),...,a1,a(n/2+1)]`即可。

这样相邻两个数一定不存在相等的情况，而且满足摇摆序列的要求。
* `n=1`时显然正确
* `n=2或n=3`时也显然正确。
* `n>=4时`：
   1. 首先，判断相邻的情况，如果B中现在相邻两数在原来的有序序列A也相邻，此时令`n-n/2=1， (n-1)-(n/2-1)=1，...`都解得`n=2`，意思是`n=2`是他们的公共解，而`n>=4`时，`n-n/2， (n-1)-(n/2-1)`等于`n/2>=2`，说明B中相邻两数一定在原来的有序序列A中不相邻；
   
   2. 有人会说也存在原本(在A中)不相邻但是相等的情况，即几个数连续相等，但其中两个相等的数并不相邻，比如`aq=a(q+1)=a(q+2)`，`aq=a(q+2)`相等但是不相邻，但是我们知道如果`a(n/2-k)=a(n-k)`即不相邻相等，那么由于他们中间的所有数都要相等，而且与这两个数相等才能保证不相邻相等：即`a(n/2-k)=a(n/2-k+1)=a(n/2-k+2)=...=a(n-k-2)=a(n-k-1)=a(n-k)`，一共`n/2+1`个数相等。
   
   3. 而不相邻相等这种情况是不行的：虽然只有`a(n/2-k),a(n-k)`（在B中相邻）在原序列A中不相邻相等，但也违背了摇摆序列的定义，所以这道题有一个隐藏的条件：输入序列在排序后最多只有序列长度一半(`n/2`)的相邻的数连续相等。
* 在这个条件下：这道题按此排列就没问题。大家可以用🖊验证一下。

代码如下:
<details>
    <summary>Java</summary>
    
```Java []
class Solution {
    
    /**
     * 先排序再穿插
     * O(nlogn)+O(n)=O(nlogn)
     * @param nums
     */
    Arrays.sort(nums);
    int len = nums.length;
    int smalllen = (len % 2 == 0) ? len / 2 : (len / 2 + 1);
    int[] smaller = new int[smalllen], bigger = new int[len / 2];
    System.arraycopy(nums, 0, smaller, 0, smaller.length);
    System.arraycopy(nums,smaller.length,bigger,0,bigger.length);
    for (int i = 0; i < len/2; i++) {
        nums[2 * i] = smaller[smaller.length - 1 - i];
        nums[2 * i + 1] = bigger[bigger.length-i-1];
    }
    if (len % 2 != 0) {
        nums[len - 1] = smaller[0];
    }
    }
}
```
</details>