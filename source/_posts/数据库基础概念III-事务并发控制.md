title: 数据库基础概念III-事务并发控制

date: 2020-6-12 23:12:12

categories: 2020年6月

tags: [Database,MySQL]

---

数据库事务的并发控制


<!-- more -->


# 数据库四大特性ACID

 ACID，是指在可靠数据库管理系统（DBMS）中，事务(transaction)所应该具有的四个特性：
 
 原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）.
 
 这是可靠数据库所应具备的几个特性

##  原子性（Atomicity）
原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 

## 一致性（Consistency）
事务必须使数据库从一个一致性状态变换到另外一个一致性状态。

## 隔离性（Isolation）
事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。

## 持久性（Durability）
持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。

# 脏读、幻读、不可重复读[^1]
如果没有隔离或者隔离级别不足，会带来的问题[^2]：
    
    脏写（Dirty Write）
    脏读（Dirty Read）
    不可重复读（Unrepeatable Read）
    幻读（Phantom）
    读偏差（Read Skew）
    写偏差（Write Skew）
    丢失更新（Lost Updates）

## 脏读（Dirty Read）：

一个事务还未提交，另外一个事务访问此事务修改的数据，并使用，读取了事务中间状态数据。
## 幻读（Phantom Reads）：

一个事务读取2次，得到的记录条数不一致，由于2次读取之间另外一个事务对数据进行了增删。
## 不可重复读（Unrepeatable Read）：

一个事务读取同一条记录2次，得到的结果不一致，由于在2次读取之间另外一个事务对此行数据进行了修改。

## 丢失更新（Lost Updates）[^3]：

两个事务都同时更新一行数据，但是第二个事务却中途失败退出，
导致对数据的两个修改都失效了。

在事务的隔离级别内容中，能够了解到两个不同的事务在并发的时候可能会发生数据的影响。细心的话可以发现事务隔离级别章节中，脏读、不可重复读、幻读三个问题都是由事务A对数据进行修改、增加，事务B总是在做读操作。如果两事务都在对数据进行修改则会导致另外的问题：丢失更新。

1. 丢失更新的定义及产生原因。

第一类丢失更新(回滚丢失，Lostupdate)（通过设置隔离级别可以防止 Repeatable Read）

A事务撤销时，把已经提交的B事务的更新数据覆盖了。

2. 第二类丢失更新(覆盖丢失/两次更新问题，Second lost update)

A事务覆盖B事务已经提交的数据，造成B事务所做操作丢失

第二类丢失更新，实际上和不可重复读是同一种问题

## 解决方法
设置不同的事务隔离级别：

### 未授权读取

也称为读未提交（Read Uncommitted）：允许脏读取，但不允许更新丢失。如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现。

### 授权读取

也称为读提交（Read Committed）：允许不可重复读取，但不允许脏读取。这可以通过“瞬间共享读锁”和“排他写锁”实现。读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。

### 可重复读取（Repeatable Read）

可重复读取（Repeatable Read）：禁止不可重复读取和脏读取，但是有时可能出现幻读数据。这可以通过“共享读锁”和“排他写锁”实现。读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。

### 序列化（Serializable）

序列化（Serializable）：提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。

隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed。它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读和第二类丢失更新这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。


# 数据库事务的并发控制[^4]

## 调度(schedule)
事务在并发执行时，各个事务中的不同指令的先后执行顺序称为调度。比如事务T1由两条指令a和b组成，事务T2由c和d组成。那么，这两个事务在并发执行时abcd、acbd等的这些执行顺序都称之为调度。

## 串行的(serial)
如果在一个调度中，属于同一个事务的指令紧挨在一起，我们就称这个调度是串行的。上面的例子中，T1和T2的串行调度有两种，分别是abcd和cdab。对于n个事务组成的事务组，共有n!个不同的串行调度。

## 可串行化的(serializable)
如果一个调度等价于一个串行调度，那么就称该调度是可串行化的。显然，串行调度是可串行化的。

# 调度的可串行化
## 串行化与冲突可串行化

串行调度是可串行化的，但是，如果许多事务的指令交错执行，则很难确定一个调度是否是可串行化的。事务就是程序，要确定一个事务有哪些操作，多个事务的不同操作如何相互作用，是非常困难的。

因此，这里我们不会考虑一个事务可以对一个数据项执行的所有不同类型的操作，而只考虑两种操作：read和write。

我们假设，在数据Q上的read(Q)和write(Q)之间，事务可以对驻留在事务局部缓冲区中Q的拷贝执行任意操作序列。按这种模式，从调度的角度来说，事务唯一重要的操作就是read和write。

假设I和J是不同事务在相同数据项上的操作，那么当它们全是read时，它们的次序无关紧要。但是，当其中至少有一个write时，它们的顺序将直接影响最终事务的执行结果，这时我们说I和J是冲突(conflict)的。

如果调度S经过一系列非冲突指令次序交换转换成S'，我们称S和S'是 **冲突等价(conflict equivalent)** 的。

可以理解，不是所有的串行调度之间都是冲突等价的。

如果一个调度与串行调度冲突等价，则称该调度是 **冲突可串行化(conflict serializable)** 的。

## 冲突可串行化(conflict serializable)的判定
这里给出一个简单有效的方法，来确定一个调度是否冲突可串行化。

假设S是一个调度，我们由S构造一个有向图，称为优先图(precedence graph)。该图由定义为G=(V,E)，其中V是顶点集，E是边集，顶点集由所有参与调度的事务组成。如果事务Ti和Tj满足下列三个条件之一，优先图中就存在边Ti->Tj：
    
    1. 在Tj执行read(Q)之前，Ti执行write(Q)。
    2. 在Tj执行write(Q)之前，Ti执行read(Q)。
    3. 在Tj执行write(Q)之前，Ti执行write(Q)。


这里的意思是，事务中冲突的操作决定了事务的执行顺序。所以，如果优先图中存在边Ti->Tj，则在任何等价于S的串行调度S’中，Ti必出现在Tj之前。

这样，如果调度S的优先图中有环，则调度S是非冲突可串行化的，如果优先图中无环，则调度S是冲突可串行化的。

串行化顺序(serializability order)可通过拓扑排序(topological
sorting，用于计算与优先图的偏序相一致的线形顺序)得到。一般而言，通过拓扑排序可以获得多个线形顺序。

因此，要判断冲突可串行化，需要构造优先图并调用一个环检测算法。基于深度优先的环检测算法需要n^2数量级的运算，其中n是优先图中的定点数(即事务数)。

## 冲突等价的局限性
有可能存在两个调度，它们产生的结果相同，但它们不是冲突等价的。

调度等价的定义实际上是比冲突等价更为宽松，也就是说存在不是冲突等价的两个等价调度。

对于计算机来说，要判定调度S与串行调度<T1,T2>产生的结果相同，必须分析T1和T2所进行的计算，而不只是分析read和write操作。

由于从数学的角度，递增和递减是可以交换的，导致两个调度等价。

实际中，一个事务可能会表示为一条复杂的SQL语句，或一个有JDBC调用的Java程序等，这种判定的计算代价很大。

除此之外，也存在一些别的纯粹基于read和write操作的调度等价定义，比如视图等价，其中有视图可串行化的概念。这里暂且不做介绍。
 

# 两阶段锁（Two-phase locking，2PL）[^5]

注意两阶段锁（Two-phase locking，2PL）需要和两阶段提交（Two-phase commit）区别开来。

两阶段锁（Two-phase locking，2PL）主要用于单机事务中的一致性与隔离性；而两阶段提交（Two-phase commit）主要用于分布式事务。

## 什么是两阶段加锁（Two-phase locking，2PL）
在一个事务中，分为加锁阶段（也称为增长阶段，expanding phase）和解锁阶段（也称为缩减阶段，shrinking phase）。

加锁阶段：所有该事务中涉及的锁都会在这个阶段被获取，且在这个阶段没有锁被释放；


解锁阶段：所有该事务中涉及的锁都会在这个阶段被释放，且在这个阶段没有锁被获；

这意味着，不管同一个事务内需要在多少个数据项上加锁，所有的加锁操作都只能在加锁阶段（增长阶段）完成。在这个阶段内，不允许对已经加锁的数据项进行解锁操作。

同时，在加锁完成后，也只能在解锁阶段（缩减阶段）对所有数据项进行解锁。当解锁阶段结束后，所有持有的锁都已经被释放。

对于任何一个数据项而言，分为两种锁：

排他锁 / 写锁（Exclusive lock，X）：此时数据项既可以被读取也可以被写入（增加、修改和删除）；

共享锁 / 读锁（Shared lock，S）：此时数据项只能被读取。

这两种锁需要遵循下面的规则：

一个事务对某个数据项的写锁会阻塞另一个事务对该数据项的写锁；

一个事务对某个数据项的写锁会阻塞另一个事务对该数据项的读锁；

一个事务对某个数据项的读锁会阻塞另一个事务对该数据项的写锁；

一个事务对某个数据项的读锁不会阻塞另一个事务对该数据项的读锁；
    
    Lock type	read-lock	write-lock
    read-lock	            	X
    write-lock  	X	        X

## 为什么需要两阶段加锁
两阶段加锁是一种并发控制（Concurrency Control）的一种手段，除此之外，也可以通过多版本并发控制（Multiversion Concurrency Control）实现。

引入两阶段加锁是为了在保证事务的隔离性（即多个事务在并发的情况下等同于串行的执行）去前提下，尽可能的提高事务的并发度。

为了提高并发度，才对锁进行分类，分出共享锁（读锁）和排它锁（写锁），因这两种类型的锁，又产生加两种锁共四种事务之间受影响的情况：

## 严格的两阶段锁（Strict two-phase locking）

在实际情况下，SQL 是千变万化、条数不定的，数据库很难在事务中判定什么是加锁阶段，什么是解锁阶段。于是引入了 Strict-2PL（S2PL）即：在事务中只有提交（commit）或者回滚（rollback）时才是解锁阶段，其余时间为加锁阶段。


# MySQL 查询优化[^6][^7]

## Simple Nested-Loop Join （简单嵌套循环连接）


## Index Nested-Loop Join（索引嵌套循环连接）


## Block Nested-Loop Join（缓存块嵌套循环连接）




[^1]:http://www.jiujichaoshi.com/2016/06/06/transaction-feature/

[^2]:https://juejin.im/post/5d8abc2d518825095e3d628e

[^3]:https://blog.csdn.net/u014590757/article/details/79612858

[^4]:https://www.jianshu.com/p/478c6dca1b74

[^5]:https://swsmile.info/2019/02/21/%E3%80%90Database%E3%80%91%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81/

[^6]:https://zhuanlan.zhihu.com/p/54919968

[^7]:https://www.jianshu.com/p/47db8ac001ea

