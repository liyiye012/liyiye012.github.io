---
title: 405. 数字转化为十六进制数
date: 2020-4-29 16:12:12  
categories: 2020年4月
tags: [LeetCode, Bit Manipulation]

---

给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。

<!-- more -->

这道题看似简单但想符合所有情况还是很伤脑筋。
用了无符号右移和位运算后简化了很多。
首先要知道16进制数在计算机中是怎么表示的，
由于对于16进制一个有16个数（0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f）
所以我们只需要使用4位 2^4=16刚好可以表示16个数，
所以计算机在内部是用4位来表示16进制的0000表示0,0001表示1.....1111表示f.
所有题目给我们一个int型的数字num,一个int= 4字节 = 32位，
所以，这个32位数字可以被分隔成8个4位数，
所以我们只需要从头到尾每4位每4的的遍历，每遍历一个4位就将其转化为16进制的数即可
，有人可能会问为什么这样可以，其实这样我们是做了两个步骤，
先转化为2进制（由于计算机中所有东西本身就是2进制存储的，所以我们可以直接得到该数字的2进制），
再转化为16进制，比如对于26 ->二进制为‭00011010‬（前面省略了24个0）
所以每4位遍历就变成了0001,1010对于0001 对应16进制中的1,1010对应16进制中的a所以结果就是为1a.
所以对于此题我们只需要从尾部开始用位运算取出每一个4位，
再转化为16进制即可只需要注意前面为0的16进制应该删除即可。
我们首先需要设一个数字calc = 0xf也就是右边4位为1其余均为0
，此时我们把数字num与之进行与运算就可以取出，num右边4位的值，
然后再把calc向左边移动4位就变成了11110000(前面省略24个0)此时在与之相与就可以得到num中右边8位的值，
此时还需要把这个值向右移动4位，因为这样是的到了第2个4位值，然后再次重复此步骤即可。

# 解题思路：

java里面有 Integer.toHexString() 但是题目要求自己写 位运算，以4位为粒度进行取数,转化为16进制字符串


     /**
     * 如：35 == 0010 0011 = 23
     *
     * 注意：java中
     *      hex to int Integer.valueOf("12ff",16)
     *      int to hex Integer.toHexString(35)
     */
    ```
        public String toHex(int num) {
            char[] hex = "0123456789abcdef".toCharArray();
            String s = new String();
            while(num != 0){
                int end = num&15;
                s = hex[end] + s;
                //无符号右移
                num >>>=4;
            }
            if(s.length() == 0){
                s = "0";
            }

            return s;
        }
# 无符号右移运算符>>>

它的通用格式如下所示：

　　value >>> num

num 指定要移位值value 移动的位数。

无符号右移的规则只记住一点：忽略了符号位扩展，0补最高位

无符号右移规则和右移运算是一样的，只是填充时不管左边的数字是正是负都用0来填充，无符号右移运算只针对负数计算，因为对于正数来说这种运算没有意义
无符号右移运算符>>> 只是对32位和64位的值有意义
