---
title: 684.冗余链接
date: 2020-05-19 10:26:12
categories: 2020年5月
tags: [LeetCode,Union Find,Tree,Graph]

---

使用并查集找到一条可以删去的边。

<!-- more -->

# 并查集
在计算机科学中，并查集是一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题。有一个联合-查找算法（Union-find Algorithm）定义了两个用于此数据结构的操作：

Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。
Union：将两个子集合并成同一个集合。

由于支持这两种操作，一个不相交集也常被称为联合-查找数据结构（Union-find Data Structure）或合并-查找集合（Merge-find Set）。
为了更加精确的定义这些方法，需要定义如何表示集合。一种常用的策略是为每个集合选定一个固定的元素，称为代表，以表示整个集合。接着，Find(x) 返回 x 所属集合的代表，而 Union 使用两个集合的代表作为参数。

# 问题描述
本问题中, 树指的是一个连通且无环的无向图。

输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。

结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u < v，表示连接顶点u 和v的无向图的边。

返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u < v。

示例 1：

输入: [[1,2], [1,3], [2,3]]
输出: [2,3]
解释: 给定的无向图为:
  1
 / \
2 - 3
示例 2：

输入: [[1,2], [2,3], [3,4], [1,4], [1,5]]
输出: [1,4]
解释: 给定的无向图为:
5 - 1 - 2
    |   |
    4 - 3

# 解法

##  方法一：DFS
**算法：**
对于每个边 `(u, v)`，用深度优先搜索遍历图，以查看是否可以将 `u` 连接到 `v`。如果可以，则它是重复边。

**复杂度分析**

* 时间复杂度：*O(N^2)*。其中 *N* 是图中的结点数（以及边数）。在最坏的情况下，对于我们包含的每一条边，我们必须搜索图中出现的每一条边。
* 空间复杂度：*O(N)*，图的当前构造最多有 *N* 个结点。


##  方法二：并查集
**算法：**
如果我们熟悉并查集（DSU）数据结构，我们可以直接使用它来解决这个问题：我们只需找到已经连接的图中出现的第一条边。本解释的其余部分将重点介绍实现 DSU 的细节。

一个 DSU 数据结构可以用来维护图形连接组件的数据，并快速查询它们。有两种操作：
- `dsu.find(node x)`，找到元素 `x` 所在的集合的代表，该操作也可以用于判断两个元素是否位于同一个集合。
- `dsu.union(node x, node y)`，把元素 `x` 和元素 `y` 所在的集合合并，要求 `x`和 `y` 所在的集合不相交，如果相交则不合并。

为了实现这一点，我们跟踪父结点，它会记录同一连接节点中较小结点的所在的集合。如果结点是它自己的父结点，我们将其称为连接结点的领导者。

DSU 结构的简单实现如下所示：
伪代码 ：
我们使用两种技术来提高运行时的复杂性：路径压缩和按秩合并。
- 路径压缩涉及将 `find` 函数中的 `x=parent[x]` 更改为`parent[x]=find(parent[x])`。
- 按秩合并涉及到将发现的工作量平均分配给领导者。每当 `dsu.union(x, y)` 时，我们都有两个领导者 `xr，yr`，并且我们要选择是要 `parent[x]=yr` 还是 `parent[y]=xr`。我们选择有更多子节点的领导者作为领导者。
-  具体地说，`rank` 的含义是 `x` 的跟随者少于 `2 ^ rank[x]`，这个策略可以作为 `dsu.find` 中的递归循环可中的界限。

**复杂度分析**

* 时间复杂度：![O(N\alpha(N))\approxO(N) ](./p__O_Nalpha_N___approx_O_N__.png) 。其中， *N* 是图中顶点的数目（以及边的数目），![\alpha ](./p__alpha_.png)  是 `Inverse-Ackermann` 函数。我们对 `dsu.union` 进行了多达 *N* 次查询，这需要花费 ![O(\alpha(N)) ](./p__O_alpha_N___.png)  时间。可以去查阅资料为什么 `dsu.union` 具有 ![O(\alpha(N)) ](./p__O_alpha_N___.png)  复杂性、`Inverse-Ackermann` 函数是什么以及为什么 ![O(\alpha(N)) ](./p__O_alpha_N___.png)  大约是 *O(1)* 的原因。
* 空间复杂度：*O(N)*，图的当前构造（嵌入在我们的 DSU 结构中）最多有 *N* 个结点。

# 并查集的实现

## 集合树：
所有节点以代表节点为父节点构成的多叉树

## 节点的代表节点：
可以理解为节点的父节点，从当前节点出发，可以向上找到的第一个节点

## 集合的代表节点：
可以理解为根节点，意味着该集合内所有节点向上走，最终都能到达的节点

体到这个题上：
我们以这个边集合为例子[[1,2], [3,4], [3,2], [1,4], [1,5]]

一、首先，对于边集合edges的每个元素，我们将其看作两个节点集合

比如边[2, 3],我们将其看作节点集合2，和节点集合3

二、在没有添加边的时候，各个节点集合独立，我们需要初始化各个节点集合的代表节点为其自身

所以，我们先初始化一个容器vector，使得vector[i]=i。

这里两个i意思不同，作为索引的i是指当前节点，作为值的i是指当前节点所在集合的代表节点。

比如vector[2] = 2，意味着2这个节点所在集合的代表节点就是2，没有添加边的情况下，所有节点单独成集合，自身就是代表节点

三、然后我们开始遍历边集合，将边转化为集合的关系

这里有一点很重要：边[a,b]意味着a所在集合可以和b所在集合合并。

合并方法很多，这里我们简单地将a集合的代表节点戳到b集合的代表节点上。
这意味着，将b集合代表节点作为合并后大集合的代表节点。

对于一个集合的代表节点s，一定有s->s，意思是s如果是代表节点，那么它本身不存在代表节点

假设我们的读取顺序为[[1,2], [3,4], [3,2], [1,4], [1,5]]

初始化vector[0, 1, 2, 3, 4, 5]

对应的index [0, 1, 2, 3, 4, 5]

##########################################################################

1.读取[1,2]：

读取顺序为[[1,2], [3,4], [3,2], [1,4], [1,5]]

当前vector[0, 1, 2, 3, 4, 5]

当前index [0, 1, 2, 3, 4, 5]

原本1->1，2->2，

由1节点出发，vector[1]=1, 找到1所在集合的代表节点1

由2节点出发，vector[2]=2, 找到2所在集合的代表节点2

于是，将1的代表置为2，vector[1]=2, vector[2]=2

对应的vector[0, 2, 2, 3, 4, 5]

对应的index [0, 1, 2, 3, 4, 5]

##########################################################################

2.读取[3, 4]

读取顺序为[[1,2], [3,4], [3,2], [1,4], [1,5]]

当前vector[0, 2, 2, 3, 4, 5]

当前index [0, 1, 2, 3, 4, 5]

同理，将3所在集合的的代表节点3的代表节点置为4

对应的vector[0, 2, 2, 4, 4, 5]

对应的index [0, 1, 2, 3, 4, 5]

##########################################################################
3.读取[3, 2]

读取顺序为[[1,2], [3,4], [3,2], [1,4], [1,5]]

当前vector[0, 1, 2, 4, 4, 5]

当前index [0, 1, 2, 3, 4, 5]

从节点3出发，vector[3]=4, vector[4]=4,于是找到节点3所在集合的代表节点为4

从节点2出发，vector[2]=2, 找到节点2所在集合的代表节点为2

于是，将4的代表置为2，vector[4]=2, vector[2]=2

对应的vector[0, 2, 2, 4, 2, 5]

对应的index [0, 1, 2, 3, 4, 5]

##########################################################################
4.读取[1, 4]

读取顺序为[[1,2], [3,4], [3,2], [1,4], [1,5]]

当前vector[0, 2, 2, 4, 2, 5]

当前index [0, 1, 2, 3, 4, 5]

从节点1出发，vector[1]=2, vector[2]=2, 找到节点1所在集合代表节点为2

从节点4出发，vector[4]=2, vector[2]=2, 找到节点4所在集合代表节点为2

由于1和4的代表节点相同，说明这两个节点本身就在同一个集合中

由于原图是无向图，路径是双向可达的，1能够到达2,而且2能够到达4，再加上1能够到达4

说明1能通过两条路径到达4，,这也意味着这条边出现的时候，原图中一定出现了环

至于题中要求的，返回最后一条边，其实这就是返回添加过后会构成环的那一条边
直白解释就是，在这条边出现之前，图中没有环

这条边出现，图中也出现环。包括这条边在内，构成环的边都是满足破圈条件的边
然而谁是最后一条出现在边集合里的？当然，就是这条构成环的最后一条边
##########################################################################

    class Solution {
    public:
        vector<int> findRedundantConnection(vector<vector<int>>& edges) {
            vector<int> rp(1001);
            int sz = edges.size();
            // 初始化各元素为单独的集合，代表节点就是其本身
            for(int i=0;i<sz;i++)
                rp[i] = i;
            for(int j=0;j<sz;j++){
                // 找到边上两个节点所在集合的代表节点
                int set1 = find(edges[j][0], rp);
                int set2 = find(edges[j][1], rp);
                if(set1 == set2)  // 两个集合代表节点相同，说明出现环，返回答案
                    return edges[j];
                else    // 两个集合独立，合并集合。将前一个集合代表节点戳到后一个集合代表节点上
                    rp[set1] = set2;
            }
            return {0, 0};
        }

        // 查找路径并返回代表节点，实际上就是给定当前节点，返回该节点所在集合的代表节点
        // 之前这里写的压缩路径，引起歧义，因为结果没更新到vector里，所以这里改成路径查找比较合适
        int find(int n, vector<int> &rp){
            int num = n;
            while(rp[num] != num)
                num = rp[num];
            return num;
        }
    };


# Java实现并查集

对于同一棵树的所有节点来说，都拥有共同的祖先节点。

因此，判断冗余连接的条件即为，判断新加入的边，两个节点是否有共同的祖先。

（1）如果有共同的祖先，则说明这条边是冗余的边；

（2）如果没有共同的祖先，则说明这两条边并未加入树中，因此进行合并操作。
循环边的记录，获取最后出现的冗余边，就是答案。

    public static class UnionFind {
        int[] parent;
        int[] rank;

        public UnionFind(int total) {
            parent = new int[total];
            rank = new int[total];

            for (int i = 0; i < total; i++) {
                parent[i] = i;
                rank[i] = 1;
            }
        }

        public int find(int x) {
            while (x != parent[x]) {
                parent[x] = parent[parent[x]];
                x = parent[x];
            }
            return x;
        }

        public void unionElements(int p, int q) {
            int pRoot = find(p);
            int qRoot = find(q);

            if (pRoot == qRoot) {
                return;
            }

            if (rank[pRoot] < rank[qRoot]) {
                parent[pRoot] = qRoot;
            } else if (rank[pRoot] > rank[qRoot]) {
                parent[qRoot] = pRoot;
            } else {
                parent[pRoot] = qRoot;
                rank[qRoot] += 1;
            }
        }
    }

    public int[] findRedundantConnection(int[][] edges) {
        int[] res = new int[2];
        UnionFind unionFind = new UnionFind(edges.length);

        // 第一条边肯定未记录至树中，可直接合并节点
        unionFind.unionElements(edges[0][0] - 1, edges[0][1] - 1);
        for (int i = 1; i < edges.length; i++) {
            if (unionFind.find(edges[i][0] - 1) == unionFind.find(edges[i][1] - 1)) {
                res[0] = edges[i][0];
                res[1] = edges[i][1];
            } else {
                unionFind.unionElements(edges[i][0] - 1, edges[i][1] - 1);
            }
        }
        return res;
    }

# Map实现并查集（Java）
逻辑很简单，对每一条边：
1、如果两个顶点在不同的树上，则合并两个树
2、如果两个顶点在相同的树上，那么他们一定构成了闭环

为了提升效率，getRoot(并查集中的find)方法中对树进行了压缩

    class Solution {
    public int[] findRedundantConnection(int[][] edges) {
        Map<Integer, Integer> cMap = new HashMap<>();
        for (int i = 0; i < edges.length; i++) {
            int pi0 = getRoot(cMap, edges[i][0]);
            int pi1 = getRoot(cMap, edges[i][1]);
            if(pi0 != pi1){
                cMap.put(pi0,pi1);
            } else {
                return edges[i];
            }
        }
        return null;
    }

    private int getRoot(Map<Integer, Integer> parents, int i){
        if(parents.get(i) == null){
            parents.put(i, i);
            return i;
        }
        if(parents.get(i) == i){
            return i;
        }
        return getRoot(parents,parents.get(i));
    }
    }


# 证明    ：给定一条新的边，两头节点在同一个集合，就意味着出现了环
#####################################################################
下面是增加的一部分证明，

证明一下为什么给定一条新的边，两头节点在同一个集合，就意味着出现了环

这里有个大前提，因为是无向图，集合里不会同时出现[1,2]和[2,1]这种重合边

上面的代码遇到集合里有重合边的情况是会出现误判的

就拿这个[1,2]和[2,1]来举例

给定[1,2]后，再读取[2,1]，两个节点在同一个集合，然而并没有出现环。

所以，这里代码工作的前提是不出现重合边
#####################################################################

下面回到最初的问题，为什么给定新边的两个节点在同一集合就意味着出现了环

假设给定新边的两个节点分别为5,6，新边为[5,6]

对于一条新出现的边，总共有两种情况，两个节点之一单独成集合，两个节点均不单独成集合

第一种情况，两个节点之一单独成集合

假设5单独成集合。这种情况下，两个节点不可能在一个集合里

因为有一个独立集合（只有节点5），6所在的集合和这个集合必然没有交集

之后这两个集合进行合并操作

直观点理解就是，5单独成集合，意味着5第一次出现在图里

这里只有新边和5相关，所以当前只给定一条和5相关的边，对5而言，就像只举起了一只手

要形成环，环上每个节点都必须是举起两只手的

所以这种情况下是不可能出现环的，程序中也是这样判定的

第二种情况，两个节点均不单独成集合

这里也可以细分为5和6是否作为该集合的代表节点

假设5所在集合代表节点为a

6所在集合代表节点也为a

2.1第一个分支，如果a不为5和6本身，那么就有5->...->a，6->...->a，路径双向可达

可以得到5->...->a->...->6,对于给定边[5,6]可得5->6

所以5到达6有两条路径，出现了环。

2.2第二个分支，a为5和6之一

假设，a为5

2.2.1 首先考虑，6直接指向5这种情况

出现这种情况，只能是在已经存在集合x->...->6时，出现[...,5]这样的边

其中，...为x->...->6路径上除6以外任意节点

此时...的代表节点为6，5的代表节点为5，合并，6戳到5上，于是出现了6直接指向5

这种情况下，已经存在6->...->5一条路径，再读取到[5,6]，环出现了

2.2.2 再考虑6不直接指向5的情况，就简单很多了，6->x->5

再读取到[5,6]，6可以通过两条路径到达5，出现环

综上，在边集合没有重合边的情况下，如果给定新边的两个节点在同一集合中，说明图中出现了环
# 参考资料：
【1】https://leetcode-cn.com/problems/redundant-connection/solution/tong-su-jiang-jie-bing-cha-ji-bang-zhu-xiao-bai-ku/

【2】https://leetcode-cn.com/problems/redundant-connection/solution/bing-cha-ji-jie-jue-rong-yu-lian-jie-i-by-jxd134/

【3】https://leetcode-cn.com/problems/redundant-connection/solution/bing-cha-ji-mapshi-xian-de-ling-lei-bing-cha-ji-by/
