---
title: 操作系统面试高频题
date: 2018-9-21 17:12:13  
categories: 2018年9月
tags: [Operating System]

---
 

整理一下互联网公司操作系统面试高频题

<!-- more -->

## （1） 进程与线程的区别和联系

进程是具有一定功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源调度和分配的一个独立单位。
线程是进程的实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。
一个进程可以有多个线程，多个线程也可以并发执行
如果你对进程或者线程不太熟悉，建议阅读：[进程与线程的一个简单解释](https://link.zhihu.com/?target=http%3A//www.ruanyifeng.com/blog/2013/04/processes_and_threads.html)

## （2） 一个进程可以创建多少线程，和什么有关
## （3） 一个程序从开始运行到结束的完整过程（四个过程）
源程序到可执行程序的过程。在这个过程中，会发生如下的变化：



.c文件生成.obj文件的过程，称为编译，.obj文件生成到.exe文件的过程，称为链接。
.obj文件就是一个是程序编译生成的二进制文件，当.exe文件生成以后.obj文件就会被删除。
事实上，.c文件生成.exe文件的过程总共是经历了预处理，编译，汇编，链接，这四个过程。

1、预处理
为了接下来能够解释的更加清楚，使用linux平台下的gcc编译器解释。
先书写一个非常简单的程序来介绍：

	1 #include<stdio.h>
	2
	3 int main()
	4 {
	5     printf("hello");
	6
	7     return 0;
	8 }

直接编译得到：

第一步发生的是预编译，使用-E指令会使程序只进行到预编译指令。经过预编译指令后的会生成一个.i文件。

在预编译的过程中，主要处理源代码中的预处理指令，引入头文件，去除注释，处理所有的条件编译指令，宏的替换，添加行号，保留所有的编译器指令。

当进行预编译以后的文件中将不再存在宏，所有的宏都已经被替代。当想要判断宏是否正确或者头文件包含是否正确时，也可以通过预编译来查看。

2、编译

在预处理结束后，进行的是编译。编译过程所进行的是对预处理后的文件进行语法分析，词法分析，语义分析，符号汇总，然后生成汇编代码。

3、汇编

汇编过程将汇编代码转成二进制文件，二进制文件就可以让机器来读取。每一条汇编语句都会产生一句机器语言。

在这里最终会生成一个重定位目标文件 .o文件，类似windows下的.obj文件。这里生成的目标文件里面就是二进制文件。另外，在这里会形成符号表，给这些符号会分配虚拟地址。

4、链接

由汇编程序生成的目标文件并不能立即就被执行，其中可能还有许多没有解决的问题。例如，某个源文件中的函数可能引用了另一个源文件中定义的某个符号（如变量或者函数调用等）；在程序中可能调用了某个库文件中的函数等等。所有这些问题，都需要经链接程序的处理方能得以解决。链接程序的主要工作就是将有关的目标文件彼此相连接，也即将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体。

链接分为静态链接和动态链接：

静态链接：后缀是.a，主要在编译的时候将库文件里面代码搬迁到可执行的文件中；

动态链接：后缀是.so,主要在执行的时候需要转换到库文件代码执行；

两种链接的优缺点：

（1）静态的链接产生的可执行的文件体积比较的大；而动态链接的可执行文件的体积比较小；

（2）动态的链接的编译的效率比较的高；

（3）静态链接的可执行的文件执行的效率高

（4）静态链接的可执行的文件的“布局”比较好一点；

## （4） 进程通信方法（Linux和windows下），线程通信方法（Linux和windows下）

主要分为：管道、系统IPC（包括消息队列、信号量、共享存储）、SOCKET

管道主要分为：普通管道PIPE 、流管道（s_pipe）、命名管道（name_pipe）

管道是一种半双工的通信方式，数据只能单项流动，并且只能在具有亲缘关系的进程间流动，进程的亲缘关系通常是父子进程
命名管道也是半双工的通信方式，它允许无亲缘关系的进程间进行通信
信号量是一个计数器，用来控制多个进程对资源的访问，它通常作为一种锁机制。
消息队列是消息的链表，存放在内核中并由消息队列标识符标识。
信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
共享内存就是映射一段能被其它进程访问的内存，这段共享内存由一个进程创建，但是多个进程可以访问。
如果你对进程的通信方式不太熟悉，建议阅读： [进程间的几种通信方式](https://blog.csdn.net/yufaw/article/details/7409596)


## （5） 进程调度方法详细介绍
## （6） 页面置换方法详细介绍

## （7） 能否实现一个LRU算法
## （8） 死锁的必要条件（怎么检测死锁，解决死锁问题）

在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲就是两个或多个进程无限期的阻塞、相互等待的一种状态。

死锁产生的四个条件（有一个条件不成立，则不会产生死锁）

互斥条件：一个资源一次只能被一个进程使用
请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放
不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺
循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系
如果对死锁还不是太熟悉，建议阅读：[死锁产生的原因和解锁的方法](http://www.cnblogs.com/Jessy/p/3540724.html)


## （9） 哲学家就餐，银行家，读者写者，生产者消费者（怎么加锁解锁，伪代码）
## （10） 海量数据的bitmap使用原理
## （11） 布隆过滤器原理与优点
## （12） 布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题
## （13） 同步IO和异步IO
## （14） 文件读写使用的系统调用
## （15） 线程池的了解、优点、调度处理方式和保护任务队列的方式
## （16） 怎么回收线程
## （17） 僵尸进程问题
## （18） 多线程同步（尤其是如果项目中用到了多线程，很大可能会结合讨论）
## （19） memcache了解
## （20） 异常和中断的区别
## （21） 一般情况下在Linux/windows平台下栈空间的大小
