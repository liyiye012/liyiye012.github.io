title: 数据结构与数据库学习笔记

date: 2020-8-27 11:12:12

categories: 2020年8月

tags: [Database,Data Structure]

---

数据结构与数据库课程学习笔记

<!-- more -->

## 数据库部分（30分）
1. 关系型数据库系统是以满足一定条件的二维表为数据模型的数据库系统
2. 关系代数是以集合操作为基础的运算
3. 五种基本运算是并、交、差、投影和选择,都可由这些运算导出。
4. 关系中，关键字是指能唯一标识元组的那个属性
5. 关系中与元组有关的正确表述是在关系中的各元组的顺序可以任意排列。不能有完全相同的元组
6. 设有关系模式R（工号，姓名，工种，工时定额）根据语意，存在下列函数依赖关系：工号-》姓名；工号-》工种；工号-》工时定额；工种-》工时定额；请将其分解为满足3NF的关系模式。R1（工号，姓名，工种）码为工号， R2（工种，工时定额）码为工种

这题太麻烦了，最后做吧
第三范式(Third Normal Form,3rd NF)

就是指表中的所有数据元素不但要能唯一地被主关键字所标识,而且它们之间还必须相互独立,不存在其他的函数关系。[^2]

1）最小依赖集求法：

右侧先拆单，依赖依次删。
还原即可删，再拆左非单。

工号-》姓名；工号-》工种；工号-》工时定额；工种-》工时定额；

去掉工号-》工时定额；因为可以由工号-》工种和工种-》工时定额得到。

剩下
工号-》姓名；工号-》工种；工种-》工时定额；

2）3NF分解：

口诀：

保函依赖分解题，先求最小依赖集。

依赖两侧未出现，分成子集放一边，剩余依赖变子集。

若要连接成无损，再添候选做子集。

{工号,姓名},{工号,工种},{工种,工时定额}

7. 设R和S是两个关系，

R

A | B  | X 
---|---|---
a | b | 3 
b | c | 6 
c | b | 2

S


A | B  | Y
---|---|---
a | b | 5
b | c | 2
b | c | 4

分别写出
σR.B=S.B(R X S) 和R⋈S的运算结果

σR.B=S.B(R X S)=


A | B  | X | Y
---|---|---|---
a | b | 3 | 5
b | c | 6 | 2
b | c | 6 | 4
c | b | 2 | 5

R⋈S=

A | B  | X | Y
---|---|---|---
a | b | 3 | 5
b | c | 6 | 2


8. 已知关系模式如下：

供应者关系模式： S(Sno,Sname,City), 供应者代号Sno为关键字

零件关系模式： P(Pno,Pname,Color,Wight,City), 零件代号Pno为关键字

供应关系模式：SP(Sno,Pno,Qty), (Sno,Pno)是关键字

(1)用关系代数表示检索操作：同时供应代号为P1和P2两种零件的供应者的Sno。

    Πsno,pno(sp) ÷ ΠPno(σpno='p1' V pno='p2'(P))

(2)用SQL语句表示检索操作：求供应红色零件的供应者之Sno。

    select SP.Sno 
    from SP
    join P
    on SP.Pno=P.Pno
    where P.Color="红色"
    

(3)用SQL语句表示操作：创建S表。


属性的数据类型：
Sno： 3位整型数；
Sname： 长度为8的定长字符串；
City： 长度为10的定长字符串

    Create Tables
    (Sno Decimal(3) NOT NULL UNIQUE,
    Sname char(8),
    City char(10)
    );


## 判断题
1. 数据库避免了一切数据冗余 F
2. 关系可用二维表表示，二维表就是关系。 F
3. 实体完整性规则指关键字值的任何组成部分不能为空值，引用完整性则不允许引用不存在的实体（即元组） T
4. 关系规范化理论中，分解关系模式主要是消除关系模式中多余的数据相关性 F（应该是分解关系运算）
5. 数据库系统的存储模式如有变化，则模式应做相应的调整，否则用户程序会在这行中出错 F

## 选择与填空

3. 数据库管理系统能实现对数据库中数据的查询、插入、修改和删除，这类功能称为数据操纵功能
4. 关系数据模型是当前最常用的一种基本数据模型，它使用++二维表结构++来表示实体类型和实体间联系的。关系数据库的数据操作语言DML主要包括++检索和更新++两类操作，关系模型的关系运算是以关系代数为理论基础的，关系代数最基本的操作是并、差，笛卡尔积、投影和选择。

9. 数据库体系结构ANSI模型的三级模式是内模式，模式，外模式
10. SQL语言是一种非过程化的语言 
11. SQL语言的一次查询结果是一个表
12. 在关系代数中，对一个关系做投影操作以后，新关系的元组个数等于原来关系的元组个数
13. 关系模型的关系运算是以关系代数为理论基础的，关系代数的原子运算是并、差、笛卡尔积、投影和选择 ，其它关系运算都可以从这几种原子关系运算推出
14. 设有关系模式R（C,P,S,G,T,R）,其中各属性的含义为：C-课程，P-教师，S-学生，G-成绩，T-时间，R-教室。根据语义有下列数据依赖集：C->P,(S,C)->G,(T,R)->C,(T,P)->R,(T,S)->R;则R的一个关键字是 ；R的规范化程度最高达到 

解答：
①求候选码（关键字）
L：S,T
R:G
LR:C,P,R

ST→CPSGTR
因此求得候选码为ST

②分析最高化规范程度
我们已经从①中求得了候选码是ST了，在关系中很明显可以发现没有S或者T单独推出的属性，只有ST一起推出的属性，S与非主属性或者T与非主属性推出的属性。因此该关系是完全函数依赖。最起码已经满足了2NF。
ps：此处顺便明确一下完全函数依赖的问题
举例如：通过AB能得出C，但是AB单独得不出C，那么说C完全依赖于AB。
在D={C→P,(S,C)→G,(T,R)→C,(T,P)→R,(T,S)→R}中，已经求出候选码ST。C→P、(T,R)→C、(T,P)→R。此处稍微忽略一下S和T，那么不难发现C→P、R→C、P→R存在传递依赖，因此其规范程度无法达到3NF，只能是2NF。

## 算法题

La和Lb分别是两个带头节点的、按数据域data值非递减有序的单链表的头指针。写出将La和Lb归并成一个非递增有序单链表La的算法（利用两个链表的原有节点）用C++写

 leetcode 21.合并两个有序链表
```
ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode* preHead = new ListNode(-1);

        ListNode* prev = preHead;
        while (l1 != nullptr && l2 != nullptr) {
            if (l1->val < l2->val) {
                prev->next = l1;
                l1 = l1->next;
            } else {
                prev->next = l2;
                l2 = l2->next;
            }
            prev = prev->next;
        }

        // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可
        prev->next = l1 == nullptr ? l2 : l1;

        return preHead->next;
    }

```

4. 设关键字序列为{22,38,56,09,77,53,94,43,64},哈希函数为H(key)=key mod 11,线性探测法解决冲突，哈希地址空间为0～11 ，填写下面的哈希表，并求等概情况下查找成功的平均查找长度ASL，

0  | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11
---|---|---|---|---|---|---|---|---|---|---|---
22 |56 | 77|64 |   |38 | 94|   |   | 9 |53  | 43 |

查找成功时，ASL=(1+1+1+1+2+2+1+2+7)/9

查找成功的ASL计算方法[^3]：

5. 有向图G如图a所示，请写出：

（1）顶点1为出发点的DFS序列

123654

（2）顶点1为出发点的BFS序列

124536

（3） G的一个拓扑序列

012543

要求：当有若干个顶点可以选择时，优先选择序号较小的节点。

6. 以{2,5,6,8,4,1}为叶子结点的权值，

（1）画出哈夫曼树；
```
        26
        /\
   11       15
   /\       /\          
  5  6    7    8      
          /\        
         3  4      
        /\    
       1  2
```
（2） 填写存储结构表（合并时，权值较小的成为左子树，较大的成为右子树）

表格打起来太麻烦就不写了。如上图所示。

7. 无向联通网如下图所示，用Prim算法从顶点A开始构造最小生成树，画出每一步的求解过程。

假设N=（V,{E}）是连通图，TE是N上最小生成树中边的集合。算法从U={u0}（u0∈V），TE={}开始，

重复执行下述操作：

在所有u∈U，v∈V-U的边（u，v）∈E中找一条代价最小的边（u0，v0）并入集合TE，同时v0 并入U，直至U=V为止。

此时TE中必有n-1条边，则T=（V，{TE}）为N的最小生成树。

求解过程[^4]




[^1]:http://staff.ustc.edu.cn/~ypb/
[^2]:https://blog.csdn.net/sumaliqinghua/article/details/86246762
[^3]:https://www.cnblogs.com/qixinbo/p/7782314.html
[^4]:https://visualgo.net/zh/mst