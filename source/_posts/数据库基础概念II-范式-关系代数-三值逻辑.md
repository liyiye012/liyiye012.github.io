title: 数据库基础概念II-范式-关系代数-三值逻辑

date: 2020-6-10 12:12:12

categories: 2020年6月

tags: [Database，MySQL]

---

范式(Normal Form),关系代数，超键、候选键、主键、外键。三值逻辑。


<!-- more -->

这部分内容更偏向理论，本科时在孙甲松老师的数据库课上学过一遍，如今再拿出来回炉一下。


# 数据库DB、DBMS、DBA、DBS概念

数据库（Data Base，DB)是按一定结构组织并长期存储在计算机内的、可共享的大量数据的有机集合。其实就是存放数据的仓库，只不过这些数据存在一定的关联、并按一定的格式存放在计算机上。例如，把一个学校的学生、课程、学生成绩等数据有序的组织并存放在计算机内，就可以构成一个数据库。

数据库管理系统（Data Base Management System，DBMS）是管理和维护数据库的系统软件。常用的DBMS有：Oracle、DB2、SqlServer、MySql等

数据库管理员（Date Base Administrator ,DBA)管理操作数据库人员。

数据库系统（Data Base System，DBS）是实现有组织的、动态地存储大量关联数据、方便多用户访问的计算机软件、硬件和数据资源组成的系统，简化为：DBS=计算机系统（硬件、软件平台、人）+DBMS+DB



# 范式(Normal Form)

设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式（Normal Form），各种范式呈递次规范，越高的范式数据库冗余越小。

目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）[^1]。

第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。

第二范式（2NF）：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。

第三范式（3NF）：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如 果存在"A → B → C"的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系： 关键字段 → 非关键字段 x → 非关键字段y

如果你对三个还不太了解，建议阅读：[解释一下关系数据库的第一第二第三范式？](https://www.zhihu.com/question/24696366)

# 范式分解[^2]
1. 函数依赖（FD）

如果A->B，称为A决定B，即当A确定时，B的值唯一

2. 闭包（Closure）

求闭包的过程很简单，比如求A的闭包（A+），只需找到所有只有A在左边的函数依赖，将所有的右边的都加到A的闭包中来，遍历所有的函数依赖，最后不要忘记加上A自己
闭包可以用来求关系模式的key：对于R（A，B，C），若A+ = ABC , 那么可以判定A是R的key。

3. 平凡依赖（trivial FD）

称A->A这样的函数依赖为一个平凡的依赖，当然由此我们也知道了非平凡依赖是什么了。



# 关系代数

关系代数是以关系为运算的一组高级运算的集合[^3]。

由于定义为属性个数 相同的元组的集合，因此集合代数的操作就可以引入到关系代数中。

关系代数也可以看做是一种抽象的查询语言，是对关系的运算来表达查询的。任何一种运算都是将一定的运算符作用于一定的运算对象上，得到预期的运算结果。所以运算对象、运算符、运算结果是运算的三大要素。 

关系代数的运算对象是关系，运算结果亦为关系。关系代数用到的运算符包括四类:集合运算符、专门的关系运算符、算术比较符和逻辑运算符。

关系代数可分为两类：

1. 传统的集合操作：并、差、交、笛卡尔积（乘）、笛卡尔积的逆运算（除法）
2. 扩充的关系操作：对关系进行垂直分割（投影）、水平分割（选择)、关系的结合（连接、自然连接）

## 五个基本操作：

1. 并（Union）：

关系R和S具有相同的关系模式，R和S的并是由属性R和S的元组构成的集合。 形式定义如下：

    R∪S={t|t∈R∨ t∈S} , t 是元组变量，R和S的元素相同
    
其结果由R和S的元素组成 


2. 差（Difference）: 

关系R和S具有相同的关系模式，R和S的差由属于R但不属于S的元组构成的集合。 形式定义如下：

    R-S={t|t∈R ∧ t￠S)  t 是元组变量，R和S的元素相同

其结果由属于R不属于S的所有元组构成



3. 笛卡尔积（Cartesian Product) :

广义笛卡尔积是一个(r+s)列的元组的集合

4. 投影（Projection）：

对一个关系进行垂直分割，消去某些列，并重新安排列的顺序。记作：

         ΠA(R) = { t[A] | t∈R }

其中A为R中的属性列。

5. 选择（Selection）：

根据某些条件对关系做水平分割，即选取符合条件的元组。 

       σF(R) = {t|t∈R ∧ F(t)=true}

σ为选择元算符，F表示选择条件，它是一个逻辑表达式，取逻辑值‘真’或‘假’。

## 四个组合操作

1. 交（Intersection）：

由属于R和S的元组构成的集合。记作：

        R∩S={t|t∈R∧t∈S}
        
由于R∩S=R(R-S)，或R∩S=S-S(S-R) 得到的，因此交操作不是一个独立的操作。

2. 连接（Join）:

连接也称为θ连接，它是从两个关系的笛卡尔积中选取属性中满足一定条件的元组。


其中A和B分别为R和S上度数相等且可比的属性组。θ是比较运算符。连接运算从R和S的广义笛卡尔积R×S中选取 (R关系)在A属性组上的值与(S关系)在B属性组上值满足比较关系θ的元组。

连接操作中比较重要且常用的连接是等值连接和自然连接。

等值连接：

θ为“=”时的连接运算称为等值运算，它是从R和S中选取R中的A属性组上的元组等于S中B属性组上的元组。

自然连接（Natural join）：

自然连接用R连接R⋈S表示，是一种特殊的等值连接，一般使用在R和S中有公共属性的情况中。


3. 除法（Division）：

设关系R和S的元数分别为r和s(设r>s>0),那么R÷S是一个（r-s)元的元组集合。

# 超键、候选键、主键、外键

## 超键(super key):

在关系中能唯一标识元组的属性集称为关系模式的超键

## 候选键(candidate key):

不含有多余属性的超键称为候选键

## 主键(primary key):

用户选作元组标识的一个候选键程序主键

## 外键(foreign key)：

如果关系模式R1中的某属性集不是R1的主键，而是另一个关系R2的主键则该属性集是关系模式R1的外键。

结合实例的具体解释：

假设有如下两个表：
    
    学生（学号，姓名，性别，身份证号，教师编号）
    
    教师（教师编号，姓名，工资）
    
## 超键：

由超键的定义可知，学生表中含有学号或者身份证号的任意组合都为此表的超键。如：（学号）、（学号，姓名）、（身份证号，性别）等。

## 候选键：

候选键属于超键，它是最小的超键，就是说如果再去掉候选键中的任何一个属性它就不再是超键了。学生表中的候选键为：（学号）、（身份证号）

## 主键：

主键就是候选键里面的一个，是人为规定的，例如学生表中，我们通常会让“学号”做主键，教师表中让“教师编号”做主键。

## 外键：

外键比较简单，学生表中的外键就是“教师编号”。外键主要是用来描述两个表的关系。

# 三值逻辑
　　
这个三值逻辑不是三目运算，指的是三个逻辑值[^4]，有人可能有疑问了，逻辑值不是只有真(true)和假(false)吗，哪来的第三个？
　　

说这话时我们需要注意所处的环境，在主流的编程语言中（C、JAVA、Python、JS等）中，逻辑值确实只有 2 个，但在 SQL中却存在第三个逻辑值：unknown。这有点类似于我们平时所说的：对、错、不知道。

　　逻辑值 unknown 和作为 NULL 的一种的 UNKNOWN （未知）是不同的东西。前者是明确的布尔型的逻辑值，后者既不是值也不是变量。为了便于区分，前者采用小写字母 unknown ，后者用大写字母 UNKNOWN 来表示。为了让大家理解两者的不同，我们来看一个 x=x 这样的简单等式。x 是逻辑值 unknown 时，x=x 被判断为 true ，而 x 是 UNKNOWN 时被判断为 unknown 
    
    -- 这个是明确的逻辑值的比较
    unknown = unknown → true
    
    -- 这个相当于NULL = NULL
    UNKNOWN = UNKNOWN → unknown

## NULL 特殊值[^5]

NULL 值将三值逻辑的概念引入 SQL。NULL 值通过任何比较运算符与任何值（包括 NULL 值）进行比较时都是"UNKNOWN"。

返回 TRUE 的唯一搜索条件是 IS NULL 谓语。

在 SQL 中，只有 WHERE 子句中搜索条件的值为 TRUE 时才选择行；不选择值为 UNKNOWN 或 FALSE 的行。

[^1]:https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F


[^2]:https://blog.csdn.net/thor_w/article/details/70231604

[^3]:https://blog.csdn.net/huo_yun/article/details/12904727

[^4]:https://www.cnblogs.com/youzhibing/p/11337745.html

[^5]:http://dcx.sybase.com/sa160/zh/dbreference/nulls.html