<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-07T04:03:17.272Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot学习笔记X</title>
    <link href="http://yoursite.com/2019/08/06/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0X/"/>
    <id>http://yoursite.com/2019/08/06/SpringBoot学习笔记X/</id>
    <published>2019-08-06T07:12:12.000Z</published>
    <updated>2019-08-07T04:03:17.272Z</updated>
    
    <content type="html"><![CDATA[<p>重新温习Java中的抽象类和接口</p><a id="more"></a><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。</p><p>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。</p><p>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。</p><p>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。</p><p>在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p><p>在Java语言中使用abstract class来定义抽象类。如下实例：</p><p>Employee.java 文件代码：</p><pre><code>/* 文件名 : Employee.java */public abstract class Employee{   private String name;   private String address;   private int number;   public Employee(String name, String address, int number)   {      System.out.println(&quot;Constructing an Employee&quot;);      this.name = name;      this.address = address;      this.number = number;   }   public double computePay()   {     System.out.println(&quot;Inside Employee computePay&quot;);     return 0.0;   }   public void mailCheck()   {      System.out.println(&quot;Mailing a check to &quot; + this.name       + &quot; &quot; + this.address);   }   public String toString()   {      return name + &quot; &quot; + address + &quot; &quot; + number;   }   public String getName()   {      return name;   }   public String getAddress()   {      return address;   }   public void setAddress(String newAddress)   {      address = newAddress;   }   public int getNumber()   {     return number;   }}</code></pre><p>注意到该 Employee 类没有什么不同，尽管该类是抽象类，但是它仍然有 3 个成员变量，7 个成员方法和 1 个构造方法。 现在如果你尝试如下的例子：</p><p>AbstractDemo.java 文件代码：</p><pre><code>/* 文件名 : AbstractDemo.java */public class AbstractDemo{   public static void main(String [] args)   {      /* 以下是不允许的，会引发错误 */      Employee e = new Employee(&quot;George W.&quot;, &quot;Houston, TX&quot;, 43);      System.out.println(&quot;\n Call mailCheck using Employee reference--&quot;);      e.mailCheck();    }}</code></pre><p>当你尝试编译AbstractDemo类时，会产生如下错误：</p><pre><code>Employee.java:46: Employee is abstract; cannot be instantiated      Employee e = new Employee(&quot;George W.&quot;, &quot;Houston, TX&quot;, 43);                   ^1 error</code></pre><h2 id="继承抽象类"><a href="#继承抽象类" class="headerlink" title="继承抽象类"></a>继承抽象类</h2><p>我们能通过一般的方法继承Employee类：</p><p>Salary.java 文件代码：</p><pre><code>/* 文件名 : Salary.java */public class Salary extends Employee{   private double salary; //Annual salary   public Salary(String name, String address, int number, double      salary)   {       super(name, address, number);       setSalary(salary);   }   public void mailCheck()   {       System.out.println(&quot;Within mailCheck of Salary class &quot;);       System.out.println(&quot;Mailing check to &quot; + getName()       + &quot; with salary &quot; + salary);   }   public double getSalary()   {       return salary;   }   public void setSalary(double newSalary)   {       if(newSalary &gt;= 0.0)       {          salary = newSalary;       }   }   public double computePay()   {      System.out.println(&quot;Computing salary pay for &quot; + getName());      return salary/52;   }}</code></pre><p>尽管我们不能实例化一个 Employee 类的对象，但是如果我们实例化一个 Salary 类对象，该对象将从 Employee 类继承 7 个成员方法，且通过该方法可以设置或获取三个成员变量。</p><p>AbstractDemo.java 文件代码：</p><pre><code>/* 文件名 : AbstractDemo.java */public class AbstractDemo{   public static void main(String [] args)   {      Salary s = new Salary(&quot;Mohd Mohtashim&quot;, &quot;Ambehta, UP&quot;, 3, 3600.00);      Employee e = new Salary(&quot;John Adams&quot;, &quot;Boston, MA&quot;, 2, 2400.00);      System.out.println(&quot;Call mailCheck using Salary reference --&quot;);      s.mailCheck();      System.out.println(&quot;\n Call mailCheck using Employee reference--&quot;);      e.mailCheck();    }}</code></pre><p>以上程序编译运行结果如下：</p><pre><code>Constructing an EmployeeConstructing an EmployeeCall mailCheck using  Salary reference --Within mailCheck of Salary classMailing check to Mohd Mohtashim with salary 3600.0Call mailCheck using Employee reference--Within mailCheck of Salary classMailing check to John Adams with salary 2400.</code></pre><h2 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h2><p>如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。</p><p>Abstract 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。</p><p>抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。</p><pre><code>public abstract class Employee{   private String name;   private String address;   private int number;   public abstract double computePay();   //其余代码}</code></pre><p>声明抽象方法会造成以下两个结果：</p><p>如果一个类包含抽象方法，那么该类必须是抽象类。</p><p>任何子类必须重写父类的抽象方法，或者声明自身为抽象类。</p><p>继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。</p><p>如果Salary类继承了Employee类，那么它必须实现computePay()方法：</p><p>Salary.java 文件代码：</p><pre><code>/* 文件名 : Salary.java */public class Salary extends Employee{   private double salary; // Annual salary   public double computePay()   {      System.out.println(&quot;Computing salary pay for &quot; + getName());      return salary/52;   }   //其余代码}</code></pre><p>抽象类总结规定</p><ol><li><p>抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。</p></li><li><p>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p></li><li><p>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</p></li><li><p>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。</p></li><li><p>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</p></li></ol><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p><p>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。</p><p>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</p><p>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p><h2 id="接口与类相似点："><a href="#接口与类相似点：" class="headerlink" title="接口与类相似点："></a>接口与类相似点：</h2><p>一个接口可以有多个方法。</p><p>接口文件保存在 .java 结尾的文件中，文件名使用接口名。</p><p>接口的字节码文件保存在 .class 结尾的文件中。</p><p>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</p><h2 id="接口与类的区别："><a href="#接口与类的区别：" class="headerlink" title="接口与类的区别："></a>接口与类的区别：</h2><p>接口不能用于实例化对象。</p><p>接口没有构造方法。</p><p>接口中所有的方法必须是抽象方法。</p><p>接口不能包含成员变量，除了 static 和 final 变量。</p><p>接口不是被类继承了，而是要被类实现。</p><p>接口支持多继承。</p><h2 id="接口特性"><a href="#接口特性" class="headerlink" title="接口特性"></a>接口特性</h2><p>接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。</p><p>接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。</p><p>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。</p><h2 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h2><ol><li><p>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</p></li><li><p>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。</p></li><li><p>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</p></li><li><p>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p></li></ol><p>注：JDK 1.8 以后，接口里可以有静态方法和方法体了。</p><h2 id="接口的声明"><a href="#接口的声明" class="headerlink" title="接口的声明"></a>接口的声明</h2><p>接口的声明语法格式如下：</p><pre><code>[可见度] interface 接口名称 [extends 其他的接口名] {        // 声明变量        // 抽象方法}</code></pre><p>Interface关键字用来声明一个接口。下面是接口声明的一个简单例子。<br>NameOfInterface.java 文件代码：</p><pre><code>/* 文件名 : NameOfInterface.java */import java.lang.*;//引入包public interface NameOfInterface{   //任何类型 final, static 字段   //抽象方法}</code></pre><p>接口有以下特性：</p><p>接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。</p><p>接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键字。</p><p>接口中的方法都是公有的。</p><p>实例</p><pre><code>Animal.java 文件代码：/* 文件名 : Animal.java * /interface Animal {   public void eat();   public void travel();}</code></pre><h2 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h2><p>当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。</p><p>类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。</p><p>实现一个接口的语法，可以使用这个公式：</p><p>Animal.java 文件代码：</p><pre><code>...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ...</code></pre><p>实例<br>MammalInt.java 文件代码：</p><pre><code>/* 文件名 : MammalInt.java * /public class MammalInt implements Animal{   public void eat(){      System.out.println(&quot;Mammal eats&quot;);   }   public void travel(){      System.out.println(&quot;Mammal travels&quot;);   }   public int noOfLegs(){      return 0;   }   public static void main(String args[]){      MammalInt m = new MammalInt();      m.eat();      m.travel();   }}</code></pre><p>以上实例编译运行结果如下:</p><pre><code>Mammal eatsMammal travels</code></pre><p>重写接口中声明的方法时，需要注意以下规则：</p><p>类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。</p><p>类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。</p><p>如果实现接口的类是抽象类，那么就没必要实现该接口的方法。</p><p>在实现接口的时候，也要注意一些规则：</p><p>一个类可以同时实现多个接口。</p><p>一个类只能继承一个类，但是能实现多个接口。</p><p>一个接口能继承另一个接口，这和类之间的继承比较相似。</p><h2 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h2><p>一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。</p><p>下面的Sports接口被Hockey和Football接口继承：</p><pre><code>// 文件名: Sports.javapublic interface Sports{   public void setHomeTeam(String name);   public void setVisitingTeam(String name);}// 文件名: Football.javapublic interface Football extends Sports{   public void homeTeamScored(int points);   public void visitingTeamScored(int points);   public void endOfQuarter(int quarter);}// 文件名: Hockey.javapublic interface Hockey extends Sports{   public void homeGoalScored();   public void visitingGoalScored();   public void endOfPeriod(int period);   public void overtimePeriod(int ot);}</code></pre><p>Hockey接口自己声明了四个方法，从Sports接口继承了两个方法，这样，实现Hockey接口的类需要实现六个方法。</p><p>相似的，实现Football接口的类需要实现五个方法，其中两个来自于Sports接口。<br>接口的多继承</p><p>在Java中，类的多继承是不合法，但接口允许多继承。</p><p>在接口的多继承中extends关键字只需要使用一次，在其后跟着继承接口。 如下所示：</p><pre><code>public interface Hockey extends Sports, Event</code></pre><p>以上的程序片段是合法定义的子接口，与类不同的是，接口允许多继承，而 Sports及 Event 可能定义或是继承相同的方法</p><h2 id="标记接口"><a href="#标记接口" class="headerlink" title="标记接口"></a>标记接口</h2><p>最常用的继承接口是没有包含任何方法的接口。</p><p>标记接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。</p><p>标记接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。</p><p>例如：java.awt.event 包中的 MouseListener 接口继承的 java.util.EventListener 接口定义如下：</p><pre><code>package java.util;public interface EventListener{}</code></pre><p>没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的：</p><p>建立一个公共的父接口：</p><p>正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。</p><p>向一个类添加数据类型：</p><p>这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://www.runoob.com/java/java-abstraction.html" target="_blank" rel="noopener">https://www.runoob.com/java/java-abstraction.html</a></p><p>【2】<a href="https://www.runoob.com/java/java-interfaces.html" target="_blank" rel="noopener">https://www.runoob.com/java/java-interfaces.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重新温习Java中的抽象类和接口&lt;/p&gt;
    
    </summary>
    
      <category term="2019年8月" scheme="http://yoursite.com/categories/2019%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot学习笔记IX</title>
    <link href="http://yoursite.com/2019/08/05/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0IX/"/>
    <id>http://yoursite.com/2019/08/05/SpringBoot学习笔记IX/</id>
    <published>2019-08-05T03:22:12.000Z</published>
    <updated>2019-08-07T01:58:53.794Z</updated>
    
    <content type="html"><![CDATA[<p>CMS系统学习，MapReduce思想学习,对Java8中对新特性stream，map和reduce进行学习，Stream API部分主要来自于IBM Developer官网，原文写的非常详尽清晰。</p><a id="more"></a><h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h1><p>先阅读cn.creditease.bdp.newcms.notice源码，定时相关，其中impl/CmsTaskNoticeHelperImpl/sendMsgByBatch函数是模块入口</p><p>阅读<br>cn.creditease.bdp.newcms.cmswrapper.controller.PaymentScheduleController的源码，涉及到customer表，里面是借贷用户的信息</p><p>需求：CMS逾期天数计算方式优化</p><h1 id="系统介绍"><a href="#系统介绍" class="headerlink" title="系统介绍"></a>系统介绍</h1><p>最早的site系统，scala语言，编译运行比较慢，一小时左右，包括了application，postloan等所有系统</p><p>测试官网网址：<a href="http://shangtongdai.yxapp.xyz/newsite/?code=YANGKAI34#/loginReg/login" target="_blank" rel="noopener">http://shangtongdai.yxapp.xyz/newsite/?code=YANGKAI34#/loginReg/login</a></p><p>查询语句：</p><pre><code>select * from shangtongdai.users    where id in (      select user_id from shangtongdai.applications          where id in (                select application_id from shangtongdai.loans                      where loan_status_id=12 ))</code></pre><p>application系统：进件系统</p><p>巨星系统：数据中转</p><p>爬虫系统：爬取商户数据</p><p>miner系统：评级系统</p><p>postloan系统（贷后系统）</p><p>User系统：管理用户</p><p>User-refer系统：返还佣金</p><p>Report系统：做报表</p><p>Report-tool系统：基础查询</p><p>综合信贷系统：管理合同签约</p><p>新核心系统：管理还款计划表</p><p>结算系统：管理还款逻辑</p><p>添加店户会触发爬虫系统，爬取商户的数据，使用miner系统进行评级，巨星系统进行数据中转筛除。</p><p>评级通过之后，进件将由CMS系统进行审核，审核通过后，所有审核逻辑都在CMS系统中。</p><p>审核通过后，由postloan系统（贷后系统）处理，包括了：</p><p>1.合同管理：签约，管理状态,综合信贷系统管理合同签约</p><p>2.还款：还款计划表,新核心系统管理还款计划表</p><p>3.放款：结算系统管理还款逻辑</p><p>团队主要负责CMS，postloan和report，report-tool等系统。</p><p>application进件系统，爬虫系统，巨星系统，miner评级系统由进件团队负责。</p><p>CMS系统里有初审，复审，分发等36个状态。</p><p><strong><em>shangtongdai数据库表信息：</em></strong></p><p>transport表：进件表，维护进件状态，</p><p>transportlabel拒绝或接受打下标签</p><p>transportext 进件附加信息，以json格式存储（最重要）</p><p>transport_decisions:重大决策信息放款或其它</p><p>transport_assigned_history：客服分单给客户历史的信息</p><p>loan :合同</p><p>repayment：业务订单，用户还款会生成业务订单</p><p>loanrepayment：合同和业务订单的关系，一笔合同会有多笔订单</p><p>repayment_type字段，还款类型</p><p>repayment_order字段：</p><p>repaymenttags:业务订单信息</p><p>权限信息的相关表<br>privilege<br>role<br>role_privilege<br>user_role</p><p>任务相关的表<br>tb_cron_ini<br>cms_task</p><h1 id="MapReduce思想及Java中的实现"><a href="#MapReduce思想及Java中的实现" class="headerlink" title="MapReduce思想及Java中的实现"></a>MapReduce思想及Java中的实现</h1><p>MapReduce源于Google一篇论文，它充分借鉴了分而治之的思想，将一个数据处理过程拆分为主要的Map(映射)与Reduce(化简)两步。用户不懂分布式计算框架的内部运行机制，只要能用Map和Reduce的思想描述清楚要处理的问题，即编写map()和reduce( )函数，就能轻松地使问题的计算实现分布式，并在Hadoop上运行。MapReduce的编程具有以下特点。</p><h2 id="开发简单"><a href="#开发简单" class="headerlink" title="开发简单:"></a>开发简单:</h2><p>得益于MapReduce的编程模型，用户可以不用考虑进程间通信、套接字编程，无需非常高深的技巧，只需要实现一些非常简单的逻辑，其他的交由MapReduce计算框架去完成，大大简化了分布式程序的编写难度。</p><h2 id="可扩展性强"><a href="#可扩展性强" class="headerlink" title="可扩展性强:"></a>可扩展性强:</h2><p>同HDFS一样，当集群资源不能满足计算需求时，可以通过增加节点的方式达到线性扩展集群的目的。</p><h2 id="容错性强"><a href="#容错性强" class="headerlink" title="容错性强:"></a>容错性强:</h2><p>对于节点故障导致的作业失败，MapReduce计算框架会自动将作业安排到健康节点重新执行，直到任务完成，而这些，对于用户来说都是透明的。</p><h2 id="MapReduce的编程思想"><a href="#MapReduce的编程思想" class="headerlink" title="MapReduce的编程思想"></a>MapReduce的编程思想</h2><p>Map(映射)与Reduce(化简)来源于LISP和其他函数式编程语言中的古老的映射和化简操作，MapReduce操作数据的最小单位是一个键值对。用户在使用MapReduce编程模型的时候，第一步就需要将数据抽象为键值对的形式，接着<strong><em>map函数</em></strong> 会以键值对作为输入，经过map函数的处理，产生一系类新的键值对作为中间结果输出到本地。MapReduce计算框架会自动将这些中间结果数据按照键做聚合处理，并将键相同的数据分发给reduce函数处理(用户可以设置分发规则)。<strong><em>reduce函数</em></strong> 以键和对应的值的集合作为输入，经过reduce函数的处理后，产生了另外一系列键值对作为最终输出。</p><p>如果用表达式表示，其过程如下式所示 :</p><pre><code>{Keyl，Value1}~{Key2, List&lt;Value2&gt;}~{Key3, Value3}</code></pre><p>读者可能觉得上面的描述和表达式非常抽象，那么让我们先来看一个例子。有一篮苹果，一些是红苹果，一些是青苹果，每个苹果有一个唯一编号，要解决的问题是统计该篮苹果的数目、红苹果(深色)的个数和青苹果(浅色)的个数。</p><p><img src="assets/markdown-img-paste-20190806142009358.png" alt="https://img-blog.csdn.net/20170502224501777?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDgwMTQzOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p><p>  假设有A, B, C三个人，A获得第一排苹果，B获得第二排苹果，这时，A和B分别统计自己手上的苹果的个数，然后将结果告知C, C将A, B的结果做一次汇总，得到最后结果。对于这个过程，其实用到了MapReduce的思想。我们可以从下一幅图看出端倪。</p><p><img src="assets/markdown-img-paste-20190806142045676.png" alt="https://img-blog.csdn.net/20170502224831447?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDgwMTQzOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p><p>A的map函数的输入的格式为键值对appleId-count，比女fl “ 11-1”表示appleId为11的苹果个数为1，经过map函数的累和，即将所有appleId的count相加，输出为新的键值对AppleCount-6，此时B也进行同样的操作，由于A和B的map函数输出的键值对的键相同，都为“AppleCount”，所以MapReduce框架会将其都分发到C作为reduce函数的输入，并在reduce函数中完成对键相同的值的累和，并输出最后结果AppleCount-12。如果用表达式表示，即为:</p><pre><code>(appleId, count}一&gt;(AppleCount，List&lt;count&gt;}一&gt;{AppleCount，count}</code></pre><p>在这个例子中，就是用MapReduce的思想来完成苹果计数的问题，细心的读者可能发现，这个例子中reduce函数只执行了一次，是否可以执行多次呢，答案是肯定的，下面来看用MapReduce思想解决对红苹果和青苹果分别计数的问题。</p><p>假设有A, B. C, D四个人，A获得第一排苹果，B获得第二排苹果，A将手上的红苹果给C、青苹果给D、B将手上的红苹果给C、青苹果给D。C, D再统计各自手上的结果，得到最后结果，如下图所示。</p><p><img src="assets/markdown-img-paste-20190806142148349.png" alt="https://img-blog.csdn.net/20170502225302823?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDgwMTQzOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p><p>A的map函数的输入同上次一样，在map函数中，用color和appleId作为新的键值对重新输出，B也做同样的操作。而A, B的map函数的输出的键值对会因为不同的键被分别分发到C和D执行:reduce函数，而真正的计数是由reduce函数完成，并输出最后结果。这里:reduce函数一共执行了两次，第一次是处理键为Red的数据.第二次是处理键为Green的数据。如果用表达式表示，即为:</p><pre><code>{appleId, count}~{color, List&lt;appleId&gt;}~{color, count}</code></pre><p>要理解MapReduce的编程思想，其核心的一点就是将数据用键值对表示。在现实生活中，很多数据要么本身就为键值对的形式，要么可以用键值对这种方式来表示，例如电话号码和通话记录，文件名和文件存储的数据等，键值对并不是高端数据挖掘独有的数据模型，而是存在于我们身边非常普通的模型。</p><p>利用分而治之的思想，可以将很多复杂的数据分析问题转变为一系列MapReduce作业，利用Hadoop的提供MapReduce计算框架，实现分布式计算，这样就能对海量数据进行复杂的数据分析，这也是MapReduce的意义所在。</p><h1 id="Java8-中的Stream"><a href="#Java8-中的Stream" class="headerlink" title="Java8 中的Stream"></a>Java8 中的Stream</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。所以说，Java 8 中首次出现的 java.util.stream 是一个函数式语言+多核时代综合影响的产物。</p><h2 id="什么是聚合操作"><a href="#什么是聚合操作" class="headerlink" title="什么是聚合操作"></a>什么是聚合操作</h2><p>在传统的 J2EE 应用中，Java 代码经常不得不依赖于关系型数据库的聚合操作来完成诸如：</p><p>客户每月平均消费金额</p><p>最昂贵的在售商品</p><p>本周完成的有效订单（排除了无效的）</p><p>取十个数据样本作为首页推荐</p><p>这类的操作。</p><p>但在当今这个数据大爆炸的时代，在数据来源多样化、数据海量化的今天，很多时候不得不脱离 RDBMS，或者以底层返回的数据为基础进行更上层的数据统计。而 Java 的集合 API 中，仅仅有极少量的辅助型方法，更多的时候是程序员需要用 Iterator 来遍历集合，完成相关的聚合应用逻辑。这是一种远不够高效、笨拙的方法。在 Java 7 中，如果要发现 type 为 grocery 的所有交易，然后返回以交易值降序排序好的交易 ID 集合，我们需要这样写：</p><h3 id="Java-7-的排序、取值实现"><a href="#Java-7-的排序、取值实现" class="headerlink" title="Java 7 的排序、取值实现"></a>Java 7 的排序、取值实现</h3><pre><code>List&lt;Transaction&gt; groceryTransactions = new Arraylist&lt;&gt;();for(Transaction t: transactions){ if(t.getType() == Transaction.GROCERY){ groceryTransactions.add(t); }}Collections.sort(groceryTransactions, new Comparator(){ public int compare(Transaction t1, Transaction t2){ return t2.getValue().compareTo(t1.getValue()); }});List&lt;Integer&gt; transactionIds = new ArrayList&lt;&gt;();for(Transaction t: groceryTransactions){ transactionsIds.add(t.getId());}</code></pre><p>而在 Java 8 使用 Stream，代码更加简洁易读；而且使用并发模式，程序执行速度更快。</p><h3 id="Java-8-的排序、取值实现"><a href="#Java-8-的排序、取值实现" class="headerlink" title="Java 8 的排序、取值实现"></a>Java 8 的排序、取值实现</h3><pre><code>List&lt;Integer&gt; transactionsIds = transactions.parallelStream(). filter(t -&gt; t.getType() == Transaction.GROCERY). sorted(comparing(Transaction::getValue).reversed()). map(Transaction::getId). collect(toList());</code></pre><h2 id="Stream总览"><a href="#Stream总览" class="headerlink" title="Stream总览"></a>Stream总览</h2><h3 id="什么是流"><a href="#什么是流" class="headerlink" title="什么是流"></a>什么是流</h3><p>Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。</p><p>Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。</p><p>而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。</p><p>而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。</p><p>Stream 的并行操作依赖于 Java7 中引入的 Fork/Join 框架（JSR166y）来拆分任务和加速处理过程。Java 的并行 API 演变历程基本如下：</p><p>1.0-1.4 中的 java.lang.Thread</p><p>5.0 中的 java.util.concurrent</p><p>6.0 中的 Phasers 等</p><p>7.0 中的 Fork/Join 框架</p><p>8.0 中的 Lambda</p><p>Stream 的另外一大特点是，数据源本身可以是无限的。</p><h3 id="流的构成"><a href="#流的构成" class="headerlink" title="流的构成"></a>流的构成</h3><p>当我们使用一个流的时候，通常包括三个基本步骤：</p><p>获取一个数据源（source）→ 数据转换→执行操作获取想要的结果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道，如下图所示。</p><p><img src="assets/markdown-img-paste-20190806173551210.png" alt="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/img001.png"></p><p>图1:流管道 (Stream Pipeline) 的构成</p><p>有多种方式生成 Stream Source：</p><h4 id="从-Collection-和数组"><a href="#从-Collection-和数组" class="headerlink" title="从 Collection 和数组"></a>从 Collection 和数组</h4><p>Collection.stream()</p><p>Collection.parallelStream()</p><p>Arrays.stream(T array) or Stream.of()</p><h4 id="从-BufferedReader"><a href="#从-BufferedReader" class="headerlink" title="从 BufferedReader"></a>从 BufferedReader</h4><p>java.io.BufferedReader.lines()</p><h4 id="静态工厂"><a href="#静态工厂" class="headerlink" title="静态工厂"></a>静态工厂</h4><p>java.util.stream.IntStream.range()<br>java.nio.file.Files.walk()</p><h4 id="自己构建"><a href="#自己构建" class="headerlink" title="自己构建"></a>自己构建</h4><p>java.util.Spliterator</p><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>Random.ints()</p><p>BitSet.stream()</p><p>Pattern.splitAsStream(java.lang.CharSequence)</p><p>JarFile.stream()</p><h3 id="流的操作类型分为两种："><a href="#流的操作类型分为两种：" class="headerlink" title="流的操作类型分为两种："></a>流的操作类型分为两种：</h3><h4 id="Intermediate："><a href="#Intermediate：" class="headerlink" title="Intermediate："></a>Intermediate：</h4><p>一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。</p><h4 id="Terminal："><a href="#Terminal：" class="headerlink" title="Terminal："></a>Terminal：</h4><p>一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。</p><p>在对于一个 Stream 进行多次转换操作 (Intermediate 操作)，每次都对 Stream 的每个元素进行转换，而且是执行多次，这样时间复杂度就是 N（转换次数）个 for 循环里把所有操作都做掉的总和吗？其实不是这样的，转换操作都是 lazy 的，多个转换操作只会在 Terminal 操作的时候融合起来，一次循环完成。</p><p>我们可以这样简单的理解，Stream 里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在 Terminal 操作的时候循环 Stream 对应的集合，然后对每个元素执行所有的函数。</p><p>还有一种操作被称为 <strong><em>short-circuiting</em></strong>。用以指：</p><p>对于一个 intermediate 操作，如果它接受的是一个无限大（infinite/unbounded）的 Stream，但返回一个有限的新 Stream。</p><p>对于一个 terminal 操作，如果它接受的是一个无限大的 Stream，但能在有限的时间计算出结果。</p><p>当操作一个无限大的 Stream，而又希望在有限时间内完成操作，则在管道内拥有一个 short-circuiting 操作是必要非充分条件。</p><h3 id="一个流操作的示例"><a href="#一个流操作的示例" class="headerlink" title="一个流操作的示例"></a>一个流操作的示例</h3><pre><code>int sum = widgets.stream().filter(w -&gt; w.getColor() == RED) .mapToInt(w -&gt; w.getWeight()) .sum();</code></pre><p>stream() 获取当前小物件的 source，filter 和 mapToInt 为 intermediate 操作，进行数据筛选和转换，最后一个 sum() 为 terminal 操作，对符合条件的全部小物件作重量求和。</p><h2 id="流的使用详解"><a href="#流的使用详解" class="headerlink" title="流的使用详解"></a>流的使用详解</h2><p>简单说，对 Stream 的使用就是实现一个 filter-map-reduce 过程，产生一个最终结果，或者导致一个副作用（side effect）。</p><p>流的构造与转换</p><p>下面提供最常见的几种构造 Stream 的样例。</p><h3 id="构造流的几种常见方法"><a href="#构造流的几种常见方法" class="headerlink" title="构造流的几种常见方法"></a>构造流的几种常见方法</h3><pre><code>// 1. Individual valuesStream stream = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);// 2. ArraysString [] strArray = new String[] {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;};stream = Stream.of(strArray);stream = Arrays.stream(strArray);// 3. CollectionsList&lt;String&gt; list = Arrays.asList(strArray);stream = list.stream();</code></pre><p>需要注意的是，对于基本数值型，目前有三种对应的包装类型 Stream：</p><p>IntStream、LongStream、DoubleStream。</p><p>当然我们也可以用 Stream<integer>、Stream<long> &gt;、Stream<double>，但是 boxing 和 unboxing 会很耗时，所以特别为这三种基本数值型提供了对应的 Stream。</double></long></integer></p><p>Java 8 中还没有提供其它数值型 Stream，因为这将导致扩增的内容较多。而常规的数值型聚合运算可以通过上面三种 Stream 进行。</p><h3 id="数值流的构造"><a href="#数值流的构造" class="headerlink" title="数值流的构造"></a>数值流的构造</h3><pre><code>IntStream.of(new int[]{1, 2, 3}).forEach(System.out::println);IntStream.range(1, 3).forEach(System.out::println);IntStream.rangeClosed(1, 3).forEach(System.out::println);</code></pre><h3 id="流转换为其它数据结构"><a href="#流转换为其它数据结构" class="headerlink" title="流转换为其它数据结构"></a>流转换为其它数据结构</h3><pre><code>// 1. ArrayString[] strArray1 = stream.toArray(String[]::new);// 2. CollectionList&lt;String&gt; list1 = stream.collect(Collectors.toList());List&lt;String&gt; list2 = stream.collect(Collectors.toCollection(ArrayList::new));Set set1 = stream.collect(Collectors.toSet());Stack stack1 = stream.collect(Collectors.toCollection(Stack::new));// 3. StringString str = stream.collect(Collectors.joining()).toString();</code></pre><p>一个 Stream 只可以使用一次，上面的代码为了简洁而重复使用了数次。</p><h2 id="流的操作"><a href="#流的操作" class="headerlink" title="流的操作"></a>流的操作</h2><p>接下来，当把一个数据结构包装成 Stream 后，就要开始对里面的元素进行各类操作了。常见的操作可以归类如下。</p><h3 id="Intermediate：-1"><a href="#Intermediate：-1" class="headerlink" title="Intermediate："></a>Intermediate：</h3><p>map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered</p><h3 id="Terminal：-1"><a href="#Terminal：-1" class="headerlink" title="Terminal："></a>Terminal：</h3><p>forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator</p><h3 id="Short-circuiting："><a href="#Short-circuiting：" class="headerlink" title="Short-circuiting："></a>Short-circuiting：</h3><p>anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit</p><p>我们下面看一下 Stream 的比较典型用法。</p><h2 id="map-flatMap"><a href="#map-flatMap" class="headerlink" title="map/flatMap"></a>map/flatMap</h2><p>我们先来看 map。如果你熟悉 scala 这类函数式语言，对这个方法应该很了解，它的作用就是把 input Stream 的每一个元素，映射成 output Stream 的另外一个元素。</p><h3 id="转换大写"><a href="#转换大写" class="headerlink" title="转换大写"></a>转换大写</h3><pre><code>List&lt;String&gt; output = wordList.stream().map(String::toUpperCase).collect(Collectors.toList());</code></pre><p>这段代码把所有的单词转换为大写。</p><h3 id="平方数"><a href="#平方数" class="headerlink" title="平方数"></a>平方数</h3><pre><code>List&lt;Integer&gt; nums = Arrays.asList(1, 2, 3, 4);List&lt;Integer&gt; squareNums = nums.stream().map(n -&gt; n * n).collect(Collectors.toList());</code></pre><p>  这段代码生成一个整数 list 的平方数 {1, 4, 9, 16}。</p><p>  从上面例子可以看出，map 生成的是个 1:1 映射，每个输入元素，都按照规则转换成为另外一个元素。还有一些场景，是一对多映射关系的，这时需要 flatMap。</p><h3 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h3><pre><code>Stream&lt;List&lt;Integer&gt;&gt; inputStream = Stream.of( Arrays.asList(1), Arrays.asList(2, 3), Arrays.asList(4, 5, 6) );Stream&lt;Integer&gt; outputStream = inputStream.flatMap((childList) -&gt; childList.stream());</code></pre><p>flatMap 把 input Stream 中的层级结构扁平化，就是将最底层元素抽出来放到一起，最终 output 的新 Stream 里面已经没有 List 了，都是直接的数字。</p><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>filter 对原始 Stream 进行某项测试，通过测试的元素被留下来生成一个新 Stream。</p><h3 id="留下偶数"><a href="#留下偶数" class="headerlink" title="留下偶数"></a>留下偶数</h3><pre><code>Integer[] sixNums = {1, 2, 3, 4, 5, 6};Integer[] evens =Stream.of(sixNums).filter(n -&gt; n%2 == 0).toArray(Integer[]::new);</code></pre><p>经过条件“被 2 整除”的 filter，剩下的数字为 {2, 4, 6}。</p><h3 id="把单词挑出来"><a href="#把单词挑出来" class="headerlink" title="把单词挑出来"></a>把单词挑出来</h3><pre><code>List&lt;String&gt; output = reader.lines(). flatMap(line -&gt; Stream.of(line.split(REGEXP))). filter(word -&gt; word.length() &gt; 0). collect(Collectors.toList());</code></pre><p>这段代码首先把每行的单词用 flatMap 整理到新的 Stream，然后保留长度不为 0 的，就是整篇文章中的全部单词了。</p><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><p>forEach 方法接收一个 Lambda 表达式，然后在 Stream 的每一个元素上执行该表达式。</p><h3 id="打印姓名（forEach-和-pre-java8-的对比）"><a href="#打印姓名（forEach-和-pre-java8-的对比）" class="headerlink" title="打印姓名（forEach 和 pre-java8 的对比）"></a>打印姓名（forEach 和 pre-java8 的对比）</h3><pre><code>// Java 8roster.stream() .filter(p -&gt; p.getGender() == Person.Sex.MALE) .forEach(p -&gt; System.out.println(p.getName()));// Pre-Java 8for (Person p : roster) { if (p.getGender() == Person.Sex.MALE) { System.out.println(p.getName()); }}</code></pre><p>对一个人员集合遍历，找出男性并打印姓名。可以看出来，forEach 是为 Lambda 而设计的，保持了最紧凑的风格。而且 Lambda 表达式本身是可以重用的，非常方便。当需要为多核系统优化时，可以 parallelStream().forEach()，只是此时原有元素的次序没法保证，并行的情况下将改变串行时操作的行为，此时 forEach 本身的实现不需要调整，而 Java8 以前的 for 循环 code 可能需要加入额外的多线程逻辑。</p><p>但一般认为，forEach 和常规 for 循环的差异不涉及到性能，它们仅仅是函数式风格与传统 Java 风格的差别。</p><p>另外一点需要注意，forEach 是 terminal 操作，因此它执行后，Stream 的元素就被“消费”掉了，你无法对一个 Stream 进行两次 terminal 运算。下面的代码是错误的：</p><pre><code>stream.forEach(element -&gt; doOneThing(element));stream.forEach(element -&gt; doAnotherThing(element));</code></pre><p>相反，具有相似功能的 intermediate 操作 peek 可以达到上述目的。如下是出现在该 api javadoc 上的一个示例。</p><h3 id="peek-对每个元素执行操作并返回一个新的-Stream"><a href="#peek-对每个元素执行操作并返回一个新的-Stream" class="headerlink" title="peek 对每个元素执行操作并返回一个新的 Stream"></a>peek 对每个元素执行操作并返回一个新的 Stream</h3><pre><code>Stream.of(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;) .filter(e -&gt; e.length() &gt; 3) .peek(e -&gt; System.out.println(&quot;Filtered value: &quot; + e)) .map(String::toUpperCase) .peek(e -&gt; System.out.println(&quot;Mapped value: &quot; + e)) .collect(Collectors.toList());</code></pre><p>forEach 不能修改自己包含的本地变量值，也不能用 break/return 之类的关键字提前结束循环。</p><h2 id="findFirst"><a href="#findFirst" class="headerlink" title="findFirst"></a>findFirst</h2><p>这是一个 termimal 兼 short-circuiting 操作，它总是返回 Stream 的第一个元素，或者空。<br>这里比较重点的是它的返回值类型：Optional。这也是一个模仿 Scala 语言中的概念，作为一个容器，它可能含有某值，或者不包含。使用它的目的是尽可能避免 NullPointerException。</p><h3 id="Optional-的两个用例"><a href="#Optional-的两个用例" class="headerlink" title="Optional 的两个用例"></a>Optional 的两个用例</h3><pre><code>String strA = &quot; abcd &quot;, strB = null;print(strA);print(&quot;&quot;);print(strB);getLength(strA);getLength(&quot;&quot;);getLength(strB);public static void print(String text) { // Java 8 Optional.ofNullable(text).ifPresent(System.out::println); // Pre-Java 8 if (text != null) {   System.out.println(text);  } }public static int getLength(String text) { // Java 8return Optional.ofNullable(text).map(String::length).orElse(-1); // Pre-Java 8// return if (text != null) ? text.length() : -1; };</code></pre><p>在更复杂的 if (xx != null) 的情况中，使用 Optional 代码的可读性更好，而且它提供的是编译时检查，能极大的降低 NPE 这种 Runtime Exception 对程序的影响，或者迫使程序员更早的在编码阶段处理空值问题，而不是留到运行时再发现和调试。</p><p>Stream 中的 findAny、max/min、reduce 等方法等返回 Optional 值。还有例如 IntStream.average() 返回 OptionalDouble 等等。</p><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><p>这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。例如 Stream 的 sum 就相当于</p><pre><code>Integer sum = integers.reduce(0, (a, b) -&gt; a+b);</code></pre><p>或</p><pre><code>Integer sum = integers.reduce(0, Integer::sum);</code></pre><p>也有没有起始值的情况，这时会把 Stream 的前面两个元素组合起来，返回的是 Optional。</p><h3 id="reduce-的用例"><a href="#reduce-的用例" class="headerlink" title="reduce 的用例"></a>reduce 的用例</h3><pre><code>// 字符串连接，concat = &quot;ABCD&quot;String concat = Stream.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;).reduce(&quot;&quot;, String::concat);// 求最小值，minValue = -3.0double minValue = Stream.of(-1.5, 1.0, -3.0, -2.0).reduce(Double.MAX_VALUE, Double::min);// 求和，sumValue = 10, 有起始值int sumValue = Stream.of(1, 2, 3, 4).reduce(0, Integer::sum);// 求和，sumValue = 10, 无起始值sumValue = Stream.of(1, 2, 3, 4).reduce(Integer::sum).get();// 过滤，字符串连接，concat = &quot;ace&quot;concat = Stream.of(&quot;a&quot;, &quot;B&quot;, &quot;c&quot;, &quot;D&quot;, &quot;e&quot;, &quot;F&quot;). filter(x -&gt; x.compareTo(&quot;Z&quot;) &gt; 0). reduce(&quot;&quot;, String::concat);</code></pre><p>上面代码例如第一个示例的 reduce()，第一个参数（空白字符）即为起始值，第二个参数（String::concat）为 BinaryOperator。这类有起始值的 reduce() 都返回具体的对象。而对于第四个示例没有起始值的 reduce()，由于可能没有足够的元素，返回的是 Optional，请留意这个区别。</p><h2 id="limit-skip"><a href="#limit-skip" class="headerlink" title="limit/skip"></a>limit/skip</h2><p>limit 返回 Stream 的前面 n 个元素；skip 则是扔掉前 n 个元素（它是由一个叫 subStream 的方法改名而来）。</p><h3 id="limit-和-skip-对运行次数的影响"><a href="#limit-和-skip-对运行次数的影响" class="headerlink" title="limit 和 skip 对运行次数的影响"></a>limit 和 skip 对运行次数的影响</h3><pre><code>public void testLimitAndSkip() { List&lt;Person&gt; persons = new ArrayList(); for (int i = 1; i &lt;= 10000; i++) { Person person = new Person(i, &quot;name&quot; + i); persons.add(person); }List&lt;String&gt; personList2 = persons.stream().map(Person::getName).limit(10).skip(3).collect(Collectors.toList()); System.out.println(personList2);}private class Person { public int no; private String name; public Person (int no, String name) { this.no = no; this.name = name; } public String getName() { System.out.println(name); return name; }}</code></pre><p>输出结果为：</p><pre><code>name1name2name3name4name5name6name7name8name9name10[name4, name5, name6, name7, name8, name9, name10]</code></pre><p>这是一个有 10，000 个元素的 Stream，但在 short-circuiting 操作 limit 和 skip 的作用下，管道中 map 操作指定的 getName() 方法的执行次数为 limit 所限定的 10 次，而最终返回结果在跳过前 3 个元素后只有后面 7 个返回。</p><p>有一种情况是 limit/skip 无法达到 short-circuiting 目的的，就是把它们放在 Stream 的排序操作后，原因跟 sorted 这个 intermediate 操作有关：此时系统并不知道 Stream 排序后的次序如何，所以 sorted 中的操作看上去就像完全没有被 limit 或者 skip 一样。</p><h3 id="limit-和-skip-对-sorted-后的运行次数无影响"><a href="#limit-和-skip-对-sorted-后的运行次数无影响" class="headerlink" title="limit 和 skip 对 sorted 后的运行次数无影响"></a>limit 和 skip 对 sorted 后的运行次数无影响</h3><pre><code>List&lt;Person&gt; persons = new ArrayList(); for (int i = 1; i &lt;= 5; i++) { Person person = new Person(i, &quot;name&quot; + i); persons.add(person); }List&lt;Person&gt; personList2 = persons.stream().sorted((p1, p2) -&gt;p1.getName().compareTo(p2.getName())).limit(2).collect(Collectors.toList());System.out.println(personList2);</code></pre><p>上面的示例对“peek 对每个元素执行操作并返回一个新的 Stream”做了微调，首先对 5 个元素的 Stream 排序，然后进行 limit 操作。输出结果为：</p><pre><code>name2name1name3name2name4name3name5name4[stream.StreamDW$Person@816f27d, stream.StreamDW$Person@87aac27]</code></pre><p>即虽然最后的返回元素数量是 2，但整个管道中的 sorted 表达式执行次数没有像前面例子相应减少。</p><p>最后有一点需要注意的是，对一个 parallel 的 Steam 管道来说，如果其元素是有序的，那么 limit 操作的成本会比较大，因为它的返回对象必须是前 n 个也有一样次序的元素。取而代之的策略是取消元素间的次序，或者不要用 parallel Stream。</p><h2 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h2><p>对 Stream 的排序通过 sorted 进行，它比数组的排序更强之处在于你可以首先对 Stream 进行各类 map、filter、limit、skip 甚至 distinct 来减少元素数量后，再排序，这能帮助程序明显缩短执行时间。我们对“Optional 的两个用例” 进行优化：</p><h3 id="优化：排序前进行-limit-和-skip"><a href="#优化：排序前进行-limit-和-skip" class="headerlink" title="优化：排序前进行 limit 和 skip"></a>优化：排序前进行 limit 和 skip</h3><pre><code>List&lt;Person&gt; persons = new ArrayList(); for (int i = 1; i &lt;= 5; i++) { Person person = new Person(i, &quot;name&quot; + i); persons.add(person); }List&lt;Person&gt; personList2 = persons.stream().limit(2).sorted((p1, p2) -&gt; p1.getName().compareTo(p2.getName())).collect(Collectors.toList());System.out.println(personList2);</code></pre><p>结果会简单很多：</p><pre><code>name2name1[stream.StreamDW$Person@6ce253f1, stream.StreamDW$Person@53d8d10a]</code></pre><p>当然，这种优化是有 business logic 上的局限性的：即不要求排序后再取值。<br>min/max/distinct</p><p>min 和 max 的功能也可以通过对 Stream 元素先排序，再 findFirst 来实现，但前者的性能会更好，为 O(n)，而 sorted 的成本是 O(n log n)。同时它们作为特殊的 reduce 方法被独立出来也是因为求最大最小值是很常见的操作。</p><h3 id="找出最长一行的长度"><a href="#找出最长一行的长度" class="headerlink" title="找出最长一行的长度"></a>找出最长一行的长度</h3><pre><code>BufferedReader br = new BufferedReader(new FileReader(&quot;c:\\SUService.log&quot;));int longest = br.lines(). mapToInt(String::length). max(). getAsInt();br.close();System.out.println(longest);</code></pre><p>下面的例子则使用 distinct 来找出不重复的单词。</p><h3 id="找出全文的单词，转小写，并排序"><a href="#找出全文的单词，转小写，并排序" class="headerlink" title="找出全文的单词，转小写，并排序"></a>找出全文的单词，转小写，并排序</h3><pre><code>List&lt;String&gt; words = br.lines(). flatMap(line -&gt; Stream.of(line.split(&quot; &quot;))). filter(word -&gt; word.length() &gt; 0). map(String::toLowerCase). distinct(). sorted(). collect(Collectors.toList());br.close();System.out.println(words);</code></pre><h2 id="Match"><a href="#Match" class="headerlink" title="Match"></a>Match</h2><p>Stream 有三个 match 方法，从语义上说：<br>allMatch：Stream 中全部元素符合传入的 predicate，返回 true<br>anyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 true<br>noneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true<br>它们都不是要遍历全部元素才能返回结果。例如 allMatch 只要一个元素不满足条件，就 skip 剩下的所有元素，返回 false。对清单 13 中的 Person 类稍做修改，加入一个 age 属性和 getAge 方法。</p><h3 id="使用-Match"><a href="#使用-Match" class="headerlink" title="使用 Match"></a>使用 Match</h3><pre><code>List&lt;Person&gt; persons = new ArrayList();persons.add(new Person(1, &quot;name&quot; + 1, 10));persons.add(new Person(2, &quot;name&quot; + 2, 21));persons.add(new Person(3, &quot;name&quot; + 3, 34));persons.add(new Person(4, &quot;name&quot; + 4, 6));persons.add(new Person(5, &quot;name&quot; + 5, 55));boolean isAllAdult = persons.stream(). allMatch(p -&gt; p.getAge() &gt; 18);System.out.println(&quot;All are adult? &quot; + isAllAdult);boolean isThereAnyChild = persons.stream(). anyMatch(p -&gt; p.getAge() &lt; 12);System.out.println(&quot;Any child? &quot; + isThereAnyChild);</code></pre><p>输出结果：<br>    1<br>    2<br>    All are adult? false<br>    Any child? true</p><h2 id="进阶：自己生成流"><a href="#进阶：自己生成流" class="headerlink" title="进阶：自己生成流"></a>进阶：自己生成流</h2><h2 id="Stream-generate"><a href="#Stream-generate" class="headerlink" title="Stream.generate"></a>Stream.generate</h2><p>通过实现 Supplier 接口，你可以自己来控制流的生成。这种情形通常用于随机数、常量的 Stream，或者需要前后元素间维持着某种状态信息的 Stream。把 Supplier 实例传递给 Stream.generate() 生成的 Stream，默认是串行（相对 parallel 而言）但无序的（相对 ordered 而言）。由于它是无限的，在管道中，必须利用 limit 之类的操作限制 Stream 大小。</p><h3 id="生成-10-个随机整数"><a href="#生成-10-个随机整数" class="headerlink" title="生成 10 个随机整数"></a>生成 10 个随机整数</h3><pre><code>Random seed = new Random();Supplier&lt;Integer&gt; random = seed::nextInt;Stream.generate(random).limit(10).forEach(System.out::println);//Another wayIntStream.generate(() -&gt; (int) (System.nanoTime() % 100)).limit(10).forEach(System.out::println);</code></pre><p>Stream.generate() 还接受自己实现的 Supplier。例如在构造海量测试数据的时候，用某种自动的规则给每一个变量赋值；或者依据公式计算 Stream 的每个元素值。这些都是维持状态信息的情形。</p><h3 id="自实现-Supplier"><a href="#自实现-Supplier" class="headerlink" title="自实现 Supplier"></a>自实现 Supplier</h3><pre><code>Stream.generate(new PersonSupplier()).limit(10).forEach(p -&gt; System.out.println(p.getName() + &quot;, &quot; + p.getAge()));private class PersonSupplier implements Supplier&lt;Person&gt; { private int index = 0; private Random random = new Random(); @Override public Person get() { return new Person(index++, &quot;StormTestUser&quot; + index, random.nextInt(100)); }}</code></pre><p>输出结果：</p><pre><code>StormTestUser1, 9StormTestUser2, 12StormTestUser3, 88StormTestUser4, 51StormTestUser5, 22StormTestUser6, 28StormTestUser7, 81StormTestUser8, 51StormTestUser9, 4StormTestUser10, 76</code></pre><h2 id="Stream-iterate"><a href="#Stream-iterate" class="headerlink" title="Stream.iterate"></a>Stream.iterate</h2><p>iterate 跟 reduce 操作很像，接受一个种子值，和一个 UnaryOperator（例如 f）。然后种子值成为 Stream 的第一个元素，f(seed) 为第二个，f(f(seed)) 第三个，以此类推。</p><h3 id="生成一个等差数列"><a href="#生成一个等差数列" class="headerlink" title="生成一个等差数列"></a>生成一个等差数列</h3><pre><code>Stream.iterate(0, n -&gt; n + 3).limit(10). forEach(x -&gt; System.out.print(x + &quot; &quot;));.</code></pre><p>输出结果：</p><pre><code>0 3 6 9 12 15 18 21 24 27</code></pre><p>与 Stream.generate 相仿，在 iterate 时候管道必须有 limit 这样的操作来限制 Stream 大小。</p><h2 id="进阶：用-Collectors-来进行-reduction-操作"><a href="#进阶：用-Collectors-来进行-reduction-操作" class="headerlink" title="进阶：用 Collectors 来进行 reduction 操作"></a>进阶：用 Collectors 来进行 reduction 操作</h2><p>java.util.stream.Collectors 类的主要作用就是辅助进行各类有用的 reduction 操作，例如转变输出为 Collection，把 Stream 元素进行归组。<br>groupingBy/partitioningBy</p><h3 id="按照年龄归组"><a href="#按照年龄归组" class="headerlink" title="按照年龄归组"></a>按照年龄归组</h3><pre><code>Map&lt;Integer, List&lt;Person&gt;&gt; personGroups = Stream.generate(new PersonSupplier()). limit(100). collect(Collectors.groupingBy(Person::getAge));Iterator it = personGroups.entrySet().iterator();while (it.hasNext()) { Map.Entry&lt;Integer, List&lt;Person&gt;&gt; persons = (Map.Entry) it.next(); System.out.println(&quot;Age &quot; + persons.getKey() + &quot; = &quot; + persons.getValue().size());}</code></pre><p>上面的 code，首先生成 100 人的信息，然后按照年龄归组，相同年龄的人放到同一个 list 中，可以看到如下的输出：</p><pre><code>Age 0 = 2Age 1 = 2Age 5 = 2Age 8 = 1Age 9 = 1Age 11 = 2……</code></pre><h3 id="按照未成年人和成年人归组"><a href="#按照未成年人和成年人归组" class="headerlink" title="按照未成年人和成年人归组"></a>按照未成年人和成年人归组</h3><pre><code>Map&lt;Boolean, List&lt;Person&gt;&gt; children = Stream.generate(new PersonSupplier()). limit(100). collect(Collectors.partitioningBy(p -&gt; p.getAge() &lt; 18));System.out.println(&quot;Children number: &quot; + children.get(true).size());System.out.println(&quot;Adult number: &quot; + children.get(false).size());</code></pre><p>输出结果：</p><pre><code>Children number: 23Adult number: 77</code></pre><p>在使用条件“年龄小于 18”进行分组后可以看到，不到 18 岁的未成年人是一组，成年人是另外一组。</p><p>partitioningBy 其实是一种特殊的 groupingBy，它依照条件测试的是否两种结果来构造返回的数据结构，get(true) 和 get(false) 能即为全部的元素对象。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>总之，Stream 的特性可以归纳为：</p><p>不是数据结构</p><p>它没有内部存储，它只是用操作管道从 source（数据结构、数组、generator function、IO channel）抓取数据。</p><p>它也绝不修改自己所封装的底层数据结构的数据。例如 Stream 的 filter 操作会产生一个不包含被过滤元素的新 Stream，而不是从 source 删除那些元素。</p><p>所有 Stream 的操作必须以 lambda 表达式为参数</p><p>不支持索引访问</p><p>你可以请求第一个元素，但无法请求第二个，第三个，或最后一个。不过请参阅下一项。</p><p>很容易生成数组或者 List</p><p>惰性化</p><p>很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。<br>Intermediate 操作永远是惰性化的。</p><p>并行能力</p><p>当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的。</p><p>可以是无限的</p><p>集合有固定大小，Stream 则不必。limit(n) 和 findFirst() 这类的 short-circuiting 操作可以对无限的 Stream 进行运算并很快完成。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<br><a href="https://blog.csdn.net/weixin_34112900/article/details/93630203" target="_blank" rel="noopener">https://blog.csdn.net/weixin_34112900/article/details/93630203</a></p><p>【2】<a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/index.html</a></p><p>【3】<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html</a></p><p>【4】<a href="https://javarevisited.blogspot.com/2018/07/java-8-tutorials-resources-and-examples-lambda-expression-stream-api-functional-interfaces.html" target="_blank" rel="noopener">https://javarevisited.blogspot.com/2018/07/java-8-tutorials-resources-and-examples-lambda-expression-stream-api-functional-interfaces.html</a></p><p>【5】<a href="http://www.drdobbs.com/jvm/lambdas-and-streams-in-java-8-libraries/240166818" target="_blank" rel="noopener">http://www.drdobbs.com/jvm/lambdas-and-streams-in-java-8-libraries/240166818</a></p><p>【6】<a href="https://www.ibm.com/developerworks/cn/java/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CMS系统学习，MapReduce思想学习,对Java8中对新特性stream，map和reduce进行学习，Stream API部分主要来自于IBM Developer官网，原文写的非常详尽清晰。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年8月" scheme="http://yoursite.com/categories/2019%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot学习笔记VIII</title>
    <link href="http://yoursite.com/2019/08/01/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0VIII/"/>
    <id>http://yoursite.com/2019/08/01/SpringBoot学习笔记VIII/</id>
    <published>2019-08-01T09:12:12.000Z</published>
    <updated>2019-08-06T09:09:22.938Z</updated>
    
    <content type="html"><![CDATA[<p>CMS系统学习，对常用到的注解做详解,总结Java8 Lambda表达式，对涉及到到final关键字做了回顾</p><a id="more"></a><h1 id="CMS系统简介"><a href="#CMS系统简介" class="headerlink" title="CMS系统简介"></a>CMS系统简介</h1><p>内容管理系统（英语：content management system，缩写为 CMS）是指在一个合作模式下，用于管理工作流程的一套制度。该系统可应用于手工操作中，也可以应用到计算机或网络里。作为一种中央储存器（central repository），内容管理系统可将相关内容集中储存并具有群组管理、版本控制等功能。版本控制是内容管理系统的一个主要优势。<br>内容管理系统在物品或文案或数据的存储、掌管、修订（盘存）、语用充实、文档发布等方面有着广泛的应用。现在流行的开源CMS系统有WordPress、Joomla!、Drupal、Xoops、CmsTop等。</p><h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><p>进件 Transport 业务上增加贷款或商户的操作。</p><h1 id="任务描述"><a href="#任务描述" class="headerlink" title="任务描述"></a>任务描述</h1><h2 id="实现查询接口"><a href="#实现查询接口" class="headerlink" title="实现查询接口"></a>实现查询接口</h2><p>saas-cms 的Respository中建立自己的分支，在controller/creditreview/TransportController中画出getAllProcessHistory函数的流程图，自己重新实现一个查询接口<br>数据库配置文件在resources.local/application.yml中<br>使用的数据库是：jdbc:mysql://10.143.248.78:3306/creditreview?</p><p>其中该函数根据GET请求/{transportId}/{attr}中的attr参数（花括号内为参数值）查询相应的数据库transportLabel、transportExt、transportProcessHistory、transportDecision四个数据库</p><h2 id="画出putExts函数流程图（周一上午提交）"><a href="#画出putExts函数流程图（周一上午提交）" class="headerlink" title="画出putExts函数流程图（周一上午提交）"></a>画出putExts函数流程图（周一上午提交）</h2><h2 id="CMS排查问题记录"><a href="#CMS排查问题记录" class="headerlink" title="CMS排查问题记录"></a>CMS排查问题记录</h2><p>入手学习CMS系统</p><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>handler method 参数绑定常用的注解,根据处理的Request的不同内容部分分为四类：（主要讲解常用类型）</p><p>A、处理request uri 部分（这里指uri template中variable，不含queryString部分）的注解：@PathVariable;</p><p>B、处理request header部分的注解：   @RequestHeader, @CookieValue;</p><p>C、处理request body部分的注解：@RequestParam,  @RequestBody;</p><p>D、处理attribute类型是注解： @SessionAttributes, @ModelAttribute;</p><h2 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h2><p>当使用@RequestMapping URI template 样式映射时， 即 someUrl/{paramId}, 这时的paramId可通过 @Pathvariable注解绑定它传过来的值到方法的参数上。</p><p>示例代码：</p><pre><code>@Controller@RequestMapping(&quot;/owners/{ownerId}&quot;)public class RelativePathUriTemplateController {  @RequestMapping(&quot;/pets/{petId}&quot;)  public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) {        // implementation omitted  }}</code></pre><p>上面代码把URI template 中变量 ownerId的值和petId的值，绑定到方法的参数上。若方法参数名称和需要绑定的uri template中变量名称不一致，需要在@PathVariable(“name”)指定uri template中的名称。</p><h2 id="RequestHeader、-CookieValue"><a href="#RequestHeader、-CookieValue" class="headerlink" title="@RequestHeader、@CookieValue"></a>@RequestHeader、@CookieValue</h2><p><strong><em>@RequestHeader注解，可以把Request请求header部分的值绑定到方法的参数上。</em></strong></p><p>示例代码：</p><p>这是一个Request 的header部分：</p><pre><code>Host                    localhost:8080Accept                  text/html,application/xhtml+xml,application/xml;q=0.9Accept-Language         fr,en-gb;q=0.7,en;q=0.3Accept-Encoding         gzip,deflateAccept-Charset          ISO-8859-1,utf-8;q=0.7,*;q=0.7Keep-Alive              300</code></pre><p>下面的代码，把request header部分的 Accept-Encoding的值，绑定到参数encoding上了， Keep-Alive header的值绑定到参数keepAlive上。</p><pre><code>@RequestMapping(&quot;/displayHeaderInfo.do&quot;)public void displayHeaderInfo(@RequestHeader(&quot;Accept-Encoding&quot;) String encoding,                              @RequestHeader(&quot;Keep-Alive&quot;) long keepAlive)  {  //...}</code></pre><p><strong><em>@CookieValue 可以把Request header中关于cookie的值绑定到方法的参数上。</em></strong></p><p>例如有如下Cookie值：</p><pre><code>JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84</code></pre><p>参数绑定的代码：</p><pre><code>@RequestMapping(&quot;/displayHeaderInfo.do&quot;)public void displayHeaderInfo(@CookieValue(&quot;JSESSIONID&quot;) String cookie)  {  //...}</code></pre><p>即把JSESSIONID的值绑定到参数cookie上。</p><h2 id="RequestParam-RequestBody"><a href="#RequestParam-RequestBody" class="headerlink" title="@RequestParam, @RequestBody"></a>@RequestParam, @RequestBody</h2><h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h3><p>A） 常用来处理简单类型的绑定，通过Request.getParameter() 获取的String可直接转换为简单类型的情况（ String–&gt; 简单类型的转换操作由ConversionService配置的转换器来完成）；因为使用request.getParameter()方式获取参数，所以可以处理get 方式中queryString的值，也可以处理post方式中 body data的值；</p><p>B）用来处理Content-Type: 为 application/x-www-form-urlencoded编码的内容，提交方式GET、POST；</p><p>C) 该注解有两个属性： value、required； value用来指定要传入值的id名称，required用来指示参数是否必须绑定；</p><p>示例代码：</p><pre><code>@Controller@RequestMapping(&quot;/pets&quot;)@SessionAttributes(&quot;pet&quot;)public class EditPetForm {    // ...    @RequestMapping(method = RequestMethod.GET)    public String setupForm(@RequestParam(&quot;petId&quot;) int petId, ModelMap model) {        Pet pet = this.clinic.loadPet(petId);        model.addAttribute(&quot;pet&quot;, pet);        return &quot;petForm&quot;;    }    // ...</code></pre><h3 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h3><p>该注解常用来处理Content-Type: 不是application/x-www-form-urlencoded编码的内容，例如application/json, application/xml等；</p><p>它是通过使用HandlerAdapter 配置的HttpMessageConverters来解析post data body，然后绑定到相应的bean上的。</p><p>因为配置有FormHttpMessageConverter，所以也可以用来处理 application/x-www-form-urlencoded的内容，处理完的结果放在一个MultiValueMap&lt;String, String&gt;里，这种情况在某些特殊需求下使用，详情查看FormHttpMessageConverter api;</p><p>示例代码：</p><pre><code>@RequestMapping(value = &quot;/something&quot;, method = RequestMethod.PUT)public void handle(@RequestBody String body, Writer writer) throws IOException {  writer.write(body);</code></pre><h2 id="SessionAttributes-ModelAttribute"><a href="#SessionAttributes-ModelAttribute" class="headerlink" title="@SessionAttributes, @ModelAttribute"></a>@SessionAttributes, @ModelAttribute</h2><h3 id="SessionAttributes"><a href="#SessionAttributes" class="headerlink" title="@SessionAttributes:"></a>@SessionAttributes:</h3><p>该注解用来绑定HttpSession中的attribute对象的值，便于在方法中的参数里使用。</p><p>该注解有value、types两个属性，可以通过名字和类型指定要使用的attribute 对象；</p><p>示例代码：</p><pre><code>@Controller@RequestMapping(&quot;/editPet.do&quot;)@SessionAttributes(&quot;pet&quot;)public class EditPetForm {    // ...}</code></pre><h3 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a>@ModelAttribute</h3><p>该注解有两个用法，一个是用于方法上，一个是用于参数上；</p><p>用于方法上时：  通常用来在处理@RequestMapping之前，为请求绑定需要从后台查询的model；</p><p>用于参数上时： 用来通过名称对应，把相应名称的值绑定到注解的参数bean上；要绑定的值来源于：</p><p>A） @SessionAttributes 启用的attribute 对象上；</p><p>B） @ModelAttribute 用于方法上时指定的model对象；</p><p>C） 上述两种情况都没有时，new一个需要绑定的bean对象，然后把request中按名称对应的方式把值绑定到bean中。</p><p>用到方法上@ModelAttribute的示例代码：</p><pre><code>// Add one attribute// The return value of the method is added to the model under the name &quot;account&quot;// You can customize the name via @ModelAttribute(&quot;myAccount&quot;)@ModelAttributepublic Account addAccount(@RequestParam String number) {    return accountManager.findAccount(number);}</code></pre><p>这种方式实际的效果就是在调用@RequestMapping的方法之前，为request对象的model里put（“account”， Account）；</p><p>用在参数上的@ModelAttribute示例代码：</p><pre><code>@RequestMapping(value=&quot;/owners/{ownerId}/pets/{petId}/edit&quot;, method = RequestMethod.POST)public String processSubmit(@ModelAttribute Pet pet) {}</code></pre><p>首先查询 @SessionAttributes有无绑定的Pet对象，若没有则查询@ModelAttribute方法层面上是否绑定了Pet对象，若没有则将URI template中的值按对应的名称绑定到Pet对象的各属性上。</p><h2 id="在不给定注解的情况下，参数是怎样绑定的？"><a href="#在不给定注解的情况下，参数是怎样绑定的？" class="headerlink" title="在不给定注解的情况下，参数是怎样绑定的？"></a>在不给定注解的情况下，参数是怎样绑定的？</h2><p>通过分析AnnotationMethodHandlerAdapter和RequestMappingHandlerAdapter的源代码发现，方法的参数在不给定参数的情况下：</p><p>若要绑定的对象时简单类型：  调用@RequestParam来处理的。 </p><p>若要绑定的对象时复杂类型：  调用@ModelAttribute来处理的。</p><p>这里的简单类型指java的原始类型(boolean, int 等)、原始类型对象（Boolean, Int等）、String、Date等ConversionService里可以直接String转换成目标对象的类型；</p><h1 id="Java8-Lambda表达式"><a href="#Java8-Lambda表达式" class="headerlink" title="Java8 Lambda表达式"></a>Java8 Lambda表达式</h1><p>Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。<br>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。<br>使用 Lambda 表达式可以使代码变的更加简洁紧凑。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>lambda 表达式的语法格式如下：</p><pre><code>(parameters) -&gt; expression或(parameters) -&gt;{ statements; }</code></pre><p>以下是lambda表达式的重要特征:</p><p>可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。</p><p>可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。</p><p>可选的大括号：如果主体包含了一个语句，就不需要使用大括号。</p><p>可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</p><h2 id="Lambda-表达式实例"><a href="#Lambda-表达式实例" class="headerlink" title="Lambda 表达式实例"></a>Lambda 表达式实例</h2><p>Lambda 表达式的简单例子:</p><pre><code>// 1. 不需要参数,返回值为 5  () -&gt; 5  // 2. 接收一个参数(数字类型),返回其2倍的值  x -&gt; 2 * x  // 3. 接受2个参数(数字),并返回他们的差值  (x, y) -&gt; x – y  // 4. 接收2个int型整数,返回他们的和  (int x, int y) -&gt; x + y  // 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  (String s) -&gt; System.out.print(s)</code></pre><p>在 Java8Tester.java 文件输入以下代码：</p><pre><code>public class Java8Tester {   public static void main(String args[]){      Java8Tester tester = new Java8Tester();      // 类型声明      MathOperation addition = (int a, int b) -&gt; a + b;      // 不用类型声明      MathOperation subtraction = (a, b) -&gt; a - b;      // 大括号中的返回语句      MathOperation multiplication = (int a, int b) -&gt; { return a * b; };      // 没有大括号及返回语句      MathOperation division = (int a, int b) -&gt; a / b;      System.out.println(&quot;10 + 5 = &quot; + tester.operate(10, 5, addition));      System.out.println(&quot;10 - 5 = &quot; + tester.operate(10, 5, subtraction));      System.out.println(&quot;10 x 5 = &quot; + tester.operate(10, 5, multiplication));      System.out.println(&quot;10 / 5 = &quot; + tester.operate(10, 5, division));      // 不用括号      GreetingService greetService1 = message -&gt;      System.out.println(&quot;Hello &quot; + message);      // 用括号      GreetingService greetService2 = (message) -&gt;      System.out.println(&quot;Hello &quot; + message);      greetService1.sayMessage(&quot;Runoob&quot;);      greetService2.sayMessage(&quot;Google&quot;);   }   interface MathOperation {      int operation(int a, int b);   }   interface GreetingService {      void sayMessage(String message);   }   private int operate(int a, int b, MathOperation mathOperation){      return mathOperation.operation(a, b);   }}</code></pre><p>执行以上脚本，输出结果为：</p><pre><code>$ javac Java8Tester.java$ java Java8Tester10 + 5 = 1510 - 5 = 510 x 5 = 5010 / 5 = 2Hello RunoobHello Google</code></pre><p>使用 Lambda 表达式需要注意以下两点：</p><p>Lambda 表达式主要用来定义行内执行的方法类型接口，例如，一个简单方法接口。在上面例子中，我们使用各种类型的Lambda表达式来定义MathOperation接口的方法。然后我们定义了sayMessage的执行。</p><p>Lambda 表达式免去了使用匿名方法的麻烦，并且给予Java简单但是强大的函数化的编程能力。</p><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>lambda 表达式只能引用标记了 final 的外层局部变量，这就是说不能在 lambda 内部修改定义在域外的局部变量，否则会编译错误。<br>在 Java8Tester.java 文件输入以下代码：</p><pre><code>public class Java8Tester {final static String salutation = &quot;Hello! &quot;;public static void main(String args[]){  GreetingService greetService1 = message -&gt;  System.out.println(salutation + message);  greetService1.sayMessage(&quot;Runoob&quot;);}interface GreetingService {  void sayMessage(String message);}}</code></pre><p>执行以上脚本，输出结果为：</p><pre><code>$ javac Java8Tester.java$ java Java8TesterHello! Runoob</code></pre><p>我们也可以直接在 lambda 表达式中访问外层的局部变量：</p><pre><code>public class Java8Tester {    public static void main(String args[]) {        final int num = 1;        Converter&lt;Integer, String&gt; s = (param) -&gt; System.out.println(String.valueOf(param + num));        s.convert(2);  // 输出结果为 3    }    public interface Converter&lt;T1, T2&gt; {        void convert(int i);    }}</code></pre><p>lambda 表达式的局部变量可以不用声明为 final，但是必须不可被后面的代码修改（即隐性的具有 final 的语义）</p><pre><code>int num = 1;  Converter&lt;Integer, String&gt; s = (param) -&gt; System.out.println(String.valueOf(param + num));s.convert(2);num = 5;  //报错信息：Local variable num defined in an enclosing scope must be final or effectively final</code></pre><p>在 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量。</p><pre><code>String first = &quot;&quot;;  Comparator&lt;String&gt; comparator = (first, second) -&gt; Integer.compare(first.length(), second.length());  //编译会出错</code></pre><h1 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h1><p>final是一个关键字，可以用于修饰类，成员变量，成员方法。</p><h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><p>它修饰的类不能被继承。</p><p>它修饰的成员变量是一个常量。</p><p>它修饰的成员方法是不能被子类重写的。</p><p>final修饰的常量定义一般都有书写规范,被final修饰的常量名称,所有字母都大写。</p><p>final修饰成员变量,必须初始化,初始化有两种</p><p>显示初始化；</p><p>构造方法初始化。</p><p>但是不能两个一起初始化</p><h2 id="final和private的区别："><a href="#final和private的区别：" class="headerlink" title="final和private的区别："></a>final和private的区别：</h2><p>final修饰的类可以访问；</p><p>private不可以修饰外部类，但可以修饰内部类（其实把外部类私有化是没有意义的）。</p><p>final修饰的方法不可以被子类重写；</p><p>private修饰的方法表面上看是可以被子类重写的，其实不可以，子类是看不到父类的私有方法的。</p><p>final修饰的变量只能在显示初始化或者构造函数初始化的时候赋值一次，以后不允许更改；</p><p>private修饰的变量，也不允许直接被子类或一个包中的其它类访问或修改，但是他可以通过set和get方法对其改值和取值。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://blog.csdn.net/walkerJong/article/details/7946109" target="_blank" rel="noopener">https://blog.csdn.net/walkerJong/article/details/7946109</a></p><p>【2】<a href="https://www.runoob.com/java/java8-lambda-expressions.html" target="_blank" rel="noopener">https://www.runoob.com/java/java8-lambda-expressions.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CMS系统学习，对常用到的注解做详解,总结Java8 Lambda表达式，对涉及到到final关键字做了回顾&lt;/p&gt;
    
    </summary>
    
      <category term="2019年8月" scheme="http://yoursite.com/categories/2019%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot学习笔记VII</title>
    <link href="http://yoursite.com/2019/07/31/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0VII/"/>
    <id>http://yoursite.com/2019/07/31/SpringBoot学习笔记VII/</id>
    <published>2019-07-31T03:12:12.000Z</published>
    <updated>2019-08-01T09:54:20.748Z</updated>
    
    <content type="html"><![CDATA[<p>Mybatis的分页查询，日志log的写法详解</p><a id="more"></a><h1 id="SQL分页查询"><a href="#SQL分页查询" class="headerlink" title="SQL分页查询"></a>SQL分页查询</h1><p>使用SELECT查询时，如果结果集数据量很大，比如几万行数据，放在一个页面显示的话数据量太大，不如分页显示，每次显示100条。</p><p>要实现分页功能，实际上就是从结果集中显示第1 ~ 100条记录作为第1页，显示第101~200条记录作为第2页，以此类推。</p><p>因此，分页实际上就是从结果集中“截取”出第M~N条记录。这个查询可以通过LIMIT <m> OFFSET <n>子句实现。</n></m></p><p>例如基本查询语句：</p><pre><code>SELECT id,name,gender,scoreFROM studentsORDER BY score DESC;</code></pre><p>现在将结果集分页，每页3条记录。要获取第一页的记录，可以使用 LIMIT 3 OFFSET 0:</p><pre><code>SELECT id,name,gender,scoreFROM studentsORDER BY score DESCLIMIT 3 OFFSET 0;</code></pre><p>上述查询LIMIT 3 OFFSET 0表示：<br>对结果集从0号记录开始，最多取3条（注意SQL记录集对索引从0开始）。<br>若要查询第2页，那么我们只需要跳过前3条记录，即对结果集从3号记录开始查询，把OFFSET设定为3:</p><pre><code>SELECT id,name,gender,scoreFROM studentsORDER BY score DESCLIMIT 3 OFFSET 3;</code></pre><p>类似的，查询第3页的时候，OFFSET应该设为6，查询第4页的时候，OFFSET应该设为9.如果查询的表第4页只有1条记录，则最终结果按照实际数量1显示，LIMIT 3表示的意思是“最多3条记录”。</p><p>可见分页查询的关键在于，首先要确定每页需要显示的结果数量pageSize，然后根据当前页的索引pageIndex（从1开始），确定LIMIT和OFFSET应该设定的值：</p><p>LIMIT总是设定为pageSize；<br>OFFSET计算公式为pageSize*（pageIndex-1）。</p><h2 id="扩展思考"><a href="#扩展思考" class="headerlink" title="扩展思考"></a>扩展思考</h2><p>如果原本记录集只有10条记录，但我们将OFFSET设置为20，结果会怎样呢？<br>答案是OFFSET超过查询的最大数量并不会报错，而是会得到一个空的结果集</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>OFFSET是可选的，OFFSET缺省值为0.即LIMIT 3 相当于LIMIT 3 OFFSET 0<br>在MySQL中，LIMIT 3 OFFSET 0也可简写为LIMIT 3，0<br>使用LIMIT M OFFSET N进行分页查询时，N越大查询效率越低。</p><h1 id="SQL连接查询"><a href="#SQL连接查询" class="headerlink" title="SQL连接查询"></a>SQL连接查询</h1><p>连接查询是将两个或两个以上的表按某些条件连接起来，从中选取需要的数据。可以分为内连接查询(通过where实现)和外连接查询（join）。</p><h2 id="内连接查询"><a href="#内连接查询" class="headerlink" title="内连接查询"></a>内连接查询</h2><p>只有不同表中有相同意义的字段时才能进行连接，而且内连接查询只查询出指定字段取值相同的记录。<br><img src="assets/markdown-img-paste-20190801165654826.png" alt="https://img-blog.csdn.net/20171209135846780?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcGxnMTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p><pre><code>一般语法:select a.* , b.*from table_a as a, table_b as bwhere a.id = b.id;</code></pre><h2 id="外连接查询"><a href="#外连接查询" class="headerlink" title="外连接查询"></a>外连接查询</h2><p>需要通过指定字段来进行连接。当该字段取值相等时，可以查询出该记录；而且当该字段不等时，也可以查询出来。包括左连接，右连接查询。</p><pre><code>一般语法：select 属性名列表from 表1left | right join 表2on 表1.属性名 = 表2.属性名;</code></pre><h3 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h3><p>left join 是left outer join的简写，它的全称是左外连接，是外连接中的一种。<br>左(外)连接，左表(a_table)的记录将会全部表示出来，而右表(b_table)只会显示符合搜索条件的记录。右表记录不足的地方均为NULL。<br><img src="assets/markdown-img-paste-2019080116575036.png" alt="https://img-blog.csdn.net/20171209142610819?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcGxnMTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p><h3 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h3><p>右外连接与左外连接相对称，<br>right join是right outer join的简写，它的全称是右外连接，是外连接中的一种。<br>与左(外)连接相反，右(外)连接，左表(a_table)只会显示符合搜索条件的记录，而右表(b_table)的记录将会全部表示出来。左表记录不足的地方均为NULL。<br><img src="assets/markdown-img-paste-20190801175330121.png" alt="https://img-blog.csdn.net/20171209144056668?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcGxnMTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p><h3 id="外连接查询加条件语句"><a href="#外连接查询加条件语句" class="headerlink" title="外连接查询加条件语句"></a>外连接查询加条件语句</h3><p>使用外连接查询时，可以加上各种条件进行筛选。</p><pre><code>select table1.column1, table2.column1from table1join table2on table1.column2 = table2.column3;select table1.column1, table2.column1from table1,table2where table1.column2 = table2.column3;</code></pre><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>子查询时将一个查询语句嵌套在另一个查询语句中，内层查询语句的查询结果，可以为外层查询语句提供查询条件。在特定情况下：一个查询语句的条件需要另一个查询语句来获取。<br>子查询，又叫内部查询，相对于内部查询，包含内部查询的就称为外部查询。</p><p>子查询可以包含普通select可以包括的任何子句，比如：distinct、 group by、order by、limit、join和union等；但是对应的外部查询必须是以下语句之一：select、insert、update、delete、set或 者do。</p><p>注：一个查询语句只能有一个order by ，在子查询中只能位于外部查询后面.</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>子查询分为如下几类：<br>1）. 标量子查询：返回单一值的标量，最简单的形式。<br>2）. 列子查询：返回的结果集是 N 行一列。<br>3）. 行子查询：返回的结果集是一行 N 列。<br>4）. 表子查询：返回的结果集是 N 行 N 列。<br>可以使用的操作符：= &gt; &lt; &gt;= &lt;= &lt;&gt; ANY IN SOME ALL EXISTS</p><p>释义：一个子查询会返回一个标量（就一个值）、一个行、一个列或一个表，这些子查询称之为标量、行、列和表子查询。</p><h3 id="带有any关键字的子查询"><a href="#带有any关键字的子查询" class="headerlink" title="带有any关键字的子查询"></a>带有any关键字的子查询</h3><p>any关键字表示满足其中任一条件，使用any关键字时，只要满足内层查询语句返回的结果中的任何一个，就可以通过该条件来执行外层查询语句。</p><p>从computer表中查询哪些人分数高于任何一个奖学金的最低分。</p><pre><code>select * from computer_stuwhere score &gt;= ANY                  (select score From  scholarship);</code></pre><h3 id="带有all关键字的子查询"><a href="#带有all关键字的子查询" class="headerlink" title="带有all关键字的子查询"></a>带有all关键字的子查询</h3><p>表示需要满足所有的条件。只有满足内层查询语句返回的所有结果，才可以执行外层查询语句。</p><h3 id="带有exists关键字的子查询"><a href="#带有exists关键字的子查询" class="headerlink" title="带有exists关键字的子查询"></a>带有exists关键字的子查询</h3><p>exists关键字表示存在，内层查询语句不返回查询的记录，而是返回一个真假值，如果内层查询语句查询到满足条件的记录，就返回一个true，外层查询语句将进行查询。</p><pre><code>select * from employeewhere exists (select d_name from department where d_id = 1003);//如果department存在d_id为1003，则查询employee表。</code></pre><p>还可以分为相关子查询，独立子查询。以上子查询与外层查询没有关联，称为独立子查询，如果子查询有用到外层查询的字段，则称相关子查询，相关子查询容易产生性能问题。</p><h1 id="Mybatis分页查询"><a href="#Mybatis分页查询" class="headerlink" title="Mybatis分页查询"></a>Mybatis分页查询</h1><h1 id="日志Log写法详解"><a href="#日志Log写法详解" class="headerlink" title="日志Log写法详解"></a>日志Log写法详解</h1><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://www.liaoxuefeng.com/wiki/1177760294764384/1217864791925600" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1177760294764384/1217864791925600</a><br>【2】<a href="https://blog.csdn.net/plg17/article/details/78758593" target="_blank" rel="noopener">https://blog.csdn.net/plg17/article/details/78758593</a><br>【3】<a href="https://cloud.tencent.com/developer/article/1333120" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1333120</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mybatis的分页查询，日志log的写法详解&lt;/p&gt;
    
    </summary>
    
      <category term="2019年7月" scheme="http://yoursite.com/categories/2019%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot学习笔记VI</title>
    <link href="http://yoursite.com/2019/07/31/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0VI/"/>
    <id>http://yoursite.com/2019/07/31/SpringBoot学习笔记VI/</id>
    <published>2019-07-31T02:12:12.000Z</published>
    <updated>2019-08-01T08:36:08.203Z</updated>
    
    <content type="html"><![CDATA[<p>简单总结SpringMVC整合Mybatis，从Get/Request请求中实现对数据库的增删改查，对应着SpringBoot学习笔记II中的Mybatis任务中的第二项。</p><a id="more"></a><h1 id="建立项目步骤"><a href="#建立项目步骤" class="headerlink" title="建立项目步骤"></a>建立项目步骤</h1><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>在主目录下（com.example.std.java.demo）下建立Controller包，在controller下建立与表对应的controller</p><pre><code>package com.example.std.java.demo.controller;import com.example.std.java.demo.dto.request.*;import com.example.std.java.demo.dto.response.MerchantResponseDTO;import com.example.std.java.demo.entity.TblMerchantEntity;import com.example.std.java.demo.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;/** @Description: 商户接口* @Author:yiye.li* @Date:2019-07-28*/@RestController@RequestMapping(&quot;/Merchant&quot;)public class MerchantController extends BaseController{@AutowiredUserService userService;/* *商户接口 * 1。注册商户 * http://localhost:8080//Merchant/CreateMerchant Postman中Get内容，其余内容可以在Params中填写 * 使用@RequestBody格式则需在GET中的Body-》raw中以JSON串格式填写(注意在最右面的一栏中选择JSON(application/json)) * @param MerchantRequestDTO * @return */@GetMapping(&quot;/CreateMerchant&quot;)public MerchantResponseDTO CreateMerchant(@RequestBody CreateMerchantRequestDTO createMerchantRequestDTO){    TblMerchantEntity tblMerchantEntity=new TblMerchantEntity();    tblMerchantEntity.setMerchantName(createMerchantRequestDTO.getMerchantName());    tblMerchantEntity.setContactName(createMerchantRequestDTO.getContactName());    tblMerchantEntity.setPlatformKey(createMerchantRequestDTO.getPlatformKey());    tblMerchantEntity.setShortName(createMerchantRequestDTO.getShortName());    MerchantResponseDTO merchantResponseDTO;    merchantResponseDTO=userService.MybatisCreateMerchant(tblMerchantEntity);    return merchantResponseDTO;}/* *商户接口 * 2。根据商编查询商户 * http://localhost:8080//Merchant/SelectByMerchantNo Postman中Get内容，其余内容可以在Params中填写 * @param MerchantRequestDTO * @return */@GetMapping(&quot;/SelectByMerchantNo&quot;)public MerchantResponseDTO SelectByMerchantNo(@RequestBody SelectByMerchantNoRequestDTO selectByMerchantNoRequestDTO){    TblMerchantEntity tblMerchantEntity=new TblMerchantEntity();    tblMerchantEntity.setMerchantNo(selectByMerchantNoRequestDTO.getMerchantNo());    MerchantResponseDTO merchantResponseDTO;    merchantResponseDTO=userService.MybatisSelectByMerchantNo(tblMerchantEntity);    return merchantResponseDTO;}/* *商户接口 * 3。修改商户状态 * http://localhost:8080//Merchant/UpdateMerchantStatus Postman中Get内容，其余内容可以在Params中填写 * @param MerchantRequestDTO * @return */@GetMapping(&quot;/UpdateMerchantStatus&quot;)public MerchantResponseDTO UpdateMerchantStatus(@RequestBody UpdateMerchantRequestDTO updateMerchantRequestDTO){    TblMerchantEntity tblMerchantEntity=new TblMerchantEntity();    tblMerchantEntity.setId(updateMerchantRequestDTO.getId());    MerchantResponseDTO merchantResponseDTO;    merchantResponseDTO=userService.MybatisUpdateMerchantStatus(tblMerchantEntity);    return merchantResponseDTO;}/* *商户接口 * 4。从外部能够查询商户(根据ID查询商户) * http://localhost:8080//Merchant/MerchantQuery Postman中Get内容，其余内容可以在Params中的KEY和VALUE填写 * @param MerchantRequestDTO * @return */@GetMapping(&quot;/MerchantQuery&quot;)public MerchantResponseDTO MerchantQuery(@RequestBody SelectByIDMerchantRequestDTO selectByIDMerchantRequestDTO){    TblMerchantEntity tblMerchantEntity=new TblMerchantEntity();    tblMerchantEntity.setId(selectByIDMerchantRequestDTO.getId());    MerchantResponseDTO merchantResponseDTO;    merchantResponseDTO=userService.MybatisSpringQuery(tblMerchantEntity);    return merchantResponseDTO;}/*    //4。从外部能够查询商户(根据ID查询商户)//http://localhost:8080//Merchant/MerchantQuery Postman中Get内容，其余内容可以在Params中的KEY和VALUE填写@GetMapping(&quot;/MerchantQuery&quot;)public MerchantResponseDTO MerchantQuery(@RequestParam(&quot;merchantName&quot;) String merchantName,                                    @RequestParam(&quot;contactName&quot;) String contactName,                                    @RequestParam(&quot;contactPhone&quot;)  String contactPhone,                                    @RequestParam(&quot;platformKey&quot;) String platformKey,                                    @RequestParam(&quot;shortName&quot;) String shortName){    MerchantResponseDTO merchantResponseDTO=new MerchantResponseDTO();    merchantResponseDTO=userService.MybatisSpringQuery(40L);    return merchantResponseDTO;}*/}</code></pre><h2 id="DTO"><a href="#DTO" class="headerlink" title="DTO"></a>DTO</h2><h3 id="RequestDTO"><a href="#RequestDTO" class="headerlink" title="RequestDTO"></a>RequestDTO</h3><p>在主目录下建立dto包，再分别建立子目录request和response，request下建立相应的requestDTO文件，每个文件中对应着HTTP请求中相应的参数，而response下建立相应的responseDTO文件，其中对应着要返回的参数</p><p>如SelectByIDMerchantRequestDTO.class</p><pre><code>package com.example.std.java.demo.dto.request;import java.io.Serializable;import lombok.Data;/*** @Description: 商户dto* @Author: yiye.li* @Date: 2019-07-29 10:45*/@Datapublic class SelectByIDMerchantRequestDTO {  /**   * 商户ID   */  private Long id;}</code></pre><p>再如CreateMerchantRequestDTO.class文件</p><pre><code>package com.example.std.java.demo.dto.request;import java.io.Serializable;import lombok.Data;/** * @Description: 商户dto * @Author: yiye.li * @Date: 2019-07-29 10:45 */@Datapublic class CreateMerchantRequestDTO {    /**     * 商户名称     */    private String merchantName;    /**     * 联系人姓名     */    private String contactName;    /**     * 联系电话     */    private String contactPhone;    /**     * 平台钥匙     */    private String platformKey;    /**     * 简称     */    private String shortName;}</code></pre><h3 id="ReponseDTO"><a href="#ReponseDTO" class="headerlink" title="ReponseDTO"></a>ReponseDTO</h3><p>ReponseDTO中写相应的返回参数，例如：</p><pre><code>package com.example.std.java.demo.dto.response;import lombok.Data;import java.util.Date;/** * @Description: 商户返回dto * @Author: yiye.li * @Date: 2019-07-29 10:45 */@Datapublic class MerchantResponseDTO {    //可以自选返回什么    /**     * ID     */    private long ID;    /**     * CREATE_TIME     */    private Date createTime;    /**     * 上次更新时间     */    private Date lastUpdateTime;    /**     * 商户编号     */    private String merchantNo;    /**     * 商户名称     */    private String merchantName;    /**     * 联系人姓名     */    private String contactName;    /**     * 联系电话     */    private String contactPhone;    /**     * 平台钥匙     */    private String platformKey;    /**     * 商户状态     */    private String status;    /**     * 简称     */    private String shortName;    /**     * 组     */    private String checkGroup;}</code></pre><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>在主目录下建立Service包，其中建立Service文件中声明方法名和参数，再建立impl包，其中的ServiceImpl文件来实现对HTTP请求相应的处理方法</p><p>UserService.class文件</p><pre><code>package com.example.std.java.demo.service;import com.example.std.java.demo.dto.response.MerchantResponseDTO;import com.example.std.java.demo.entity.TblMerchantEntity;public interface UserService {    String test();    /**     * 创建商户     * @param tblMerchantEntity     * @return     */    MerchantResponseDTO MybatisCreateMerchant(TblMerchantEntity tblMerchantEntity);    /**     * 根据商编查询商户     * @param tblMerchantEntity     * @return     */    MerchantResponseDTO MybatisSelectByMerchantNo(TblMerchantEntity tblMerchantEntity);    /**     *     * @param tblMerchantEntity     * @return     */    MerchantResponseDTO MybatisUpdateMerchantStatus(TblMerchantEntity tblMerchantEntity);    /**     *     * @param tblMerchantEntity     * @return     */    MerchantResponseDTO MybatisSpringQuery(TblMerchantEntity tblMerchantEntity);}</code></pre><p>而impl文件中的UserServiceImpl.class文件如下：</p><pre><code>package com.example.std.java.demo.service.impl;import com.alibaba.fastjson.JSON;import com.example.std.java.demo.dao.TblMerchantEntityMapper;import com.example.std.java.demo.dto.response.MerchantResponseDTO;import com.example.std.java.demo.entity.TblMerchantEntity;import com.example.std.java.demo.entity.TblMerchantEntityExample;import com.example.std.java.demo.service.UserService;import lombok.extern.apachecommons.CommonsLog;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.util.CollectionUtils;import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.List;import java.util.Random;@Servicepublic class UserServiceImpl implements UserService {    private static final Logger logger= LoggerFactory.getLogger(UserServiceImpl.class);    //要加一些事务处理    //@Transcational (rollback=...    @Override    public String test() {        return null;    }    @Autowired    private TblMerchantEntityMapper tblMerchantEntityMapper;//create duplicate problem to solve    @Override    public MerchantResponseDTO MybatisCreateMerchant(TblMerchantEntity RequesttblMerchantEntity){        MerchantResponseDTO merchantResponseDTO=new MerchantResponseDTO();        TblMerchantEntity tblMerchantEntity=new TblMerchantEntity();        //生成随机数        Random random=new Random();        int nextInt=random.nextInt(100000);        long IDnum=nextInt;        if(tblMerchantEntityMapper.selectByPrimaryKey(IDnum)==null) {            tblMerchantEntity.setId(IDnum);            try{                DateFormat format=new SimpleDateFormat(&quot;yyyyMMddHHmmss&quot;);                Date date =format.parse(System.currentTimeMillis()+&quot;&quot;);                Date dateend =format.parse(System.currentTimeMillis()+24+&quot;&quot;);                tblMerchantEntity.setCreateTime(date);                tblMerchantEntity.setLastUpdateTime(dateend);            }catch(ParseException e){                e.printStackTrace();            }            tblMerchantEntity.setMerchantNo(&quot;&quot;+nextInt);            //set the new data from the requestDTO            tblMerchantEntity.setMerchantName(RequesttblMerchantEntity.getMerchantName());            tblMerchantEntity.setContactName(RequesttblMerchantEntity.getContactName());            tblMerchantEntity.setContactPhone(RequesttblMerchantEntity.getContactPhone());            tblMerchantEntity.setPlatformKey(RequesttblMerchantEntity.getPlatformKey());            tblMerchantEntity.setShortName(RequesttblMerchantEntity.getShortName());            tblMerchantEntity.setStatus(&quot;1&quot;);            tblMerchantEntity.setCheckGroup(&quot;集贸市场&quot;);            tblMerchantEntityMapper.insert(tblMerchantEntity);            merchantResponseDTO.setID(tblMerchantEntity.getId());            merchantResponseDTO.setCreateTime(tblMerchantEntity.getCreateTime());            merchantResponseDTO.setLastUpdateTime(tblMerchantEntity.getLastUpdateTime());            merchantResponseDTO.setMerchantNo(tblMerchantEntity.getMerchantNo());            merchantResponseDTO.setMerchantName(tblMerchantEntity.getMerchantName());            merchantResponseDTO.setContactName(tblMerchantEntity.getContactName());            merchantResponseDTO.setContactPhone(tblMerchantEntity.getContactPhone());            merchantResponseDTO.setPlatformKey(tblMerchantEntity.getPlatformKey());            merchantResponseDTO.setStatus(tblMerchantEntity.getStatus());            merchantResponseDTO.setShortName(tblMerchantEntity.getShortName());            merchantResponseDTO.setCheckGroup(tblMerchantEntity.getCheckGroup());            //将entity中的属性set到merchantResponseDTO中去            System.out.println(&quot;*********Create by ID=&quot;+IDnum+&quot;************&quot;);        }else{            System.out.println(&quot;*********Create The Record Failed, The record has already existed*************&quot;);            tblMerchantEntity=tblMerchantEntityMapper.selectByPrimaryKey(IDnum);            merchantResponseDTO.setID(tblMerchantEntity.getId());            merchantResponseDTO.setCreateTime(tblMerchantEntity.getCreateTime());            merchantResponseDTO.setLastUpdateTime(tblMerchantEntity.getLastUpdateTime());            merchantResponseDTO.setMerchantNo(tblMerchantEntity.getMerchantNo());            merchantResponseDTO.setMerchantName(tblMerchantEntity.getMerchantName());            merchantResponseDTO.setContactName(tblMerchantEntity.getContactName());            merchantResponseDTO.setContactPhone(tblMerchantEntity.getContactPhone());            merchantResponseDTO.setPlatformKey(tblMerchantEntity.getPlatformKey());            merchantResponseDTO.setStatus(tblMerchantEntity.getStatus());            merchantResponseDTO.setShortName(tblMerchantEntity.getShortName());            merchantResponseDTO.setCheckGroup(tblMerchantEntity.getCheckGroup());        }        return merchantResponseDTO;    }    @Override    public MerchantResponseDTO MybatisSelectByMerchantNo(TblMerchantEntity RequesttblMerchantEntity){        MerchantResponseDTO merchantResponseDTO= null;        try {            merchantResponseDTO = new MerchantResponseDTO();            if(logger.isDebugEnabled()){                //debug 级别的日志                logger.debug(&quot;&quot;);            }            logger.info(&quot;query merchant info by merchantN={}&quot;,RequesttblMerchantEntity);            //1。构建商户实体            TblMerchantEntity tblMerchantEntity=new TblMerchantEntity();            TblMerchantEntityExample tblMerchantEntityExample=new TblMerchantEntityExample();            TblMerchantEntityExample.Criteria criteria=tblMerchantEntityExample.createCriteria();            criteria.andMerchantNoEqualTo(RequesttblMerchantEntity.getMerchantNo());            // 2。从数据库查询商户信息            List&lt;TblMerchantEntity&gt; tblMerchantEntities = tblMerchantEntityMapper.selectByExample(tblMerchantEntityExample);            // 判断如果查询的商户信息为空则抛出异常            if(CollectionUtils.isEmpty(tblMerchantEntities)){                throw new RuntimeException(&quot;merchant is null&quot;);            }else{                //如果查询的商户有重复则在日志中写入warn                if(tblMerchantEntities.size()&gt;1) {                    logger.warn(&quot;query merchant size ={}&quot;, tblMerchantEntities.size());                }                //获取第一个商户的信息                tblMerchantEntity=tblMerchantEntities.get(0);            }            //3。将entity中的属性set到merchantResponseDTO中去            merchantResponseDTO.setID(tblMerchantEntity.getId());            merchantResponseDTO.setCreateTime(tblMerchantEntity.getCreateTime());            merchantResponseDTO.setLastUpdateTime(tblMerchantEntity.getLastUpdateTime());            merchantResponseDTO.setMerchantNo(tblMerchantEntity.getMerchantNo());            merchantResponseDTO.setMerchantName(tblMerchantEntity.getMerchantName());            merchantResponseDTO.setContactName(tblMerchantEntity.getContactName());            merchantResponseDTO.setContactPhone(tblMerchantEntity.getContactPhone());            merchantResponseDTO.setPlatformKey(tblMerchantEntity.getPlatformKey());            merchantResponseDTO.setStatus(tblMerchantEntity.getStatus());            merchantResponseDTO.setShortName(tblMerchantEntity.getShortName());            merchantResponseDTO.setCheckGroup(tblMerchantEntity.getCheckGroup());            System.out.println(&quot;*********Select by MerchantNo=&quot;+tblMerchantEntity.getMerchantNo()+&quot;************&quot;);            System.out.println(JSON.toJSONString(tblMerchantEntity));        } catch (RuntimeException e) {            logger.error(&quot;system error &quot;,e);            throw e;        }        return merchantResponseDTO;    }    @Override    public MerchantResponseDTO MybatisUpdateMerchantStatus(TblMerchantEntity RequesttblMerchantEntity){        //制定要更新的ID        long IDnum=RequesttblMerchantEntity.getId();        TblMerchantEntity tblMerchantEntity=tblMerchantEntityMapper.selectByPrimaryKey(IDnum);        MerchantResponseDTO merchantResponseDTO=new MerchantResponseDTO();        TblMerchantEntityExample tblMerchantEntityExample=new TblMerchantEntityExample();        TblMerchantEntityExample.Criteria criteria=tblMerchantEntityExample.createCriteria();        criteria.andIdEqualTo(tblMerchantEntity.getId());        tblMerchantEntity.setStatus(&quot;1&quot;);        //set the new data from the requestDTO        tblMerchantEntityMapper.updateByExample(tblMerchantEntity,tblMerchantEntityExample);        merchantResponseDTO.setID(tblMerchantEntity.getId());        merchantResponseDTO.setCreateTime(tblMerchantEntity.getCreateTime());        merchantResponseDTO.setLastUpdateTime(tblMerchantEntity.getLastUpdateTime());        merchantResponseDTO.setMerchantNo(tblMerchantEntity.getMerchantNo());        merchantResponseDTO.setMerchantName(tblMerchantEntity.getMerchantName());        merchantResponseDTO.setContactName(tblMerchantEntity.getContactName());        merchantResponseDTO.setContactPhone(tblMerchantEntity.getContactPhone());        merchantResponseDTO.setPlatformKey(tblMerchantEntity.getPlatformKey());        merchantResponseDTO.setStatus(tblMerchantEntity.getStatus());        merchantResponseDTO.setShortName(tblMerchantEntity.getShortName());        merchantResponseDTO.setCheckGroup(tblMerchantEntity.getCheckGroup());        System.out.println(&quot;*********Update by ID=&quot;+tblMerchantEntity.getId()+&quot;************&quot;);        System.out.println(JSON.toJSONString(tblMerchantEntity));        return merchantResponseDTO;    }    @Override    public MerchantResponseDTO MybatisSpringQuery(TblMerchantEntity RequesttblMerchantEntity){        //1。获取对应信息        long IDnum=RequesttblMerchantEntity.getId();        MerchantResponseDTO merchantResponseDTO=new MerchantResponseDTO();        //2。先从缓存中尝试获取数据        //3。缓存无，从db中获取数据        //注意是mybatis中自动生成的TblMerchantEntity而不是JPA中生成的实体TblMerchant        TblMerchantEntity tblMerchantEntity=tblMerchantEntityMapper.selectByPrimaryKey(IDnum);        //制定要更新的ID        System.out.println(&quot;*********Query by ID=&quot;+IDnum+&quot;************&quot;);        merchantResponseDTO.setID(tblMerchantEntity.getId());        merchantResponseDTO.setCreateTime(tblMerchantEntity.getCreateTime());        merchantResponseDTO.setLastUpdateTime(tblMerchantEntity.getLastUpdateTime());        merchantResponseDTO.setMerchantNo(tblMerchantEntity.getMerchantNo());        //将Get请求中的信息set到ReponseDTO中去        merchantResponseDTO.setMerchantName(tblMerchantEntity.getMerchantName());        merchantResponseDTO.setContactName(tblMerchantEntity.getContactName());        merchantResponseDTO.setContactPhone(tblMerchantEntity.getContactPhone());        merchantResponseDTO.setPlatformKey(tblMerchantEntity.getPlatformKey());        merchantResponseDTO.setStatus(tblMerchantEntity.getStatus());        //        merchantResponseDTO.setShortName(tblMerchantEntity.getShortName());        merchantResponseDTO.setCheckGroup(tblMerchantEntity.getCheckGroup());        //4。返回结果        //将entity中的属性set到merchantResponseDTO中去        return merchantResponseDTO;    }}</code></pre><p>其中的文件目录树如下：</p><p><img src="assets/markdown-img-paste-20190731101545612.png" alt=""></p><h1 id="PostMan使用"><a href="#PostMan使用" class="headerlink" title="PostMan使用"></a>PostMan使用</h1><p>PostMan软件可用于调试HTTP接口，具体使用方法不再赘述<br>只说需要注意的几点：</p><h2 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h2><p>当controller中当方法参数为@RequestParam形式时</p><pre><code>//4。从外部能够查询商户(根据ID查询商户)//http://localhost:8080//Merchant/MerchantQuery Postman中Get内容，其余内容可以在Params中的KEY和VALUE填写@GetMapping(&quot;/MerchantQuery&quot;)public MerchantResponseDTO MerchantQuery(@RequestParam(&quot;merchantName&quot;) String merchantName,                                    @RequestParam(&quot;contactName&quot;) String contactName,                                    @RequestParam(&quot;contactPhone&quot;)  String contactPhone,                                    @RequestParam(&quot;platformKey&quot;) String platformKey,                                    @RequestParam(&quot;shortName&quot;) String shortName){    MerchantResponseDTO merchantResponseDTO=new MerchantResponseDTO();    merchantResponseDTO=userService.MybatisSpringQuery(40L);    return merchantResponseDTO;}</code></pre><p>Postman中选择POST格式发送，<a href="http://localhost:8080/Merchant/MerchantQuery" target="_blank" rel="noopener">http://localhost:8080/Merchant/MerchantQuery</a><br>然后在Params中填入KEY和VALUE，即可发送对应当POST请求。</p><h2 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h2><p>如果controller中的方法参数为@RequestBody形式时:</p><pre><code>/**商户接口* 4。从外部能够查询商户(根据ID查询商户)* http://localhost:8080//Merchant/MerchantQuery Postman中Get内容，其余内容可以在Params中的KEY和VALUE填写* @param MerchantRequestDTO* @return*/@GetMapping(&quot;/MerchantQuery&quot;)public MerchantResponseDTO MerchantQuery(@RequestBody SelectByIDMerchantRequestDTO selectByIDMerchantRequestDTO){  TblMerchantEntity tblMerchantEntity=new TblMerchantEntity();  tblMerchantEntity.setId(selectByIDMerchantRequestDTO.getId());  MerchantResponseDTO merchantResponseDTO;  merchantResponseDTO=userService.MybatisSpringQuery(tblMerchantEntity);  return merchantResponseDTO;}</code></pre><p>则选择Body-》raw形式，然后在右侧的栏中选择JSON(application/json)<br>以JSON格式填写POST中的Body：</p><pre><code>{    &quot;ID&quot;: &quot;47943&quot;}</code></pre><h1 id="浏览器测试"><a href="#浏览器测试" class="headerlink" title="浏览器测试"></a>浏览器测试</h1><p>除了用Postman进行测试外，也可以直接在浏览器中输入GET请求进行测试，在网址栏输入<a href="http://localhost:8080//Merchant/MerchantQuery发送即可" target="_blank" rel="noopener">http://localhost:8080//Merchant/MerchantQuery发送即可</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单总结SpringMVC整合Mybatis，从Get/Request请求中实现对数据库的增删改查，对应着SpringBoot学习笔记II中的Mybatis任务中的第二项。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年7月" scheme="http://yoursite.com/categories/2019%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot学习笔记V</title>
    <link href="http://yoursite.com/2019/07/30/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0V/"/>
    <id>http://yoursite.com/2019/07/30/SpringBoot学习笔记V/</id>
    <published>2019-07-30T08:28:12.000Z</published>
    <updated>2019-07-31T02:40:06.154Z</updated>
    
    <content type="html"><![CDATA[<p>介绍了SpringMVC的基本概念和HTTP中Get与POST的区别。</p><a id="more"></a><h1 id="原理详解"><a href="#原理详解" class="headerlink" title="原理详解"></a>原理详解</h1><h2 id="SpringMVC是什么"><a href="#SpringMVC是什么" class="headerlink" title="SpringMVC是什么"></a>SpringMVC是什么</h2><p>早期 Java Web 的开发中，统一把显示层、控制层、数据层的操作全部交给 JSP 或者 JavaBean 来进行处理，我们称之为 Model1：<br><img src="assets/markdown-img-paste-20190730171141304.png" alt="https://upload-images.jianshu.io/upload_images/7896890-7b3f9cd59394b017.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/963"></p><p>出现的弊端：</p><p>1.JSP 和 Java Bean 之间严重耦合，Java 代码和 HTML 代码也耦合在了一起</p><p>2.要求开发者不仅要掌握 Java ，还要有高超的前端水平</p><p>3.前端和后端相互依赖，前端需要等待后端完成，后端也依赖前端完成，才能进行有效的测试</p><p>4.代码难以复用</p><p>正因为上面的种种弊端，所以很快这种方式就被 Servlet + JSP + Java Bean 所替代了，早期的 MVC 模型（Model2）就像下图这样：<br><img src="assets/markdown-img-paste-20190730171449446.png" alt="https://upload-images.jianshu.io/upload_images/7896890-403a273b08fec826.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/985"></p><p>首先用户的请求会到达 Servlet，然后根据请求调用相应的 Java Bean，并把所有的显示结果交给 JSP 去完成，这样的模式我们就称为 MVC 模式。</p><p>M 代表 模型（Model）<br>模型是什么呢？ 模型就是数据，就是 dao,bean</p><p>V 代表 视图（View）<br>视图是什么呢？ 就是网页, JSP，用来展示模型中的数据</p><p>C 代表 控制器（controller)<br>控制器是什么？ 控制器的作用就是把不同的数据(Model)，显示在不同的视图(View)上，Servlet 扮演的就是这样的角色。</p><h3 id="Spring-MVC-的架构"><a href="#Spring-MVC-的架构" class="headerlink" title="Spring MVC 的架构"></a>Spring MVC 的架构</h3><p>为解决持久层中一直未处理好的数据库事务的编程，又为了迎合 NoSQL 的强势崛起，Spring MVC 给出了方案</p><p><img src="assets/markdown-img-paste-20190730171743535.png" alt="https://upload-images.jianshu.io/upload_images/7896890-a25782fb05f315de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000"></p><p>传统的模型层被拆分为了业务层(Service)和数据访问层（DAO,Data Access Object）。 在 Service 下可以通过 Spring 的声明式事务操作数据访问层，而在业务层上还允许我们访问 NoSQL ，这样就能够满足异军突起的 NoSQL 的使用了，它可以大大提高互联网系统的性能。</p><p>特点：</p><p>1.结构松散，几乎可以在 Spring MVC 中使用各类视图</p><p>2.松耦合，各个模块分离</p><p>3.与 Spring 无缝集成</p><h2 id="HTTP中Get与POST的区别"><a href="#HTTP中Get与POST的区别" class="headerlink" title="HTTP中Get与POST的区别"></a>HTTP中Get与POST的区别</h2><p>Get和Post是两种Http请求方式：</p><p><strong><em>GET-从指定的资源请求数据</em></strong></p><p><strong><em>POST-向指定的资源提交要被处理的数据</em></strong></p><h3 id="GET方法"><a href="#GET方法" class="headerlink" title="GET方法"></a>GET方法</h3><p>查询字符串（名称/值对）是在GET请求的URL中发送的：</p><pre><code>http://localhost:8080/Merchant/SelectByMerchantNo?name1=value1&amp;name2=value2</code></pre><p>GET 请求可被缓存</p><p>GET 请求保留在浏览器历史记录中</p><p>GET 请求可被收藏为书签</p><p>GET 请求不应在处理敏感数据时使用</p><p>GET 请求有长度限制</p><p>GET 请求只应当用于取回数据</p><h3 id="POST方法"><a href="#POST方法" class="headerlink" title="POST方法"></a>POST方法</h3><p>查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的：</p><pre><code>POST /test/demo_form.asp HTTP/1.1Host: w3schools.comname1=value1&amp;name2=value2</code></pre><p>POST 请求不会被缓存</p><p>POST 请求不会保留在浏览器历史记录中</p><p>POST 不能被收藏为书签</p><p>POST 请求对数据长度没有要求</p><table><thead><tr><th></th><th>Get</th><th>POST</th></tr></thead><tbody><tr><td>后退按钮/刷新</td><td>无害</td><td>数据会被重新提交（浏览器应该告知用户数据会被重新提交</td></tr><tr><td>书签</td><td>可收藏为书签</td><td>不可收藏为书签</td></tr><tr><td>缓存</td><td>能被缓存</td><td>不能缓存</td></tr><tr><td>编码类型</td><td>application/x-www-form-urlencoded</td><td>application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。</td></tr><tr><td>历史</td><td>参数保留在浏览器历史中</td><td>参数不会保留在浏览器历史中</td></tr><tr><td>对数据长度的限制</td><td>只允许ASCII字符</td><td>没有限制，也允许二进制数据</td></tr><tr><td>安全性</td><td>较差，因为发送的数据是URL的一部分</td><td>POST比GET更安全，因为参数不会被保留在浏览器历史或WEB服务器日志中</td></tr><tr><td>可见性</td><td>数据在URL中对所有人都是可见的</td><td>数据不会显示在URL在中</td></tr></tbody></table><p>其它HTTP请求方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>HEAD</td><td>与GET相同，但只返回HTTP报头，不返回文档主体</td></tr><tr><td>PUT</td><td>上传指定但URI表示</td></tr><tr><td>DELETE</td><td>删除指定资源</td></tr><tr><td>OPTIONS</td><td>返回服务器支持但HTTP方法</td></tr><tr><td>CONNECT</td><td>把请求连接转换到透明的TCP/IP通道</td></tr></tbody></table><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://www.jianshu.com/p/91a2d0a1e45a" target="_blank" rel="noopener">https://www.jianshu.com/p/91a2d0a1e45a</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍了SpringMVC的基本概念和HTTP中Get与POST的区别。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年7月" scheme="http://yoursite.com/categories/2019%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot学习笔记IV</title>
    <link href="http://yoursite.com/2019/07/26/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0IV/"/>
    <id>http://yoursite.com/2019/07/26/SpringBoot学习笔记IV/</id>
    <published>2019-07-26T10:30:12.000Z</published>
    <updated>2019-07-30T08:32:30.968Z</updated>
    
    <content type="html"><![CDATA[<p>简单总结Java工程师的学习路径，之后还会详细介绍，总结了最近用到的一些知识和注意事项如定时组件，注释，日志，注解等。</p><a id="more"></a><h1 id="中级Java工程师（十年学习计划）"><a href="#中级Java工程师（十年学习计划）" class="headerlink" title="中级Java工程师（十年学习计划）"></a>中级Java工程师（十年学习计划）</h1><p>JVM调优，class如何编译生成<br>分布式事务<br>分布式组件/工具zoomkeeper<br>缓存的使用（redis）<br>分库分表<br>微服务，看SpringCloud源码<br>并发编程<br>Spring源码（建议看两到三遍）</p><h1 id="最近半年学习方向（两个方向）："><a href="#最近半年学习方向（两个方向）：" class="headerlink" title="最近半年学习方向（两个方向）："></a>最近半年学习方向（两个方向）：</h1><p>1.Spring源码，例如bean初始化<br>2.AQS</p><h1 id="今日学习任务"><a href="#今日学习任务" class="headerlink" title="今日学习任务"></a>今日学习任务</h1><h2 id="定时组件学习"><a href="#定时组件学习" class="headerlink" title="定时组件学习"></a>定时组件学习</h2><h2 id="注释写法"><a href="#注释写法" class="headerlink" title="注释写法"></a>注释写法</h2><p>从Controller到DTO再到Service，每个类中的函数都要有注释，包括功能，参数，返回值，格式如下：<br>Service中的例子：</p><pre><code>/** * 创建商户 * @param tblMerchantEntity * @return */</code></pre><p>DTO中的例子：</p><pre><code>/*** @Description: 商户dto* @Author: yiye.li* @Date: 2019-07-29 10:45*/</code></pre><p><strong><em>注释写法，可以先按照步骤写出注释，然后再相应等填充代码</em></strong></p><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>（日志级别分为info，debug，warning，error等），可用于debug。<br>例程：</p><pre><code>@Overridepublic MerchantResponseDTO MybatisSelectByMerchantNo(TblMerchantEntity RequesttblMerchantEntity){    MerchantResponseDTO merchantResponseDTO= null;    try {        merchantResponseDTO = new MerchantResponseDTO();        if(logger.isDebugEnabled()){            //debug 级别的日志            logger.debug(&quot;&quot;);        }        logger.info(&quot;query merchant info by merchantN={}&quot;,RequesttblMerchantEntity);        //1。构建商户实体        TblMerchantEntity tblMerchantEntity=new TblMerchantEntity();        TblMerchantEntityExample tblMerchantEntityExample=new TblMerchantEntityExample();        TblMerchantEntityExample.Criteria criteria=tblMerchantEntityExample.createCriteria();        criteria.andMerchantNoEqualTo(RequesttblMerchantEntity.getMerchantNo());        // 2。从数据库查询商户信息        List&lt;TblMerchantEntity&gt; tblMerchantEntities = tblMerchantEntityMapper.selectByExample(tblMerchantEntityExample);        // 判断如果查询的商户信息为空则抛出异常        if(CollectionUtils.isEmpty(tblMerchantEntities)){            throw new RuntimeException(&quot;merchant is null&quot;);        }else{            //如果查询的商户有重复则在日志中写入warn            if(tblMerchantEntities.size()&gt;1) {                logger.warn(&quot;query merchant size ={}&quot;, tblMerchantEntities.size());            }            //获取第一个商户的信息            tblMerchantEntity=tblMerchantEntities.get(0);        }        //3。将entity中的属性set到merchantResponseDTO中去        merchantResponseDTO.setID(tblMerchantEntity.getId());        merchantResponseDTO.setCreateTime(tblMerchantEntity.getCreateTime());        merchantResponseDTO.setLastUpdateTime(tblMerchantEntity.getLastUpdateTime());        merchantResponseDTO.setMerchantNo(tblMerchantEntity.getMerchantNo());        merchantResponseDTO.setMerchantName(tblMerchantEntity.getMerchantName());        merchantResponseDTO.setContactName(tblMerchantEntity.getContactName());        merchantResponseDTO.setContactPhone(tblMerchantEntity.getContactPhone());        merchantResponseDTO.setPlatformKey(tblMerchantEntity.getPlatformKey());        merchantResponseDTO.setStatus(tblMerchantEntity.getStatus());        merchantResponseDTO.setShortName(tblMerchantEntity.getShortName());        merchantResponseDTO.setCheckGroup(tblMerchantEntity.getCheckGroup());        System.out.println(&quot;*********Select by MerchantNo=&quot;+tblMerchantEntity.getMerchantNo()+&quot;************&quot;);        System.out.println(JSON.toJSONString(tblMerchantEntity));    } catch (RuntimeException e) {        logger.error(&quot;system error &quot;,e);        throw e;    }    return merchantResponseDTO;}</code></pre><p>日志技巧.var</p><h2 id="实现SpringBoot热部署"><a href="#实现SpringBoot热部署" class="headerlink" title="实现SpringBoot热部署"></a>实现SpringBoot热部署</h2><h2 id="SpringBoot注解学习"><a href="#SpringBoot注解学习" class="headerlink" title="SpringBoot注解学习"></a>SpringBoot注解学习</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单总结Java工程师的学习路径，之后还会详细介绍，总结了最近用到的一些知识和注意事项如定时组件，注释，日志，注解等。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年7月" scheme="http://yoursite.com/categories/2019%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot学习笔记III</title>
    <link href="http://yoursite.com/2019/07/25/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0III/"/>
    <id>http://yoursite.com/2019/07/25/SpringBoot学习笔记III/</id>
    <published>2019-07-25T01:36:12.000Z</published>
    <updated>2019-07-26T10:47:25.468Z</updated>
    
    <content type="html"><![CDATA[<p>阐述Spring，Spring MVC，Spring Boot 三者的原理和区别。学习笔记II中涉及到对@Resource和@Autowired的区别做了解释。<br>对用命令查询网络端口占用情况，查找/杀死进程做了回顾性的复习。</p><a id="more"></a><h1 id="三省吾身："><a href="#三省吾身：" class="headerlink" title="三省吾身："></a>三省吾身：</h1><h2 id="什么是Spring？它解决了什么问题？"><a href="#什么是Spring？它解决了什么问题？" class="headerlink" title="什么是Spring？它解决了什么问题？"></a>什么是Spring？它解决了什么问题？</h2><p>Spring是一个开源的轻量级Java SE（Java 标准版本）/Java EE（Java 企业版本）开发应用框架，其目的是用于简化企业级应用程序开发。应用程序是由一组相互协作的对象组成。而在传统应用程序开发中，一个完整的应用是由一组相互协作的对象组成。所以开发一个应用除了要开发业务逻辑之外，最多的是关注如何使这些对象协作来完成所需功能，而且要低耦合、高内聚。业务逻辑开发是不可避免的，那如果有个框架出来帮我们来创建对象及管理这些对象之间的依赖关系。可能有人说了，比如“抽象工厂、工厂方法设计模式”不也可以帮我们创建对象，“生成器模式”帮我们处理对象间的依赖关系，不也能完成这些功能吗？可是这些又需要我们创建另一些工厂类、生成器类，我们又要而外管理这些类，增加了我们的负担，如果能有种通过配置方式来创建对象，管理对象之间依赖关系，我们不需要通过工厂和生成器来创建及管理对象之间的依赖关系，这样我们是不是减少了许多工作，加速了开发，能节省出很多时间来干其他事。Spring框架刚出来时主要就是来完成这个功能。</p><p>Spring框架除了帮我们<strong><em>管理对象及其依赖关系</em></strong>，还提供像通用日志记录、性能统计、安全控制、异常处理等面向切面的能力，还能帮我管理最头疼的数据库事务，本身提供了一套简单的JDBC访问实现，提供与第三方数据访问框架集成（如Hibernate、JPA），与各种Java EE技术整合（如Java Mail、任务调度等等），提供一套自己的web层框架Spring MVC、而且还能非常简单的与第三方web框架集成。从这里我们可以认为Spring是一个超级粘合平台，除了自己提供功能外，还提供粘合其他技术和框架的能力，从而使我们可以更自由的选择到底使用什么技术进行开发。而且不管是JAVA SE（C/S架构）应用程序还是JAVA EE（B/S架构）应用程序都可以使用这个平台进行开发。</p><p>Spring，一般指代的是Spring Framework，它是一个开源的应用程序框架，提供了一个简易的开发方式，通过这种开发方式，将避免那些可能致使代码变得繁杂混乱的大量的业务/工具对象，说的更通俗一点就是由框架来帮你管理这些对象，包括它的创建，销毁等，比如基于Spring的项目里经常能看到的Bean，它代表的就是由Spring管辖的对象。<br>而在被管理对象与业务逻辑之间，Spring通过IOC（控制反转）架起使用的桥梁，IOC也可以看做Spring最核心最重要的思想，通过IOC能带来什么好处呢？首先来看一个实际开发中的典型应用场景，假设我们有一个基于MVC分层结构的应用，通过controller层对外提供接口，而通过service层提供具体的实现，在service层中有一个WelcomeService服务接口，一般情况下都是通过WelcomeService service = new WelcomeServiceImpl();创建实例并进行调用：</p><pre><code>public class WelcomeController {    private WelcomeService service = new WelcomeServiceImpl();    @RequestMapping(&quot;/welcome&quot;)    public String welcome() {    return service.retrieveWelcomeMessage();    }}</code></pre><p>调用后发现一切正常，此时，功能提交，需要进行测试，而由于实际应用环境与测试环境有所区别，需要替换WelcomeServiceImpl为一个MockWelcomeServiceImpl，以方便测试，怎么办？没有其他办法，只有改代码：</p><pre><code>public class WelcomeController {    private WelcomeService service = new MockWelcomeServiceImpl();    ...}测试OK后再将代码改回去，这种方式太过于繁琐，且对代码的侵入性很强；下面看通过Spring的IOC如何实现，首先将WelcomeService交由Spring管理：&lt;bean name=&quot;WelcomeService&quot; class=&quot;XXX.XXX.XXX.service.impl.WelcomeServiceImpl&quot;/&gt;</code></pre><p>然后在业务代码处通过Spring IOC拿到具体对象：</p><pre><code>public class WelcomeController {    @Autowired    private WelcomeService service;    @RequestMapping(&quot;/welcome&quot;)    public String welcome() {        return service.retrieveWelcomeMessage();    }}</code></pre><p>测试的时候，只需要更改配置文件，将WelcomeService对应的实现改为MockWelcomeServiceImpl即可：</p><pre><code>&lt;bean name=&quot;WelcomeService&quot; class=&quot;XXX.XXX.XXX.service.impl.MockWelcomeServiceImpl&quot;/&gt;</code></pre><p>这种方式对业务代码没有任何侵入，它有效的实现松耦合，大家都知道紧耦合的代码是业务发展的噩梦；同时，Spring IOC提供的远不止这些，如通过单例减少创建无用的对象，通过延迟加载优化初始化成本等<br>当然，Spring 的核心功能远不知这些，如：</p><pre><code>Spring AOPSpring JDBCSpring MVCSpring ORMSpring JMSSpring Test</code></pre><p>其实不通过Spring框架依然可以实现这些功能特定，但是Spring 提供了更优雅的抽象接口以方便对这些功能的组装，同时又给予每个具体实现以灵活的配置；另外，基于Spring，你可以方便的与其他框架进行集成，如hibernate，ibatis等，Spring官方的原则是绝不重复造轮子，有好的解决方案只需要通过Spring进行集成即可。纵览Spring的结构，你会发现Spring Framework 本身并未提供太多具体的功能，它主要专注于让你的项目代码组织更加优雅，使其具有极好的灵活性和扩展性，同时又能通过Spring集成业界优秀的解决方案，想了解Spring的核心实现机制可参考tiny spring 项目</p><h2 id="什么是Spring-MVC？它解决了什么问题？"><a href="#什么是Spring-MVC？它解决了什么问题？" class="headerlink" title="什么是Spring MVC？它解决了什么问题？"></a>什么是Spring MVC？它解决了什么问题？</h2><p>Spring MVC是Spring的一部分，Spring 出来以后，大家觉得很好用，于是按照这种模式设计了一个 MVC框架（一些用Spring 解耦的组件），主要用于开发WEB应用和网络接口，它是Spring的一个模块，通过Dispatcher Servlet, ModelAndView 和 View Resolver，让应用开发变得很容易，一个典型的Spring MVC应用开发分为下面几步：<br>首先通过配置文件声明Dispatcher Servlet：</p><pre><code>&lt;servlet&gt;    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;    &lt;servlet-class&gt;com.qgd.oms.web.common.mvc.OmsDispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;/WEB-INF/applicationContext.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><p>通过配置文件声明servlet详情，如MVC resource，data source，bean等</p><pre><code>&lt;mvc:resources mapping=&quot;/css/**/*&quot; location=&quot;/static/css/&quot; cache-period=&quot;21600&quot;/&gt;&lt;mvc:resources mapping=&quot;/js/**/*&quot; location=&quot;/static/js/&quot; cache-period=&quot;21600&quot;/&gt;&lt;mvc:resources mapping=&quot;/views/**/*.html&quot; location=&quot;/static/views/&quot; cache-period=&quot;21600&quot;/&gt;&lt;mvc:resources mapping=&quot;/fonts/**/*&quot; location=&quot;/static/fonts/&quot;/&gt;&lt;mvc:resources mapping=&quot;/ueditor/**/*&quot; location=&quot;/static/js/lib/ueditor/&quot;/&gt;&lt;mvc:resources mapping=&quot;/img/**/*&quot; location=&quot;/static/img/&quot;/&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp2.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;    &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot;/&gt;    &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;    &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt;    &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;    &lt;property name=&quot;validationQuery&quot; value=&quot;${jdbc.validationQuery}&quot;/&gt;    &lt;property name=&quot;maxTotal&quot; value=&quot;10&quot;/&gt;    &lt;property name=&quot;minIdle&quot; value=&quot;5&quot;/&gt;    &lt;property name=&quot;maxIdle&quot; value=&quot;10&quot;/&gt;    &lt;property name=&quot;defaultAutoCommit&quot; value=&quot;true&quot;/&gt;    &lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot;/&gt;    &lt;property name=&quot;testOnBorrow&quot; value=&quot;true&quot;/&gt;    &lt;property name=&quot;poolPreparedStatements&quot; value=&quot;true&quot;/&gt;    &lt;property name=&quot;maxOpenPreparedStatements&quot; value=&quot;50&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;configService&quot; class=&quot;com.qgd.oms.web.common.service.ConfigService&quot;&gt;    &lt;property name=&quot;configStore&quot;&gt;        &lt;bean class=&quot;com.qgd.oms.web.common.service.impl.DbConfigStore&quot;&gt;            &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;                &lt;property name=&quot;taskScheduler&quot; ref=&quot;defaultScheduler&quot;/&gt;            &lt;property name=&quot;refreshInterval&quot; value=&quot;30000&quot;/&gt;        &lt;/bean&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><p>若需添加其它功能，如security，则需添加对应配置：<br>    <http pattern="/css/**/*" security="none"><br>    <http pattern="/js/**/*" security="none"><br>    <http pattern="/views/**/*.html" security="none"><br>    <http pattern="/fonts/**/*" security="none"><br>    <http pattern="/ueditor/**/*" security="none"><br>    <http pattern="/img/**/*" security="none"></http></http></http></http></http></http></p><pre><code>&lt;http use-expressions=&quot;true&quot; entry-point-ref=&quot;omsAuthenticationEntryPoint&quot;&gt;    &lt;logout logout-url=&quot;/omsmc/authentication/logout/*&quot; success-handler-ref=&quot;omsLogoutSuccessHandler&quot;&gt;&lt;/logout&gt;    &lt;intercept-url pattern=&apos;/omsmc/authentication/login*&apos; access=&quot;permitAll&quot; /&gt;    &lt;intercept-url pattern=&apos;/ms/**/*&apos; access=&quot;permitAll&quot; /&gt;    &lt;intercept-url pattern=&apos;/**&apos; access=&quot;authenticated&quot; /&gt;    &lt;!--&lt;security:form-login /&gt;--&gt;    &lt;custom-filter ref=&quot;omsUsernamePasswordAuthenticationFilter&quot; position=&quot;FORM_LOGIN_FILTER&quot; /&gt;    &lt;remember-me services-ref=&quot;omsRememberMeServices&quot; key=&quot;yfboms&quot;/&gt;    &lt;csrf disabled=&quot;true&quot;/&gt;&lt;/http&gt;</code></pre><p>增加业务代码，如controller，service，model等，最后生成war包，通过容器进行启动</p><h2 id="什么是Spring-Boot？它解决了什么问题？"><a href="#什么是Spring-Boot？它解决了什么问题？" class="headerlink" title="什么是Spring Boot？它解决了什么问题？"></a>什么是Spring Boot？它解决了什么问题？</h2><p>初期的Spring通过代码加配置的形式为项目提供了良好的灵活性和扩展性，但随着Spring越来越庞大，其配置文件也越来越繁琐，太多复杂的xml文件也一直是Spring被人诟病的地方，特别是近些年其他简洁的WEB方案层出不穷，如基于Python或Node.Js，几行代码就能实现一个WEB服务器，对比起来，大家渐渐觉得Spring那一套太过繁琐，此时，Spring社区推出了Spring Boot，它的目的在于实现自动配置，降低项目搭建的复杂度，如需要搭建一个接口服务，通过Spring Boot，几行代码即可实现，请看代码示例：</p><pre><code>//引入spring-boot-starter-web依赖&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;//声明Spring Boot应用，直接写业务逻辑即可@Controller@SpringBootApplicationpublic class MockServerApplication {    @RequestMapping(&quot;/hi&quot;)    @ResponseBody    String home() {        return &quot;how are you!&quot;;    }    public static void main(String[] args) {        SpringApplication.run(MockServerApplication.class, args);    }}</code></pre><p>你甚至都不用额外的WEB容器，直接生成jar包执行即可，因为spring-boot-starter-web模块中包含有一个内置tomcat，可以直接提供容器使用；基于Spring Boot，不是说原来的配置没有了，而是Spring Boot有一套默认配置，我们可以把它看做比较通用的约定，而Spring Boot遵循的也是约定优于配置原则，同时，如果你需要使用到Spring以往提供的各种复杂但功能强大的配置功能，Spring Boot一样支持<br>在Spring Boot中，你会发现你引入的所有包都是starter形式，如：</p><p>spring-boot-starter-web-services，针对SOAP Web Services</p><p>spring-boot-starter-web，针对Web应用与网络接口</p><p>spring-boot-starter-jdbc，针对JDBC</p><p>spring-boot-starter-data-jpa，基于hibernate的持久层框架</p><p>spring-boot-starter-cache，针对缓存支持<br>等等</p><p>Spring Boot对starter的解释如下：</p><p><strong><em>Starters are a set of convenient dependency descriptors that you can include in your application. You get a one-stop-shop for all the Spring and related technology that you need, without having to hunt through sample code and copy paste loads of dependency descriptors. For example, if you want to get started using Spring and JPA for database access, just include the spring-boot-starter-data-jpa dependency in your project, and you are good to go</em></strong></p><p>这句话的译意为：</p><p><strong><em>Starters是一系列极其方便的依赖描述，通过在你的项目中包含这些starter，你可以一站式获得你所需要的服务，而无需像以往那样copy各种示例配置及代码，然后调试，真正做到开箱即用；比如你想使用Spring JPA进行数据操作，只需要在你的项目依赖中引入spring-boot-starter-data-jpa即可</em></strong></p><h2 id="Spring，Spring-MVC，Spring-Boot-三者比较"><a href="#Spring，Spring-MVC，Spring-Boot-三者比较" class="headerlink" title="Spring，Spring MVC，Spring Boot 三者比较"></a>Spring，Spring MVC，Spring Boot 三者比较</h2><p>三者专注的领域不同，解决的问题也不一样；总的来说，Spring 就像一个大家族，有众多衍生产品例如 Boot，Security，JPA等等。但他们的基础都是Spring 的 IOC 和 AOP，IOC提供了依赖注入的容器，而AOP解决了面向切面的编程，然后在此两者的基础上实现了其他衍生产品的高级功能；Spring MVC是基于 Servlet 的一个 MVC 框架，主要解决 WEB 开发的问题，因为 Spring 的配置非常复杂，各种xml，properties处理起来比较繁琐。于是为了简化开发者的使用，Spring社区创造性地推出了Spring Boot，它遵循约定优于配置，极大降低了Spring使用门槛，但又不失Spring原本灵活强大的功能</p><p><a href="https://upload-images.jianshu.io/upload_images/4185175-a0a50bf022178e1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/667" target="_blank" rel="noopener">https://upload-images.jianshu.io/upload_images/4185175-a0a50bf022178e1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/667</a></p><h2 id="Resource和-Autowired的区别？"><a href="#Resource和-Autowired的区别？" class="headerlink" title="@Resource和@Autowired的区别？"></a>@Resource和@Autowired的区别？</h2><p>@Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。</p><h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3><p>两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。</p><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><h4 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h4><p>@Autowired为Spring提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;只按照byType注入。</p><pre><code>public class TestServiceImpl {    // 下面两种@Autowired只要使用一种即可    @Autowired    private UserDao userDao; // 用于字段上    @Autowired    public void setUserDao(UserDao userDao) { // 用于属性的方法上        this.userDao = userDao;    }}</code></pre><p>  @Autowired注解是<strong>按照类型（byType）装配</strong>依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。如下：</p><pre><code>public class TestServiceImpl {    @Autowired    @Qualifier(&quot;userDao&quot;)    private UserDao userDao;}</code></pre><h4 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h4><p>@Resource默认按照ByName自动注入，<strong><em> 是JDK1.6支持的注解，按照名称进行装配，</em></strong><br>由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。</p><pre><code>public class TestServiceImpl {    // 下面两种@Resource只要使用一种即可    @Resource(name=&quot;userDao&quot;)    private UserDao userDao; // 用于字段上    @Resource(name=&quot;userDao&quot;)    public void setUserDao(UserDao userDao) { // 用于属性的setter方法上        this.userDao = userDao;    }}</code></pre><p>  注：最好是将@Resource放在setter方法上，因为这样更符合面向对象的思想，通过set、get去操作属性，而不是直接去操作属性。</p><h5 id="Resource装配顺序："><a href="#Resource装配顺序：" class="headerlink" title="@Resource装配顺序："></a>@Resource装配顺序：</h5><p><strong><em> ①如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。</em></strong></p><p><strong><em> ②如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。</em></strong></p><p><strong><em> ③如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。</em></strong></p><p><strong><em> ④如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。</em></strong></p><pre><code>@Resource的作用相当于@Autowired，只不过@Autowired按照byType自动注入。</code></pre><h1 id="Mac-OS-Linux命令查询网络端口占用情况，查找-杀死进程"><a href="#Mac-OS-Linux命令查询网络端口占用情况，查找-杀死进程" class="headerlink" title="Mac OS/Linux命令查询网络端口占用情况，查找/杀死进程"></a>Mac OS/Linux命令查询网络端口占用情况，查找/杀死进程</h1><h2 id="netstat命令"><a href="#netstat命令" class="headerlink" title="netstat命令"></a>netstat命令</h2><pre><code>netstat -an | grep 3306</code></pre><p>3306替换成需要grep的端口号</p><h2 id="lsof命令"><a href="#lsof命令" class="headerlink" title="lsof命令"></a>lsof命令</h2><p>通过list open file命令可以查看到当前打开文件，在linux中所有事物都是以文件形式存在，包括网络连接及硬件设备。</p><pre><code>lsof -i:80</code></pre><p>-i参数表示网络链接，:80指明端口号，该命令会同时列出PID，方便kill</p><p>查看所有进程监听的端口</p><pre><code>sudo lsof -i -P | grep -i &quot;listen&quot;</code></pre><h2 id="ps-A-grep-进程名"><a href="#ps-A-grep-进程名" class="headerlink" title="ps -A|grep [进程名]"></a>ps -A|grep [进程名]</h2><p>找PID： ps -A|grep [进程名]</p><h2 id="kill-PID"><a href="#kill-PID" class="headerlink" title="kill [PID]"></a>kill [PID]</h2><p>杀进程：kill [PID]<br>参考资料：</p><p>【1】<a href="https://www.jianshu.com/p/42620a0a2c33" target="_blank" rel="noopener">https://www.jianshu.com/p/42620a0a2c33</a></p><p>【2】<a href="https://www.cnblogs.com/think-in-java/p/5474740.html" target="_blank" rel="noopener">https://www.cnblogs.com/think-in-java/p/5474740.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;阐述Spring，Spring MVC，Spring Boot 三者的原理和区别。学习笔记II中涉及到对@Resource和@Autowired的区别做了解释。&lt;br&gt;对用命令查询网络端口占用情况，查找/杀死进程做了回顾性的复习。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年7月" scheme="http://yoursite.com/categories/2019%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot学习笔记II</title>
    <link href="http://yoursite.com/2019/07/19/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0II/"/>
    <id>http://yoursite.com/2019/07/19/SpringBoot学习笔记II/</id>
    <published>2019-07-19T03:23:12.000Z</published>
    <updated>2019-07-30T08:40:01.329Z</updated>
    
    <content type="html"><![CDATA[<p>总结整理在学习SpringBoot的过程中遇到的问题和解决方案。</p><a id="more"></a><h1 id="JPA任务："><a href="#JPA任务：" class="headerlink" title="JPA任务："></a>JPA任务：</h1><p>在Merchant表中完成一个JPA项目的增删改查,并在test/java/com.example.std.java.demo/DemoApplicationTests中进行测试</p><h1 id="Mybatis任务："><a href="#Mybatis任务：" class="headerlink" title="Mybatis任务："></a>Mybatis任务：</h1><p>1.在Merchant表中完成一个Mybatis项目的增删改查,并在test/java/com.example.std.java.demo/DemoApplicationTests中进行测试<br>2.使用Mybatis注册商户，根据商编（MerchantNO）查询商户，修改商户状态，从外部能查询，Controller调service，再调dto（写注释，包括每个dto属性是做什么的,DTO中只需要写要从外部传入的属性，写日志）</p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="建表注意事项："><a href="#建表注意事项：" class="headerlink" title="建表注意事项："></a>建表注意事项：</h2><p>创建数据访问接口userRepository建在dao层中。</p><p>社区版的Intellij IDEA可以直接在文件夹上右键New-&gt;Jpa Entities即可自动创建实体。</p><p>对数据库对增删改查可以直接写在test文件夹下的DemoApplicationTest中，每次执行时只需要Run相应的test函数即可，不需全部Run一遍。</p><h2 id="常见问题application-properties文件解析错误："><a href="#常见问题application-properties文件解析错误：" class="headerlink" title="常见问题application.properties文件解析错误："></a>常见问题application.properties文件解析错误：</h2><p>application.yml和application.properties的格式是不同的，注意更改格式。</p><h2 id="导入目录时格式混乱"><a href="#导入目录时格式混乱" class="headerlink" title="导入目录时格式混乱"></a>导入目录时格式混乱</h2><p>打开本地项目时直接open pom.xml会自动解析项目</p><p>如果从git上拉分支则注意：<br>Intellij IDEA从git上拉取分支时要选择import project from external model，<br>在import Project一栏时Root directory栏目中不要默认目录，否则会找不到pom.xml，要选择clone下来的目录中的demo文件</p><h2 id="Maven配置问题"><a href="#Maven配置问题" class="headerlink" title="Maven配置问题"></a>Maven配置问题</h2><p>File-&gt;Preference-&gt;Maven中的Maven home directory; User settings file; Local repository三个根目录中都要选择公司私有的maven目录</p><h2 id="Debug问题"><a href="#Debug问题" class="headerlink" title="Debug问题"></a>Debug问题</h2><p>IDEA中错误信息以堆栈形式输出，所以最下面的错误是第一个错误，优先看</p><h2 id="hibernate-dialect配置问题"><a href="#hibernate-dialect配置问题" class="headerlink" title="hibernate.dialect配置问题"></a>hibernate.dialect配置问题</h2><p>启动时报错：<br>Access to DialectResolutionInfo cannot be null when ‘hibernate.dialect’ not set</p><p>hibernate.dialect是为了更好的适配各种数据库，针对每种数据库都指定方言dialect，将各类数据库Oracle，Mysql等不同类型等语法<br>转换成hibernate能理解等统一的格式。</p><h3 id="解决方法1"><a href="#解决方法1" class="headerlink" title="解决方法1:"></a>解决方法1:</h3><p>这个问题花了很长时间，google到的方法都没有作用，最后确定原因是demo/config/JpaConfig文件中的factory.setJpaProperties(jpaProperties.getProperties());一行中Jpaproperties读到的属性为空，</p><p>demo/config/JpaConfig文件如下</p><pre><code>package com.example.std.java.demo.config;import javax.annotation.Resource;import javax.persistence.EntityManagerFactory;import javax.sql.DataSource;import com.example.std.java.demo.config.jpa.HibernateConfig;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;import org.springframework.boot.autoconfigure.orm.jpa.JpaProperties;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import org.springframework.data.jpa.repository.config.EnableJpaRepositories;import org.springframework.orm.jpa.DefaultJpaDialect;import org.springframework.orm.jpa.JpaTransactionManager;import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;import org.springframework.transaction.PlatformTransactionManager;import org.springframework.transaction.annotation.EnableTransactionManagement;import java.util.Map;import java.util.Properties;@Configuration@EnableTransactionManagement@EnableJpaRepositories(    entityManagerFactoryRef = &quot;entityManagerFactory&quot;,    transactionManagerRef = &quot;platformTransactionManager&quot;,    basePackages = {&quot;com.example.std.java.demo.dao.jpa&quot;}) //设置Repository所在位置public class JpaConfig {    @Resource    private HibernateConfig jpaProperties;    @Resource(name = &quot;testDataSource&quot;)    private DataSource dataSource;    @Primary    @Bean(name = &quot;entityManagerFactory&quot;)    public EntityManagerFactory entityManagerFactory() {        HibernateJpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter();        LocalContainerEntityManagerFactoryBean factory = new LocalContainerEntityManagerFactoryBean();        factory.setJpaVendorAdapter(vendorAdapter);        factory.setPackagesToScan(&quot;com.example.std.java.demo.entity.jpa&quot;);        factory.setDataSource(dataSource);//数据源        factory.setJpaProperties(jpaProperties.getProperties());        factory.afterPropertiesSet();//在完成了其它所有相关的配置加载以及属性设置后,才初始化        return factory.getObject();    }    /**     * 配置事物管理器     * @return     */    @Bean(name = &quot;platformTransactionManager&quot;)    @Primary    public PlatformTransactionManager platformTransactionManager() {        JpaTransactionManager jpaTransactionManager = new JpaTransactionManager();        jpaTransactionManager.setEntityManagerFactory(this.entityManagerFactory());        return jpaTransactionManager;    }}</code></pre><p>为了能传进属性，在demo/config/jpa/HibernateConfig文件中增加属性properties</p><pre><code>package com.example.std.java.demo.config.jpa;import lombok.Data;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Configuration;import java.util.Properties;@Configuration@ConfigurationProperties(prefix = &quot;user.jpa&quot;)@Datapublic class HibernateConfig {    Properties properties;}</code></pre><p>其中注解中的的@ConfigurationProperties(prefix = “user.jpa”)指的是resources/local/application.yml中的数据源配置</p><pre><code>spring:  datasource:    test:      jdbcUrl: jdbc:mysql://10.143.248.78:3306/java_demo?autoReconnect=true&amp;characterEncoding=UTF8&amp;&amp;parseTime=True      type: org.apache.tomcat.jdbc.pool.DataSource      username: root      password: mojiti      testOnBorrow: true      validationQuery: &quot;select version()&quot;      driver-class-name: com.mysql.jdbc.Driver    shangtongdai:      jdbcUrl: jdbc:mysql://10.143.248.78:3306/shangtongdai?autoReconnect=true&amp;characterEncoding=UTF8&amp;&amp;parseTime=True      type: org.apache.tomcat.jdbc.pool.DataSource      username: root      password: mojiti      testOnBorrow: true      validationQuery: &quot;select version()&quot;      driver-class-name: com.mysql.jdbc.Driveruser:  jpa:    properties:      hibernate:        hbm2ddlauto: update        dialect: org.hibernate.dialect.MySQL5InnoDBDialect</code></pre><h3 id="解决方法2"><a href="#解决方法2" class="headerlink" title="解决方法2:"></a>解决方法2:</h3><p>也可以直接将properties固定的写在JpaConfig中</p><pre><code>@Primary @Bean(name = &quot;entityManagerFactory&quot;) public EntityManagerFactory entityManagerFactory() {     HibernateJpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter();     LocalContainerEntityManagerFactoryBean factory = new LocalContainerEntityManagerFactoryBean();     factory.setJpaVendorAdapter(vendorAdapter);     factory.setPackagesToScan(&quot;com.example.std.java.demo.entity.jpa&quot;);     factory.setDataSource(dataSource);//数据源     Properties properties=new Properties();     properties.setProperty(&quot;hibernate.dialect&quot;,&quot;org.hibernate.dialect.MySQL5InnoDBDialect&quot;);     factory.setJpaProperties(properties);     factory.afterPropertiesSet();//在完成了其它所有相关的配置加载以及属性设置后,才初始化     return factory.getObject(); }</code></pre><h2 id="新建SpringBoot项目启动时往往会报错"><a href="#新建SpringBoot项目启动时往往会报错" class="headerlink" title="新建SpringBoot项目启动时往往会报错"></a>新建SpringBoot项目启动时往往会报错</h2><h3 id="常见错误类型："><a href="#常见错误类型：" class="headerlink" title="常见错误类型："></a>常见错误类型：</h3><pre><code>***************************APPLICATION FAILED TO START***************************Description:Failed to configure a DataSource: &apos;url&apos; attribute is not specified and no embedded datasource could be configured.Reason: Failed to determine a suitable driver class</code></pre><h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><p>配置Mybatis时出现的错误，原因是因为添加了数据库组件，所以autoconfig会去读取数据源但配置，而新建项目还没有配置数据源，所以会导致异常出现。</p><p>方法1:需要先在target/pom.xml中去掉对数据库的依赖，即去掉下面这段。</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;2.1.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>方法2:也可以在启动类的@EnableAutoConfiguration或@SpringBootApplication中添加exclude = {DataSourceAutoConfiguration.class}，排除此类的autoconfig。启动以后就可以正常运行。修改如下：</p><pre><code>@SpringBootApplication(exclude= DataSourceAutoConfiguration.class)public class DemoApplication {    public static void main(String[] args) {        SpringApplication.run(DemoApplication.class, args);    }}</code></pre><h3 id="常见错误类型：-1"><a href="#常见错误类型：-1" class="headerlink" title="常见错误类型："></a>常见错误类型：</h3><pre><code>Error starting ApplicationContext. To display the conditions report re-run your application with &apos;debug&apos; enabled.</code></pre><h3 id="解决办法：-1"><a href="#解决办法：-1" class="headerlink" title="解决办法："></a>解决办法：</h3><p>这是配置JPA时出现的错误，错误原因同上，同理可知解决方法。</p><h2 id="多数据源问题："><a href="#多数据源问题：" class="headerlink" title="多数据源问题："></a>多数据源问题：</h2><p>在多数据源情况下，会出现所链接的数据库中没有需要查询的表，而该表在另一个数据库中，此时在demo/config/JpaConfig文件中找到</p><pre><code>@Qualifier(&quot;testDataSource&quot;)private DataSource dataSource;</code></pre><p>改为<br>    @Resource(name = “testDataSource”)<br>    private DataSource dataSource;<br>或者@Autowired注解来选择数据源，其中dataSource等来自于demo/config/DbAutoConfiguration</p><pre><code>package com.example.std.java.demo.config;import javax.sql.DataSource;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.jdbc.DataSourceBuilder;import org.springframework.context.annotation.AdviceMode;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.transaction.annotation.EnableTransactionManagement;/** * @Description: db数据库自动化配置 * @Author: * @Date: 2019-07-11 14:50 */@Configuration@EnableTransactionManagement(mode = AdviceMode.ASPECTJ)public class DbAutoConfiguration {    @Bean(&quot;testDataSource&quot;)    @ConfigurationProperties(prefix = &quot;spring.datasource.test&quot;)    public DataSource dataSource() {        return DataSourceBuilder.create().build();    }    @Bean(&quot;dataSource&quot;)    @ConfigurationProperties(prefix = &quot;spring.datasource.shangtongdai&quot;)    public DataSource dataSource2() {        return DataSourceBuilder.create().build();    }}</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1]<a href="https://stackoverflow.com/questions/40738818/illegalargumentexception-at-least-one-jpa-metamodel-must-be-present?newreg=1d1be5c9c5a04ec2878d9fc8237bbda5" target="_blank" rel="noopener">https://stackoverflow.com/questions/40738818/illegalargumentexception-at-least-one-jpa-metamodel-must-be-present?newreg=1d1be5c9c5a04ec2878d9fc8237bbda5</a><br>[2]]<a href="https://blog.csdn.net/zsg88/article/details/80780281" target="_blank" rel="noopener">https://blog.csdn.net/zsg88/article/details/80780281</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结整理在学习SpringBoot的过程中遇到的问题和解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年7月" scheme="http://yoursite.com/categories/2019%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot学习笔记I</title>
    <link href="http://yoursite.com/2019/07/17/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0I/"/>
    <id>http://yoursite.com/2019/07/17/SpringBoot学习笔记I/</id>
    <published>2019-07-17T07:30:12.000Z</published>
    <updated>2019-07-25T01:49:45.216Z</updated>
    
    <content type="html"><![CDATA[<p>总结整理在学习SpringBoot的过程中遇到的问题和解决方案（我又双叒要开始更新博客了）。</p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>忙忙碌碌的暑假结束了，虽然可以算得上十分充实，不过在学习新知识提高自己这一方面却做的并不尽如人意，之前制定的学习计划大都被其它各种计划所取代，<br>从屈指可数的博客更新就能看出来。<br>随着步入职场，自我学习变得更加重要，之前这段时间的状态不能再继续下去。写了这么多中心思想就一条：“我又双叒要开始更新博客了”。</p><h2 id="SSM框架"><a href="#SSM框架" class="headerlink" title="SSM框架"></a>SSM框架</h2><p>Java中常用的有三大框架SSM（Spring，SpringMVC和Mybatis），其中Spring是一个轻量级的控制反转（IoC）和面向切面（AOP）的容器框架，<br>是为了解决企业应用开发的复杂性而创建的。而SpringMVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。<br>SpringMVC分离了控制器、模型对象、分派器以及处理程序对象的角色，这种分离让它们更容易进行定制。<br>MyBatis本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。<br>MyBatis是一个基于Java的持久层框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects（DAO）MyBatis<br>消除了几乎所有的JDBC代码和参数的手工设置以及结果集的检索。<br>MyBatis 使用简单的 XML或注解用于配置和原始映射，将接口和 Java 的POJOs（Plain Old Java Objects，普通的 Java对象）映射成数据库中的记录。</p><h2 id="SpringBoot简介"><a href="#SpringBoot简介" class="headerlink" title="SpringBoot简介"></a>SpringBoot简介</h2><p>而我们之后要学习的SpringBoot则可以快速构建容易配置的 Spring 应用程序，使用SpringBoot可以减少配置的工作量。SpringBoot网站对它的简洁介绍如下：</p><p>“ Spring Boot 使您能轻松地创建独立的、生产级的、基于 Spring 且能直接运行的应用程序。我们对 Spring 平台和第三方库有自己的看法，<br>所以您从一开始只会遇到极少的麻烦。”</p><p>刚开始学习SpringBoot时可以从HelloWorld开始，此处网上例程很多，不再赘述。</p><h1 id="概念剖析"><a href="#概念剖析" class="headerlink" title="概念剖析"></a>概念剖析</h1><p>首先学习几个Java开发中会遇到的概念。<br><img src="assets/markdown-img-paste-20190718153319935.png" alt="https://img-blog.csdn.net/20170816144718827"></p><h2 id="1-DAO-data-access-object-数据访问对象"><a href="#1-DAO-data-access-object-数据访问对象" class="headerlink" title="1.DAO[data access object]数据访问对象"></a>1.DAO[data access object]数据访问对象</h2><p>一个面向对象的数据库接口，负责持久层的操作，为业务层提供接口，主要用来封装对数据库的访问，常见操作无外乎 CURD。我们也可以认为一个 DAO 对应一个 POJO 的对象，它位于业务逻辑与数据库资源中间，可以结合 PO 对数据库进行相关的操作。<br>此处注意对数据访问不仅仅指的是对数据库的访问。 假如A系统调用B系统的服务获取数据，这时候A系统对B系统访问数据对象的封装也可以称为DAO。</p><h2 id="2-DTO-data-transfer-object-数据传输对象"><a href="#2-DTO-data-transfer-object-数据传输对象" class="headerlink" title="2.DTO[data transfer object]数据传输对象"></a>2.DTO[data transfer object]数据传输对象</h2><p>主要用于远程调用等需要大量传输对象的地方，比如我们有一个交易订单表，含有20个字段，那么其对应的PO就有20个属性，但我们的页面上只需要显示5个字段，因此没有必要把整个 PO 对象传递给客户端，这时我们只需把仅有 5 个属性的 DTO 把结果传递给客户端即可，而且如果用这个对象来对应界面的显示对象，那此时它的身份就转为VO。使用DTO的好处有两个，一是能避免传递过多的无用数据，提高数据的传输速度；二是能隐藏后端的表结构。常见的用法是：将请求的数据或属性组装成一个RequestDTO，再将响应的数据或属性组装成一个 ResponseDTO.</p><h2 id="3-PO-persistant-object-持久层对象"><a href="#3-PO-persistant-object-持久层对象" class="headerlink" title="3.PO[persistant object]持久层对象"></a>3.PO[persistant object]持久层对象</h2><p>由一组属性和属性的get和set方法组成，最简单的 PO 就是对应数据库中某个表中的一条记录（也就是说，我们可以将数据库表中的一条记录理解为一个持久层对象），多个记录可以用 PO 的集合，PO 中应该不包含任何对数据库的操作。PO 的属性是跟数据库表的字段一一对应的，此外 PO 对象需要实现序列化接口。因对象-关系映射（Object-Relational Mapping，简称ORM）框架的广泛使用而被引入到JavaEE项目设计中。</p><h2 id="4-BO-bussiness-object-业务对象"><a href="#4-BO-bussiness-object-业务对象" class="headerlink" title="4.BO[bussiness object]业务对象"></a>4.BO[bussiness object]业务对象</h2><p>简单的真实世界的软件抽象，通常位于中间层。BO 的主要作用是把业务逻辑封装为一个对象，这个对象可以包括一个或多个其它的对象。举一个求职简历的例子，每份简历都包括教育经历、项目经历等，我们可以让教育经历和项目经历分别对应一个 PO，这样在我们建立对应求职简历的 BO 对象处理简历的时候，让每个 BO 都包含这些 PO 即可。</p><h2 id="5-VO-value-object-值对象"><a href="#5-VO-value-object-值对象" class="headerlink" title="5.VO[value object]值对象"></a>5.VO[value object]值对象</h2><p>通常用于业务层之间的数据传递，和 PO 一样也是仅仅包含数据而已，但 VO 应该是抽象出的业务对象，可以和表对应，也可以不对应，这根据业务的需要。 如果锅碗瓢盆分别为对应的业务对象的话，那么整个碗柜就是一个值对象。此外，VO 也可以称为页面对象，如果称为页面对象的话，那么它所代表的将是整个页面展示层的对象，也可以由需要的业务对象进行组装而来。</p><h2 id="6-POJO-plain-ordiary-java-object-简单java对象"><a href="#6-POJO-plain-ordiary-java-object-简单java对象" class="headerlink" title="6.POJO[plain ordiary java object] 简单java对象"></a>6.POJO[plain ordiary java object] 简单java对象</h2><p>实际就是普通的 JavaBeans，是为了避免和 EJB（Enterprise JavaBean）混淆所创造的简称。POJO 实质上可以理解为简单的实体类，其中有一些属性及其getter和setter方法的类，没有业务逻辑，也不允许有业务方法，也不能携带有connection之类的方法。POJO 是 JavaEE 世界里面最灵活的对象，在简单系统中，如果从数据库到页面展示都是 POJO 的话，它可以是 DTO；如果从数据库中到业务处理中都是 POJO 的话，它可以是 BO；如果从数据库到整个页面的展示的话，它也可以是 VO.</p><h2 id="7-Entity-实体"><a href="#7-Entity-实体" class="headerlink" title="7.Entity 实体"></a>7.Entity 实体</h2><p>对应数据库中的表，简单的理解为一个表对应一个实体，以交易订单表Order为例，若该表中含有20个字段，那么这个OrderEntity对象里面也要含有20个对应的属性。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】详述 PO VO BO DTO DAO 和 POJO 的概念及区别<a href="https://blog.csdn.net/qq_35246620/article/details/77247427" target="_blank" rel="noopener">https://blog.csdn.net/qq_35246620/article/details/77247427</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结整理在学习SpringBoot的过程中遇到的问题和解决方案（我又双叒要开始更新博客了）。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年7月" scheme="http://yoursite.com/categories/2019%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Linux配置问题小结</title>
    <link href="http://yoursite.com/2019/06/03/Linux%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2019/06/03/Linux配置问题小结/</id>
    <published>2019-06-03T04:47:45.000Z</published>
    <updated>2019-07-18T04:07:56.272Z</updated>
    
    <content type="html"><![CDATA[<p>记录Linux配置问题的解决方案，在Ubuntu 18.04中安装terminator 并在右键菜单中添加open in termintor;解决了搜狗输入法在Ubuntu 18.04 中无法安装和安装后无法使用的问题;解决了Linux下无线网卡rtl8821CE/rtl8723ce驱动无法驱动的问题。</p><a id="more"></a><h2 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h2><ol><li>Ubuntu 18.04 安装terminator 并在右键菜单中添加open in termintor</li><li>解决了搜狗输入法在Ubuntu 18.04 中无法安装和安装后无法使用的问题</li><li>解决了Linux下无线网卡rtl8821CE/rtl8723ce驱动无法驱动的问题。</li></ol><h2 id="Terminator安装和右键菜单添加解决方案"><a href="#Terminator安装和右键菜单添加解决方案" class="headerlink" title="Terminator安装和右键菜单添加解决方案"></a>Terminator安装和右键菜单添加解决方案</h2><p>  题外话，安利下terminator，是Linux环境下一款非常赞的命令行管理工具，前段时间微软宣布推出名为Windows Terminal的新款命令行工具，在个人看来也是姗姗来迟的将terminator能实现的功能在windows中实现了。</p><p>  安装terminator</p><pre><code>sudo apt install terminator</code></pre><p>  网上大多用dconf系统配置编辑器将terminator设为默认，但在我的系统中这样在文件位置中右键打开时还是只能打开默认的终端，用起来很不方便，直到找到了这种方法（<a href="https://blog.csdn.net/bestBT/article/details/81221378）。" target="_blank" rel="noopener">https://blog.csdn.net/bestBT/article/details/81221378）。</a><br>  安装Nautilus-actions</p><pre><code>sudo add-apt-repository ppa:daniel-marynicz/filemanager-actionssudo apt-get install filemanager-actions-nautilus-extension</code></pre><p>使用fma-config-tool 来配置。<br>1.新建动作，在action（动作）界面中勾选第二项Display item in location context menu。在Context label中输入想写的名字“在Terminator中打开”。<br>2.在Command（命令）界面中输入路径/usr/bin/terminator，参数中输入–working-directory=%d/%b。<br>3.这样操作完在terminator中打开还在右键的二级菜单中，所以点右上角齿轮标志（编辑您的首选项），在运行时首选项-》Nautilus菜单布局中取消勾选Create a root “FileManager-Actions” menu，这样就可以愉快的使用Terminator了。</p><h2 id="搜狗拼音输入法安装问题解决方案"><a href="#搜狗拼音输入法安装问题解决方案" class="headerlink" title="搜狗拼音输入法安装问题解决方案"></a>搜狗拼音输入法安装问题解决方案</h2><p>一开始嫌麻烦所以用Linux自带的Ibus系统下的输入法，但各种问题实在忍不了，所以还是装了搜狗拼音法，中间遇到几个问题只找到这个靠谱的解决方法（<a href="https://ywnz.com/linuxjc/1476.html）。" target="_blank" rel="noopener">https://ywnz.com/linuxjc/1476.html）。</a></p><p>在根据指导方法安装搜狗拼音输入法后，会遇到很多依赖问题，一路折腾后会发现搜狗拼音依赖的fcitx-libs-qt这个包在ubuntu18.04的源里面是不存在的。替代品似乎是libfcitx-qt0，但也很难搞。</p><h3 id="下载旧版"><a href="#下载旧版" class="headerlink" title="下载旧版"></a>下载旧版</h3><p>搜狗官方的最新版（sogoupinyin_2.2.0.0102_amd64.deb）是不能用的，原因不作深究。需要下载一个旧版本（sogoupinyin_2.1.0.0086_amd64.deb）。<br>将该deb包放置于一个空目录。</p><h3 id="创建软件包目录"><a href="#创建软件包目录" class="headerlink" title="创建软件包目录"></a>创建软件包目录</h3><pre><code>mkdir -p extract/DEBIAN</code></pre><h3 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h3><pre><code>dpkg-deb -x sogoupinyin_2.1.0.0086_amd64.deb extract/dpkg-deb -e sogoupinyin_2.1.0.0086_amd64.deb extract/DEBIAN</code></pre><h3 id="修改control文件"><a href="#修改control文件" class="headerlink" title="修改control文件"></a>修改control文件</h3><p>用任意文本编辑器打开extract/DEBIAN/control 找到Depends行，删除fcitx-libs和fcitx-libs-qt，保存退出。<br>其中要找的Depends行长这个样子</p><pre><code>Depends: fcitx (&gt;= 1:4.2.8.3-3~), fcitx-frontend-gtk2, fcitx-frontend-gtk3, fcitx-frontend-qt4, fcitx-module-kimpanel, im-config, libopencc2 | libopencc1, lsb-release, unzip, x11-utils, libc6 (&gt;= 2.8), libgcc1 (&gt;= 1:4.1.1), libgdk-pixbuf2.0-0 (&gt;= 2.22.0), libglib2.0-0 (&gt;= 2.16.0), libidn11 (&gt;= 1.13), libnotify4 (&gt;= 0.7.0), libqt4-dbus (&gt;= 4:4.8.0), libqt4-declarative (&gt;= 4:4.8.0), libqt4-network (&gt;= 4:4.8.0), libqtcore4 (&gt;= 4:4.8.0), libqtgui4 (&gt;= 4:4.8.0), libstdc++6 (&gt;= 4.6), libx11-6, zlib1g (&gt;= 1:1.2.0)</code></pre><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><pre><code>mkdir builddpkg-deb -b extract/ build/</code></pre><p>执行完毕build目录下会生成一个新的deb包。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>先彻底卸载掉搜狗输入法，并删除以下配置文件：</p><p>.sogouinput</p><p>.config/fcitx</p><p>.config/sogou-qimpanel</p><p>.config/SogouPY</p><p>.config/SogouPY.users</p><p>.config/fcitx-qimpanel</p><p>然后安装我们重新打包的输入法即可。重启之后，搜狗输入法恢复正常。<br>最后要记得在设置-》区域和语言-》管理已安装的语言-》语言支持-》语言-》键盘输入法系统中选择Fcitx系统，因为搜狗输入法等都是在Fcitx系统框架下的。</p><h2 id="LINUX下无线网卡rtl8821CE-rtl8723de驱动无法驱动解决办法"><a href="#LINUX下无线网卡rtl8821CE-rtl8723de驱动无法驱动解决办法" class="headerlink" title="LINUX下无线网卡rtl8821CE/rtl8723de驱动无法驱动解决办法"></a>LINUX下无线网卡rtl8821CE/rtl8723de驱动无法驱动解决办法</h2><h3 id="1-确保linux内核版本大于-4-14"><a href="#1-确保linux内核版本大于-4-14" class="headerlink" title="1. 确保linux内核版本大于 4.14"></a>1. 确保linux内核版本大于 4.14</h3><p>  如何查看linux 内核版本 ：终端 uname -sr</p><p>  如果内核版本低于 4.14：升级linux内核 ubuntu可以参照 <a href="https://www.linuxidc.com/Linux/2017-03/141940.html" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2017-03/141940.html</a></p><p>  升级完记得重启</p><h3 id="2-下载linux中8821CE-rtl8723de的驱动源码"><a href="#2-下载linux中8821CE-rtl8723de的驱动源码" class="headerlink" title="2. 下载linux中8821CE/rtl8723de的驱动源码"></a>2. 下载linux中8821CE/rtl8723de的驱动源码</h3><p>git原地址（rtl8821CE）：<a href="https://github.com/endlessm/linux/tree/master/drivers/net/wireless/rtl8821ce" target="_blank" rel="noopener">https://github.com/endlessm/linux/tree/master/drivers/net/wireless/rtl8821ce</a></p><p>git原地址（rtl8723de）：<a href="https://github.com/endlessm/linux/tree/master/drivers/net/wireless/rtl8723de" target="_blank" rel="noopener">https://github.com/endlessm/linux/tree/master/drivers/net/wireless/rtl8723de</a></p><p>或者本地下载 <a href="https://free-1253146430.cos.ap-shanghai.myqcloud.com/rtl8821ce.zip" target="_blank" rel="noopener">https://free-1253146430.cos.ap-shanghai.myqcloud.com/rtl8821ce.zip</a></p><p>（rtl8723de 的话 自己 去git上下吧）</p><h3 id="3-编译驱动"><a href="#3-编译驱动" class="headerlink" title="3.编译驱动"></a>3.编译驱动</h3><p>  <strong><em>解压rtl8821ce.zip</em></strong></p><p>  <strong><em>修改文件Makefile</em></strong></p><pre><code>export TopDIR ?= $(srctree)/drivers/net/wireless/rtl8821ce</code></pre><p>从这行 “export TopDIR ?= 后面改成当前目录 例如我的：</p><pre><code>export TopDIR ?= /home/horsun/Downloads/rtl8821ce</code></pre><p><strong><em>保存修改</em></strong></p><p>  分别进行：</p><pre><code>makesudo make installsudo modprobe -a 8821ce</code></pre><p>遇到问题</p><pre><code>modprobe: ERROR: could not insert &apos;8812au&apos;: Exec format error</code></pre><p><strong><em>执行</em></strong></p><pre><code>make cleanmakesudo make installsudo modprobe 8812au</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录Linux配置问题的解决方案，在Ubuntu 18.04中安装terminator 并在右键菜单中添加open in termintor;解决了搜狗输入法在Ubuntu 18.04 中无法安装和安装后无法使用的问题;解决了Linux下无线网卡rtl8821CE/rtl8723ce驱动无法驱动的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年6月" scheme="http://yoursite.com/categories/2019%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>操作系统基础概念I</title>
    <link href="http://yoursite.com/2019/06/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5I/"/>
    <id>http://yoursite.com/2019/06/02/操作系统基础概念I/</id>
    <published>2019-06-02T02:42:12.000Z</published>
    <updated>2019-07-18T04:08:31.095Z</updated>
    
    <content type="html"><![CDATA[<p>总结操作系统基础概念</p><a id="more"></a><h2 id="（一）请分别简单说一说进程和线程以及它们的区别。"><a href="#（一）请分别简单说一说进程和线程以及它们的区别。" class="headerlink" title="（一）请分别简单说一说进程和线程以及它们的区别。"></a>（一）请分别简单说一说进程和线程以及它们的区别。</h2><h3 id="1-进程是资源分配的基本单位"><a href="#1-进程是资源分配的基本单位" class="headerlink" title="1.进程是资源分配的基本单位"></a>1.进程是资源分配的基本单位</h3><p>进程是具有一定功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源调度和分配的基本单位。</p><h3 id="2-线程是独立调度的基本单位"><a href="#2-线程是独立调度的基本单位" class="headerlink" title="2.线程是独立调度的基本单位"></a>2.线程是独立调度的基本单位</h3><p>线程是进程的实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。<br>一个进程可以有多个线程，多个线程也可以并发执行</p><h3 id="3-区别"><a href="#3-区别" class="headerlink" title="3.区别"></a>3.区别</h3><h4 id="I-拥有资源"><a href="#I-拥有资源" class="headerlink" title="I 拥有资源"></a>I 拥有资源</h4><p>进程是资源分配的基本单位，而线程不拥有资源，线程可以访问隶属雨进程的资源</p><h4 id="II-调度"><a href="#II-调度" class="headerlink" title="II 调度"></a>II 调度</h4><p>线程是独立调度的基本单位，在同一进程中，线程切换不会引起进程切换。从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</p><h4 id="III-系统开销"><a href="#III-系统开销" class="headerlink" title="III 系统开销"></a>III 系统开销</h4><p>在创建或撤销进程时，系统都要为之分配或者回收资源（内存空间，I/O设备），开销远大于创建或者撤销线程的开销。在进行进程切换时，涉及当前执行进程CPU环境的保存及新调度进程CPU环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</p><h4 id="IV-通信方面"><a href="#IV-通信方面" class="headerlink" title="IV 通信方面"></a>IV 通信方面</h4><p>线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助IPC。</p><p>如果你对进程或者线程不太熟悉，建议阅读：<a href="https://link.zhihu.com/?target=http%3A//www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="noopener">进程与线程的一个简单解释</a></p><h2 id="（二）线程同步的方式有哪些？"><a href="#（二）线程同步的方式有哪些？" class="headerlink" title="（二）线程同步的方式有哪些？"></a>（二）线程同步的方式有哪些？</h2><h3 id="互斥量："><a href="#互斥量：" class="headerlink" title="互斥量："></a>互斥量：</h3><p>采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。</p><h3 id="信号量："><a href="#信号量：" class="headerlink" title="信号量："></a>信号量：</h3><p>它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</p><h3 id="事件（信号）："><a href="#事件（信号）：" class="headerlink" title="事件（信号）："></a>事件（信号）：</h3><p>通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</p><p>如果你对线程同步IPC的方式不太熟悉，建议阅读：<a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/lebronjames/archive/2010/08/11/1797702.html" target="_blank" rel="noopener">线程同步的几种方式</a></p><h2 id="（三）进程的通信方式有哪些？"><a href="#（三）进程的通信方式有哪些？" class="headerlink" title="（三）进程的通信方式有哪些？"></a>（三）进程的通信方式有哪些？</h2><p>主要分为：管道（普通管道PIPE 、流管道（s_pipe）、命名管道（name_pipe））、系统IPC（包括消息队列、信号量、共享存储）、套接字（SOCKET）</p><h3 id="1-管道"><a href="#1-管道" class="headerlink" title="1.管道"></a>1.管道</h3><p><strong><em>普通管道PIPE</em></strong></p><p>管道是通过调用匹配pipe函数创建的，fd[0]用于读，fd[1]用于写。</p><pre><code>#include&lt;unistd.h&gt;int pipe(int fd[2]);</code></pre><p>管道具有以下限制：</p><p>  （1）只支持半双工通信（单向交替传输）</p><p>  （2）只能在父子进程中使用（只能在具有亲缘关系的进程间流动，进程的亲缘关系通常是父子进程）</p><p><strong><em>命名管道FIFO</em></strong></p><p>  也是半双工的通信方式，它去除了管道只能在父子进程中使用的限制，允许无亲缘关系的进程间进行通信</p><pre><code>#include&lt;sys/stat.h&gt;int mkfifo(const char *path, mode_t mode);int mkfifoat(int fd,const char *path,mode_t mode);</code></pre><p>FIFO常用于客户-服务器应用程序中，FIFO用作汇聚点，在客户进程和服务器进程之间传递数据。</p><h3 id="2-系统IPC"><a href="#2-系统IPC" class="headerlink" title="2.系统IPC"></a>2.系统IPC</h3><p><strong><em>消息队列</em></strong></p><p>是消息的链表，存放在内核中并由消息队列标识符标识。<br>相比于FIFO，消息队列有以下优点：</p><p>  （1）消息队列能够独立于读写进程的存在，从而避免了FIFO中同步管道的打开和关闭时可能产生的困难。</p><p>  （2）避免了FIFO的同步阻塞问题，不需要进程自己提供同步方法。</p><p>  （3）读进程可以根据消息类型有选择地接受消息，而不像FIFO那样只能默认地接收。</p><p><strong><em>信号量</em></strong></p><p>是一个计数器,用于为多个进程提供共享对象的访问。</p><p><strong><em>信号</em></strong></p><p>是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p><p><strong><em>共享内存</em></strong></p><p>允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种IPC。</p><p>需要使用信号量用来同步对共享存储的访问。</p><p>多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外XSL共享内存不是使用文件，而是使用内存的匿名段。</p><h3 id="3-套接字"><a href="#3-套接字" class="headerlink" title="3.套接字"></a>3.套接字</h3><p>与其它通信机制不同的是，它可用于不同机器间的进程通信。</p><p>如果你对进程的通信方式不太熟悉，建议阅读： <a href="https://blog.csdn.net/yufaw/article/details/7409596" target="_blank" rel="noopener">进程间的几种通信方式</a></p><h2 id="（四）什么是缓冲区溢出？有什么危害？其原因是什么？"><a href="#（四）什么是缓冲区溢出？有什么危害？其原因是什么？" class="headerlink" title="（四）什么是缓冲区溢出？有什么危害？其原因是什么？"></a>（四）什么是缓冲区溢出？有什么危害？其原因是什么？</h2><p>缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。</p><p>危害有以下两点：</p><p>程序崩溃，导致拒绝额服务<br>跳转并且执行一段恶意代码<br>造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入。</p><p>如果你想深入了解缓冲区溢出，推荐阅读：<a href="http://www.cnblogs.com/fanzhidongyzby/archive/2013/08/10/3250405.html" target="_blank" rel="noopener">缓冲区溢出攻击</a></p><h2 id="（五）什么是死锁？死锁产生的条件？"><a href="#（五）什么是死锁？死锁产生的条件？" class="headerlink" title="（五）什么是死锁？死锁产生的条件？"></a>（五）什么是死锁？死锁产生的条件？</h2><p>在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。</p><p>通俗的讲就是两个或多个进程无限期的阻塞、相互等待的一种状态。</p><p><strong><em>死锁产生的四个条件</em></strong>（有一个条件不成立，则不会产生死锁）</p><p><strong><em>互斥</em></strong>：一个资源一次只能被一个进程使用,每个资源要么已经分配给了一个进程，要么就是可用的。</p><p><strong><em>请求与保持</em></strong>(也叫作占有和等待)：一个进程因请求资源而阻塞时，对已获得资源保持不放</p><p><strong><em>不可剥夺</em></strong>（不可抢占）：进程获得的资源，在未完全使用完之前，不能强行剥夺，其只能被占有它的资源显式地释放。</p><p><strong><em>循环等待</em></strong>（环路等待）：若干进程之间形成一种头尾相接的环形等待资源关系</p><p><strong><em>四种解锁方法</em></strong></p><p><strong><em>鸵鸟策略</em></strong>假装问题根本没发生，因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。<br>当发生死锁时不会对用户造成多大的影响，或发生概率很低时可采用鸵鸟策略。<br>Unix，Linux和Windows等多数操作系统处理死锁的方法就是忽略它。</p><p><strong><em>死锁检测与死锁恢复</em></strong><br><img src="lock.png" alt=""></p><p><strong><em>死锁预防</em></strong></p><p><strong><em>死锁避免</em></strong></p><p>如果对死锁还不是太熟悉，建议阅读：<a href="http://www.cnblogs.com/Jessy/p/3540724.html" target="_blank" rel="noopener">死锁产生的原因和解锁的方法</a></p><h2 id="（六）进程有哪几种状态？"><a href="#（六）进程有哪几种状态？" class="headerlink" title="（六）进程有哪几种状态？"></a>（六）进程有哪几种状态？</h2><p>就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源<br>运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数<br>阻塞状态： 进程等待某种条件，在条件满足之前无法执行<br>如果你对进程的几种状态以及中间的装换不太了解，建议阅读：<a href="http://www.cnblogs.com/Jessy/p/3540724.html" target="_blank" rel="noopener">进程的三种状态及转换</a></p><h2 id="（七）分页和分段有什么区别？"><a href="#（七）分页和分段有什么区别？" class="headerlink" title="（七）分页和分段有什么区别？"></a>（七）分页和分段有什么区别？</h2><p>段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 ；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的。<br>段的大小不固定，有它所完成的功能决定；页大大小固定，由系统决定<br>段向用户提供二维地址空间；页向用户提供的是一维地址空间<br>段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。<br>如果你对分页和分段还不太了解，建议阅读：<a href="https://blog.csdn.net/wangrunmin/article/details/7967293" target="_blank" rel="noopener">分段和分页</a></p><h2 id="（八）-操作系统中进程调度策略有哪几种？"><a href="#（八）-操作系统中进程调度策略有哪几种？" class="headerlink" title="（八） 操作系统中进程调度策略有哪几种？"></a>（八） 操作系统中进程调度策略有哪几种？</h2><p>FCFS(先来先服务)，优先级，时间片轮转，多级反馈</p><p>如果你想深入的了解这几种调度策略，推荐阅读：<a href="https://blog.csdn.net/luyafei_89430/article/details/12971171" target="_blank" rel="noopener">几个常用的操作系统进程调度算法</a></p><h2 id="（九）说一说进程同步有哪几种机制。"><a href="#（九）说一说进程同步有哪几种机制。" class="headerlink" title="（九）说一说进程同步有哪几种机制。"></a>（九）说一说进程同步有哪几种机制。</h2><p>原子操作、信号量机制、自旋锁管程、会合、分布式系统</p><p>如果你想深入的了解这几种机制，推荐阅读： <a href="http://www.cnblogs.com/sonic4x/archive/2011/07/05/2098036.html" target="_blank" rel="noopener">进程同步的几种机制</a></p><h2 id="（十）说一说死锁的处理基本策略和常用方法。"><a href="#（十）说一说死锁的处理基本策略和常用方法。" class="headerlink" title="（十）说一说死锁的处理基本策略和常用方法。"></a>（十）说一说死锁的处理基本策略和常用方法。</h2><p>解决死锁的基本方法如下：</p><p>预防死锁、避免死锁、检测死锁、解除死锁</p><p>解决四多的常用策略如下：</p><p>鸵鸟策略、预防策略、避免策略、检测与解除死锁<br>如果你对死锁的处理策略不是太熟悉，推荐阅读：<a href="https://blog.csdn.net/bxyill/article/details/8237339" target="_blank" rel="noopener">产生死锁的原因和必要条件+解决死锁的基本方法</a></p><h2 id="（十一）进程通信和进程同步的区别"><a href="#（十一）进程通信和进程同步的区别" class="headerlink" title="（十一）进程通信和进程同步的区别"></a>（十一）进程通信和进程同步的区别</h2><p>进程通信是一种手段，是在进程间传输信息<br>进程同步是一种目的，是控制多个进程按照一定的顺序执行<br>为了达到进程同步的目的，需要让进程进行通信，传输进程同步所需的信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结操作系统基础概念&lt;/p&gt;
    
    </summary>
    
      <category term="2019年6月" scheme="http://yoursite.com/categories/2019%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Operating System" scheme="http://yoursite.com/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客多终端更新问题</title>
    <link href="http://yoursite.com/2019/05/28/Hexo%E5%8D%9A%E5%AE%A2%E5%A4%9A%E7%BB%88%E7%AB%AF%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/05/28/Hexo博客多终端更新问题/</id>
    <published>2019-05-28T11:19:45.000Z</published>
    <updated>2019-07-18T04:07:43.663Z</updated>
    
    <content type="html"><![CDATA[<p>记录Hexo博客多终端备份更新问题的解决方案</p><a id="more"></a><h2 id="问题介绍"><a href="#问题介绍" class="headerlink" title="问题介绍"></a>问题介绍</h2><p>很多人会把Hexo生成出来的静态网站放到GitHub Pages来进行托管。一般发布Hexo博客的流程是，首先在本地搭建Hexo的环境，编写新文章，然后利用hexo deploy来发布到Git。那么对于本地的Hexo的原始文件怎么管理呢？如果换电脑了怎么办？如果没有对原始文件进行备份，突然有一天你的本地环境挂了导致源文件丢失，那就很悲催了。可以用Dropbox或者其他方案来对源文件进行备份，但是每次更新完博客，需要备份好源文件，然后执行hexo deploy进行发布，非常麻烦。这就是写博客常遇到的多终端备份和更新问题。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>目前找到的解决方法有两种：</p><h3 id="1-持续集成"><a href="#1-持续集成" class="headerlink" title="1.持续集成"></a>1.持续集成</h3><p>用两个GitHub Repo，一个Repo放Hexo的源文件（这里称之为Source Repo），另一个Repo放Hexo生成出来的静态网站（这里称之为Content Repo），然后使用AppVeyor做持续集成。每当需要更新博客，只需要更新Source Repo，AppVeyor会自动生成静态网站并push到Content Repo，一气呵成，版本控制完全由GitHub完成，也不需要手动deploy。参见（<a href="https://formulahendry.github.io/2016/12/04/hexo-ci/）。" target="_blank" rel="noopener">https://formulahendry.github.io/2016/12/04/hexo-ci/）。</a><br>但是这种方法比较麻烦，AppVeyor的注册和使用都很不顺畅。所以我推荐下面的方法。</p><h3 id="2-git分支进行多终端工作"><a href="#2-git分支进行多终端工作" class="headerlink" title="2.git分支进行多终端工作"></a>2.git分支进行多终端工作</h3><p>这种方法是利用git的分支进行多终端工作，可以参见（<a href="http://fangzh.top）" target="_blank" rel="noopener">http://fangzh.top）</a><br>每次打开不一样的电脑，只需要进行简单的配置和在github上把文件同步下来，可以无缝操作。而且这种方法对新手比较友好。</p><h3 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h3><p>由于hexo d上传部署到github的其实是hexo编译后的文件，是用来生成网页的，不包含源文件。也就是上传的是在本地目录里自动生成的.deploy_git里面。其他文件 ，包括我们写在source 里面的，和配置文件，主题文件，都没有上传到github<br>所以可以利用git的分支管理，将源文件上传到github的另一个分支即可。</p><h3 id="上传分支"><a href="#上传分支" class="headerlink" title="上传分支"></a>上传分支</h3><p>首先，先在github上新建一个hexo分支，然后在这个仓库的settings中，选择默认分支为hexo分支（这样每次同步的时候就不用指定分支，比较方便）。<br>然后在本地的任意目录下，打开git bash，</p><pre><code>git clone git@github.com:liyiye012/liyiye012.github.io.git</code></pre><p>将其克隆到本地，因为默认分支已经设成了hexo，所以clone时只clone了hexo。接下来在克隆到本地的liyiye012.github.io中，把除了.git 文件夹外的所有文件都删掉 把之前我们写的博客源文件全部复制过来，除了.deploy_git。<br>这里应该说一句，复制过来的源文件应该有一个.gitignore，用来忽略一些不需要的文件，如果没有的话，自己新建一个，在里面写上如下，表示这些类型文件不需要git：.DS_Store</p><pre><code>Thumbs.dbdb.json*.lognode_modules/public/.deploy*/</code></pre><p>注意，如果之前克隆过theme中的主题文件，那么应该把主题文件中的.git文件夹删掉，因为git不能嵌套上传，最好是显示隐藏文件，检查一下有没有，否则上传的时候会出错，导致你的主题文件无法上传，这样你的配置在别的电脑上就用不了了。而后</p><pre><code>git add .git commit –m &quot;add branch&quot;git push</code></pre><p>这样就上传完了，可以去github上看一看hexo分支有没有上传上去，其中node_modules、public、db.json已经被忽略掉了，没有关系，不需要上传的，因为在别的电脑上需要重新输入命令安装 。</p><p>这样就上传完了。</p><h3 id="更换电脑操作"><a href="#更换电脑操作" class="headerlink" title="更换电脑操作"></a>更换电脑操作</h3><p>跟之前的环境搭建一样，安装git</p><pre><code>sudo apt-get install git</code></pre><p>设置git全局邮箱和用户名</p><pre><code>git config --global user.name &quot;yourgithubname&quot;git config --global user.email &quot;yourgithubemail&quot;</code></pre><p>设置ssh key</p><pre><code>ssh-keygen -t rsa -C &quot;youremail&quot;#生成后填到github和coding上（有coding平台的话）#验证是否成功ssh -T git@github.comssh -T git@git.coding.net #(有coding平台的话)</code></pre><p>安装nodejs</p><pre><code>sudo apt-get install nodejssudo apt-get install npm</code></pre><p>安装hexo  </p><pre><code>sudo npm install hexo-cli -g</code></pre><p>但是已经不需要初始化了，直接在任意文件夹下，git clone git@………………<br>然后进入克隆到的文件夹：cd xxx.github.io</p><pre><code>npm installnpm install hexo-deployer-git --save</code></pre><p>生成，部署：</p><pre><code>hexo ghexo d</code></pre><p>然后就可以愉快的开始写新博客了</p><pre><code>hexo new newpage</code></pre><p>Tips:不要忘了，每次写完最好都把源文件上传一下</p><pre><code>git add .git commit –m &quot;xxxx&quot;git push</code></pre><p>如果是在已经编辑过的电脑上，已经有clone文件夹了，那么，每次只要和远端同步一下就行了</p><pre><code>git pull</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录Hexo博客多终端备份更新问题的解决方案&lt;/p&gt;
    
    </summary>
    
      <category term="2019年5月" scheme="http://yoursite.com/categories/2019%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow入门-Mnist手写数字识别</title>
    <link href="http://yoursite.com/2018/11/22/TensorFlow%E5%85%A5%E9%97%A8-Mnist%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/"/>
    <id>http://yoursite.com/2018/11/22/TensorFlow入门-Mnist手写数字识别/</id>
    <published>2018-11-22T08:30:34.000Z</published>
    <updated>2019-07-18T04:08:04.114Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下Mnist手写数字识别的练习过程，网上已经有很多类似的教程比如(<a href="https://blog.csdn.net/simple_the_best/article/details/75267863，https://blog.csdn.net/cqrtxwd/article/details/79028264），" target="_blank" rel="noopener">https://blog.csdn.net/simple_the_best/article/details/75267863，https://blog.csdn.net/cqrtxwd/article/details/79028264），</a> 但会有些许问题，所以做修改后整理一下<br>当然最好的入门教程还是TensorFlow中文社区（<a href="http://www.tensorfly.cn" target="_blank" rel="noopener">www.tensorfly.cn</a>)</p><a id="more"></a><h2 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h2><p> 可在<a href="http://yann.lecun.com/exdb/mnist/下载mnist数据集，包含" target="_blank" rel="noopener">http://yann.lecun.com/exdb/mnist/下载mnist数据集，包含</a></p><pre><code>Training set images: train-images-idx3-ubyte.gz (9.9 MB, 解压后 47 MB, 包含 60,000 个样本)Training set labels: train-labels-idx1-ubyte.gz (29 KB, 解压后 60 KB, 包含 60,000 个标签)Test set images: t10k-images-idx3-ubyte.gz (1.6 MB, 解压后 7.8 MB, 包含 10,000 个样本)Test set labels: t10k-labels-idx1-ubyte.gz (5KB, 解压后 10 KB, 包含 10,000 个标签）</code></pre><p>MNIST 数据集来自美国国家标准与技术研究所, National Institute of Standards and Technology (NIST). 训练集 (training set) 由来自 250 个不同人手写的数字构成, 其中 50% 是高中学生, 50% 来自人口普查局 (the Census Bureau) 的工作人员. 测试集(test set) 也是同样比例的手写数字数据.<br>图片是以字节的形式进行存储, 我们需要把它们读取到 NumPy array 中, 以便训练和测试算法,载入数据</p><pre><code>import tensorflow as tffrom tensorflow.examples.tutorials.mnist import input_datamnist=input_data.read_data_sets(&quot;MNIST_data/&quot;,one_hot=True)import osimport structimport numpy as npdef load_mnist(path,kind=&apos;train&apos;):    labels_path=os.path.join(path,&apos;%s-labels-idx1-ubyte&apos;%kind)    images_path=os.path.join(path,&apos;%s-images-idx3-ubyte&apos;%kind)    with open(labels_path,&apos;rb&apos;) as lbpath:        magic,n=struct.unpack(&apos;&gt;II&apos;,lbpath.read(8))        labels=np.fromfile(lbpath,dtype=np.uint8)    with open(images_path,&apos;rb&apos;) as imgpath:        magic,num,rows,cols=struct.unpack(&apos;IIII&apos;,imgpath.read(16))        images=np.fromfile(imgpath,dtype=np.uint8).reshape(len(labels),784)    return images,labels</code></pre><p>load_mnist 函数返回两个数组, 第一个是一个 n x m 维的NumPy array(images), 这里的 n 是样本数(行数), m 是特征数(列数). 训练数据集包含 60,000 个样本, 测试数据集包含 10,000 样本. 在 MNIST 数据集中的每张图片由 28 x 28 个像素点构成, 每个像素点用一个灰度值表示. 在这里, 我们将 28 x 28 的像素展开为一个一维的行向量, 这些行向量就是图片数组里的行(每行 784 个值, 或者说每行就是代表了一张图片). load_mnist 函数返回的第二个数组(labels) 包含了相应的目标变量, 也就是手写数字的类标签(整数 0-9).这里对图片的读取方式做一些解释：</p><pre><code>magic, n = struct.unpack(&apos;&gt;II&apos;, lbpath.read(8))labels = np.fromfile(lbpath, dtype=np.uint8)</code></pre><p>看一下 MNIST 网站上对数据集的介绍:</p><pre><code>TRAINING SET LABEL FILE (train-labels-idx1-ubyte):[offset] [type]          [value]          [description]0000     32 bit integer  0x00000801(2049) magic number (MSB first)0004     32 bit integer  60000            number of items0008     unsigned byte   ??               label0009     unsigned byte   ??               label........xxxx     unsigned byte   ??               labelThe labels values are 0 to 9.</code></pre><p>我们首先读入 magic number, 它是一个文件协议的描述, 也是在我们调用 fromfile 方法将字节读入 NumPy array 之前在文件缓冲中的 item 数(n). 作为参数值传入 struct.unpack 的 &gt;II 有两个部分:</p><blockquote><p>: 这是指大端(用来定义字节是如何存储的); 如果你还不知道什么是大端和小端, Endianness 是一个非常好的解释. (关于大小端, 更多内容可见&lt;&lt;深入理解计算机系统 – 2.1 节信息存储&gt;&gt;)<br>I: 这是指一个无符号整数.</p></blockquote><p>通过执行下面的代码, 我们将会从刚刚解压 MNIST 数据集后的 mnist 目录下加载 60,000 个训练样本和 10,000 个测试样本.</p><h2 id="数据预览"><a href="#数据预览" class="headerlink" title="数据预览"></a>数据预览</h2><p>此时要将文件解压后放在MNIST_data文件夹下，可视化处理. 从 feature matrix 中将 784-像素值 的向量 reshape 为之前的 28*28 的形状, 然后通过 matplotlib 的 imshow 函数进行绘制:</p><pre><code>import matplotlib.pyplot as pltX_train,y_train=load_mnist(&quot;MNIST_data/&quot;,kind=&apos;train&apos;)fig, ax = plt.subplots(    nrows=2,    ncols=5,    sharex=True,    sharey=True, )ax = ax.flatten()for i in range(10):    img = X_train[y_train == i][0].reshape(28, 28)    ax[i].imshow(img, cmap=&apos;Greys&apos;, interpolation=&apos;nearest&apos;)ax[0].set_xticks([])ax[0].set_yticks([])#plt.tight_layout()plt.show()</code></pre><p>可以看到一个 2*5 的图片, 里面分别是 0-9 单个数字的图片.还可以绘制某一数字的多个样本图片, 来看一下这些手写样本到底有多不同:</p><pre><code>fig,ax=plt.subplots(    nrows=5,    ncols=5,    sharex=True,    sharey=True,)ax=ax.flatten()for i in range(25):    img=X_train[y_train==7][i].reshape(28,28)    ax[i].imshow(img,cmap=&apos;Greys&apos;,interpolation=&apos;nearest&apos;)ax[0].set_xticks([])ax[0].set_yticks([])plt.show()</code></pre><p>我们也可以选择将 MNIST 图片数据和标签保存为 CSV 文件, 这样就可以在不支持特殊的字节格式的程序中打开数据集. 但是, 有一点要说明, CSV 的文件格式将会占用更多的磁盘空间, 如下所示:</p><pre><code>train_img.csv: 109.5 MBtrain_labels.csv: 120 KBtest_img.csv: 18.3 MBtest_labels: 20 KB</code></pre><p>如果我们打算保存这些 CSV 文件, 在将 MNIST 数据集加载入 NumPy array 以后, 我们应该执行下列代码:</p><pre><code>np.savetxt(&apos;train_img.csv&apos;, X_train,           fmt=&apos;%i&apos;, delimiter=&apos;,&apos;)np.savetxt(&apos;train_labels.csv&apos;, y_train,           fmt=&apos;%i&apos;, delimiter=&apos;,&apos;)np.savetxt(&apos;test_img.csv&apos;, X_test,           fmt=&apos;%i&apos;, delimiter=&apos;,&apos;)np.savetxt(&apos;test_labels.csv&apos;, y_test,           fmt=&apos;%i&apos;, delimiter=&apos;,&apos;)</code></pre><p>一旦将数据集保存为 CSV 文件, 我们也可以用 NumPy 的 genfromtxt 函数重新将它们加载入程序中:</p><pre><code>X_train = np.genfromtxt(&apos;train_img.csv&apos;,                        dtype=int, delimiter=&apos;,&apos;)y_train = np.genfromtxt(&apos;train_labels.csv&apos;,                        dtype=int, delimiter=&apos;,&apos;)X_test = np.genfromtxt(&apos;test_img.csv&apos;,                       dtype=int, delimiter=&apos;,&apos;)y_test = np.genfromtxt(&apos;test_labels.csv&apos;,                       dtype=int, delimiter=&apos;,&apos;)</code></pre><p>不过, 从 CSV 文件中加载 MNIST 数据将会显著发给更长的时间, 因此如果可能的话, 还是建议维持数据集原有的字节格式.</p><h2 id="神经网络结构"><a href="#神经网络结构" class="headerlink" title="神经网络结构"></a>神经网络结构</h2><p>流程分为三步：<br>1.构建卷积神经网络结构<br>2.构建loss function，配置寻优器<br>3.训练，测试<br>在源码中使用了两个卷积层+池化层，最后接上两个全连接层。<br>第一层卷积使用了32个3x3x1的卷积核，步长为1，边界处理方式为“SAME”（卷积的输入和输出保持相同尺寸），激活函数为ReLu，后接一个2x2的池化层，方式为最大化池化；<br>第二层卷积使用50个3x3x32的卷积核，步长为1，边界处理方式为“SAME”，激活函数为ReLu，后接一个2x2的池化层，方式为最大化池化；<br>第一层全连接层：使用1024个神经元，激活函数为ReLu。<br>第二层全连接层：使用10个神经元，激活函数为Softmax,用于输出结果</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><pre><code>import tensorflow as tffrom tensorflow.examples.tutorials.mnist import input_data#读取数据mnist=input_data.read_data_sets(&apos;MNIST_data/&apos;,one_hot=True)sess=tf.InteractiveSession()#构建卷积神经网络结构#自定义卷积函数def conv2d(x,w):    return tf.nn.conv2d(x,w,strides=[1,1,1,1],padding=&apos;SAME&apos;)#自定义池化函数def max_pool_2x2(x):    return tf.nn.max_pool(x,ksize=[1,2,2,1],strides=[1,2,2,1],padding=&apos;SAME&apos;)#设置占位符，尺寸为样本输入和输出的尺寸x=tf.placeholder(tf.float32,[None,784])y_=tf.placeholder(tf.float32,[None,10])x_img=tf.reshape(x,[-1,28,28,1])#设置第一个卷积层和池化层w_conv1=tf.Variable(tf.truncated_normal([3,3,1,32],stddev=0.1))b_conv1=tf.Variable(tf.constant(0.1,shape=[32]))h_conv1=tf.nn.relu(conv2d(x_img,w_conv1)+b_conv1)h_pool1=max_pool_2x2(h_conv1)#设置第二个卷积层和池化层w_conv2=tf.Variable(tf.truncated_normal([3,3,32,50],stddev=0.1))b_conv2=tf.Variable(tf.constant(0.1,shape=[50]))h_conv2=tf.nn.relu(conv2d(h_pool1,w_conv2)+b_conv2)h_pool2=max_pool_2x2(h_conv2)#设置第一个全连接层w_fc1=tf.Variable(tf.truncated_normal([7*7*50,1024],stddev=0.1))b_fc1=tf.Variable(tf.constant(0.1,shape=[1024]))h_pool2_flat=tf.reshape(h_pool2,[-1,7*7*50])h_fc1=tf.nn.relu(tf.matmul(h_pool2_flat,w_fc1)+b_fc1)#dropout(随机权重失活)keep_prob=tf.placeholder(tf.float32)h_fc1_drop=tf.nn.dropout(h_fc1,keep_prob)#设置第二个全连接层w_fc2=tf.Variable(tf.truncated_normal([1024,10]))b_fc2=tf.Variable(tf.constant(0.1,shape=[10]))y_out=tf.nn.softmax(tf.matmul(h_fc1_drop,w_fc2)+b_fc2)#建立loss function,为交叉熵loss=tf.reduce_mean(-tf.reduce_sum(y_*tf.log(y_out),reduction_indices=[1]))#配置Adam优化器，学习速率为1e-4train_step=tf.train.AdamOptimizer(1e-4).minimize(loss)#建立正确率计算表达式correct_prediction=tf.equal(tf.argmax(y_out,1),tf.argmax(y_,1))accuracy=tf.reduce_mean(tf.cast(correct_prediction,tf.float32))#训练tf.global_variables_initializer().run()for i in range(20000):    batch = mnist.train.next_batch(50)    if i%100==0:        train_accuracy=accuracy.eval(feed_dict={x:batch[0],y_:batch[1],keep_prob:1})        print(&quot;ste %d,train_accuracy=%g&quot; %(i,train_accuracy))    train_step.run(feed_dict={x:batch[0],y_:batch[1],keep_prob:0.5})#训练后用测试集进行测试，输出最终结果print(&quot;test_accuracy= %h&quot; %accuracy.eval(feed_dict={x:mnist.test.images,y_:mnist.test.labels,keep_prob:1}))</code></pre><h2 id="代码详解："><a href="#代码详解：" class="headerlink" title="代码详解："></a>代码详解：</h2><pre><code>#自定义卷积函数def conv2d(x,w):    return tf.nn.conv2d(x,w,strides=[1,1,1,1],padding=&apos;SAME&apos;)#自定义池化函数def max_pool_2x2(x):    return tf.nn.max_pool(x,ksize=[1,2,2,1],strides=[1,2,2,1],padding=&apos;SAME&apos;)</code></pre><p>卷积步长为1，如果要改为步长为2则strides=[1,2,2,1],对于二维图来说只有中间两个是有效的，使用‘SAME’的padding方法（即输出与输入保持相同尺寸，边界处少一两个像素则自动补上）；池化层的设置也类似，池化尺寸为2x2</p><pre><code>#设置占位符，尺寸为样本输入和输出的尺寸x=tf.placeholder(tf.float32,[None,784])y_=tf.placeholder(tf.float32,[None,10])x_img=tf.reshape(x,[-1,28,28,1])</code></pre><p>设置输入输出的占位符，占位符是向一个会话中喂数据的入口，因为在TensorFlow的使用中通过构建计算图来设计网络，而网络的运行计算则在会话中启动，这个过程我们无法直接介入，需要通过placeholder来对一个会话进行数据输入。<br>占位符设置好之后将x变形为28x28是矩阵形式（tf.reshape()函数)</p><pre><code>#设置第一个卷积层和池化层w_conv1=tf.Variable(tf.truncated_normal([3,3,1,32],stddev=0.1))b_conv1=tf.Variable(tf.constant(0.1,shape=[32]))h_conv1=tf.nn.relu(conv2d(x_img,w_conv1)+b_conv1)h_pool1=max_pool_2x2(h_conv1)#设置第二个卷积层和池化层w_conv2=tf.Variable(tf.truncated_normal([3,3,32,50],stddev=0.1))b_conv2=tf.Variable(tf.constant(0.1,shape=[50]))h_conv2=tf.nn.relu(conv2d(h_pool1,w_conv2)+b_conv2)h_pool2=max_pool_2x2(h_conv2)</code></pre><p>第一层卷积使用3x3x1的卷积核，一共有32个卷积核，权值使用方差为0.1的截断正态分布（最大值不超过方差两倍的分布）来初始化，偏置的初值设定为常数0.1。<br>第二层卷积核第一层类似，卷积核尺寸为3x3x32（32是通道数，因为上一层使用32个卷积核，所以这一层的通道数就变成了32），这一层一共使用了50个卷积核，其他设置与上一层相同。<br>每一层卷积完之后接上一个2x2的最大化池化操作</p><pre><code>#设置第一个全连接层w_fc1=tf.Variable(tf.truncated_normal([7*7*50,1024],stddev=0.1))b_fc1=tf.Variable(tf.constant(0.1,shape=[1024]))h_pool2_flat=tf.reshape(h_pool2,[-1,7*7*50])h_fc1=tf.nn.relu(tf.matmul(h_pool2_flat,w_fc1)+b_fc1)#dropout(随机权重失活)keep_prob=tf.placeholder(tf.float32)h_fc1_drop=tf.nn.dropout(h_fc1,keep_prob)#设置第二个全连接层w_fc2=tf.Variable(tf.truncated_normal([1024,10]))b_fc2=tf.Variable(tf.constant(0.1,shape=[10]))y_out=tf.nn.softmax(tf.matmul(h_fc1_drop,w_fc2)+b_fc2)</code></pre><p>卷积层之后就是两个全连接层，第一个全连接层有1024个神经元，现将卷积层得到的2x2输出展开成一长条，使用ReLu激活函数得到输出，输出为1024维。</p><p>Dropout：在这一层使用权值随机失活，对一些神经元突触连接进行强制的置零，这个trick可以防止神经网络过拟合。这里的dropout的保留比例是0.5，即随机的保留一半权值，删除另一半。dropout比例通过placeholder来设置，因为训练过程中需要dropout，但是在最后的测试过程中，我们有希望使用全部的权值，随意dropout的比例要能够改变，这里使用placeholder。</p><p>第二个全连接层有10个神经元，分别对应0-9这19个数字，和之前每层不同，这里使用的激活函数是softmax，softmax是以指数函数作为核函数的归一化操作，与一般归一化操作不同的是，指数函数能够放大一个分布内各个数值的差异，两级分布现象会更明显。</p><pre><code>#建立loss function,为交叉熵loss=tf.reduce_mean(-tf.reduce_sum(y_*tf.log(y_out),reduction_indices=[1]))#配置Adam优化器，学习速率为1e-4train_step=tf.train.AdamOptimizer(1e-4).minimize(loss)#建立正确率计算表达式correct_prediction=tf.equal(tf.argmax(y_out,1),tf.argmax(y_,1))accuracy=tf.reduce_mean(tf.cast(correct_prediction,tf.float32))</code></pre><p>建立loss function很重要，这里使用交叉熵作为loss，交叉熵用来衡量两个分布的相似程度。两个分布越接近，则交叉熵越小。<br>使用Adam优化器来最小化loss，配置学习速率为1e-4，然后建立正确率的计算表达式，tf.argmax(y_,1)函数用来返回其中最大的值的下标，tf.equal用来计算两个值是否相等，tf.cast()函数用来实现数据类型转换，tf.reduce_mean()用来求平均（得到正确率）</p><pre><code>#训练tf.global_variables_initializer().run()for i in range(20000):    batch = mnist.train.next_batch(50)    if i%100==0:        train_accuracy=accuracy.eval(feed_dict={x:batch[0],y_:batch[1],keep_prob:1})        print(&quot;ste %d,train_accuracy=%g&quot; %(i,train_accuracy))    train_step.run(feed_dict={x:batch[0],y_:batch[1],keep_prob:0.5})</code></pre><p>对网络进行训练，首先使用<code>tf.global_variables_initializer().run()</code>初始化所有数据，从mnist训练数据集中集中一次取50个样本作为一组训练，共进行20000组训练，每100次就输出一次该组数据上的正确率，进行训练计算的方式是<code>train_step.run(feed_dict={x:batch[0],y_:batch[1],keep_prob:0.5})</code><br>,通过feed_dict来对会话输送训练数据（以及其他一些想在计算过程中实时调整的参数，比如dropout比例）<br>这段代码中可以看到，训练时dropout的保留比例是0.5，测试时的保留比例是1.</p><pre><code>#训练后用测试集进行测试，输出最终结果print(&quot;test_accuracy= %h&quot; %accuracy.eval(feed_dict={x:mnist.test.images,y_:mnist.test.labels,keep_prob:1}))</code></pre><p>最后输入测试集进行测试验证</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下Mnist手写数字识别的练习过程，网上已经有很多类似的教程比如(&lt;a href=&quot;https://blog.csdn.net/simple_the_best/article/details/75267863，https://blog.csdn.net/cqrtxwd/article/details/79028264），&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/simple_the_best/article/details/75267863，https://blog.csdn.net/cqrtxwd/article/details/79028264），&lt;/a&gt; 但会有些许问题，所以做修改后整理一下&lt;br&gt;当然最好的入门教程还是TensorFlow中文社区（&lt;a href=&quot;http://www.tensorfly.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.tensorfly.cn&lt;/a&gt;)&lt;/p&gt;
    
    </summary>
    
      <category term="2018年11月" scheme="http://yoursite.com/categories/2018%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="TensorFlow" scheme="http://yoursite.com/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>235.Lowest Common Ancestor of a Binary Search Tree 二叉搜索树的最近公共祖先</title>
    <link href="http://yoursite.com/2018/10/30/235.Lowest%20Common%20Ancestor%20of%20a%20Binary%20Search%20Tree%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <id>http://yoursite.com/2018/10/30/235.Lowest Common Ancestor of a Binary Search Tree 二叉搜索树的最近公共祖先/</id>
    <published>2018-10-30T02:13:20.000Z</published>
    <updated>2019-07-18T06:30:25.299Z</updated>
    
    <content type="html"><![CDATA[<p> 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><a id="more"></a><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p><pre><code>     _______6______    /              \ ___2__          ___8__/      \        /      \0      _4       7       9      /  \      3   5</code></pre><p>示例 1:</p><pre><code>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8输出: 6解释: 节点 2 和节点 8 的最近公共祖先是 6。</code></pre><p>示例 2:</p><pre><code>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4输出: 2解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。说明:所有节点的值都是唯一的。p、q 为不同节点且均存在于给定的二叉搜索树中。</code></pre><h2 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h2><pre><code>/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {        if(root.val&gt;p.val &amp;&amp; root.val&gt;q.val){            return lowestCommonAncestor(root.left,p,q);        }        else if(root.val&lt;p.val &amp;&amp; root.val&lt;q.val){            return lowestCommonAncestor(root.right,p,q);        }else return root;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年10月" scheme="http://yoursite.com/categories/2018%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>Permutations全排列问题总结</title>
    <link href="http://yoursite.com/2018/10/11/Permutations%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/10/11/Permutations全排列问题总结/</id>
    <published>2018-10-11T02:33:14.000Z</published>
    <updated>2019-07-18T04:08:00.302Z</updated>
    
    <content type="html"><![CDATA[<p>总结几个常见的全排列问题<br>46.Permutations 全排列<br>47.PermutationsII 全排列II<br>31.Next Permutations 下一个排列<br>60.Permutation Sequence 第k个排列<br>266.Palindrome Permutation 回文排列<br>267.Palindrome PermutationII 回文排列II</p><a id="more"></a><h2 id="46-Permutations-全排列"><a href="#46-Permutations-全排列" class="headerlink" title="46.Permutations 全排列"></a>46.Permutations 全排列</h2><p>给定一个没有重复数字的序列，返回其所有可能的全排列。</p><p>示例:</p><pre><code>输入: [1,2,3]输出:[  [1,2,3],  [1,3,2],  [2,1,3],  [2,3,1],  [3,1,2],  [3,2,1]]</code></pre><h3 id="回溯思路"><a href="#回溯思路" class="headerlink" title="回溯思路"></a>回溯思路</h3><p>回溯的写法，每次交换nums里面的两个数字，经过回溯可以生成所有的排列情况</p><pre><code>class Solution {public:    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) {        vector&lt;vector&lt;int&gt;&gt; result;        permuteRecursive(nums,0,result);        return result;    }    void output(vector&lt;vector&lt;int&gt;&gt; result){        cout&lt;&lt;&quot;start to print&quot;&lt;&lt;endl;        for(int i=0;i&lt;result.size();i++){            for(int j=0;j&lt;result[i].size();j++){                cout&lt;&lt;result[i][j];            }cout&lt;&lt;endl;        }        cout&lt;&lt;&quot;end to print&quot;&lt;&lt;endl;    }    void permuteRecursive(vector&lt;int&gt; &amp;num,int begin,vector&lt;vector&lt;int&gt;&gt; &amp;result){        // cout&lt;&lt;&quot;begin=&quot;&lt;&lt;begin&lt;&lt;endl;        // cout&lt;&lt;&quot;   num=&quot;;        // for(int i=0;i&lt;num.size();i++) cout&lt;&lt;num[i]&lt;&lt;&quot; &quot;;        // cout&lt;&lt;endl;        // output(result);        if(begin&gt;=num.size()){            result.push_back(num);            return ;        }        for(int i=begin;i&lt;num.size();i++){            swap(num[begin],num[i]);            permuteRecursive(num,begin+1,result);            swap(num[begin],num[i]);        }    }};</code></pre><h3 id="DFS思路"><a href="#DFS思路" class="headerlink" title="DFS思路"></a>DFS思路</h3><p>这种方法是CareerCup书上的方法，也挺不错的，这道题是思想是这样的：</p><p>当n=1时，数组中只有一个数a1，其全排列只有一种，即为a1</p><p>当n=2时，数组中此时有a1a2，其全排列有两种，a1a2和a2a1，那么此时我们考虑和上面那种情况的关系，我们发现，其实就是在a1的前后两个位置分别加入了a2</p><p>当n=3时，数组中有a1a2a3，此时全排列有六种，分别为a1a2a3, a1a3a2, a2a1a3, a2a3a1, a3a1a2, 和 a3a2a1。那么根据上面的结论，实际上是在a1a2和a2a1的基础上在不同的位置上加入a3而得到的。</p><p>_ a1 _ a2 _ : a3a1a2, a1a3a2, a1a2a3</p><p>_ a2 _ a1 _ : a3a2a1, a2a3a1, a2a1a3</p><pre><code>class Solution {public:vector&lt;vector&lt;int&gt; &gt; permute(vector&lt;int&gt; &amp;num) {    vector&lt;vector&lt;int&gt; &gt; ans;    dfs(num, ans);    return ans;}void dfs(vector&lt;int&gt; &amp;num, vector&lt;vector&lt;int&gt;&gt; &amp;ans) {    if (num.size() == 1) {        vector&lt;int&gt; tmp(num.begin(), num.end());        ans.push_back(tmp);        return;    }    vector&lt;vector&lt;int&gt; &gt; ans1;    vector&lt;int&gt; num1(num.begin()+1, num.end());    dfs(num1, ans);    for(int i = 0; i &lt; ans.size(); ++i) {        for(int j = 0; j &lt;= ans[i].size(); ++j) {            vector&lt;int&gt; tmp = ans[i];            tmp.insert(tmp.begin()+j, num[0]);            ans1.push_back(tmp);        }    }    ans = ans1;}};</code></pre><h2 id="47-PermutationsII-全排列II"><a href="#47-PermutationsII-全排列II" class="headerlink" title="47.PermutationsII 全排列II"></a>47.PermutationsII 全排列II</h2><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p><p>示例:</p><pre><code>输入: [1,1,2]输出:[  [1,1,2],  [1,2,1],  [2,1,1]]</code></pre><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>  这里我们先考虑一下，它与上题唯一的不同在于：在DFS函数中，做循环遍历时，如果与当前元素相同的一个元素已经被取用过，则要跳过所有值相同的元素。<br>  举个例子：对于序列&lt;1,1,2,3&gt;。在DFS首遍历时，1 作为首元素被加到list中，并进行后续元素的添加；那么，当DFS跑完第一个分支，遍历到1 (第二个)时，这个1 不再作为首元素添加到list中，因为1 作为首元素的情况已经在第一个分支中考虑过了。<br>  为了实现这一剪枝思路，有了如下的解题算法。</p><p>解题算法：</p><p>  1. 先对给定的序列nums进行排序，使得大小相同的元素排在一起。<br>  2. 新建一个used数组，大小与nums相同，用来标记在本次DFS读取中，位置i的元素是否已经被添加到list中了。<br>  3. 根据思路可知，我们选择跳过一个数，当且仅当这个数与前一个数相等，并且前一个数未被添加到list中。</p><pre><code>class Solution {public:    void recursion(vector&lt;int&gt; num, int i, int j, vector&lt;vector&lt;int&gt; &gt; &amp;res) {        if (i == j-1) {            res.push_back(num);            return;        }        for (int k = i; k &lt; j; k++) {            if (i != k &amp;&amp; num[i] == num[k]) continue;            swap(num[i], num[k]);            recursion(num, i+1, j, res);        }    }    vector&lt;vector&lt;int&gt; &gt; permuteUnique(vector&lt;int&gt; &amp;num) {        sort(num.begin(), num.end());        vector&lt;vector&lt;int&gt; &gt;res;        recursion(num, 0, num.size(), res);        return res;    }};</code></pre><h2 id="31-Next-Permutations-下一个排列"><a href="#31-Next-Permutations-下一个排列" class="headerlink" title="31.Next Permutations 下一个排列"></a>31.Next Permutations 下一个排列</h2><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须原地修改，只允许使用额外常数空间。</p><p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。</p><pre><code>1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1</code></pre><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>  这里，先考虑一个序列的最大最小情况。当一个序列为非递减序列时，它必然是该组数的最小的排列数；同理，当一个序列为非递增序列时，它必然是该组数的最大的排列数。  </p><p>  由此，我们可以知道，本题的关键即是求出数组末尾的最长的非递增子序列。<br>  不妨假设在数组nums中，nums[k+1]…nums[n]均满足前一个元素大于等于后一个元素，即这一子序列非递增。<br>  那么，我们要做的，就是把nums[k]与其后序列中稍大于nums[k]的数交换，接着再逆序nums[k+1]…nums[n]即可。</p><pre><code>class Solution {public:    void nextPermutation(vector&lt;int&gt;&amp; nums) {        int n = nums.size(), k, l;        for (k = n - 2; k &gt;= 0; k--) {            if (nums[k] &lt; nums[k + 1]) {                break;            }        }        if (k &lt; 0) {            reverse(nums.begin(), nums.end());        } else {            for (l = n - 1; l &gt; k; l--) {                if (nums[l] &gt; nums[k]) {                    break;                }            }            swap(nums[k], nums[l]);            reverse(nums.begin() + k + 1, nums.end());        }    }};</code></pre><h2 id="60-Permutation-Sequence-第k个排列"><a href="#60-Permutation-Sequence-第k个排列" class="headerlink" title="60.Permutation Sequence 第k个排列"></a>60.Permutation Sequence 第k个排列</h2><p>给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。</p><p>按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：</p><pre><code>&quot;123&quot;&quot;132&quot;&quot;213&quot;&quot;231&quot;&quot;312&quot;&quot;321&quot;</code></pre><p>给定 n 和 k，返回第 k 个排列。</p><p>说明：</p><pre><code>给定 n 的范围是 [1, 9]。给定 k 的范围是[1,  n!]。</code></pre><p>示例 1:</p><pre><code>输入: n = 3, k = 3输出: &quot;213&quot;</code></pre><p>示例 2:</p><pre><code>输入: n = 4, k = 9输出: &quot;2314&quot;</code></pre><h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>  这里我们先考虑一个特殊情况，当n=4时，序列为[1,2,3,4]，有以下几种情况：<br>  “1+(2,3,4)的全排列”<br>  “2+(1,3,4)的全排列”<br>  “3+(1,2,4)的全排列”<br>  “4+(1,2,3)的全排列”<br>  我们已经知道，对于n个数的全排列，有n!种情况。所以，3个数的全排列就有6种情况。<br>  <br>  如果我们这里给定的k为14，那么它将会出现在：<br>    “3+(1,2,4)的全排列”<br>  这一情况中。</p><p>  我们可以程式化地得到这个结果：取k=13(从0开始计数)，(n-1)!=3!=6，k/(n-1)!=2，而3在有序序列[1,2,3,4]中的索引就是2。<br>  同理，我们继续计算，新的k=13%6=1，新的n=3，那么1/(n-1)!=2/2=0。在序列[1,2,4]中，索引0的数是1。那么，此时的字符串为”31”。<br>  继续迭代，新的k=1%2=1，新的n=2，那么k/(n-1)!=1/1=1。在序列[2,4]中，索引为1的数是4。那么，此时的字符串为”314”。最后在串尾添上仅剩的2，可以得到字符串”3142”。<br>  经过验算，此串确实是序列[1,2,3,4]的全排列数中第14大的序列。</p><p>解题算法：</p><p>  1. 创建一个长度为n 的数组array，存放对应下标n的阶乘值。<br>  2. 再新建一个长度为n 的数组nums，初始值为nums[i]=i+1，用来存放待选的字符序列。<br>  3. 将得到的k减1后，开始迭代。迭代的规则是：迭代n次，每次选nums数组中下标为k/(n-1)!的数放在字符串的末尾，新的k=k%(n-1)!，新的n=n-1。<br>  4. 最后，返回得到的字符串。</p><pre><code>class Solution {public:    string getPermutation(int n, int k) {        // initialize a dictionary that stores 1, 2, ..., n. This string will store the permutation.        string dict(n, 0);        iota(dict.begin(), dict.end(), &apos;1&apos;);        // build up a look-up table, which stores (n-1)!, (n-2)!, ..., 1!, 0!        vector&lt;int&gt; fract(n, 1);        for (int idx = n - 3; idx &gt;= 0; --idx) {            fract[idx] = fract[idx + 1] * (n - 1 - idx);        }        // let k be zero base        --k;        // the main part.        string ret(n, 0);        for (int idx = 0; idx &lt; n; ++idx) {            int select = k / fract[idx];            k %= fract[idx];            ret[idx] = dict[select];            dict.erase(next(dict.begin(), select)); // note that it is an O(n) operation        }        return ret;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结几个常见的全排列问题&lt;br&gt;46.Permutations 全排列&lt;br&gt;47.PermutationsII 全排列II&lt;br&gt;31.Next Permutations 下一个排列&lt;br&gt;60.Permutation Sequence 第k个排列&lt;br&gt;266.Palindrome Permutation 回文排列&lt;br&gt;267.Palindrome PermutationII 回文排列II&lt;/p&gt;
    
    </summary>
    
      <category term="2018年10月" scheme="http://yoursite.com/categories/2018%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>84.Largest Rectangle in Histogram柱状图中最大的矩形</title>
    <link href="http://yoursite.com/2018/10/09/84.Largest%20Rectangle%20in%20Histogram%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/"/>
    <id>http://yoursite.com/2018/10/09/84.Largest Rectangle in Histogram柱状图中最大的矩形/</id>
    <published>2018-10-09T02:06:44.000Z</published>
    <updated>2019-07-18T04:03:28.415Z</updated>
    
    <content type="html"><![CDATA[<p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><a id="more"></a><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p>柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。</p><p>阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。</p><p>示例:</p><pre><code>输入: [2,1,5,6,2,3]输出: 10</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>分析寻找的过程，如果要在O(n)的时间内找到最大的面积，则需要记录下来每个高度为N的矩形，其长度最大可以达到多少。这样就分为两种情况，如图中描述的，首先是高度N越来越大，其次是高度N越来越小。</p><p>1.在高度N越来越大时，其上一个数字构成的高度的矩形的最大长度则增加1，例如，2 3，高度为3时，则高度为2的矩形的长度就加1. 2.在高度N越来越小时，其上一个数字构成的高度的矩形的最大长度就不变，例如 4 3，高度为4时，其构成的矩形长度为1，到了3，矩形长度没有递增，而4之前的数字3构成的矩形的长度也加1。</p><p>可以使用一个stack来存储矩形的高度和长度，其中长度会动态的变化。当遇到一个数字大于栈顶数字的时候就压入栈，小于栈顶的数字就弹出栈，在这个动态过程中，更新最大的矩形面积。</p><pre><code>class Solution {public:    int largestRectangleArea(vector&lt;int&gt;&amp; heights) {        heights.push_back(0);        int len=heights.size();        stack&lt;int&gt; stk;        int i=0,maxarea=0;        while(i&lt;len){            if(stk.empty() || heights[i]&gt;=heights[stk.top()]) {                stk.push(i);                i++;            }            else{                int h=stk.top();                stk.pop();                maxarea=max(maxarea,heights[h]*(stk.empty()? i: i-stk.top()-1));            }        }        return maxarea;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年10月" scheme="http://yoursite.com/categories/2018%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>52. N-QueensNII皇后II</title>
    <link href="http://yoursite.com/2018/10/05/52.%20N-QueensIIN%E7%9A%87%E5%90%8EII/"/>
    <id>http://yoursite.com/2018/10/05/52. N-QueensIIN皇后II/</id>
    <published>2018-10-05T11:55:26.000Z</published>
    <updated>2019-07-18T04:03:05.140Z</updated>
    
    <content type="html"><![CDATA[<p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><a id="more"></a><p>给定一个整数 n，返回 n 皇后不同的解决方案的数量。</p><p>示例:</p><p>输入: 4<br>输出: 2<br>解释: 4 皇后问题存在如下两个不同的解法。<br>[<br> [“.Q..”,  // 解法 1<br>  “…Q”,<br>  “Q…”,<br>  “..Q.”],</p><p> [“..Q.”,  // 解法 2<br>  “Q…”,<br>  “…Q”,<br>  “.Q..”]<br>]</p><h2 id="思路-DFS"><a href="#思路-DFS" class="headerlink" title="思路 DFS"></a>思路 DFS</h2><pre><code>def totalNQueens(self, n):    self.res = 0    self.dfs([-1]*n, 0)    return self.resdef dfs(self, nums, index):    if index == len(nums):        self.res += 1        return    for i in xrange(len(nums)):        nums[index] = i        if self.valid(nums, index):            self.dfs(nums, index+1)def valid(self, nums, n):    for i in xrange(n):        if nums[i] == nums[n] or abs(nums[n]-nums[i]) == n-i:            return False    return True</code></pre><h2 id="C-版"><a href="#C-版" class="headerlink" title="C++版"></a>C++版</h2><pre><code>int totalNQueens(int n) {    vector&lt;bool&gt; col(n, true);    vector&lt;bool&gt; anti(2*n-1, true);    vector&lt;bool&gt; main(2*n-1, true);    vector&lt;int&gt; row(n, 0);    int count = 0;    dfs(0, row, col, main, anti, count);    return count;}void dfs(int i, vector&lt;int&gt; &amp;row, vector&lt;bool&gt; &amp;col, vector&lt;bool&gt;&amp; main, vector&lt;bool&gt; &amp;anti, int &amp;count) {        if (i == row.size()) {            count++;            return;        }       for (int j = 0; j &lt; col.size(); j++) {         if (col[j] &amp;&amp; main[i+j] &amp;&amp; anti[i+col.size()-1-j]) {             row[i] = j;             col[j] = main[i+j] = anti[i+col.size()-1-j] = false;             dfs(i+1, row, col, main, anti, count);             col[j] = main[i+j] = anti[i+col.size()-1-j] = true;      }    }</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年10月" scheme="http://yoursite.com/categories/2018%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>51. N-QueensN皇后</title>
    <link href="http://yoursite.com/2018/10/05/51.%20N-QueensN%E7%9A%87%E5%90%8E/"/>
    <id>http://yoursite.com/2018/10/05/51. N-QueensN皇后/</id>
    <published>2018-10-05T11:19:45.000Z</published>
    <updated>2019-07-18T06:32:04.263Z</updated>
    
    <content type="html"><![CDATA[<p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><a id="more"></a><p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p><p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><p>示例:</p><pre><code>输入: 4输出: [ [&quot;.Q..&quot;,  // 解法 1  &quot;...Q&quot;,  &quot;Q...&quot;,  &quot;..Q.&quot;], [&quot;..Q.&quot;,  // 解法 2  &quot;Q...&quot;,  &quot;...Q&quot;,  &quot;.Q..&quot;]]解释: 4 皇后问题存在两个不同的解法。</code></pre><h2 id="思路1-递归"><a href="#思路1-递归" class="headerlink" title="思路1 递归"></a>思路1 递归</h2><p>尝试每个可能存在皇后的位置</p><pre><code>class Solution {private:    vector&lt;vector&lt;string&gt;&gt; res;public:    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) {       vector&lt;string&gt; cur(n,string(n,&apos;.&apos;));        helper(cur,0);        return res;    }    void helper(vector&lt;string&gt; &amp;cur,int row){        if(row==cur.size()){            res.push_back(cur);            return;        }        for(int col=0;col&lt;cur.size();col++)            if(isValid(cur,row,col)){                cur[row][col]=&apos;Q&apos;;                helper(cur,row+1);                cur[row][col]=&apos;.&apos;;            }    }    bool isValid(vector&lt;string&gt; &amp;cur,int row,int col){        for(int i=0;i&lt;row;i++)            if(cur[i][col] == &apos;Q&apos;) return false;        for(int i=row-1,j=col-1;i&gt;=0 &amp;&amp; j&gt;=0;i--,j--)            if(cur[i][j]==&apos;Q&apos;) return false;        for(int i=row-1,j=col+1;i&gt;=0 &amp;&amp; j&lt;cur.size();i--,j++)            if(cur[i][j]==&apos;Q&apos;) return false;        return true;    }};</code></pre><h2 id="思路2：DFS"><a href="#思路2：DFS" class="headerlink" title="思路2：DFS"></a>思路2：DFS</h2><p>queen用来记录皇后的横纵坐标位置，xy_dif用来记录横纵坐标之差，xy_sum用来记录横纵坐标之和，p + q == x + y 时在同一条对角线上， p - q == x - y时在同一条反对角线上</p><pre><code>def solveNQueens(self, n):    def DFS(queens, xy_dif, xy_sum):        p = len(queens)        if p==n:            result.append(queens)            return None        for q in range(n):            if q not in queens and p-q not in xy_dif and p+q not in xy_sum:                DFS(queens+[q], xy_dif+[p-q], xy_sum+[p+q])      result = [] #全局变量    DFS([],[],[])    return [ [&quot;.&quot;*i + &quot;Q&quot; + &quot;.&quot;*(n-i-1) for i in sol] for sol in result]</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年10月" scheme="http://yoursite.com/categories/2018%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>102.Binary Tree Level Order Traversal二叉树的层次遍历</title>
    <link href="http://yoursite.com/2018/10/04/102.Binary%20Tree%20Level%20Order%20Traversal%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%20/"/>
    <id>http://yoursite.com/2018/10/04/102.Binary Tree Level Order Traversal二叉树的层次遍历 /</id>
    <published>2018-10-04T11:14:32.000Z</published>
    <updated>2019-07-18T06:30:49.533Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。</p><a id="more"></a><p>例如:</p><pre><code>给定二叉树: [3,9,20,null,null,15,7],    3   / \  9  20    /  \   15   7</code></pre><p>返回其层次遍历结果：</p><pre><code>[  [3],  [9,20],  [15,7]]</code></pre><h2 id="思路1-递归"><a href="#思路1-递归" class="headerlink" title="思路1:递归"></a>思路1:递归</h2><pre><code>/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {        vector&lt;vector&lt;int&gt;&gt; res;        leveltravel(res,0,root);        return res;    }    void leveltravel(vector&lt;vector&lt;int&gt;&gt; &amp;res,int depth,TreeNode * root){         if(!root) return ;        vector&lt;int&gt; temp;        if(res.size()==depth) res.push_back(temp);        res[depth].push_back(root-&gt;val);        leveltravel(res,depth+1,root-&gt;left);        leveltravel(res,depth+1,root-&gt;right);        return;    }};</code></pre><h2 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h2><p>在做的过程中注意队列的大小会随时变化，因此需要将q.size()保存为一个变量</p><pre><code>/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {        queue&lt;TreeNode *&gt; q;        vector&lt;vector&lt;int&gt;&gt; res;        if(root) {            q.push(root);        }        while(!q.empty()){         vector&lt;int&gt; temp;           int len=q.size();         for(int i=0;i&lt;len;i++){            TreeNode *cur;            cur=q.front();            temp.push_back(cur-&gt;val);            q.pop();             //cout&lt;&lt;&quot;i=&quot;&lt;&lt;i&lt;&lt;&quot;   cur-&gt;val=&quot;&lt;&lt;cur-&gt;val&lt;&lt;endl;            if(cur-&gt;left) q.push(cur-&gt;left);            if(cur-&gt;right) q.push(cur-&gt;right);            }            //cout&lt;&lt;&quot;  *********&quot;&lt;&lt;endl;            res.push_back(temp);        }    return res;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年10月" scheme="http://yoursite.com/categories/2018%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Breadth-first Search" scheme="http://yoursite.com/tags/Breadth-first-Search/"/>
    
  </entry>
  
</feed>
