<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-02T02:52:36.758Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot学习笔记VIII</title>
    <link href="http://yoursite.com/2019/08/01/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0VIII/"/>
    <id>http://yoursite.com/2019/08/01/SpringBoot学习笔记VIII/</id>
    <published>2019-08-01T09:12:12.000Z</published>
    <updated>2019-08-02T02:52:36.758Z</updated>
    
    <content type="html"><![CDATA[<p>CMS系统学习，对常用到的注解做详解</p><a id="more"></a><h1 id="CMS系统简介"><a href="#CMS系统简介" class="headerlink" title="CMS系统简介"></a>CMS系统简介</h1><p>内容管理系统（英语：content management system，缩写为 CMS）是指在一个合作模式下，用于管理工作流程的一套制度。该系统可应用于手工操作中，也可以应用到计算机或网络里。作为一种中央储存器（central repository），内容管理系统可将相关内容集中储存并具有群组管理、版本控制等功能。版本控制是内容管理系统的一个主要优势。<br>内容管理系统在物品或文案或数据的存储、掌管、修订（盘存）、语用充实、文档发布等方面有着广泛的应用。现在流行的开源CMS系统有WordPress、Joomla!、Drupal、Xoops、CmsTop等。</p><h1 id="任务描述"><a href="#任务描述" class="headerlink" title="任务描述"></a>任务描述</h1><p>saas-cms 的Respository中建立自己的分支，在controller/creditreview/TransportController中画出getAllProcessHistory函数的流程图，自己重新实现一个查询接口<br>数据库配置文件在resources.local/application.yml中<br>使用的数据库是：jdbc:mysql://10.143.248.78:3306/creditreview?</p><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>handler method 参数绑定常用的注解,根据处理的Request的不同内容部分分为四类：（主要讲解常用类型）</p><p>A、处理request uri 部分（这里指uri template中variable，不含queryString部分）的注解：@PathVariable;</p><p>B、处理request header部分的注解：   @RequestHeader, @CookieValue;</p><p>C、处理request body部分的注解：@RequestParam,  @RequestBody;</p><p>D、处理attribute类型是注解： @SessionAttributes, @ModelAttribute;</p><h2 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h2><p>当使用@RequestMapping URI template 样式映射时， 即 someUrl/{paramId}, 这时的paramId可通过 @Pathvariable注解绑定它传过来的值到方法的参数上。</p><p>示例代码：</p><pre><code>@Controller@RequestMapping(&quot;/owners/{ownerId}&quot;)public class RelativePathUriTemplateController {  @RequestMapping(&quot;/pets/{petId}&quot;)  public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) {        // implementation omitted  }}</code></pre><p>上面代码把URI template 中变量 ownerId的值和petId的值，绑定到方法的参数上。若方法参数名称和需要绑定的uri template中变量名称不一致，需要在@PathVariable(“name”)指定uri template中的名称。</p><h2 id="RequestHeader、-CookieValue"><a href="#RequestHeader、-CookieValue" class="headerlink" title="@RequestHeader、@CookieValue"></a>@RequestHeader、@CookieValue</h2><p><strong><em>@RequestHeader注解，可以把Request请求header部分的值绑定到方法的参数上。</em></strong></p><p>示例代码：</p><p>这是一个Request 的header部分：</p><pre><code>Host                    localhost:8080Accept                  text/html,application/xhtml+xml,application/xml;q=0.9Accept-Language         fr,en-gb;q=0.7,en;q=0.3Accept-Encoding         gzip,deflateAccept-Charset          ISO-8859-1,utf-8;q=0.7,*;q=0.7Keep-Alive              300</code></pre><p>下面的代码，把request header部分的 Accept-Encoding的值，绑定到参数encoding上了， Keep-Alive header的值绑定到参数keepAlive上。</p><pre><code>@RequestMapping(&quot;/displayHeaderInfo.do&quot;)public void displayHeaderInfo(@RequestHeader(&quot;Accept-Encoding&quot;) String encoding,                              @RequestHeader(&quot;Keep-Alive&quot;) long keepAlive)  {  //...}</code></pre><p><strong><em>@CookieValue 可以把Request header中关于cookie的值绑定到方法的参数上。</em></strong></p><p>例如有如下Cookie值：</p><pre><code>JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84</code></pre><p>参数绑定的代码：</p><pre><code>@RequestMapping(&quot;/displayHeaderInfo.do&quot;)public void displayHeaderInfo(@CookieValue(&quot;JSESSIONID&quot;) String cookie)  {  //...}</code></pre><p>即把JSESSIONID的值绑定到参数cookie上。</p><h2 id="RequestParam-RequestBody"><a href="#RequestParam-RequestBody" class="headerlink" title="@RequestParam, @RequestBody"></a>@RequestParam, @RequestBody</h2><h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h3><p>A） 常用来处理简单类型的绑定，通过Request.getParameter() 获取的String可直接转换为简单类型的情况（ String–&gt; 简单类型的转换操作由ConversionService配置的转换器来完成）；因为使用request.getParameter()方式获取参数，所以可以处理get 方式中queryString的值，也可以处理post方式中 body data的值；</p><p>B）用来处理Content-Type: 为 application/x-www-form-urlencoded编码的内容，提交方式GET、POST；</p><p>C) 该注解有两个属性： value、required； value用来指定要传入值的id名称，required用来指示参数是否必须绑定；</p><p>示例代码：</p><pre><code>@Controller@RequestMapping(&quot;/pets&quot;)@SessionAttributes(&quot;pet&quot;)public class EditPetForm {    // ...    @RequestMapping(method = RequestMethod.GET)    public String setupForm(@RequestParam(&quot;petId&quot;) int petId, ModelMap model) {        Pet pet = this.clinic.loadPet(petId);        model.addAttribute(&quot;pet&quot;, pet);        return &quot;petForm&quot;;    }    // ...</code></pre><h3 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h3><p>该注解常用来处理Content-Type: 不是application/x-www-form-urlencoded编码的内容，例如application/json, application/xml等；</p><p>它是通过使用HandlerAdapter 配置的HttpMessageConverters来解析post data body，然后绑定到相应的bean上的。</p><p>因为配置有FormHttpMessageConverter，所以也可以用来处理 application/x-www-form-urlencoded的内容，处理完的结果放在一个MultiValueMap&lt;String, String&gt;里，这种情况在某些特殊需求下使用，详情查看FormHttpMessageConverter api;</p><p>示例代码：</p><pre><code>@RequestMapping(value = &quot;/something&quot;, method = RequestMethod.PUT)public void handle(@RequestBody String body, Writer writer) throws IOException {  writer.write(body);</code></pre><h2 id="SessionAttributes-ModelAttribute"><a href="#SessionAttributes-ModelAttribute" class="headerlink" title="@SessionAttributes, @ModelAttribute"></a>@SessionAttributes, @ModelAttribute</h2><h3 id="SessionAttributes"><a href="#SessionAttributes" class="headerlink" title="@SessionAttributes:"></a>@SessionAttributes:</h3><p>该注解用来绑定HttpSession中的attribute对象的值，便于在方法中的参数里使用。</p><p>该注解有value、types两个属性，可以通过名字和类型指定要使用的attribute 对象；</p><p>示例代码：</p><pre><code>@Controller@RequestMapping(&quot;/editPet.do&quot;)@SessionAttributes(&quot;pet&quot;)public class EditPetForm {    // ...}</code></pre><h3 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a>@ModelAttribute</h3><p>该注解有两个用法，一个是用于方法上，一个是用于参数上；</p><p>用于方法上时：  通常用来在处理@RequestMapping之前，为请求绑定需要从后台查询的model；</p><p>用于参数上时： 用来通过名称对应，把相应名称的值绑定到注解的参数bean上；要绑定的值来源于：</p><p>A） @SessionAttributes 启用的attribute 对象上；</p><p>B） @ModelAttribute 用于方法上时指定的model对象；</p><p>C） 上述两种情况都没有时，new一个需要绑定的bean对象，然后把request中按名称对应的方式把值绑定到bean中。</p><p>用到方法上@ModelAttribute的示例代码：</p><pre><code>// Add one attribute// The return value of the method is added to the model under the name &quot;account&quot;// You can customize the name via @ModelAttribute(&quot;myAccount&quot;)@ModelAttributepublic Account addAccount(@RequestParam String number) {    return accountManager.findAccount(number);}</code></pre><p>这种方式实际的效果就是在调用@RequestMapping的方法之前，为request对象的model里put（“account”， Account）；</p><p>用在参数上的@ModelAttribute示例代码：</p><pre><code>@RequestMapping(value=&quot;/owners/{ownerId}/pets/{petId}/edit&quot;, method = RequestMethod.POST)public String processSubmit(@ModelAttribute Pet pet) {}</code></pre><p>首先查询 @SessionAttributes有无绑定的Pet对象，若没有则查询@ModelAttribute方法层面上是否绑定了Pet对象，若没有则将URI template中的值按对应的名称绑定到Pet对象的各属性上。</p><h2 id="在不给定注解的情况下，参数是怎样绑定的？"><a href="#在不给定注解的情况下，参数是怎样绑定的？" class="headerlink" title="在不给定注解的情况下，参数是怎样绑定的？"></a>在不给定注解的情况下，参数是怎样绑定的？</h2><p>通过分析AnnotationMethodHandlerAdapter和RequestMappingHandlerAdapter的源代码发现，方法的参数在不给定参数的情况下：</p><p>若要绑定的对象时简单类型：  调用@RequestParam来处理的。 </p><p>若要绑定的对象时复杂类型：  调用@ModelAttribute来处理的。</p><p>这里的简单类型指java的原始类型(boolean, int 等)、原始类型对象（Boolean, Int等）、String、Date等ConversionService里可以直接String转换成目标对象的类型；</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://blog.csdn.net/walkerJong/article/details/7946109" target="_blank" rel="noopener">https://blog.csdn.net/walkerJong/article/details/7946109</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CMS系统学习，对常用到的注解做详解&lt;/p&gt;
    
    </summary>
    
      <category term="2019年8月" scheme="http://yoursite.com/categories/2019%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot学习笔记VII</title>
    <link href="http://yoursite.com/2019/07/31/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0VII/"/>
    <id>http://yoursite.com/2019/07/31/SpringBoot学习笔记VII/</id>
    <published>2019-07-31T03:12:12.000Z</published>
    <updated>2019-08-01T09:54:20.748Z</updated>
    
    <content type="html"><![CDATA[<p>Mybatis的分页查询，日志log的写法详解</p><a id="more"></a><h1 id="SQL分页查询"><a href="#SQL分页查询" class="headerlink" title="SQL分页查询"></a>SQL分页查询</h1><p>使用SELECT查询时，如果结果集数据量很大，比如几万行数据，放在一个页面显示的话数据量太大，不如分页显示，每次显示100条。</p><p>要实现分页功能，实际上就是从结果集中显示第1 ~ 100条记录作为第1页，显示第101~200条记录作为第2页，以此类推。</p><p>因此，分页实际上就是从结果集中“截取”出第M~N条记录。这个查询可以通过LIMIT <m> OFFSET <n>子句实现。</n></m></p><p>例如基本查询语句：</p><pre><code>SELECT id,name,gender,scoreFROM studentsORDER BY score DESC;</code></pre><p>现在将结果集分页，每页3条记录。要获取第一页的记录，可以使用 LIMIT 3 OFFSET 0:</p><pre><code>SELECT id,name,gender,scoreFROM studentsORDER BY score DESCLIMIT 3 OFFSET 0;</code></pre><p>上述查询LIMIT 3 OFFSET 0表示：<br>对结果集从0号记录开始，最多取3条（注意SQL记录集对索引从0开始）。<br>若要查询第2页，那么我们只需要跳过前3条记录，即对结果集从3号记录开始查询，把OFFSET设定为3:</p><pre><code>SELECT id,name,gender,scoreFROM studentsORDER BY score DESCLIMIT 3 OFFSET 3;</code></pre><p>类似的，查询第3页的时候，OFFSET应该设为6，查询第4页的时候，OFFSET应该设为9.如果查询的表第4页只有1条记录，则最终结果按照实际数量1显示，LIMIT 3表示的意思是“最多3条记录”。</p><p>可见分页查询的关键在于，首先要确定每页需要显示的结果数量pageSize，然后根据当前页的索引pageIndex（从1开始），确定LIMIT和OFFSET应该设定的值：</p><p>LIMIT总是设定为pageSize；<br>OFFSET计算公式为pageSize*（pageIndex-1）。</p><h2 id="扩展思考"><a href="#扩展思考" class="headerlink" title="扩展思考"></a>扩展思考</h2><p>如果原本记录集只有10条记录，但我们将OFFSET设置为20，结果会怎样呢？<br>答案是OFFSET超过查询的最大数量并不会报错，而是会得到一个空的结果集</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>OFFSET是可选的，OFFSET缺省值为0.即LIMIT 3 相当于LIMIT 3 OFFSET 0<br>在MySQL中，LIMIT 3 OFFSET 0也可简写为LIMIT 3，0<br>使用LIMIT M OFFSET N进行分页查询时，N越大查询效率越低。</p><h1 id="SQL连接查询"><a href="#SQL连接查询" class="headerlink" title="SQL连接查询"></a>SQL连接查询</h1><p>连接查询是将两个或两个以上的表按某些条件连接起来，从中选取需要的数据。可以分为内连接查询(通过where实现)和外连接查询（join）。</p><h2 id="内连接查询"><a href="#内连接查询" class="headerlink" title="内连接查询"></a>内连接查询</h2><p>只有不同表中有相同意义的字段时才能进行连接，而且内连接查询只查询出指定字段取值相同的记录。<br><img src="assets/markdown-img-paste-20190801165654826.png" alt="https://img-blog.csdn.net/20171209135846780?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcGxnMTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p><pre><code>一般语法:select a.* , b.*from table_a as a, table_b as bwhere a.id = b.id;</code></pre><h2 id="外连接查询"><a href="#外连接查询" class="headerlink" title="外连接查询"></a>外连接查询</h2><p>需要通过指定字段来进行连接。当该字段取值相等时，可以查询出该记录；而且当该字段不等时，也可以查询出来。包括左连接，右连接查询。</p><pre><code>一般语法：select 属性名列表from 表1left | right join 表2on 表1.属性名 = 表2.属性名;</code></pre><h3 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h3><p>left join 是left outer join的简写，它的全称是左外连接，是外连接中的一种。<br>左(外)连接，左表(a_table)的记录将会全部表示出来，而右表(b_table)只会显示符合搜索条件的记录。右表记录不足的地方均为NULL。<br><img src="assets/markdown-img-paste-2019080116575036.png" alt="https://img-blog.csdn.net/20171209142610819?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcGxnMTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p><h3 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h3><p>右外连接与左外连接相对称，<br>right join是right outer join的简写，它的全称是右外连接，是外连接中的一种。<br>与左(外)连接相反，右(外)连接，左表(a_table)只会显示符合搜索条件的记录，而右表(b_table)的记录将会全部表示出来。左表记录不足的地方均为NULL。<br><img src="assets/markdown-img-paste-20190801175330121.png" alt="https://img-blog.csdn.net/20171209144056668?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcGxnMTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p><h3 id="外连接查询加条件语句"><a href="#外连接查询加条件语句" class="headerlink" title="外连接查询加条件语句"></a>外连接查询加条件语句</h3><p>使用外连接查询时，可以加上各种条件进行筛选。</p><pre><code>select table1.column1, table2.column1from table1join table2on table1.column2 = table2.column3;select table1.column1, table2.column1from table1,table2where table1.column2 = table2.column3;</code></pre><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>子查询时将一个查询语句嵌套在另一个查询语句中，内层查询语句的查询结果，可以为外层查询语句提供查询条件。在特定情况下：一个查询语句的条件需要另一个查询语句来获取。<br>子查询，又叫内部查询，相对于内部查询，包含内部查询的就称为外部查询。</p><p>子查询可以包含普通select可以包括的任何子句，比如：distinct、 group by、order by、limit、join和union等；但是对应的外部查询必须是以下语句之一：select、insert、update、delete、set或 者do。</p><p>注：一个查询语句只能有一个order by ，在子查询中只能位于外部查询后面.</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>子查询分为如下几类：<br>1）. 标量子查询：返回单一值的标量，最简单的形式。<br>2）. 列子查询：返回的结果集是 N 行一列。<br>3）. 行子查询：返回的结果集是一行 N 列。<br>4）. 表子查询：返回的结果集是 N 行 N 列。<br>可以使用的操作符：= &gt; &lt; &gt;= &lt;= &lt;&gt; ANY IN SOME ALL EXISTS</p><p>释义：一个子查询会返回一个标量（就一个值）、一个行、一个列或一个表，这些子查询称之为标量、行、列和表子查询。</p><h3 id="带有any关键字的子查询"><a href="#带有any关键字的子查询" class="headerlink" title="带有any关键字的子查询"></a>带有any关键字的子查询</h3><p>any关键字表示满足其中任一条件，使用any关键字时，只要满足内层查询语句返回的结果中的任何一个，就可以通过该条件来执行外层查询语句。</p><p>从computer表中查询哪些人分数高于任何一个奖学金的最低分。</p><pre><code>select * from computer_stuwhere score &gt;= ANY                  (select score From  scholarship);</code></pre><h3 id="带有all关键字的子查询"><a href="#带有all关键字的子查询" class="headerlink" title="带有all关键字的子查询"></a>带有all关键字的子查询</h3><p>表示需要满足所有的条件。只有满足内层查询语句返回的所有结果，才可以执行外层查询语句。</p><h3 id="带有exists关键字的子查询"><a href="#带有exists关键字的子查询" class="headerlink" title="带有exists关键字的子查询"></a>带有exists关键字的子查询</h3><p>exists关键字表示存在，内层查询语句不返回查询的记录，而是返回一个真假值，如果内层查询语句查询到满足条件的记录，就返回一个true，外层查询语句将进行查询。</p><pre><code>select * from employeewhere exists (select d_name from department where d_id = 1003);//如果department存在d_id为1003，则查询employee表。</code></pre><p>还可以分为相关子查询，独立子查询。以上子查询与外层查询没有关联，称为独立子查询，如果子查询有用到外层查询的字段，则称相关子查询，相关子查询容易产生性能问题。</p><h1 id="Mybatis分页查询"><a href="#Mybatis分页查询" class="headerlink" title="Mybatis分页查询"></a>Mybatis分页查询</h1><h1 id="日志Log写法详解"><a href="#日志Log写法详解" class="headerlink" title="日志Log写法详解"></a>日志Log写法详解</h1><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://www.liaoxuefeng.com/wiki/1177760294764384/1217864791925600" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1177760294764384/1217864791925600</a><br>【2】<a href="https://blog.csdn.net/plg17/article/details/78758593" target="_blank" rel="noopener">https://blog.csdn.net/plg17/article/details/78758593</a><br>【3】<a href="https://cloud.tencent.com/developer/article/1333120" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1333120</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mybatis的分页查询，日志log的写法详解&lt;/p&gt;
    
    </summary>
    
      <category term="2019年7月" scheme="http://yoursite.com/categories/2019%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot学习笔记VI</title>
    <link href="http://yoursite.com/2019/07/31/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0VI/"/>
    <id>http://yoursite.com/2019/07/31/SpringBoot学习笔记VI/</id>
    <published>2019-07-31T02:12:12.000Z</published>
    <updated>2019-08-01T08:36:08.203Z</updated>
    
    <content type="html"><![CDATA[<p>简单总结SpringMVC整合Mybatis，从Get/Request请求中实现对数据库的增删改查，对应着SpringBoot学习笔记II中的Mybatis任务中的第二项。</p><a id="more"></a><h1 id="建立项目步骤"><a href="#建立项目步骤" class="headerlink" title="建立项目步骤"></a>建立项目步骤</h1><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>在主目录下（com.example.std.java.demo）下建立Controller包，在controller下建立与表对应的controller</p><pre><code>package com.example.std.java.demo.controller;import com.example.std.java.demo.dto.request.*;import com.example.std.java.demo.dto.response.MerchantResponseDTO;import com.example.std.java.demo.entity.TblMerchantEntity;import com.example.std.java.demo.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;/** @Description: 商户接口* @Author:yiye.li* @Date:2019-07-28*/@RestController@RequestMapping(&quot;/Merchant&quot;)public class MerchantController extends BaseController{@AutowiredUserService userService;/* *商户接口 * 1。注册商户 * http://localhost:8080//Merchant/CreateMerchant Postman中Get内容，其余内容可以在Params中填写 * 使用@RequestBody格式则需在GET中的Body-》raw中以JSON串格式填写(注意在最右面的一栏中选择JSON(application/json)) * @param MerchantRequestDTO * @return */@GetMapping(&quot;/CreateMerchant&quot;)public MerchantResponseDTO CreateMerchant(@RequestBody CreateMerchantRequestDTO createMerchantRequestDTO){    TblMerchantEntity tblMerchantEntity=new TblMerchantEntity();    tblMerchantEntity.setMerchantName(createMerchantRequestDTO.getMerchantName());    tblMerchantEntity.setContactName(createMerchantRequestDTO.getContactName());    tblMerchantEntity.setPlatformKey(createMerchantRequestDTO.getPlatformKey());    tblMerchantEntity.setShortName(createMerchantRequestDTO.getShortName());    MerchantResponseDTO merchantResponseDTO;    merchantResponseDTO=userService.MybatisCreateMerchant(tblMerchantEntity);    return merchantResponseDTO;}/* *商户接口 * 2。根据商编查询商户 * http://localhost:8080//Merchant/SelectByMerchantNo Postman中Get内容，其余内容可以在Params中填写 * @param MerchantRequestDTO * @return */@GetMapping(&quot;/SelectByMerchantNo&quot;)public MerchantResponseDTO SelectByMerchantNo(@RequestBody SelectByMerchantNoRequestDTO selectByMerchantNoRequestDTO){    TblMerchantEntity tblMerchantEntity=new TblMerchantEntity();    tblMerchantEntity.setMerchantNo(selectByMerchantNoRequestDTO.getMerchantNo());    MerchantResponseDTO merchantResponseDTO;    merchantResponseDTO=userService.MybatisSelectByMerchantNo(tblMerchantEntity);    return merchantResponseDTO;}/* *商户接口 * 3。修改商户状态 * http://localhost:8080//Merchant/UpdateMerchantStatus Postman中Get内容，其余内容可以在Params中填写 * @param MerchantRequestDTO * @return */@GetMapping(&quot;/UpdateMerchantStatus&quot;)public MerchantResponseDTO UpdateMerchantStatus(@RequestBody UpdateMerchantRequestDTO updateMerchantRequestDTO){    TblMerchantEntity tblMerchantEntity=new TblMerchantEntity();    tblMerchantEntity.setId(updateMerchantRequestDTO.getId());    MerchantResponseDTO merchantResponseDTO;    merchantResponseDTO=userService.MybatisUpdateMerchantStatus(tblMerchantEntity);    return merchantResponseDTO;}/* *商户接口 * 4。从外部能够查询商户(根据ID查询商户) * http://localhost:8080//Merchant/MerchantQuery Postman中Get内容，其余内容可以在Params中的KEY和VALUE填写 * @param MerchantRequestDTO * @return */@GetMapping(&quot;/MerchantQuery&quot;)public MerchantResponseDTO MerchantQuery(@RequestBody SelectByIDMerchantRequestDTO selectByIDMerchantRequestDTO){    TblMerchantEntity tblMerchantEntity=new TblMerchantEntity();    tblMerchantEntity.setId(selectByIDMerchantRequestDTO.getId());    MerchantResponseDTO merchantResponseDTO;    merchantResponseDTO=userService.MybatisSpringQuery(tblMerchantEntity);    return merchantResponseDTO;}/*    //4。从外部能够查询商户(根据ID查询商户)//http://localhost:8080//Merchant/MerchantQuery Postman中Get内容，其余内容可以在Params中的KEY和VALUE填写@GetMapping(&quot;/MerchantQuery&quot;)public MerchantResponseDTO MerchantQuery(@RequestParam(&quot;merchantName&quot;) String merchantName,                                    @RequestParam(&quot;contactName&quot;) String contactName,                                    @RequestParam(&quot;contactPhone&quot;)  String contactPhone,                                    @RequestParam(&quot;platformKey&quot;) String platformKey,                                    @RequestParam(&quot;shortName&quot;) String shortName){    MerchantResponseDTO merchantResponseDTO=new MerchantResponseDTO();    merchantResponseDTO=userService.MybatisSpringQuery(40L);    return merchantResponseDTO;}*/}</code></pre><h2 id="DTO"><a href="#DTO" class="headerlink" title="DTO"></a>DTO</h2><h3 id="RequestDTO"><a href="#RequestDTO" class="headerlink" title="RequestDTO"></a>RequestDTO</h3><p>在主目录下建立dto包，再分别建立子目录request和response，request下建立相应的requestDTO文件，每个文件中对应着HTTP请求中相应的参数，而response下建立相应的responseDTO文件，其中对应着要返回的参数</p><p>如SelectByIDMerchantRequestDTO.class</p><pre><code>package com.example.std.java.demo.dto.request;import java.io.Serializable;import lombok.Data;/*** @Description: 商户dto* @Author: yiye.li* @Date: 2019-07-29 10:45*/@Datapublic class SelectByIDMerchantRequestDTO {  /**   * 商户ID   */  private Long id;}</code></pre><p>再如CreateMerchantRequestDTO.class文件</p><pre><code>package com.example.std.java.demo.dto.request;import java.io.Serializable;import lombok.Data;/** * @Description: 商户dto * @Author: yiye.li * @Date: 2019-07-29 10:45 */@Datapublic class CreateMerchantRequestDTO {    /**     * 商户名称     */    private String merchantName;    /**     * 联系人姓名     */    private String contactName;    /**     * 联系电话     */    private String contactPhone;    /**     * 平台钥匙     */    private String platformKey;    /**     * 简称     */    private String shortName;}</code></pre><h3 id="ReponseDTO"><a href="#ReponseDTO" class="headerlink" title="ReponseDTO"></a>ReponseDTO</h3><p>ReponseDTO中写相应的返回参数，例如：</p><pre><code>package com.example.std.java.demo.dto.response;import lombok.Data;import java.util.Date;/** * @Description: 商户返回dto * @Author: yiye.li * @Date: 2019-07-29 10:45 */@Datapublic class MerchantResponseDTO {    //可以自选返回什么    /**     * ID     */    private long ID;    /**     * CREATE_TIME     */    private Date createTime;    /**     * 上次更新时间     */    private Date lastUpdateTime;    /**     * 商户编号     */    private String merchantNo;    /**     * 商户名称     */    private String merchantName;    /**     * 联系人姓名     */    private String contactName;    /**     * 联系电话     */    private String contactPhone;    /**     * 平台钥匙     */    private String platformKey;    /**     * 商户状态     */    private String status;    /**     * 简称     */    private String shortName;    /**     * 组     */    private String checkGroup;}</code></pre><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>在主目录下建立Service包，其中建立Service文件中声明方法名和参数，再建立impl包，其中的ServiceImpl文件来实现对HTTP请求相应的处理方法</p><p>UserService.class文件</p><pre><code>package com.example.std.java.demo.service;import com.example.std.java.demo.dto.response.MerchantResponseDTO;import com.example.std.java.demo.entity.TblMerchantEntity;public interface UserService {    String test();    /**     * 创建商户     * @param tblMerchantEntity     * @return     */    MerchantResponseDTO MybatisCreateMerchant(TblMerchantEntity tblMerchantEntity);    /**     * 根据商编查询商户     * @param tblMerchantEntity     * @return     */    MerchantResponseDTO MybatisSelectByMerchantNo(TblMerchantEntity tblMerchantEntity);    /**     *     * @param tblMerchantEntity     * @return     */    MerchantResponseDTO MybatisUpdateMerchantStatus(TblMerchantEntity tblMerchantEntity);    /**     *     * @param tblMerchantEntity     * @return     */    MerchantResponseDTO MybatisSpringQuery(TblMerchantEntity tblMerchantEntity);}</code></pre><p>而impl文件中的UserServiceImpl.class文件如下：</p><pre><code>package com.example.std.java.demo.service.impl;import com.alibaba.fastjson.JSON;import com.example.std.java.demo.dao.TblMerchantEntityMapper;import com.example.std.java.demo.dto.response.MerchantResponseDTO;import com.example.std.java.demo.entity.TblMerchantEntity;import com.example.std.java.demo.entity.TblMerchantEntityExample;import com.example.std.java.demo.service.UserService;import lombok.extern.apachecommons.CommonsLog;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.util.CollectionUtils;import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.List;import java.util.Random;@Servicepublic class UserServiceImpl implements UserService {    private static final Logger logger= LoggerFactory.getLogger(UserServiceImpl.class);    //要加一些事务处理    //@Transcational (rollback=...    @Override    public String test() {        return null;    }    @Autowired    private TblMerchantEntityMapper tblMerchantEntityMapper;//create duplicate problem to solve    @Override    public MerchantResponseDTO MybatisCreateMerchant(TblMerchantEntity RequesttblMerchantEntity){        MerchantResponseDTO merchantResponseDTO=new MerchantResponseDTO();        TblMerchantEntity tblMerchantEntity=new TblMerchantEntity();        //生成随机数        Random random=new Random();        int nextInt=random.nextInt(100000);        long IDnum=nextInt;        if(tblMerchantEntityMapper.selectByPrimaryKey(IDnum)==null) {            tblMerchantEntity.setId(IDnum);            try{                DateFormat format=new SimpleDateFormat(&quot;yyyyMMddHHmmss&quot;);                Date date =format.parse(System.currentTimeMillis()+&quot;&quot;);                Date dateend =format.parse(System.currentTimeMillis()+24+&quot;&quot;);                tblMerchantEntity.setCreateTime(date);                tblMerchantEntity.setLastUpdateTime(dateend);            }catch(ParseException e){                e.printStackTrace();            }            tblMerchantEntity.setMerchantNo(&quot;&quot;+nextInt);            //set the new data from the requestDTO            tblMerchantEntity.setMerchantName(RequesttblMerchantEntity.getMerchantName());            tblMerchantEntity.setContactName(RequesttblMerchantEntity.getContactName());            tblMerchantEntity.setContactPhone(RequesttblMerchantEntity.getContactPhone());            tblMerchantEntity.setPlatformKey(RequesttblMerchantEntity.getPlatformKey());            tblMerchantEntity.setShortName(RequesttblMerchantEntity.getShortName());            tblMerchantEntity.setStatus(&quot;1&quot;);            tblMerchantEntity.setCheckGroup(&quot;集贸市场&quot;);            tblMerchantEntityMapper.insert(tblMerchantEntity);            merchantResponseDTO.setID(tblMerchantEntity.getId());            merchantResponseDTO.setCreateTime(tblMerchantEntity.getCreateTime());            merchantResponseDTO.setLastUpdateTime(tblMerchantEntity.getLastUpdateTime());            merchantResponseDTO.setMerchantNo(tblMerchantEntity.getMerchantNo());            merchantResponseDTO.setMerchantName(tblMerchantEntity.getMerchantName());            merchantResponseDTO.setContactName(tblMerchantEntity.getContactName());            merchantResponseDTO.setContactPhone(tblMerchantEntity.getContactPhone());            merchantResponseDTO.setPlatformKey(tblMerchantEntity.getPlatformKey());            merchantResponseDTO.setStatus(tblMerchantEntity.getStatus());            merchantResponseDTO.setShortName(tblMerchantEntity.getShortName());            merchantResponseDTO.setCheckGroup(tblMerchantEntity.getCheckGroup());            //将entity中的属性set到merchantResponseDTO中去            System.out.println(&quot;*********Create by ID=&quot;+IDnum+&quot;************&quot;);        }else{            System.out.println(&quot;*********Create The Record Failed, The record has already existed*************&quot;);            tblMerchantEntity=tblMerchantEntityMapper.selectByPrimaryKey(IDnum);            merchantResponseDTO.setID(tblMerchantEntity.getId());            merchantResponseDTO.setCreateTime(tblMerchantEntity.getCreateTime());            merchantResponseDTO.setLastUpdateTime(tblMerchantEntity.getLastUpdateTime());            merchantResponseDTO.setMerchantNo(tblMerchantEntity.getMerchantNo());            merchantResponseDTO.setMerchantName(tblMerchantEntity.getMerchantName());            merchantResponseDTO.setContactName(tblMerchantEntity.getContactName());            merchantResponseDTO.setContactPhone(tblMerchantEntity.getContactPhone());            merchantResponseDTO.setPlatformKey(tblMerchantEntity.getPlatformKey());            merchantResponseDTO.setStatus(tblMerchantEntity.getStatus());            merchantResponseDTO.setShortName(tblMerchantEntity.getShortName());            merchantResponseDTO.setCheckGroup(tblMerchantEntity.getCheckGroup());        }        return merchantResponseDTO;    }    @Override    public MerchantResponseDTO MybatisSelectByMerchantNo(TblMerchantEntity RequesttblMerchantEntity){        MerchantResponseDTO merchantResponseDTO= null;        try {            merchantResponseDTO = new MerchantResponseDTO();            if(logger.isDebugEnabled()){                //debug 级别的日志                logger.debug(&quot;&quot;);            }            logger.info(&quot;query merchant info by merchantN={}&quot;,RequesttblMerchantEntity);            //1。构建商户实体            TblMerchantEntity tblMerchantEntity=new TblMerchantEntity();            TblMerchantEntityExample tblMerchantEntityExample=new TblMerchantEntityExample();            TblMerchantEntityExample.Criteria criteria=tblMerchantEntityExample.createCriteria();            criteria.andMerchantNoEqualTo(RequesttblMerchantEntity.getMerchantNo());            // 2。从数据库查询商户信息            List&lt;TblMerchantEntity&gt; tblMerchantEntities = tblMerchantEntityMapper.selectByExample(tblMerchantEntityExample);            // 判断如果查询的商户信息为空则抛出异常            if(CollectionUtils.isEmpty(tblMerchantEntities)){                throw new RuntimeException(&quot;merchant is null&quot;);            }else{                //如果查询的商户有重复则在日志中写入warn                if(tblMerchantEntities.size()&gt;1) {                    logger.warn(&quot;query merchant size ={}&quot;, tblMerchantEntities.size());                }                //获取第一个商户的信息                tblMerchantEntity=tblMerchantEntities.get(0);            }            //3。将entity中的属性set到merchantResponseDTO中去            merchantResponseDTO.setID(tblMerchantEntity.getId());            merchantResponseDTO.setCreateTime(tblMerchantEntity.getCreateTime());            merchantResponseDTO.setLastUpdateTime(tblMerchantEntity.getLastUpdateTime());            merchantResponseDTO.setMerchantNo(tblMerchantEntity.getMerchantNo());            merchantResponseDTO.setMerchantName(tblMerchantEntity.getMerchantName());            merchantResponseDTO.setContactName(tblMerchantEntity.getContactName());            merchantResponseDTO.setContactPhone(tblMerchantEntity.getContactPhone());            merchantResponseDTO.setPlatformKey(tblMerchantEntity.getPlatformKey());            merchantResponseDTO.setStatus(tblMerchantEntity.getStatus());            merchantResponseDTO.setShortName(tblMerchantEntity.getShortName());            merchantResponseDTO.setCheckGroup(tblMerchantEntity.getCheckGroup());            System.out.println(&quot;*********Select by MerchantNo=&quot;+tblMerchantEntity.getMerchantNo()+&quot;************&quot;);            System.out.println(JSON.toJSONString(tblMerchantEntity));        } catch (RuntimeException e) {            logger.error(&quot;system error &quot;,e);            throw e;        }        return merchantResponseDTO;    }    @Override    public MerchantResponseDTO MybatisUpdateMerchantStatus(TblMerchantEntity RequesttblMerchantEntity){        //制定要更新的ID        long IDnum=RequesttblMerchantEntity.getId();        TblMerchantEntity tblMerchantEntity=tblMerchantEntityMapper.selectByPrimaryKey(IDnum);        MerchantResponseDTO merchantResponseDTO=new MerchantResponseDTO();        TblMerchantEntityExample tblMerchantEntityExample=new TblMerchantEntityExample();        TblMerchantEntityExample.Criteria criteria=tblMerchantEntityExample.createCriteria();        criteria.andIdEqualTo(tblMerchantEntity.getId());        tblMerchantEntity.setStatus(&quot;1&quot;);        //set the new data from the requestDTO        tblMerchantEntityMapper.updateByExample(tblMerchantEntity,tblMerchantEntityExample);        merchantResponseDTO.setID(tblMerchantEntity.getId());        merchantResponseDTO.setCreateTime(tblMerchantEntity.getCreateTime());        merchantResponseDTO.setLastUpdateTime(tblMerchantEntity.getLastUpdateTime());        merchantResponseDTO.setMerchantNo(tblMerchantEntity.getMerchantNo());        merchantResponseDTO.setMerchantName(tblMerchantEntity.getMerchantName());        merchantResponseDTO.setContactName(tblMerchantEntity.getContactName());        merchantResponseDTO.setContactPhone(tblMerchantEntity.getContactPhone());        merchantResponseDTO.setPlatformKey(tblMerchantEntity.getPlatformKey());        merchantResponseDTO.setStatus(tblMerchantEntity.getStatus());        merchantResponseDTO.setShortName(tblMerchantEntity.getShortName());        merchantResponseDTO.setCheckGroup(tblMerchantEntity.getCheckGroup());        System.out.println(&quot;*********Update by ID=&quot;+tblMerchantEntity.getId()+&quot;************&quot;);        System.out.println(JSON.toJSONString(tblMerchantEntity));        return merchantResponseDTO;    }    @Override    public MerchantResponseDTO MybatisSpringQuery(TblMerchantEntity RequesttblMerchantEntity){        //1。获取对应信息        long IDnum=RequesttblMerchantEntity.getId();        MerchantResponseDTO merchantResponseDTO=new MerchantResponseDTO();        //2。先从缓存中尝试获取数据        //3。缓存无，从db中获取数据        //注意是mybatis中自动生成的TblMerchantEntity而不是JPA中生成的实体TblMerchant        TblMerchantEntity tblMerchantEntity=tblMerchantEntityMapper.selectByPrimaryKey(IDnum);        //制定要更新的ID        System.out.println(&quot;*********Query by ID=&quot;+IDnum+&quot;************&quot;);        merchantResponseDTO.setID(tblMerchantEntity.getId());        merchantResponseDTO.setCreateTime(tblMerchantEntity.getCreateTime());        merchantResponseDTO.setLastUpdateTime(tblMerchantEntity.getLastUpdateTime());        merchantResponseDTO.setMerchantNo(tblMerchantEntity.getMerchantNo());        //将Get请求中的信息set到ReponseDTO中去        merchantResponseDTO.setMerchantName(tblMerchantEntity.getMerchantName());        merchantResponseDTO.setContactName(tblMerchantEntity.getContactName());        merchantResponseDTO.setContactPhone(tblMerchantEntity.getContactPhone());        merchantResponseDTO.setPlatformKey(tblMerchantEntity.getPlatformKey());        merchantResponseDTO.setStatus(tblMerchantEntity.getStatus());        //        merchantResponseDTO.setShortName(tblMerchantEntity.getShortName());        merchantResponseDTO.setCheckGroup(tblMerchantEntity.getCheckGroup());        //4。返回结果        //将entity中的属性set到merchantResponseDTO中去        return merchantResponseDTO;    }}</code></pre><p>其中的文件目录树如下：</p><p><img src="assets/markdown-img-paste-20190731101545612.png" alt=""></p><h1 id="PostMan使用"><a href="#PostMan使用" class="headerlink" title="PostMan使用"></a>PostMan使用</h1><p>PostMan软件可用于调试HTTP接口，具体使用方法不再赘述<br>只说需要注意的几点：</p><h2 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h2><p>当controller中当方法参数为@RequestParam形式时</p><pre><code>//4。从外部能够查询商户(根据ID查询商户)//http://localhost:8080//Merchant/MerchantQuery Postman中Get内容，其余内容可以在Params中的KEY和VALUE填写@GetMapping(&quot;/MerchantQuery&quot;)public MerchantResponseDTO MerchantQuery(@RequestParam(&quot;merchantName&quot;) String merchantName,                                    @RequestParam(&quot;contactName&quot;) String contactName,                                    @RequestParam(&quot;contactPhone&quot;)  String contactPhone,                                    @RequestParam(&quot;platformKey&quot;) String platformKey,                                    @RequestParam(&quot;shortName&quot;) String shortName){    MerchantResponseDTO merchantResponseDTO=new MerchantResponseDTO();    merchantResponseDTO=userService.MybatisSpringQuery(40L);    return merchantResponseDTO;}</code></pre><p>Postman中选择POST格式发送，<a href="http://localhost:8080/Merchant/MerchantQuery" target="_blank" rel="noopener">http://localhost:8080/Merchant/MerchantQuery</a><br>然后在Params中填入KEY和VALUE，即可发送对应当POST请求。</p><h2 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h2><p>如果controller中的方法参数为@RequestBody形式时:</p><pre><code>/**商户接口* 4。从外部能够查询商户(根据ID查询商户)* http://localhost:8080//Merchant/MerchantQuery Postman中Get内容，其余内容可以在Params中的KEY和VALUE填写* @param MerchantRequestDTO* @return*/@GetMapping(&quot;/MerchantQuery&quot;)public MerchantResponseDTO MerchantQuery(@RequestBody SelectByIDMerchantRequestDTO selectByIDMerchantRequestDTO){  TblMerchantEntity tblMerchantEntity=new TblMerchantEntity();  tblMerchantEntity.setId(selectByIDMerchantRequestDTO.getId());  MerchantResponseDTO merchantResponseDTO;  merchantResponseDTO=userService.MybatisSpringQuery(tblMerchantEntity);  return merchantResponseDTO;}</code></pre><p>则选择Body-》raw形式，然后在右侧的栏中选择JSON(application/json)<br>以JSON格式填写POST中的Body：</p><pre><code>{    &quot;ID&quot;: &quot;47943&quot;}</code></pre><h1 id="浏览器测试"><a href="#浏览器测试" class="headerlink" title="浏览器测试"></a>浏览器测试</h1><p>除了用Postman进行测试外，也可以直接在浏览器中输入GET请求进行测试，在网址栏输入<a href="http://localhost:8080//Merchant/MerchantQuery发送即可" target="_blank" rel="noopener">http://localhost:8080//Merchant/MerchantQuery发送即可</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单总结SpringMVC整合Mybatis，从Get/Request请求中实现对数据库的增删改查，对应着SpringBoot学习笔记II中的Mybatis任务中的第二项。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年7月" scheme="http://yoursite.com/categories/2019%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot学习笔记V</title>
    <link href="http://yoursite.com/2019/07/30/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0V/"/>
    <id>http://yoursite.com/2019/07/30/SpringBoot学习笔记V/</id>
    <published>2019-07-30T08:28:12.000Z</published>
    <updated>2019-07-31T02:40:06.154Z</updated>
    
    <content type="html"><![CDATA[<p>介绍了SpringMVC的基本概念和HTTP中Get与POST的区别。</p><a id="more"></a><h1 id="原理详解"><a href="#原理详解" class="headerlink" title="原理详解"></a>原理详解</h1><h2 id="SpringMVC是什么"><a href="#SpringMVC是什么" class="headerlink" title="SpringMVC是什么"></a>SpringMVC是什么</h2><p>早期 Java Web 的开发中，统一把显示层、控制层、数据层的操作全部交给 JSP 或者 JavaBean 来进行处理，我们称之为 Model1：<br><img src="assets/markdown-img-paste-20190730171141304.png" alt="https://upload-images.jianshu.io/upload_images/7896890-7b3f9cd59394b017.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/963"></p><p>出现的弊端：</p><p>1.JSP 和 Java Bean 之间严重耦合，Java 代码和 HTML 代码也耦合在了一起</p><p>2.要求开发者不仅要掌握 Java ，还要有高超的前端水平</p><p>3.前端和后端相互依赖，前端需要等待后端完成，后端也依赖前端完成，才能进行有效的测试</p><p>4.代码难以复用</p><p>正因为上面的种种弊端，所以很快这种方式就被 Servlet + JSP + Java Bean 所替代了，早期的 MVC 模型（Model2）就像下图这样：<br><img src="assets/markdown-img-paste-20190730171449446.png" alt="https://upload-images.jianshu.io/upload_images/7896890-403a273b08fec826.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/985"></p><p>首先用户的请求会到达 Servlet，然后根据请求调用相应的 Java Bean，并把所有的显示结果交给 JSP 去完成，这样的模式我们就称为 MVC 模式。</p><p>M 代表 模型（Model）<br>模型是什么呢？ 模型就是数据，就是 dao,bean</p><p>V 代表 视图（View）<br>视图是什么呢？ 就是网页, JSP，用来展示模型中的数据</p><p>C 代表 控制器（controller)<br>控制器是什么？ 控制器的作用就是把不同的数据(Model)，显示在不同的视图(View)上，Servlet 扮演的就是这样的角色。</p><h3 id="Spring-MVC-的架构"><a href="#Spring-MVC-的架构" class="headerlink" title="Spring MVC 的架构"></a>Spring MVC 的架构</h3><p>为解决持久层中一直未处理好的数据库事务的编程，又为了迎合 NoSQL 的强势崛起，Spring MVC 给出了方案</p><p><img src="assets/markdown-img-paste-20190730171743535.png" alt="https://upload-images.jianshu.io/upload_images/7896890-a25782fb05f315de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000"></p><p>传统的模型层被拆分为了业务层(Service)和数据访问层（DAO,Data Access Object）。 在 Service 下可以通过 Spring 的声明式事务操作数据访问层，而在业务层上还允许我们访问 NoSQL ，这样就能够满足异军突起的 NoSQL 的使用了，它可以大大提高互联网系统的性能。</p><p>特点：</p><p>1.结构松散，几乎可以在 Spring MVC 中使用各类视图</p><p>2.松耦合，各个模块分离</p><p>3.与 Spring 无缝集成</p><h2 id="HTTP中Get与POST的区别"><a href="#HTTP中Get与POST的区别" class="headerlink" title="HTTP中Get与POST的区别"></a>HTTP中Get与POST的区别</h2><p>Get和Post是两种Http请求方式：</p><p><strong><em>GET-从指定的资源请求数据</em></strong></p><p><strong><em>POST-向指定的资源提交要被处理的数据</em></strong></p><h3 id="GET方法"><a href="#GET方法" class="headerlink" title="GET方法"></a>GET方法</h3><p>查询字符串（名称/值对）是在GET请求的URL中发送的：</p><pre><code>http://localhost:8080/Merchant/SelectByMerchantNo?name1=value1&amp;name2=value2</code></pre><p>GET 请求可被缓存</p><p>GET 请求保留在浏览器历史记录中</p><p>GET 请求可被收藏为书签</p><p>GET 请求不应在处理敏感数据时使用</p><p>GET 请求有长度限制</p><p>GET 请求只应当用于取回数据</p><h3 id="POST方法"><a href="#POST方法" class="headerlink" title="POST方法"></a>POST方法</h3><p>查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的：</p><pre><code>POST /test/demo_form.asp HTTP/1.1Host: w3schools.comname1=value1&amp;name2=value2</code></pre><p>POST 请求不会被缓存</p><p>POST 请求不会保留在浏览器历史记录中</p><p>POST 不能被收藏为书签</p><p>POST 请求对数据长度没有要求</p><table><thead><tr><th></th><th>Get</th><th>POST</th></tr></thead><tbody><tr><td>后退按钮/刷新</td><td>无害</td><td>数据会被重新提交（浏览器应该告知用户数据会被重新提交</td></tr><tr><td>书签</td><td>可收藏为书签</td><td>不可收藏为书签</td></tr><tr><td>缓存</td><td>能被缓存</td><td>不能缓存</td></tr><tr><td>编码类型</td><td>application/x-www-form-urlencoded</td><td>application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。</td></tr><tr><td>历史</td><td>参数保留在浏览器历史中</td><td>参数不会保留在浏览器历史中</td></tr><tr><td>对数据长度的限制</td><td>只允许ASCII字符</td><td>没有限制，也允许二进制数据</td></tr><tr><td>安全性</td><td>较差，因为发送的数据是URL的一部分</td><td>POST比GET更安全，因为参数不会被保留在浏览器历史或WEB服务器日志中</td></tr><tr><td>可见性</td><td>数据在URL中对所有人都是可见的</td><td>数据不会显示在URL在中</td></tr></tbody></table><p>其它HTTP请求方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>HEAD</td><td>与GET相同，但只返回HTTP报头，不返回文档主体</td></tr><tr><td>PUT</td><td>上传指定但URI表示</td></tr><tr><td>DELETE</td><td>删除指定资源</td></tr><tr><td>OPTIONS</td><td>返回服务器支持但HTTP方法</td></tr><tr><td>CONNECT</td><td>把请求连接转换到透明的TCP/IP通道</td></tr></tbody></table><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://www.jianshu.com/p/91a2d0a1e45a" target="_blank" rel="noopener">https://www.jianshu.com/p/91a2d0a1e45a</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍了SpringMVC的基本概念和HTTP中Get与POST的区别。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年7月" scheme="http://yoursite.com/categories/2019%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot学习笔记IV</title>
    <link href="http://yoursite.com/2019/07/26/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0IV/"/>
    <id>http://yoursite.com/2019/07/26/SpringBoot学习笔记IV/</id>
    <published>2019-07-26T10:30:12.000Z</published>
    <updated>2019-07-30T08:32:30.968Z</updated>
    
    <content type="html"><![CDATA[<p>简单总结Java工程师的学习路径，之后还会详细介绍，总结了最近用到的一些知识和注意事项如定时组件，注释，日志，注解等。</p><a id="more"></a><h1 id="中级Java工程师（十年学习计划）"><a href="#中级Java工程师（十年学习计划）" class="headerlink" title="中级Java工程师（十年学习计划）"></a>中级Java工程师（十年学习计划）</h1><p>JVM调优，class如何编译生成<br>分布式事务<br>分布式组件/工具zoomkeeper<br>缓存的使用（redis）<br>分库分表<br>微服务，看SpringCloud源码<br>并发编程<br>Spring源码（建议看两到三遍）</p><h1 id="最近半年学习方向（两个方向）："><a href="#最近半年学习方向（两个方向）：" class="headerlink" title="最近半年学习方向（两个方向）："></a>最近半年学习方向（两个方向）：</h1><p>1.Spring源码，例如bean初始化<br>2.AQS</p><h1 id="今日学习任务"><a href="#今日学习任务" class="headerlink" title="今日学习任务"></a>今日学习任务</h1><h2 id="定时组件学习"><a href="#定时组件学习" class="headerlink" title="定时组件学习"></a>定时组件学习</h2><h2 id="注释写法"><a href="#注释写法" class="headerlink" title="注释写法"></a>注释写法</h2><p>从Controller到DTO再到Service，每个类中的函数都要有注释，包括功能，参数，返回值，格式如下：<br>Service中的例子：</p><pre><code>/** * 创建商户 * @param tblMerchantEntity * @return */</code></pre><p>DTO中的例子：</p><pre><code>/*** @Description: 商户dto* @Author: yiye.li* @Date: 2019-07-29 10:45*/</code></pre><p><strong><em>注释写法，可以先按照步骤写出注释，然后再相应等填充代码</em></strong></p><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>（日志级别分为info，debug，warning，error等），可用于debug。<br>例程：</p><pre><code>@Overridepublic MerchantResponseDTO MybatisSelectByMerchantNo(TblMerchantEntity RequesttblMerchantEntity){    MerchantResponseDTO merchantResponseDTO= null;    try {        merchantResponseDTO = new MerchantResponseDTO();        if(logger.isDebugEnabled()){            //debug 级别的日志            logger.debug(&quot;&quot;);        }        logger.info(&quot;query merchant info by merchantN={}&quot;,RequesttblMerchantEntity);        //1。构建商户实体        TblMerchantEntity tblMerchantEntity=new TblMerchantEntity();        TblMerchantEntityExample tblMerchantEntityExample=new TblMerchantEntityExample();        TblMerchantEntityExample.Criteria criteria=tblMerchantEntityExample.createCriteria();        criteria.andMerchantNoEqualTo(RequesttblMerchantEntity.getMerchantNo());        // 2。从数据库查询商户信息        List&lt;TblMerchantEntity&gt; tblMerchantEntities = tblMerchantEntityMapper.selectByExample(tblMerchantEntityExample);        // 判断如果查询的商户信息为空则抛出异常        if(CollectionUtils.isEmpty(tblMerchantEntities)){            throw new RuntimeException(&quot;merchant is null&quot;);        }else{            //如果查询的商户有重复则在日志中写入warn            if(tblMerchantEntities.size()&gt;1) {                logger.warn(&quot;query merchant size ={}&quot;, tblMerchantEntities.size());            }            //获取第一个商户的信息            tblMerchantEntity=tblMerchantEntities.get(0);        }        //3。将entity中的属性set到merchantResponseDTO中去        merchantResponseDTO.setID(tblMerchantEntity.getId());        merchantResponseDTO.setCreateTime(tblMerchantEntity.getCreateTime());        merchantResponseDTO.setLastUpdateTime(tblMerchantEntity.getLastUpdateTime());        merchantResponseDTO.setMerchantNo(tblMerchantEntity.getMerchantNo());        merchantResponseDTO.setMerchantName(tblMerchantEntity.getMerchantName());        merchantResponseDTO.setContactName(tblMerchantEntity.getContactName());        merchantResponseDTO.setContactPhone(tblMerchantEntity.getContactPhone());        merchantResponseDTO.setPlatformKey(tblMerchantEntity.getPlatformKey());        merchantResponseDTO.setStatus(tblMerchantEntity.getStatus());        merchantResponseDTO.setShortName(tblMerchantEntity.getShortName());        merchantResponseDTO.setCheckGroup(tblMerchantEntity.getCheckGroup());        System.out.println(&quot;*********Select by MerchantNo=&quot;+tblMerchantEntity.getMerchantNo()+&quot;************&quot;);        System.out.println(JSON.toJSONString(tblMerchantEntity));    } catch (RuntimeException e) {        logger.error(&quot;system error &quot;,e);        throw e;    }    return merchantResponseDTO;}</code></pre><p>日志技巧.var</p><h2 id="实现SpringBoot热部署"><a href="#实现SpringBoot热部署" class="headerlink" title="实现SpringBoot热部署"></a>实现SpringBoot热部署</h2><h2 id="SpringBoot注解学习"><a href="#SpringBoot注解学习" class="headerlink" title="SpringBoot注解学习"></a>SpringBoot注解学习</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单总结Java工程师的学习路径，之后还会详细介绍，总结了最近用到的一些知识和注意事项如定时组件，注释，日志，注解等。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年7月" scheme="http://yoursite.com/categories/2019%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot学习笔记III</title>
    <link href="http://yoursite.com/2019/07/25/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0III/"/>
    <id>http://yoursite.com/2019/07/25/SpringBoot学习笔记III/</id>
    <published>2019-07-25T01:36:12.000Z</published>
    <updated>2019-07-26T10:47:25.468Z</updated>
    
    <content type="html"><![CDATA[<p>阐述Spring，Spring MVC，Spring Boot 三者的原理和区别。学习笔记II中涉及到对@Resource和@Autowired的区别做了解释。<br>对用命令查询网络端口占用情况，查找/杀死进程做了回顾性的复习。</p><a id="more"></a><h1 id="三省吾身："><a href="#三省吾身：" class="headerlink" title="三省吾身："></a>三省吾身：</h1><h2 id="什么是Spring？它解决了什么问题？"><a href="#什么是Spring？它解决了什么问题？" class="headerlink" title="什么是Spring？它解决了什么问题？"></a>什么是Spring？它解决了什么问题？</h2><p>Spring是一个开源的轻量级Java SE（Java 标准版本）/Java EE（Java 企业版本）开发应用框架，其目的是用于简化企业级应用程序开发。应用程序是由一组相互协作的对象组成。而在传统应用程序开发中，一个完整的应用是由一组相互协作的对象组成。所以开发一个应用除了要开发业务逻辑之外，最多的是关注如何使这些对象协作来完成所需功能，而且要低耦合、高内聚。业务逻辑开发是不可避免的，那如果有个框架出来帮我们来创建对象及管理这些对象之间的依赖关系。可能有人说了，比如“抽象工厂、工厂方法设计模式”不也可以帮我们创建对象，“生成器模式”帮我们处理对象间的依赖关系，不也能完成这些功能吗？可是这些又需要我们创建另一些工厂类、生成器类，我们又要而外管理这些类，增加了我们的负担，如果能有种通过配置方式来创建对象，管理对象之间依赖关系，我们不需要通过工厂和生成器来创建及管理对象之间的依赖关系，这样我们是不是减少了许多工作，加速了开发，能节省出很多时间来干其他事。Spring框架刚出来时主要就是来完成这个功能。</p><p>Spring框架除了帮我们<strong><em>管理对象及其依赖关系</em></strong>，还提供像通用日志记录、性能统计、安全控制、异常处理等面向切面的能力，还能帮我管理最头疼的数据库事务，本身提供了一套简单的JDBC访问实现，提供与第三方数据访问框架集成（如Hibernate、JPA），与各种Java EE技术整合（如Java Mail、任务调度等等），提供一套自己的web层框架Spring MVC、而且还能非常简单的与第三方web框架集成。从这里我们可以认为Spring是一个超级粘合平台，除了自己提供功能外，还提供粘合其他技术和框架的能力，从而使我们可以更自由的选择到底使用什么技术进行开发。而且不管是JAVA SE（C/S架构）应用程序还是JAVA EE（B/S架构）应用程序都可以使用这个平台进行开发。</p><p>Spring，一般指代的是Spring Framework，它是一个开源的应用程序框架，提供了一个简易的开发方式，通过这种开发方式，将避免那些可能致使代码变得繁杂混乱的大量的业务/工具对象，说的更通俗一点就是由框架来帮你管理这些对象，包括它的创建，销毁等，比如基于Spring的项目里经常能看到的Bean，它代表的就是由Spring管辖的对象。<br>而在被管理对象与业务逻辑之间，Spring通过IOC（控制反转）架起使用的桥梁，IOC也可以看做Spring最核心最重要的思想，通过IOC能带来什么好处呢？首先来看一个实际开发中的典型应用场景，假设我们有一个基于MVC分层结构的应用，通过controller层对外提供接口，而通过service层提供具体的实现，在service层中有一个WelcomeService服务接口，一般情况下都是通过WelcomeService service = new WelcomeServiceImpl();创建实例并进行调用：</p><pre><code>public class WelcomeController {    private WelcomeService service = new WelcomeServiceImpl();    @RequestMapping(&quot;/welcome&quot;)    public String welcome() {    return service.retrieveWelcomeMessage();    }}</code></pre><p>调用后发现一切正常，此时，功能提交，需要进行测试，而由于实际应用环境与测试环境有所区别，需要替换WelcomeServiceImpl为一个MockWelcomeServiceImpl，以方便测试，怎么办？没有其他办法，只有改代码：</p><pre><code>public class WelcomeController {    private WelcomeService service = new MockWelcomeServiceImpl();    ...}测试OK后再将代码改回去，这种方式太过于繁琐，且对代码的侵入性很强；下面看通过Spring的IOC如何实现，首先将WelcomeService交由Spring管理：&lt;bean name=&quot;WelcomeService&quot; class=&quot;XXX.XXX.XXX.service.impl.WelcomeServiceImpl&quot;/&gt;</code></pre><p>然后在业务代码处通过Spring IOC拿到具体对象：</p><pre><code>public class WelcomeController {    @Autowired    private WelcomeService service;    @RequestMapping(&quot;/welcome&quot;)    public String welcome() {        return service.retrieveWelcomeMessage();    }}</code></pre><p>测试的时候，只需要更改配置文件，将WelcomeService对应的实现改为MockWelcomeServiceImpl即可：</p><pre><code>&lt;bean name=&quot;WelcomeService&quot; class=&quot;XXX.XXX.XXX.service.impl.MockWelcomeServiceImpl&quot;/&gt;</code></pre><p>这种方式对业务代码没有任何侵入，它有效的实现松耦合，大家都知道紧耦合的代码是业务发展的噩梦；同时，Spring IOC提供的远不止这些，如通过单例减少创建无用的对象，通过延迟加载优化初始化成本等<br>当然，Spring 的核心功能远不知这些，如：</p><pre><code>Spring AOPSpring JDBCSpring MVCSpring ORMSpring JMSSpring Test</code></pre><p>其实不通过Spring框架依然可以实现这些功能特定，但是Spring 提供了更优雅的抽象接口以方便对这些功能的组装，同时又给予每个具体实现以灵活的配置；另外，基于Spring，你可以方便的与其他框架进行集成，如hibernate，ibatis等，Spring官方的原则是绝不重复造轮子，有好的解决方案只需要通过Spring进行集成即可。纵览Spring的结构，你会发现Spring Framework 本身并未提供太多具体的功能，它主要专注于让你的项目代码组织更加优雅，使其具有极好的灵活性和扩展性，同时又能通过Spring集成业界优秀的解决方案，想了解Spring的核心实现机制可参考tiny spring 项目</p><h2 id="什么是Spring-MVC？它解决了什么问题？"><a href="#什么是Spring-MVC？它解决了什么问题？" class="headerlink" title="什么是Spring MVC？它解决了什么问题？"></a>什么是Spring MVC？它解决了什么问题？</h2><p>Spring MVC是Spring的一部分，Spring 出来以后，大家觉得很好用，于是按照这种模式设计了一个 MVC框架（一些用Spring 解耦的组件），主要用于开发WEB应用和网络接口，它是Spring的一个模块，通过Dispatcher Servlet, ModelAndView 和 View Resolver，让应用开发变得很容易，一个典型的Spring MVC应用开发分为下面几步：<br>首先通过配置文件声明Dispatcher Servlet：</p><pre><code>&lt;servlet&gt;    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;    &lt;servlet-class&gt;com.qgd.oms.web.common.mvc.OmsDispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;/WEB-INF/applicationContext.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><p>通过配置文件声明servlet详情，如MVC resource，data source，bean等</p><pre><code>&lt;mvc:resources mapping=&quot;/css/**/*&quot; location=&quot;/static/css/&quot; cache-period=&quot;21600&quot;/&gt;&lt;mvc:resources mapping=&quot;/js/**/*&quot; location=&quot;/static/js/&quot; cache-period=&quot;21600&quot;/&gt;&lt;mvc:resources mapping=&quot;/views/**/*.html&quot; location=&quot;/static/views/&quot; cache-period=&quot;21600&quot;/&gt;&lt;mvc:resources mapping=&quot;/fonts/**/*&quot; location=&quot;/static/fonts/&quot;/&gt;&lt;mvc:resources mapping=&quot;/ueditor/**/*&quot; location=&quot;/static/js/lib/ueditor/&quot;/&gt;&lt;mvc:resources mapping=&quot;/img/**/*&quot; location=&quot;/static/img/&quot;/&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp2.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;    &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot;/&gt;    &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;    &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt;    &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;    &lt;property name=&quot;validationQuery&quot; value=&quot;${jdbc.validationQuery}&quot;/&gt;    &lt;property name=&quot;maxTotal&quot; value=&quot;10&quot;/&gt;    &lt;property name=&quot;minIdle&quot; value=&quot;5&quot;/&gt;    &lt;property name=&quot;maxIdle&quot; value=&quot;10&quot;/&gt;    &lt;property name=&quot;defaultAutoCommit&quot; value=&quot;true&quot;/&gt;    &lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot;/&gt;    &lt;property name=&quot;testOnBorrow&quot; value=&quot;true&quot;/&gt;    &lt;property name=&quot;poolPreparedStatements&quot; value=&quot;true&quot;/&gt;    &lt;property name=&quot;maxOpenPreparedStatements&quot; value=&quot;50&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;configService&quot; class=&quot;com.qgd.oms.web.common.service.ConfigService&quot;&gt;    &lt;property name=&quot;configStore&quot;&gt;        &lt;bean class=&quot;com.qgd.oms.web.common.service.impl.DbConfigStore&quot;&gt;            &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;                &lt;property name=&quot;taskScheduler&quot; ref=&quot;defaultScheduler&quot;/&gt;            &lt;property name=&quot;refreshInterval&quot; value=&quot;30000&quot;/&gt;        &lt;/bean&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><p>若需添加其它功能，如security，则需添加对应配置：<br>    <http pattern="/css/**/*" security="none"><br>    <http pattern="/js/**/*" security="none"><br>    <http pattern="/views/**/*.html" security="none"><br>    <http pattern="/fonts/**/*" security="none"><br>    <http pattern="/ueditor/**/*" security="none"><br>    <http pattern="/img/**/*" security="none"></http></http></http></http></http></http></p><pre><code>&lt;http use-expressions=&quot;true&quot; entry-point-ref=&quot;omsAuthenticationEntryPoint&quot;&gt;    &lt;logout logout-url=&quot;/omsmc/authentication/logout/*&quot; success-handler-ref=&quot;omsLogoutSuccessHandler&quot;&gt;&lt;/logout&gt;    &lt;intercept-url pattern=&apos;/omsmc/authentication/login*&apos; access=&quot;permitAll&quot; /&gt;    &lt;intercept-url pattern=&apos;/ms/**/*&apos; access=&quot;permitAll&quot; /&gt;    &lt;intercept-url pattern=&apos;/**&apos; access=&quot;authenticated&quot; /&gt;    &lt;!--&lt;security:form-login /&gt;--&gt;    &lt;custom-filter ref=&quot;omsUsernamePasswordAuthenticationFilter&quot; position=&quot;FORM_LOGIN_FILTER&quot; /&gt;    &lt;remember-me services-ref=&quot;omsRememberMeServices&quot; key=&quot;yfboms&quot;/&gt;    &lt;csrf disabled=&quot;true&quot;/&gt;&lt;/http&gt;</code></pre><p>增加业务代码，如controller，service，model等，最后生成war包，通过容器进行启动</p><h2 id="什么是Spring-Boot？它解决了什么问题？"><a href="#什么是Spring-Boot？它解决了什么问题？" class="headerlink" title="什么是Spring Boot？它解决了什么问题？"></a>什么是Spring Boot？它解决了什么问题？</h2><p>初期的Spring通过代码加配置的形式为项目提供了良好的灵活性和扩展性，但随着Spring越来越庞大，其配置文件也越来越繁琐，太多复杂的xml文件也一直是Spring被人诟病的地方，特别是近些年其他简洁的WEB方案层出不穷，如基于Python或Node.Js，几行代码就能实现一个WEB服务器，对比起来，大家渐渐觉得Spring那一套太过繁琐，此时，Spring社区推出了Spring Boot，它的目的在于实现自动配置，降低项目搭建的复杂度，如需要搭建一个接口服务，通过Spring Boot，几行代码即可实现，请看代码示例：</p><pre><code>//引入spring-boot-starter-web依赖&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;//声明Spring Boot应用，直接写业务逻辑即可@Controller@SpringBootApplicationpublic class MockServerApplication {    @RequestMapping(&quot;/hi&quot;)    @ResponseBody    String home() {        return &quot;how are you!&quot;;    }    public static void main(String[] args) {        SpringApplication.run(MockServerApplication.class, args);    }}</code></pre><p>你甚至都不用额外的WEB容器，直接生成jar包执行即可，因为spring-boot-starter-web模块中包含有一个内置tomcat，可以直接提供容器使用；基于Spring Boot，不是说原来的配置没有了，而是Spring Boot有一套默认配置，我们可以把它看做比较通用的约定，而Spring Boot遵循的也是约定优于配置原则，同时，如果你需要使用到Spring以往提供的各种复杂但功能强大的配置功能，Spring Boot一样支持<br>在Spring Boot中，你会发现你引入的所有包都是starter形式，如：</p><p>spring-boot-starter-web-services，针对SOAP Web Services</p><p>spring-boot-starter-web，针对Web应用与网络接口</p><p>spring-boot-starter-jdbc，针对JDBC</p><p>spring-boot-starter-data-jpa，基于hibernate的持久层框架</p><p>spring-boot-starter-cache，针对缓存支持<br>等等</p><p>Spring Boot对starter的解释如下：</p><p><strong><em>Starters are a set of convenient dependency descriptors that you can include in your application. You get a one-stop-shop for all the Spring and related technology that you need, without having to hunt through sample code and copy paste loads of dependency descriptors. For example, if you want to get started using Spring and JPA for database access, just include the spring-boot-starter-data-jpa dependency in your project, and you are good to go</em></strong></p><p>这句话的译意为：</p><p><strong><em>Starters是一系列极其方便的依赖描述，通过在你的项目中包含这些starter，你可以一站式获得你所需要的服务，而无需像以往那样copy各种示例配置及代码，然后调试，真正做到开箱即用；比如你想使用Spring JPA进行数据操作，只需要在你的项目依赖中引入spring-boot-starter-data-jpa即可</em></strong></p><h2 id="Spring，Spring-MVC，Spring-Boot-三者比较"><a href="#Spring，Spring-MVC，Spring-Boot-三者比较" class="headerlink" title="Spring，Spring MVC，Spring Boot 三者比较"></a>Spring，Spring MVC，Spring Boot 三者比较</h2><p>三者专注的领域不同，解决的问题也不一样；总的来说，Spring 就像一个大家族，有众多衍生产品例如 Boot，Security，JPA等等。但他们的基础都是Spring 的 IOC 和 AOP，IOC提供了依赖注入的容器，而AOP解决了面向切面的编程，然后在此两者的基础上实现了其他衍生产品的高级功能；Spring MVC是基于 Servlet 的一个 MVC 框架，主要解决 WEB 开发的问题，因为 Spring 的配置非常复杂，各种xml，properties处理起来比较繁琐。于是为了简化开发者的使用，Spring社区创造性地推出了Spring Boot，它遵循约定优于配置，极大降低了Spring使用门槛，但又不失Spring原本灵活强大的功能</p><p><a href="https://upload-images.jianshu.io/upload_images/4185175-a0a50bf022178e1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/667" target="_blank" rel="noopener">https://upload-images.jianshu.io/upload_images/4185175-a0a50bf022178e1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/667</a></p><h2 id="Resource和-Autowired的区别？"><a href="#Resource和-Autowired的区别？" class="headerlink" title="@Resource和@Autowired的区别？"></a>@Resource和@Autowired的区别？</h2><p>@Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。</p><h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3><p>两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。</p><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><h4 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h4><p>@Autowired为Spring提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;只按照byType注入。</p><pre><code>public class TestServiceImpl {    // 下面两种@Autowired只要使用一种即可    @Autowired    private UserDao userDao; // 用于字段上    @Autowired    public void setUserDao(UserDao userDao) { // 用于属性的方法上        this.userDao = userDao;    }}</code></pre><p>  @Autowired注解是<strong>按照类型（byType）装配</strong>依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。如下：</p><pre><code>public class TestServiceImpl {    @Autowired    @Qualifier(&quot;userDao&quot;)    private UserDao userDao;}</code></pre><h4 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h4><p>@Resource默认按照ByName自动注入，<strong><em> 是JDK1.6支持的注解，按照名称进行装配，</em></strong><br>由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。</p><pre><code>public class TestServiceImpl {    // 下面两种@Resource只要使用一种即可    @Resource(name=&quot;userDao&quot;)    private UserDao userDao; // 用于字段上    @Resource(name=&quot;userDao&quot;)    public void setUserDao(UserDao userDao) { // 用于属性的setter方法上        this.userDao = userDao;    }}</code></pre><p>  注：最好是将@Resource放在setter方法上，因为这样更符合面向对象的思想，通过set、get去操作属性，而不是直接去操作属性。</p><h5 id="Resource装配顺序："><a href="#Resource装配顺序：" class="headerlink" title="@Resource装配顺序："></a>@Resource装配顺序：</h5><p><strong><em> ①如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。</em></strong></p><p><strong><em> ②如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。</em></strong></p><p><strong><em> ③如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。</em></strong></p><p><strong><em> ④如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。</em></strong></p><pre><code>@Resource的作用相当于@Autowired，只不过@Autowired按照byType自动注入。</code></pre><h1 id="Mac-OS-Linux命令查询网络端口占用情况，查找-杀死进程"><a href="#Mac-OS-Linux命令查询网络端口占用情况，查找-杀死进程" class="headerlink" title="Mac OS/Linux命令查询网络端口占用情况，查找/杀死进程"></a>Mac OS/Linux命令查询网络端口占用情况，查找/杀死进程</h1><h2 id="netstat命令"><a href="#netstat命令" class="headerlink" title="netstat命令"></a>netstat命令</h2><pre><code>netstat -an | grep 3306</code></pre><p>3306替换成需要grep的端口号</p><h2 id="lsof命令"><a href="#lsof命令" class="headerlink" title="lsof命令"></a>lsof命令</h2><p>通过list open file命令可以查看到当前打开文件，在linux中所有事物都是以文件形式存在，包括网络连接及硬件设备。</p><pre><code>lsof -i:80</code></pre><p>-i参数表示网络链接，:80指明端口号，该命令会同时列出PID，方便kill</p><p>查看所有进程监听的端口</p><pre><code>sudo lsof -i -P | grep -i &quot;listen&quot;</code></pre><h2 id="ps-A-grep-进程名"><a href="#ps-A-grep-进程名" class="headerlink" title="ps -A|grep [进程名]"></a>ps -A|grep [进程名]</h2><p>找PID： ps -A|grep [进程名]</p><h2 id="kill-PID"><a href="#kill-PID" class="headerlink" title="kill [PID]"></a>kill [PID]</h2><p>杀进程：kill [PID]<br>参考资料：</p><p>【1】<a href="https://www.jianshu.com/p/42620a0a2c33" target="_blank" rel="noopener">https://www.jianshu.com/p/42620a0a2c33</a></p><p>【2】<a href="https://www.cnblogs.com/think-in-java/p/5474740.html" target="_blank" rel="noopener">https://www.cnblogs.com/think-in-java/p/5474740.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;阐述Spring，Spring MVC，Spring Boot 三者的原理和区别。学习笔记II中涉及到对@Resource和@Autowired的区别做了解释。&lt;br&gt;对用命令查询网络端口占用情况，查找/杀死进程做了回顾性的复习。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年7月" scheme="http://yoursite.com/categories/2019%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot学习笔记II</title>
    <link href="http://yoursite.com/2019/07/19/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0II/"/>
    <id>http://yoursite.com/2019/07/19/SpringBoot学习笔记II/</id>
    <published>2019-07-19T03:23:12.000Z</published>
    <updated>2019-07-30T08:40:01.329Z</updated>
    
    <content type="html"><![CDATA[<p>总结整理在学习SpringBoot的过程中遇到的问题和解决方案。</p><a id="more"></a><h1 id="JPA任务："><a href="#JPA任务：" class="headerlink" title="JPA任务："></a>JPA任务：</h1><p>在Merchant表中完成一个JPA项目的增删改查,并在test/java/com.example.std.java.demo/DemoApplicationTests中进行测试</p><h1 id="Mybatis任务："><a href="#Mybatis任务：" class="headerlink" title="Mybatis任务："></a>Mybatis任务：</h1><p>1.在Merchant表中完成一个Mybatis项目的增删改查,并在test/java/com.example.std.java.demo/DemoApplicationTests中进行测试<br>2.使用Mybatis注册商户，根据商编（MerchantNO）查询商户，修改商户状态，从外部能查询，Controller调service，再调dto（写注释，包括每个dto属性是做什么的,DTO中只需要写要从外部传入的属性，写日志）</p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="建表注意事项："><a href="#建表注意事项：" class="headerlink" title="建表注意事项："></a>建表注意事项：</h2><p>创建数据访问接口userRepository建在dao层中。</p><p>社区版的Intellij IDEA可以直接在文件夹上右键New-&gt;Jpa Entities即可自动创建实体。</p><p>对数据库对增删改查可以直接写在test文件夹下的DemoApplicationTest中，每次执行时只需要Run相应的test函数即可，不需全部Run一遍。</p><h2 id="常见问题application-properties文件解析错误："><a href="#常见问题application-properties文件解析错误：" class="headerlink" title="常见问题application.properties文件解析错误："></a>常见问题application.properties文件解析错误：</h2><p>application.yml和application.properties的格式是不同的，注意更改格式。</p><h2 id="导入目录时格式混乱"><a href="#导入目录时格式混乱" class="headerlink" title="导入目录时格式混乱"></a>导入目录时格式混乱</h2><p>打开本地项目时直接open pom.xml会自动解析项目</p><p>如果从git上拉分支则注意：<br>Intellij IDEA从git上拉取分支时要选择import project from external model，<br>在import Project一栏时Root directory栏目中不要默认目录，否则会找不到pom.xml，要选择clone下来的目录中的demo文件</p><h2 id="Maven配置问题"><a href="#Maven配置问题" class="headerlink" title="Maven配置问题"></a>Maven配置问题</h2><p>File-&gt;Preference-&gt;Maven中的Maven home directory; User settings file; Local repository三个根目录中都要选择公司私有的maven目录</p><h2 id="Debug问题"><a href="#Debug问题" class="headerlink" title="Debug问题"></a>Debug问题</h2><p>IDEA中错误信息以堆栈形式输出，所以最下面的错误是第一个错误，优先看</p><h2 id="hibernate-dialect配置问题"><a href="#hibernate-dialect配置问题" class="headerlink" title="hibernate.dialect配置问题"></a>hibernate.dialect配置问题</h2><p>启动时报错：<br>Access to DialectResolutionInfo cannot be null when ‘hibernate.dialect’ not set</p><p>hibernate.dialect是为了更好的适配各种数据库，针对每种数据库都指定方言dialect，将各类数据库Oracle，Mysql等不同类型等语法<br>转换成hibernate能理解等统一的格式。</p><h3 id="解决方法1"><a href="#解决方法1" class="headerlink" title="解决方法1:"></a>解决方法1:</h3><p>这个问题花了很长时间，google到的方法都没有作用，最后确定原因是demo/config/JpaConfig文件中的factory.setJpaProperties(jpaProperties.getProperties());一行中Jpaproperties读到的属性为空，</p><p>demo/config/JpaConfig文件如下</p><pre><code>package com.example.std.java.demo.config;import javax.annotation.Resource;import javax.persistence.EntityManagerFactory;import javax.sql.DataSource;import com.example.std.java.demo.config.jpa.HibernateConfig;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;import org.springframework.boot.autoconfigure.orm.jpa.JpaProperties;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import org.springframework.data.jpa.repository.config.EnableJpaRepositories;import org.springframework.orm.jpa.DefaultJpaDialect;import org.springframework.orm.jpa.JpaTransactionManager;import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;import org.springframework.transaction.PlatformTransactionManager;import org.springframework.transaction.annotation.EnableTransactionManagement;import java.util.Map;import java.util.Properties;@Configuration@EnableTransactionManagement@EnableJpaRepositories(    entityManagerFactoryRef = &quot;entityManagerFactory&quot;,    transactionManagerRef = &quot;platformTransactionManager&quot;,    basePackages = {&quot;com.example.std.java.demo.dao.jpa&quot;}) //设置Repository所在位置public class JpaConfig {    @Resource    private HibernateConfig jpaProperties;    @Resource(name = &quot;testDataSource&quot;)    private DataSource dataSource;    @Primary    @Bean(name = &quot;entityManagerFactory&quot;)    public EntityManagerFactory entityManagerFactory() {        HibernateJpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter();        LocalContainerEntityManagerFactoryBean factory = new LocalContainerEntityManagerFactoryBean();        factory.setJpaVendorAdapter(vendorAdapter);        factory.setPackagesToScan(&quot;com.example.std.java.demo.entity.jpa&quot;);        factory.setDataSource(dataSource);//数据源        factory.setJpaProperties(jpaProperties.getProperties());        factory.afterPropertiesSet();//在完成了其它所有相关的配置加载以及属性设置后,才初始化        return factory.getObject();    }    /**     * 配置事物管理器     * @return     */    @Bean(name = &quot;platformTransactionManager&quot;)    @Primary    public PlatformTransactionManager platformTransactionManager() {        JpaTransactionManager jpaTransactionManager = new JpaTransactionManager();        jpaTransactionManager.setEntityManagerFactory(this.entityManagerFactory());        return jpaTransactionManager;    }}</code></pre><p>为了能传进属性，在demo/config/jpa/HibernateConfig文件中增加属性properties</p><pre><code>package com.example.std.java.demo.config.jpa;import lombok.Data;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Configuration;import java.util.Properties;@Configuration@ConfigurationProperties(prefix = &quot;user.jpa&quot;)@Datapublic class HibernateConfig {    Properties properties;}</code></pre><p>其中注解中的的@ConfigurationProperties(prefix = “user.jpa”)指的是resources/local/application.yml中的数据源配置</p><pre><code>spring:  datasource:    test:      jdbcUrl: jdbc:mysql://10.143.248.78:3306/java_demo?autoReconnect=true&amp;characterEncoding=UTF8&amp;&amp;parseTime=True      type: org.apache.tomcat.jdbc.pool.DataSource      username: root      password: mojiti      testOnBorrow: true      validationQuery: &quot;select version()&quot;      driver-class-name: com.mysql.jdbc.Driver    shangtongdai:      jdbcUrl: jdbc:mysql://10.143.248.78:3306/shangtongdai?autoReconnect=true&amp;characterEncoding=UTF8&amp;&amp;parseTime=True      type: org.apache.tomcat.jdbc.pool.DataSource      username: root      password: mojiti      testOnBorrow: true      validationQuery: &quot;select version()&quot;      driver-class-name: com.mysql.jdbc.Driveruser:  jpa:    properties:      hibernate:        hbm2ddlauto: update        dialect: org.hibernate.dialect.MySQL5InnoDBDialect</code></pre><h3 id="解决方法2"><a href="#解决方法2" class="headerlink" title="解决方法2:"></a>解决方法2:</h3><p>也可以直接将properties固定的写在JpaConfig中</p><pre><code>@Primary @Bean(name = &quot;entityManagerFactory&quot;) public EntityManagerFactory entityManagerFactory() {     HibernateJpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter();     LocalContainerEntityManagerFactoryBean factory = new LocalContainerEntityManagerFactoryBean();     factory.setJpaVendorAdapter(vendorAdapter);     factory.setPackagesToScan(&quot;com.example.std.java.demo.entity.jpa&quot;);     factory.setDataSource(dataSource);//数据源     Properties properties=new Properties();     properties.setProperty(&quot;hibernate.dialect&quot;,&quot;org.hibernate.dialect.MySQL5InnoDBDialect&quot;);     factory.setJpaProperties(properties);     factory.afterPropertiesSet();//在完成了其它所有相关的配置加载以及属性设置后,才初始化     return factory.getObject(); }</code></pre><h2 id="新建SpringBoot项目启动时往往会报错"><a href="#新建SpringBoot项目启动时往往会报错" class="headerlink" title="新建SpringBoot项目启动时往往会报错"></a>新建SpringBoot项目启动时往往会报错</h2><h3 id="常见错误类型："><a href="#常见错误类型：" class="headerlink" title="常见错误类型："></a>常见错误类型：</h3><pre><code>***************************APPLICATION FAILED TO START***************************Description:Failed to configure a DataSource: &apos;url&apos; attribute is not specified and no embedded datasource could be configured.Reason: Failed to determine a suitable driver class</code></pre><h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><p>配置Mybatis时出现的错误，原因是因为添加了数据库组件，所以autoconfig会去读取数据源但配置，而新建项目还没有配置数据源，所以会导致异常出现。</p><p>方法1:需要先在target/pom.xml中去掉对数据库的依赖，即去掉下面这段。</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;2.1.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>方法2:也可以在启动类的@EnableAutoConfiguration或@SpringBootApplication中添加exclude = {DataSourceAutoConfiguration.class}，排除此类的autoconfig。启动以后就可以正常运行。修改如下：</p><pre><code>@SpringBootApplication(exclude= DataSourceAutoConfiguration.class)public class DemoApplication {    public static void main(String[] args) {        SpringApplication.run(DemoApplication.class, args);    }}</code></pre><h3 id="常见错误类型：-1"><a href="#常见错误类型：-1" class="headerlink" title="常见错误类型："></a>常见错误类型：</h3><pre><code>Error starting ApplicationContext. To display the conditions report re-run your application with &apos;debug&apos; enabled.</code></pre><h3 id="解决办法：-1"><a href="#解决办法：-1" class="headerlink" title="解决办法："></a>解决办法：</h3><p>这是配置JPA时出现的错误，错误原因同上，同理可知解决方法。</p><h2 id="多数据源问题："><a href="#多数据源问题：" class="headerlink" title="多数据源问题："></a>多数据源问题：</h2><p>在多数据源情况下，会出现所链接的数据库中没有需要查询的表，而该表在另一个数据库中，此时在demo/config/JpaConfig文件中找到</p><pre><code>@Qualifier(&quot;testDataSource&quot;)private DataSource dataSource;</code></pre><p>改为<br>    @Resource(name = “testDataSource”)<br>    private DataSource dataSource;<br>或者@Autowired注解来选择数据源，其中dataSource等来自于demo/config/DbAutoConfiguration</p><pre><code>package com.example.std.java.demo.config;import javax.sql.DataSource;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.jdbc.DataSourceBuilder;import org.springframework.context.annotation.AdviceMode;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.transaction.annotation.EnableTransactionManagement;/** * @Description: db数据库自动化配置 * @Author: * @Date: 2019-07-11 14:50 */@Configuration@EnableTransactionManagement(mode = AdviceMode.ASPECTJ)public class DbAutoConfiguration {    @Bean(&quot;testDataSource&quot;)    @ConfigurationProperties(prefix = &quot;spring.datasource.test&quot;)    public DataSource dataSource() {        return DataSourceBuilder.create().build();    }    @Bean(&quot;dataSource&quot;)    @ConfigurationProperties(prefix = &quot;spring.datasource.shangtongdai&quot;)    public DataSource dataSource2() {        return DataSourceBuilder.create().build();    }}</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1]<a href="https://stackoverflow.com/questions/40738818/illegalargumentexception-at-least-one-jpa-metamodel-must-be-present?newreg=1d1be5c9c5a04ec2878d9fc8237bbda5" target="_blank" rel="noopener">https://stackoverflow.com/questions/40738818/illegalargumentexception-at-least-one-jpa-metamodel-must-be-present?newreg=1d1be5c9c5a04ec2878d9fc8237bbda5</a><br>[2]]<a href="https://blog.csdn.net/zsg88/article/details/80780281" target="_blank" rel="noopener">https://blog.csdn.net/zsg88/article/details/80780281</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结整理在学习SpringBoot的过程中遇到的问题和解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年7月" scheme="http://yoursite.com/categories/2019%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot学习笔记I</title>
    <link href="http://yoursite.com/2019/07/17/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0I/"/>
    <id>http://yoursite.com/2019/07/17/SpringBoot学习笔记I/</id>
    <published>2019-07-17T07:30:12.000Z</published>
    <updated>2019-07-25T01:49:45.216Z</updated>
    
    <content type="html"><![CDATA[<p>总结整理在学习SpringBoot的过程中遇到的问题和解决方案（我又双叒要开始更新博客了）。</p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>忙忙碌碌的暑假结束了，虽然可以算得上十分充实，不过在学习新知识提高自己这一方面却做的并不尽如人意，之前制定的学习计划大都被其它各种计划所取代，<br>从屈指可数的博客更新就能看出来。<br>随着步入职场，自我学习变得更加重要，之前这段时间的状态不能再继续下去。写了这么多中心思想就一条：“我又双叒要开始更新博客了”。</p><h2 id="SSM框架"><a href="#SSM框架" class="headerlink" title="SSM框架"></a>SSM框架</h2><p>Java中常用的有三大框架SSM（Spring，SpringMVC和Mybatis），其中Spring是一个轻量级的控制反转（IoC）和面向切面（AOP）的容器框架，<br>是为了解决企业应用开发的复杂性而创建的。而SpringMVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。<br>SpringMVC分离了控制器、模型对象、分派器以及处理程序对象的角色，这种分离让它们更容易进行定制。<br>MyBatis本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。<br>MyBatis是一个基于Java的持久层框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects（DAO）MyBatis<br>消除了几乎所有的JDBC代码和参数的手工设置以及结果集的检索。<br>MyBatis 使用简单的 XML或注解用于配置和原始映射，将接口和 Java 的POJOs（Plain Old Java Objects，普通的 Java对象）映射成数据库中的记录。</p><h2 id="SpringBoot简介"><a href="#SpringBoot简介" class="headerlink" title="SpringBoot简介"></a>SpringBoot简介</h2><p>而我们之后要学习的SpringBoot则可以快速构建容易配置的 Spring 应用程序，使用SpringBoot可以减少配置的工作量。SpringBoot网站对它的简洁介绍如下：</p><p>“ Spring Boot 使您能轻松地创建独立的、生产级的、基于 Spring 且能直接运行的应用程序。我们对 Spring 平台和第三方库有自己的看法，<br>所以您从一开始只会遇到极少的麻烦。”</p><p>刚开始学习SpringBoot时可以从HelloWorld开始，此处网上例程很多，不再赘述。</p><h1 id="概念剖析"><a href="#概念剖析" class="headerlink" title="概念剖析"></a>概念剖析</h1><p>首先学习几个Java开发中会遇到的概念。<br><img src="assets/markdown-img-paste-20190718153319935.png" alt="https://img-blog.csdn.net/20170816144718827"></p><h2 id="1-DAO-data-access-object-数据访问对象"><a href="#1-DAO-data-access-object-数据访问对象" class="headerlink" title="1.DAO[data access object]数据访问对象"></a>1.DAO[data access object]数据访问对象</h2><p>一个面向对象的数据库接口，负责持久层的操作，为业务层提供接口，主要用来封装对数据库的访问，常见操作无外乎 CURD。我们也可以认为一个 DAO 对应一个 POJO 的对象，它位于业务逻辑与数据库资源中间，可以结合 PO 对数据库进行相关的操作。<br>此处注意对数据访问不仅仅指的是对数据库的访问。 假如A系统调用B系统的服务获取数据，这时候A系统对B系统访问数据对象的封装也可以称为DAO。</p><h2 id="2-DTO-data-transfer-object-数据传输对象"><a href="#2-DTO-data-transfer-object-数据传输对象" class="headerlink" title="2.DTO[data transfer object]数据传输对象"></a>2.DTO[data transfer object]数据传输对象</h2><p>主要用于远程调用等需要大量传输对象的地方，比如我们有一个交易订单表，含有20个字段，那么其对应的PO就有20个属性，但我们的页面上只需要显示5个字段，因此没有必要把整个 PO 对象传递给客户端，这时我们只需把仅有 5 个属性的 DTO 把结果传递给客户端即可，而且如果用这个对象来对应界面的显示对象，那此时它的身份就转为VO。使用DTO的好处有两个，一是能避免传递过多的无用数据，提高数据的传输速度；二是能隐藏后端的表结构。常见的用法是：将请求的数据或属性组装成一个RequestDTO，再将响应的数据或属性组装成一个 ResponseDTO.</p><h2 id="3-PO-persistant-object-持久层对象"><a href="#3-PO-persistant-object-持久层对象" class="headerlink" title="3.PO[persistant object]持久层对象"></a>3.PO[persistant object]持久层对象</h2><p>由一组属性和属性的get和set方法组成，最简单的 PO 就是对应数据库中某个表中的一条记录（也就是说，我们可以将数据库表中的一条记录理解为一个持久层对象），多个记录可以用 PO 的集合，PO 中应该不包含任何对数据库的操作。PO 的属性是跟数据库表的字段一一对应的，此外 PO 对象需要实现序列化接口。因对象-关系映射（Object-Relational Mapping，简称ORM）框架的广泛使用而被引入到JavaEE项目设计中。</p><h2 id="4-BO-bussiness-object-业务对象"><a href="#4-BO-bussiness-object-业务对象" class="headerlink" title="4.BO[bussiness object]业务对象"></a>4.BO[bussiness object]业务对象</h2><p>简单的真实世界的软件抽象，通常位于中间层。BO 的主要作用是把业务逻辑封装为一个对象，这个对象可以包括一个或多个其它的对象。举一个求职简历的例子，每份简历都包括教育经历、项目经历等，我们可以让教育经历和项目经历分别对应一个 PO，这样在我们建立对应求职简历的 BO 对象处理简历的时候，让每个 BO 都包含这些 PO 即可。</p><h2 id="5-VO-value-object-值对象"><a href="#5-VO-value-object-值对象" class="headerlink" title="5.VO[value object]值对象"></a>5.VO[value object]值对象</h2><p>通常用于业务层之间的数据传递，和 PO 一样也是仅仅包含数据而已，但 VO 应该是抽象出的业务对象，可以和表对应，也可以不对应，这根据业务的需要。 如果锅碗瓢盆分别为对应的业务对象的话，那么整个碗柜就是一个值对象。此外，VO 也可以称为页面对象，如果称为页面对象的话，那么它所代表的将是整个页面展示层的对象，也可以由需要的业务对象进行组装而来。</p><h2 id="6-POJO-plain-ordiary-java-object-简单java对象"><a href="#6-POJO-plain-ordiary-java-object-简单java对象" class="headerlink" title="6.POJO[plain ordiary java object] 简单java对象"></a>6.POJO[plain ordiary java object] 简单java对象</h2><p>实际就是普通的 JavaBeans，是为了避免和 EJB（Enterprise JavaBean）混淆所创造的简称。POJO 实质上可以理解为简单的实体类，其中有一些属性及其getter和setter方法的类，没有业务逻辑，也不允许有业务方法，也不能携带有connection之类的方法。POJO 是 JavaEE 世界里面最灵活的对象，在简单系统中，如果从数据库到页面展示都是 POJO 的话，它可以是 DTO；如果从数据库中到业务处理中都是 POJO 的话，它可以是 BO；如果从数据库到整个页面的展示的话，它也可以是 VO.</p><h2 id="7-Entity-实体"><a href="#7-Entity-实体" class="headerlink" title="7.Entity 实体"></a>7.Entity 实体</h2><p>对应数据库中的表，简单的理解为一个表对应一个实体，以交易订单表Order为例，若该表中含有20个字段，那么这个OrderEntity对象里面也要含有20个对应的属性。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】详述 PO VO BO DTO DAO 和 POJO 的概念及区别<a href="https://blog.csdn.net/qq_35246620/article/details/77247427" target="_blank" rel="noopener">https://blog.csdn.net/qq_35246620/article/details/77247427</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结整理在学习SpringBoot的过程中遇到的问题和解决方案（我又双叒要开始更新博客了）。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年7月" scheme="http://yoursite.com/categories/2019%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Linux配置问题小结</title>
    <link href="http://yoursite.com/2019/06/03/Linux%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2019/06/03/Linux配置问题小结/</id>
    <published>2019-06-03T04:47:45.000Z</published>
    <updated>2019-07-18T04:07:56.272Z</updated>
    
    <content type="html"><![CDATA[<p>记录Linux配置问题的解决方案，在Ubuntu 18.04中安装terminator 并在右键菜单中添加open in termintor;解决了搜狗输入法在Ubuntu 18.04 中无法安装和安装后无法使用的问题;解决了Linux下无线网卡rtl8821CE/rtl8723ce驱动无法驱动的问题。</p><a id="more"></a><h2 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h2><ol><li>Ubuntu 18.04 安装terminator 并在右键菜单中添加open in termintor</li><li>解决了搜狗输入法在Ubuntu 18.04 中无法安装和安装后无法使用的问题</li><li>解决了Linux下无线网卡rtl8821CE/rtl8723ce驱动无法驱动的问题。</li></ol><h2 id="Terminator安装和右键菜单添加解决方案"><a href="#Terminator安装和右键菜单添加解决方案" class="headerlink" title="Terminator安装和右键菜单添加解决方案"></a>Terminator安装和右键菜单添加解决方案</h2><p>  题外话，安利下terminator，是Linux环境下一款非常赞的命令行管理工具，前段时间微软宣布推出名为Windows Terminal的新款命令行工具，在个人看来也是姗姗来迟的将terminator能实现的功能在windows中实现了。</p><p>  安装terminator</p><pre><code>sudo apt install terminator</code></pre><p>  网上大多用dconf系统配置编辑器将terminator设为默认，但在我的系统中这样在文件位置中右键打开时还是只能打开默认的终端，用起来很不方便，直到找到了这种方法（<a href="https://blog.csdn.net/bestBT/article/details/81221378）。" target="_blank" rel="noopener">https://blog.csdn.net/bestBT/article/details/81221378）。</a><br>  安装Nautilus-actions</p><pre><code>sudo add-apt-repository ppa:daniel-marynicz/filemanager-actionssudo apt-get install filemanager-actions-nautilus-extension</code></pre><p>使用fma-config-tool 来配置。<br>1.新建动作，在action（动作）界面中勾选第二项Display item in location context menu。在Context label中输入想写的名字“在Terminator中打开”。<br>2.在Command（命令）界面中输入路径/usr/bin/terminator，参数中输入–working-directory=%d/%b。<br>3.这样操作完在terminator中打开还在右键的二级菜单中，所以点右上角齿轮标志（编辑您的首选项），在运行时首选项-》Nautilus菜单布局中取消勾选Create a root “FileManager-Actions” menu，这样就可以愉快的使用Terminator了。</p><h2 id="搜狗拼音输入法安装问题解决方案"><a href="#搜狗拼音输入法安装问题解决方案" class="headerlink" title="搜狗拼音输入法安装问题解决方案"></a>搜狗拼音输入法安装问题解决方案</h2><p>一开始嫌麻烦所以用Linux自带的Ibus系统下的输入法，但各种问题实在忍不了，所以还是装了搜狗拼音法，中间遇到几个问题只找到这个靠谱的解决方法（<a href="https://ywnz.com/linuxjc/1476.html）。" target="_blank" rel="noopener">https://ywnz.com/linuxjc/1476.html）。</a></p><p>在根据指导方法安装搜狗拼音输入法后，会遇到很多依赖问题，一路折腾后会发现搜狗拼音依赖的fcitx-libs-qt这个包在ubuntu18.04的源里面是不存在的。替代品似乎是libfcitx-qt0，但也很难搞。</p><h3 id="下载旧版"><a href="#下载旧版" class="headerlink" title="下载旧版"></a>下载旧版</h3><p>搜狗官方的最新版（sogoupinyin_2.2.0.0102_amd64.deb）是不能用的，原因不作深究。需要下载一个旧版本（sogoupinyin_2.1.0.0086_amd64.deb）。<br>将该deb包放置于一个空目录。</p><h3 id="创建软件包目录"><a href="#创建软件包目录" class="headerlink" title="创建软件包目录"></a>创建软件包目录</h3><pre><code>mkdir -p extract/DEBIAN</code></pre><h3 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h3><pre><code>dpkg-deb -x sogoupinyin_2.1.0.0086_amd64.deb extract/dpkg-deb -e sogoupinyin_2.1.0.0086_amd64.deb extract/DEBIAN</code></pre><h3 id="修改control文件"><a href="#修改control文件" class="headerlink" title="修改control文件"></a>修改control文件</h3><p>用任意文本编辑器打开extract/DEBIAN/control 找到Depends行，删除fcitx-libs和fcitx-libs-qt，保存退出。<br>其中要找的Depends行长这个样子</p><pre><code>Depends: fcitx (&gt;= 1:4.2.8.3-3~), fcitx-frontend-gtk2, fcitx-frontend-gtk3, fcitx-frontend-qt4, fcitx-module-kimpanel, im-config, libopencc2 | libopencc1, lsb-release, unzip, x11-utils, libc6 (&gt;= 2.8), libgcc1 (&gt;= 1:4.1.1), libgdk-pixbuf2.0-0 (&gt;= 2.22.0), libglib2.0-0 (&gt;= 2.16.0), libidn11 (&gt;= 1.13), libnotify4 (&gt;= 0.7.0), libqt4-dbus (&gt;= 4:4.8.0), libqt4-declarative (&gt;= 4:4.8.0), libqt4-network (&gt;= 4:4.8.0), libqtcore4 (&gt;= 4:4.8.0), libqtgui4 (&gt;= 4:4.8.0), libstdc++6 (&gt;= 4.6), libx11-6, zlib1g (&gt;= 1:1.2.0)</code></pre><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><pre><code>mkdir builddpkg-deb -b extract/ build/</code></pre><p>执行完毕build目录下会生成一个新的deb包。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>先彻底卸载掉搜狗输入法，并删除以下配置文件：</p><p>.sogouinput</p><p>.config/fcitx</p><p>.config/sogou-qimpanel</p><p>.config/SogouPY</p><p>.config/SogouPY.users</p><p>.config/fcitx-qimpanel</p><p>然后安装我们重新打包的输入法即可。重启之后，搜狗输入法恢复正常。<br>最后要记得在设置-》区域和语言-》管理已安装的语言-》语言支持-》语言-》键盘输入法系统中选择Fcitx系统，因为搜狗输入法等都是在Fcitx系统框架下的。</p><h2 id="LINUX下无线网卡rtl8821CE-rtl8723de驱动无法驱动解决办法"><a href="#LINUX下无线网卡rtl8821CE-rtl8723de驱动无法驱动解决办法" class="headerlink" title="LINUX下无线网卡rtl8821CE/rtl8723de驱动无法驱动解决办法"></a>LINUX下无线网卡rtl8821CE/rtl8723de驱动无法驱动解决办法</h2><h3 id="1-确保linux内核版本大于-4-14"><a href="#1-确保linux内核版本大于-4-14" class="headerlink" title="1. 确保linux内核版本大于 4.14"></a>1. 确保linux内核版本大于 4.14</h3><p>  如何查看linux 内核版本 ：终端 uname -sr</p><p>  如果内核版本低于 4.14：升级linux内核 ubuntu可以参照 <a href="https://www.linuxidc.com/Linux/2017-03/141940.html" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2017-03/141940.html</a></p><p>  升级完记得重启</p><h3 id="2-下载linux中8821CE-rtl8723de的驱动源码"><a href="#2-下载linux中8821CE-rtl8723de的驱动源码" class="headerlink" title="2. 下载linux中8821CE/rtl8723de的驱动源码"></a>2. 下载linux中8821CE/rtl8723de的驱动源码</h3><p>git原地址（rtl8821CE）：<a href="https://github.com/endlessm/linux/tree/master/drivers/net/wireless/rtl8821ce" target="_blank" rel="noopener">https://github.com/endlessm/linux/tree/master/drivers/net/wireless/rtl8821ce</a></p><p>git原地址（rtl8723de）：<a href="https://github.com/endlessm/linux/tree/master/drivers/net/wireless/rtl8723de" target="_blank" rel="noopener">https://github.com/endlessm/linux/tree/master/drivers/net/wireless/rtl8723de</a></p><p>或者本地下载 <a href="https://free-1253146430.cos.ap-shanghai.myqcloud.com/rtl8821ce.zip" target="_blank" rel="noopener">https://free-1253146430.cos.ap-shanghai.myqcloud.com/rtl8821ce.zip</a></p><p>（rtl8723de 的话 自己 去git上下吧）</p><h3 id="3-编译驱动"><a href="#3-编译驱动" class="headerlink" title="3.编译驱动"></a>3.编译驱动</h3><p>  <strong><em>解压rtl8821ce.zip</em></strong></p><p>  <strong><em>修改文件Makefile</em></strong></p><pre><code>export TopDIR ?= $(srctree)/drivers/net/wireless/rtl8821ce</code></pre><p>从这行 “export TopDIR ?= 后面改成当前目录 例如我的：</p><pre><code>export TopDIR ?= /home/horsun/Downloads/rtl8821ce</code></pre><p><strong><em>保存修改</em></strong></p><p>  分别进行：</p><pre><code>makesudo make installsudo modprobe -a 8821ce</code></pre><p>遇到问题</p><pre><code>modprobe: ERROR: could not insert &apos;8812au&apos;: Exec format error</code></pre><p><strong><em>执行</em></strong></p><pre><code>make cleanmakesudo make installsudo modprobe 8812au</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录Linux配置问题的解决方案，在Ubuntu 18.04中安装terminator 并在右键菜单中添加open in termintor;解决了搜狗输入法在Ubuntu 18.04 中无法安装和安装后无法使用的问题;解决了Linux下无线网卡rtl8821CE/rtl8723ce驱动无法驱动的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年6月" scheme="http://yoursite.com/categories/2019%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>操作系统基础概念I</title>
    <link href="http://yoursite.com/2019/06/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5I/"/>
    <id>http://yoursite.com/2019/06/02/操作系统基础概念I/</id>
    <published>2019-06-02T02:42:12.000Z</published>
    <updated>2019-07-18T04:08:31.095Z</updated>
    
    <content type="html"><![CDATA[<p>总结操作系统基础概念</p><a id="more"></a><h2 id="（一）请分别简单说一说进程和线程以及它们的区别。"><a href="#（一）请分别简单说一说进程和线程以及它们的区别。" class="headerlink" title="（一）请分别简单说一说进程和线程以及它们的区别。"></a>（一）请分别简单说一说进程和线程以及它们的区别。</h2><h3 id="1-进程是资源分配的基本单位"><a href="#1-进程是资源分配的基本单位" class="headerlink" title="1.进程是资源分配的基本单位"></a>1.进程是资源分配的基本单位</h3><p>进程是具有一定功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源调度和分配的基本单位。</p><h3 id="2-线程是独立调度的基本单位"><a href="#2-线程是独立调度的基本单位" class="headerlink" title="2.线程是独立调度的基本单位"></a>2.线程是独立调度的基本单位</h3><p>线程是进程的实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。<br>一个进程可以有多个线程，多个线程也可以并发执行</p><h3 id="3-区别"><a href="#3-区别" class="headerlink" title="3.区别"></a>3.区别</h3><h4 id="I-拥有资源"><a href="#I-拥有资源" class="headerlink" title="I 拥有资源"></a>I 拥有资源</h4><p>进程是资源分配的基本单位，而线程不拥有资源，线程可以访问隶属雨进程的资源</p><h4 id="II-调度"><a href="#II-调度" class="headerlink" title="II 调度"></a>II 调度</h4><p>线程是独立调度的基本单位，在同一进程中，线程切换不会引起进程切换。从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</p><h4 id="III-系统开销"><a href="#III-系统开销" class="headerlink" title="III 系统开销"></a>III 系统开销</h4><p>在创建或撤销进程时，系统都要为之分配或者回收资源（内存空间，I/O设备），开销远大于创建或者撤销线程的开销。在进行进程切换时，涉及当前执行进程CPU环境的保存及新调度进程CPU环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</p><h4 id="IV-通信方面"><a href="#IV-通信方面" class="headerlink" title="IV 通信方面"></a>IV 通信方面</h4><p>线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助IPC。</p><p>如果你对进程或者线程不太熟悉，建议阅读：<a href="https://link.zhihu.com/?target=http%3A//www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="noopener">进程与线程的一个简单解释</a></p><h2 id="（二）线程同步的方式有哪些？"><a href="#（二）线程同步的方式有哪些？" class="headerlink" title="（二）线程同步的方式有哪些？"></a>（二）线程同步的方式有哪些？</h2><h3 id="互斥量："><a href="#互斥量：" class="headerlink" title="互斥量："></a>互斥量：</h3><p>采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。</p><h3 id="信号量："><a href="#信号量：" class="headerlink" title="信号量："></a>信号量：</h3><p>它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</p><h3 id="事件（信号）："><a href="#事件（信号）：" class="headerlink" title="事件（信号）："></a>事件（信号）：</h3><p>通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</p><p>如果你对线程同步IPC的方式不太熟悉，建议阅读：<a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/lebronjames/archive/2010/08/11/1797702.html" target="_blank" rel="noopener">线程同步的几种方式</a></p><h2 id="（三）进程的通信方式有哪些？"><a href="#（三）进程的通信方式有哪些？" class="headerlink" title="（三）进程的通信方式有哪些？"></a>（三）进程的通信方式有哪些？</h2><p>主要分为：管道（普通管道PIPE 、流管道（s_pipe）、命名管道（name_pipe））、系统IPC（包括消息队列、信号量、共享存储）、套接字（SOCKET）</p><h3 id="1-管道"><a href="#1-管道" class="headerlink" title="1.管道"></a>1.管道</h3><p><strong><em>普通管道PIPE</em></strong></p><p>管道是通过调用匹配pipe函数创建的，fd[0]用于读，fd[1]用于写。</p><pre><code>#include&lt;unistd.h&gt;int pipe(int fd[2]);</code></pre><p>管道具有以下限制：</p><p>  （1）只支持半双工通信（单向交替传输）</p><p>  （2）只能在父子进程中使用（只能在具有亲缘关系的进程间流动，进程的亲缘关系通常是父子进程）</p><p><strong><em>命名管道FIFO</em></strong></p><p>  也是半双工的通信方式，它去除了管道只能在父子进程中使用的限制，允许无亲缘关系的进程间进行通信</p><pre><code>#include&lt;sys/stat.h&gt;int mkfifo(const char *path, mode_t mode);int mkfifoat(int fd,const char *path,mode_t mode);</code></pre><p>FIFO常用于客户-服务器应用程序中，FIFO用作汇聚点，在客户进程和服务器进程之间传递数据。</p><h3 id="2-系统IPC"><a href="#2-系统IPC" class="headerlink" title="2.系统IPC"></a>2.系统IPC</h3><p><strong><em>消息队列</em></strong></p><p>是消息的链表，存放在内核中并由消息队列标识符标识。<br>相比于FIFO，消息队列有以下优点：</p><p>  （1）消息队列能够独立于读写进程的存在，从而避免了FIFO中同步管道的打开和关闭时可能产生的困难。</p><p>  （2）避免了FIFO的同步阻塞问题，不需要进程自己提供同步方法。</p><p>  （3）读进程可以根据消息类型有选择地接受消息，而不像FIFO那样只能默认地接收。</p><p><strong><em>信号量</em></strong></p><p>是一个计数器,用于为多个进程提供共享对象的访问。</p><p><strong><em>信号</em></strong></p><p>是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p><p><strong><em>共享内存</em></strong></p><p>允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种IPC。</p><p>需要使用信号量用来同步对共享存储的访问。</p><p>多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外XSL共享内存不是使用文件，而是使用内存的匿名段。</p><h3 id="3-套接字"><a href="#3-套接字" class="headerlink" title="3.套接字"></a>3.套接字</h3><p>与其它通信机制不同的是，它可用于不同机器间的进程通信。</p><p>如果你对进程的通信方式不太熟悉，建议阅读： <a href="https://blog.csdn.net/yufaw/article/details/7409596" target="_blank" rel="noopener">进程间的几种通信方式</a></p><h2 id="（四）什么是缓冲区溢出？有什么危害？其原因是什么？"><a href="#（四）什么是缓冲区溢出？有什么危害？其原因是什么？" class="headerlink" title="（四）什么是缓冲区溢出？有什么危害？其原因是什么？"></a>（四）什么是缓冲区溢出？有什么危害？其原因是什么？</h2><p>缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。</p><p>危害有以下两点：</p><p>程序崩溃，导致拒绝额服务<br>跳转并且执行一段恶意代码<br>造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入。</p><p>如果你想深入了解缓冲区溢出，推荐阅读：<a href="http://www.cnblogs.com/fanzhidongyzby/archive/2013/08/10/3250405.html" target="_blank" rel="noopener">缓冲区溢出攻击</a></p><h2 id="（五）什么是死锁？死锁产生的条件？"><a href="#（五）什么是死锁？死锁产生的条件？" class="headerlink" title="（五）什么是死锁？死锁产生的条件？"></a>（五）什么是死锁？死锁产生的条件？</h2><p>在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。</p><p>通俗的讲就是两个或多个进程无限期的阻塞、相互等待的一种状态。</p><p><strong><em>死锁产生的四个条件</em></strong>（有一个条件不成立，则不会产生死锁）</p><p><strong><em>互斥</em></strong>：一个资源一次只能被一个进程使用,每个资源要么已经分配给了一个进程，要么就是可用的。</p><p><strong><em>请求与保持</em></strong>(也叫作占有和等待)：一个进程因请求资源而阻塞时，对已获得资源保持不放</p><p><strong><em>不可剥夺</em></strong>（不可抢占）：进程获得的资源，在未完全使用完之前，不能强行剥夺，其只能被占有它的资源显式地释放。</p><p><strong><em>循环等待</em></strong>（环路等待）：若干进程之间形成一种头尾相接的环形等待资源关系</p><p><strong><em>四种解锁方法</em></strong></p><p><strong><em>鸵鸟策略</em></strong>假装问题根本没发生，因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。<br>当发生死锁时不会对用户造成多大的影响，或发生概率很低时可采用鸵鸟策略。<br>Unix，Linux和Windows等多数操作系统处理死锁的方法就是忽略它。</p><p><strong><em>死锁检测与死锁恢复</em></strong><br><img src="lock.png" alt=""></p><p><strong><em>死锁预防</em></strong></p><p><strong><em>死锁避免</em></strong></p><p>如果对死锁还不是太熟悉，建议阅读：<a href="http://www.cnblogs.com/Jessy/p/3540724.html" target="_blank" rel="noopener">死锁产生的原因和解锁的方法</a></p><h2 id="（六）进程有哪几种状态？"><a href="#（六）进程有哪几种状态？" class="headerlink" title="（六）进程有哪几种状态？"></a>（六）进程有哪几种状态？</h2><p>就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源<br>运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数<br>阻塞状态： 进程等待某种条件，在条件满足之前无法执行<br>如果你对进程的几种状态以及中间的装换不太了解，建议阅读：<a href="http://www.cnblogs.com/Jessy/p/3540724.html" target="_blank" rel="noopener">进程的三种状态及转换</a></p><h2 id="（七）分页和分段有什么区别？"><a href="#（七）分页和分段有什么区别？" class="headerlink" title="（七）分页和分段有什么区别？"></a>（七）分页和分段有什么区别？</h2><p>段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 ；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的。<br>段的大小不固定，有它所完成的功能决定；页大大小固定，由系统决定<br>段向用户提供二维地址空间；页向用户提供的是一维地址空间<br>段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。<br>如果你对分页和分段还不太了解，建议阅读：<a href="https://blog.csdn.net/wangrunmin/article/details/7967293" target="_blank" rel="noopener">分段和分页</a></p><h2 id="（八）-操作系统中进程调度策略有哪几种？"><a href="#（八）-操作系统中进程调度策略有哪几种？" class="headerlink" title="（八） 操作系统中进程调度策略有哪几种？"></a>（八） 操作系统中进程调度策略有哪几种？</h2><p>FCFS(先来先服务)，优先级，时间片轮转，多级反馈</p><p>如果你想深入的了解这几种调度策略，推荐阅读：<a href="https://blog.csdn.net/luyafei_89430/article/details/12971171" target="_blank" rel="noopener">几个常用的操作系统进程调度算法</a></p><h2 id="（九）说一说进程同步有哪几种机制。"><a href="#（九）说一说进程同步有哪几种机制。" class="headerlink" title="（九）说一说进程同步有哪几种机制。"></a>（九）说一说进程同步有哪几种机制。</h2><p>原子操作、信号量机制、自旋锁管程、会合、分布式系统</p><p>如果你想深入的了解这几种机制，推荐阅读： <a href="http://www.cnblogs.com/sonic4x/archive/2011/07/05/2098036.html" target="_blank" rel="noopener">进程同步的几种机制</a></p><h2 id="（十）说一说死锁的处理基本策略和常用方法。"><a href="#（十）说一说死锁的处理基本策略和常用方法。" class="headerlink" title="（十）说一说死锁的处理基本策略和常用方法。"></a>（十）说一说死锁的处理基本策略和常用方法。</h2><p>解决死锁的基本方法如下：</p><p>预防死锁、避免死锁、检测死锁、解除死锁</p><p>解决四多的常用策略如下：</p><p>鸵鸟策略、预防策略、避免策略、检测与解除死锁<br>如果你对死锁的处理策略不是太熟悉，推荐阅读：<a href="https://blog.csdn.net/bxyill/article/details/8237339" target="_blank" rel="noopener">产生死锁的原因和必要条件+解决死锁的基本方法</a></p><h2 id="（十一）进程通信和进程同步的区别"><a href="#（十一）进程通信和进程同步的区别" class="headerlink" title="（十一）进程通信和进程同步的区别"></a>（十一）进程通信和进程同步的区别</h2><p>进程通信是一种手段，是在进程间传输信息<br>进程同步是一种目的，是控制多个进程按照一定的顺序执行<br>为了达到进程同步的目的，需要让进程进行通信，传输进程同步所需的信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结操作系统基础概念&lt;/p&gt;
    
    </summary>
    
      <category term="2019年6月" scheme="http://yoursite.com/categories/2019%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Operating System" scheme="http://yoursite.com/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客多终端更新问题</title>
    <link href="http://yoursite.com/2019/05/28/Hexo%E5%8D%9A%E5%AE%A2%E5%A4%9A%E7%BB%88%E7%AB%AF%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/05/28/Hexo博客多终端更新问题/</id>
    <published>2019-05-28T11:19:45.000Z</published>
    <updated>2019-07-18T04:07:43.663Z</updated>
    
    <content type="html"><![CDATA[<p>记录Hexo博客多终端备份更新问题的解决方案</p><a id="more"></a><h2 id="问题介绍"><a href="#问题介绍" class="headerlink" title="问题介绍"></a>问题介绍</h2><p>很多人会把Hexo生成出来的静态网站放到GitHub Pages来进行托管。一般发布Hexo博客的流程是，首先在本地搭建Hexo的环境，编写新文章，然后利用hexo deploy来发布到Git。那么对于本地的Hexo的原始文件怎么管理呢？如果换电脑了怎么办？如果没有对原始文件进行备份，突然有一天你的本地环境挂了导致源文件丢失，那就很悲催了。可以用Dropbox或者其他方案来对源文件进行备份，但是每次更新完博客，需要备份好源文件，然后执行hexo deploy进行发布，非常麻烦。这就是写博客常遇到的多终端备份和更新问题。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>目前找到的解决方法有两种：</p><h3 id="1-持续集成"><a href="#1-持续集成" class="headerlink" title="1.持续集成"></a>1.持续集成</h3><p>用两个GitHub Repo，一个Repo放Hexo的源文件（这里称之为Source Repo），另一个Repo放Hexo生成出来的静态网站（这里称之为Content Repo），然后使用AppVeyor做持续集成。每当需要更新博客，只需要更新Source Repo，AppVeyor会自动生成静态网站并push到Content Repo，一气呵成，版本控制完全由GitHub完成，也不需要手动deploy。参见（<a href="https://formulahendry.github.io/2016/12/04/hexo-ci/）。" target="_blank" rel="noopener">https://formulahendry.github.io/2016/12/04/hexo-ci/）。</a><br>但是这种方法比较麻烦，AppVeyor的注册和使用都很不顺畅。所以我推荐下面的方法。</p><h3 id="2-git分支进行多终端工作"><a href="#2-git分支进行多终端工作" class="headerlink" title="2.git分支进行多终端工作"></a>2.git分支进行多终端工作</h3><p>这种方法是利用git的分支进行多终端工作，可以参见（<a href="http://fangzh.top）" target="_blank" rel="noopener">http://fangzh.top）</a><br>每次打开不一样的电脑，只需要进行简单的配置和在github上把文件同步下来，可以无缝操作。而且这种方法对新手比较友好。</p><h3 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h3><p>由于hexo d上传部署到github的其实是hexo编译后的文件，是用来生成网页的，不包含源文件。也就是上传的是在本地目录里自动生成的.deploy_git里面。其他文件 ，包括我们写在source 里面的，和配置文件，主题文件，都没有上传到github<br>所以可以利用git的分支管理，将源文件上传到github的另一个分支即可。</p><h3 id="上传分支"><a href="#上传分支" class="headerlink" title="上传分支"></a>上传分支</h3><p>首先，先在github上新建一个hexo分支，然后在这个仓库的settings中，选择默认分支为hexo分支（这样每次同步的时候就不用指定分支，比较方便）。<br>然后在本地的任意目录下，打开git bash，</p><pre><code>git clone git@github.com:liyiye012/liyiye012.github.io.git</code></pre><p>将其克隆到本地，因为默认分支已经设成了hexo，所以clone时只clone了hexo。接下来在克隆到本地的liyiye012.github.io中，把除了.git 文件夹外的所有文件都删掉 把之前我们写的博客源文件全部复制过来，除了.deploy_git。<br>这里应该说一句，复制过来的源文件应该有一个.gitignore，用来忽略一些不需要的文件，如果没有的话，自己新建一个，在里面写上如下，表示这些类型文件不需要git：.DS_Store</p><pre><code>Thumbs.dbdb.json*.lognode_modules/public/.deploy*/</code></pre><p>注意，如果之前克隆过theme中的主题文件，那么应该把主题文件中的.git文件夹删掉，因为git不能嵌套上传，最好是显示隐藏文件，检查一下有没有，否则上传的时候会出错，导致你的主题文件无法上传，这样你的配置在别的电脑上就用不了了。而后</p><pre><code>git add .git commit –m &quot;add branch&quot;git push</code></pre><p>这样就上传完了，可以去github上看一看hexo分支有没有上传上去，其中node_modules、public、db.json已经被忽略掉了，没有关系，不需要上传的，因为在别的电脑上需要重新输入命令安装 。</p><p>这样就上传完了。</p><h3 id="更换电脑操作"><a href="#更换电脑操作" class="headerlink" title="更换电脑操作"></a>更换电脑操作</h3><p>跟之前的环境搭建一样，安装git</p><pre><code>sudo apt-get install git</code></pre><p>设置git全局邮箱和用户名</p><pre><code>git config --global user.name &quot;yourgithubname&quot;git config --global user.email &quot;yourgithubemail&quot;</code></pre><p>设置ssh key</p><pre><code>ssh-keygen -t rsa -C &quot;youremail&quot;#生成后填到github和coding上（有coding平台的话）#验证是否成功ssh -T git@github.comssh -T git@git.coding.net #(有coding平台的话)</code></pre><p>安装nodejs</p><pre><code>sudo apt-get install nodejssudo apt-get install npm</code></pre><p>安装hexo  </p><pre><code>sudo npm install hexo-cli -g</code></pre><p>但是已经不需要初始化了，直接在任意文件夹下，git clone git@………………<br>然后进入克隆到的文件夹：cd xxx.github.io</p><pre><code>npm installnpm install hexo-deployer-git --save</code></pre><p>生成，部署：</p><pre><code>hexo ghexo d</code></pre><p>然后就可以愉快的开始写新博客了</p><pre><code>hexo new newpage</code></pre><p>Tips:不要忘了，每次写完最好都把源文件上传一下</p><pre><code>git add .git commit –m &quot;xxxx&quot;git push</code></pre><p>如果是在已经编辑过的电脑上，已经有clone文件夹了，那么，每次只要和远端同步一下就行了</p><pre><code>git pull</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录Hexo博客多终端备份更新问题的解决方案&lt;/p&gt;
    
    </summary>
    
      <category term="2019年5月" scheme="http://yoursite.com/categories/2019%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow入门-Mnist手写数字识别</title>
    <link href="http://yoursite.com/2018/11/22/TensorFlow%E5%85%A5%E9%97%A8-Mnist%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/"/>
    <id>http://yoursite.com/2018/11/22/TensorFlow入门-Mnist手写数字识别/</id>
    <published>2018-11-22T08:30:34.000Z</published>
    <updated>2019-07-18T04:08:04.114Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下Mnist手写数字识别的练习过程，网上已经有很多类似的教程比如(<a href="https://blog.csdn.net/simple_the_best/article/details/75267863，https://blog.csdn.net/cqrtxwd/article/details/79028264），" target="_blank" rel="noopener">https://blog.csdn.net/simple_the_best/article/details/75267863，https://blog.csdn.net/cqrtxwd/article/details/79028264），</a> 但会有些许问题，所以做修改后整理一下<br>当然最好的入门教程还是TensorFlow中文社区（<a href="http://www.tensorfly.cn" target="_blank" rel="noopener">www.tensorfly.cn</a>)</p><a id="more"></a><h2 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h2><p> 可在<a href="http://yann.lecun.com/exdb/mnist/下载mnist数据集，包含" target="_blank" rel="noopener">http://yann.lecun.com/exdb/mnist/下载mnist数据集，包含</a></p><pre><code>Training set images: train-images-idx3-ubyte.gz (9.9 MB, 解压后 47 MB, 包含 60,000 个样本)Training set labels: train-labels-idx1-ubyte.gz (29 KB, 解压后 60 KB, 包含 60,000 个标签)Test set images: t10k-images-idx3-ubyte.gz (1.6 MB, 解压后 7.8 MB, 包含 10,000 个样本)Test set labels: t10k-labels-idx1-ubyte.gz (5KB, 解压后 10 KB, 包含 10,000 个标签）</code></pre><p>MNIST 数据集来自美国国家标准与技术研究所, National Institute of Standards and Technology (NIST). 训练集 (training set) 由来自 250 个不同人手写的数字构成, 其中 50% 是高中学生, 50% 来自人口普查局 (the Census Bureau) 的工作人员. 测试集(test set) 也是同样比例的手写数字数据.<br>图片是以字节的形式进行存储, 我们需要把它们读取到 NumPy array 中, 以便训练和测试算法,载入数据</p><pre><code>import tensorflow as tffrom tensorflow.examples.tutorials.mnist import input_datamnist=input_data.read_data_sets(&quot;MNIST_data/&quot;,one_hot=True)import osimport structimport numpy as npdef load_mnist(path,kind=&apos;train&apos;):    labels_path=os.path.join(path,&apos;%s-labels-idx1-ubyte&apos;%kind)    images_path=os.path.join(path,&apos;%s-images-idx3-ubyte&apos;%kind)    with open(labels_path,&apos;rb&apos;) as lbpath:        magic,n=struct.unpack(&apos;&gt;II&apos;,lbpath.read(8))        labels=np.fromfile(lbpath,dtype=np.uint8)    with open(images_path,&apos;rb&apos;) as imgpath:        magic,num,rows,cols=struct.unpack(&apos;IIII&apos;,imgpath.read(16))        images=np.fromfile(imgpath,dtype=np.uint8).reshape(len(labels),784)    return images,labels</code></pre><p>load_mnist 函数返回两个数组, 第一个是一个 n x m 维的NumPy array(images), 这里的 n 是样本数(行数), m 是特征数(列数). 训练数据集包含 60,000 个样本, 测试数据集包含 10,000 样本. 在 MNIST 数据集中的每张图片由 28 x 28 个像素点构成, 每个像素点用一个灰度值表示. 在这里, 我们将 28 x 28 的像素展开为一个一维的行向量, 这些行向量就是图片数组里的行(每行 784 个值, 或者说每行就是代表了一张图片). load_mnist 函数返回的第二个数组(labels) 包含了相应的目标变量, 也就是手写数字的类标签(整数 0-9).这里对图片的读取方式做一些解释：</p><pre><code>magic, n = struct.unpack(&apos;&gt;II&apos;, lbpath.read(8))labels = np.fromfile(lbpath, dtype=np.uint8)</code></pre><p>看一下 MNIST 网站上对数据集的介绍:</p><pre><code>TRAINING SET LABEL FILE (train-labels-idx1-ubyte):[offset] [type]          [value]          [description]0000     32 bit integer  0x00000801(2049) magic number (MSB first)0004     32 bit integer  60000            number of items0008     unsigned byte   ??               label0009     unsigned byte   ??               label........xxxx     unsigned byte   ??               labelThe labels values are 0 to 9.</code></pre><p>我们首先读入 magic number, 它是一个文件协议的描述, 也是在我们调用 fromfile 方法将字节读入 NumPy array 之前在文件缓冲中的 item 数(n). 作为参数值传入 struct.unpack 的 &gt;II 有两个部分:</p><blockquote><p>: 这是指大端(用来定义字节是如何存储的); 如果你还不知道什么是大端和小端, Endianness 是一个非常好的解释. (关于大小端, 更多内容可见&lt;&lt;深入理解计算机系统 – 2.1 节信息存储&gt;&gt;)<br>I: 这是指一个无符号整数.</p></blockquote><p>通过执行下面的代码, 我们将会从刚刚解压 MNIST 数据集后的 mnist 目录下加载 60,000 个训练样本和 10,000 个测试样本.</p><h2 id="数据预览"><a href="#数据预览" class="headerlink" title="数据预览"></a>数据预览</h2><p>此时要将文件解压后放在MNIST_data文件夹下，可视化处理. 从 feature matrix 中将 784-像素值 的向量 reshape 为之前的 28*28 的形状, 然后通过 matplotlib 的 imshow 函数进行绘制:</p><pre><code>import matplotlib.pyplot as pltX_train,y_train=load_mnist(&quot;MNIST_data/&quot;,kind=&apos;train&apos;)fig, ax = plt.subplots(    nrows=2,    ncols=5,    sharex=True,    sharey=True, )ax = ax.flatten()for i in range(10):    img = X_train[y_train == i][0].reshape(28, 28)    ax[i].imshow(img, cmap=&apos;Greys&apos;, interpolation=&apos;nearest&apos;)ax[0].set_xticks([])ax[0].set_yticks([])#plt.tight_layout()plt.show()</code></pre><p>可以看到一个 2*5 的图片, 里面分别是 0-9 单个数字的图片.还可以绘制某一数字的多个样本图片, 来看一下这些手写样本到底有多不同:</p><pre><code>fig,ax=plt.subplots(    nrows=5,    ncols=5,    sharex=True,    sharey=True,)ax=ax.flatten()for i in range(25):    img=X_train[y_train==7][i].reshape(28,28)    ax[i].imshow(img,cmap=&apos;Greys&apos;,interpolation=&apos;nearest&apos;)ax[0].set_xticks([])ax[0].set_yticks([])plt.show()</code></pre><p>我们也可以选择将 MNIST 图片数据和标签保存为 CSV 文件, 这样就可以在不支持特殊的字节格式的程序中打开数据集. 但是, 有一点要说明, CSV 的文件格式将会占用更多的磁盘空间, 如下所示:</p><pre><code>train_img.csv: 109.5 MBtrain_labels.csv: 120 KBtest_img.csv: 18.3 MBtest_labels: 20 KB</code></pre><p>如果我们打算保存这些 CSV 文件, 在将 MNIST 数据集加载入 NumPy array 以后, 我们应该执行下列代码:</p><pre><code>np.savetxt(&apos;train_img.csv&apos;, X_train,           fmt=&apos;%i&apos;, delimiter=&apos;,&apos;)np.savetxt(&apos;train_labels.csv&apos;, y_train,           fmt=&apos;%i&apos;, delimiter=&apos;,&apos;)np.savetxt(&apos;test_img.csv&apos;, X_test,           fmt=&apos;%i&apos;, delimiter=&apos;,&apos;)np.savetxt(&apos;test_labels.csv&apos;, y_test,           fmt=&apos;%i&apos;, delimiter=&apos;,&apos;)</code></pre><p>一旦将数据集保存为 CSV 文件, 我们也可以用 NumPy 的 genfromtxt 函数重新将它们加载入程序中:</p><pre><code>X_train = np.genfromtxt(&apos;train_img.csv&apos;,                        dtype=int, delimiter=&apos;,&apos;)y_train = np.genfromtxt(&apos;train_labels.csv&apos;,                        dtype=int, delimiter=&apos;,&apos;)X_test = np.genfromtxt(&apos;test_img.csv&apos;,                       dtype=int, delimiter=&apos;,&apos;)y_test = np.genfromtxt(&apos;test_labels.csv&apos;,                       dtype=int, delimiter=&apos;,&apos;)</code></pre><p>不过, 从 CSV 文件中加载 MNIST 数据将会显著发给更长的时间, 因此如果可能的话, 还是建议维持数据集原有的字节格式.</p><h2 id="神经网络结构"><a href="#神经网络结构" class="headerlink" title="神经网络结构"></a>神经网络结构</h2><p>流程分为三步：<br>1.构建卷积神经网络结构<br>2.构建loss function，配置寻优器<br>3.训练，测试<br>在源码中使用了两个卷积层+池化层，最后接上两个全连接层。<br>第一层卷积使用了32个3x3x1的卷积核，步长为1，边界处理方式为“SAME”（卷积的输入和输出保持相同尺寸），激活函数为ReLu，后接一个2x2的池化层，方式为最大化池化；<br>第二层卷积使用50个3x3x32的卷积核，步长为1，边界处理方式为“SAME”，激活函数为ReLu，后接一个2x2的池化层，方式为最大化池化；<br>第一层全连接层：使用1024个神经元，激活函数为ReLu。<br>第二层全连接层：使用10个神经元，激活函数为Softmax,用于输出结果</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><pre><code>import tensorflow as tffrom tensorflow.examples.tutorials.mnist import input_data#读取数据mnist=input_data.read_data_sets(&apos;MNIST_data/&apos;,one_hot=True)sess=tf.InteractiveSession()#构建卷积神经网络结构#自定义卷积函数def conv2d(x,w):    return tf.nn.conv2d(x,w,strides=[1,1,1,1],padding=&apos;SAME&apos;)#自定义池化函数def max_pool_2x2(x):    return tf.nn.max_pool(x,ksize=[1,2,2,1],strides=[1,2,2,1],padding=&apos;SAME&apos;)#设置占位符，尺寸为样本输入和输出的尺寸x=tf.placeholder(tf.float32,[None,784])y_=tf.placeholder(tf.float32,[None,10])x_img=tf.reshape(x,[-1,28,28,1])#设置第一个卷积层和池化层w_conv1=tf.Variable(tf.truncated_normal([3,3,1,32],stddev=0.1))b_conv1=tf.Variable(tf.constant(0.1,shape=[32]))h_conv1=tf.nn.relu(conv2d(x_img,w_conv1)+b_conv1)h_pool1=max_pool_2x2(h_conv1)#设置第二个卷积层和池化层w_conv2=tf.Variable(tf.truncated_normal([3,3,32,50],stddev=0.1))b_conv2=tf.Variable(tf.constant(0.1,shape=[50]))h_conv2=tf.nn.relu(conv2d(h_pool1,w_conv2)+b_conv2)h_pool2=max_pool_2x2(h_conv2)#设置第一个全连接层w_fc1=tf.Variable(tf.truncated_normal([7*7*50,1024],stddev=0.1))b_fc1=tf.Variable(tf.constant(0.1,shape=[1024]))h_pool2_flat=tf.reshape(h_pool2,[-1,7*7*50])h_fc1=tf.nn.relu(tf.matmul(h_pool2_flat,w_fc1)+b_fc1)#dropout(随机权重失活)keep_prob=tf.placeholder(tf.float32)h_fc1_drop=tf.nn.dropout(h_fc1,keep_prob)#设置第二个全连接层w_fc2=tf.Variable(tf.truncated_normal([1024,10]))b_fc2=tf.Variable(tf.constant(0.1,shape=[10]))y_out=tf.nn.softmax(tf.matmul(h_fc1_drop,w_fc2)+b_fc2)#建立loss function,为交叉熵loss=tf.reduce_mean(-tf.reduce_sum(y_*tf.log(y_out),reduction_indices=[1]))#配置Adam优化器，学习速率为1e-4train_step=tf.train.AdamOptimizer(1e-4).minimize(loss)#建立正确率计算表达式correct_prediction=tf.equal(tf.argmax(y_out,1),tf.argmax(y_,1))accuracy=tf.reduce_mean(tf.cast(correct_prediction,tf.float32))#训练tf.global_variables_initializer().run()for i in range(20000):    batch = mnist.train.next_batch(50)    if i%100==0:        train_accuracy=accuracy.eval(feed_dict={x:batch[0],y_:batch[1],keep_prob:1})        print(&quot;ste %d,train_accuracy=%g&quot; %(i,train_accuracy))    train_step.run(feed_dict={x:batch[0],y_:batch[1],keep_prob:0.5})#训练后用测试集进行测试，输出最终结果print(&quot;test_accuracy= %h&quot; %accuracy.eval(feed_dict={x:mnist.test.images,y_:mnist.test.labels,keep_prob:1}))</code></pre><h2 id="代码详解："><a href="#代码详解：" class="headerlink" title="代码详解："></a>代码详解：</h2><pre><code>#自定义卷积函数def conv2d(x,w):    return tf.nn.conv2d(x,w,strides=[1,1,1,1],padding=&apos;SAME&apos;)#自定义池化函数def max_pool_2x2(x):    return tf.nn.max_pool(x,ksize=[1,2,2,1],strides=[1,2,2,1],padding=&apos;SAME&apos;)</code></pre><p>卷积步长为1，如果要改为步长为2则strides=[1,2,2,1],对于二维图来说只有中间两个是有效的，使用‘SAME’的padding方法（即输出与输入保持相同尺寸，边界处少一两个像素则自动补上）；池化层的设置也类似，池化尺寸为2x2</p><pre><code>#设置占位符，尺寸为样本输入和输出的尺寸x=tf.placeholder(tf.float32,[None,784])y_=tf.placeholder(tf.float32,[None,10])x_img=tf.reshape(x,[-1,28,28,1])</code></pre><p>设置输入输出的占位符，占位符是向一个会话中喂数据的入口，因为在TensorFlow的使用中通过构建计算图来设计网络，而网络的运行计算则在会话中启动，这个过程我们无法直接介入，需要通过placeholder来对一个会话进行数据输入。<br>占位符设置好之后将x变形为28x28是矩阵形式（tf.reshape()函数)</p><pre><code>#设置第一个卷积层和池化层w_conv1=tf.Variable(tf.truncated_normal([3,3,1,32],stddev=0.1))b_conv1=tf.Variable(tf.constant(0.1,shape=[32]))h_conv1=tf.nn.relu(conv2d(x_img,w_conv1)+b_conv1)h_pool1=max_pool_2x2(h_conv1)#设置第二个卷积层和池化层w_conv2=tf.Variable(tf.truncated_normal([3,3,32,50],stddev=0.1))b_conv2=tf.Variable(tf.constant(0.1,shape=[50]))h_conv2=tf.nn.relu(conv2d(h_pool1,w_conv2)+b_conv2)h_pool2=max_pool_2x2(h_conv2)</code></pre><p>第一层卷积使用3x3x1的卷积核，一共有32个卷积核，权值使用方差为0.1的截断正态分布（最大值不超过方差两倍的分布）来初始化，偏置的初值设定为常数0.1。<br>第二层卷积核第一层类似，卷积核尺寸为3x3x32（32是通道数，因为上一层使用32个卷积核，所以这一层的通道数就变成了32），这一层一共使用了50个卷积核，其他设置与上一层相同。<br>每一层卷积完之后接上一个2x2的最大化池化操作</p><pre><code>#设置第一个全连接层w_fc1=tf.Variable(tf.truncated_normal([7*7*50,1024],stddev=0.1))b_fc1=tf.Variable(tf.constant(0.1,shape=[1024]))h_pool2_flat=tf.reshape(h_pool2,[-1,7*7*50])h_fc1=tf.nn.relu(tf.matmul(h_pool2_flat,w_fc1)+b_fc1)#dropout(随机权重失活)keep_prob=tf.placeholder(tf.float32)h_fc1_drop=tf.nn.dropout(h_fc1,keep_prob)#设置第二个全连接层w_fc2=tf.Variable(tf.truncated_normal([1024,10]))b_fc2=tf.Variable(tf.constant(0.1,shape=[10]))y_out=tf.nn.softmax(tf.matmul(h_fc1_drop,w_fc2)+b_fc2)</code></pre><p>卷积层之后就是两个全连接层，第一个全连接层有1024个神经元，现将卷积层得到的2x2输出展开成一长条，使用ReLu激活函数得到输出，输出为1024维。</p><p>Dropout：在这一层使用权值随机失活，对一些神经元突触连接进行强制的置零，这个trick可以防止神经网络过拟合。这里的dropout的保留比例是0.5，即随机的保留一半权值，删除另一半。dropout比例通过placeholder来设置，因为训练过程中需要dropout，但是在最后的测试过程中，我们有希望使用全部的权值，随意dropout的比例要能够改变，这里使用placeholder。</p><p>第二个全连接层有10个神经元，分别对应0-9这19个数字，和之前每层不同，这里使用的激活函数是softmax，softmax是以指数函数作为核函数的归一化操作，与一般归一化操作不同的是，指数函数能够放大一个分布内各个数值的差异，两级分布现象会更明显。</p><pre><code>#建立loss function,为交叉熵loss=tf.reduce_mean(-tf.reduce_sum(y_*tf.log(y_out),reduction_indices=[1]))#配置Adam优化器，学习速率为1e-4train_step=tf.train.AdamOptimizer(1e-4).minimize(loss)#建立正确率计算表达式correct_prediction=tf.equal(tf.argmax(y_out,1),tf.argmax(y_,1))accuracy=tf.reduce_mean(tf.cast(correct_prediction,tf.float32))</code></pre><p>建立loss function很重要，这里使用交叉熵作为loss，交叉熵用来衡量两个分布的相似程度。两个分布越接近，则交叉熵越小。<br>使用Adam优化器来最小化loss，配置学习速率为1e-4，然后建立正确率的计算表达式，tf.argmax(y_,1)函数用来返回其中最大的值的下标，tf.equal用来计算两个值是否相等，tf.cast()函数用来实现数据类型转换，tf.reduce_mean()用来求平均（得到正确率）</p><pre><code>#训练tf.global_variables_initializer().run()for i in range(20000):    batch = mnist.train.next_batch(50)    if i%100==0:        train_accuracy=accuracy.eval(feed_dict={x:batch[0],y_:batch[1],keep_prob:1})        print(&quot;ste %d,train_accuracy=%g&quot; %(i,train_accuracy))    train_step.run(feed_dict={x:batch[0],y_:batch[1],keep_prob:0.5})</code></pre><p>对网络进行训练，首先使用<code>tf.global_variables_initializer().run()</code>初始化所有数据，从mnist训练数据集中集中一次取50个样本作为一组训练，共进行20000组训练，每100次就输出一次该组数据上的正确率，进行训练计算的方式是<code>train_step.run(feed_dict={x:batch[0],y_:batch[1],keep_prob:0.5})</code><br>,通过feed_dict来对会话输送训练数据（以及其他一些想在计算过程中实时调整的参数，比如dropout比例）<br>这段代码中可以看到，训练时dropout的保留比例是0.5，测试时的保留比例是1.</p><pre><code>#训练后用测试集进行测试，输出最终结果print(&quot;test_accuracy= %h&quot; %accuracy.eval(feed_dict={x:mnist.test.images,y_:mnist.test.labels,keep_prob:1}))</code></pre><p>最后输入测试集进行测试验证</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下Mnist手写数字识别的练习过程，网上已经有很多类似的教程比如(&lt;a href=&quot;https://blog.csdn.net/simple_the_best/article/details/75267863，https://blog.csdn.net/cqrtxwd/article/details/79028264），&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/simple_the_best/article/details/75267863，https://blog.csdn.net/cqrtxwd/article/details/79028264），&lt;/a&gt; 但会有些许问题，所以做修改后整理一下&lt;br&gt;当然最好的入门教程还是TensorFlow中文社区（&lt;a href=&quot;http://www.tensorfly.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.tensorfly.cn&lt;/a&gt;)&lt;/p&gt;
    
    </summary>
    
      <category term="2018年11月" scheme="http://yoursite.com/categories/2018%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="TensorFlow" scheme="http://yoursite.com/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>235.Lowest Common Ancestor of a Binary Search Tree 二叉搜索树的最近公共祖先</title>
    <link href="http://yoursite.com/2018/10/30/235.Lowest%20Common%20Ancestor%20of%20a%20Binary%20Search%20Tree%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <id>http://yoursite.com/2018/10/30/235.Lowest Common Ancestor of a Binary Search Tree 二叉搜索树的最近公共祖先/</id>
    <published>2018-10-30T02:13:20.000Z</published>
    <updated>2019-07-18T06:30:25.299Z</updated>
    
    <content type="html"><![CDATA[<p> 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><a id="more"></a><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p><pre><code>     _______6______    /              \ ___2__          ___8__/      \        /      \0      _4       7       9      /  \      3   5</code></pre><p>示例 1:</p><pre><code>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8输出: 6解释: 节点 2 和节点 8 的最近公共祖先是 6。</code></pre><p>示例 2:</p><pre><code>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4输出: 2解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。说明:所有节点的值都是唯一的。p、q 为不同节点且均存在于给定的二叉搜索树中。</code></pre><h2 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h2><pre><code>/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {        if(root.val&gt;p.val &amp;&amp; root.val&gt;q.val){            return lowestCommonAncestor(root.left,p,q);        }        else if(root.val&lt;p.val &amp;&amp; root.val&lt;q.val){            return lowestCommonAncestor(root.right,p,q);        }else return root;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年10月" scheme="http://yoursite.com/categories/2018%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>Permutations全排列问题总结</title>
    <link href="http://yoursite.com/2018/10/11/Permutations%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/10/11/Permutations全排列问题总结/</id>
    <published>2018-10-11T02:33:14.000Z</published>
    <updated>2019-07-18T04:08:00.302Z</updated>
    
    <content type="html"><![CDATA[<p>总结几个常见的全排列问题<br>46.Permutations 全排列<br>47.PermutationsII 全排列II<br>31.Next Permutations 下一个排列<br>60.Permutation Sequence 第k个排列<br>266.Palindrome Permutation 回文排列<br>267.Palindrome PermutationII 回文排列II</p><a id="more"></a><h2 id="46-Permutations-全排列"><a href="#46-Permutations-全排列" class="headerlink" title="46.Permutations 全排列"></a>46.Permutations 全排列</h2><p>给定一个没有重复数字的序列，返回其所有可能的全排列。</p><p>示例:</p><pre><code>输入: [1,2,3]输出:[  [1,2,3],  [1,3,2],  [2,1,3],  [2,3,1],  [3,1,2],  [3,2,1]]</code></pre><h3 id="回溯思路"><a href="#回溯思路" class="headerlink" title="回溯思路"></a>回溯思路</h3><p>回溯的写法，每次交换nums里面的两个数字，经过回溯可以生成所有的排列情况</p><pre><code>class Solution {public:    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) {        vector&lt;vector&lt;int&gt;&gt; result;        permuteRecursive(nums,0,result);        return result;    }    void output(vector&lt;vector&lt;int&gt;&gt; result){        cout&lt;&lt;&quot;start to print&quot;&lt;&lt;endl;        for(int i=0;i&lt;result.size();i++){            for(int j=0;j&lt;result[i].size();j++){                cout&lt;&lt;result[i][j];            }cout&lt;&lt;endl;        }        cout&lt;&lt;&quot;end to print&quot;&lt;&lt;endl;    }    void permuteRecursive(vector&lt;int&gt; &amp;num,int begin,vector&lt;vector&lt;int&gt;&gt; &amp;result){        // cout&lt;&lt;&quot;begin=&quot;&lt;&lt;begin&lt;&lt;endl;        // cout&lt;&lt;&quot;   num=&quot;;        // for(int i=0;i&lt;num.size();i++) cout&lt;&lt;num[i]&lt;&lt;&quot; &quot;;        // cout&lt;&lt;endl;        // output(result);        if(begin&gt;=num.size()){            result.push_back(num);            return ;        }        for(int i=begin;i&lt;num.size();i++){            swap(num[begin],num[i]);            permuteRecursive(num,begin+1,result);            swap(num[begin],num[i]);        }    }};</code></pre><h3 id="DFS思路"><a href="#DFS思路" class="headerlink" title="DFS思路"></a>DFS思路</h3><p>这种方法是CareerCup书上的方法，也挺不错的，这道题是思想是这样的：</p><p>当n=1时，数组中只有一个数a1，其全排列只有一种，即为a1</p><p>当n=2时，数组中此时有a1a2，其全排列有两种，a1a2和a2a1，那么此时我们考虑和上面那种情况的关系，我们发现，其实就是在a1的前后两个位置分别加入了a2</p><p>当n=3时，数组中有a1a2a3，此时全排列有六种，分别为a1a2a3, a1a3a2, a2a1a3, a2a3a1, a3a1a2, 和 a3a2a1。那么根据上面的结论，实际上是在a1a2和a2a1的基础上在不同的位置上加入a3而得到的。</p><p>_ a1 _ a2 _ : a3a1a2, a1a3a2, a1a2a3</p><p>_ a2 _ a1 _ : a3a2a1, a2a3a1, a2a1a3</p><pre><code>class Solution {public:vector&lt;vector&lt;int&gt; &gt; permute(vector&lt;int&gt; &amp;num) {    vector&lt;vector&lt;int&gt; &gt; ans;    dfs(num, ans);    return ans;}void dfs(vector&lt;int&gt; &amp;num, vector&lt;vector&lt;int&gt;&gt; &amp;ans) {    if (num.size() == 1) {        vector&lt;int&gt; tmp(num.begin(), num.end());        ans.push_back(tmp);        return;    }    vector&lt;vector&lt;int&gt; &gt; ans1;    vector&lt;int&gt; num1(num.begin()+1, num.end());    dfs(num1, ans);    for(int i = 0; i &lt; ans.size(); ++i) {        for(int j = 0; j &lt;= ans[i].size(); ++j) {            vector&lt;int&gt; tmp = ans[i];            tmp.insert(tmp.begin()+j, num[0]);            ans1.push_back(tmp);        }    }    ans = ans1;}};</code></pre><h2 id="47-PermutationsII-全排列II"><a href="#47-PermutationsII-全排列II" class="headerlink" title="47.PermutationsII 全排列II"></a>47.PermutationsII 全排列II</h2><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p><p>示例:</p><pre><code>输入: [1,1,2]输出:[  [1,1,2],  [1,2,1],  [2,1,1]]</code></pre><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>  这里我们先考虑一下，它与上题唯一的不同在于：在DFS函数中，做循环遍历时，如果与当前元素相同的一个元素已经被取用过，则要跳过所有值相同的元素。<br>  举个例子：对于序列&lt;1,1,2,3&gt;。在DFS首遍历时，1 作为首元素被加到list中，并进行后续元素的添加；那么，当DFS跑完第一个分支，遍历到1 (第二个)时，这个1 不再作为首元素添加到list中，因为1 作为首元素的情况已经在第一个分支中考虑过了。<br>  为了实现这一剪枝思路，有了如下的解题算法。</p><p>解题算法：</p><p>  1. 先对给定的序列nums进行排序，使得大小相同的元素排在一起。<br>  2. 新建一个used数组，大小与nums相同，用来标记在本次DFS读取中，位置i的元素是否已经被添加到list中了。<br>  3. 根据思路可知，我们选择跳过一个数，当且仅当这个数与前一个数相等，并且前一个数未被添加到list中。</p><pre><code>class Solution {public:    void recursion(vector&lt;int&gt; num, int i, int j, vector&lt;vector&lt;int&gt; &gt; &amp;res) {        if (i == j-1) {            res.push_back(num);            return;        }        for (int k = i; k &lt; j; k++) {            if (i != k &amp;&amp; num[i] == num[k]) continue;            swap(num[i], num[k]);            recursion(num, i+1, j, res);        }    }    vector&lt;vector&lt;int&gt; &gt; permuteUnique(vector&lt;int&gt; &amp;num) {        sort(num.begin(), num.end());        vector&lt;vector&lt;int&gt; &gt;res;        recursion(num, 0, num.size(), res);        return res;    }};</code></pre><h2 id="31-Next-Permutations-下一个排列"><a href="#31-Next-Permutations-下一个排列" class="headerlink" title="31.Next Permutations 下一个排列"></a>31.Next Permutations 下一个排列</h2><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须原地修改，只允许使用额外常数空间。</p><p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。</p><pre><code>1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1</code></pre><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>  这里，先考虑一个序列的最大最小情况。当一个序列为非递减序列时，它必然是该组数的最小的排列数；同理，当一个序列为非递增序列时，它必然是该组数的最大的排列数。  </p><p>  由此，我们可以知道，本题的关键即是求出数组末尾的最长的非递增子序列。<br>  不妨假设在数组nums中，nums[k+1]…nums[n]均满足前一个元素大于等于后一个元素，即这一子序列非递增。<br>  那么，我们要做的，就是把nums[k]与其后序列中稍大于nums[k]的数交换，接着再逆序nums[k+1]…nums[n]即可。</p><pre><code>class Solution {public:    void nextPermutation(vector&lt;int&gt;&amp; nums) {        int n = nums.size(), k, l;        for (k = n - 2; k &gt;= 0; k--) {            if (nums[k] &lt; nums[k + 1]) {                break;            }        }        if (k &lt; 0) {            reverse(nums.begin(), nums.end());        } else {            for (l = n - 1; l &gt; k; l--) {                if (nums[l] &gt; nums[k]) {                    break;                }            }            swap(nums[k], nums[l]);            reverse(nums.begin() + k + 1, nums.end());        }    }};</code></pre><h2 id="60-Permutation-Sequence-第k个排列"><a href="#60-Permutation-Sequence-第k个排列" class="headerlink" title="60.Permutation Sequence 第k个排列"></a>60.Permutation Sequence 第k个排列</h2><p>给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。</p><p>按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：</p><pre><code>&quot;123&quot;&quot;132&quot;&quot;213&quot;&quot;231&quot;&quot;312&quot;&quot;321&quot;</code></pre><p>给定 n 和 k，返回第 k 个排列。</p><p>说明：</p><pre><code>给定 n 的范围是 [1, 9]。给定 k 的范围是[1,  n!]。</code></pre><p>示例 1:</p><pre><code>输入: n = 3, k = 3输出: &quot;213&quot;</code></pre><p>示例 2:</p><pre><code>输入: n = 4, k = 9输出: &quot;2314&quot;</code></pre><h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>  这里我们先考虑一个特殊情况，当n=4时，序列为[1,2,3,4]，有以下几种情况：<br>  “1+(2,3,4)的全排列”<br>  “2+(1,3,4)的全排列”<br>  “3+(1,2,4)的全排列”<br>  “4+(1,2,3)的全排列”<br>  我们已经知道，对于n个数的全排列，有n!种情况。所以，3个数的全排列就有6种情况。<br>  <br>  如果我们这里给定的k为14，那么它将会出现在：<br>    “3+(1,2,4)的全排列”<br>  这一情况中。</p><p>  我们可以程式化地得到这个结果：取k=13(从0开始计数)，(n-1)!=3!=6，k/(n-1)!=2，而3在有序序列[1,2,3,4]中的索引就是2。<br>  同理，我们继续计算，新的k=13%6=1，新的n=3，那么1/(n-1)!=2/2=0。在序列[1,2,4]中，索引0的数是1。那么，此时的字符串为”31”。<br>  继续迭代，新的k=1%2=1，新的n=2，那么k/(n-1)!=1/1=1。在序列[2,4]中，索引为1的数是4。那么，此时的字符串为”314”。最后在串尾添上仅剩的2，可以得到字符串”3142”。<br>  经过验算，此串确实是序列[1,2,3,4]的全排列数中第14大的序列。</p><p>解题算法：</p><p>  1. 创建一个长度为n 的数组array，存放对应下标n的阶乘值。<br>  2. 再新建一个长度为n 的数组nums，初始值为nums[i]=i+1，用来存放待选的字符序列。<br>  3. 将得到的k减1后，开始迭代。迭代的规则是：迭代n次，每次选nums数组中下标为k/(n-1)!的数放在字符串的末尾，新的k=k%(n-1)!，新的n=n-1。<br>  4. 最后，返回得到的字符串。</p><pre><code>class Solution {public:    string getPermutation(int n, int k) {        // initialize a dictionary that stores 1, 2, ..., n. This string will store the permutation.        string dict(n, 0);        iota(dict.begin(), dict.end(), &apos;1&apos;);        // build up a look-up table, which stores (n-1)!, (n-2)!, ..., 1!, 0!        vector&lt;int&gt; fract(n, 1);        for (int idx = n - 3; idx &gt;= 0; --idx) {            fract[idx] = fract[idx + 1] * (n - 1 - idx);        }        // let k be zero base        --k;        // the main part.        string ret(n, 0);        for (int idx = 0; idx &lt; n; ++idx) {            int select = k / fract[idx];            k %= fract[idx];            ret[idx] = dict[select];            dict.erase(next(dict.begin(), select)); // note that it is an O(n) operation        }        return ret;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结几个常见的全排列问题&lt;br&gt;46.Permutations 全排列&lt;br&gt;47.PermutationsII 全排列II&lt;br&gt;31.Next Permutations 下一个排列&lt;br&gt;60.Permutation Sequence 第k个排列&lt;br&gt;266.Palindrome Permutation 回文排列&lt;br&gt;267.Palindrome PermutationII 回文排列II&lt;/p&gt;
    
    </summary>
    
      <category term="2018年10月" scheme="http://yoursite.com/categories/2018%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>84.Largest Rectangle in Histogram柱状图中最大的矩形</title>
    <link href="http://yoursite.com/2018/10/09/84.Largest%20Rectangle%20in%20Histogram%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/"/>
    <id>http://yoursite.com/2018/10/09/84.Largest Rectangle in Histogram柱状图中最大的矩形/</id>
    <published>2018-10-09T02:06:44.000Z</published>
    <updated>2019-07-18T04:03:28.415Z</updated>
    
    <content type="html"><![CDATA[<p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><a id="more"></a><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p>柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。</p><p>阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。</p><p>示例:</p><pre><code>输入: [2,1,5,6,2,3]输出: 10</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>分析寻找的过程，如果要在O(n)的时间内找到最大的面积，则需要记录下来每个高度为N的矩形，其长度最大可以达到多少。这样就分为两种情况，如图中描述的，首先是高度N越来越大，其次是高度N越来越小。</p><p>1.在高度N越来越大时，其上一个数字构成的高度的矩形的最大长度则增加1，例如，2 3，高度为3时，则高度为2的矩形的长度就加1. 2.在高度N越来越小时，其上一个数字构成的高度的矩形的最大长度就不变，例如 4 3，高度为4时，其构成的矩形长度为1，到了3，矩形长度没有递增，而4之前的数字3构成的矩形的长度也加1。</p><p>可以使用一个stack来存储矩形的高度和长度，其中长度会动态的变化。当遇到一个数字大于栈顶数字的时候就压入栈，小于栈顶的数字就弹出栈，在这个动态过程中，更新最大的矩形面积。</p><pre><code>class Solution {public:    int largestRectangleArea(vector&lt;int&gt;&amp; heights) {        heights.push_back(0);        int len=heights.size();        stack&lt;int&gt; stk;        int i=0,maxarea=0;        while(i&lt;len){            if(stk.empty() || heights[i]&gt;=heights[stk.top()]) {                stk.push(i);                i++;            }            else{                int h=stk.top();                stk.pop();                maxarea=max(maxarea,heights[h]*(stk.empty()? i: i-stk.top()-1));            }        }        return maxarea;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年10月" scheme="http://yoursite.com/categories/2018%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>52. N-QueensNII皇后II</title>
    <link href="http://yoursite.com/2018/10/05/52.%20N-QueensIIN%E7%9A%87%E5%90%8EII/"/>
    <id>http://yoursite.com/2018/10/05/52. N-QueensIIN皇后II/</id>
    <published>2018-10-05T11:55:26.000Z</published>
    <updated>2019-07-18T04:03:05.140Z</updated>
    
    <content type="html"><![CDATA[<p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><a id="more"></a><p>给定一个整数 n，返回 n 皇后不同的解决方案的数量。</p><p>示例:</p><p>输入: 4<br>输出: 2<br>解释: 4 皇后问题存在如下两个不同的解法。<br>[<br> [“.Q..”,  // 解法 1<br>  “…Q”,<br>  “Q…”,<br>  “..Q.”],</p><p> [“..Q.”,  // 解法 2<br>  “Q…”,<br>  “…Q”,<br>  “.Q..”]<br>]</p><h2 id="思路-DFS"><a href="#思路-DFS" class="headerlink" title="思路 DFS"></a>思路 DFS</h2><pre><code>def totalNQueens(self, n):    self.res = 0    self.dfs([-1]*n, 0)    return self.resdef dfs(self, nums, index):    if index == len(nums):        self.res += 1        return    for i in xrange(len(nums)):        nums[index] = i        if self.valid(nums, index):            self.dfs(nums, index+1)def valid(self, nums, n):    for i in xrange(n):        if nums[i] == nums[n] or abs(nums[n]-nums[i]) == n-i:            return False    return True</code></pre><h2 id="C-版"><a href="#C-版" class="headerlink" title="C++版"></a>C++版</h2><pre><code>int totalNQueens(int n) {    vector&lt;bool&gt; col(n, true);    vector&lt;bool&gt; anti(2*n-1, true);    vector&lt;bool&gt; main(2*n-1, true);    vector&lt;int&gt; row(n, 0);    int count = 0;    dfs(0, row, col, main, anti, count);    return count;}void dfs(int i, vector&lt;int&gt; &amp;row, vector&lt;bool&gt; &amp;col, vector&lt;bool&gt;&amp; main, vector&lt;bool&gt; &amp;anti, int &amp;count) {        if (i == row.size()) {            count++;            return;        }       for (int j = 0; j &lt; col.size(); j++) {         if (col[j] &amp;&amp; main[i+j] &amp;&amp; anti[i+col.size()-1-j]) {             row[i] = j;             col[j] = main[i+j] = anti[i+col.size()-1-j] = false;             dfs(i+1, row, col, main, anti, count);             col[j] = main[i+j] = anti[i+col.size()-1-j] = true;      }    }</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年10月" scheme="http://yoursite.com/categories/2018%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>51. N-QueensN皇后</title>
    <link href="http://yoursite.com/2018/10/05/51.%20N-QueensN%E7%9A%87%E5%90%8E/"/>
    <id>http://yoursite.com/2018/10/05/51. N-QueensN皇后/</id>
    <published>2018-10-05T11:19:45.000Z</published>
    <updated>2019-07-18T06:32:04.263Z</updated>
    
    <content type="html"><![CDATA[<p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><a id="more"></a><p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p><p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><p>示例:</p><pre><code>输入: 4输出: [ [&quot;.Q..&quot;,  // 解法 1  &quot;...Q&quot;,  &quot;Q...&quot;,  &quot;..Q.&quot;], [&quot;..Q.&quot;,  // 解法 2  &quot;Q...&quot;,  &quot;...Q&quot;,  &quot;.Q..&quot;]]解释: 4 皇后问题存在两个不同的解法。</code></pre><h2 id="思路1-递归"><a href="#思路1-递归" class="headerlink" title="思路1 递归"></a>思路1 递归</h2><p>尝试每个可能存在皇后的位置</p><pre><code>class Solution {private:    vector&lt;vector&lt;string&gt;&gt; res;public:    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) {       vector&lt;string&gt; cur(n,string(n,&apos;.&apos;));        helper(cur,0);        return res;    }    void helper(vector&lt;string&gt; &amp;cur,int row){        if(row==cur.size()){            res.push_back(cur);            return;        }        for(int col=0;col&lt;cur.size();col++)            if(isValid(cur,row,col)){                cur[row][col]=&apos;Q&apos;;                helper(cur,row+1);                cur[row][col]=&apos;.&apos;;            }    }    bool isValid(vector&lt;string&gt; &amp;cur,int row,int col){        for(int i=0;i&lt;row;i++)            if(cur[i][col] == &apos;Q&apos;) return false;        for(int i=row-1,j=col-1;i&gt;=0 &amp;&amp; j&gt;=0;i--,j--)            if(cur[i][j]==&apos;Q&apos;) return false;        for(int i=row-1,j=col+1;i&gt;=0 &amp;&amp; j&lt;cur.size();i--,j++)            if(cur[i][j]==&apos;Q&apos;) return false;        return true;    }};</code></pre><h2 id="思路2：DFS"><a href="#思路2：DFS" class="headerlink" title="思路2：DFS"></a>思路2：DFS</h2><p>queen用来记录皇后的横纵坐标位置，xy_dif用来记录横纵坐标之差，xy_sum用来记录横纵坐标之和，p + q == x + y 时在同一条对角线上， p - q == x - y时在同一条反对角线上</p><pre><code>def solveNQueens(self, n):    def DFS(queens, xy_dif, xy_sum):        p = len(queens)        if p==n:            result.append(queens)            return None        for q in range(n):            if q not in queens and p-q not in xy_dif and p+q not in xy_sum:                DFS(queens+[q], xy_dif+[p-q], xy_sum+[p+q])      result = [] #全局变量    DFS([],[],[])    return [ [&quot;.&quot;*i + &quot;Q&quot; + &quot;.&quot;*(n-i-1) for i in sol] for sol in result]</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年10月" scheme="http://yoursite.com/categories/2018%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>102.Binary Tree Level Order Traversal二叉树的层次遍历</title>
    <link href="http://yoursite.com/2018/10/04/102.Binary%20Tree%20Level%20Order%20Traversal%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%20/"/>
    <id>http://yoursite.com/2018/10/04/102.Binary Tree Level Order Traversal二叉树的层次遍历 /</id>
    <published>2018-10-04T11:14:32.000Z</published>
    <updated>2019-07-18T06:30:49.533Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。</p><a id="more"></a><p>例如:</p><pre><code>给定二叉树: [3,9,20,null,null,15,7],    3   / \  9  20    /  \   15   7</code></pre><p>返回其层次遍历结果：</p><pre><code>[  [3],  [9,20],  [15,7]]</code></pre><h2 id="思路1-递归"><a href="#思路1-递归" class="headerlink" title="思路1:递归"></a>思路1:递归</h2><pre><code>/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {        vector&lt;vector&lt;int&gt;&gt; res;        leveltravel(res,0,root);        return res;    }    void leveltravel(vector&lt;vector&lt;int&gt;&gt; &amp;res,int depth,TreeNode * root){         if(!root) return ;        vector&lt;int&gt; temp;        if(res.size()==depth) res.push_back(temp);        res[depth].push_back(root-&gt;val);        leveltravel(res,depth+1,root-&gt;left);        leveltravel(res,depth+1,root-&gt;right);        return;    }};</code></pre><h2 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h2><p>在做的过程中注意队列的大小会随时变化，因此需要将q.size()保存为一个变量</p><pre><code>/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {        queue&lt;TreeNode *&gt; q;        vector&lt;vector&lt;int&gt;&gt; res;        if(root) {            q.push(root);        }        while(!q.empty()){         vector&lt;int&gt; temp;           int len=q.size();         for(int i=0;i&lt;len;i++){            TreeNode *cur;            cur=q.front();            temp.push_back(cur-&gt;val);            q.pop();             //cout&lt;&lt;&quot;i=&quot;&lt;&lt;i&lt;&lt;&quot;   cur-&gt;val=&quot;&lt;&lt;cur-&gt;val&lt;&lt;endl;            if(cur-&gt;left) q.push(cur-&gt;left);            if(cur-&gt;right) q.push(cur-&gt;right);            }            //cout&lt;&lt;&quot;  *********&quot;&lt;&lt;endl;            res.push_back(temp);        }    return res;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年10月" scheme="http://yoursite.com/categories/2018%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Breadth-first Search" scheme="http://yoursite.com/tags/Breadth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>117.Populating Next Right Pointers in Each NodeII填充同一层的兄弟节点II</title>
    <link href="http://yoursite.com/2018/10/04/117.Populating%20Next%20Right%20Pointers%20in%20Each%20NodeII%E5%A1%AB%E5%85%85%E5%90%8C%E4%B8%80%E5%B1%82%E7%9A%84%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9II/"/>
    <id>http://yoursite.com/2018/10/04/117.Populating Next Right Pointers in Each NodeII填充同一层的兄弟节点II/</id>
    <published>2018-10-04T11:14:32.000Z</published>
    <updated>2019-07-18T06:38:10.650Z</updated>
    
    <content type="html"><![CDATA[<p>填充同一层的兄弟节点II</p><a id="more"></a><p>给定一个二叉树</p><pre><code>struct TreeLinkNode {  TreeLinkNode *left;  TreeLinkNode *right;  TreeLinkNode *next;}</code></pre><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><!-- more --><p>说明:</p><p>你只能使用额外常数空间。<br>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。<br>示例:</p><p>给定二叉树，</p><pre><code>     1   /  \  2    3 / \    \4   5    7</code></pre><p>调用你的函数后，该二叉树变为：</p><pre><code>     1 -&gt; NULL   /  \  2 -&gt; 3 -&gt; NULL / \    \4-&gt; 5 -&gt; 7 -&gt; NULL</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用三个指针，head指向下一层的第一个结点，prev指向下一层的当前结点，cur指向当前层的当前结点，分层遍历，再按照当前结点是否有左结点和右结点分情况讨论，以当前结点有左结点为例，如果prev为空，说明当前层尚未被遍历过，因此初始化head，若非空说明已经被遍历过，上一个被遍历过的结点是prev，因此将prev的next指向当前结点左结点，然后推进一步，将prev置为cur-&gt;left</p><pre><code>/** * Definition for binary tree with next pointer. * struct TreeLinkNode { *  int val; *  TreeLinkNode *left, *right, *next; *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {} * }; */class Solution {public:    void connect(TreeLinkNode *root) {        TreeLinkNode *head = NULL; //head of the next level        TreeLinkNode *prev = NULL; //the leading node on the next level        TreeLinkNode *cur = root;  //current node of current level        while (cur != NULL) {            while (cur != NULL) { //iterate on the current level                //left child                if (cur-&gt;left != NULL) {                    if (prev != NULL) {                        prev-&gt;next = cur-&gt;left;                    } else {                        head = cur-&gt;left;                    }                    prev = cur-&gt;left;                }                //right child                if (cur-&gt;right != NULL) {                    if (prev != NULL) {                        prev-&gt;next = cur-&gt;right;                    } else {                        head = cur-&gt;right;                    }                    prev = cur-&gt;right;                }                //move to next node                cur = cur-&gt;next;            }            //move to next level            cur = head;            head = NULL;            prev = NULL;        }    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;填充同一层的兄弟节点II&lt;/p&gt;
    
    </summary>
    
      <category term="2018年10月" scheme="http://yoursite.com/categories/2018%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>199.Binary Tree Right Side View二叉树的右视图</title>
    <link href="http://yoursite.com/2018/10/04/199.Binary%20Tree%20Right%20Side%20View%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/"/>
    <id>http://yoursite.com/2018/10/04/199.Binary Tree Right Side View二叉树的右视图/</id>
    <published>2018-10-04T11:14:32.000Z</published>
    <updated>2019-07-18T04:04:54.455Z</updated>
    
    <content type="html"><![CDATA[<p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><a id="more"></a><p>示例:</p><pre><code>输入: [1,2,3,null,5,null,4]输出: [1, 3, 4]解释:   1            &lt;--- /   \2     3         &lt;--- \     \  5     4       &lt;---</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用队列层次遍历二叉树，存储每层最右边的结点</p><pre><code>/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public:    vector&lt;int&gt; rightSideView(TreeNode* root) {        vector&lt;int&gt; res;        queue&lt;TreeNode*&gt; q;        if(root) q.push(root);        while(!q.empty()){            int len=q.size();            for(int i=0;i&lt;len;i++){                TreeNode *cur=q.front();                q.pop();                if(i==len-1)res.push_back(cur-&gt;val);                if(cur-&gt;left) q.push(cur-&gt;left);                if(cur-&gt;right) q.push(cur-&gt;right);            }        }        return res;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年10月" scheme="http://yoursite.com/categories/2018%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Breadth-first Search" scheme="http://yoursite.com/tags/Breadth-first-Search/"/>
    
      <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
  </entry>
  
</feed>
