<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-29T06:41:10.110Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>217. 存在重复元素</title>
    <link href="http://yoursite.com/2020/06/29/217.%20%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2020/06/29/217. 存在重复元素/</id>
    <published>2020-06-29T06:33:12.000Z</published>
    <updated>2020-06-29T06:41:10.110Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数数组，判断是否存在重复元素。如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。</p><a id="more"></a><h1 id="哈希表解决"><a href="#哈希表解决" class="headerlink" title="哈希表解决"></a>哈希表解决</h1><p>可以用Set或HashMap来解决</p><figure class="highlight java"><figcaption><span>[solution 3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(nums.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x: nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(x)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        set.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多详细分析见<a href="https://leetcode-cn.com/problems/contains-duplicate/solution/cun-zai-zhong-fu-yuan-su-by-leetcode/" target="_blank" rel="noopener">^1</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://leetcode-cn.com/problems/contains-duplicate-ii/" target="_blank" rel="noopener">219 存在重复元素 II</a></li><li><a href="https://leetcode-cn.com/problems/contains-duplicate-iii/" target="_blank" rel="noopener">220 存在重复元素 III</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数数组，判断是否存在重复元素。如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>152. 乘积最大子数组</title>
    <link href="http://yoursite.com/2020/06/29/152.%20%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2020/06/29/152. 乘积最大子数组/</id>
    <published>2020-06-29T06:06:12.000Z</published>
    <updated>2020-06-29T06:23:19.793Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。</code></pre><p>示例 2:</p><pre><code>输入: [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</code></pre><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这道题比较经典，官方解法可以见<a href="https://leetcode-cn.com/problems/maximum-product-subarray/solution/cheng-ji-zui-da-zi-shu-zu-by-leetcode-solution/" target="_blank" rel="noopener">^1</a>,我首先想到用全局变量和局部变量的方法来解决，但是要注意两个测试样例[-2]和[0,2]，需要对全局和局部最大变量做相应处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProduct(int[] nums) &#123;</span><br><span class="line">        int maxpro=nums[0];</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            int localpro=nums[i];</span><br><span class="line">            maxpro = Math.max(maxpro, localpro);</span><br><span class="line">            for (int j = i+1; j &lt; nums.length; j++) &#123;</span><br><span class="line">                localpro *= nums[j];</span><br><span class="line">                maxpro = Math.max(maxpro, localpro);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxpro;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>189. 旋转数组</title>
    <link href="http://yoursite.com/2020/06/29/189.%20%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2020/06/29/189. 旋转数组/</id>
    <published>2020-06-29T06:06:12.000Z</published>
    <updated>2020-06-29T06:23:14.982Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4]</code></pre><p>示例 2:</p><pre><code>输入: [-1,-100,3,99] 和 k = 2输出: [3,99,-1,-100]解释: 向右旋转 1 步: [99,-1,-100,3]向右旋转 2 步: [3,99,-1,-100]</code></pre><p>说明:</p><pre><code>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。要求使用空间复杂度为 O(1) 的 原地 算法。</code></pre><h2 id="方法-1：暴力"><a href="#方法-1：暴力" class="headerlink" title="方法 1：暴力"></a>方法 1：暴力</h2><p>最简单的方法是旋转 k 次，每次将数组旋转 1 个元素。</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp, previous;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            previous = nums[nums.length - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                temp = nums[j];</span><br><span class="line">                nums[j] = previous;</span><br><span class="line">                previous = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(n*k)</em> 。每个元素都被移动 1 步（<em>O(n)</em>） k次（<em>O(k)</em>） 。</li><li>空间复杂度：<em>O(1)</em> 。没有额外空间被使用。</li></ul><h2 id="方法-2：使用额外的数组"><a href="#方法-2：使用额外的数组" class="headerlink" title="方法 2：使用额外的数组"></a>方法 2：使用额外的数组</h2><p><strong>算法</strong></p><p>我们可以用一个额外的数组来将每个元素放到正确的位置上，也就是原本数组里下标为 <em>i</em> 的我们把它放到 <img src="./p___i+k_%%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6_.png" alt="(i+k)\%数组长度 ">  的位置。然后把新的数组拷贝到原数组中。</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            a[(i + k) % nums.length] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度： <em>O(n)</em> 。将数字放到新的数组中需要一遍遍历，另一边来把新数组的元素拷贝回原数组。</li><li>空间复杂度： <em>O(n)</em>。另一个数组需要原数组长度的空间。</li></ul><h2 id="方法-3：使用环状替换"><a href="#方法-3：使用环状替换" class="headerlink" title="方法 3：使用环状替换"></a>方法 3：使用环状替换</h2><p><strong>算法</strong></p><p>如果我们直接把每一个数字放到它最后的位置，但这样的后果是遗失原来的元素。因此，我们需要把被替换的数字保存在变量 <em>temp</em> 里面。然后，我们将被替换数字（<em>temp*）放到它正确的位置，并继续这个过程 *n</em> 次， <em>n</em> 是数组的长度。这是因为我们需要将数组里所有的元素都移动。但是，这种方法可能会有个问题，如果 <img src="./p__n%k==0_.png" alt="n\%k==0 "> ，其中 <img src="./p__k=k%n_.png" alt="k=k\%n ">  （因为如果 <em>k</em> 大于 <em>n</em> ，移动 <em>k</em> 次实际上相当于移动 <img src="./p__k%n_.png" alt="k\%n ">  次）。这种情况下，我们会发现在没有遍历所有数字的情况下回到出发数字。此时，我们应该从下一个数字开始再重复相同的过程。</p><p>现在，我们看看上面方法的证明。假设，数组里我们有 <em>n</em> 个元素并且 <em>k</em> 是要求移动的次数。更进一步，假设 <img src="./p__n%k=0_.png" alt="n\%k=0 ">  。第一轮中，所有移动数字的下标 <em>i</em> 满足 <img src="./p__i%k==0_.png" alt="i\%k==0 ">  。这是因为我们每跳 <em>k</em> 步，我们只会到达相距为 <em>k</em> 个位置下标的数。每一轮，我们都会移动 <img src="./p__frac%7Bn%7D%7Bk%7D_.png" alt="\frac{n}{k} ">  个元素。下一轮中，我们会移动满足 <img src="./p__i%k==1_.png" alt="i\%k==1 ">  的位置的数。这样的轮次会一直持续到我们再次遇到 <img src="./p__i%k==0_.png" alt="i\%k==0 ">  的地方为止，此时 <em>i=k</em> 。此时在正确位置上的数字共有 <img src="./p__k_times_frac%7Bn%7D%7Bk%7D=n_.png" alt="k\times\frac{n}{k}=n ">  个。因此所有数字都在正确位置上。</p><p>让我们看一下接下来的例子，以更好地说明这个过程：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums: [1, 2, 3, 4, 5, 6]</span><br><span class="line">k: 2</span><br></pre></td></tr></table></figure></p><p> <a href="https://pic.leetcode-cn.com/f0493a97cdb7bc46b37306ca14e555451496f9f9c21effcad8517a81a26f30d6-image.png" target="_blank" rel="noopener">例子</a></p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k = k % nums.length;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; count &lt; nums.length; start++) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = start;</span><br><span class="line">            <span class="keyword">int</span> prev = nums[start];</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> next = (current + k) % nums.length;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[next];</span><br><span class="line">                nums[next] = prev;</span><br><span class="line">                prev = temp;</span><br><span class="line">                current = next;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">while</span> (start != current);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(n)</em> 。只遍历了每个元素一次。</li><li>空间复杂度：<em>O(1)</em> 。使用了常数个额外空间。</li></ul><h2 id="方法-4：使用反转"><a href="#方法-4：使用反转" class="headerlink" title="方法 4：使用反转"></a>方法 4：使用反转</h2><p><strong>算法</strong></p><p>这个方法基于这个事实：当我们旋转数组 k 次， <img src="./p__k%n_.png" alt="k\%n ">  个尾部元素会被移动到头部，剩下的元素会被向后移动。</p><p>在这个方法中，我们首先将所有元素反转。然后反转前 k 个元素，再反转后面 <em>n-k</em> 个元素，就能得到想要的结果。</p><p>我用这种方法来解决时遇到数组越界错误，是因为没有把k取模，因为有些情况下k可能大于数组长度。这个易错点需要注意。</p><p>假设 <em>n=7</em> 且 <em>k=3</em> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原始数组                  : 1 2 3 4 5 6 7</span><br><span class="line">反转所有数字后             : 7 6 5 4 3 2 1</span><br><span class="line">反转前 k 个数字后          : 5 6 7 4 3 2 1</span><br><span class="line">反转后 n-k 个数字后        : 5 6 7 1 2 3 4 --&gt; 结果</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k %= nums.length;</span><br><span class="line">        reverse(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, k, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[start];</span><br><span class="line">            nums[start] = nums[end];</span><br><span class="line">            nums[end] = temp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(n)</em> 。 <em>n</em> 个元素被反转了总共 3 次。</li><li>空间复杂度：<em>O(1)</em> 。 没有使用额外的空间。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>63. 不同路径II</title>
    <link href="http://yoursite.com/2020/06/28/63.%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II/"/>
    <id>http://yoursite.com/2020/06/28/63. 不同路径II/</id>
    <published>2020-06-28T12:50:12.000Z</published>
    <updated>2020-06-29T06:22:31.214Z</updated>
    
    <content type="html"><![CDATA[<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><a id="more"></a><p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p><p>说明：m 和 n 的值均不超过 100。</p><p>示例1:</p><pre><code>输入:[  [0,0,0],  [0,1,0],  [0,0,0]]输出: 2解释:3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</code></pre><h2 id="方法-1：动态规划-1"><a href="#方法-1：动态规划-1" class="headerlink" title="方法 1：动态规划^1"></a>方法 1：动态规划<a href="https://leetcode-cn.com/problems/unique-paths-ii/solution/bu-tong-lu-jing-ii-by-leetcode/" target="_blank" rel="noopener">^1</a></h2><p><strong>直觉</strong></p><p>机器人只可以向下和向右移动，因此第一行的格子只能从左边的格子移动到，第一列的格子只能从上方的格子移动到。</p><p>如果格子上有障碍，那么我们不考虑包含这个格子的任何路径。我们从左至右、从上至下的遍历整个数组，那么在到达某个顶点之前我们就已经获得了到达前驱节点的方案数，这就变成了一个<code>动态规划</code>问题。我们只需要一个 <code>obstacleGrid</code> 数组作为 DP 数组。</p><p><code>注意：</code> 根据题目描述，包含障碍物的格点有权值 <code>1</code>，我们依此来判断是否包含在路径中，然后我们可以用这个空间来存储到达这个格点的方案数。</p><p><strong>算法</strong></p><ol><li>如果第一个格点 <code>obstacleGrid[0,0]</code> 是 <code>1</code>，说明有障碍物，那么机器人不能做任何移动，我们返回结果 <code>0</code>。</li><li>否则，如果 <code>obstacleGrid[0,0]</code> 是 <code>0</code>，我们初始化这个值为 <code>1</code> 然后继续算法。</li><li>遍历第一行，如果有一个格点初始值为 <code>1</code> ，说明当前节点有障碍物，没有路径可以通过，设值为 <code>0</code> ；否则设这个值是前一个节点的值 <code>obstacleGrid[i,j] = obstacleGrid[i,j-1]</code>。</li><li>遍历第一列，如果有一个格点初始值为 <code>1</code> ，说明当前节点有障碍物，没有路径可以通过，设值为 <code>0</code> ；否则设这个值是前一个节点的值 <code>obstacleGrid[i,j] = obstacleGrid[i-1,j]</code>。</li><li>现在，从 <code>obstacleGrid[1,1]</code> 开始遍历整个数组，如果某个格点初始不包含任何障碍物，就把值赋为上方和左侧两个格点方案数之和 <code>obstacleGrid[i,j] = obstacleGrid[i-1,j] + obstacleGrid[i,j-1]</code>。</li><li>如果这个点有障碍物，设值为 <code>0</code> ，这可以保证不会对后面的路径产生贡献。</li></ol><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> R = obstacleGrid.length;</span><br><span class="line">        <span class="keyword">int</span> C = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the starting cell has an obstacle, then simply return as there would be</span></span><br><span class="line">        <span class="comment">// no paths to the destination.</span></span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Number of ways of reaching the starting cell = 1.</span></span><br><span class="line">        obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Filling the values for the first column</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; R; i++) &#123;</span><br><span class="line">            obstacleGrid[i][<span class="number">0</span>] = (obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; obstacleGrid[i - <span class="number">1</span>][<span class="number">0</span>] == <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Filling the values for the first row</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; C; i++) &#123;</span><br><span class="line">            obstacleGrid[<span class="number">0</span>][i] = (obstacleGrid[<span class="number">0</span>][i] == <span class="number">0</span> &amp;&amp; obstacleGrid[<span class="number">0</span>][i - <span class="number">1</span>] == <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Starting from cell(1,1) fill up the values</span></span><br><span class="line">        <span class="comment">// No. of ways of reaching cell[i][j] = cell[i - 1][j] + cell[i][j - 1]</span></span><br><span class="line">        <span class="comment">// i.e. From above and left.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; R; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; C; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    obstacleGrid[i][j] = obstacleGrid[i - <span class="number">1</span>][j] + obstacleGrid[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    obstacleGrid[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return value stored in rightmost bottommost cell. That is the destination.</span></span><br><span class="line">        <span class="keyword">return</span> obstacleGrid[R - <span class="number">1</span>][C - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 ： O(M\timesN)   。长方形网格的大小是 M\timesN ，而访问每个格点恰好一次。</li><li>空间复杂度 ： <em>O(1)</em>。我们利用 <code>obstacleGrid</code> 作为 DP 数组，因此不需要额外的空间。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>980. 不同路径 III</title>
    <link href="http://yoursite.com/2020/06/28/980.%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%20III/"/>
    <id>http://yoursite.com/2020/06/28/980. 不同路径 III/</id>
    <published>2020-06-28T12:50:12.000Z</published>
    <updated>2020-06-29T06:25:10.160Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在二维网格 grid 上，有 4 种类型的方格：</p><pre><code>1 表示起始方格。且只有一个起始方格。2 表示结束方格，且只有一个结束方格。0 表示我们可以走过的空方格。-1 表示我们无法跨越的障碍。</code></pre><p>返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目，每一个无障碍方格都要通过一次。</p><p>示例 1：</p><pre><code>输入：[[1,0,0,0],[0,0,0,0],[0,0,2,-1]]输出：2解释：我们有以下两条路径：1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)</code></pre><p>示例 2：</p><pre><code>输入：[[1,0,0,0],[0,0,0,0],[0,0,0,2]]输出：4解释：我们有以下四条路径： 1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)</code></pre><p>示例 3：</p><pre><code>输入：[[0,1],[2,0]]输出：0解释：没有一条路能完全穿过每一个空的方格一次。请注意，起始和结束方格可以位于网格中的任意位置。</code></pre><p>提示：</p><p>1 &lt;= grid.length * grid[0].length &lt;= 20</p><h4 id="方法一：回溯深度优先搜索"><a href="#方法一：回溯深度优先搜索" class="headerlink" title="方法一：回溯深度优先搜索"></a>方法一：回溯深度优先搜索</h4><p><strong>思路与算法</strong><a href="https://leetcode-cn.com/problems/unique-paths-iii/solution/bu-tong-lu-jing-iii-by-leetcode/" target="_blank" rel="noopener">^1</a></p><p>让我们尝试遍历每一个 <code>0</code> 方格，并在走过的方格里留下一个障碍。回溯的时候，我们要删除那些自己留下的障碍。</p><p>介于输入数据的限制，这个方法是可以通过的，因为一个不好的路径很快就会因没有无障碍的方格可以走而被卡住。 </p><figure class="highlight java"><figcaption><span>[2RULHstn-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="keyword">int</span>[][] grid;</span><br><span class="line">    <span class="keyword">int</span> targetR, targetC;</span><br><span class="line">    <span class="keyword">int</span> R, C;</span><br><span class="line">    <span class="keyword">int</span>[] dr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] dc = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsIII</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.grid = grid;</span><br><span class="line">        R = grid.length;</span><br><span class="line">        C = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> todo = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sourceR = <span class="number">0</span>, sourceC = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//获取无障碍方格数量和出发终止位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; c++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] != -<span class="number">1</span>) &#123;</span><br><span class="line">                    todo++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="number">1</span>) &#123;</span><br><span class="line">                    sourceR = r;</span><br><span class="line">                    sourceC = c;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[r][c] == <span class="number">2</span>) &#123;</span><br><span class="line">                    targetR = r;</span><br><span class="line">                    targetC = c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        dfs(sourceR, sourceC, todo);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> todo)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每一个无障碍方格都要通过一次</span></span><br><span class="line">        todo--;</span><br><span class="line">        <span class="keyword">if</span> (todo &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//到达终点</span></span><br><span class="line">        <span class="keyword">if</span> (r == targetR &amp;&amp; c == targetC) &#123;</span><br><span class="line">            <span class="keyword">if</span> (todo == <span class="number">0</span>) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在走过的方格里留下一个障碍</span></span><br><span class="line">        grid[r][c] = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">int</span> nr = r + dr[k];</span><br><span class="line">            <span class="keyword">int</span> nc = c + dc[k];</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> &lt;= nr &amp;&amp; nr &lt; R &amp;&amp; <span class="number">0</span> &lt;= nc &amp;&amp; nc &lt; C) &#123;</span><br><span class="line">                <span class="comment">//尝试遍历每一个 `0` 方格</span></span><br><span class="line">                <span class="keyword">if</span> (grid[nr][nc] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    dfs(nr, nc, todo);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//回溯的时候，我们要删除那些自己留下的障碍。</span></span><br><span class="line">        grid[r][c] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[2RULHstn-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsIII</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        R, C = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">nei</span>***<span class="title">ors</span><span class="params">(r, c)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> nr, nc <span class="keyword">in</span> ((r<span class="number">-1</span>, c), (r, c<span class="number">-1</span>), (r+<span class="number">1</span>, c), (r, c+<span class="number">1</span>)):</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= nr &lt; R <span class="keyword">and</span> <span class="number">0</span> &lt;= nc &lt; C <span class="keyword">and</span> grid[nr][nc] % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">yield</span> nr, nc</span><br><span class="line"></span><br><span class="line">        todo = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> r, row <span class="keyword">in</span> enumerate(grid):</span><br><span class="line">            <span class="keyword">for</span> c, val <span class="keyword">in</span> enumerate(row):</span><br><span class="line">                <span class="keyword">if</span> val != <span class="number">-1</span>: todo += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> val == <span class="number">1</span>: sr, sc = r, c</span><br><span class="line">                <span class="keyword">if</span> val == <span class="number">2</span>: tr, tc = r, c</span><br><span class="line"></span><br><span class="line">        self.ans = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(r, c, todo)</span>:</span></span><br><span class="line">            todo -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> todo &lt; <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> r == tr <span class="keyword">and</span> c == tc:</span><br><span class="line">                <span class="keyword">if</span> todo == <span class="number">0</span>:</span><br><span class="line">                    self.ans += <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            grid[r][c] = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">for</span> nr, nc <span class="keyword">in</span> nei***ors(r, c):</span><br><span class="line">                dfs(nr, nc, todo)</span><br><span class="line">            grid[r][c] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        dfs(sr, sc, todo)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(4^{R<em>C})</em>，其中 *R, C</em> 是这个二维网格行与列的大小。（我们可以找到一个更加精确的界限，但是这个界限已经超越了本文的范围）</p></li><li><p>空间复杂度：<em>O(R</em>C)*。</p></li></ul><hr><h4 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h4><p><strong>思路与算法</strong></p><p>让我们定义 <code>dp(r, c, todo)</code> 为从  <code>(r, c)</code> 开始行走，还没有遍历的无障碍方格集合为 <code>todo</code> 的好路径的数量。</p><p>我们可以使用一个与 <em>方法一</em> 类似的方法，并通过记忆化状态 <code>(r, c, todo)</code> 的答案来避免重复搜索。</p><figure class="highlight java"><figcaption><span>[pRtnUqNa-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="keyword">int</span>[][] grid;</span><br><span class="line">    <span class="keyword">int</span> R, C;</span><br><span class="line">    <span class="keyword">int</span> tr, tc, target;</span><br><span class="line">    <span class="keyword">int</span>[] dr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] dc = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    Integer[][][] memo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsIII</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.grid = grid;</span><br><span class="line">        R = grid.length;</span><br><span class="line">        C = grid[<span class="number">0</span>].length;</span><br><span class="line">        target = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sr = <span class="number">0</span>, sc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; ++r)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                    target |= code(r, c);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="number">1</span>) &#123;</span><br><span class="line">                    sr = r;</span><br><span class="line">                    sc = c;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[r][c] == <span class="number">2</span>) &#123;</span><br><span class="line">                    tr = r;</span><br><span class="line">                    tc = c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        memo = <span class="keyword">new</span> Integer[R][C][<span class="number">1</span> &lt;&lt; R*C];</span><br><span class="line">        <span class="keyword">return</span> dp(sr, sc, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">code</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; (r * C + c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">dp</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> todo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (memo[r][c][todo] != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> memo[r][c][todo];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r == tr &amp;&amp; c == tc) &#123;</span><br><span class="line">            <span class="keyword">return</span> todo == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">            <span class="keyword">int</span> nr = r + dr[k];</span><br><span class="line">            <span class="keyword">int</span> nc = c + dc[k];</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> &lt;= nr &amp;&amp; nr &lt; R &amp;&amp; <span class="number">0</span> &lt;= nc &amp;&amp; nc &lt; C) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((todo &amp; code(nr, nc)) != <span class="number">0</span>)</span><br><span class="line">                    ans += dp(nr, nc, todo ^ code(nr, nc));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memo[r][c][todo] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[pRtnUqNa-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsIII</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        R, C = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">code</span><span class="params">(r, c)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; (r * C + c)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">nei</span>***<span class="title">ors</span><span class="params">(r, c)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> nr, nc <span class="keyword">in</span> ((r<span class="number">-1</span>, c), (r, c<span class="number">-1</span>), (r+<span class="number">1</span>, c), (r, c+<span class="number">1</span>)):</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= nr &lt; R <span class="keyword">and</span> <span class="number">0</span> &lt;= nc &lt; C <span class="keyword">and</span> grid[nr][nc] % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">yield</span> nr, nc</span><br><span class="line"></span><br><span class="line">        target = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> r, row <span class="keyword">in</span> enumerate(grid):</span><br><span class="line">            <span class="keyword">for</span> c, val <span class="keyword">in</span> enumerate(row):</span><br><span class="line">                <span class="keyword">if</span> val % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    target |= code(r, c)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> val == <span class="number">1</span>:</span><br><span class="line">                    sr, sc = r, c</span><br><span class="line">                <span class="keyword">if</span> val == <span class="number">2</span>:</span><br><span class="line">                    tr, tc = r, c</span><br><span class="line"></span><br><span class="line"><span class="meta">        @lru_cache(None)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(r, c, todo)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> r == tr <span class="keyword">and</span> c == tc:</span><br><span class="line">                <span class="keyword">return</span> +(todo == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            ans = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> nr, nc <span class="keyword">in</span> nei***ors(r, c):</span><br><span class="line">                <span class="keyword">if</span> todo &amp; code(nr, nc):</span><br><span class="line">                    ans += dp(nr, nc, todo ^ code(nr, nc))</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp(sr, sc, target)</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(R * C * 2^{R<em>C})</em>，其中 *R, C</em> 是给定二维网格行与列的大小。</li><li>空间复杂度：<em>O(R * C * 2^{R</em>C})*。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;在二维网格 grid 上，有 4 种类型的方格：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1 表示
      
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>62. 不同路径</title>
    <link href="http://yoursite.com/2020/06/28/62.%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2020/06/28/62. 不同路径/</id>
    <published>2020-06-28T12:12:12.000Z</published>
    <updated>2020-06-28T14:32:49.381Z</updated>
    
    <content type="html"><![CDATA[<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。问总共有多少条不同的路径？</p><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p><p>示例 1:</p><pre><code>输入: m = 3, n = 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向右 -&gt; 向下2. 向右 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向右</code></pre><p>示例 2:</p><pre><code>输入: m = 7, n = 3输出: 28</code></pre><p>提示：</p><pre><code>1 &lt;= m, n &lt;= 100</code></pre><p>题目数据保证答案小于等于 2 * 10 ^ 9</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="思路一：排列组合"><a href="#思路一：排列组合" class="headerlink" title="思路一：排列组合"></a><strong>思路一：排列组合</strong></h2><p>因为机器到底右下角，向下几步，向右几步都是固定的，</p><p>比如，<code>m=3, n=2</code>，我们只要向下 1 步，向右 2 步就一定能到达终点。</p><p>所以有 <em>C_{m+n-2}^{m-1}</em></p><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> int(math.factorial(m+n<span class="number">-2</span>)/math.factorial(m<span class="number">-1</span>)/math.factorial(n<span class="number">-1</span>))</span><br></pre></td></tr></table></figure><h2 id="思路二：动态规划"><a href="#思路二：动态规划" class="headerlink" title="思路二：动态规划"></a><strong>思路二：动态规划</strong></h2><p>我们令 <code>dp[i][j]</code> 是到达 <code>i, j</code> 最多路径</p><p>动态方程：<code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code></p><p>注意，对于第一行 <code>dp[0][j]</code>，或者第一列 <code>dp[i][0]</code>，由于都是在边界，所以只能为 <code>1</code></p><p>时间复杂度：<em>O(m*n)</em></p><p>空间复杂度：<em>O(m * n)</em></p><h2 id="优化：因为我们每次只需要-dp-i-1-j-dp-i-j-1"><a href="#优化：因为我们每次只需要-dp-i-1-j-dp-i-j-1" class="headerlink" title="优化：因为我们每次只需要 dp[i-1][j],dp[i][j-1]"></a>优化：因为我们每次只需要 <code>dp[i-1][j],dp[i][j-1]</code></h2><p>所以我们只要记录这两个数，直接看代码吧！</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>思路二：</p><figure class="highlight java"><figcaption><span>[1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化1：空间复杂度 <em>O(2n)</em></p><figure class="highlight java"><figcaption><span>[2]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] pre = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] cur = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(pre, <span class="number">1</span>);</span><br><span class="line">        Arrays.fill(cur,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                cur[j] = cur[j-<span class="number">1</span>] + pre[j];</span><br><span class="line">            &#125;</span><br><span class="line">            pre = cur.clone();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre[n-<span class="number">1</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化2：空间复杂度 <em>O(n)</em></p><figure class="highlight java"><figcaption><span>[3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] cur = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(cur,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                cur[j] += cur[j-<span class="number">1</span>] ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。问总共有多少条不同的路径？&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>212. 单词搜索II</title>
    <link href="http://yoursite.com/2020/06/28/212.%20%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2II/"/>
    <id>http://yoursite.com/2020/06/28/212. 单词搜索II/</id>
    <published>2020-06-28T10:12:12.000Z</published>
    <updated>2020-06-28T12:02:17.704Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二维网格board和一个字典中的单词列表 words，找出所有同时在二维网格和字典中出现的单词。</p><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。</p><p>示例:</p><p>输入: </p><pre><code>words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;] and board =[  [&apos;o&apos;,&apos;a&apos;,&apos;a&apos;,&apos;n&apos;],  [&apos;e&apos;,&apos;t&apos;,&apos;a&apos;,&apos;e&apos;],  [&apos;i&apos;,&apos;h&apos;,&apos;k&apos;,&apos;r&apos;],  [&apos;i&apos;,&apos;f&apos;,&apos;l&apos;,&apos;v&apos;]]</code></pre><p>输出:</p><pre><code>[&quot;eat&quot;,&quot;oath&quot;]</code></pre><p>说明:</p><p>你可以假设所有输入都由小写字母 a-z 组成。</p><p>提示:</p><ul><li><p>你需要优化回溯算法以通过更大数据量的测试。你能否早点停止回溯？</p></li><li><p>如果当前单词不存在于所有单词的前缀中，则可以立即停止回溯。什么样的数据结构可以有效地执行这样的操作？散列表是否可行？为什么？ 前缀树如何？如果你想学习如何实现一个基本的前缀树，请先查看这个问题： 实现Trie（前缀树）。</p></li></ul><h4 id="方法一：使用前缀树的回溯"><a href="#方法一：使用前缀树的回溯" class="headerlink" title="方法一：使用前缀树的回溯"></a>方法一：使用前缀树的回溯</h4><p>这个问题实际上是一个简化的纵横填字游戏，在这个游戏中，单词的解已经被嵌入了一些无关字母。我们要做的就是把它们划掉。</p><p>直观地说，为了划掉所有潜在的单词，总体策略是一个接一个地迭代单元格，然后从每个单元格沿着它的四个潜在方向的走，找到匹配的单词。</p><p>当我们在黑板上徘徊时，若我们知道这不会发现新单词时，我们会停止探索。</p><p>有人可能已经猜到了我们用来解决这个问题的方法。是的，它是回溯，这将是解决方案的主干。构造一个回溯的解决方案是相当简单的。</p><p>解决这个问题的关键在于我们如何从字典中找到单词的匹配项。直观地说，可以使用 hashset 数据结构（例如Python 中的 <code>set()</code>）。</p><p>然而，在回溯过程中，人们会更经常地遇到这样的问题：是否存在任何包含特定前缀的单词，而不是是否有一个字符串作为单词存在于字典中。因为如果我们知道给定前缀的字典中不存在任何单词匹配，那么我们就不需要进一步探索某个方向。而这，将大大减少探测空间，从而提高回溯算法的性能。</p><p>能够查找前缀的数据结构叫 Trie，于 hashset 比较。Trie 不仅可以检查一个单词，还可以立即找到共享给定前缀的单词。事实证明，数据结构的选择（Trie 与 hashset）可能以排名前 5% 或后 5% 的解决方案结束。</p><p>这里我们展示了一个由单词列表构建的 Trie 示例。如下图所示，在所表示的节点处，我们将知道字典中至少有两个前缀为 <code>d</code> 的单词。</p><p> <a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl90cmllX2V4YW1wbGUucG5n?x-oss-process=image/format,png" target="_blank" rel="noopener">一个由单词列表构建的 Trie 示例</a></p><p>我们在实现 Trie 数据结构时遇到麻烦。我们可以从<a href="https://leetcode.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">Trie 问题</a>开始作为热身，然后再回来这个问题。</p><p><strong>算法：</strong></p><p>该算法的整个工作流程是直观的，包括在二维网格中的每个单元上循环和从单元开始的递归函数调用。这是算法的框架。</p><ul><li>我们根据字典中的单词构建一个 Trie，稍后将用于匹配过程。</li><li>从每个单元格开始，如果字典中存在以单元格中的字母开头的单词,则我们开始回溯探索（即 <code>backtracking(cell)</code>）。</li><li>在递归函数 <code>backtracking(cell)</code> 调用过程中，我们探索当前单元格周围的相邻单元格（即 <code>neighborCell</code>）以进行下一个递归调用 <code>backtracking(neighborCell)</code>。在每次调用时，我们都会检查到目前为止遍历的字母序列是否与字典中的任何单词匹配，这需要借助于我们在开始时构建的 Trie 数据结构。</li></ul><p>下面是算法的工作原理的。基于上述思想，我们给出了一些示例实现。之后，我们详细介绍了一些可以进一步应用于该算法的优化。</p><p> <a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl90cmllX2FsZ28ucG5n?x-oss-process=image/format,png" target="_blank" rel="noopener">算法的工作原理</a></p><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">  HashMap&lt;Character, TrieNode&gt; children = <span class="keyword">new</span> HashMap&lt;Character, TrieNode&gt;();</span><br><span class="line">  String word = <span class="keyword">null</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span>[][] _board = <span class="keyword">null</span>;</span><br><span class="line">  ArrayList&lt;String&gt; _result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findWords</span><span class="params">(<span class="keyword">char</span>[][] board, String[] words)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 1). Construct the Trie</span></span><br><span class="line">    TrieNode root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">      TrieNode node = root;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (Character letter : word.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.children.containsKey(letter)) &#123;</span><br><span class="line">          node = node.children.get(letter);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          TrieNode newNode = <span class="keyword">new</span> TrieNode();</span><br><span class="line">          node.children.put(letter, newNode);</span><br><span class="line">          node = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      node.word = word;  <span class="comment">// store words in Trie</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._board = board;</span><br><span class="line">    <span class="comment">// Step 2). Backtracking starting for each cell in the board</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; board.length; ++row) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; board[row].length; ++col) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.children.containsKey(board[row][col])) &#123;</span><br><span class="line">          backtracking(row, col, root);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._result;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, TrieNode parent)</span> </span>&#123;</span><br><span class="line">    Character letter = <span class="keyword">this</span>._board[row][col];</span><br><span class="line">    TrieNode currNode = parent.children.get(letter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check if there is any match</span></span><br><span class="line">    <span class="keyword">if</span> (currNode.word != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>._result.add(currNode.word);</span><br><span class="line">      currNode.word = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mark the current letter before the EXPLORATION</span></span><br><span class="line">    <span class="keyword">this</span>._board[row][col] = <span class="string">'#'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// explore neighbor cells in around-clock directions: up, right, down, left</span></span><br><span class="line">    <span class="keyword">int</span>[] rowOffset = &#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] colOffset = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">      <span class="keyword">int</span> newRow = row + rowOffset[i];</span><br><span class="line">      <span class="keyword">int</span> newCol = col + colOffset[i];</span><br><span class="line">      <span class="keyword">if</span> (newRow &lt; <span class="number">0</span> || newRow &gt;= <span class="keyword">this</span>._board.length || newCol &lt; <span class="number">0</span></span><br><span class="line">          || newCol &gt;= <span class="keyword">this</span>._board[<span class="number">0</span>].length) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (currNode.children.containsKey(<span class="keyword">this</span>._board[newRow][newCol])) &#123;</span><br><span class="line">        backtracking(newRow, newCol, currNode);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// End of EXPLORATION, restore the original letter in the board.</span></span><br><span class="line">    <span class="keyword">this</span>._board[row][col] = letter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optimization: incrementally remove the leaf nodes</span></span><br><span class="line">    <span class="keyword">if</span> (currNode.children.isEmpty()) &#123;</span><br><span class="line">      parent.children.remove(letter);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了更好地理解回溯过程，我们将在下面的动画中演示如何在 Trie 中找到 <code>dog</code>。</p><p>  [1](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV8xLnBuZw?x-oss-process=image/format" target="_blank" rel="noopener">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV8xLnBuZw?x-oss-process=image/format</a> png) </p><p>  [2](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV8yLnBuZw?x-oss-process=image/format" target="_blank" rel="noopener">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV8yLnBuZw?x-oss-process=image/format</a> png)  </p><p>  [3](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV8zLnBuZw?x-oss-process=image/format" target="_blank" rel="noopener">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV8zLnBuZw?x-oss-process=image/format</a> png)  </p><p>  [4](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV80LnBuZw?x-oss-process=image/format" target="_blank" rel="noopener">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV80LnBuZw?x-oss-process=image/format</a> png)  </p><p>  [5](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV81LnBuZw?x-oss-process=image/format" target="_blank" rel="noopener">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV81LnBuZw?x-oss-process=image/format</a> png)  </p><p>  [6](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV82LnBuZw?x-oss-process=image/format" target="_blank" rel="noopener">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV82LnBuZw?x-oss-process=image/format</a> png) </p><h2 id="优化："><a href="#优化：" class="headerlink" title="优化："></a><strong>优化</strong>：</h2><p>在上述实现中，除了应用 Trie 数据结构外，我们还应用了一些技巧来进一步加快运行时间。特别是，Python 实现的运行速度可以超过 98% 的提交。我们按其重要性将这些技巧详述如下。</p><ul><li>沿着 Trie 的节点回溯。</li></ul><p>人们可以简单地使用 Trie 作为字典来快速找到单词和前缀的匹配，即在回溯的每一步，我们都从Trie 的根开始。</p><p>然而，更有效的方法是将 Trie 与回溯过程一起遍历，即每一步 <code>backtracking(TrieNode)</code>，<code>TrieNode</code> 的深度对应于我们到目前为止匹配的前缀的长度。这项措施可以将您的解决方案从提交的最低 <em>5%</em> 中脱颖出来。</p><ul><li>在回溯过程中逐渐剪除 Trie 中的节点（剪枝）。</li></ul><p>这个想法的动机是整个算法的时间复杂度取决于 Trie 的大小。对于 Trie 中的叶节点，一旦遍历它（即找到匹配的单词），就不需要再遍历它了。结果，我们可以把它从树上剪下来。</p><p>逐渐地，这些非叶节点可以成为叶节点以后，因为我们修剪他们的孩子叶节点。在极端情况下，一旦我们找到字典中所有单词的匹配项，Trie 就会变成空的。这个剪枝措施可以减少在线测试用例 50% 的运行时间。</p><p> <a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl90cmllX3BydW5lLnBuZw?x-oss-process=image/format,png" target="_blank" rel="noopener">剪枝</a></p><ul><li>从 Trie 中删除匹配的单词。</li></ul><p>在这个问题中，我们被要求返回所有匹配的单词，而不是潜在匹配的数量。因此，一旦到达包含单词匹配的特定 Trie 节点，我们就可以从 Trie 中删除匹配单词。</p><p>作为附带好处，我们不需要检查结果集中是否有任何重复项。因此，我们可以简单地使用一个列表而不是集合来保存结果，这样可以加快解决方案的速度。</p><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>\mathcal{O}(M(4\cdot3^{L-1}))<em>，其中</em>M</em> 是二维网格中的单元格数，<em>L</em> 是单词的最大长度。</p><ul><li>计算回溯算法将执行的确切步数是一个棘手的问题。我们为这个问题的最坏情况提供了该步骤的上限。该算法循环遍历二维网格中的所有单元，因此在复杂度公式中我们有 <em>M</em> 作为因子。然后将其归结为每个启动单元所需的最大步骤数（即 <em>4\cdot3^{L-1}</em>）。</li><li>假设单词的最大长度是 <em>L</em>，从一个单元格开始，最初我们最多可以探索 4 个方向。假设每个方向都是有效的（即最坏情况），在接下来的探索中，我们最多有 3 个相邻的单元（不包括我们来的单元）要探索。因此，在回溯探索期间，我们最多遍历 <em>4\cdot3^{L-1}</em> 个单元格。</li><li>你可能会想最坏的情况是什么样子。这里有一个例子。想象一下，二维网格中的每个单元都包含字母 <code>a</code>，单词词典包含一个单词 <code>[&#39;aaaa&#39;]</code>。这是算法将遇到的最坏的情况之一。</li></ul><p><a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9jb21wbGV4aXR5X2V4YW1wbGUucG5n?x-oss-process=image/format,png" target="_blank" rel="noopener">最坏的情况</a></p></li></ul><p>注意，上述时间复杂性是在 Trie 数据结构一旦构建就不会改变的假设下估计的。如果采用优化策略逐步删除 Trie 中的节点，则可以大大提高时间复杂度，因为一旦匹配词典中的所有单词，即 Trie 变为空，回溯的成本就会降低到零。 </p><ul><li>空间复杂度：<em>\mathcal{O}(N)*，其中 *N</em> 是字典中的字母总数。<ul><li>算法消耗的主要空间是我们构建的 Trie 数据结构。在最坏的情况下，如果单词之间没有前缀重叠，则 Trie 将拥有与所有单词的字母一样多的节点。也可以选择在 Trie 中保留单词的副本。因此，我们可能需要 *2N$ 的空间用于 Trie。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个二维网格board和一个字典中的单词列表 words，找出所有同时在二维网格和字典中出现的单词。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Trie" scheme="http://yoursite.com/tags/Trie/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Java编程思想-第二十三章 注解阅读笔记</title>
    <link href="http://yoursite.com/2020/06/28/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%89%E7%AB%A0%20%E6%B3%A8%E8%A7%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/06/28/Java编程思想-第二十三章 注解阅读笔记/</id>
    <published>2020-06-28T02:59:12.000Z</published>
    <updated>2020-06-29T06:23:06.841Z</updated>
    
    <content type="html"><![CDATA[<p>接口和抽象类提供了一种将接口与实现分离的更加结构化的方法。</p><a id="more"></a><p>[TOC]</p><!-- Annotations --><h1 id="第二十三章-注解"><a href="#第二十三章-注解" class="headerlink" title="第二十三章 注解"></a>第二十三章 注解</h1><p>注解（也被称为元数据）为我们在代码中添加信息提供了一种形式化的方式，使我们可以在稍后的某个时刻更容易的使用这些数据。</p><p>注解在一定程度上是把元数据和源代码文件结合在一起的趋势所激发的，而不是保存在外部文档。这同样是对像 C# 语言对于 Java 语言特性压力的一种回应。</p><p>注解是 Java 5 所引入的众多语言变化之一。它们提供了 Java 无法表达的但是你需要完整表述程序所需的信息。因此，注解使得我们可以以编译器验证的格式存储程序的额外信息。注解可以生成描述符文件，甚至是新的类定义，并且有助于减轻编写“样板”代码的负担。通过使用注解，你可以将元数据保存在 Java 源代码中。并拥有如下优势：简单易读的代码，编译器类型检查，使用 annotation API 为自己的注解构造处理工具。即使 Java 定义了一些类型的元数据，但是一般来说注解类型的添加和如何使用完全取决于你。</p><p>注解的语法十分简单，主要是在现有语法中添加 @ 符号。Java 5 引入了前三种定义在 <strong>java.lang</strong> 包中的注解：</p><ul><li><strong>@Override</strong>：表示当前的方法定义将覆盖基类的方法。如果你不小心拼写错误，或者方法签名被错误拼写的时候，编译器就会发出错误提示。</li><li><strong>@Deprecated</strong>：如果使用该注解的元素被调用，编译器就会发出警告信息。</li><li><strong>@SuppressWarnings</strong>：关闭不当的编译器警告信息。</li><li><strong>@SafeVarargs</strong>：在 Java 7 中加入用于禁止对具有泛型varargs参数的方法或构造函数的调用方发出警告。</li><li><strong>@FunctionalInterface</strong>：Java 8 中加入用于表示类型声明为函数式接口</li></ul><p>还有 5 种额外的注解类型用于创造新的注解。你将会在这一章学习它们。</p><p>每当创建涉及重复工作的类或接口时，你通常可以使用注解来自动化和简化流程。例如在 Enterprise JavaBean（EJB）中的许多额外工作就是通过注解来消除的。</p><p>注解的出现可以替代一些现有的系统，例如 XDoclet，它是一种独立的文档化工具，专门设计用来生成注解风格的文档。与之相比，注解是真正语言层级的概念，以前构造出来就享有编译器的类型检查保护。注解在源代码级别保存所有信息而不是通过注释文字，这使得代码更加整洁和便于维护。通过使用拓展的 annotation API 或稍后在本章节可以看到的外部的字节码工具类库，你会拥有对源代码及字节码强大的检查与操作能力。</p><!-- Basic Syntax --><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><!-- Writing Annotation Processors --><p>在下面的例子中，使用 <code>@Test</code> 对 <code>testExecute()</code> 进行注解。该注解本身不做任何事情，但是编译器要保证其类路径上有 <code>@Test</code> 注解的定义。你将在本章看到，我们通过注解创建了一个工具用于运行这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/Testable.java</span></span><br><span class="line"><span class="keyword">package</span> annotations;</span><br><span class="line"><span class="keyword">import</span> onjava.atunit.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Testable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Executing.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testExecute</span><span class="params">()</span> </span>&#123; execute(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被注解标注的方法和其他的方法没有任何区别。在这个例子中，注解 <code>@Test</code> 可以和任何修饰符共同用于方法，诸如 <strong>public</strong>、<strong>static</strong> 或 <strong>void</strong>。从语法的角度上看，注解的使用方式和修饰符的使用方式一致。</p><h3 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h3><p>如下是一个注解的定义。注解的定义看起来很像接口的定义。事实上，它们和其他 Java 接口一样，也会被编译成 class 文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/atunit/Test.java</span></span><br><span class="line"><span class="comment">// The @Test tag</span></span><br><span class="line"><span class="keyword">package</span> onjava.atunit;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test &#123;&#125;</span><br></pre></td></tr></table></figure><p>除了 @ 符号之外， <code>@Test</code> 的定义看起来更像一个空接口。注解的定义也需要一些元注解（meta-annoation），比如 <code>@Target</code> 和 <code>@Retention</code>。<code>@Target</code> 定义你的注解可以应用在哪里（例如是方法还是字段）。<code>@Retention</code> 定义了注解在哪里可用，在源代码中（SOURCE），class文件（CLASS）中或者是在运行时（RUNTIME）。</p><p>注解通常会包含一些表示特定值的元素。当分析处理注解的时候，程序或工具可以利用这些值。注解的元素看起来就像接口的方法，但是可以为其指定默认值。</p><p>不包含任何元素的注解称为标记注解（marker annotation），例如上例中的 <code>@Test</code> 就是标记注解。</p><p>下面是一个简单的注解，我们可以用它来追踪项目中的用例。程序员可以使用该注解来标注满足特定用例的一个方法或者一组方法。于是，项目经理可以通过统计已经实现的用例来掌控项目的进展，而开发者在维护项目时可以轻松的找到用例用于更新，或者他们可以调试系统中业务逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/UseCase.java</span></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> UseCase &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">description</span><span class="params">()</span> <span class="keyword">default</span> "no description"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 <strong>id</strong> 和 <strong>description</strong> 与方法定义类似。由于编译器会对 <strong>id</strong> 进行类型检查，因此将跟踪数据库与用例文档和源代码相关联是可靠的方式。<strong>description</strong> 元素拥有一个 <strong>default</strong> 值，如果在注解某个方法时没有给出 <strong>description</strong> 的值。则该注解的处理器会使用此元素的默认值。</p><p>在下面的类中，有三个方法被注解为用例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/PasswordUtils.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PasswordUtils</span> </span>&#123;</span><br><span class="line">    <span class="meta">@UseCase</span>(id = <span class="number">47</span>, description =</span><br><span class="line">            <span class="string">"Passwords must contain at least one numeric"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validatePassword</span><span class="params">(String passwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (passwd.matches(<span class="string">"\\w*\\d\\w*"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@UseCase</span>(id = <span class="number">48</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">encryptPassword</span><span class="params">(String passwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(passwd)</span><br><span class="line">                .reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@UseCase</span>(id = <span class="number">49</span>, description =</span><br><span class="line">            <span class="string">"New passwords can't equal previously used ones"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkForNewPassword</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            List&lt;String&gt; prevPasswords, String passwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !prevPasswords.contains(passwd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解的元素在使用时表现为 名-值 对的形式，并且需要放置在 <code>@UseCase</code> 声明之后的括号内。在 <code>encryptPassword()</code> 方法的注解中，并没有给出 <strong>description</strong> 的值，所以在 <strong>@interface UseCase</strong> 的注解处理器分析处理这个类的时候会使用该元素的默认值。</p><p>你应该能够想象到如何使用这套工具来“勾勒”出将要建造的系统，然后在建造的过程中逐渐实现系统的各项功能。</p><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>Java 语言中目前有 5 种标准注解（前面介绍过），以及 5 种元注解。元注解用于注解其他的注解</p><table><thead><tr><th>注解</th><th>解释</th></tr></thead><tbody><tr><td>@Target</td><td>表示注解可以用于哪些地方。可能的 <strong>ElementType</strong> 参数包括：<br><strong>CONSTRUCTOR</strong>：构造器的声明<br><strong>FIELD</strong>：字段声明（包括 enum 实例）<br><strong>LOCAL_VARIABLE</strong>：局部变量声明<br><strong>METHOD</strong>：方法声明<br><strong>PACKAGE</strong>：包声明<br><strong>PARAMETER</strong>：参数声明<br><strong>TYPE</strong>：类、接口（包括注解类型）或者 enum 声明</td></tr><tr><td>@Retention</td><td>表示注解信息保存的时长。可选的 <strong>RetentionPolicy</strong> 参数包括：<br><strong>SOURCE</strong>：注解将被编译器丢弃<br><strong>CLASS</strong>：注解在 class 文件中可用，但是会被 VM 丢弃。<br><strong>RUNTIME</strong>：VM 将在运行期也保留注解，因此可以通过反射机制读取注解的信息。</td></tr><tr><td>@Documented</td><td>将此注解保存在 Javadoc 中</td></tr><tr><td>@Inherited</td><td>允许子类继承父类的注解</td></tr><tr><td>@Repeatable</td><td>允许一个注解可以被使用一次或者多次（Java 8）。</td></tr></tbody></table><p>大多数时候，程序员定义自己的注解，并编写自己的处理器来处理他们。</p><h2 id="编写注解处理器"><a href="#编写注解处理器" class="headerlink" title="编写注解处理器"></a>编写注解处理器</h2><p>如果没有用于读取注解的工具，那么注解不会比注释更有用。使用注解中一个很重要的部分就是，创建与使用注解处理器。Java 拓展了反射机制的 API 用于帮助你创造这类工具。同时他还提供了 javac 编译器钩子在编译时使用注解。</p><p>下面是一个非常简单的注解处理器，我们用它来读取被注解的 <strong>PasswordUtils</strong> 类，并且使用反射机制来寻找 <strong>@UseCase</strong> 标记。给定一组 <strong>id</strong> 值，然后列出在 <strong>PasswordUtils</strong> 中找到的用例，以及缺失的用例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/UseCaseTracker.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseCaseTracker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">    trackUseCases(List&lt;Integer&gt; useCases, Class&lt;?&gt; cl) &#123;</span><br><span class="line">        <span class="keyword">for</span>(Method m : cl.getDeclaredMethods()) &#123;</span><br><span class="line">            UseCase uc = m.getAnnotation(UseCase.class);</span><br><span class="line">            <span class="keyword">if</span>(uc != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Found Use Case "</span> +</span><br><span class="line">                        uc.id() + <span class="string">"\n "</span> + uc.description());</span><br><span class="line">                useCases.remove(Integer.valueOf(uc.id()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        useCases.forEach(i -&gt;</span><br><span class="line">                System.out.println(<span class="string">"Missing use case "</span> + i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; useCases = IntStream.range(<span class="number">47</span>, <span class="number">51</span>)</span><br><span class="line">                .boxed().collect(Collectors.toList());</span><br><span class="line">        trackUseCases(useCases, PasswordUtils.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Found Use Case <span class="number">48</span></span><br><span class="line">no description</span><br><span class="line">Found Use Case <span class="number">47</span></span><br><span class="line">Passwords must contain at least one numeric</span><br><span class="line">Found Use Case <span class="number">49</span></span><br><span class="line">New passwords can<span class="string">'t equal previously used ones</span></span><br><span class="line"><span class="string">Missing use case 50</span></span><br></pre></td></tr></table></figure><p>这个程序用了两个反射的方法：<code>getDeclaredMethods()</code>  和 <code>getAnnotation()</code>，它们都属于 <strong>AnnotatedElement</strong> 接口（<strong>Class</strong>，<strong>Method</strong> 与 <strong>Field</strong> 类都实现了该接口）。<code>getAnnotation()</code> 方法返回指定类型的注解对象，在本例中就是 “<strong>UseCase</strong>”。如果被注解的方法上没有该类型的注解，返回值就为 <strong>null</strong>。我们通过调用 <code>id()</code> 和 <code>description()</code> 方法来提取元素值。注意 <code>encryptPassword()</code> 方法在注解的时候没有指定 <strong>description</strong> 的值，因此处理器在处理它对应的注解时，通过 <code>description()</code> 取得的是默认值 “no description”。</p><h3 id="注解元素"><a href="#注解元素" class="headerlink" title="注解元素"></a>注解元素</h3><p>在 <strong>UseCase.java</strong> 中定义的 <strong>@UseCase</strong> 的标签包含 int 元素 <strong>id</strong> 和 String 元素 <strong>description</strong>。注解元素可用的类型如下所示：</p><ul><li>所有基本类型（int、float、boolean等）</li><li>String</li><li>Class</li><li>enum</li><li>Annotation</li><li>以上类型的数组</li></ul><p>如果你使用了其他类型，编译器就会报错。注意，也不允许使用任何包装类型，但是由于自动装箱的存在，这不算是什么限制。注解也可以作为元素的类型。稍后你会看到，注解嵌套是一个非常有用的技巧。</p><h3 id="默认值限制"><a href="#默认值限制" class="headerlink" title="默认值限制"></a>默认值限制</h3><p>编译器对于元素的默认值有些过于挑剔。首先，元素不能有不确定的值。也就是说，元素要么有默认值，要么就在使用注解时提供元素的值。</p><p>这里有另外一个限制：任何非基本类型的元素， 无论是在源代码声明时还是在注解接口中定义默认值时，都不能使用 null 作为其值。这个限制使得处理器很难表现一个元素的存在或者缺失的状态，因为在每个注解的声明中，所有的元素都存在，并且具有相应的值。为了绕开这个约束，可以自定义一些特殊的值，比如空字符串或者负数用于表达某个元素不存在。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/SimulatingNull.java</span></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SimulatingNull &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line">    <span class="function">String <span class="title">description</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个在定义注解的习惯用法。</p><h3 id="生成外部文件"><a href="#生成外部文件" class="headerlink" title="生成外部文件"></a>生成外部文件</h3><p>当有些框架需要一些额外的信息才能与你的源代码协同工作，这种情况下注解就会变得十分有用。像 Enterprise JavaBeans (EJB3 之前)这样的技术，每一个 Bean 都需要需要大量的接口和部署描述文件，而这些就是“样板”文件。Web Service，自定义标签库以及对象/关系映射工具（例如 Toplink 和 Hibernate）通常都需要 XML 描述文件，而这些文件脱离于代码之外。除了定义 Java 类，程序员还必须忍受沉闷，重复的提供某些信息，例如类名和包名等已经在原始类中已经提供的信息。每当你使用外部描述文件时，他就拥有了一个类的两个独立信息源，这经常导致代码的同步问题。同时这也要求了为项目工作的程序员在知道如何编写 Java 程序的同时，也必须知道如何编辑描述文件。</p><p>假设你想提供一些基本的对象/关系映射功能，能够自动生成数据库表。你可以使用 XML 描述文件来指明类的名字、每个成员以及数据库映射的相关信息。但是，通过使用注解，你可以把所有信息都保存在 <strong>JavaBean</strong> 源文件中。为此你需要一些用于定义数据库表名称、数据库列以及将 SQL 类型映射到属性的注解。</p><p>以下是一个注解的定义，它告诉注解处理器应该创建一个数据库表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/database/DBTable.java</span></span><br><span class="line"><span class="keyword">package</span> annotations.database;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE) <span class="comment">// Applies to classes only</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DBTable &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>@Target</code> 注解中指定的每一个 <strong>ElementType</strong> 就是一个约束，它告诉编译器，这个自定义的注解只能用于指定的类型。你可以指定 <strong>enum ElementType</strong> 中的一个值，或者以逗号分割的形式指定多个值。如果想要将注解应用于所有的 <strong>ElementType</strong>，那么可以省去 <code>@Target</code> 注解，但是这并不常见。</p><p>注意 <strong>@DBTable</strong> 中有一个 <code>name()</code> 元素，该注解通过这个元素为处理器创建数据库时提供表的名字。</p><p>如下是修饰字段的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/database/Constraints.java</span></span><br><span class="line"><span class="keyword">package</span> annotations.database;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Constraints &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">primaryKey</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">allowNull</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">unique</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/database/SQLString.java</span></span><br><span class="line"><span class="keyword">package</span> annotations.database;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SQLString &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">Constraints <span class="title">constraints</span><span class="params">()</span> <span class="keyword">default</span> @Constraints</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/database/SQLInteger.java</span></span><br><span class="line"><span class="keyword">package</span> annotations.database;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SQLInteger &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">Constraints <span class="title">constraints</span><span class="params">()</span> <span class="keyword">default</span> @Constraints</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@Constraints</strong> 注解允许处理器提供数据库表的元数据。<strong>@Constraints</strong> 代表了数据库通常提供的约束的一小部分，但是它所要表达的思想已经很清楚了。<code>primaryKey()</code>，<code>allowNull()</code> 和 <code>unique()</code> 元素明显的提供了默认值，从而使得在大多数情况下，该注解的使用者不需要输入太多东西。</p><p>另外两个 <strong>@interface</strong> 定义的是 SQL 类型。如果希望这个框架更有价值的话，我们应该为每个 SQL 类型都定义相应的注解。不过为为示例，两个元素足够了。</p><p>这些 SQL 类型具有 <code>name()</code> 元素和 <code>constraints()</code> 元素。后者利用了嵌套注解的功能，将数据库列的类型约束信息嵌入其中。注意 <code>constraints()</code> 元素的默认值是 <strong>@Constraints</strong>。由于在 <strong>@Constraints</strong> 注解类型之后，没有在括号中指明 <strong>@Constraints</strong> 元素的值，因此，<strong>constraints()</strong> 的默认值为所有元素都为默认值的 <strong>@Constraints</strong> 注解。如果要使得嵌入的  <strong>@Constraints</strong>  注解中的 <code>unique()</code> 元素为 true，并作为 <code>constraints()</code> 元素的默认值，你可以像如下定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/database/Uniqueness.java</span></span><br><span class="line"><span class="comment">// Sample of nested annotations</span></span><br><span class="line"><span class="keyword">package</span> annotations.database;</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Uniqueness &#123;</span><br><span class="line">    <span class="function">Constraints <span class="title">constraints</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="keyword">default</span> @<span class="title">Constraints</span><span class="params">(unique = <span class="keyword">true</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个简单的，使用了如上注解的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/database/Member.java</span></span><br><span class="line"><span class="keyword">package</span> annotations.database;</span><br><span class="line"><span class="meta">@DBTable</span>(name = <span class="string">"MEMBER"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SQLString</span>(<span class="number">30</span>) String firstName;</span><br><span class="line">    <span class="meta">@SQLString</span>(<span class="number">50</span>) String lastName;</span><br><span class="line">    <span class="meta">@SQLInteger</span> Integer age;</span><br><span class="line">    <span class="meta">@SQLString</span>(value = <span class="number">30</span>,</span><br><span class="line">            constraints = <span class="meta">@Constraints</span>(primaryKey = <span class="keyword">true</span>))</span><br><span class="line">    String reference;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> memberCount;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getReference</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> reference; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> firstName; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> lastName; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> reference; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类注解 <strong>@DBTable</strong> 注解给定了元素值 MEMBER，它将会作为标的名字。类的属性 <strong>firstName</strong> 和 <strong>lastName</strong> 都被注解为 <strong>@SQLString</strong> 类型并且给了默认元素值分别为 30 和 50。这些注解都有两个有趣的地方：首先，他们都使用了嵌入的 <strong>@Constraints</strong> 注解的默认值；其次，它们都是用了快捷方式特性。如果你在注解中定义了名为 <strong>value</strong> 的元素，并且在使用该注解时，<strong>value</strong> 为唯一一个需要赋值的元素，你就不需要使用名—值对的语法，你只需要在括号中给出 <strong>value</strong> 元素的值即可。这可以应用于任何合法类型的元素。这也限制了你必须将元素命名为 <strong>value</strong>，不过在上面的例子中，这样的注解语句也更易于理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SQLString</span>(<span class="number">30</span>)</span><br></pre></td></tr></table></figure><p>处理器将在创建表的时候使用该值设置 SQL 列的大小。</p><p>默认值的语法虽然很灵巧，但是它很快就变的复杂起来。以 <strong>reference</strong> 字段的注解为例，上面拥有 <strong>@SQLString</strong> 注解，但是这个字段也将成为表的主键，因此在嵌入的 <strong>@Constraint</strong> 注解中设定 <strong>primaryKey</strong> 元素的值。这时事情就变的复杂了。你不得不为这个嵌入的注解使用很长的键—值对的形式，来指定元素名称和 <strong>@interface</strong> 的名称。同时，由于有特殊命名的 <strong>value</strong> 也不是唯一需要赋值的元素，因此不能再使用快捷方式特性。如你所见，最终结果不算清晰易懂。</p><h3 id="替代方案"><a href="#替代方案" class="headerlink" title="替代方案"></a>替代方案</h3><p>可以使用多种不同的方式来定义自己的注解用于上述任务。例如，你可以使用一个单一的注解类 <strong>@TableColumn</strong>，它拥有一个 <strong>enum</strong> 元素，元素值定义了 <strong>STRING</strong>，<strong>INTEGER</strong>，<strong>FLOAT</strong> 等类型。这消除了每个 SQL 类型都需要定义一个 <strong>@interface</strong> 的负担，不过也使得用额外信息修饰 SQL 类型变的不可能，这些额外的信息例如长度或精度等，都可能是非常有用的。</p><p>你也可以使用一个 <strong>String</strong> 类型的元素来描述实际的 SQL 类型，比如 “VARCHAR(30)” 或者 “INTEGER”。这使得你可以修饰 SQL 类型，但是这也将 Java 类型到 SQL 类型的映射绑在了一起，这不是一个好的设计。你并不想在数据库更改之后重新编译你的代码；如果我们只需要告诉注解处理器，我们正在使用的是什么“口味（favor）”的 SQL，然后注解助力器来为我们处理 SQL 类型的细节，那将是一个优雅的设计。</p><p>第三种可行的方案是一起使用两个注解，<strong>@Constraints</strong> 和相应的 SQL 类型（例如，<strong>@SQLInteger</strong>）去注解同一个字段。这可能会让代码有些混乱，但是编译器允许你对同一个目标使用多个注解。在 Java 8，在使用多个注解的时候，你可以重复使用同一个注解。</p><h3 id="注解不支持继承"><a href="#注解不支持继承" class="headerlink" title="注解不支持继承"></a>注解不支持继承</h3><p>你不能使用 <strong>extends</strong> 关键字来继承 <strong>@interfaces</strong>。这真是一个遗憾，如果可以定义 <strong>@TableColumn</strong> 注解（参考前面的建议），同时嵌套一个 <strong>@SQLType</strong> 类型的注解，将成为一个优雅的设计。按照这种方式，你可以通过继承 <strong>@SQLType</strong> 来创造各种 SQL 类型。例如 <strong>@SQLInteger</strong> 和 <strong>@SQLString</strong>。如果支持继承，就会大大减少打字的工作量并且使得语法更整洁。在 Java 的未来版本中，似乎没有任何关于让注解支持继承的提案，所以在当前情况下，上例中的解决方案可能已经是最佳方案了。</p><h3 id="实现处理器"><a href="#实现处理器" class="headerlink" title="实现处理器"></a>实现处理器</h3><p>下面是一个注解处理器的例子，他将读取一个类文件，检查上面的数据库注解，并生成用于创建数据库的 SQL 命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/database/TableCreator.java</span></span><br><span class="line"><span class="comment">// Reflection-based annotation processor</span></span><br><span class="line"><span class="comment">// &#123;java annotations.database.TableCreator</span></span><br><span class="line"><span class="comment">// annotations.database.Member&#125;</span></span><br><span class="line"><span class="keyword">package</span> annotations.database;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TableCreator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">    main(String[] args) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(</span><br><span class="line">                    <span class="string">"arguments: annotated classes"</span>);</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String className : args) &#123;</span><br><span class="line">            Class&lt;?&gt; cl = Class.forName(className);</span><br><span class="line">            DBTable dbTable = cl.getAnnotation(DBTable.class);</span><br><span class="line">            <span class="keyword">if</span> (dbTable == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(</span><br><span class="line">                        <span class="string">"No DBTable annotations in class "</span> +</span><br><span class="line">                                className);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String tableName = dbTable.name();</span><br><span class="line">            <span class="comment">// If the name is empty, use the Class name:</span></span><br><span class="line">            <span class="keyword">if</span> (tableName.length() &lt; <span class="number">1</span>)</span><br><span class="line">                tableName = cl.getName().toUpperCase();</span><br><span class="line">            List&lt;String&gt; columnDefs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (Field field : cl.getDeclaredFields()) &#123;</span><br><span class="line">                String columnName = <span class="keyword">null</span>;</span><br><span class="line">                Annotation[] anns =</span><br><span class="line">                        field.getDeclaredAnnotations();</span><br><span class="line">                <span class="keyword">if</span> (anns.length &lt; <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// Not a db table column</span></span><br><span class="line">                <span class="keyword">if</span> (anns[<span class="number">0</span>] <span class="keyword">instanceof</span> SQLInteger) &#123;</span><br><span class="line">                    SQLInteger sInt = (SQLInteger) anns[<span class="number">0</span>];</span><br><span class="line">                    <span class="comment">// Use field name if name not specified</span></span><br><span class="line">                    <span class="keyword">if</span> (sInt.name().length() &lt; <span class="number">1</span>)</span><br><span class="line">                        columnName = field.getName().toUpperCase();</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        columnName = sInt.name();</span><br><span class="line">                    columnDefs.add(columnName + <span class="string">" INT"</span> +</span><br><span class="line">                            getConstraints(sInt.constraints()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (anns[<span class="number">0</span>] <span class="keyword">instanceof</span> SQLString) &#123;</span><br><span class="line">                    SQLString sString = (SQLString) anns[<span class="number">0</span>];</span><br><span class="line">                    <span class="comment">// Use field name if name not specified.</span></span><br><span class="line">                    <span class="keyword">if</span> (sString.name().length() &lt; <span class="number">1</span>)</span><br><span class="line">                        columnName = field.getName().toUpperCase();</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        columnName = sString.name();</span><br><span class="line">                    columnDefs.add(columnName + <span class="string">" VARCHAR("</span> +</span><br><span class="line">                            sString.value() + <span class="string">")"</span> +</span><br><span class="line">                            getConstraints(sString.constraints()));</span><br><span class="line">                &#125;</span><br><span class="line">                StringBuilder createCommand = <span class="keyword">new</span> StringBuilder(</span><br><span class="line">                        <span class="string">"CREATE TABLE "</span> + tableName + <span class="string">"("</span>);</span><br><span class="line">                <span class="keyword">for</span> (String columnDef : columnDefs)</span><br><span class="line">                    createCommand.append(</span><br><span class="line">                            <span class="string">"\n "</span> + columnDef + <span class="string">","</span>);</span><br><span class="line">                <span class="comment">// Remove trailing comma</span></span><br><span class="line">                String tableCreate = createCommand.substring(</span><br><span class="line">                        <span class="number">0</span>, createCommand.length() - <span class="number">1</span>) + <span class="string">");"</span>;</span><br><span class="line">                System.out.println(<span class="string">"Table Creation SQL for "</span> +</span><br><span class="line">                        className + <span class="string">" is:\n"</span> + tableCreate);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getConstraints</span><span class="params">(Constraints con)</span> </span>&#123;</span><br><span class="line">        String constraints = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span> (!con.allowNull())</span><br><span class="line">            constraints += <span class="string">" NOT NULL"</span>;</span><br><span class="line">        <span class="keyword">if</span> (con.primaryKey())</span><br><span class="line">            constraints += <span class="string">" PRIMARY KEY"</span>;</span><br><span class="line">        <span class="keyword">if</span> (con.unique())</span><br><span class="line">            constraints += <span class="string">" UNIQUE"</span>;</span><br><span class="line">        <span class="keyword">return</span> constraints;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Table Creation SQL for annotations.database.Member is:</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">MEMBER</span>(</span><br><span class="line">    FIRSTNAME <span class="built_in">VARCHAR</span>(<span class="number">30</span>));</span><br><span class="line">Table Creation SQL for annotations.database.Member is:</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">MEMBER</span>(</span><br><span class="line">    FIRSTNAME <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">    LASTNAME <span class="built_in">VARCHAR</span>(<span class="number">50</span>));</span><br><span class="line">Table Creation SQL for annotations.database.Member is:</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">MEMBER</span>(</span><br><span class="line">    FIRSTNAME <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">    LASTNAME <span class="built_in">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    AGE <span class="built_in">INT</span>);</span><br><span class="line">Table Creation SQL for annotations.database.Member is:</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">MEMBER</span>(</span><br><span class="line">    FIRSTNAME <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">    LASTNAME <span class="built_in">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    AGE <span class="built_in">INT</span>,</span><br><span class="line">    <span class="keyword">REFERENCE</span> <span class="built_in">VARCHAR</span>(<span class="number">30</span>) PRIMARY <span class="keyword">KEY</span>);</span><br></pre></td></tr></table></figure><p>主方法会循环处理命令行传入的每一个类名。每一个类都是用 <code>forName()</code> 方法进行加载，并使用 <code>getAnnotation(DBTable.class)</code> 来检查该类是否带有 <strong>@DBTable</strong> 注解。如果存在，将表名存储起来。然后读取这个类的所有字段，并使用 <code>getDeclaredAnnotations()</code> 进行检查。这个方法返回一个包含特定字段上所有注解的数组。然后使用 <strong>instanceof</strong> 操作符判断这些注解是否是 <strong>@SQLInteger</strong> 或者 <strong>@SQLString</strong> 类型。如果是的话，在对应的处理块中将构造出相应的数据库列的字符串片段。注意，由于注解没有继承机制，如果要获取近似多态的行为，使用 <code>getDeclaredAnnotations()</code> 似乎是唯一的方式。</p><p>嵌套的 <strong>@Constraint</strong> 注解被传递给 <code>getConstraints()</code>方法，并用它来构造一个包含 SQL 约束的 String 对象。</p><p>需要提醒的是，上面演示的技巧对于真实的对象/映射关系而言，是十分幼稚的。使用 <strong>@DBTable</strong> 的注解来获取表的名称，这使得如果要修改表的名字，则迫使你重新编译 Java 代码。这种效果并不理想。现在已经有了很多可用的框架，用于将对象映射到数据库中，并且越来越多的框架开始使用注解了。</p><!-- Using javac to Process Annotations --><h2 id="使用javac处理注解"><a href="#使用javac处理注解" class="headerlink" title="使用javac处理注解"></a>使用javac处理注解</h2><p>通过 <strong>javac</strong>，你可以通过创建编译时（compile-time）注解处理器在 Java 源文件上使用注解，而不是编译之后的 class 文件。但是这里有一个重大限制：你不能通过处理器来改变源代码。唯一影响输出的方式就是创建新的文件。</p><p>如果你的注解处理器创建了新的源文件，在新一轮处理中注解会检查源文件本身。工具在检测一轮之后持续循环，直到不再有新的源文件产生。然后它编译所有的源文件。</p><p>每一个你编写的注解都需要处理器，但是 <strong>javac</strong> 可以非常容易的将多个注解处理器合并在一起。你可以指定多个需要处理的类，并且你可以添加监听器用于监听注解处理完成后接到通知。</p><p>本节中的示例将帮助你开始学习，但如果你必须深入学习，请做好反复学习，大量访问 Google 和StackOverflow 的准备。</p><h3 id="最简单的处理器"><a href="#最简单的处理器" class="headerlink" title="最简单的处理器"></a>最简单的处理器</h3><p>让我们开始定义我们能想到的最简单的处理器，只是为了编译和测试。如下是注解的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/simplest/Simple.java</span></span><br><span class="line"><span class="comment">// A bare-bones annotation</span></span><br><span class="line"><span class="keyword">package</span> annotations.simplest;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD,</span><br><span class="line">        ElementType.CONSTRUCTOR,</span><br><span class="line">        ElementType.ANNOTATION_TYPE,</span><br><span class="line">        ElementType.PACKAGE, ElementType.FIELD,</span><br><span class="line">        ElementType.LOCAL_VARIABLE&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Simple &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> "-<span class="keyword">default</span>-"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@Retention</strong> 的参数现在为 <strong>SOURCE</strong>，这意味着注解不会再存留在编译后的代码。这在编译时处理注解是没有必要的，它只是指出，在这里，<strong>javac</strong> 是唯一有机会处理注解的代理。</p><p><strong>@Target</strong> 声明了几乎所有的目标类型（除了 <strong>PACKAGE</strong>） ，同样是为了演示。下面是一个测试示例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/simplest/SimpleTest.java</span></span><br><span class="line"><span class="comment">// Test the "Simple" annotation</span></span><br><span class="line"><span class="comment">// &#123;java annotations.simplest.SimpleTest&#125;</span></span><br><span class="line"><span class="keyword">package</span> annotations.simplest;</span><br><span class="line"><span class="meta">@Simple</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Simple</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="meta">@Simple</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleTest</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Simple</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SimpleTest.foo()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Simple</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(String s, <span class="keyword">int</span> i, <span class="keyword">float</span> f)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SimpleTest.bar()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Simple</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Simple</span></span><br><span class="line">        SimpleTest st = <span class="keyword">new</span> SimpleTest();</span><br><span class="line">        st.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SimpleTest.foo()</span><br></pre></td></tr></table></figure><p>在这里我们使用 <strong>@Simple</strong> 注解了所有 <strong>@Target</strong> 声明允许的地方。</p><p><strong>SimpleTest.java</strong> 只需要 <strong>Simple.java</strong> 就可以编译成功。当我们编译的时候什么都没有发生。</p><p><strong>javac</strong> 允许 <strong>@Simple</strong> 注解（只要它存在）在我们创建处理器并将其 hook 到编译器之前，不做任何事情。</p><p>如下是一个十分简单的处理器，其所作的事情就是把注解相关的信息打印出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/simplest/SimpleProcessor.java</span></span><br><span class="line"><span class="comment">// A bare-bones annotation processor</span></span><br><span class="line"><span class="keyword">package</span> annotations.simplest;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.processing.*;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.SourceVersion;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="meta">@SupportedAnnotationTypes</span>(</span><br><span class="line">        <span class="string">"annotations.simplest.Simple"</span>)</span><br><span class="line"><span class="meta">@SupportedSourceVersion</span>(SourceVersion.RELEASE_8)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleProcessor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Set&lt;? extends TypeElement&gt; annotations,</span></span></span><br><span class="line"><span class="function"><span class="params">            RoundEnvironment env)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(TypeElement t : annotations)</span><br><span class="line">            System.out.println(t);</span><br><span class="line">        <span class="keyword">for</span>(Element el :</span><br><span class="line">                env.getElementsAnnotatedWith(Simple.class))</span><br><span class="line">            display(el);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Element el)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==== "</span> + el + <span class="string">" ===="</span>);</span><br><span class="line">        System.out.println(el.getKind() +</span><br><span class="line">                <span class="string">" : "</span> + el.getModifiers() +</span><br><span class="line">                <span class="string">" : "</span> + el.getSimpleName() +</span><br><span class="line">                <span class="string">" : "</span> + el.asType());</span><br><span class="line">        <span class="keyword">if</span>(el.getKind().equals(ElementKind.CLASS)) &#123;</span><br><span class="line">            TypeElement te = (TypeElement)el;</span><br><span class="line">            System.out.println(te.getQualifiedName());</span><br><span class="line">            System.out.println(te.getSuperclass());</span><br><span class="line">            System.out.println(te.getEnclosedElements());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(el.getKind().equals(ElementKind.METHOD)) &#123;</span><br><span class="line">            ExecutableElement ex = (ExecutableElement)el;</span><br><span class="line">            System.out.print(ex.getReturnType() + <span class="string">" "</span>);</span><br><span class="line">            System.out.print(ex.getSimpleName() + <span class="string">"("</span>);</span><br><span class="line">            System.out.println(ex.getParameters() + <span class="string">")"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（旧的，失效的）<strong>apt</strong> 版本的处理器需要额外的方法来确定支持哪些注解以及支持的 Java 版本。不过，你现在可以简单的使用 <strong>@SupportedAnnotationTypes</strong> 和 <strong>@SupportedSourceVersion</strong> 注解（这是一个很好的示例关于注解如何简化你的代码）。</p><p>你唯一需要实现的方法就是 <code>process()</code>，这里是所有行为发生的地方。第一个参数告诉你哪个注解是存在的，第二个参数保留了剩余信息。我们所做的事情只是打印了注解（这里只存在一个），可以看 <strong>TypeElement</strong> 文档中的其他行为。通过使用 <code>process()</code> 的第二个操作，我们循环所有被 <strong>@Simple</strong> 注解的元素，并且针对每一个元素调用我们的 <code>display()</code> 方法。所有 <strong>Element</strong> 展示了本身的基本信息；例如，<code>getModifiers()</code> 告诉你它是否为 <strong>public</strong> 和 <strong>static</strong> 的。</p><p><strong>Element</strong> 只能执行那些编译器解析的所有基本对象共有的操作，而类和方法之类的东西有额外的信息需要提取。所以（如果你阅读了正确的文档，但是我没有在任何文档中找到——我不得不通过 StackOverflow 寻找线索）你检查它是哪种 <strong>ElementKind</strong>，然后将其向下转换为更具体的元素类型，注入针对 CLASS 的 TypeElement 和 针对 METHOD 的ExecutableElement。此时，可以为这些元素调用其他方法。</p><p>动态向下转型（在编译期不进行检查）并不像是 Java 的做事方式，这非常不直观这也是为什么我从未想过要这样做事。相反，我花了好几天的时间，试图发现你应该如何访问这些信息，而这些信息至少在某种程度上是用不起作用的恰当方法简单明了的。我还没有遇到任何东西说上面是规范的形式，但在我看来是。</p><p>如果只是通过平常的方式来编译 <strong>SimpleTest.java</strong>，你不会得到任何结果。为了得到注解输出，你必须增加一个 <strong>processor</strong> 标志并且连接注解处理器类</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -processor annotations.simplest.SimpleProcessor SimpleTest.java</span><br></pre></td></tr></table></figure><p>现在编译器有了输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">annotations.simplest.Simple</span><br><span class="line">==== annotations.simplest.SimpleTest ====</span><br><span class="line">CLASS : [public] : SimpleTest : annotations.simplest.SimpleTest</span><br><span class="line">annotations.simplest.SimpleTest</span><br><span class="line">java.lang.Object</span><br><span class="line">i,SimpleTest(),foo(),bar(java.lang.String,int,float),main(java.lang.String[])</span><br><span class="line">==== i ====</span><br><span class="line">FIELD : [] : i : int</span><br><span class="line">==== SimpleTest() ====</span><br><span class="line">CONSTRUCTOR : [public] : &lt;init&gt; : ()void</span><br><span class="line">==== foo() ====</span><br><span class="line">METHOD : [public] : foo : ()void</span><br><span class="line">void foo()</span><br><span class="line">==== bar(java.lang.String,int,float) ====</span><br><span class="line">METHOD : [public] : bar : (java.lang.String,int,float)void</span><br><span class="line">void bar(s,i,f)</span><br><span class="line">==== main(java.lang.String[]) ====</span><br><span class="line">METHOD : [public, static] : main : (java.lang.String[])void</span><br><span class="line">void main(args)</span><br></pre></td></tr></table></figure><p>这给了你一些可以发现的东西，包括参数名和类型、返回值等。</p><h3 id="更复杂的处理器"><a href="#更复杂的处理器" class="headerlink" title="更复杂的处理器"></a>更复杂的处理器</h3><p>当你创建用于 javac 注解处理器时，你不能使用 Java 的反射特性，因为你处理的是源代码，而并非是编译后的 class 文件。各种 mirror[^3 ] 解决这个问题的方法是，通过允许你在未编译的源代码中查看方法、字段和类型。</p><p>如下是一个用于提取类中方法的注解，所以它可以被抽取成为一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/ifx/ExtractInterface.java</span></span><br><span class="line"><span class="comment">// javac-based annotation processing</span></span><br><span class="line"><span class="keyword">package</span> annotations.ifx;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ExtractInterface &#123;</span><br><span class="line">    <span class="function">String <span class="title">interfaceName</span><span class="params">()</span> <span class="keyword">default</span> "-!!-"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>RetentionPolicy</strong> 的值为 <strong>SOURCE</strong>，这是为了在提取类中的接口之后不再将注解信息保留在 class 文件中。接下来的测试类提供了一些公用方法，这些方法可以成为接口的一部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/ifx/Multiplier.java</span></span><br><span class="line"><span class="comment">// javac-based annotation processing</span></span><br><span class="line"><span class="comment">// &#123;java annotations.ifx.Multiplier&#125;</span></span><br><span class="line"><span class="keyword">package</span> annotations.ifx;</span><br><span class="line"><span class="meta">@ExtractInterface</span>(interfaceName=<span class="string">"IMultiplier"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Multiplier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x; i++)</span><br><span class="line">            total = add(total, y);</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fortySeven</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">47</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">timesTen</span><span class="params">(<span class="keyword">double</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arg * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Multiplier m = <span class="keyword">new</span> Multiplier();</span><br><span class="line">        System.out.println(</span><br><span class="line">                <span class="string">"11 * 16 = "</span> + m.multiply(<span class="number">11</span>, <span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span> * <span class="number">16</span> = <span class="number">176</span></span><br></pre></td></tr></table></figure><p><strong>Multiplier</strong> 类（只能处理正整数）拥有一个 <code>multiply()</code> 方法，这个方法会多次调用私有方法 <code>add()</code> 来模拟乘法操作。<code>add()</code> 是私有方法，因此不能成为接口的一部分。其他的方法提供了语法多样性。注解被赋予 <strong>IMultiplier</strong> 的 <strong>InterfaceName</strong> 作为要创建的接口的名称。</p><p>这里有一个编译时处理器用于提取有趣的方法，并创建一个新的 interface 源代码文件（这个源文件将会在下一轮中被自动编译）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/ifx/IfaceExtractorProcessor.java</span></span><br><span class="line"><span class="comment">// javac-based annotation processing</span></span><br><span class="line"><span class="keyword">package</span> annotations.ifx;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.processing.*;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.SourceVersion;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.*;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="meta">@SupportedAnnotationTypes</span>(</span><br><span class="line">        <span class="string">"annotations.ifx.ExtractInterface"</span>)</span><br><span class="line"><span class="meta">@SupportedSourceVersion</span>(SourceVersion.RELEASE_8)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IfaceExtractorProcessor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Element&gt;</span><br><span class="line">            interfaceMethods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Elements elementUtils;</span><br><span class="line">    <span class="keyword">private</span> ProcessingEnvironment processingEnv;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ProcessingEnvironment processingEnv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.processingEnv = processingEnv;</span><br><span class="line">        elementUtils = processingEnv.getElementUtils();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Set&lt;? extends TypeElement&gt; annotations,</span></span></span><br><span class="line"><span class="function"><span class="params">            RoundEnvironment env)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Element elem:env.getElementsAnnotatedWith(</span><br><span class="line">                ExtractInterface.class)) &#123;</span><br><span class="line">            String interfaceName = elem.getAnnotation(</span><br><span class="line">                    ExtractInterface.class).interfaceName();</span><br><span class="line">            <span class="keyword">for</span>(Element enclosed :</span><br><span class="line">                    elem.getEnclosedElements()) &#123;</span><br><span class="line">                <span class="keyword">if</span>(enclosed.getKind()</span><br><span class="line">                        .equals(ElementKind.METHOD) &amp;&amp;</span><br><span class="line">                        enclosed.getModifiers()</span><br><span class="line">                                .contains(Modifier.PUBLIC) &amp;&amp;</span><br><span class="line">                        !enclosed.getModifiers()</span><br><span class="line">                                .contains(Modifier.STATIC)) &#123;</span><br><span class="line">                    interfaceMethods.add(enclosed);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(interfaceMethods.size() &gt; <span class="number">0</span>)</span><br><span class="line">                writeInterfaceFile(interfaceName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span></span><br><span class="line">    writeInterfaceFile(String interfaceName) &#123;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">                Writer writer = processingEnv.getFiler()</span><br><span class="line">                        .createSourceFile(interfaceName)</span><br><span class="line">                        .openWriter()</span><br><span class="line">        ) &#123;</span><br><span class="line">            String packageName = elementUtils</span><br><span class="line">                    .getPackageOf(interfaceMethods</span><br><span class="line">                            .get(<span class="number">0</span>)).toString();</span><br><span class="line">            writer.write(</span><br><span class="line">                    <span class="string">"package "</span> + packageName + <span class="string">";\n"</span>);</span><br><span class="line">            writer.write(<span class="string">"public interface "</span> +</span><br><span class="line">                    interfaceName + <span class="string">" &#123;\n"</span>);</span><br><span class="line">            <span class="keyword">for</span>(Element elem : interfaceMethods) &#123;</span><br><span class="line">                ExecutableElement method =</span><br><span class="line">                        (ExecutableElement)elem;</span><br><span class="line">                String signature = <span class="string">" public "</span>;</span><br><span class="line">                signature += method.getReturnType() + <span class="string">" "</span>;</span><br><span class="line">                signature += method.getSimpleName();</span><br><span class="line">                signature += createArgList(</span><br><span class="line">                        method.getParameters());</span><br><span class="line">                System.out.println(signature);</span><br><span class="line">                writer.write(signature + <span class="string">";\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            writer.write(<span class="string">"&#125;"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">createArgList</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            List&lt;? extends VariableElement&gt; parameters)</span> </span>&#123;</span><br><span class="line">        String args = parameters.stream()</span><br><span class="line">                .map(p -&gt; p.asType() + <span class="string">" "</span> + p.getSimpleName())</span><br><span class="line">                .collect(Collectors.joining(<span class="string">", "</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"("</span> + args + <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Elements</strong> 对象实例 <strong>elementUtils</strong> 是一组静态方法的工具；我们用它来寻找 <strong>writeInterfaceFile()</strong> 中含有的包名。</p><p><code>getEnclosedElements()</code>方法会通过指定的元素生成所有的“闭包”元素。在这里，这个类闭包了它的所有元素。通过使用 <code>getKind()</code> 我们会找到所有的 <strong>public</strong> 和 <strong>static</strong> 方法，并将其添加到 <strong>interfaceMethods</strong> 列表中。接下来 <code>writeInterfaceFile()</code> 使用 <strong>interfaceMethods</strong> 列表里面的值生成新的接口定义。注意，在 <code>writeInterfaceFile()</code> 使用了向下转型到 <strong>ExecutableElement</strong>，这使得我们可以获取所有的方法信息。<strong>createArgList()</strong> 是一个帮助方法，用于生成参数列表。</p><p><strong>Filer</strong>是 <code>getFiler()</code> 生成的，并且是 <strong>PrintWriter</strong> 的一种实例，可以用于创建新文件。我们使用 <strong>Filer</strong> 对象，而不是原生的 <strong>PrintWriter</strong> 原因是，这个对象可以运行 <strong>javac</strong> 追踪你创建的新文件，这使得它可以在新一轮中检查新文件中的注解并编译文件。</p><p>如下是一个命令行，可以在编译的时候使用处理器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -processor annotations.ifx.IfaceExtractorProcessor Multiplier.java</span><br></pre></td></tr></table></figure><p>新生成的 <strong>IMultiplier.java</strong> 的文件，正如你通过查看上面处理器的 <code>println()</code> 语句所猜测的那样，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> annotations.ifx;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMultiplier</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fortySeven</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">timesTen</span><span class="params">(<span class="keyword">double</span> arg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类同样会被 <strong>javac</strong> 编译（在某一轮中），所以你会在同一个目录中看到 <strong>IMultiplier.class</strong> 文件。</p><!-- Annotation-Based Unit Testing --><h2 id="基于注解的单元测试"><a href="#基于注解的单元测试" class="headerlink" title="基于注解的单元测试"></a>基于注解的单元测试</h2><p>单元测试是对类中每个方法提供一个或者多个测试的一种事件，其目的是为了有规律的测试一个类中每个部分是否具备正确的行为。在 Java 中，最著名的单元测试工具就是 <strong>JUnit</strong>。<strong>JUnit</strong> 4 版本已经包含了注解。在注解版本之前的 JUnit 一个最主要的问题是，为了启动和运行 <strong>JUnit</strong> 测试，有大量的“仪式”需要标注。这种负担已经减轻了一些，<strong>但是</strong>注解使得测试更接近“可以工作的最简单的测试系统”。</p><p>在注解版本之前的 JUnit，你必须创建一个单独的文件来保存单元测试。通过注解，我们可以将单元测试集成在需要被测试的类中，从而将单元测试的时间和麻烦降到了最低。这种方式有额外的好处，就是使得测试私有方法和公有方法变的一样容易。</p><p>这个基于注解的测试框架叫做 <strong>@Unit</strong>。其最基本的测试形式，可能也是你使用的最多的一个注解是 <strong>@Test</strong>，我们使用 <strong>@Test</strong> 来标记测试方法。测试方法不带参数，并返回 <strong>boolean</strong> 结果来说明测试方法成功或者失败。你可以任意命名它的测试方法。同时 <strong>@Unit</strong> 测试方法可以是任意你喜欢的访问修饰方法，包括 <strong>private</strong>。</p><p>要使用 <strong>@Unit</strong>，你必须导入 <strong>onjava.atunit</strong> 包，并且使用 <strong>@Unit</strong> 的测试标记为合适的方法和字段打上标签（在接下来的例子中你会学到），然后让你的构建系统对编译后的类运行 <strong>@Unit</strong>，下面是一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/AtUnitExample1.java</span></span><br><span class="line"><span class="comment">// &#123;java onjava.atunit.AtUnit</span></span><br><span class="line"><span class="comment">// build/classes/main/annotations/AtUnitExample1.class&#125;</span></span><br><span class="line"><span class="keyword">package</span> annotations;</span><br><span class="line"><span class="keyword">import</span> onjava.atunit.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtUnitExample1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">methodOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"This is methodOne"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">methodTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is methodTwo"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">methodOneTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> methodOne().equals(<span class="string">"This is methodOne"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">m2</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> methodTwo() == <span class="number">2</span>; &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">m3</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">true</span>; &#125;</span><br><span class="line">    <span class="comment">// Shows output for failure:</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">failureTest</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">false</span>; &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">anotherDisappointment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">annotations.AtUnitExample1</span><br><span class="line">. m3</span><br><span class="line">. methodOneTest</span><br><span class="line">. m2 This is methodTwo</span><br><span class="line">. failureTest (failed)</span><br><span class="line">. anotherDisappointment (failed)</span><br><span class="line">(<span class="number">5</span> tests)</span><br><span class="line">&gt;&gt;&gt; <span class="number">2</span> FAILURES &lt;&lt;&lt;</span><br><span class="line">annotations.AtUnitExample1: failureTest</span><br><span class="line">annotations.AtUnitExample1: anotherDisappointment</span><br></pre></td></tr></table></figure><p>使用 <strong>@Unit</strong> 进行测试的类必须定义在某个包中（即必须包括 <strong>package</strong> 声明）。</p><p><strong>@Test</strong> 注解被置于 <code>methodOneTest()</code>、 <code>m2()</code>、<code>m3()</code>、<code>failureTest()</code> 以及 a<code>notherDisappointment()</code> 方法之前，它们告诉 <strong>@Unit</strong> 方法作为单元测试来运行。同时 <strong>@Test</strong> 确保这些方法没有任何参数并且返回值为 <strong>boolean</strong> 或者 <strong>void</strong>。当你填写单元测试时，唯一需要做的就是决定测试是成功还是失败，（对于返回值为 <strong>boolean</strong> 的方法）应该返回 <strong>ture</strong> 还是 <strong>false</strong>。</p><p>如果你熟悉 <strong>JUnit</strong>，你还将注意到 <strong>@Unit</strong> 输出的信息更多。你会看到现在正在运行的测试的输出更有用，最后它会告诉你导致失败的类和测试。</p><p>你并非必须将测试方法嵌入到原来的类中，有时候这种事情根本做不到。要生产一个非嵌入式的测试，最简单的方式就是继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/AUExternalTest.java</span></span><br><span class="line"><span class="comment">// Creating non-embedded tests</span></span><br><span class="line"><span class="comment">// &#123;java onjava.atunit.AtUnit</span></span><br><span class="line"><span class="comment">// build/classes/main/annotations/AUExternalTest.class&#125;</span></span><br><span class="line"><span class="keyword">package</span> annotations;</span><br><span class="line"><span class="keyword">import</span> onjava.atunit.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AUExternalTest</span> <span class="keyword">extends</span> <span class="title">AtUnitExample1</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">_MethodOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> methodOne().equals(<span class="string">"This is methodOne"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">_MethodTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> methodTwo() == <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">annotations.AUExternalTest</span><br><span class="line">. tMethodOne</span><br><span class="line">. tMethodTwo This is methodTwo</span><br><span class="line">OK (<span class="number">2</span> tests)</span><br></pre></td></tr></table></figure><p>这个示例还表现出灵活命名的价值。在这里，<strong>@Test</strong> 方法被命名为下划线前缀加上要测试的方法名称（我并不认为这是一种理想的命名形式，这只是表现一种可能性罢了）。</p><p>你也可以使用组合来创建非嵌入式的测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/AUComposition.java</span></span><br><span class="line"><span class="comment">// Creating non-embedded tests</span></span><br><span class="line"><span class="comment">// &#123;java onjava.atunit.AtUnit</span></span><br><span class="line"><span class="comment">// build/classes/main/annotations/AUComposition.class&#125;</span></span><br><span class="line"><span class="keyword">package</span> annotations;</span><br><span class="line"><span class="keyword">import</span> onjava.atunit.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AUComposition</span> </span>&#123;</span><br><span class="line">    AtUnitExample1 testObject = <span class="keyword">new</span> AtUnitExample1();</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tMethodOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> testObject.methodOne()</span><br><span class="line">                .equals(<span class="string">"This is methodOne"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tMethodTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> testObject.methodTwo() == <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">annotations.AUComposition</span><br><span class="line">. tMethodTwo This is methodTwo</span><br><span class="line">. tMethodOne</span><br><span class="line">OK (<span class="number">2</span> tests)</span><br></pre></td></tr></table></figure><p>因为在每一个测试里面都会创建 <strong>AUComposition</strong> 对象，所以创建新的成员变量 <strong>testObject</strong> 用于以后的每一个测试方法。</p><p>因为 <strong>@Unit</strong> 中没有 <strong>JUnit</strong> 中特殊的 <strong>assert</strong> 方法，不过另一种形式的 <strong>@Test</strong> 方法仍然允许返回值为 <strong>void</strong>（如果你还想使用 <strong>true</strong> 或者 <strong>false</strong> 的话，也可以使用 <strong>boolean</strong> 作为方法返回值类型）。为了表示测试成功，可以使用 Java 的 <strong>assert</strong> 语句。Java 断言机制需要你在 java 命令行行加上 <strong>-ea</strong> 标志来开启，但是 <strong>@Unit</strong> 已经自动开启了该功能。要表示测试失败的话，你甚至可以使用异常。<strong>@Unit</strong> 的设计目标之一就是尽可能减少添加额外的语法，而 Java 的 <strong>assert</strong> 和异常对于报告错误而言，即已经足够了。一个失败的 <strong>assert</strong> 或者从方法从抛出的异常都被视为测试失败，但是 <strong>@Unit</strong> 不会在这个失败的测试上卡住，它会继续运行，直到所有测试完毕，下面是一个示例程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/AtUnitExample2.java</span></span><br><span class="line"><span class="comment">// Assertions and exceptions can be used in @Tests</span></span><br><span class="line"><span class="comment">// &#123;java onjava.atunit.AtUnit</span></span><br><span class="line"><span class="comment">// build/classes/main/annotations/AtUnitExample2.class&#125;</span></span><br><span class="line"><span class="keyword">package</span> annotations;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> onjava.atunit.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtUnitExample2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">methodOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"This is methodOne"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">methodTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is methodTwo"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">assertExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">methodOne</span><span class="params">()</span>.<span class="title">equals</span><span class="params">(<span class="string">"This is methodOne"</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">assertFailureExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> <span class="number">1</span> == <span class="number">2</span>: <span class="string">"What a surprise!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exceptionExample</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(FileInputStream fis =</span><br><span class="line">                    <span class="keyword">new</span> FileInputStream(<span class="string">"nofile.txt"</span>)) &#123;&#125; <span class="comment">// Throws</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">assertAndReturn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Assertion with message:</span></span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">methodTwo</span><span class="params">()</span> </span>== <span class="number">2</span>: <span class="string">"methodTwo must equal 2"</span>;</span><br><span class="line">        <span class="keyword">return</span> methodOne().equals(<span class="string">"This is methodOne"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">annotations.AtUnitExample2</span><br><span class="line">. exceptionExample java.io.FileNotFoundException:</span><br><span class="line">nofile.txt (The system cannot find the file specified)</span><br><span class="line">(failed)</span><br><span class="line">. assertExample</span><br><span class="line">. assertAndReturn This is methodTwo</span><br><span class="line">. assertFailureExample java.lang.AssertionError: What</span><br><span class="line">a surprise!</span><br><span class="line">(failed)</span><br><span class="line">(<span class="number">4</span> tests)</span><br><span class="line">&gt;&gt;&gt; <span class="number">2</span> FAILURES &lt;&lt;&lt;</span><br><span class="line">annotations.AtUnitExample2: exceptionExample</span><br><span class="line">annotations.AtUnitExample2: assertFailureExample</span><br></pre></td></tr></table></figure><p>如下是一个使用非嵌入式测试的例子，并且使用了断言，它将会对 <strong>java.util.HashSet</strong> 进行一些简单的测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/HashSetTest.java</span></span><br><span class="line"><span class="comment">// &#123;java onjava.atunit.AtUnit</span></span><br><span class="line"><span class="comment">// build/classes/main/annotations/HashSetTest.class&#125;</span></span><br><span class="line"><span class="keyword">package</span> annotations;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> onjava.atunit.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetTest</span> </span>&#123;</span><br><span class="line">    HashSet&lt;String&gt; testObject = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initialization</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> testObject.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">_Contains</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        testObject.add(<span class="string">"one"</span>);</span><br><span class="line">        <span class="keyword">assert</span> testObject.contains(<span class="string">"one"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">_Remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        testObject.add(<span class="string">"one"</span>);</span><br><span class="line">        testObject.remove(<span class="string">"one"</span>);</span><br><span class="line">        <span class="keyword">assert</span> testObject.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用继承的方式可能会更简单，也没有一些其他的约束。</p><p>对每一个单元测试而言，<strong>@Unit</strong> 都会使用默认的无参构造器，为该测试类所属的类创建出一个新的实例。并在此新创建的对象上运行测试，然后丢弃该对象，以免对其他测试产生副作用。如此创建对象导致我们依赖于类的默认构造器。如果你的类没有默认构造器，或者对象需要复杂的构造过程，那么你可以创建一个 <strong>static</strong> 方法专门负责构造对象，然后使用 <strong>@TestObjectCreate</strong> 注解标记该方法，例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/AtUnitExample3.java</span></span><br><span class="line"><span class="comment">// &#123;java onjava.atunit.AtUnit</span></span><br><span class="line"><span class="comment">// build/classes/main/annotations/AtUnitExample3.class&#125;</span></span><br><span class="line"><span class="keyword">package</span> annotations;</span><br><span class="line"><span class="keyword">import</span> onjava.atunit.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtUnitExample3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtUnitExample3</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">this</span>.n = n; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getN</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">methodOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"This is methodOne"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">methodTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is methodTwo"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@TestObjectCreate</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> AtUnitExample3 <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AtUnitExample3(<span class="number">47</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">initialization</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> n == <span class="number">47</span>; &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">methodOneTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> methodOne().equals(<span class="string">"This is methodOne"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">m2</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> methodTwo() == <span class="number">2</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">annotations.AtUnitExample3</span><br><span class="line">. initialization</span><br><span class="line">. m2 This is methodTwo</span><br><span class="line">. methodOneTest</span><br><span class="line">OK (<span class="number">3</span> tests)</span><br></pre></td></tr></table></figure><p><strong>@TestObjectCreate</strong> 修饰的方法必须声明为 <strong>static</strong> ，且必须返回一个你正在测试的类型对象，这一切都由 <strong>@Unit</strong> 负责确保成立。</p><p>有的时候，你需要向单元测试中增加一些字段。这时候可以使用 <strong>@TestProperty</strong> 注解，由它注解的字段表示只在单元测试中使用（因此，在你将产品发布给客户之前，他们应该被删除）。在下面的例子中，一个 <strong>String</strong> 通过 <code>String.split()</code> 方法进行分割，从其中读取一个值，这个值将会被生成测试对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/AtUnitExample4.java</span></span><br><span class="line"><span class="comment">// &#123;java onjava.atunit.AtUnit</span></span><br><span class="line"><span class="comment">// build/classes/main/annotations/AtUnitExample4.class&#125;</span></span><br><span class="line"><span class="comment">// &#123;VisuallyInspectOutput&#125;</span></span><br><span class="line"><span class="keyword">package</span> annotations;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> onjava.atunit.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtUnitExample4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String theory = <span class="string">"All brontosauruses "</span> +</span><br><span class="line">            <span class="string">"are thin at one end, much MUCH thicker in the "</span> +</span><br><span class="line">            <span class="string">"middle, and then thin again at the far end."</span>;</span><br><span class="line">    <span class="keyword">private</span> String word;</span><br><span class="line">    <span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random(); <span class="comment">// Time-based seed</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtUnitExample4</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.word = word;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getWord</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> word; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">scrambleWord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Character&gt; chars = Arrays.asList(</span><br><span class="line">                ConvertTo.boxed(word.toCharArray()));</span><br><span class="line">        Collections.shuffle(chars, rand);</span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch : chars)</span><br><span class="line">            result.append(ch);</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@TestProperty</span></span><br><span class="line">    <span class="keyword">static</span> List&lt;String&gt; input =</span><br><span class="line">            Arrays.asList(theory.split(<span class="string">" "</span>));</span><br><span class="line">    <span class="meta">@TestProperty</span></span><br><span class="line">    <span class="keyword">static</span> Iterator&lt;String&gt; words = input.iterator();</span><br><span class="line">    <span class="meta">@TestObjectCreate</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> AtUnitExample4 <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(words.hasNext())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AtUnitExample4(words.next());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">words</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"'"</span> + getWord() + <span class="string">"'"</span>);</span><br><span class="line">        <span class="keyword">return</span> getWord().equals(<span class="string">"are"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">scramble1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// Use specific seed to get verifiable results:</span></span><br><span class="line">        rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        System.out.println(<span class="string">"'"</span> + getWord() + <span class="string">"'"</span>);</span><br><span class="line">        String scrambled = scrambleWord();</span><br><span class="line">        System.out.println(scrambled);</span><br><span class="line">        <span class="keyword">return</span> scrambled.equals(<span class="string">"lAl"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">scramble2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rand = <span class="keyword">new</span> Random(<span class="number">74</span>);</span><br><span class="line">        System.out.println(<span class="string">"'"</span> + getWord() + <span class="string">"'"</span>);</span><br><span class="line">        String scrambled = scrambleWord();</span><br><span class="line">        System.out.println(scrambled);</span><br><span class="line">        <span class="keyword">return</span> scrambled.equals(<span class="string">"tsaeborornussu"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">annotations.AtUnitExample4</span><br><span class="line">. words <span class="string">'All'</span></span><br><span class="line">(failed)</span><br><span class="line">. scramble1 <span class="string">'brontosauruses'</span></span><br><span class="line">ntsaueorosurbs</span><br><span class="line">(failed)</span><br><span class="line">. scramble2 <span class="string">'are'</span></span><br><span class="line">are</span><br><span class="line">(failed)</span><br><span class="line">(<span class="number">3</span> tests)</span><br><span class="line">&gt;&gt;&gt; <span class="number">3</span> FAILURES &lt;&lt;&lt;</span><br><span class="line">annotations.AtUnitExample4: words</span><br><span class="line">annotations.AtUnitExample4: scramble1</span><br><span class="line">annotations.AtUnitExample4: scramble2</span><br></pre></td></tr></table></figure><p><strong>@TestProperty</strong> 也可以用来标记那些只在测试中使用的方法，但是它们本身不是测试方法。</p><p>如果你的测试对象需要执行某些初始化工作，并且使用完成之后还需要执行清理工作，那么可以选择使用 <strong>static</strong> 的  <strong>@TestObjectCleanup</strong> 方法，当测试对象使用结束之后，该方法会为你执行清理工作。在下面的示例中，<strong>@TestObjectCleanup</strong> 为每一个测试对象都打开了一个文件，因此必须在丢弃测试的时候关闭该文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/AtUnitExample5.java</span></span><br><span class="line"><span class="comment">// &#123;java onjava.atunit.AtUnit</span></span><br><span class="line"><span class="comment">// build/classes/main/annotations/AtUnitExample5.class&#125;</span></span><br><span class="line"><span class="keyword">package</span> annotations;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> onjava.atunit.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtUnitExample5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String text;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtUnitExample5</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.text = text;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> text; &#125;</span><br><span class="line">    <span class="meta">@TestProperty</span></span><br><span class="line">    <span class="keyword">static</span> PrintWriter output;</span><br><span class="line">    <span class="meta">@TestProperty</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> counter;</span><br><span class="line">    <span class="meta">@TestObjectCreate</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> AtUnitExample5 <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String id = Integer.toString(counter++);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            output = <span class="keyword">new</span> PrintWriter(<span class="string">"Test"</span> + id + <span class="string">".txt"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AtUnitExample5(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@TestObjectCleanup</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">(AtUnitExample5 tobj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Running cleanup"</span>);</span><br><span class="line">        output.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        output.print(<span class="string">"test1"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        output.print(<span class="string">"test2"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        output.print(<span class="string">"test3"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">annotations.AtUnitExample5</span><br><span class="line">. test1</span><br><span class="line">Running cleanup</span><br><span class="line">. test3</span><br><span class="line">Running cleanup</span><br><span class="line">. test2</span><br><span class="line">Running cleanup</span><br><span class="line">OK (<span class="number">3</span> tests)</span><br></pre></td></tr></table></figure><p>在输出中我们可以看到，清理方法会在每个测试方法结束之后自动运行。</p><h3 id="在-Unit-中使用泛型"><a href="#在-Unit-中使用泛型" class="headerlink" title="在 @Unit 中使用泛型"></a>在 @Unit 中使用泛型</h3><p>泛型为 <strong>@Unit</strong> 出了一个难题，因为我们不可能“通用测试”。我们必须针对某个特定类型的参数或者参数集才能进行测试。解决方法十分简单，让测试类继承自泛型类的一个特定版本即可：</p><p>下面是一个 <strong>stack</strong> 的简单实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/StackL.java</span></span><br><span class="line"><span class="comment">// A stack built on a LinkedList</span></span><br><span class="line"><span class="keyword">package</span> annotations;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackL</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;T&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T v)</span> </span>&#123; list.addFirst(v); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">top</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> list.getFirst(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> list.removeFirst(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了测试 String 版本，我们直接让测试类继承一个 Stack&lt;String&gt; ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/StackLStringTst.java</span></span><br><span class="line"><span class="comment">// Applying @Unit to generics</span></span><br><span class="line"><span class="comment">// &#123;java onjava.atunit.AtUnit</span></span><br><span class="line"><span class="comment">// build/classes/main/annotations/StackLStringTst.class&#125;</span></span><br><span class="line"><span class="keyword">package</span> annotations;</span><br><span class="line"><span class="keyword">import</span> onjava.atunit.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="class"><span class="title">StackLStringTst</span> <span class="keyword">extends</span> <span class="title">StackL</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tPush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        push(<span class="string">"one"</span>);</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">top</span><span class="params">()</span>.<span class="title">equals</span><span class="params">(<span class="string">"one"</span>)</span></span>;</span><br><span class="line">        push(<span class="string">"two"</span>);</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">top</span><span class="params">()</span>.<span class="title">equals</span><span class="params">(<span class="string">"two"</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tPop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        push(<span class="string">"one"</span>);</span><br><span class="line">        push(<span class="string">"two"</span>);</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">pop</span><span class="params">()</span>.<span class="title">equals</span><span class="params">(<span class="string">"two"</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">pop</span><span class="params">()</span>.<span class="title">equals</span><span class="params">(<span class="string">"one"</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tTop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        push(<span class="string">"A"</span>);</span><br><span class="line">        push(<span class="string">"B"</span>);</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">top</span><span class="params">()</span>.<span class="title">equals</span><span class="params">(<span class="string">"B"</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">top</span><span class="params">()</span>.<span class="title">equals</span><span class="params">(<span class="string">"B"</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">annotations.StackLStringTst</span><br><span class="line">. tTop</span><br><span class="line">. tPush</span><br><span class="line">. tPop</span><br><span class="line">OK (<span class="number">3</span> tests)</span><br></pre></td></tr></table></figure><p>这种方法存在的唯一缺点是，继承使我们失去了访问被测试的类中 <strong>private</strong> 方法的能力。这对你非常重要，那你要么把 private 方法变为 <strong>protected</strong>，要么添加一个非 <strong>private</strong> 的 <strong>@TestProperty</strong> 方法，由它来调用 <strong>private</strong> 方法（稍后我们会看到，<strong>AtUnitRemover</strong> 会删除产品中的 <strong>@TestProperty</strong> 方法）。</p><p><strong>@Unit</strong> 搜索那些包含合适注解的类文件，然后运行 <strong>@Test</strong> 方法。我的主要目标就是让 <strong>@Unit</strong> 测试系统尽可能的透明，使得人们使用它的时候只需要添加 <strong>@Test</strong> 注解，而不需要特殊的编码和知识（现在版本的 <strong>JUnit</strong> 符合这个实践）。不过，如果说编写测试不会遇到任何困难，也不太可能，因此 <strong>@Unit</strong> 会尽量让这些困难变的微不足道，希望通过这种方式，你们会更乐意编写测试。</p><h3 id="实现-Unit"><a href="#实现-Unit" class="headerlink" title="实现 @Unit"></a>实现 @Unit</h3><p>首先我们需要定义所有的注解类型。这些都是简单的标签，并且没有任何字段。@Test 标签在本章开头已经定义过了，这里是其他所需要的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/atunit/TestObjectCreate.java</span></span><br><span class="line"><span class="comment">// The @Unit @TestObjectCreate tag</span></span><br><span class="line"><span class="keyword">package</span> onjava.atunit;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestObjectCreate &#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/atunit/TestObjectCleanup.java</span></span><br><span class="line"><span class="comment">// The @Unit @TestObjectCleanup tag</span></span><br><span class="line"><span class="keyword">package</span> onjava.atunit;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestObjectCleanup &#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/atunit/TestProperty.java</span></span><br><span class="line"><span class="comment">// The @Unit @TestProperty tag</span></span><br><span class="line"><span class="keyword">package</span> onjava.atunit;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="comment">// Both fields and methods can be tagged as properties:</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD, ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestProperty &#123;&#125;</span><br></pre></td></tr></table></figure><p>所有测试的保留属性都为 <strong>RUNTIME</strong>，这是因为 <strong>@Unit</strong> 必须在编译后的代码中发现这些注解。</p><p>要实现系统并运行测试，我们还需要反射机制来提取注解。下面这个程序通过注解中的信息，决定如何构造测试对象，并在测试对象上运行测试。正是由于注解帮助，这个程序才会如此短小而直接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/atunit/AtUnit.java</span></span><br><span class="line"><span class="comment">// An annotation-based unit-test framework</span></span><br><span class="line"><span class="comment">// &#123;java onjava.atunit.AtUnit&#125;</span></span><br><span class="line"><span class="keyword">package</span> onjava.atunit;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtUnit</span> <span class="keyword">implements</span> <span class="title">ProcessFiles</span>.<span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Class&lt;?&gt; testClass;</span><br><span class="line">    <span class="keyword">static</span> List&lt;String&gt; failedTests= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> testsRun = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> failures = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">    main(String[] args) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ClassLoader.getSystemClassLoader()</span><br><span class="line">                .setDefaultAssertionStatus(<span class="keyword">true</span>); <span class="comment">// Enable assert</span></span><br><span class="line">        <span class="keyword">new</span> ProcessFiles(<span class="keyword">new</span> AtUnit(), <span class="string">"class"</span>).start(args);</span><br><span class="line">        <span class="keyword">if</span>(failures == <span class="number">0</span>)</span><br><span class="line">            System.out.println(<span class="string">"OK ("</span> + testsRun + <span class="string">" tests)"</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"("</span> + testsRun + <span class="string">" tests)"</span>);</span><br><span class="line">            System.out.println(</span><br><span class="line">                    <span class="string">"\n&gt;&gt;&gt; "</span> + failures + <span class="string">" FAILURE"</span> +</span><br><span class="line">                            (failures &gt; <span class="number">1</span> ? <span class="string">"S"</span> : <span class="string">""</span>) + <span class="string">" &lt;&lt;&lt;"</span>);</span><br><span class="line">            <span class="keyword">for</span>(String failed : failedTests)</span><br><span class="line">                System.out.println(<span class="string">" "</span> + failed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(File cFile)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String cName = ClassNameFinder.thisClass(</span><br><span class="line">                    Files.readAllBytes(cFile.toPath()));</span><br><span class="line">            <span class="keyword">if</span>(!cName.startsWith(<span class="string">"public:"</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            cName = cName.split(<span class="string">":"</span>)[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(!cName.contains(<span class="string">"."</span>))</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// Ignore unpackaged classes</span></span><br><span class="line">            testClass = Class.forName(cName);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        TestMethods testMethods = <span class="keyword">new</span> TestMethods();</span><br><span class="line">        Method creator = <span class="keyword">null</span>;</span><br><span class="line">        Method cleanup = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(Method m : testClass.getDeclaredMethods()) &#123;</span><br><span class="line">            testMethods.addIfTestMethod(m);</span><br><span class="line">            <span class="keyword">if</span>(creator == <span class="keyword">null</span>)</span><br><span class="line">                creator = checkForCreatorMethod(m);</span><br><span class="line">            <span class="keyword">if</span>(cleanup == <span class="keyword">null</span>)</span><br><span class="line">                cleanup = checkForCleanupMethod(m);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(testMethods.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(creator == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!Modifier.isPublic(testClass</span><br><span class="line">                            .getDeclaredConstructor()</span><br><span class="line">                            .getModifiers())) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"Error: "</span> + testClass +</span><br><span class="line">                                <span class="string">" no-arg constructor must be public"</span>);</span><br><span class="line">                        System.exit(<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span>(NoSuchMethodException e) &#123;</span><br><span class="line"><span class="comment">// Synthesized no-arg constructor; OK</span></span><br><span class="line">                &#125;</span><br><span class="line">            System.out.println(testClass.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Method m : testMethods) &#123;</span><br><span class="line">            System.out.print(<span class="string">" . "</span> + m.getName() + <span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object testObject = createTestObject(creator);</span><br><span class="line">                <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(m.getReturnType().equals(<span class="keyword">boolean</span>.class))</span><br><span class="line">                        success = (Boolean)m.invoke(testObject);</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        m.invoke(testObject);</span><br><span class="line">                        success = <span class="keyword">true</span>; <span class="comment">// If no assert fails</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span>(InvocationTargetException e) &#123;</span><br><span class="line"><span class="comment">// Actual exception is inside e:</span></span><br><span class="line">                    System.out.println(e.getCause());</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(success ? <span class="string">""</span> : <span class="string">"(failed)"</span>);</span><br><span class="line">                testsRun++;</span><br><span class="line">                <span class="keyword">if</span>(!success) &#123;</span><br><span class="line">                    failures++;</span><br><span class="line">                    failedTests.add(testClass.getName() +</span><br><span class="line">                            <span class="string">": "</span> + m.getName());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cleanup != <span class="keyword">null</span>)</span><br><span class="line">                    cleanup.invoke(testObject, testObject);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(IllegalAccessException |</span><br><span class="line">                    IllegalArgumentException |</span><br><span class="line">                    InvocationTargetException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TestMethods</span> <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">Method</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">addIfTestMethod</span><span class="params">(Method m)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(m.getAnnotation(Test.class) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(m.getReturnType().equals(<span class="keyword">boolean</span>.class) ||</span><br><span class="line">                    m.getReturnType().equals(<span class="keyword">void</span>.class)))</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"@Test method"</span> +</span><br><span class="line">                        <span class="string">" must return boolean or void"</span>);</span><br><span class="line">            m.setAccessible(<span class="keyword">true</span>); <span class="comment">// If it's private, etc.</span></span><br><span class="line">            add(m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span></span><br><span class="line">    <span class="function">Method <span class="title">checkForCreatorMethod</span><span class="params">(Method m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m.getAnnotation(TestObjectCreate.class) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(!m.getReturnType().equals(testClass))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"@TestObjectCreate "</span> +</span><br><span class="line">                    <span class="string">"must return instance of Class to be tested"</span>);</span><br><span class="line">        <span class="keyword">if</span>((m.getModifiers() &amp;</span><br><span class="line">                java.lang.reflect.Modifier.STATIC) &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"@TestObjectCreate "</span> +</span><br><span class="line">                    <span class="string">"must be static."</span>);</span><br><span class="line">        m.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span></span><br><span class="line">    <span class="function">Method <span class="title">checkForCleanupMethod</span><span class="params">(Method m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m.getAnnotation(TestObjectCleanup.class) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(!m.getReturnType().equals(<span class="keyword">void</span>.class))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"@TestObjectCleanup "</span> +</span><br><span class="line">                    <span class="string">"must return void"</span>);</span><br><span class="line">        <span class="keyword">if</span>((m.getModifiers() &amp;</span><br><span class="line">                java.lang.reflect.Modifier.STATIC) &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"@TestObjectCleanup "</span> +</span><br><span class="line">                    <span class="string">"must be static."</span>);</span><br><span class="line">        <span class="keyword">if</span>(m.getParameterTypes().length == <span class="number">0</span> ||</span><br><span class="line">                m.getParameterTypes()[<span class="number">0</span>] != testClass)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"@TestObjectCleanup "</span> +</span><br><span class="line">                    <span class="string">"must take an argument of the tested type."</span>);</span><br><span class="line">        m.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object</span><br><span class="line">    createTestObject(Method creator) &#123;</span><br><span class="line">        <span class="keyword">if</span>(creator != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> creator.invoke(testClass);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(IllegalAccessException |</span><br><span class="line">                    IllegalArgumentException |</span><br><span class="line">                    InvocationTargetException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Couldn't run "</span> +</span><br><span class="line">                        <span class="string">"@TestObject (creator) method."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// Use the no-arg constructor:</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> testClass.newInstance();</span><br><span class="line">            &#125; <span class="keyword">catch</span>(InstantiationException |</span><br><span class="line">                    IllegalAccessException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                        <span class="string">"Couldn't create a test object. "</span> +</span><br><span class="line">                                <span class="string">"Try using a @TestObject method."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然它可能是“过早的重构”（因为它只在书中使用过一次），<strong>AtUnit.java</strong> 使用了 <strong>ProcessFiles</strong> 工具逐步判断命令行中的参数，决定它是一个目录还是文件，并采取相应的行为。这可以应用于不同的解决方法，是因为它包含了一个 可用于自定义的 <strong>Strategy</strong> 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/ProcessFiles.java</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessFiles</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(File file)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line">    <span class="keyword">private</span> String ext;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProcessFiles</span><span class="params">(Strategy strategy, String ext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">        <span class="keyword">this</span>.ext = ext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(args.length == <span class="number">0</span>)</span><br><span class="line">                processDirectoryTree(<span class="keyword">new</span> File(<span class="string">"."</span>));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">for</span>(String arg : args) &#123;</span><br><span class="line">                    File fileArg = <span class="keyword">new</span> File(arg);</span><br><span class="line">                    <span class="keyword">if</span>(fileArg.isDirectory())</span><br><span class="line">                        processDirectoryTree(fileArg);</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Allow user to leave off extension:</span></span><br><span class="line">                        <span class="keyword">if</span>(!arg.endsWith(<span class="string">"."</span> + ext))</span><br><span class="line">                            arg += <span class="string">"."</span> + ext;</span><br><span class="line">                        strategy.process(</span><br><span class="line">                                <span class="keyword">new</span> File(arg).getCanonicalFile());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processDirectoryTree</span><span class="params">(File root)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        PathMatcher matcher = FileSystems.getDefault()</span><br><span class="line">                .getPathMatcher(<span class="string">"glob:**/*.&#123;"</span> + ext + <span class="string">"&#125;"</span>);</span><br><span class="line">        Files.walk(root.toPath())</span><br><span class="line">                .filter(matcher::matches)</span><br><span class="line">                .forEach(p -&gt; strategy.process(p.toFile()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AtUnit</strong> 类实现了 <strong>ProcessFiles.Strategy</strong>，其包含了一个 <code>process()</code> 方法。在这种方式下，<strong>AtUnit</strong> 实例可以作为参数传递给 <strong>ProcessFiles</strong> 构造器。第二个构造器的参数告诉 <strong>ProcessFiles</strong> 如寻找所有包含 “class” 拓展名的文件。</p><p>如下是一个简单的使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/DemoProcessFiles.java</span></span><br><span class="line"><span class="keyword">import</span> onjava.ProcessFiles;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoProcessFiles</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ProcessFiles(file -&gt; System.out.println(file),</span><br><span class="line">                <span class="string">"java"</span>).start(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">.\AtUnitExample1.java</span><br><span class="line">.\AtUnitExample2.java</span><br><span class="line">.\AtUnitExample3.java</span><br><span class="line">.\AtUnitExample4.java</span><br><span class="line">.\AtUnitExample5.java</span><br><span class="line">.\AUComposition.java</span><br><span class="line">.\AUExternalTest.java</span><br><span class="line">.\database\Constraints.java</span><br><span class="line">.\database\DBTable.java</span><br><span class="line">.\database\Member.java</span><br><span class="line">.\database\SQLInteger.java</span><br><span class="line">.\database\SQLString.java</span><br><span class="line">.\database\TableCreator.java</span><br><span class="line">.\database\Uniqueness.java</span><br><span class="line">.\DemoProcessFiles.java</span><br><span class="line">.\HashSetTest.java</span><br><span class="line">.\ifx\ExtractInterface.java</span><br><span class="line">.\ifx\IfaceExtractorProcessor.java</span><br><span class="line">.\ifx\Multiplier.java</span><br><span class="line">.\PasswordUtils.java</span><br><span class="line">.\simplest\Simple.java</span><br><span class="line">.\simplest\SimpleProcessor.java</span><br><span class="line">.\simplest\SimpleTest.java</span><br><span class="line">.\SimulatingNull.java</span><br><span class="line">.\StackL.java</span><br><span class="line">.\StackLStringTst.java</span><br><span class="line">.\Testable.java</span><br><span class="line">.\UseCase.java</span><br><span class="line">.\UseCaseTracker.java</span><br></pre></td></tr></table></figure><p>如果没有命令行参数，这个程序会遍历当前的目录树。你还可以提供多个参数，这些参数可以是类文件（带或不带.class扩展名）或目录。</p><p>回到我们对 <strong>AtUnit.java</strong> 的讨论，因为 <strong>@Unit</strong> 会自动找到可测试的类和方法，所以不需要“套件”机制。</p><p><strong>AtUnit.java</strong> 中存在的一个我们必须要解决的问题是，当它发现类文件时，类文件名中的限定类名（包括包）不明显。为了发现这个信息，必须解析类文件 - 这不是微不足道的，但也不是不可能的。 找到 .class 文件时，会打开它并读取其二进制数据并将其传递给 <code>ClassNameFinder.thisClass()</code>。 在这里，我们正在进入“字节码工程”领域，因为我们实际上正在分析类文件的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/atunit/ClassNameFinder.java</span></span><br><span class="line"><span class="comment">// &#123;java onjava.atunit.ClassNameFinder&#125;</span></span><br><span class="line"><span class="keyword">package</span> onjava.atunit;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassNameFinder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">thisClass</span><span class="params">(<span class="keyword">byte</span>[] classBytes)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; offsetTable = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Integer,String&gt; classNameTable = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DataInputStream data = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">                    <span class="keyword">new</span> ByteArrayInputStream(classBytes));</span><br><span class="line">            <span class="keyword">int</span> magic = data.readInt(); <span class="comment">// 0xcafebabe</span></span><br><span class="line">            <span class="keyword">int</span> minorVersion = data.readShort();</span><br><span class="line">            <span class="keyword">int</span> majorVersion = data.readShort();</span><br><span class="line">            <span class="keyword">int</span> constantPoolCount = data.readShort();</span><br><span class="line">            <span class="keyword">int</span>[] constantPool = <span class="keyword">new</span> <span class="keyword">int</span>[constantPoolCount];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; constantPoolCount; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> tag = data.read();</span><br><span class="line">                <span class="comment">// int tableSize;</span></span><br><span class="line">                <span class="keyword">switch</span>(tag) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// UTF</span></span><br><span class="line">                        <span class="keyword">int</span> length = data.readShort();</span><br><span class="line">                        <span class="keyword">char</span>[] bytes = <span class="keyword">new</span> <span class="keyword">char</span>[length];</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; bytes.length; k++)</span><br><span class="line">                            bytes[k] = (<span class="keyword">char</span>)data.read();</span><br><span class="line">                        String className = <span class="keyword">new</span> String(bytes);</span><br><span class="line">                        classNameTable.put(i, className);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">5</span>: <span class="comment">// LONG</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="number">6</span>: <span class="comment">// DOUBLE</span></span><br><span class="line">                        data.readLong(); <span class="comment">// discard 8 bytes</span></span><br><span class="line">                        i++; <span class="comment">// Special skip necessary</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">7</span>: <span class="comment">// CLASS</span></span><br><span class="line">                        <span class="keyword">int</span> offset = data.readShort();</span><br><span class="line">                        offsetTable.put(i, offset);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">8</span>: <span class="comment">// STRING</span></span><br><span class="line">                        data.readShort(); <span class="comment">// discard 2 bytes</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">// INTEGER</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="number">4</span>: <span class="comment">// FLOAT</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="number">9</span>: <span class="comment">// FIELD_REF</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="number">10</span>: <span class="comment">// METHOD_REF</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="number">11</span>: <span class="comment">// INTERFACE_METHOD_REF</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="number">12</span>: <span class="comment">// NAME_AND_TYPE</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="number">18</span>: <span class="comment">// Invoke Dynamic</span></span><br><span class="line">                        data.readInt(); <span class="comment">// discard 4 bytes</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">15</span>: <span class="comment">// Method Handle</span></span><br><span class="line">                        data.readByte();</span><br><span class="line">                        data.readShort();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">16</span>: <span class="comment">// Method Type</span></span><br><span class="line">                        data.readShort();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">throw</span></span><br><span class="line">                                <span class="keyword">new</span> RuntimeException(<span class="string">"Bad tag "</span> + tag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">short</span> accessFlags = data.readShort();</span><br><span class="line">            String access = (accessFlags &amp; <span class="number">0x0001</span>) == <span class="number">0</span> ?</span><br><span class="line">                    <span class="string">"nonpublic:"</span> : <span class="string">"public:"</span>;</span><br><span class="line">            <span class="keyword">int</span> thisClass = data.readShort();</span><br><span class="line">            <span class="keyword">int</span> superClass = data.readShort();</span><br><span class="line">            <span class="keyword">return</span> access + classNameTable.get(</span><br><span class="line">                    offsetTable.get(thisClass)).replace(<span class="string">'/'</span>, <span class="string">'.'</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException | RuntimeException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Demonstration:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        PathMatcher matcher = FileSystems.getDefault()</span><br><span class="line">                .getPathMatcher(<span class="string">"glob:**/*.class"</span>);</span><br><span class="line"><span class="comment">// Walk the entire tree:</span></span><br><span class="line">        Files.walk(Paths.get(<span class="string">"."</span>))</span><br><span class="line">                .filter(matcher::matches)</span><br><span class="line">                .map(p -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> thisClass(Files.readAllBytes(p));</span><br><span class="line">                    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .filter(s -&gt; s.startsWith(<span class="string">"public:"</span>))</span><br><span class="line"><span class="comment">// .filter(s -&gt; s.indexOf('$') &gt;= 0)</span></span><br><span class="line">                .map(s -&gt; s.split(<span class="string">":"</span>)[<span class="number">1</span>])</span><br><span class="line">                .filter(s -&gt; !s.startsWith(<span class="string">"enums."</span>))</span><br><span class="line">                .filter(s -&gt; s.contains(<span class="string">"."</span>))</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">onjava.ArrayShow</span><br><span class="line">onjava.atunit.AtUnit$TestMethods</span><br><span class="line">onjava.atunit.AtUnit</span><br><span class="line">onjava.atunit.ClassNameFinder</span><br><span class="line">onjava.atunit.Test</span><br><span class="line">onjava.atunit.TestObjectCleanup</span><br><span class="line">onjava.atunit.TestObjectCreate</span><br><span class="line">onjava.atunit.TestProperty</span><br><span class="line">onjava.BasicSupplier</span><br><span class="line">onjava.CollectionMethodDifferences</span><br><span class="line">onjava.ConvertTo</span><br><span class="line">onjava.Count$Boolean</span><br><span class="line">onjava.Count$Byte</span><br><span class="line">onjava.Count$Character</span><br><span class="line">onjava.Count$Double</span><br><span class="line">onjava.Count$Float</span><br><span class="line">onjava.Count$Integer</span><br><span class="line">onjava.Count$Long</span><br><span class="line">onjava.Count$Pboolean</span><br><span class="line">onjava.Count$Pbyte</span><br><span class="line">onjava.Count$Pchar</span><br><span class="line">onjava.Count$Pdouble</span><br><span class="line">onjava.Count$Pfloat</span><br><span class="line">onjava.Count$Pint</span><br><span class="line">onjava.Count$Plong</span><br><span class="line">onjava.Count$Pshort</span><br><span class="line">onjava.Count$Short</span><br><span class="line">onjava.Count</span><br><span class="line">onjava.CountingIntegerList</span><br><span class="line">onjava.CountMap</span><br><span class="line">onjava.Countries</span><br><span class="line">onjava.Enums</span><br><span class="line">onjava.FillMap</span><br><span class="line">onjava.HTMLColors</span><br><span class="line">onjava.MouseClick</span><br><span class="line">onjava.Nap</span><br><span class="line">onjava.Null</span><br><span class="line">onjava.Operations</span><br><span class="line">onjava.OSExecute</span><br><span class="line">onjava.OSExecuteException</span><br><span class="line">onjava.Pair</span><br><span class="line">onjava.ProcessFiles$Strategy</span><br><span class="line">onjava.ProcessFiles</span><br><span class="line">onjava.Rand$Boolean</span><br><span class="line">onjava.Rand$Byte</span><br><span class="line">onjava.Rand$Character</span><br><span class="line">onjava.Rand$Double</span><br><span class="line">onjava.Rand$Float</span><br><span class="line">onjava.Rand$Integer</span><br><span class="line">onjava.Rand$Long</span><br><span class="line">onjava.Rand$Pboolean</span><br><span class="line">onjava.Rand$Pbyte</span><br><span class="line">onjava.Rand$Pchar</span><br><span class="line">onjava.Rand$Pdouble</span><br><span class="line">onjava.Rand$Pfloat</span><br><span class="line">onjava.Rand$Pint</span><br><span class="line">onjava.Rand$Plong</span><br><span class="line">onjava.Rand$Pshort</span><br><span class="line">onjava.Rand$Short</span><br><span class="line">onjava.Rand$String</span><br><span class="line">onjava.Rand</span><br><span class="line">onjava.Range</span><br><span class="line">onjava.Repeat</span><br><span class="line">onjava.RmDir</span><br><span class="line">onjava.Sets</span><br><span class="line">onjava.Stack</span><br><span class="line">onjava.Suppliers</span><br><span class="line">onjava.TimedAbort</span><br><span class="line">onjava.Timer</span><br><span class="line">onjava.Tuple</span><br><span class="line">onjava.Tuple2</span><br><span class="line">onjava.Tuple3</span><br><span class="line">onjava.Tuple4</span><br><span class="line">onjava.Tuple5</span><br><span class="line">onjava.TypeCounter</span><br></pre></td></tr></table></figure><p> 虽然无法在这里介绍其中所有的细节，但是每个类文件都必须遵循一定的格式，而我已经尽力用有意义的字段来表示这些从 <strong>ByteArrayInputStream</strong> 中提取出来的数据片段。通过施加在输入流上的读操作，你能看出每个信息片的大小。例如每一个类的头 32 个 bit 总是一个 “神秘数字” <strong>0xcafebabe</strong>，而接下来的两个 <strong>short</strong> 值是版本信息。常量池包含了程序的常量，所以这是一个可变的值。接下来的 <strong>short</strong> 告诉我们这个常量池有多大，然后我们为其创建一个尺寸合适的数组。常量池中的每一个元素，其长度可能是固定式，也可能是可变的值，因此我们必须检查每一个常量的起始标记，然后才能知道该怎么做，这就是 switch 语句的工作。我们并不打算精确的分析类中所有的数据，仅仅是从文件的起始一步一步的走，直到取得我们所需的信息，因此你会发现，在这个过程中我们丢弃了大量的数据。关于类的信息都保存在 <strong>classNameTable</strong> 和 <strong>offsetTable</strong> 中。在读取常量池之后，就找到了 <strong>this_class</strong> 信息，这是 <strong>offsetTable</strong> 的一个坐标，通过它可以找到进入  <strong>classNameTable</strong> 的坐标，然后就可以得到我们所需的类的名字了。</p><p>现在让我们回到 <strong>AtUtil.java</strong> 中，process() 方法中拥有了类的名字，然后检查它是否包含“.”，如果有就表示该类定义于一个包中。没有包的类会被忽略。如果一个类在包中，那么我们就可以使用标准的类加载器通过 <code>Class.forName()</code>  将其加载进来。现在我们可以对这个类进行 <strong>@Unit</strong> 注解的分析工作了。</p><p>我们只需要关注三件事：首先是 <strong>@Test</strong> 方法，它们被保存在 <strong>TestMehtods</strong> 列表中，然后检查其是否具有 @TestObjectCreate 和 <strong>@TestObjectCleanup****</strong> 方法。从代码中可以看到，我们通过调用相应的方法来查询注解从而找到这些方法。</p><p>每找到一个 @Test 方法，就打印出来当前类的名字，于是观察者立刻就可以知道发生了什么。接下来开始执行测试，也就是打印出方法名，然后调用 createTestObject() （如果存在一个加了 @TestObjectCreate 注解的方法），或者调用默认构造器。一旦创建出来测试对象，如果调用其上的测试方法。如果测试的返回值为 boolean，就捕获该结果。如果测试方法没有返回值，那么就没有异常发生，我们就假设测试成功，反之，如果当 assert 失败或者有任何异常抛出的时候，就说明测试失败，这时将异常信息打印出来以显示错误的原因。如果有失败的测试发生，那么还要统计失败的次数，并将失败所属的类和方法加入到 failedTests 中，以便最后报告给用户。</p><!-- Summary --><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>注解是 Java 引入的一项非常受欢迎的补充，它提供了一种结构化，并且具有类型检查能力的新途径，从而使得你能够为代码中加入元数据，而且不会导致代码杂乱并难以阅读。使用注解能够帮助我们避免编写累赘的部署描述性文件，以及其他的生成文件。而 Javadoc 中的 @deprecated 被 @Deprecated 注解所替代的事实也说明，与注释性文字相比，注解绝对更适用于描述类相关的信息。</p><p>Java 提供了很少的内置注解。这意味着如果你在别处找不到可用的类库，那么就只能自己创建新的注解以及相应的处理器。通过将注解处理器链接到 javac，你可以一步完成编译新生成的文件，简化了构造过程。</p><p>API 的提供方和框架将会将注解作为他们工具的一部分。通过 @Unit 系统，我们可以想象，注解会极大的改变我们的 Java 编程体验。</p><!-- 分页 --><div style="page-break-after: always;"></div><p>[^3 ]: The Java designers coyly suggest that a mirror is where you find a reflection.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接口和抽象类提供了一种将接口与实现分离的更加结构化的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java编程思想-第二十章 泛型阅读笔记</title>
    <link href="http://yoursite.com/2020/06/28/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0%20%E6%B3%9B%E5%9E%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/06/28/Java编程思想-第二十章 泛型阅读笔记/</id>
    <published>2020-06-28T02:53:12.000Z</published>
    <updated>2020-06-29T06:23:02.363Z</updated>
    
    <content type="html"><![CDATA[<p>接口和抽象类提供了一种将接口与实现分离的更加结构化的方法。</p><a id="more"></a><p>[TOC]</p><!-- Generics --><h1 id="第二十章-泛型"><a href="#第二十章-泛型" class="headerlink" title="第二十章 泛型"></a>第二十章 泛型</h1><blockquote><p>普通的类和方法只能使用特定的类型：基本数据类型或类类型。如果编写的代码需要应用于多种类型，这种严苛的限制对代码的束缚就会很大。</p></blockquote><p>多态是一种面向对象思想的泛化机制。可以将方法的参数类型设为基类，这样的方法就可以接受任何派生类作为参数，包括暂时还不存在的类。这样的方法更通用，应用范围更广。在类内部也是如此，在任何使用特定类型的地方，基类意味着更大的灵活性。除了 <code>final</code> 类（或只提供私有构造函数的类）任何类型都可被扩展，所以大部分时候这种灵活性是自带的。</p><p>拘泥于单一的继承体系太过局限，因为只有继承体系中的对象才能适用基类作为参数的方法中。如果方法以接口而不是类作为参数，限制就宽松多了，只要实现了接口就可以。这给予调用方一种选项，通过调整现有的类来实现接口，满足方法参数要求。接口可以突破继承体系的限制。</p><p>即便是接口也还是有诸多限制。一旦指定了接口，它就要求我们的代码必须使用特定的接口。而我们希望编写更通用的代码，能够适用“非特定的类型”，而不是一个具体的接口或类。</p><p>这就是泛型的概念，是 Java 5 的重大变化之一。泛型实现了<em>参数化类型</em>，这样我们编写的组件（通常是集合）可以适用于多种类型。“泛型”这个术语的含义是“适用于很多类型”。编程语言中泛型出现的初衷是通过解耦类或方法与所使用的类型之间的约束，使得类或方法具备最宽泛的表达力。随后我们会发现 Java 中泛型的实现并没有那么“泛”，我们可能会质疑“泛型”这个词是否合适用来描述这一功能。</p><p>如果我们从未接触过参数化类型机制，我们会发现泛型对 Java 语言确实是个很有益的补充。在我们实例化一个类型参数时，编译器会负责转型并确保类型的正确性。这是一大进步。</p><p>然而，如果我们了解其他语言（例如 C++ ）的参数化机制，我们会发现，Java 泛型并不能满足所有的预期。使用别人创建好的泛型相对容易，但是创建自己的泛型时，就会遇到很多意料之外的麻烦。</p><p>这并不是说 Java 泛型毫无用处。在很多情况下，它可以使代码更直接更优雅。不过，如果我们见识过那种实现了更纯粹的泛型的编程语言，那么，Java 可能会令我们失望。本章会介绍 Java 泛型的优点与局限。我会解释 Java 的泛型是如何发展成现在这样的，希望能够帮助我们更有效地使用这个特性。</p><h3 id="与-C-的比较"><a href="#与-C-的比较" class="headerlink" title="与 C++ 的比较"></a>与 C++ 的比较</h3><p>Java 的设计者曾说过，这门语言的灵感主要来自 C++ 。尽管如此，学习 Java 时基本不用参考 C++ 。</p><p>但是，Java 中的泛型需要与 C++ 进行对比，理由有两个：首先，理解 C++ <em>模板</em>（泛型的主要灵感来源，包括基本语法）的某些特性，有助于理解泛型的基础理念。同时，非常重要的一点是，我们可以了解 Java 泛型的局限是什么，以及为什么会有这些局限。最终的目标是明确 Java 泛型的边界，让我们成为一个程序高手。只有知道了某个技术不能做什么，我们才能更好地做到所能做的（部分原因是，不必浪费时间在死胡同里）。</p><p>第二个原因是，在 Java 社区中，大家普遍对 C++ 模板有一种误解，而这种误解可能会令我们在理解泛型的意图时产生偏差。</p><p>因此，本章中会介绍少量 C++ 模板的例子，仅当它们确实可以加深理解时才会引入。</p><!-- Simple Generics --><h2 id="简单泛型"><a href="#简单泛型" class="headerlink" title="简单泛型"></a>简单泛型</h2><p>促成泛型出现的最主要的动机之一是为了创建<em>集合类</em>，参见 集合 章节。集合用于存放要使用到的对象。数组也是如此，不过集合比数组更加灵活，功能更丰富。几乎所有程序在运行过程中都会涉及到一组对象，因此集合是可复用性最高的类库之一。</p><p>我们先看一个只能持有单个对象的类。这个类可以明确指定其持有的对象的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Holder1.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Automobile</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Automobile a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder1</span><span class="params">(Automobile a)</span> </span>&#123; <span class="keyword">this</span>.a = a; &#125;</span><br><span class="line">    <span class="function">Automobile <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类的可复用性不高，它无法持有其他类型的对象。我们可不希望为碰到的每个类型都编写一个新的类。</p><p>在 Java 5 之前，我们可以让这个类直接持有 <code>Object</code> 类型的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ObjectHolder.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObjectHolder</span><span class="params">(Object a)</span> </span>&#123; <span class="keyword">this</span>.a = a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object a)</span> </span>&#123; <span class="keyword">this</span>.a = a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ObjectHolder h2 = <span class="keyword">new</span> ObjectHolder(<span class="keyword">new</span> Automobile());</span><br><span class="line">        Automobile a = (Automobile)h2.get();</span><br><span class="line">        h2.set(<span class="string">"Not an Automobile"</span>);</span><br><span class="line">        String s = (String)h2.get();</span><br><span class="line">        h2.set(<span class="number">1</span>); <span class="comment">// 自动装箱为 Integer</span></span><br><span class="line">        Integer x = (Integer)h2.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，<code>ObjectHolder</code> 可以持有任何类型的对象，在上面的示例中，一个 <code>ObjectHolder</code> 先后持有了三种不同类型的对象。</p><p>一个集合中存储多种不同类型的对象的情况很少见，通常而言，我们只会用集合存储同一种类型的对象。泛型的主要目的之一就是用来约定集合要存储什么类型的对象，并且通过编译器确保规约得以满足。</p><p>因此，与其使用 <code>Object</code> ，我们更希望先指定一个类型占位符，稍后再决定具体使用什么类型。要达到这个目的，需要使用<em>类型参数</em>，用尖括号括住，放在类名后面。然后在使用这个类时，再用实际的类型替换此类型参数。在下面的例子中，<code>T</code> 就是类型参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericHolder.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericHolder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericHolder</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T a)</span> </span>&#123; <span class="keyword">this</span>.a = a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericHolder&lt;Automobile&gt; h3 = <span class="keyword">new</span> GenericHolder&lt;Automobile&gt;();</span><br><span class="line">        h3.set(<span class="keyword">new</span> Automobile()); <span class="comment">// 此处有类型校验</span></span><br><span class="line">        Automobile a = h3.get();  <span class="comment">// 无需类型转换</span></span><br><span class="line">        <span class="comment">//- h3.set("Not an Automobile"); // 报错</span></span><br><span class="line">        <span class="comment">//- h3.set(1);  // 报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 <code>GenericHolder</code> 对象时，必须指明要持有的对象的类型，将其置于尖括号内，就像 <code>main()</code> 中那样使用。然后，我们就只能在 <code>GenericHolder</code> 中存储该类型（或其子类，因为多态与泛型不冲突）的对象了。当我们调用 <code>get()</code> 取值时，直接就是正确的类型。</p><p>这就是 Java 泛型的核心概念：我们只需告诉编译器要使用什么类型，剩下的细节交给它来处理。</p><p>我们可能注意到 <code>h3</code> 的定义非常繁复。在 <code>=</code> 左边有 <code>GenericHolder&lt;Automobile&gt;</code>, 右边又重复了一次。在 Java 5 中，这种写法被解释成“必要的”，但在 Java 7 中设计者修正了这个问题（新的简写语法随后成为备受欢迎的特性）。以下是简写的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Diamond.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bob</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Diamond</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericHolder&lt;Bob&gt; h3 = <span class="keyword">new</span> GenericHolder&lt;&gt;();</span><br><span class="line">        h3.set(<span class="keyword">new</span> Bob());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，在 <code>h3</code> 的定义处，<code>=</code> 右边的尖括号是空的（称为“钻石语法”），而不是重复左边的类型信息。在本书剩余部分都会使用这种语法。</p><p>一般来说，我们可以认为泛型和其他类型差不多，只不过它们碰巧有类型参数罢了。在使用泛型时，我们只需要指定它们的名称和类型参数列表即可。</p><h3 id="一个元组类库"><a href="#一个元组类库" class="headerlink" title="一个元组类库"></a>一个元组类库</h3><p>有时一个方法需要能返回多个对象。而 <strong>return</strong> 语句只能返回单个对象，解决方法就是创建一个对象，用它打包想要返回的多个对象。当然，可以在每次需要的时候，专门创建一个类来完成这样的工作。但是有了泛型，我们就可以一劳永逸。同时，还获得了编译时的类型安全。</p><p>这个概念称为<em>元组*，它是将一组对象直接打包存储于单一对象中。可以从该对象读取其中的元素，但不允许向其中存储新对象（这个概念也称为 *数据传输对象</em> 或 <em>信使</em> ）。</p><p>通常，元组可以具有任意长度，元组中的对象可以是不同类型的。不过，我们希望能够为每个对象指明类型，并且从元组中读取出来时，能够得到正确的类型。要处理不同长度的问题，我们需要创建多个不同的元组。下面是一个可以存储两个对象的元组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/Tuple2.java</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple2</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> A a1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> B a2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tuple2</span><span class="params">(A a, B b)</span> </span>&#123; a1 = a; a2 = b; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">rep</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> a1 + <span class="string">", "</span> + a2; &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"("</span> + rep() + <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数传入要存储的对象。这个元组隐式地保持了其中元素的次序。</p><p>初次阅读上面的代码时，我们可能认为这违反了 Java 编程的封装原则。<code>a1</code> 和 <code>a2</code> 应该声明为 <strong>private</strong>，然后提供 <code>getFirst()</code> 和 <code>getSecond()</code> 取值方法才对呀？考虑下这样做能提供的“安全性”是什么：元组的使用程序可以读取 <code>a1</code> 和 <code>a2</code> 然后对它们执行任何操作，但无法对 <code>a1</code> 和 <code>a2</code> 重新赋值。例子中的 <code>final</code> 可以实现同样的效果，并且更为简洁明了。</p><p>另一种设计思路是允许元组的用户给 <code>a1</code> 和 <code>a2</code> 重新赋值。然而，采用上例中的形式无疑更加安全，如果用户想存储不同的元素，就会强制他们创建新的 <code>Tuple2</code> 对象。</p><p>我们可以利用继承机制实现长度更长的元组。添加更多的类型参数就行了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/Tuple3.java</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple3</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>&gt; <span class="keyword">extends</span> <span class="title">Tuple2</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> C a3;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tuple3</span><span class="params">(A a, B b, C c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(a, b);</span><br><span class="line">        a3 = c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">rep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.rep() + <span class="string">", "</span> + a3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// onjava/Tuple4.java</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple4</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>, <span class="title">D</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">Tuple3</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> D a4;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tuple4</span><span class="params">(A a, B b, C c, D d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(a, b, c);</span><br><span class="line">        a4 = d;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">rep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.rep() + <span class="string">", "</span> + a4;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// onjava/Tuple5.java</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple5</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>, <span class="title">D</span>, <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">Tuple4</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>, <span class="title">D</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> E a5;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tuple5</span><span class="params">(A a, B b, C c, D d, E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(a, b, c, d);</span><br><span class="line">        a5 = e;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">rep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.rep() + <span class="string">", "</span> + a5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>演示需要，再定义两个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Amphibian.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Amphibian</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// generics/Vehicle.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>使用元组时，我们只需要定义一个长度适合的元组，将其作为返回值即可。注意下面例子中方法的返回类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/TupleTest.java</span></span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TupleTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Tuple2&lt;String, Integer&gt; <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 47 自动装箱为 Integer</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;&gt;(<span class="string">"hi"</span>, <span class="number">47</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> Tuple3&lt;Amphibian, String, Integer&gt; <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple3&lt;&gt;(<span class="keyword">new</span> Amphibian(), <span class="string">"hi"</span>, <span class="number">47</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> Tuple4&lt;Vehicle, Amphibian, String, Integer&gt; <span class="title">h</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple4&lt;&gt;(<span class="keyword">new</span> Vehicle(), <span class="keyword">new</span> Amphibian(), <span class="string">"hi"</span>, <span class="number">47</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> Tuple5&lt;Vehicle, Amphibian, String, Integer, Double&gt; <span class="title">k</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple5&lt;&gt;(<span class="keyword">new</span> Vehicle(), <span class="keyword">new</span> Amphibian(), <span class="string">"hi"</span>, <span class="number">47</span>, <span class="number">11.1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Tuple2&lt;String, Integer&gt; ttsi = f();</span><br><span class="line">        System.out.println(ttsi);</span><br><span class="line">        <span class="comment">// ttsi.a1 = "there"; // 编译错误，因为 final 不能重新赋值</span></span><br><span class="line">        System.out.println(g());</span><br><span class="line">        System.out.println(h());</span><br><span class="line">        System.out.println(k());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment"> (hi, 47)</span></span><br><span class="line"><span class="comment"> (Amphibian@1540e19d, hi, 47)</span></span><br><span class="line"><span class="comment"> (Vehicle@7f31245a, Amphibian@6d6f6e28, hi, 47)</span></span><br><span class="line"><span class="comment"> (Vehicle@330bedb4, Amphibian@2503dbd3, hi, 47, 11.1)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>有了泛型，我们可以很容易地创建元组，令其返回一组任意类型的对象。</p><p>通过 <code>ttsi.a1 = &quot;there&quot;</code> 语句的报错，我们可以看出，<strong>final</strong> 声明确实可以确保 <strong>public</strong> 字段在对象被构造出来之后就不能重新赋值了。</p><p>在上面的程序中，<code>new</code> 表达式有些啰嗦。本章稍后会介绍，如何利用 <em>泛型方法</em> 简化它们。</p><h3 id="一个堆栈类"><a href="#一个堆栈类" class="headerlink" title="一个堆栈类"></a>一个堆栈类</h3><p>接下来我们看一个稍微复杂一点的例子：堆栈。在 <a href="book/12-Collections.md">集合</a> 一章中，我们用 <code>LinkedList</code> 实现了 <code>onjava.Stack</code> 类。在那个例子中，<code>LinkedList</code> 本身已经具备了创建堆栈所需的方法。<code>Stack</code> 是通过两个泛型类 <code>Stack&lt;T&gt;</code> 和 <code>LinkedList&lt;T&gt;</code> 的组合来创建。我们可以看出，泛型只不过是一种类型罢了（稍后我们会看到一些例外的情况）。</p><p>这次我们不用 <code>LinkedList</code> 来实现自己的内部链式存储机制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/LinkedStack.java</span></span><br><span class="line"><span class="comment">// 用链式结构实现的堆栈</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedStack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">U</span>&gt; </span>&#123;</span><br><span class="line">        U item;</span><br><span class="line">        Node&lt;U&gt; next;</span><br><span class="line">    </span><br><span class="line">        Node() &#123; item = <span class="keyword">null</span>; next = <span class="keyword">null</span>; &#125;</span><br><span class="line">        </span><br><span class="line">        Node(U item, Node&lt;U&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> item == <span class="keyword">null</span> &amp;&amp; next == <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; top = <span class="keyword">new</span> Node&lt;&gt;();  <span class="comment">// 栈顶</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">        top = <span class="keyword">new</span> Node&lt;&gt;(item, top);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T result = top.item;</span><br><span class="line">        <span class="keyword">if</span> (!top.end()) &#123;</span><br><span class="line">            top = top.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedStack&lt;String&gt; lss = <span class="keyword">new</span> LinkedStack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : <span class="string">"Phasers on stun!"</span>.split(<span class="string">" "</span>)) &#123;</span><br><span class="line">            lss.push(s);</span><br><span class="line">        &#125;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span> ((s = lss.pop()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stun!</span><br><span class="line">on</span><br><span class="line">Phasers</span><br></pre></td></tr></table></figure><p>内部类 <code>Node</code> 也是一个泛型，它拥有自己的类型参数。</p><p>这个例子使用了一个 <em>末端标识</em> (end sentinel) 来判断栈何时为空。这个末端标识是在构造 <code>LinkedStack</code> 时创建的。然后，每次调用 <code>push()</code> 就会创建一个 <code>Node&lt;T&gt;</code> 对象，并将其链接到前一个 <code>Node&lt;T&gt;</code> 对象。当我们调用 <code>pop()</code> 方法时，总是返回 <code>top.item</code>，然后丢弃当前 <code>top</code> 所指向的 <code>Node&lt;T&gt;</code>，并将 <code>top</code> 指向下一个 <code>Node&lt;T&gt;</code>，除非到达末端标识，这时就不能再移动 <code>top</code> 了。如果已经到达末端，程序还继续调用 <code>pop()</code> 方法，它只能得到 <code>null</code>，说明栈已经空了。</p><h3 id="RandomList"><a href="#RandomList" class="headerlink" title="RandomList"></a>RandomList</h3><p>作为容器的另一个例子，假设我们需要一个持有特定类型对象的列表，每次调用它的 <code>select()</code> 方法时都随机返回一个元素。如果希望这种列表可以适用于各种类型，就需要使用泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/RandomList.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(rand.nextInt(size()));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RandomList&lt;String&gt; rs = <span class="keyword">new</span> RandomList&lt;&gt;();</span><br><span class="line">        Arrays.stream(<span class="string">"The quick brown fox jumped over the lazy brown dog"</span>.split(<span class="string">" "</span>)).forEach(rs::add);</span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">11</span>).forEach(i -&gt; </span><br><span class="line">            System.out.print(rs.select() + <span class="string">" "</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brown over fox quick quick dog brown The brown lazy brown</span><br></pre></td></tr></table></figure><p><code>RandomList</code> 继承了 <code>ArrayList</code> 的所有方法。本例中只添加了 <code>select()</code> 这个方法。</p><!-- Generic Interfaces --><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>泛型也可以应用于接口。例如 <em>生成器*，这是一种专门负责创建对象的类。实际上，这是 *工厂方法</em> 设计模式的一种应用。不过，当使用生成器创建新的对象时，它不需要任何参数，而工厂方法一般需要参数。生成器无需额外的信息就知道如何创建新对象。</p><p>一般而言，一个生成器只定义一个方法，用于创建对象。例如 <code>java.util.function</code> 类库中的 <code>Supplier</code> 就是一个生成器，调用其 <code>get()</code> 获取对象。<code>get()</code> 是泛型方法，返回值为类型参数 <code>T</code>。</p><p>为了演示 <code>Supplier</code>，我们需要定义几个类。下面是个咖啡相关的继承体系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/coffee/Coffee.java</span></span><br><span class="line"><span class="keyword">package</span> generics.coffee;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getSimpleName() + <span class="string">" "</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// generics/coffee/Latte.java</span></span><br><span class="line"><span class="keyword">package</span> generics.coffee;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Latte</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// generics/coffee/Mocha.java</span></span><br><span class="line"><span class="keyword">package</span> generics.coffee;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mocha</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// generics/coffee/Cappuccino.java</span></span><br><span class="line"><span class="keyword">package</span> generics.coffee;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cappuccino</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// generics/coffee/Americano.java</span></span><br><span class="line"><span class="keyword">package</span> generics.coffee;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Americano</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// generics/coffee/Breve.java</span></span><br><span class="line"><span class="keyword">package</span> generics.coffee;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Breve</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>现在，我们可以编写一个类，实现 <code>Supplier&lt;Coffee&gt;</code> 接口，它能够随机生成不同类型的 <code>Coffee</code> 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/coffee/CoffeeSupplier.java</span></span><br><span class="line"><span class="comment">// &#123;java generics.coffee.CoffeeSupplier&#125;</span></span><br><span class="line"><span class="keyword">package</span> generics.coffee;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeSupplier</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">Coffee</span>&gt;, <span class="title">Iterable</span>&lt;<span class="title">Coffee</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] types = &#123; Latte.class, Mocha.class, </span><br><span class="line">        Cappuccino.class, Americano.class, Breve.class &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CoffeeSupplier</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// For iteration:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CoffeeSupplier</span><span class="params">(<span class="keyword">int</span> sz)</span> </span>&#123; size = sz; &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Coffee <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Coffee) types[rand.nextInt(types.length)].newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CoffeeIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Coffee</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = size;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> count &gt; <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Coffee <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            count--;</span><br><span class="line">            <span class="keyword">return</span> CoffeeSupplier.<span class="keyword">this</span>.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Coffee&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CoffeeIterator();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream.generate(<span class="keyword">new</span> CoffeeSupplier())</span><br><span class="line">              .limit(<span class="number">5</span>)</span><br><span class="line">              .forEach(System.out::println);</span><br><span class="line">        <span class="keyword">for</span> (Coffee c : <span class="keyword">new</span> CoffeeSupplier(<span class="number">5</span>)) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Americano <span class="number">0</span></span><br><span class="line">Latte <span class="number">1</span></span><br><span class="line">Americano <span class="number">2</span></span><br><span class="line">Mocha <span class="number">3</span></span><br><span class="line">Mocha <span class="number">4</span></span><br><span class="line">Breve <span class="number">5</span></span><br><span class="line">Americano <span class="number">6</span></span><br><span class="line">Latte <span class="number">7</span></span><br><span class="line">Cappuccino <span class="number">8</span></span><br><span class="line">Cappuccino <span class="number">9</span></span><br></pre></td></tr></table></figure><p>参数化的 <code>Supplier</code> 接口确保 <code>get()</code> 返回值是参数的类型。<code>CoffeeSupplier</code> 同时还实现了 <code>Iterable</code> 接口，所以能用于 <em>for-in</em> 语句。不过，它还需要知道何时终止循环，这正是第二个构造函数的作用。</p><p>下面是另一个实现 <code>Supplier&lt;T&gt;</code> 接口的例子，它负责生成 Fibonacci 数列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Fibonacci.java</span></span><br><span class="line"><span class="comment">// Generate a Fibonacci sequence</span></span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fibonacci</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> fib(count++); &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> fib(n-<span class="number">2</span>) + fib(n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream.generate(<span class="keyword">new</span> Fibonacci())</span><br><span class="line">              .limit(<span class="number">18</span>)</span><br><span class="line">              .map(n -&gt; n + <span class="string">" "</span>)</span><br><span class="line">              .forEach(System.out::print);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span> <span class="number">610</span> <span class="number">987</span> <span class="number">1597</span> <span class="number">2584</span></span><br></pre></td></tr></table></figure><p>虽然我们在 <code>Fibonacci</code> 类的里里外外使用的都是 <code>int</code> 类型，但是其参数类型却是 <code>Integer</code>。这个例子引出了 Java 泛型的一个局限性：基本类型无法作为类型参数。不过 Java 5 具备自动装箱和拆箱的功能，可以很方便地在基本类型和相应的包装类之间进行转换。通过这个例子中 <code>Fibonacci</code> 类对 <code>int</code> 的使用，我们已经看到了这种效果。</p><p>如果还想更进一步，编写一个实现了 <code>Iterable</code> 的 <code>Fibnoacci</code> 生成器。我们的一个选择是重写这个类，令其实现 <code>Iterable</code> 接口。不过，我们并不是总能拥有源代码的控制权，并且，除非必须这么做，否则，我们也不愿意重写一个类。而且我们还有另一种选择，就是创建一个 <em>适配器</em> (Adapter) 来实现所需的接口，我们在前面介绍过这个设计模式。</p><p>有多种方法可以实现适配器。例如，可以通过继承来创建适配器类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/IterableFibonacci.java</span></span><br><span class="line"><span class="comment">// Adapt the Fibonacci class to make it Iterable</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IterableFibonacci</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Fibonacci</span> <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IterableFibonacci</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123; n = count; &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Integer&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> n &gt; <span class="number">0</span>; &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                n--;</span><br><span class="line">                <span class="keyword">return</span> IterableFibonacci.<span class="keyword">this</span>.get();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123; <span class="comment">// Not implemented</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : <span class="keyword">new</span> IterableFibonacci(<span class="number">18</span>))</span><br><span class="line">            System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span> <span class="number">610</span> <span class="number">987</span> <span class="number">1597</span> <span class="number">2584</span></span><br></pre></td></tr></table></figure><p>在 <em>for-in</em> 语句中使用 <code>IterableFibonacci</code>，必须在构造函数中提供一个边界值，这样 <code>hasNext()</code> 才知道何时返回 <strong>false</strong>，结束循环。</p><!-- Generic Methods --><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>到目前为止，我们已经研究了参数化整个类。其实还可以参数化类中的方法。类本身可能是泛型的，也可能不是，不过这与它的方法是否是泛型的并没有什么关系。</p><p>泛型方法独立于类而改变方法。作为准则，请“尽可能”使用泛型方法。通常将单个方法泛型化要比将整个类泛型化更清晰易懂。</p><p>如果方法是 <strong>static</strong> 的，则无法访问该类的泛型类型参数，因此，如果使用了泛型类型参数，则它必须是泛型方法。</p><p>要定义泛型方法，请将泛型参数列表放置在返回值之前，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericMethods.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMethods</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">        System.out.println(x.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericMethods gm = <span class="keyword">new</span> GenericMethods();</span><br><span class="line">        gm.f(<span class="string">""</span>);</span><br><span class="line">        gm.f(<span class="number">1</span>);</span><br><span class="line">        gm.f(<span class="number">1.0</span>);</span><br><span class="line">        gm.f(<span class="number">1.0F</span>);</span><br><span class="line">        gm.f(<span class="string">'c'</span>);</span><br><span class="line">        gm.f(gm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">java.lang.String</span></span><br><span class="line"><span class="comment">java.lang.Integer</span></span><br><span class="line"><span class="comment">java.lang.Double</span></span><br><span class="line"><span class="comment">java.lang.Float</span></span><br><span class="line"><span class="comment">java.lang.Character</span></span><br><span class="line"><span class="comment">GenericMethods</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>尽管可以同时对类及其方法进行参数化，但这里未将 <strong>GenericMethods</strong> 类参数化。只有方法 <code>f()</code> 具有类型参数，该参数由方法返回类型之前的参数列表指示。</p><p>对于泛型类，必须在实例化该类时指定类型参数。使用泛型方法时，通常不需要指定参数类型，因为编译器会找出这些类型。 这称为 <em>类型参数推断</em>。因此，对 <code>f()</code> 的调用看起来像普通的方法调用，并且 <code>f()</code> 看起来像被重载了无数次一样。它甚至会接受 <strong>GenericMethods</strong> 类型的参数。</p><p>如果使用基本类型调用 <code>f()</code> ，自动装箱就开始起作用，自动将基本类型包装在它们对应的包装类型中。</p><!-- Varargs and Generic Methods --><h3 id="变长参数和泛型方法"><a href="#变长参数和泛型方法" class="headerlink" title="变长参数和泛型方法"></a>变长参数和泛型方法</h3><p>泛型方法和变长参数列表可以很好地共存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericVarargs.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericVarargs</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SafeVarargs</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">makeList</span><span class="params">(T... args)</span> </span>&#123;</span><br><span class="line">        List&lt;T&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (T item : args)</span><br><span class="line">            result.add(item);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; ls = makeList(<span class="string">"A"</span>);</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">        ls = makeList(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>);</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">        ls = makeList(</span><br><span class="line">                <span class="string">"ABCDEFFHIJKLMNOPQRSTUVWXYZ"</span>.split(<span class="string">""</span>));</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[A]</span></span><br><span class="line"><span class="comment">[A, B, C]</span></span><br><span class="line"><span class="comment">[A, B, C, D, E, F, F, H, I, J, K, L, M, N, O, P, Q, R,</span></span><br><span class="line"><span class="comment">S, T, U, V, W, X, Y, Z]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>此处显示的 <code>makeList()</code> 方法产生的功能与标准库的 <code>java.util.Arrays.asList()</code> 方法相同。</p><p><code>@SafeVarargs</code> 注解保证我们不会对变长参数列表进行任何修改，这是正确的，因为我们只从中读取。如果没有此注解，编译器将无法知道这些并会发出警告。</p><!-- A General-Purpose Supplier --><h3 id="一个泛型的-Supplier"><a href="#一个泛型的-Supplier" class="headerlink" title="一个泛型的 Supplier"></a>一个泛型的 Supplier</h3><p>这是一个为任意具有无参构造方法的类生成 <strong>Supplier</strong> 的类。为了减少键入，它还包括一个用于生成 <strong>BasicSupplier</strong> 的泛型方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/BasicSupplier.java</span></span><br><span class="line"><span class="comment">// Supplier from a class with a no-arg constructor</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicSupplier</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; type;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasicSupplier</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Assumes type is a public class:</span></span><br><span class="line">            <span class="keyword">return</span> type.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException |</span><br><span class="line">                IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Produce a default Supplier from a type token:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Supplier&lt;T&gt; <span class="title">create</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BasicSupplier&lt;&gt;(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此类提供了产生以下对象的基本实现：</p><ol><li><p>是 <strong>public</strong> 的。 因为 <strong>BasicSupplier</strong> 在单独的包中，所以相关的类必须具有 <strong>public</strong> 权限，而不仅仅是包级访问权限。</p></li><li><p>具有无参构造方法。要创建一个这样的 <strong>BasicSupplier</strong> 对象，请调用 <code>create()</code> 方法，并将要生成类型的类型令牌传递给它。通用的 <code>create()</code> 方法提供了 <code>BasicSupplier.create(MyType.class)</code> 这种较简洁的语法来代替较笨拙的 <code>new BasicSupplier &lt;MyType&gt;(MyType.class)</code>。</p></li></ol><p>例如，这是一个具有无参构造方法的简单类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/CountedObject.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountedObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">id</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"CountedObject "</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CountedObject</strong> 类可以跟踪自身创建了多少个实例，并通过 <code>toString()</code> 报告这些实例的数量。 <strong>BasicSupplier</strong> 可以轻松地为 <strong>CountedObject</strong> 创建 <strong>Supplier</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// generics/BasicSupplierDemo.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> onjava.BasicSupplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicSupplierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream.generate(</span><br><span class="line">                BasicSupplier.create(CountedObject.class))</span><br><span class="line">                .limit(<span class="number">5</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">CountedObject 0</span></span><br><span class="line"><span class="comment">CountedObject 1</span></span><br><span class="line"><span class="comment">CountedObject 2</span></span><br><span class="line"><span class="comment">CountedObject 3</span></span><br><span class="line"><span class="comment">CountedObject 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>泛型方法减少了产生 <strong>Supplier</strong> 对象所需的代码量。 Java 泛型强制传递 <strong>Class</strong> 对象，以便在 <code>create()</code> 方法中将其用于类型推断。</p><!-- Simplifying Tuple Use --><h3 id="简化元组的使用"><a href="#简化元组的使用" class="headerlink" title="简化元组的使用"></a>简化元组的使用</h3><p>使用类型参数推断和静态导入，我们将把早期的元组重写为更通用的库。在这里，我们使用重载的静态方法创建元组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/Tuple.java</span></span><br><span class="line"><span class="comment">// Tuple library using type argument inference</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;A, B&gt; <span class="function">Tuple2&lt;A, B&gt; <span class="title">tuple</span><span class="params">(A a, B b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;&gt;(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;A, B, C&gt; Tuple3&lt;A, B, C&gt;</span><br><span class="line">    tuple(A a, B b, C c) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple3&lt;&gt;(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;A, B, C, D&gt; Tuple4&lt;A, B, C, D&gt;</span><br><span class="line">    tuple(A a, B b, C c, D d) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple4&lt;&gt;(a, b, c, d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;A, B, C, D, E&gt;</span><br><span class="line">    <span class="function">Tuple5&lt;A, B, C, D, E&gt; <span class="title">tuple</span><span class="params">(A a, B b, C c, D d, E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple5&lt;&gt;(a, b, c, d, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们修改 <strong>TupleTest.java</strong> 来测试 <strong>Tuple.java</strong> :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/TupleTest2.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> onjava.Tuple2;</span><br><span class="line"><span class="keyword">import</span> onjava.Tuple3;</span><br><span class="line"><span class="keyword">import</span> onjava.Tuple4;</span><br><span class="line"><span class="keyword">import</span> onjava.Tuple5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> onjava.Tuple.tuple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TupleTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Tuple2&lt;String, Integer&gt; <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tuple(<span class="string">"hi"</span>, <span class="number">47</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Tuple2 <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tuple(<span class="string">"hi"</span>, <span class="number">47</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Tuple3&lt;Amphibian, String, Integer&gt; <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tuple(<span class="keyword">new</span> Amphibian(), <span class="string">"hi"</span>, <span class="number">47</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Tuple4&lt;Vehicle, Amphibian, String, Integer&gt; <span class="title">h</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tuple(</span><br><span class="line">                <span class="keyword">new</span> Vehicle(), <span class="keyword">new</span> Amphibian(), <span class="string">"hi"</span>, <span class="number">47</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Tuple5&lt;Vehicle, Amphibian,</span><br><span class="line">            String, Integer, Double&gt; k() &#123;</span><br><span class="line">        <span class="keyword">return</span> tuple(<span class="keyword">new</span> Vehicle(), <span class="keyword">new</span> Amphibian(),</span><br><span class="line">                <span class="string">"hi"</span>, <span class="number">47</span>, <span class="number">11.1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Tuple2&lt;String, Integer&gt; ttsi = f();</span><br><span class="line">        System.out.println(ttsi);</span><br><span class="line">        System.out.println(f2());</span><br><span class="line">        System.out.println(g());</span><br><span class="line">        System.out.println(h());</span><br><span class="line">        System.out.println(k());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">(hi, 47)</span></span><br><span class="line"><span class="comment">(hi, 47)</span></span><br><span class="line"><span class="comment">(Amphibian@14ae5a5, hi, 47)</span></span><br><span class="line"><span class="comment">(Vehicle@135fbaa4, Amphibian@45ee12a7, hi, 47)</span></span><br><span class="line"><span class="comment">(Vehicle@4b67cf4d, Amphibian@7ea987ac, hi, 47, 11.1)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>请注意，<code>f()</code> 返回一个参数化的 <strong>Tuple2</strong> 对象，而 <code>f2()</code> 返回一个未参数化的 <strong>Tuple2</strong> 对象。编译器不会在这里警告 <code>f2()</code> ，因为返回值未以参数化方式使用。从某种意义上说，它被“向上转型”为一个未参数化的 <strong>Tuple2</strong> 。 但是，如果尝试将 <code>f2()</code> 的结果放入到参数化的 <strong>Tuple2</strong> 中，则编译器将发出警告。</p><!-- A Set Utility --><h3 id="一个-Set-工具"><a href="#一个-Set-工具" class="headerlink" title="一个 Set 工具"></a>一个 Set 工具</h3><p>对于泛型方法的另一个示例，请考虑由 <strong>Set</strong> 表示的数学关系。这些被方便地定义为可用于所有不同类型的泛型方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/Sets.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sets</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Set&lt;T&gt; <span class="title">union</span><span class="params">(Set&lt;T&gt; a, Set&lt;T&gt; b)</span> </span>&#123;</span><br><span class="line">        Set&lt;T&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;(a);</span><br><span class="line">        result.addAll(b);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line">    <span class="function">Set&lt;T&gt; <span class="title">intersection</span><span class="params">(Set&lt;T&gt; a, Set&lt;T&gt; b)</span> </span>&#123;</span><br><span class="line">        Set&lt;T&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;(a);</span><br><span class="line">        result.retainAll(b);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Subtract subset from superset:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Set&lt;T&gt;</span><br><span class="line">    difference(Set&lt;T&gt; superset, Set&lt;T&gt; subset) &#123;</span><br><span class="line">        Set&lt;T&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;(superset);</span><br><span class="line">        result.removeAll(subset);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reflexive--everything not in the intersection:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Set&lt;T&gt; <span class="title">complement</span><span class="params">(Set&lt;T&gt; a, Set&lt;T&gt; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> difference(union(a, b), intersection(a, b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前三个方法通过将第一个参数的引用复制到新的 <strong>HashSet</strong> 对象中来复制第一个参数，因此不会直接修改参数集合。因此，返回值是一个新的 <strong>Set</strong> 对象。</p><p>这四种方法代表数学集合操作： <code>union()</code> 返回一个包含两个参数并集的 <strong>Set</strong> ， <code>intersection()</code> 返回一个包含两个参数集合交集的 <strong>Set</strong> ， <code>difference()</code> 从 <strong>superset</strong> 中减去 <strong>subset</strong> 的元素 ，而 <code>complement()</code> 返回所有不在交集中的元素的 <strong>Set</strong>。作为显示这些方法效果的简单示例的一部分，下面是一个包含不同水彩名称的 <strong>enum</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/watercolors/Watercolors.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> watercolors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Watercolors &#123;</span><br><span class="line">    ZINC, LEMON_YELLOW, MEDIUM_YELLOW, DEEP_YELLOW,</span><br><span class="line">    ORANGE, BRILLIANT_RED, CRIMSON, MAGENTA,</span><br><span class="line">    ROSE_MADDER, VIOLET, CERULEAN_BLUE_HUE,</span><br><span class="line">    PHTHALO_BLUE, ULTRAMARINE, COBALT_BLUE_HUE,</span><br><span class="line">    PERMANENT_GREEN, VIRIDIAN_HUE, SAP_GREEN,</span><br><span class="line">    YELLOW_OCHRE, BURNT_SIENNA, RAW_UMBER,</span><br><span class="line">    BURNT_UMBER, PAYNES_GRAY, IVORY_BLACK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了方便起见（不必全限定所有名称），将其静态导入到以下示例中。本示例使用 <strong>EnumSet</strong> 轻松从 <strong>enum</strong> 中创建 <strong>Set</strong> 。（可以在<a href="book/22-Enumerations.md">第二十二章 枚举</a>一章中了解有关 <strong>EnumSet</strong> 的更多信息。）在这里，静态方法 <code>EnumSet.range()</code> 要求提供所要在结果 <strong>Set</strong> 中创建的元素范围的第一个和最后一个元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/WatercolorSets.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> watercolors.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.EnumSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> watercolors.Watercolors.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> onjava.Sets.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WatercolorSets</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;Watercolors&gt; set1 =</span><br><span class="line">                EnumSet.range(BRILLIANT_RED, VIRIDIAN_HUE);</span><br><span class="line">        Set&lt;Watercolors&gt; set2 =</span><br><span class="line">                EnumSet.range(CERULEAN_BLUE_HUE, BURNT_UMBER);</span><br><span class="line">        System.out.println(<span class="string">"set1: "</span> + set1);</span><br><span class="line">        System.out.println(<span class="string">"set2: "</span> + set2);</span><br><span class="line">        System.out.println(</span><br><span class="line">                <span class="string">"union(set1, set2): "</span> + union(set1, set2));</span><br><span class="line">        Set&lt;Watercolors&gt; subset = intersection(set1, set2);</span><br><span class="line">        System.out.println(</span><br><span class="line">                <span class="string">"intersection(set1, set2): "</span> + subset);</span><br><span class="line">        System.out.println(<span class="string">"difference(set1, subset): "</span> +</span><br><span class="line">                difference(set1, subset));</span><br><span class="line">        System.out.println(<span class="string">"difference(set2, subset): "</span> +</span><br><span class="line">                difference(set2, subset));</span><br><span class="line">        System.out.println(<span class="string">"complement(set1, set2): "</span> +</span><br><span class="line">                complement(set1, set2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">set1: [BRILLIANT_RED, CRIMSON, MAGENTA, ROSE_MADDER,</span></span><br><span class="line"><span class="comment">VIOLET, CERULEAN_BLUE_HUE, PHTHALO_BLUE, ULTRAMARINE,</span></span><br><span class="line"><span class="comment">COBALT_BLUE_HUE, PERMANENT_GREEN, VIRIDIAN_HUE]</span></span><br><span class="line"><span class="comment">set2: [CERULEAN_BLUE_HUE, PHTHALO_BLUE, ULTRAMARINE,</span></span><br><span class="line"><span class="comment">COBALT_BLUE_HUE, PERMANENT_GREEN, VIRIDIAN_HUE,</span></span><br><span class="line"><span class="comment">SAP_GREEN, YELLOW_OCHRE, BURNT_SIENNA, RAW_UMBER,</span></span><br><span class="line"><span class="comment">BURNT_UMBER]</span></span><br><span class="line"><span class="comment">union(set1, set2): [BURNT_SIENNA, BRILLIANT_RED,</span></span><br><span class="line"><span class="comment">YELLOW_OCHRE, MAGENTA, SAP_GREEN, CERULEAN_BLUE_HUE,</span></span><br><span class="line"><span class="comment">ULTRAMARINE, VIRIDIAN_HUE, VIOLET, RAW_UMBER,</span></span><br><span class="line"><span class="comment">ROSE_MADDER, PERMANENT_GREEN, BURNT_UMBER,</span></span><br><span class="line"><span class="comment">PHTHALO_BLUE, CRIMSON, COBALT_BLUE_HUE]</span></span><br><span class="line"><span class="comment">intersection(set1, set2): [PERMANENT_GREEN,</span></span><br><span class="line"><span class="comment">CERULEAN_BLUE_HUE, ULTRAMARINE, VIRIDIAN_HUE,</span></span><br><span class="line"><span class="comment">PHTHALO_BLUE, COBALT_BLUE_HUE]</span></span><br><span class="line"><span class="comment">difference(set1, subset): [BRILLIANT_RED, MAGENTA,</span></span><br><span class="line"><span class="comment">VIOLET, CRIMSON, ROSE_MADDER]</span></span><br><span class="line"><span class="comment">difference(set2, subset): [BURNT_SIENNA, YELLOW_OCHRE,</span></span><br><span class="line"><span class="comment">BURNT_UMBER, SAP_GREEN, RAW_UMBER]</span></span><br><span class="line"><span class="comment">complement(set1, set2): [BURNT_SIENNA, BRILLIANT_RED,</span></span><br><span class="line"><span class="comment">YELLOW_OCHRE, MAGENTA, SAP_GREEN, VIOLET, RAW_UMBER,</span></span><br><span class="line"><span class="comment">ROSE_MADDER, BURNT_UMBER, CRIMSON]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>接下来的例子使用 <code>Sets.difference()</code> 方法来展示 <strong>java.util</strong> 包中各种 <strong>Collection</strong> 和 <strong>Map</strong> 类之间的方法差异：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/CollectionMethodDifferences.java</span></span><br><span class="line"><span class="comment">// &#123;java onjava.CollectionMethodDifferences&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionMethodDifferences</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Set&lt;String&gt; <span class="title">methodSet</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(type.getMethods())</span><br><span class="line">                .map(Method::getName)</span><br><span class="line">                .collect(Collectors.toCollection(TreeSet::<span class="keyword">new</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">interfaces</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"Interfaces in "</span> +</span><br><span class="line">                type.getSimpleName() + <span class="string">": "</span>);</span><br><span class="line">        System.out.println(</span><br><span class="line">                Arrays.stream(type.getInterfaces())</span><br><span class="line">                        .map(Class::getSimpleName)</span><br><span class="line">                        .collect(Collectors.toList()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Set&lt;String&gt; object = methodSet(Object.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        object.add(<span class="string">"clone"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">    difference(Class&lt;?&gt; superset, Class&lt;?&gt; subset) &#123;</span><br><span class="line">        System.out.print(superset.getSimpleName() +</span><br><span class="line">                <span class="string">" extends "</span> + subset.getSimpleName() +</span><br><span class="line">                <span class="string">", adds: "</span>);</span><br><span class="line">        Set&lt;String&gt; comp = Sets.difference(</span><br><span class="line">                methodSet(superset), methodSet(subset));</span><br><span class="line">        comp.removeAll(object); <span class="comment">// Ignore 'Object' methods</span></span><br><span class="line">        System.out.println(comp);</span><br><span class="line">        interfaces(superset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Collection: "</span> +</span><br><span class="line">                methodSet(Collection.class));</span><br><span class="line">        interfaces(Collection.class);</span><br><span class="line">        difference(Set.class, Collection.class);</span><br><span class="line">        difference(HashSet.class, Set.class);</span><br><span class="line">        difference(LinkedHashSet.class, HashSet.class);</span><br><span class="line">        difference(TreeSet.class, Set.class);</span><br><span class="line">        difference(List.class, Collection.class);</span><br><span class="line">        difference(ArrayList.class, List.class);</span><br><span class="line">        difference(LinkedList.class, List.class);</span><br><span class="line">        difference(Queue.class, Collection.class);</span><br><span class="line">        difference(PriorityQueue.class, Queue.class);</span><br><span class="line">        System.out.println(<span class="string">"Map: "</span> + methodSet(Map.class));</span><br><span class="line">        difference(HashMap.class, Map.class);</span><br><span class="line">        difference(LinkedHashMap.class, HashMap.class);</span><br><span class="line">        difference(SortedMap.class, Map.class);</span><br><span class="line">        difference(TreeMap.class, Map.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Collection: [add, addAll, clear, contains, containsAll,</span></span><br><span class="line"><span class="comment">equals, forEach, hashCode, isEmpty, iterator,</span></span><br><span class="line"><span class="comment">parallelStream, remove, removeAll, removeIf, retainAll,</span></span><br><span class="line"><span class="comment">size, spliterator, stream, toArray]</span></span><br><span class="line"><span class="comment">Interfaces in Collection: [Iterable]</span></span><br><span class="line"><span class="comment">Set extends Collection, adds: []</span></span><br><span class="line"><span class="comment">Interfaces in Set: [Collection]</span></span><br><span class="line"><span class="comment">HashSet extends Set, adds: []</span></span><br><span class="line"><span class="comment">Interfaces in HashSet: [Set, Cloneable, Serializable]</span></span><br><span class="line"><span class="comment">LinkedHashSet extends HashSet, adds: []</span></span><br><span class="line"><span class="comment">Interfaces in LinkedHashSet: [Set, Cloneable,</span></span><br><span class="line"><span class="comment">Serializable]</span></span><br><span class="line"><span class="comment">TreeSet extends Set, adds: [headSet,</span></span><br><span class="line"><span class="comment">descendingIterator, descendingSet, pollLast, subSet,</span></span><br><span class="line"><span class="comment">floor, tailSet, ceiling, last, lower, comparator,</span></span><br><span class="line"><span class="comment">pollFirst, first, higher]</span></span><br><span class="line"><span class="comment">Interfaces in TreeSet: [NavigableSet, Cloneable,</span></span><br><span class="line"><span class="comment">Serializable]</span></span><br><span class="line"><span class="comment">List extends Collection, adds: [replaceAll, get,</span></span><br><span class="line"><span class="comment">indexOf, subList, set, sort, lastIndexOf, listIterator]</span></span><br><span class="line"><span class="comment">Interfaces in List: [Collection]</span></span><br><span class="line"><span class="comment">ArrayList extends List, adds: [trimToSize,</span></span><br><span class="line"><span class="comment">ensureCapacity]</span></span><br><span class="line"><span class="comment">Interfaces in ArrayList: [List, RandomAccess,</span></span><br><span class="line"><span class="comment">Cloneable, Serializable]</span></span><br><span class="line"><span class="comment">LinkedList extends List, adds: [offerFirst, poll,</span></span><br><span class="line"><span class="comment">getLast, offer, getFirst, removeFirst, element,</span></span><br><span class="line"><span class="comment">removeLastOccurrence, peekFirst, peekLast, push,</span></span><br><span class="line"><span class="comment">pollFirst, removeFirstOccurrence, descendingIterator,</span></span><br><span class="line"><span class="comment">pollLast, removeLast, pop, addLast, peek, offerLast,</span></span><br><span class="line"><span class="comment">addFirst]</span></span><br><span class="line"><span class="comment">Interfaces in LinkedList: [List, Deque, Cloneable,</span></span><br><span class="line"><span class="comment">Serializable]</span></span><br><span class="line"><span class="comment">Queue extends Collection, adds: [poll, peek, offer,</span></span><br><span class="line"><span class="comment">element]</span></span><br><span class="line"><span class="comment">Interfaces in Queue: [Collection]</span></span><br><span class="line"><span class="comment">PriorityQueue extends Queue, adds: [comparator]</span></span><br><span class="line"><span class="comment">Interfaces in PriorityQueue: [Serializable]</span></span><br><span class="line"><span class="comment">Map: [clear, compute, computeIfAbsent,</span></span><br><span class="line"><span class="comment">computeIfPresent, containsKey, containsValue, entrySet,</span></span><br><span class="line"><span class="comment">equals, forEach, get, getOrDefault, hashCode, isEmpty,</span></span><br><span class="line"><span class="comment">keySet, merge, put, putAll, putIfAbsent, remove,</span></span><br><span class="line"><span class="comment">replace, replaceAll, size, values]</span></span><br><span class="line"><span class="comment">HashMap extends Map, adds: []</span></span><br><span class="line"><span class="comment">Interfaces in HashMap: [Map, Cloneable, Serializable]</span></span><br><span class="line"><span class="comment">LinkedHashMap extends HashMap, adds: []</span></span><br><span class="line"><span class="comment">Interfaces in LinkedHashMap: [Map]</span></span><br><span class="line"><span class="comment">SortedMap extends Map, adds: [lastKey, subMap,</span></span><br><span class="line"><span class="comment">comparator, firstKey, headMap, tailMap]</span></span><br><span class="line"><span class="comment">Interfaces in SortedMap: [Map]</span></span><br><span class="line"><span class="comment">TreeMap extends Map, adds: [descendingKeySet,</span></span><br><span class="line"><span class="comment">navigableKeySet, higherEntry, higherKey, floorKey,</span></span><br><span class="line"><span class="comment">subMap, ceilingKey, pollLastEntry, firstKey, lowerKey,</span></span><br><span class="line"><span class="comment">headMap, tailMap, lowerEntry, ceilingEntry,</span></span><br><span class="line"><span class="comment">descendingMap, pollFirstEntry, lastKey, firstEntry,</span></span><br><span class="line"><span class="comment">floorEntry, comparator, lastEntry]</span></span><br><span class="line"><span class="comment">Interfaces in TreeMap: [NavigableMap, Cloneable,</span></span><br><span class="line"><span class="comment">Serializable]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在第十二章 <a href="book/12-Collections.md#本章小结">集合的本章小结</a> 部分将会用到这里的输出结果。</p><!-- Building Complex Models --><h2 id="构建复杂模型"><a href="#构建复杂模型" class="headerlink" title="构建复杂模型"></a>构建复杂模型</h2><p>泛型的一个重要好处是能够简单安全地创建复杂模型。例如，我们可以轻松地创建一个元组列表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/TupleList.java</span></span><br><span class="line"><span class="comment">// Combining generic types to make complex generic types</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> onjava.Tuple4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TupleList</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>, <span class="title">D</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">Tuple4</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>, <span class="title">D</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TupleList&lt;Vehicle, Amphibian, String, Integer&gt; tl =</span><br><span class="line">                <span class="keyword">new</span> TupleList&lt;&gt;();</span><br><span class="line">        tl.add(TupleTest2.h());</span><br><span class="line">        tl.add(TupleTest2.h());</span><br><span class="line">        tl.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">(Vehicle@7cca494b, Amphibian@7ba4f24f, hi, 47)</span></span><br><span class="line"><span class="comment">(Vehicle@3b9a45b3, Amphibian@7699a589, hi, 47)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这将产生一个功能强大的数据结构，而无需太多代码。</p><p>下面是第二个例子。每个类都是组成块，总体包含很多个块。在这里，该模型是一个具有过道，货架和产品的零售商店：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Store.java</span></span><br><span class="line"><span class="comment">// Building a complex model using generic collections</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> onjava.Suppliers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line"></span><br><span class="line">    Product(<span class="keyword">int</span> idNumber, String descr, <span class="keyword">double</span> price) &#123;</span><br><span class="line">        id = idNumber;</span><br><span class="line">        description = descr;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">        System.out.println(toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id + <span class="string">": "</span> + description +</span><br><span class="line">                <span class="string">", price: $"</span> + price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">priceChange</span><span class="params">(<span class="keyword">double</span> change)</span> </span>&#123;</span><br><span class="line">        price += change;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Supplier&lt;Product&gt; generator =</span><br><span class="line">            <span class="keyword">new</span> Supplier&lt;Product&gt;() &#123;</span><br><span class="line">                <span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Product <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> Product(rand.nextInt(<span class="number">1000</span>), <span class="string">"Test"</span>,</span><br><span class="line">                            Math.round(</span><br><span class="line">                                    rand.nextDouble() * <span class="number">1000.0</span>) + <span class="number">0.99</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shelf</span> <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">Product</span>&gt; </span>&#123;</span><br><span class="line">    Shelf(<span class="keyword">int</span> nProducts) &#123;</span><br><span class="line">        Suppliers.fill(<span class="keyword">this</span>, Product.generator, nProducts);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Aisle</span> <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">Shelf</span>&gt; </span>&#123;</span><br><span class="line">    Aisle(<span class="keyword">int</span> nShelves, <span class="keyword">int</span> nProducts) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nShelves; i++)</span><br><span class="line">            add(<span class="keyword">new</span> Shelf(nProducts));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckoutStand</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Office</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Store</span> <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">Aisle</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;CheckoutStand&gt; checkouts =</span><br><span class="line">            <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Office office = <span class="keyword">new</span> Office();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Store</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> nAisles, <span class="keyword">int</span> nShelves, <span class="keyword">int</span> nProducts)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nAisles; i++)</span><br><span class="line">            add(<span class="keyword">new</span> Aisle(nShelves, nProducts));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (Aisle a : <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">for</span> (Shelf s : a)</span><br><span class="line">                <span class="keyword">for</span> (Product p : s) &#123;</span><br><span class="line">                    result.append(p);</span><br><span class="line">                    result.append(<span class="string">"\n"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Store(<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output: (First 8 Lines)</span></span><br><span class="line"><span class="comment">258: Test, price: $400.99</span></span><br><span class="line"><span class="comment">861: Test, price: $160.99</span></span><br><span class="line"><span class="comment">868: Test, price: $417.99</span></span><br><span class="line"><span class="comment">207: Test, price: $268.99</span></span><br><span class="line"><span class="comment">551: Test, price: $114.99</span></span><br><span class="line"><span class="comment">278: Test, price: $804.99</span></span><br><span class="line"><span class="comment">520: Test, price: $554.99</span></span><br><span class="line"><span class="comment">140: Test, price: $530.99</span></span><br><span class="line"><span class="comment">                  ...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>Store.toString()</code> 显示了结果：尽管有复杂的层次结构，但多层的集合仍然是类型安全的和可管理的。令人印象深刻的是，组装这样的模型并不需要耗费过多精力。</p><p><strong>Shelf</strong> 使用 <code>Suppliers.fill()</code> 这个实用程序，该实用程序接受 <strong>Collection</strong> （第一个参数），并使用 <strong>Supplier</strong> （第二个参数），以元素的数量为 <strong>n</strong> （第三个参数）来填充它。 <strong>Suppliers</strong> 类将会在本章末尾定义，其中的方法都是在执行某种填充操作，并在本章的其他示例中使用。</p><!-- The Mystery of Erasure --><h2 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h2><p>当我们开始更深入地钻研泛型时，会发现有大量的东西初看起来是没有意义的。例如，尽管可以说  <code>ArrayList.class</code>，但不能说成 <code>ArrayList&lt;Integer&gt;.class</code>。考虑下面的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ErasedTypeEquivalence.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErasedTypeEquivalence</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class c1 = <span class="keyword">new</span> ArrayList&lt;String&gt;().getClass();</span><br><span class="line">        Class c2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">        System.out.println(c1 == c2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>ArrayList&lt;String&gt;</code> 和 <code>ArrayList&lt;Integer&gt;</code> 应该是不同的类型。不同的类型会有不同的行为。例如，如果尝试向 <code>ArrayList&lt;String&gt;</code> 中放入一个 <code>Integer</code>，所得到的行为（失败）和向 <code>ArrayList&lt;Integer&gt;</code> 中放入一个 <code>Integer</code> 所得到的行为（成功）完全不同。然而上面的程序认为它们是相同的类型。</p><p>下面的例子是对该谜题的补充：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/LostInformation.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Frob</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fnorkle</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quark</span>&lt;<span class="title">Q</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Particle</span>&lt;<span class="title">POSITION</span>, <span class="title">MOMENTUM</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LostInformation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Frob&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Map&lt;Frob, Fnorkle&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Quark&lt;Fnorkle&gt; quark = <span class="keyword">new</span> Quark&lt;&gt;();</span><br><span class="line">        Particle&lt;Long, Double&gt; p = <span class="keyword">new</span> Particle&lt;&gt;();</span><br><span class="line">        System.out.println(Arrays.toString(list.getClass().getTypeParameters()));</span><br><span class="line">        System.out.println(Arrays.toString(map.getClass().getTypeParameters()));</span><br><span class="line">        System.out.println(Arrays.toString(quark.getClass().getTypeParameters()));</span><br><span class="line">        System.out.println(Arrays.toString(p.getClass().getTypeParameters()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[E]</span></span><br><span class="line"><span class="comment">[K,V]</span></span><br><span class="line"><span class="comment">[Q]</span></span><br><span class="line"><span class="comment">[POSITION,MOMENTUM]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>根据 JDK 文档，<strong>Class.getTypeParameters()</strong> “返回一个 <strong>TypeVariable</strong> 对象数组，表示泛型声明中声明的类型参数…” 这暗示我们可以发现这些参数类型。但是正如上例中输出所示，我们只能看到用作参数占位符的标识符，这并非有用的信息。</p><p>残酷的现实是：</p><p>在泛型代码内部，无法获取任何有关泛型参数类型的信息。</p><p>因此，我们可以知道如类型参数标识符和泛型边界这些信息，但无法得知实际的类型参数从而用来创建特定的实例。如果我们曾是 C++ 程序员，那么这个事实会让我们很沮丧，在使用 Java 泛型工作时，它是必须处理的最基本的问题。</p><p>Java 泛型是使用擦除实现的。这意味着当我们在使用泛型时，任何具体的类型信息都被擦除了，我们唯一知道的就是我们在使用一个对象。因此，<code>List&lt;String&gt;</code> 和 <code>List&lt;Integer&gt;</code> 在运行时实际上是相同的类型。它们都被擦除成原生类型 <code>List</code>。</p><p>理解擦除并知道如何处理它，是我们在学习 Java 泛型时面临的最大障碍之一。这也是本节将要探讨的内容。</p><h3 id="C-的方式"><a href="#C-的方式" class="headerlink" title="C++ 的方式"></a>C++ 的方式</h3><p>下面是使用模版的 C++ 示例。我们会看到类型参数的语法十分相似，因为 Java 是受 C++ 启发的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Templates.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Manipulator</span> &#123;</span></span><br><span class="line">    T obj;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Manipulator(T x) &#123; obj = x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span> </span>&#123; obj.f(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasF</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"HasF::f()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HasF hf;</span><br><span class="line">    Manipulator&lt;HasF&gt; manipulator(hf);</span><br><span class="line">    manipulator.manipulate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">HasF::f()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>Manipulator</strong> 类存储了一个 <strong>T</strong> 类型的对象。<code>manipulate()</code> 方法会调用 <strong>obj</strong> 上的 <code>f()</code> 方法。它是如何知道类型参数 <strong>T</strong> 中存在 <code>f()</code> 方法的呢？C++ 编译器会在我们实例化模版时进行检查，所以在 <code>Manipulator&lt;HasF&gt;</code> 实例化的那一刻，它看到 <strong>HasF</strong> 中含有一个方法 <code>f()</code>。如果情况并非如此，我们就会得到一个编译期错误，保持类型安全。</p><p>用 C++ 编写这种代码很简单，因为当模版被实例化时，模版代码就知道模版参数的类型。Java 泛型就不同了。下面是 <strong>HasF</strong> 的 Java 版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/HasF.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HasF</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HasF.f()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们将示例的其余代码用 Java 实现，就不会通过编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Manipulation.java</span></span><br><span class="line"><span class="comment">// &#123;WillNotCompile&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manipulator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line">    </span><br><span class="line">    Manipulator(T x) &#123;</span><br><span class="line">        obj = x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Error: cannot find symbol: method f():</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obj.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manipulation</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HasF hf = <span class="keyword">new</span> HasF();</span><br><span class="line">        Manipulator&lt;HasF&gt; manipulator = <span class="keyword">new</span> Manipulator&lt;&gt;(hf);</span><br><span class="line">        manipulator.manipulate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为擦除，Java 编译器无法将 <code>manipulate()</code> 方法必须能调用 <strong>obj</strong> 的 <code>f()</code> 方法这一需求映射到 HasF 具有 <code>f()</code> 方法这个事实上。为了调用 <code>f()</code>，我们必须协助泛型类，给定泛型类一个边界，以此告诉编译器只能接受遵循这个边界的类型。这里重用了 <strong>extends</strong> 关键字。由于有了边界，下面的代码就能通过编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manipulator2</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HasF</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line"></span><br><span class="line">    Manipulator2(T x) &#123;</span><br><span class="line">        obj = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obj.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>边界 <code>&lt;T extends HasF&gt;</code> 声明 T 必须是 HasF 类型或其子类。如果情况确实如此，就可以安全地在 <strong>obj</strong> 上调用 <code>f()</code> 方法。</p><p>我们说泛型类型参数会擦除到它的第一个边界（可能有多个边界，稍后我们将看到）。我们还提到了类型参数的擦除。编译器实际上会把类型参数替换为它的擦除，就像上面的示例，<strong>T</strong> 擦除到了 <strong>HasF</strong>，就像在类的声明中用 <strong>HasF</strong> 替换了 <strong>T</strong> 一样。</p><p>我们可能正确地观察到了泛型在 <strong>Manipulator2.java</strong> 中没有贡献任何事。我们可以很轻松地自己去执行擦除，生成没有泛型的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Manipulator3.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manipulator3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HasF obj;</span><br><span class="line">    </span><br><span class="line">    Manipulator3(HasF x) &#123;</span><br><span class="line">        obj = x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obj.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这提出了很重要的一点：泛型只有在类型参数比某个具体类型（以及其子类）更加“泛化”——代码能跨多个类工作时才有用。因此，类型参数和它们在有用的泛型代码中的应用，通常比简单的类替换更加复杂。但是，不能因此认为使用 <code>&lt;T extends HasF&gt;</code> 形式就是有缺陷的。例如，如果某个类有一个返回 <strong>T</strong> 的方法，那么泛型就有所帮助，因为它们之后将返回确切的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ReturnGenericType.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnGenericType</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HasF</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line">    </span><br><span class="line">    ReturnGenericType(T x) &#123;</span><br><span class="line">        obj = x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们必须查看所有的代码，从而确定代码是否复杂到必须使用泛型的程度。</p><p>我们将在本章稍后看到有关边界的更多细节。</p><h3 id="迁移兼容性"><a href="#迁移兼容性" class="headerlink" title="迁移兼容性"></a>迁移兼容性</h3><p>为了减少潜在的关于擦除的困惑，我们必须清楚地认识到这不是一个语言特性。它是 Java 实现泛型的一种妥协，因为泛型不是 Java 语言出现时就有的，所以就有了这种妥协。它会使我们痛苦，因此我们需要尽早习惯它并了解为什么它会这样。</p><p>如果 Java 1.0 就含有泛型的话，那么这个特性就不会使用擦除来实现——它会使用具体化，保持参数类型为第一类实体，因此我们就能在类型参数上执行基于类型的语言操作和反射操作。本章稍后我们会看到，擦除减少了泛型的泛化性。泛型在 Java 中仍然是有用的，只是不如它们本来设想的那么有用，而原因就是擦除。</p><p>在基于擦除的实现中，泛型类型被当作第二类类型处理，即不能在某些重要的上下文使用泛型类型。泛型类型只有在静态类型检测期间才出现，在此之后，程序中的所有泛型类型都将被擦除，替换为它们的非泛型上界。例如， <code>List&lt;T&gt;</code> 这样的类型注解会被擦除为 <strong>List</strong>，普通的类型变量在未指定边界的情况下会被擦除为 <strong>Object</strong>。</p><p>擦除的核心动机是我们可以在泛化的客户端上使用非泛型的类库，反之亦然。这经常被称为“迁移兼容性”。在理想情况下，所有事物将在指定的某天被泛化。在现实中，即使程序员只编写泛型代码，他们也必须处理 Java 5 之前编写的非泛型类库。这些类库的作者可能从没想过要泛化他们的代码，或许他们可能刚刚开始接触泛型。</p><p>因此 Java 泛型不仅必须支持向后兼容性——现有的代码和类文件仍然合法，继续保持之前的含义——而且还必须支持迁移兼容性，使得类库能按照它们自己的步调变为泛型，当某个类库变为泛型时，不会破坏依赖于它的代码和应用。在确定了这个目标后，Java 设计者们和从事此问题相关工作的各个团队决策认为擦除是唯一可行的解决方案。擦除使得这种向泛型的迁移成为可能，允许非泛型的代码和泛型代码共存。</p><p>例如，假设一个应用使用了两个类库 <strong>X</strong> 和 <strong>Y</strong>，<strong>Y</strong> 使用了类库 <strong>Z</strong>。随着 Java 5 的出现，这个应用和这些类库的创建者最终可能希望迁移到泛型上。但是当进行迁移时，它们有着不同的动机和限制。为了实现迁移兼容性，每个类库与应用必须与其他所有的部分是否使用泛型无关。因此，它们不能探测其他类库是否使用了泛型。因此，某个特定的类库使用了泛型这样的证据必须被”擦除“。</p><p>如果没有某种类型的迁移途径，所有已经构建了很长时间的类库就需要与希望迁移到 Java 泛型上的开发者们说再见了。类库毫无争议是编程语言的一部分，对生产效率有着极大的影响，所以这种代码无法接受。擦除是否是最佳的或唯一的迁移途径，还待时间来证明。</p><h3 id="擦除的问题"><a href="#擦除的问题" class="headerlink" title="擦除的问题"></a>擦除的问题</h3><p>因此，擦除主要的正当理由是从非泛化代码到泛化代码的转变过程，以及在不破坏现有类库的情况下将泛型融入到语言中。擦除允许我们继续使用现有的非泛型客户端代码，直至客户端准备好用泛型重写这些代码。这是一个崇高的动机，因为它不会骤然破坏所有现有的代码。</p><p>擦除的代价是显著的。泛型不能用于显式地引用运行时类型的操作中，例如转型、<strong>instanceof</strong> 操作和 <strong>new</strong> 表达式。因为所有关于参数的类型信息都丢失了，当我们在编写泛型代码时，必须时刻提醒自己，我们只是看起来拥有有关参数的类型信息而已。</p><p>考虑如下的代码段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T var;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上去当我们创建一个 <strong>Foo</strong> 实例时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Foo&lt;Cat&gt; f = <span class="keyword">new</span> Foo&lt;&gt;();</span><br></pre></td></tr></table></figure><p><strong>class</strong> <strong>Foo</strong> 中的代码应该知道现在工作于 <strong>Cat</strong> 之上。泛型语法也在强烈暗示整个类中所有 T 出现的地方都被替换，就像在 C++ 中一样。但是事实并非如此，当我们在编写这个类的代码时，必须提醒自己：“不，这只是一个 <strong>Object</strong>“。</p><p>另外，擦除和迁移兼容性意味着，使用泛型并不是强制的，尽管我们可能希望这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ErasureAndInheritance.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericBase</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T element;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">        element = arg;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived1</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">GenericBase</span>&lt;<span class="title">T</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived2</span> <span class="keyword">extends</span> <span class="title">GenericBase</span> </span>&#123;&#125; <span class="comment">// No warning</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// class Derived3 extends GenericBase&lt;?&gt; &#123;&#125;</span></span><br><span class="line"><span class="comment">// Strange error:</span></span><br><span class="line"><span class="comment">// unexpected type</span></span><br><span class="line"><span class="comment">// required: class or interface without bounds</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErasureAndInteritance</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Derived2 d2 = <span class="keyword">new</span> Derived2();</span><br><span class="line">        Object obj = d2.get();</span><br><span class="line">        d2.set(obj); <span class="comment">// Warning here!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Derived2</strong> 继承自 <strong>GenericBase</strong>，但是没有任何类型参数，编译器没有发出任何警告。直到调用 <code>set()</code> 方法时才出现警告。</p><p>为了关闭警告，Java 提供了一个注解，我们可以在列表中看到它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br></pre></td></tr></table></figure><p>这个注解放置在产生警告的方法上，而不是整个类上。当我们要关闭警告时，最好尽可能地“聚焦”，这样就不会因为过于宽泛地关闭警告，而导致意外地遮蔽掉真正的问题。</p><p>可以推断，<strong>Derived3</strong> 产生的错误意味着编译器期望得到一个原生基类。</p><p>当我们希望将类型参数不仅仅当作 Object 处理时，就需要付出额外努力来管理边界，并且与在 C++、Ada 和 Eiffel 这样的语言中获得参数化类型相比，我们需要付出多得多的努力来获得少得多的回报。这并不是说，对于大多数的编程问题而言，这些语言通常都会比 Java 更得心应手，只是说它们的参数化类型机制相比 Java 更灵活、更强大。</p><h3 id="边界处的动作"><a href="#边界处的动作" class="headerlink" title="边界处的动作"></a>边界处的动作</h3><p>因为擦除，我发现了泛型最令人困惑的方面是可以表示没有任何意义的事物。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ArrayMaker.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayMaker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; kind;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayMaker</span><span class="params">(Class&lt;T&gt; kind)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.kind = kind;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    T[] create(<span class="keyword">int</span> size) &#123;</span><br><span class="line">        <span class="keyword">return</span> (T[]) Array.newInstance(kind, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayMaker&lt;String&gt; stringMaker = <span class="keyword">new</span> ArrayMaker&lt;&gt;(String.class);</span><br><span class="line">        String[] stringArray = stringMaker.create(<span class="number">9</span>);</span><br><span class="line">        System.out.println(Arrays.toString(stringArray));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output</span></span><br><span class="line"><span class="comment">[null,null,null,null,null,null,null,null,null]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>即使 <strong>kind</strong> 被存储为 <code>Class&lt;T&gt;</code>，擦除也意味着它实际被存储为没有任何参数的 <strong>Class</strong>。因此，当我们在使用它时，例如创建数组，<code>Array.newInstance()</code> 实际上并未拥有 <strong>kind</strong> 所蕴含的类型信息。所以它不会产生具体的结果，因而必须转型，这会产生一条令我们无法满意的警告。</p><p>注意，对于在泛型中创建数组，使用 <code>Array.newInstance()</code> 是推荐的方式。</p><p>如果我们创建一个集合而不是数组，情况就不同了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ListMaker.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListMaker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ListMaker&lt;String&gt; stringMaker = <span class="keyword">new</span> ListMaker&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; stringList = stringMaker.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器不会给出任何警告，尽管我们知道（从擦除中）在 <code>create()</code> 内部的 <code>new ArrayList&lt;&gt;()</code> 中的 <code>&lt;T&gt;</code> 被移除了——在运行时，类内部没有任何 <code>&lt;T&gt;</code>，因此这看起来毫无意义。但是如果我们遵从这种思路，并将这个表达式改为 <code>new ArrayList()</code>，编译器就会发出警告。</p><p>本例中这么做真的毫无意义吗？如果在创建 <strong>List</strong> 的同时向其中放入一些对象呢，像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/FilledList.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilledList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    FilledList(Supplier&lt;T&gt; gen, <span class="keyword">int</span> size) &#123;</span><br><span class="line">        Suppliers.fill(<span class="keyword">this</span>, gen, size);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FilledList</span><span class="params">(T t, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> FilledList&lt;&gt;(<span class="string">"Hello"</span>, <span class="number">4</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">// Supplier version:</span></span><br><span class="line">        List&lt;Integer&gt; ilist = <span class="keyword">new</span> FilledList&lt;&gt;(() -&gt; <span class="number">47</span>, <span class="number">4</span>);</span><br><span class="line">        System.out.println(ilist);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[Hello,Hello,Hello,Hello]</span></span><br><span class="line"><span class="comment">[47,47,47,47]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>即使编译器无法得知 <code>add()</code> 中的 <strong>T</strong> 的任何信息，但它仍可以在编译期确保我们放入 <strong>FilledList</strong> 中的对象是 <strong>T</strong> 类型。因此，即使擦除移除了方法或类中的实际类型的信息，编译器仍可以确保方法或类中使用的类型的内部一致性。</p><p>因为擦除移除了方法体中的类型信息，所以在运行时的问题就是<em>边界</em>：即对象进入和离开方法的地点。这些正是编译器在编译期执行类型检查并插入转型代码的地点。</p><p>考虑如下这段非泛型示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/SimpleHolder.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleHolder holder = <span class="keyword">new</span> SimpleHolder();</span><br><span class="line">        holder.set(<span class="string">"Item"</span>);</span><br><span class="line">        String s = (String) holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用 <strong>javap -c SimpleHolder</strong> 反编译这个类，会得到如下内容（经过编辑）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(java.lang.Object)</span></span>;</span><br><span class="line">   <span class="number">0</span>: aload_0</span><br><span class="line">   <span class="number">1</span>: aload_1</span><br><span class="line">   2: putfield #2; // Field obj:Object;</span><br><span class="line">   <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> java.lang.<span class="function">Object <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="number">0</span>: aload_0</span><br><span class="line">   1: getfield #2; // Field obj:Object;</span><br><span class="line">   <span class="number">4</span>: areturn</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">   0: new #3; // class SimpleHolder</span><br><span class="line">   <span class="number">3</span>: dup</span><br><span class="line">   4: invokespecial #4; // Method "&lt;init&gt;":()V</span><br><span class="line">   <span class="number">7</span>: astore_1</span><br><span class="line">   <span class="number">8</span>: aload_1</span><br><span class="line">   9: ldc #5; // String Item</span><br><span class="line">   11: invokevirtual #6; // Method set:(Object;)V</span><br><span class="line">   <span class="number">14</span>: aload_1</span><br><span class="line">   15: invokevirtual #7; // Method get:()Object;</span><br><span class="line">   18: checkcast #8; // class java/lang/String</span><br><span class="line">   <span class="number">21</span>: astore_2</span><br><span class="line">   <span class="number">22</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p><code>set()</code> 和 <code>get()</code> 方法存储和产生值，转型在调用 <code>get()</code> 时接受检查。</p><p>现在将泛型融入上例代码中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericHolder2.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericHolder2</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericHolder2&lt;String&gt; holder =  <span class="keyword">new</span> GenericHolder2&lt;&gt;();</span><br><span class="line">        holder.set(<span class="string">"Item"</span>);</span><br><span class="line">        String s = holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 <code>get()</code> 返回后的转型消失了，但是我们还知道传递给 <code>set()</code> 的值在编译期会被检查。下面是相关的字节码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(java.lang.Object)</span></span>;</span><br><span class="line">   <span class="number">0</span>: aload_0</span><br><span class="line">   <span class="number">1</span>: aload_1</span><br><span class="line">   2: putfield #2; // Field obj:Object;</span><br><span class="line">   <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line">       </span><br><span class="line"><span class="keyword">public</span> java.lang.<span class="function">Object <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="number">0</span>: aload_0</span><br><span class="line">   1: getfield #2; // Field obj:Object;</span><br><span class="line">   <span class="number">4</span>: areturn</span><br><span class="line">       </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">   0: new #3; // class GenericHolder2</span><br><span class="line">   <span class="number">3</span>: dup</span><br><span class="line">   4: invokespecial #4; // Method "&lt;init&gt;":()V</span><br><span class="line">   <span class="number">7</span>: astore_1</span><br><span class="line">   <span class="number">8</span>: aload_1</span><br><span class="line">   9: ldc #5; // String Item</span><br><span class="line">   11: invokevirtual #6; // Method set:(Object;)V</span><br><span class="line">   <span class="number">14</span>: aload_1</span><br><span class="line">   15: invokevirtual #7; // Method get:()Object;</span><br><span class="line">   18: checkcast #8; // class java/lang/String</span><br><span class="line">   <span class="number">21</span>: astore_2</span><br><span class="line">   <span class="number">22</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>所产生的字节码是相同的。对进入 <code>set()</code> 的类型进行检查是不需要的，因为这将由编译器执行。而对 <code>get()</code> 返回的值进行转型仍然是需要的，只不过不需要我们来操作，它由编译器自动插入，这样我们就不用编写（阅读）杂乱的代码。</p><p><code>get()</code> 和 <code>set()</code> 产生了相同的字节码，这就告诉我们泛型的所有动作都发生在边界处——对入参的编译器检查和对返回值的转型。这有助于澄清对擦除的困惑，记住：“边界就是动作发生的地方”。</p><!-- Compensating for Erasure --><h2 id="补偿擦除"><a href="#补偿擦除" class="headerlink" title="补偿擦除"></a>补偿擦除</h2><p>因为擦除，我们将失去执行泛型代码中某些操作的能力。无法在运行时知道确切类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Erased.java</span></span><br><span class="line"><span class="comment">// &#123;WillNotCompile&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Erased</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// error: illegal generic type for instanceof</span></span><br><span class="line">        <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> T) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// error: unexpected type</span></span><br><span class="line">        T var = <span class="keyword">new</span> T();</span><br><span class="line">        <span class="comment">// error: generic array creation</span></span><br><span class="line">        T[] array = <span class="keyword">new</span> T[SIZE];</span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked cast</span></span><br><span class="line">        T[] array = (T[]) <span class="keyword">new</span> Object[SIZE];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时，我们可以对这些问题进行编程，但是有时必须通过引入类型标签来补偿擦除。这意味着为所需的类型显式传递一个 <strong>Class</strong> 对象，以在类型表达式中使用它。</p><p>例如，由于擦除了类型信息，因此在上一个程序中尝试使用 <strong>instanceof</strong> 将会失败。类型标签可以使用动态 <code>isInstance()</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ClassTypeCapture.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span> <span class="keyword">extends</span> <span class="title">Building</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassTypeCapture</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    Class&lt;T&gt; kind;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassTypeCapture</span><span class="params">(Class&lt;T&gt; kind)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.kind = kind;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">f</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> kind.isInstance(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassTypeCapture&lt;Building&gt; ctt1 =</span><br><span class="line">                <span class="keyword">new</span> ClassTypeCapture&lt;&gt;(Building.class);</span><br><span class="line">        System.out.println(ctt1.f(<span class="keyword">new</span> Building()));</span><br><span class="line">        System.out.println(ctt1.f(<span class="keyword">new</span> House()));</span><br><span class="line">        ClassTypeCapture&lt;House&gt; ctt2 =</span><br><span class="line">                <span class="keyword">new</span> ClassTypeCapture&lt;&gt;(House.class);</span><br><span class="line">        System.out.println(ctt2.f(<span class="keyword">new</span> Building()));</span><br><span class="line">        System.out.println(ctt2.f(<span class="keyword">new</span> House()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>编译器来保证类型标签与泛型参数相匹配。</p><!-- Creating Instances of Types --><h3 id="创建类型的实例"><a href="#创建类型的实例" class="headerlink" title="创建类型的实例"></a>创建类型的实例</h3><p>试图在 <strong>Erased.java</strong> 中 <code>new T()</code> 是行不通的，部分原因是由于擦除，部分原因是编译器无法验证 <strong>T</strong> 是否具有默认（无参）构造函数。但是在 C++ 中，此操作自然，直接且安全（在编译时检查）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/InstantiateGenericType.cpp</span></span><br><span class="line"><span class="comment">// C++, not Java!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">  T x; <span class="comment">// Create a field of type T</span></span><br><span class="line">  T* y; <span class="comment">// Pointer to T</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Initialize the pointer:</span></span><br><span class="line">  Foo() &#123; y = <span class="keyword">new</span> T(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Foo&lt;Bar&gt; fb;</span><br><span class="line">  Foo&lt;<span class="keyword">int</span>&gt; fi; <span class="comment">// ... and it works with primitives</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 中的解决方案是传入一个工厂对象，并使用该对象创建新实例。方便的工厂对象只是 <strong>Class</strong> 对象，因此，如果使用类型标记，则可以使用 <code>newInstance()</code> 创建该类型的新对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/InstantiateGenericType.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassAsFactory</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    Class&lt;T&gt; kind;</span><br><span class="line"></span><br><span class="line">    ClassAsFactory(Class&lt;T&gt; kind) &#123;</span><br><span class="line">        <span class="keyword">this</span>.kind = kind;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> kind.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException |</span><br><span class="line">                IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Employee"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstantiateGenericType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassAsFactory&lt;Employee&gt; fe =</span><br><span class="line">                <span class="keyword">new</span> ClassAsFactory&lt;&gt;(Employee.class);</span><br><span class="line">        System.out.println(fe.get());</span><br><span class="line">        ClassAsFactory&lt;Integer&gt; fi =</span><br><span class="line">                <span class="keyword">new</span> ClassAsFactory&lt;&gt;(Integer.class);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(fi.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Employee</span></span><br><span class="line"><span class="comment">java.lang.InstantiationException: java.lang.Integer</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这样可以编译，但对于 <code>ClassAsFactory&lt;Integer&gt;</code> 会失败，这是因为 <strong>Integer</strong> 没有无参构造函数。由于错误不是在编译时捕获的，因此语言创建者不赞成这种方法。他们建议使用显式工厂（<strong>Supplier</strong>）并约束类型，以便只有实现该工厂的类可以这样创建对象。这是创建工厂的两种不同方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/FactoryConstraint.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> onjava.Suppliers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegerFactory</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ++i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    Widget(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        id = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Widget "</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">Widget</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Widget <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Widget(++i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fudge</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n = count++;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Fudge "</span> + n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo2</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; x = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Foo2(Supplier&lt;T&gt; factory) &#123;</span><br><span class="line">        Suppliers.fill(x, factory, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryConstraint</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">                <span class="keyword">new</span> Foo2&lt;&gt;(<span class="keyword">new</span> IntegerFactory()));</span><br><span class="line">        System.out.println(</span><br><span class="line">                <span class="keyword">new</span> Foo2&lt;&gt;(<span class="keyword">new</span> Widget.Factory()));</span><br><span class="line">        System.out.println(</span><br><span class="line">                <span class="keyword">new</span> Foo2&lt;&gt;(Fudge::<span class="keyword">new</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment">[Widget 1, Widget 2, Widget 3, Widget 4, Widget 5]</span></span><br><span class="line"><span class="comment">[Fudge 1, Fudge 2, Fudge 3, Fudge 4, Fudge 5]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>IntegerFactory</strong> 本身就是通过实现 <code>Supplier&lt;Integer&gt;</code> 的工厂。 <strong>Widget</strong> 包含一个内部类，它是一个工厂。还要注意，<strong>Fudge</strong> 并没有做任何类似于工厂的操作，并且传递 <code>Fudge::new</code> 仍然会产生工厂行为，因为编译器将对函数方法 <code>::new</code> 的调用转换为对 <code>get()</code> 的调用。</p><p>另一种方法是模板方法设计模式。在以下示例中，<code>create()</code> 是模板方法，在子类中被重写以生成该类型的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/CreatorGeneric.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericWithCreate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> T element;</span><br><span class="line"></span><br><span class="line">    GenericWithCreate() &#123;</span><br><span class="line">        element = create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> T <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XCreator</span> <span class="keyword">extends</span> <span class="title">GenericWithCreate</span>&lt;<span class="title">X</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">X <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> X();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">                element.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatorGeneric</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        XCreator xc = <span class="keyword">new</span> XCreator();</span><br><span class="line">        xc.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">X</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>GenericWithCreate</strong> 包含 <code>element</code> 字段，并通过无参构造函数强制其初始化，该构造函数又调用抽象的 <code>create()</code> 方法。这种创建方式可以在子类中定义，同时建立 <strong>T</strong> 的类型。</p><!-- Arrays of Generics --><h3 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h3><p>正如在 <strong>Erased.java</strong> 中所看到的，我们无法创建泛型数组。通用解决方案是在试图创建泛型数组的时候使用 <strong>ArrayList</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ListOfGenerics.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListOfGenerics</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; array = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">        array.add(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做可以获得数组的行为，并且还具有泛型提供的编译时类型安全性。</p><p>有时，仍然会创建泛型类型的数组（例如， <strong>ArrayList</strong> 在内部使用数组）。可以通过使编译器满意的方式定义对数组的通用引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ArrayOfGenericReference.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayOfGenericReference</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Generic&lt;Integer&gt;[] gia;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器接受此操作而不产生警告。但是我们永远无法创建具有该确切类型（包括类型参数）的数组，因此有点令人困惑。由于所有数组，无论它们持有什么类型，都具有相同的结构（每个数组插槽的大小和数组布局），因此似乎可以创建一个 <strong>Object</strong> 数组并将其转换为所需的数组类型。实际上，这确实可以编译，但是会产生 <strong>ClassCastException</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ArrayOfGeneric.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayOfGeneric</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">static</span> Generic&lt;Integer&gt;[] gia;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            gia = (Generic&lt;Integer&gt;[]) <span class="keyword">new</span> Object[SIZE];</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Runtime type is the raw (erased) type:</span></span><br><span class="line">        gia = (Generic&lt;Integer&gt;[]) <span class="keyword">new</span> Generic[SIZE];</span><br><span class="line">        System.out.println(gia.getClass().getSimpleName());</span><br><span class="line">        gia[<span class="number">0</span>] = <span class="keyword">new</span> Generic&lt;&gt;();</span><br><span class="line">        <span class="comment">//- gia[1] = new Object(); // Compile-time error</span></span><br><span class="line">        <span class="comment">// Discovers type mismatch at compile time:</span></span><br><span class="line">        <span class="comment">//- gia[2] = new Generic&lt;Double&gt;();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[Ljava.lang.Object; cannot be cast to [LGeneric;</span></span><br><span class="line"><span class="comment">Generic[]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>问题在于数组会跟踪其实际类型，而该类型是在创建数组时建立的。因此，即使 <code>gia</code> 被强制转换为 <code>Generic&lt;Integer&gt;[]</code> ，该信息也仅在编译时存在（并且没有 <strong>@SuppressWarnings</strong> 注解，将会收到有关该强制转换的警告）。在运行时，它仍然是一个 <strong>Object</strong> 数组，这会引起问题。成功创建泛型类型的数组的唯一方法是创建一个已擦除类型的新数组，并将其强制转换。</p><p>让我们看一个更复杂的示例。考虑一个包装数组的简单泛型包装器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericArray.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericArray</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericArray</span><span class="params">(<span class="keyword">int</span> sz)</span> </span>&#123;</span><br><span class="line">        array = (T[]) <span class="keyword">new</span> Object[sz];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> index, T item)</span> </span>&#123;</span><br><span class="line">        array[index] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Method that exposes the underlying representation:</span></span><br><span class="line">    <span class="keyword">public</span> T[] rep() &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericArray&lt;Integer&gt; gai = <span class="keyword">new</span> GenericArray&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer[] ia = gai.rep();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// This is OK:</span></span><br><span class="line">        Object[] oa = gai.rep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[Ljava.lang.Object; cannot be cast to</span></span><br><span class="line"><span class="comment">[Ljava.lang.Integer;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>和以前一样，我们不能说 <code>T[] array = new T[sz]</code> ，所以我们创建了一个 <strong>Object</strong> 数组并将其强制转换。</p><p><code>rep()</code> 方法返回一个 <code>T[]</code> ，在主方法中它应该是 <code>gai</code> 的 <code>Integer[]</code>，但是如果调用它并尝试将结果转换为 <code>Integer[]</code> 引用，则会得到 <strong>ClassCastException</strong> ，这再次是因为实际的运行时类型为 <code>Object[]</code> 。</p><p>如果再注释掉 <strong>@SuppressWarnings</strong> 注解后编译 <strong>GenericArray.java</strong> ，则编译器会产生警告：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GenericArray.java uses unchecked or unsafe operations.</span><br><span class="line">Recompile with -Xlint:unchecked <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure><p>在这里，我们收到了一个警告，我们认为这是有关强制转换的。</p><p>但是要真正确定，请使用 <code>-Xlint：unchecked</code> 进行编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GenericArray.java:<span class="number">7</span>: warning: [unchecked] unchecked cast    array = (T[])<span class="keyword">new</span> Object[sz];                 ^  required: T[]  found:    Object[]  where T is a type-variable:    T extends Object declared in <span class="class"><span class="keyword">class</span> <span class="title">GenericArray</span> 1 <span class="title">warning</span></span></span><br></pre></td></tr></table></figure><p>确实是在抱怨那个强制转换。由于警告会变成噪音，因此，一旦我们确认预期会出现特定警告，我们可以做的最好的办法就是使用 <strong>@SuppressWarnings</strong> 将其关闭。这样，当警告确实出现时，我们将进行实际调查。</p><p>由于擦除，数组的运行时类型只能是 <code>Object[]</code> 。 如果我们立即将其转换为 <code>T[]</code> ，则在编译时会丢失数组的实际类型，并且编译器可能会错过一些潜在的错误检查。因此，最好在集合中使用 <code>Object[]</code> ，并在使用数组元素时向 <strong>T</strong> 添加强制类型转换。让我们来看看在 <strong>GenericArray.java</strong> 示例中会是怎么样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericArray2.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericArray2</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericArray2</span><span class="params">(<span class="keyword">int</span> sz)</span> </span>&#123;</span><br><span class="line">        array = <span class="keyword">new</span> Object[sz];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> index, T item)</span> </span>&#123;</span><br><span class="line">        array[index] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) array[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> T[] rep() &#123;</span><br><span class="line">        <span class="keyword">return</span> (T[]) array; <span class="comment">// Unchecked cast</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericArray2&lt;Integer&gt; gai =</span><br><span class="line">                <span class="keyword">new</span> GenericArray2&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">            gai.put(i, i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">            System.out.print(gai.get(i) + <span class="string">" "</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer[] ia = gai.rep();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"><span class="comment">java.lang.ClassCastException: [Ljava.lang.Object;</span></span><br><span class="line"><span class="comment">cannot be cast to [Ljava.lang.Integer;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>最初，看起来并没有太大不同，只是转换的位置移动了。没有 <strong>@SuppressWarnings</strong> 注解，仍然会收到“unchecked”警告。但是，内部表示现在是 <code>Object[]</code> 而不是 <code>T[]</code> 。 调用 <code>get()</code> 时，它将对象强制转换为 <strong>T</strong> ，实际上这是正确的类型，因此很安全。但是，如果调用 <code>rep()</code> ，它将再次尝试将 <code>Object[]</code> 强制转换为 <code>T[]</code> ，但仍然不正确，并在编译时生成警告，并在运行时生成异常。因此，无法破坏基础数组的类型，该基础数组只能是 <code>Object[]</code> 。在内部将数组视为 <code>Object[]</code> 而不是 <code>T[]</code> 的优点是，我们不太可能会忘记数组的运行时类型并意外地引入了bug，尽管大多数（也许是全部）此类错误会在运行时被迅速检测到。</p><p>对于新代码，请传入类型标记。在这种情况下，<strong>GenericArray</strong> 如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericArrayWithTypeToken.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericArrayWithTypeToken</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericArrayWithTypeToken</span><span class="params">(Class&lt;T&gt; type, <span class="keyword">int</span> sz)</span> </span>&#123;</span><br><span class="line">        array = (T[]) Array.newInstance(type, sz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> index, T item)</span> </span>&#123;</span><br><span class="line">        array[index] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Expose the underlying representation:</span></span><br><span class="line">    <span class="keyword">public</span> T[] rep() &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericArrayWithTypeToken&lt;Integer&gt; gai =</span><br><span class="line">                <span class="keyword">new</span> GenericArrayWithTypeToken&lt;&gt;(</span><br><span class="line">                        Integer.class, <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// This now works:</span></span><br><span class="line">        Integer[] ia = gai.rep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型标记 <strong>Class&lt;T&gt;</strong> 被传递到构造函数中以从擦除中恢复，因此尽管必须使用 <strong>@SuppressWarnings</strong> 关闭来自强制类型转换的警告，但我们仍可以创建所需的实际数组类型。一旦获得了实际的类型，就可以返回它并产生所需的结果，如在主方法中看到的那样。数组的运行时类型是确切的类型 <code>T[]</code> 。</p><p>不幸的是，如果查看 Java 标准库中的源代码，我们会发现到处都有从 <strong>Object</strong> 数组到参数化类型的转换。例如，这是<strong>ArrayList</strong> 中，复制一个 <strong>Collection</strong> 的构造函数，这里为了简化，去除了源码中对此不重要的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection c)</span> </span>&#123;</span><br><span class="line">  size = c.size();</span><br><span class="line">  elementData = (E[])<span class="keyword">new</span> Object[size];</span><br><span class="line">  c.toArray(elementData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们浏览 <strong>ArrayList.java</strong> 的代码，将会发现很多此类强制转换。当我们编译它时会发生什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Note: ArrayList.java uses unchecked or unsafe operations</span><br><span class="line">Note: Recompile with -Xlint:unchecked <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure><p>果然，标准库会产生很多警告。如果我们使用过 C 语言，尤其是使用 ANSI C 之前的语言，我们会记住警告的特殊效果：发现警告后，可以忽略它们。因此，除非程序员必须对其进行处理，否则最好不要从编译器发出任何类型的消息。</p><p>Neal Gafter（Java 5 的主要开发人员之一）在他的博客中[^2]指出，他在重写 Java 库时是很随意、马虎的，我们不应该像他那样做。Neal 还指出，他在不破坏现有接口的情况下无法修复某些 Java 库代码。因此，即使在 Java 库源代码中出现了一些习惯用法，它们也不一定是正确的做法。当查看库代码时，我们不能认为这就是要在自己代码中必须遵循的示例。</p><p>请注意，在 Java 文献中推荐使用类型标记技术，例如 Gilad Bracha 的论文《Generics in the Java Programming Language》[^3]，他指出：“例如，这种用法已广泛用于新的 API 中以处理注解。” 我发现此技术在人们对于舒适度的看法方面存在一些不一致之处；有些人强烈喜欢本章前面介绍的工厂方法。</p><!-- Bounds --><h2 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h2><p><em>边界</em>（bounds）在本章的前面进行了简要介绍。边界允许我们对泛型使用的参数类型施加约束。尽管这可以强制执行有关应用了泛型类型的规则，但潜在的更重要的效果是我们可以在绑定的类型中调用方法。</p><p>由于擦除会删除类型信息，因此唯一可用于无限制泛型参数的方法是那些 <strong>Object</strong> 可用的方法。但是，如果将该参数限制为某类型的子集，则可以调用该子集中的方法。为了应用约束，Java 泛型使用了 <code>extends</code> 关键字。</p><p>重要的是要理解，当用于限定泛型类型时，<code>extends</code> 的含义与通常的意义截然不同。此示例展示边界的基础应用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/BasicBounds.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">HasColor</span> </span>&#123;</span><br><span class="line">    java.awt.<span class="function">Color <span class="title">getColor</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithColor</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HasColor</span>&gt; </span>&#123;</span><br><span class="line">    T item;</span><br><span class="line"></span><br><span class="line">    WithColor(T item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">getItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The bound allows you to call a method:</span></span><br><span class="line">    java.awt.<span class="function">Color <span class="title">color</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.getColor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coord</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x, y, z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This fails. Class must be first, then interfaces:</span></span><br><span class="line"><span class="comment">// class WithColorCoord&lt;T extends HasColor &amp; Coord&gt; &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Multiple bounds:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithColorCoord</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Coord</span> &amp; <span class="title">HasColor</span>&gt; </span>&#123;</span><br><span class="line">    T item;</span><br><span class="line"></span><br><span class="line">    WithColorCoord(T item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">getItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    java.awt.<span class="function">Color <span class="title">color</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.getColor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getZ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Weight</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">weight</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// As with inheritance, you can have only one</span></span><br><span class="line"><span class="comment">// concrete class but multiple interfaces:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solid</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Coord</span> &amp; <span class="title">HasColor</span> &amp; <span class="title">Weight</span>&gt; </span>&#123;</span><br><span class="line">    T item;</span><br><span class="line"></span><br><span class="line">    Solid(T item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">getItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    java.awt.<span class="function">Color <span class="title">color</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.getColor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getZ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">weight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.weight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bounded</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">Coord</span> <span class="keyword">implements</span> <span class="title">HasColor</span>, <span class="title">Weight</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> java.awt.<span class="function">Color <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">weight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicBounds</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solid&lt;Bounded&gt; solid =</span><br><span class="line">                <span class="keyword">new</span> Solid&lt;&gt;(<span class="keyword">new</span> Bounded());</span><br><span class="line">        solid.color();</span><br><span class="line">        solid.getY();</span><br><span class="line">        solid.weight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可能会观察到 <strong>BasicBounds.java</strong> 中似乎包含一些冗余，它们可以通过继承来消除。在这里，每个继承级别还添加了边界约束：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/InheritBounds.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoldItem</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T item;</span><br><span class="line"></span><br><span class="line">    HoldItem(T item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">getItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithColor2</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HasColor</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">HoldItem</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    WithColor2(T item) &#123;</span><br><span class="line">        <span class="keyword">super</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    java.awt.<span class="function">Color <span class="title">color</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.getColor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithColorCoord2</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Coord</span> &amp; <span class="title">HasColor</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">WithColor2</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    WithColorCoord2(T item) &#123;</span><br><span class="line">        <span class="keyword">super</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getZ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solid2</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Coord</span> &amp; <span class="title">HasColor</span> &amp; <span class="title">Weight</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">WithColorCoord2</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    Solid2(T item) &#123;</span><br><span class="line">        <span class="keyword">super</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">weight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.weight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritBounds</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solid2&lt;Bounded&gt; solid2 =</span><br><span class="line">                <span class="keyword">new</span> Solid2&lt;&gt;(<span class="keyword">new</span> Bounded());</span><br><span class="line">        solid2.color();</span><br><span class="line">        solid2.getY();</span><br><span class="line">        solid2.weight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>HoldItem</strong> 拥有一个对象，因此此行为将继承到 <strong>WithColor2</strong> 中，这也需要其参数符合 <strong>HasColor</strong>。 <strong>WithColorCoord2</strong> 和 <strong>Solid2</strong> 进一步扩展了层次结构，并在每个级别添加了边界。现在，这些方法已被继承，并且在每个类中不再重复。</p><p>这是一个具有更多层次的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/EpicBattle.java</span></span><br><span class="line"><span class="comment">// Bounds in Java generics</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SuperPower</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">XRayVision</span> <span class="keyword">extends</span> <span class="title">SuperPower</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">seeThroughWalls</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SuperHearing</span> <span class="keyword">extends</span> <span class="title">SuperPower</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hearSubtleNoises</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SuperSmell</span> <span class="keyword">extends</span> <span class="title">SuperPower</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">trackBySmell</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperHero</span>&lt;<span class="title">POWER</span> <span class="keyword">extends</span> <span class="title">SuperPower</span>&gt; </span>&#123;</span><br><span class="line">    POWER power;</span><br><span class="line"></span><br><span class="line">    SuperHero(POWER power) &#123;</span><br><span class="line">        <span class="keyword">this</span>.power = power;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">POWER <span class="title">getPower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> power;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperSleuth</span>&lt;<span class="title">POWER</span> <span class="keyword">extends</span> <span class="title">XRayVision</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">SuperHero</span>&lt;<span class="title">POWER</span>&gt; </span>&#123;</span><br><span class="line">    SuperSleuth(POWER power) &#123;</span><br><span class="line">        <span class="keyword">super</span>(power);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">see</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        power.seeThroughWalls();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="class"><span class="title">CanineHero</span>&lt;<span class="title">POWER</span> <span class="keyword">extends</span> <span class="title">SuperHearing</span> &amp; <span class="title">SuperSmell</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">SuperHero</span>&lt;<span class="title">POWER</span>&gt; </span>&#123;</span><br><span class="line">    CanineHero(POWER power) &#123;</span><br><span class="line">        <span class="keyword">super</span>(power);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        power.hearSubtleNoises();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">smell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        power.trackBySmell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperHearSmell</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">SuperHearing</span>, <span class="title">SuperSmell</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hearSubtleNoises</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trackBySmell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DogPerson</span> <span class="keyword">extends</span> <span class="title">CanineHero</span>&lt;<span class="title">SuperHearSmell</span>&gt; </span>&#123;</span><br><span class="line">    DogPerson() &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> SuperHearSmell());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EpicBattle</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Bounds in generic methods:</span></span><br><span class="line">    <span class="keyword">static</span> &lt;POWER extends SuperHearing&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">useSuperHearing</span><span class="params">(SuperHero&lt;POWER&gt; hero)</span> </span>&#123;</span><br><span class="line">        hero.getPower().hearSubtleNoises();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;POWER extends SuperHearing &amp; SuperSmell&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">superFind</span><span class="params">(SuperHero&lt;POWER&gt; hero)</span> </span>&#123;</span><br><span class="line">        hero.getPower().hearSubtleNoises();</span><br><span class="line">        hero.getPower().trackBySmell();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DogPerson dogPerson = <span class="keyword">new</span> DogPerson();</span><br><span class="line">        useSuperHearing(dogPerson);</span><br><span class="line">        superFind(dogPerson);</span><br><span class="line">        <span class="comment">// You can do this:</span></span><br><span class="line">        List&lt;? extends SuperHearing&gt; audioPeople;</span><br><span class="line">        <span class="comment">// But you can't do this:</span></span><br><span class="line">        <span class="comment">// List&lt;? extends SuperHearing &amp; SuperSmell&gt; dogPs;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来将要研究的通配符将会把范围限制在单个类型。</p><!-- Wildcards --><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p>我们已经在 <a href="book/12-Collections.md">集合</a> 章节中看到了一些简单示例使用了通配符——在泛型参数表达式中的问号，在 <a href="book/19-Type-Information.md">类型信息</a> 一章中这种示例更多。本节将更深入地探讨这个特性。</p><p>我们的起始示例要展示数组的一种特殊行为：我们可以将派生类的数组赋值给基类的引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/CovariantArrays.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jonathan</span> <span class="keyword">extends</span> <span class="title">Apple</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantArrays</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Fruit[] fruit = <span class="keyword">new</span> Apple[<span class="number">10</span>];</span><br><span class="line">        fruit[<span class="number">0</span>] = <span class="keyword">new</span> Apple(); <span class="comment">// OK</span></span><br><span class="line">        fruit[<span class="number">1</span>] = <span class="keyword">new</span> Jonathan(); <span class="comment">// OK</span></span><br><span class="line">        <span class="comment">// Runtime type is Apple[], not Fruit[] or Orange[]:</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Compiler allows you to add Fruit:</span></span><br><span class="line">            fruit[<span class="number">0</span>] = <span class="keyword">new</span> Fruit(); <span class="comment">// ArrayStoreException</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Compiler allows you to add Oranges:</span></span><br><span class="line">            fruit[<span class="number">0</span>] = <span class="keyword">new</span> Orange(); <span class="comment">// ArrayStoreException</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">java.lang.ArrayStoreException: Fruit</span></span><br><span class="line"><span class="comment">java.lang.ArrayStoreException: Orange</span></span><br></pre></td></tr></table></figure><p><code>main()</code> 中的第一行创建了 <strong>Apple</strong> 数组，并赋值给一个 <strong>Fruit</strong> 数组引用。这是有意义的，因为 <strong>Apple</strong> 也是一种 <strong>Fruit</strong>，因此 <strong>Apple</strong> 数组应该也是一个 <strong>Fruit</strong> 数组。</p><p>但是，如果实际的数组类型是 <strong>Apple[]</strong>，我们可以在其中放置 <strong>Apple</strong> 或 <strong>Apple</strong> 的子类型，这在编译期和运行时都可以工作。但是我们也可以在数组中放置 <strong>Fruit</strong> 对象。这对编译器来说是有意义的，因为它有一个 <strong>Fruit[]</strong> 引用——它有什么理由不允许将 <strong>Fruit</strong> 对象或任何从 <strong>Fruit</strong> 继承出来的对象（比如 <strong>Orange</strong>），放置到这个数组中呢？因此在编译期，这是允许的。然而，运行时的数组机制知道它处理的是 <strong>Apple[]</strong>，因此会在向数组中放置异构类型时抛出异常。</p><p>向上转型用在这里不合适。我们真正在做的是将一个数组赋值给另一个数组。数组的行为是持有其他对象，这里只是因为我们能够向上转型而已，所以很明显，数组对象可以保留有关它们包含的对象类型的规则。看起来就像数组对它们持有的对象是有意识的，因此在编译期检查和运行时检查之间，我们不能滥用它们。</p><p>数组的这种赋值并不是那么可怕，因为在运行时我们可以发现插入了错误的类型。但是泛型的主要目标之一是将这种错误检测移到编译期。所以当我们试图使用泛型集合代替数组时，会发生什么呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/NonCovariantGenerics.java</span></span><br><span class="line"><span class="comment">// &#123;WillNotCompile&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonCovariantGenerics</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Compile Error: incompatible types:</span></span><br><span class="line">    List&lt;Fruit&gt; flist = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管我们在首次阅读这段代码时会认为“不能将一个 <strong>Apple</strong> 集合赋值给一个 <strong>Fruit</strong> 集合”。记住，泛型不仅仅是关于集合，它真正要表达的是“不能把一个涉及 <strong>Apple</strong> 的泛型赋值给一个涉及 <strong>Fruit</strong> 的泛型”。如果像在数组中的情况一样，编译器对代码的了解足够多，可以确定所涉及到的集合，那么它可能会留下一些余地。但是它不知道任何有关这方面的信息，因此它拒绝向上转型。然而实际上这也不是向上转型—— <strong>Apple</strong> 的 <strong>List</strong> 不是 <strong>Fruit</strong> 的 <strong>List</strong>。<strong>Apple</strong> 的 <strong>List</strong> 将持有 <strong>Apple</strong> 和 <strong>Apple</strong> 的子类型，<strong>Fruit</strong> 的 <strong>List</strong> 将持有任何类型的 <strong>Fruit</strong>。是的，这包括 <strong>Apple</strong>，但是它不是一个 <strong>Apple</strong> 的 <strong>List</strong>，它仍然是 <strong>Fruit</strong> 的 <strong>List</strong>。<strong>Apple</strong> 的 <strong>List</strong> 在类型上不等价于 <strong>Fruit</strong> 的 <strong>List</strong>，即使 <strong>Apple</strong> 是一种 <strong>Fruit</strong> 类型。</p><p>真正的问题是我们在讨论的集合类型，而不是集合持有对象的类型。与数组不同，泛型没有内建的协变类型。这是因为数组是完全在语言中定义的，因此可以具有编译期和运行时的内建检查，但是在使用泛型时，编译器和运行时系统不知道我们想用类型做什么，以及应该采用什么规则。</p><p>但是，有时我们想在两个类型间建立某种向上转型关系。通配符可以产生这种关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericsAndCovariance.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsAndCovariance</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Wildcards allow covariance:</span></span><br><span class="line">        List&lt;? extends Fruit&gt; flist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// Compile Error: can't add any type of object:</span></span><br><span class="line">        <span class="comment">// flist.add(new Apple());</span></span><br><span class="line">        <span class="comment">// flist.add(new Fruit());</span></span><br><span class="line">        <span class="comment">// flist.add(new Object());</span></span><br><span class="line">        flist.add(<span class="keyword">null</span>); <span class="comment">// Legal but uninteresting</span></span><br><span class="line">        <span class="comment">// We know it returns at least Fruit:</span></span><br><span class="line">        Fruit f = flist.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>flist</strong> 的类型现在是 <code>List&lt;? extends Fruit&gt;</code>，我们可以读作“一个具有任何从 <strong>Fruit</strong> 继承的类型的列表”。然而，这实际上并不意味着这个 <strong>List</strong> 将持有任何类型的 <strong>Fruit</strong>。通配符引用的是明确的类型，因此它意味着“某种 <strong>flist</strong> 引用没有指定的具体类型”。因此这个被赋值的 <strong>List</strong> 必须持有诸如 <strong>Fruit</strong> 或 <strong>Apple</strong> 这样的指定类型，但是为了向上转型为 <strong>Fruit</strong>，这个类型是什么没人在意。</p><p><strong>List</strong> 必须持有一种具体的 <strong>Fruit</strong> 或 <strong>Fruit</strong> 的子类型，但是如果我们不关心具体的类型是什么，那么我们能对这样的 <strong>List</strong> 做什么呢？如果不知道 <strong>List</strong> 中持有的对象是什么类型，我们怎能保证安全地向其中添加对象呢？就像在 <strong>CovariantArrays.java</strong> 中向上转型一样，我们不能，除非编译器而不是运行时系统可以阻止这种操作的发生。我们很快就会发现这个问题。</p><p>我们可能认为事情开始变得有点走极端了，因为现在我们甚至不能向刚刚声明过将持有 <strong>Apple</strong> 对象的 <strong>List</strong> 中放入一个 <strong>Apple</strong> 对象。是的，但编译器并不知道这一点。<code>List&lt;? extends Fruit&gt;</code> 可能合法地指向一个 <code>List&lt;Orange&gt;</code>。一旦执行这种类型的向上转型，我们就丢失了向其中传递任何对象的能力，甚至传递 <strong>Object</strong> 也不行。</p><p>另一方面，如果我们调用了一个返回 <strong>Fruit</strong> 的方法，则是安全的，因为我们知道这个 <strong>List</strong> 中的任何对象至少具有 <strong>Fruit</strong> 类型，因此编译器允许这么做。</p><h3 id="编译器有多聪明"><a href="#编译器有多聪明" class="headerlink" title="编译器有多聪明"></a>编译器有多聪明</h3><p>现在我们可能会猜想自己不能去调用任何接受参数的方法，但是考虑下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/CompilerIntelligence.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompilerIntelligence</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;? extends Fruit&gt; flist = Arrays.asList(<span class="keyword">new</span> Apple());</span><br><span class="line">        Apple a = (Apple) flist.get(<span class="number">0</span>); <span class="comment">// No warning</span></span><br><span class="line">        flist.contains(<span class="keyword">new</span> Apple()); <span class="comment">// Argument is 'Object'</span></span><br><span class="line">        flist.indexOf(<span class="keyword">new</span> Apple()); <span class="comment">// Argument is 'Object'</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里对 <code>contains()</code> 和 <code>indexOf()</code> 的调用接受 <strong>Apple</strong> 对象作为参数，执行没问题。这是否意味着编译器实际上会检查代码，以查看是否有某个特定的方法修改了它的对象？</p><p>通过查看 <strong>ArrayList</strong> 的文档，我们发现编译器没有那么聪明。尽管 <code>add()</code> 接受一个泛型参数类型的参数，但 <code>contains()</code> 和 <code>indexOf()</code> 接受的参数类型是 <strong>Object</strong>。因此当我们指定一个 <code>ArrayList&lt;? extends Fruit&gt;</code> 时，<code>add()</code> 的参数就变成了”<strong>? extends Fruit</strong>“。从这个描述中，编译器无法得知这里需要 <strong>Fruit</strong> 的哪个具体子类型，因此它不会接受任何类型的 <strong>Fruit</strong>。如果我们先把 <strong>Apple</strong> 向上转型为 <strong>Fruit</strong>，也没有关系——编译器仅仅会拒绝调用像 <code>add()</code> 这样参数列表中涉及通配符的方法。</p><p><code>contains()</code> 和 <code>indexOf()</code> 的参数类型是 <strong>Object</strong>，不涉及通配符，所以编译器允许调用它们。这意味着将由泛型类的设计者来决定哪些调用是“安全的”，并使用 <strong>Object</strong> 类作为它们的参数类型。为了禁止对类型中使用了通配符的方法调用，需要在参数列表中使用类型参数。</p><p>下面展示一个简单的 <strong>Holder</strong> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Holder.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">        value = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">        value = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o <span class="keyword">instanceof</span> Holder &amp;&amp; Objects.equals(value, ((Holder) o).value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Holder&lt;Apple&gt; apple = <span class="keyword">new</span> Holder&lt;&gt;(<span class="keyword">new</span> Apple());</span><br><span class="line">        Apple d = apple.get();</span><br><span class="line">        apple.set(d);</span><br><span class="line">        <span class="comment">// Holder&lt;Fruit&gt; fruit = apple; // Cannot upcast</span></span><br><span class="line">        Holder&lt;? extends Fruit&gt; fruit = apple; <span class="comment">// OK</span></span><br><span class="line">        Fruit p = fruit.get();</span><br><span class="line">        d = (Apple) fruit.get();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Orange c = (Orange) fruit.get(); <span class="comment">// No warning</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fruit.set(new Apple()); // Cannot call set()</span></span><br><span class="line">        <span class="comment">// fruit.set(new Fruit()); // Cannot call set()</span></span><br><span class="line">        System.out.println(fruit.equals(d)); <span class="comment">// OK</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output</span></span><br><span class="line"><span class="comment">java.lang.ClassCastException: Apple cannot be cast to Orange</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>Holder</strong> 有一个接受 <strong>T</strong> 类型对象的 <code>set()</code> 方法，一个返回 T 对象的 <code>get()</code> 方法和一个接受 Object 对象的 <code>equals()</code> 方法。正如我们所见，如果创建了一个 <code>Holder&lt;Apple&gt;</code>，就不能将其向上转型为 <code>Holder&lt;Fruit&gt;</code>，但是可以向上转型为 <code>Holder&lt;? extends Fruit&gt;</code>。如果调用 <code>get()</code>，只能返回一个 <strong>Fruit</strong>——这就是在给定“任何扩展自 <strong>Fruit</strong> 的对象”这一边界后，它所能知道的一切了。如果我们知道更多的信息，就可以将其转型到某种具体的 <strong>Fruit</strong> 而不会导致任何警告，但是存在得到 <strong>ClassCastException</strong> 的风险。<code>set()</code> 方法不能工作在 <strong>Apple</strong> 和 <strong>Fruit</strong> 上，因为 <code>set()</code> 的参数也是”<strong>? extends Fruit</strong>“，意味着它可以是任何事物，编译器无法验证“任何事物”的类型安全性。</p><p>但是，<code>equals()</code> 方法可以正常工作，因为它接受的参数是 <strong>Object</strong> 而不是 <strong>T</strong> 类型。因此，编译器只关注传递进来和要返回的对象类型。它不会分析代码，以查看是否执行了任何实际的写入和读取操作。</p><p>Java 7 引入了 <strong>java.util.Objects</strong> 库，使创建 <code>equals()</code> 和 <code>hashCode()</code> 方法变得更加容易，当然还有很多其他功能。<code>equals()</code> 方法的标准形式参考 <a href="book/Appendix-Understanding-equals-and-hashCode">附录：理解 equals 和 hashCode 方法</a> 一章。</p><h3 id="逆变"><a href="#逆变" class="headerlink" title="逆变"></a>逆变</h3><p>还可以走另外一条路，即使用超类型通配符。这里，可以声明通配符是由某个特定类的任何基类来界定的，方法是指定 <code>&lt;？super MyClass&gt;</code> ，或者甚至使用类型参数： <code>&lt;？super T&gt;</code>（尽管我们不能对泛型参数给出一个超类型边界；即不能声明 <code>&lt;T super MyClass&gt;</code> ）。这使得我们可以安全地传递一个类型对象到泛型类型中。因此，有了超类型通配符，就可以向 <strong>Collection</strong> 写入了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/SuperTypeWildcards.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperTypeWildcards</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeTo</span><span class="params">(List&lt;? <span class="keyword">super</span> Apple&gt; apples)</span> </span>&#123;</span><br><span class="line">        apples.add(<span class="keyword">new</span> Apple());</span><br><span class="line">        apples.add(<span class="keyword">new</span> Jonathan());</span><br><span class="line">        <span class="comment">// apples.add(new Fruit()); // Error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数 <strong>apples</strong> 是 <strong>Apple</strong> 的某种基类型的 <strong>List</strong>，这样我们就知道向其中添加 <strong>Apple</strong> 或 <strong>Apple</strong> 的子类型是安全的。但是因为 <strong>Apple</strong> 是下界，所以我们知道向这样的 <strong>List</strong> 中添加 <strong>Fruit</strong> 是不安全的，因为这将使这个 <strong>List</strong> 敞开口子，从而可以向其中添加非 <strong>Apple</strong> 类型的对象，而这是违反静态类型安全的。<br>下面的示例复习了一下逆变和通配符的的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericReading.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericReading</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;Apple&gt; apples = Arrays.asList(<span class="keyword">new</span> Apple());</span><br><span class="line">    <span class="keyword">static</span> List&lt;Fruit&gt; fruit = Arrays.asList(<span class="keyword">new</span> Fruit());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">readExact</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// A static method adapts to each call:</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Apple a = readExact(apples);</span><br><span class="line">        Fruit f = readExact(fruit);</span><br><span class="line">        f = readExact(apples);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// A class type is established</span></span><br><span class="line">    <span class="comment">// when the class is instantiated:</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Reader</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">readExact</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> list.get(<span class="number">0</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Reader&lt;Fruit&gt; fruitReader = <span class="keyword">new</span> Reader&lt;&gt;();</span><br><span class="line">        Fruit f = fruitReader.readExact(fruit);</span><br><span class="line">        <span class="comment">//- Fruit a = fruitReader.readExact(apples);</span></span><br><span class="line">        <span class="comment">// error: incompatible types: List&lt;Apple&gt;</span></span><br><span class="line">        <span class="comment">// cannot be converted to List&lt;Fruit&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantReader</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">readCovariant</span><span class="params">(List&lt;? extends T&gt; list)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CovariantReader&lt;Fruit&gt; fruitReader = <span class="keyword">new</span> CovariantReader&lt;&gt;();</span><br><span class="line">        Fruit f = fruitReader.readCovariant(fruit);</span><br><span class="line">        Fruit a = fruitReader.readCovariant(apples);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        f1(); </span><br><span class="line">        f2(); </span><br><span class="line">        f3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>readExact()</code> 方法使用了精确的类型。如果使用这个没有任何通配符的精确类型，就可以向 <strong>List</strong> 中写入和读取这个精确类型。另外，对于返回值，静态的泛型方法 <code>readExact()</code> 可以有效地“适应”每个方法调用，并能够从 <code>List&lt;Apple&gt;</code> 中返回一个 <strong>Apple</strong> ，从 <code>List&lt;Fruit&gt;</code> 中返回一个 <strong>Fruit</strong> ，就像在 <code>f1()</code> 中看到的那样。因此，如果可以摆脱静态泛型方法，那么在读取时就不需要协变类型了。<br>然而对于泛型类来说，当我们创建这个类的实例时，就要为这个类确定参数。就像在 <code>f2()</code> 中看到的，<strong>fruitReader</strong> 实例可以从 <code>List&lt;Fruit&gt;</code> 中读取一个 <strong>Fruit</strong> ，因为这就是它的确切类型。但是 <code>List&lt;Apple&gt;</code> 也应该产生 <strong>Fruit</strong> 对象，而 <strong>fruitReader</strong> 不允许这么做。<br>为了修正这个问题，<code>CovariantReader.readCovariant()</code> 方法将接受 <code>List&lt;？extends T&gt;</code> ，因此，从这个列表中读取一个 <strong>T</strong> 是安全的（我们知道在这个列表中的所有对象至少是一个 <strong>T</strong> ，并且可能是从 T 导出的某种对象）。在 <code>f3()</code> 中，我们可以看到现在可以从 <code>List&lt;Apple&gt;</code> 中读取 <strong>Fruit</strong> 了。</p><h3 id="无界通配符"><a href="#无界通配符" class="headerlink" title="无界通配符"></a>无界通配符</h3><p>无界通配符 <code>&lt;?&gt;</code> 看起来意味着“任何事物”，因此使用无界通配符好像等价于使用原生类型。事实上，编译器初看起来是支持这种判断的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/UnboundedWildcards1.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnboundedWildcards1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List list1;</span><br><span class="line">    <span class="keyword">static</span> List&lt;?&gt; list2;</span><br><span class="line">    <span class="keyword">static</span> List&lt;? extends Object&gt; list3;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign1</span><span class="params">(List list)</span> </span>&#123;</span><br><span class="line">        list1 = list;</span><br><span class="line">        list2 = list;</span><br><span class="line">        <span class="comment">//- list3 = list;</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked conversion</span></span><br><span class="line">        <span class="comment">// list3 = list;</span></span><br><span class="line">        <span class="comment">//         ^</span></span><br><span class="line">        <span class="comment">// required: List&lt;? extends Object&gt;</span></span><br><span class="line">        <span class="comment">// found:    List</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign2</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">        list1 = list;</span><br><span class="line">        list2 = list;</span><br><span class="line">        list3 = list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign3</span><span class="params">(List&lt;? extends Object&gt; list)</span> </span>&#123;</span><br><span class="line">        list1 = list;</span><br><span class="line">        list2 = list;</span><br><span class="line">        list3 = list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        assign1(<span class="keyword">new</span> ArrayList());</span><br><span class="line">        assign2(<span class="keyword">new</span> ArrayList());</span><br><span class="line">        <span class="comment">//- assign3(new ArrayList());</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked method invocation:</span></span><br><span class="line">        <span class="comment">// method assign3 in class UnboundedWildcards1</span></span><br><span class="line">        <span class="comment">// is applied to given types</span></span><br><span class="line">        <span class="comment">// assign3(new ArrayList());</span></span><br><span class="line">        <span class="comment">//        ^</span></span><br><span class="line">        <span class="comment">// required: List&lt;? extends Object&gt;</span></span><br><span class="line">        <span class="comment">// found: ArrayList</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked conversion</span></span><br><span class="line">        <span class="comment">// assign3(new ArrayList());</span></span><br><span class="line">        <span class="comment">//         ^</span></span><br><span class="line">        <span class="comment">// required: List&lt;? extends Object&gt;</span></span><br><span class="line">        <span class="comment">// found:    ArrayList</span></span><br><span class="line">        <span class="comment">// 2 warnings</span></span><br><span class="line">        assign1(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        assign2(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        assign3(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="comment">// Both forms are acceptable as List&lt;?&gt;:</span></span><br><span class="line">        List&lt;?&gt; wildList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        wildList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        assign1(wildList);</span><br><span class="line">        assign2(wildList);</span><br><span class="line">        assign3(wildList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有很多情况都和我们在这里看到的情况类似，即编译器很少关心使用的是原生类型还是 <code>&lt;?&gt;</code> 。在这些情况中，<code>&lt;?&gt;</code> 可以被认为是一种装饰，但是它仍旧是很有价值的，因为，实际上它是在声明：“我是想用 Java 的泛型来编写这段代码，我在这里并不是要用原生类型，但是在当前这种情况下，泛型参数可以持有任何类型。”<br>第二个示例展示了无界通配符的一个重要应用。当我们在处理多个泛型参数时，有时允许一个参数可以是任何类型，同时为其他参数确定某种特定类型的这种能力会显得很重要：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/UnboundedWildcards2.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnboundedWildcards2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Map map1;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;?,?&gt; map2;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String,?&gt; map3;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign1</span><span class="params">(Map map)</span> </span>&#123; </span><br><span class="line">        map1 = map; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign2</span><span class="params">(Map&lt;?,?&gt; map)</span> </span>&#123; </span><br><span class="line">        map2 = map; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign3</span><span class="params">(Map&lt;String,?&gt; map)</span> </span>&#123; </span><br><span class="line">        map3 = map; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        assign1(<span class="keyword">new</span> HashMap());</span><br><span class="line">        assign2(<span class="keyword">new</span> HashMap());</span><br><span class="line">        <span class="comment">//- assign3(new HashMap());</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked method invocation:</span></span><br><span class="line">        <span class="comment">// method assign3 in class UnboundedWildcards2</span></span><br><span class="line">        <span class="comment">// is applied to given types</span></span><br><span class="line">        <span class="comment">//     assign3(new HashMap());</span></span><br><span class="line">        <span class="comment">//            ^</span></span><br><span class="line">        <span class="comment">//   required: Map&lt;String,?&gt;</span></span><br><span class="line">        <span class="comment">//   found: HashMap</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked conversion</span></span><br><span class="line">        <span class="comment">//     assign3(new HashMap());</span></span><br><span class="line">        <span class="comment">//             ^</span></span><br><span class="line">        <span class="comment">//   required: Map&lt;String,?&gt;</span></span><br><span class="line">        <span class="comment">//   found:    HashMap</span></span><br><span class="line">        <span class="comment">// 2 warnings</span></span><br><span class="line">        assign1(<span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">        assign2(<span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">        assign3(<span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，当我们拥有的全都是无界通配符时，就像在 <code>Map&lt;?,?&gt;</code> 中看到的那样，编译器看起来就无法将其与原生 <strong>Map</strong> 区分开了。另外， <strong>UnboundedWildcards1.java</strong> 展示了编译器处理  <code>List&lt;?&gt;</code> 和 <code>List&lt;? extends Object&gt;</code> 是不同的。<br>令人困惑的是，编译器并非总是关注像 <code>List</code> 和 <code>List&lt;?&gt;</code> 之间的这种差异，因此它们看起来就像是相同的事物。事实上，因为泛型参数擦除到它的第一个边界，因此 <code>List&lt;?&gt;</code> 看起来等价于 <code>List&lt;Object&gt;</code> ，而 <strong>List</strong> 实际上也是 <code>List&lt;Object&gt;</code> ——除非这些语句都不为真。<strong>List</strong> 实际上表示“持有任何 <strong>Object</strong> 类型的原生 <strong>List ** ”，而 <code>List&lt;?&gt;</code> 表示“具有某种特定类型的非原生 **List</strong> ，只是我们不知道类型是什么。”<br>编译器何时才会关注原生类型和涉及无界通配符的类型之间的差异呢？下面的示例使用了前面定义的 <code>Holder&lt;T&gt;</code> 类，它包含接受 <strong>Holder</strong> 作为参数的各种方法，但是它们具有不同的形式：作为原生类型，具有具体的类型参数以及具有无界通配符参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Wildcards.java</span></span><br><span class="line"><span class="comment">// Exploring the meaning of wildcards</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wildcards</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Raw argument:</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rawArgs</span><span class="params">(Holder holder, Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//- holder.set(arg);</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked call to set(T)</span></span><br><span class="line">        <span class="comment">// as a member of the raw type Holder</span></span><br><span class="line">        <span class="comment">//     holder.set(arg);</span></span><br><span class="line">        <span class="comment">//               ^</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in class Holder</span></span><br><span class="line">        <span class="comment">// 1 warning</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Can't do this; don't have any 'T':</span></span><br><span class="line">        <span class="comment">// T t = holder.get();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// OK, but type information is lost:</span></span><br><span class="line">        Object obj = holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Like rawArgs(), but errors instead of warnings:</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unboundedArg</span><span class="params">(Holder&lt;?&gt; holder, Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//- holder.set(arg);</span></span><br><span class="line">        <span class="comment">// error: method set in class Holder&lt;T&gt;</span></span><br><span class="line">        <span class="comment">// cannot be applied to given types;</span></span><br><span class="line">        <span class="comment">//     holder.set(arg);</span></span><br><span class="line">        <span class="comment">//           ^</span></span><br><span class="line">        <span class="comment">//   required: CAP#1</span></span><br><span class="line">        <span class="comment">//   found: Object</span></span><br><span class="line">        <span class="comment">//   reason: argument mismatch;</span></span><br><span class="line">        <span class="comment">//     Object cannot be converted to CAP#1</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in class Holder</span></span><br><span class="line">        <span class="comment">//   where CAP#1 is a fresh type-variable:</span></span><br><span class="line">        <span class="comment">//     CAP#1 extends Object from capture of ?</span></span><br><span class="line">        <span class="comment">// 1 error</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Can't do this; don't have any 'T':</span></span><br><span class="line">        <span class="comment">// T t = holder.get();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// OK, but type information is lost:</span></span><br><span class="line">        Object obj = holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">exact1</span><span class="params">(Holder&lt;T&gt; holder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">exact2</span><span class="params">(Holder&lt;T&gt; holder, T arg)</span> </span>&#123;</span><br><span class="line">        holder.set(arg);</span><br><span class="line">        <span class="keyword">return</span> holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">wildSubtype</span><span class="params">(Holder&lt;? extends T&gt; holder, T arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//- holder.set(arg);</span></span><br><span class="line">        <span class="comment">// error: method set in class Holder&lt;T#2&gt;</span></span><br><span class="line">        <span class="comment">// cannot be applied to given types;</span></span><br><span class="line">        <span class="comment">//     holder.set(arg);</span></span><br><span class="line">        <span class="comment">//           ^</span></span><br><span class="line">        <span class="comment">//   required: CAP#1</span></span><br><span class="line">        <span class="comment">//   found: T#1</span></span><br><span class="line">        <span class="comment">//   reason: argument mismatch;</span></span><br><span class="line">        <span class="comment">//     T#1 cannot be converted to CAP#1</span></span><br><span class="line">        <span class="comment">//   where T#1,T#2 are type-variables:</span></span><br><span class="line">        <span class="comment">//     T#1 extends Object declared in method</span></span><br><span class="line">        <span class="comment">//     &lt;T#1&gt;wildSubtype(Holder&lt;? extends T#1&gt;,T#1)</span></span><br><span class="line">        <span class="comment">//     T#2 extends Object declared in class Holder</span></span><br><span class="line">        <span class="comment">//   where CAP#1 is a fresh type-variable:</span></span><br><span class="line">        <span class="comment">//     CAP#1 extends T#1 from</span></span><br><span class="line">        <span class="comment">//       capture of ? extends T#1</span></span><br><span class="line">        <span class="comment">// 1 error</span></span><br><span class="line">        <span class="keyword">return</span> holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">wildSupertype</span><span class="params">(Holder&lt;? <span class="keyword">super</span> T&gt; holder, T arg)</span> </span>&#123;</span><br><span class="line">        holder.set(arg);</span><br><span class="line">        <span class="comment">//- T t = holder.get();</span></span><br><span class="line">        <span class="comment">// error: incompatible types:</span></span><br><span class="line">        <span class="comment">// CAP#1 cannot be converted to T</span></span><br><span class="line">        <span class="comment">//     T t = holder.get();</span></span><br><span class="line">        <span class="comment">//                     ^</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in method</span></span><br><span class="line">        <span class="comment">//       &lt;T&gt;wildSupertype(Holder&lt;? super T&gt;,T)</span></span><br><span class="line">        <span class="comment">//   where CAP#1 is a fresh type-variable:</span></span><br><span class="line">        <span class="comment">//     CAP#1 extends Object super:</span></span><br><span class="line">        <span class="comment">//       T from capture of ? super T</span></span><br><span class="line">        <span class="comment">// 1 error</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// OK, but type information is lost:</span></span><br><span class="line">        Object obj = holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Holder raw = <span class="keyword">new</span> Holder&lt;&gt;();</span><br><span class="line">        <span class="comment">// Or:</span></span><br><span class="line">        raw = <span class="keyword">new</span> Holder();</span><br><span class="line">        Holder&lt;Long&gt; qualified = <span class="keyword">new</span> Holder&lt;&gt;();</span><br><span class="line">        Holder&lt;?&gt; unbounded = <span class="keyword">new</span> Holder&lt;&gt;();</span><br><span class="line">        Holder&lt;? extends Long&gt; bounded = <span class="keyword">new</span> Holder&lt;&gt;();</span><br><span class="line">        Long lng = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">        rawArgs(raw, lng);</span><br><span class="line">        rawArgs(qualified, lng);</span><br><span class="line">        rawArgs(unbounded, lng);</span><br><span class="line">        rawArgs(bounded, lng);</span><br><span class="line"></span><br><span class="line">        unboundedArg(raw, lng);</span><br><span class="line">        unboundedArg(qualified, lng);</span><br><span class="line">        unboundedArg(unbounded, lng);</span><br><span class="line">        unboundedArg(bounded, lng);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Object r1 = exact1(raw);</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked method invocation:</span></span><br><span class="line">        <span class="comment">// method exact1 in class Wildcards is applied</span></span><br><span class="line">        <span class="comment">// to given types</span></span><br><span class="line">        <span class="comment">//      Object r1 = exact1(raw);</span></span><br><span class="line">        <span class="comment">//                        ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;T&gt;</span></span><br><span class="line">        <span class="comment">//   found: Holder</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//     method &lt;T&gt;exact1(Holder&lt;T&gt;)</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked conversion</span></span><br><span class="line">        <span class="comment">//      Object r1 = exact1(raw);</span></span><br><span class="line">        <span class="comment">//                         ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;T&gt;</span></span><br><span class="line">        <span class="comment">//   found:    Holder</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//     method &lt;T&gt;exact1(Holder&lt;T&gt;)</span></span><br><span class="line">        <span class="comment">// 2 warnings</span></span><br><span class="line"></span><br><span class="line">        Long r2 = exact1(qualified);</span><br><span class="line">        Object r3 = exact1(unbounded); <span class="comment">// Must return Object</span></span><br><span class="line">        Long r4 = exact1(bounded);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Long r5 = exact2(raw, lng);</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked method invocation:</span></span><br><span class="line">        <span class="comment">// method exact2 in class Wildcards is</span></span><br><span class="line">        <span class="comment">// applied to given types</span></span><br><span class="line">        <span class="comment">//     Long r5 = exact2(raw, lng);</span></span><br><span class="line">        <span class="comment">//                     ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;T&gt;,T</span></span><br><span class="line">        <span class="comment">//   found: Holder,Long</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//       method &lt;T&gt;exact2(Holder&lt;T&gt;,T)</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked conversion</span></span><br><span class="line">        <span class="comment">//     Long r5 = exact2(raw, lng);</span></span><br><span class="line">        <span class="comment">//                      ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;T&gt;</span></span><br><span class="line">        <span class="comment">//   found:    Holder</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//       method &lt;T&gt;exact2(Holder&lt;T&gt;,T)</span></span><br><span class="line">        <span class="comment">// 2 warnings</span></span><br><span class="line"></span><br><span class="line">        Long r6 = exact2(qualified, lng);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Long r7 = exact2(unbounded, lng);</span></span><br><span class="line">        <span class="comment">// error: method exact2 in class Wildcards</span></span><br><span class="line">        <span class="comment">// cannot be applied to given types;</span></span><br><span class="line">        <span class="comment">//     Long r7 = exact2(unbounded, lng);</span></span><br><span class="line">        <span class="comment">//               ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;T&gt;,T</span></span><br><span class="line">        <span class="comment">//   found: Holder&lt;CAP#1&gt;,Long</span></span><br><span class="line">        <span class="comment">//   reason: inference variable T has</span></span><br><span class="line">        <span class="comment">//     incompatible bounds</span></span><br><span class="line">        <span class="comment">//     equality constraints: CAP#1</span></span><br><span class="line">        <span class="comment">//     lower bounds: Long</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//       method &lt;T&gt;exact2(Holder&lt;T&gt;,T)</span></span><br><span class="line">        <span class="comment">//   where CAP#1 is a fresh type-variable:</span></span><br><span class="line">        <span class="comment">//     CAP#1 extends Object from capture of ?</span></span><br><span class="line">        <span class="comment">// 1 error</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Long r8 = exact2(bounded, lng);</span></span><br><span class="line">        <span class="comment">// error: method exact2 in class Wildcards</span></span><br><span class="line">        <span class="comment">// cannot be applied to given types;</span></span><br><span class="line">        <span class="comment">//      Long r8 = exact2(bounded, lng);</span></span><br><span class="line">        <span class="comment">//                ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;T&gt;,T</span></span><br><span class="line">        <span class="comment">//   found: Holder&lt;CAP#1&gt;,Long</span></span><br><span class="line">        <span class="comment">//   reason: inference variable T</span></span><br><span class="line">        <span class="comment">//     has incompatible bounds</span></span><br><span class="line">        <span class="comment">//     equality constraints: CAP#1</span></span><br><span class="line">        <span class="comment">//     lower bounds: Long</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//       method &lt;T&gt;exact2(Holder&lt;T&gt;,T)</span></span><br><span class="line">        <span class="comment">//   where CAP#1 is a fresh type-variable:</span></span><br><span class="line">        <span class="comment">//     CAP#1 extends Long from</span></span><br><span class="line">        <span class="comment">//       capture of ? extends Long</span></span><br><span class="line">        <span class="comment">// 1 error</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Long r9 = wildSubtype(raw, lng);</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked method invocation:</span></span><br><span class="line">        <span class="comment">// method wildSubtype in class Wildcards</span></span><br><span class="line">        <span class="comment">// is applied to given types</span></span><br><span class="line">        <span class="comment">//     Long r9 = wildSubtype(raw, lng);</span></span><br><span class="line">        <span class="comment">//                          ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;? extends T&gt;,T</span></span><br><span class="line">        <span class="comment">//   found: Holder,Long</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//     method &lt;T&gt;wildSubtype(Holder&lt;? extends T&gt;,T)</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked conversion</span></span><br><span class="line">        <span class="comment">//     Long r9 = wildSubtype(raw, lng);</span></span><br><span class="line">        <span class="comment">//                           ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;? extends T&gt;</span></span><br><span class="line">        <span class="comment">//   found:    Holder</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//     method &lt;T&gt;wildSubtype(Holder&lt;? extends T&gt;,T)</span></span><br><span class="line">        <span class="comment">// 2 warnings</span></span><br><span class="line"></span><br><span class="line">        Long r10 = wildSubtype(qualified, lng);</span><br><span class="line">        <span class="comment">// OK, but can only return Object:</span></span><br><span class="line">        Object r11 = wildSubtype(unbounded, lng);</span><br><span class="line">        Long r12 = wildSubtype(bounded, lng);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- wildSupertype(raw, lng);</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked method invocation:</span></span><br><span class="line">        <span class="comment">//   method wildSupertype in class Wildcards</span></span><br><span class="line">        <span class="comment">//   is applied to given types</span></span><br><span class="line">        <span class="comment">//     wildSupertype(raw, lng);</span></span><br><span class="line">        <span class="comment">//                  ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;? super T&gt;,T</span></span><br><span class="line">        <span class="comment">//   found: Holder,Long</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//     method &lt;T&gt;wildSupertype(Holder&lt;? super T&gt;,T)</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked conversion</span></span><br><span class="line">        <span class="comment">//     wildSupertype(raw, lng);</span></span><br><span class="line">        <span class="comment">//                   ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;? super T&gt;</span></span><br><span class="line">        <span class="comment">//   found:    Holder</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//     method &lt;T&gt;wildSupertype(Holder&lt;? super T&gt;,T)</span></span><br><span class="line">        <span class="comment">// 2 warnings</span></span><br><span class="line"></span><br><span class="line">        wildSupertype(qualified, lng);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- wildSupertype(unbounded, lng);</span></span><br><span class="line">        <span class="comment">// error: method wildSupertype in class Wildcards</span></span><br><span class="line">        <span class="comment">// cannot be applied to given types;</span></span><br><span class="line">        <span class="comment">//     wildSupertype(unbounded, lng);</span></span><br><span class="line">        <span class="comment">//     ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;? super T&gt;,T</span></span><br><span class="line">        <span class="comment">//   found: Holder&lt;CAP#1&gt;,Long</span></span><br><span class="line">        <span class="comment">//   reason: cannot infer type-variable(s) T</span></span><br><span class="line">        <span class="comment">//     (argument mismatch; Holder&lt;CAP#1&gt;</span></span><br><span class="line">        <span class="comment">//     cannot be converted to Holder&lt;? super T&gt;)</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//     method &lt;T&gt;wildSupertype(Holder&lt;? super T&gt;,T)</span></span><br><span class="line">        <span class="comment">//   where CAP#1 is a fresh type-variable:</span></span><br><span class="line">        <span class="comment">//     CAP#1 extends Object from capture of ?</span></span><br><span class="line">        <span class="comment">// 1 error</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//- wildSupertype(bounded, lng);</span></span><br><span class="line">        <span class="comment">// error: method wildSupertype in class Wildcards</span></span><br><span class="line">        <span class="comment">// cannot be applied to given types;</span></span><br><span class="line">        <span class="comment">//     wildSupertype(bounded, lng);</span></span><br><span class="line">        <span class="comment">//     ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;? super T&gt;,T</span></span><br><span class="line">        <span class="comment">//   found: Holder&lt;CAP#1&gt;,Long</span></span><br><span class="line">        <span class="comment">//   reason: cannot infer type-variable(s) T</span></span><br><span class="line">        <span class="comment">//     (argument mismatch; Holder&lt;CAP#1&gt;</span></span><br><span class="line">        <span class="comment">//     cannot be converted to Holder&lt;? super T&gt;)</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//     method &lt;T&gt;wildSupertype(Holder&lt;? super T&gt;,T)</span></span><br><span class="line">        <span class="comment">//   where CAP#1 is a fresh type-variable:</span></span><br><span class="line">        <span class="comment">//     CAP#1 extends Long from capture of</span></span><br><span class="line">        <span class="comment">//     ? extends Long</span></span><br><span class="line">        <span class="comment">// 1 error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>rawArgs()</code> 中，编译器知道 <code>Holder</code> 是一个泛型类型，因此即使它在这里被表示成一个原生类型，编译器仍旧知道向 <code>set()</code> 传递一个 <strong>Object</strong> 是不安全的。由于它是原生类型，我们可以将任何类型的对象传递给 <code>set()</code> ，而这个对象将被向上转型为 <strong>Object</strong> 。因此无论何时，只要使用了原生类型，都会放弃编译期检查。对 <code>get()</code> 的调用说明了相同的问题：没有任何 <strong>T</strong> 类型的对象，因此结果只能是一个 <strong>Object</strong>。<br>人们很自然地会开始考虑原生 <code>Holder</code> 与 <code>Holder&lt;?&gt;</code> 是大致相同的事物。但是 <code>unboundedArg()</code> 强调它们是不同的——它揭示了相同的问题，但是它将这些问题作为错误而不是警告报告，因为原生 <strong>Holder</strong> 将持有任何类型的组合，而 <code>Holder&lt;?&gt;</code> 将持有具有某种具体类型的同构集合，因此不能只是向其中传递 <strong>Object</strong> 。<br>在 <code>exact1()</code> 和 <code>exact2()</code> 中，我们可以看到使用了确切的泛型参数——没有任何通配符。我们将看到，<code>exact2()</code>与 <code>exact1()</code> 具有不同的限制，因为它有额外的参数。<br>在 <code>wildSubtype()</code> 中，在 <strong>Holder</strong> 类型上的限制被放松为包括持有任何扩展自 <strong>T</strong> 的对象的 <strong>Holder</strong> 。这还是意味着如果 T 是 <strong>Fruit</strong> ，那么 <code>holder</code> 可以是 <code>Holder&lt;Apple&gt;</code> ，这是合法的。为了防止将 <strong>Orange</strong> 放置到 <code>Holder&lt;Apple&gt;</code> 中，对 <code>set()</code> 的调用（或者对任何接受这个类型参数为参数的方法的调用）都是不允许的。但是，我们仍旧知道任何来自 <code>Holder&lt;？extends Fruit&gt;</code> 的对象至少是 <strong>Fruit</strong> ，因此 <code>get()</code> （或者任何将产生具有这个类型参数的返回值的方法）都是允许的。<br><code>wildSupertype()</code> 展示了超类型通配符，这个方法展示了与 <code>wildSubtype()</code> 相反的行为：<code>holder</code> 可以是持有任何 T 的基类型的容器。因此， <code>set()</code> 可以接受 <strong>T</strong> ，因为任何可以工作于基类的对象都可以多态地作用于导出类（这里就是 <strong>T</strong> ）。但是，尝试着调用 <code>get()</code> 是没有用的，因为由 <code>holder</code> 持有的类型可以是任何超类型，因此唯一安全的类型就是 <strong>Object</strong> 。<br>这个示例还展示了对于在 <code>unbounded()</code> 中使用无界通配符能够做什么不能做什么所做出的限制：因为我们没有 <strong>T</strong>，所以我们不能将 <code>set()</code> 或 <code>get()</code> 作用于 <strong>T</strong> 上。</p><p>在 <code>main()</code> 方法中我们看到了某些方法在接受某些类型的参数时没有报错和警告。为了迁移兼容性，<code>rawArgs()</code>  将接受所有 <strong>Holder</strong> 的不同变体，而不会产生警告。<code>unboundedArg()</code> 方法也可以接受相同的所有类型，尽管如前所述，它在方法体内部处理这些类型的方式并不相同。</p><p>如果向接受“确切”泛型类型（没有通配符）的方法传递一个原生 <strong>Holder</strong> 引用，就会得到一个警告，因为确切的参数期望得到在原生类型中并不存在的信息。如果向 <code>exact1()</code> 传递一个无界引用，就不会有任何可以确定返回类型的类型信息。<br>可以看到，<code>exact2()</code> 具有最多的限制，因为它希望精确地得到一个 <code>Holder&lt;T&gt;</code> ，以及一个具有类型 <strong>T</strong> 的参数，正由于此，它将产生错误或警告，除非提供确切的参数。有时，这样做很好，但是如果它过于受限，那么就可以使用通配符，这取决于是否想要从泛型参数中返回类型确定的返回值（就像在 <code>wildSubtype()</code> 中看到的那样），或者是否想要向泛型参数传递类型确定的参数（就像在 <code>wildSupertype()</code> 中看到的那样）。<br>因此，使用确切类型来替代通配符类型的好处是，可以用泛型参数来做更多的事，但是使用通配符使得我们必须接受范围更宽的参数化类型作为参数。因此，必须逐个情况地权衡利弊，找到更适合我们的需求的方法。</p><h3 id="捕获转换"><a href="#捕获转换" class="headerlink" title="捕获转换"></a>捕获转换</h3><p>有一种特殊情况需要使用 <code>&lt;?&gt;</code> 而不是原生类型。如果向一个使用 <code>&lt;?&gt;</code> 的方法传递原生类型，那么对编译器来说，可能会推断出实际的类型参数，使得这个方法可以回转并调用另一个使用这个确切类型的方法。下面的示例演示了这种技术，它被称为捕获转换，因为未指定的通配符类型被捕获，并被转换为确切类型。这里，有关警告的注释只有在 <code>@SuppressWarnings</code> 注解被移除之后才能起作用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/CaptureConversion.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CaptureConversion</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(Holder&lt;T&gt; holder)</span> </span>&#123;</span><br><span class="line">        T t = holder.get();</span><br><span class="line">        System.out.println(t.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">(Holder&lt;?&gt; holder)</span> </span>&#123;</span><br><span class="line">        f1(holder); <span class="comment">// Call with captured type</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Holder raw = <span class="keyword">new</span> Holder&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">        f1(raw);</span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked method invocation:</span></span><br><span class="line">        <span class="comment">// method f1 in class CaptureConversion</span></span><br><span class="line">        <span class="comment">// is applied to given types</span></span><br><span class="line">        <span class="comment">//     f1(raw);</span></span><br><span class="line">        <span class="comment">//       ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;T&gt;</span></span><br><span class="line">        <span class="comment">//   found: Holder</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//     method &lt;T&gt;f1(Holder&lt;T&gt;)</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked conversion</span></span><br><span class="line">        <span class="comment">//     f1(raw);</span></span><br><span class="line">        <span class="comment">//        ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;T&gt;</span></span><br><span class="line">        <span class="comment">//   found:    Holder</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//     method &lt;T&gt;f1(Holder&lt;T&gt;)</span></span><br><span class="line">        <span class="comment">// 2 warnings</span></span><br><span class="line">        f2(raw); <span class="comment">// No warnings</span></span><br><span class="line">        </span><br><span class="line">        Holder rawBasic = <span class="keyword">new</span> Holder();</span><br><span class="line">        rawBasic.set(<span class="keyword">new</span> Object());</span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked call to set(T)</span></span><br><span class="line">        <span class="comment">// as a member of the raw type Holder</span></span><br><span class="line">        <span class="comment">//     rawBasic.set(new Object());</span></span><br><span class="line">        <span class="comment">//                 ^</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in class Holder</span></span><br><span class="line">        <span class="comment">// 1 warning</span></span><br><span class="line">        f2(rawBasic); <span class="comment">// No warnings</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Upcast to Holder&lt;?&gt;, still figures it out:</span></span><br><span class="line">        Holder&lt;?&gt; wildcarded = <span class="keyword">new</span> Holder&lt;&gt;(<span class="number">1.0</span>);</span><br><span class="line">        f2(wildcarded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Integer</span></span><br><span class="line"><span class="comment">Integer</span></span><br><span class="line"><span class="comment">Object</span></span><br><span class="line"><span class="comment">Double</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>f1()</code> 中的类型参数都是确切的，没有通配符或边界。在 <code>f2()</code> 中，<strong>Holder</strong> 参数是一个无界通配符，因此它看起来是未知的。但是，在 <code>f2()</code> 中调用了 <code>f1()</code>，而 <code>f1()</code> 需要一个已知参数。这里所发生的是：在调用 <code>f2()</code> 的过程中捕获了参数类型，并在调用 <code>f1()</code> 时使用了这种类型。<br>我们可能想知道这项技术是否可以用于写入，但是这要求在传递 <code>Holder&lt;?&gt;</code> 时同时传递一个具体类型。捕获转换只有在这样的情况下可以工作：即在方法内部，我们需要使用确切的类型。注意，不能从 <code>f2()</code> 中返回 <strong>T</strong>，因为 <strong>T</strong> 对于 <code>f2()</code> 来说是未知的。捕获转换十分有趣，但是非常受限。</p><!-- Issues --><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>本节将阐述在使用 Java 泛型时会出现的各类问题。</p><h3 id="任何基本类型都不能作为类型参数"><a href="#任何基本类型都不能作为类型参数" class="headerlink" title="任何基本类型都不能作为类型参数"></a>任何基本类型都不能作为类型参数</h3><p>正如本章早先提到的，Java 泛型的限制之一是不能将基本类型用作类型参数。因此，不能创建  <code>ArrayList&lt;int&gt;</code> 之类的东西。<br>解决方法是使用基本类型的包装器类以及自动装箱机制。如果创建一个 <code>ArrayList&lt;Integer&gt;</code>，并将基本类型 <strong>int</strong> 应用于这个集合，那么我们将发现自动装箱机制将自动地实现 <strong>int</strong> 到 <strong>Integer</strong> 的双向转换——因此，这几乎就像是有一个 <code>ArrayList&lt;int&gt;</code> 一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ListOfInt.java</span></span><br><span class="line"><span class="comment">// Autoboxing compensates for the inability</span></span><br><span class="line"><span class="comment">// to use primitives in generics</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListOfInt</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; li = IntStream.range(<span class="number">38</span>, <span class="number">48</span>)</span><br><span class="line">            .boxed() <span class="comment">// Converts ints to Integers</span></span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">        System.out.println(li);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[38, 39, 40, 41, 42, 43, 44, 45, 46, 47]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>通常，这种解决方案工作得很好——能够成功地存储和读取 <strong>int</strong>，自动装箱隐藏了转换的过程。但是如果性能成为问题的话，就需要使用专门为基本类型适配的特殊版本的集合；一个开源版本的实现是 <strong>org.apache.commons.collections.primitives</strong>。<br>下面是另外一种方式，它可以创建持有 <strong>Byte</strong> 的 <strong>Set</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ByteSet.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteSet</span> </span>&#123;</span><br><span class="line">    Byte[] possibles = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    Set&lt;Byte&gt; mySet = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(possibles));</span><br><span class="line">    <span class="comment">// But you can't do this:</span></span><br><span class="line">    <span class="comment">// Set&lt;Byte&gt; mySet2 = new HashSet&lt;&gt;(</span></span><br><span class="line">    <span class="comment">// Arrays.&lt;Byte&gt;asList(1,2,3,4,5,6,7,8,9));</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自动装箱机制解决了一些问题，但并没有解决所有问题。</p><p>在下面的示例中，<strong>FillArray</strong> 接口包含一些通用方法，这些方法使用 <strong>Supplier</strong> 来用对象填充数组（这使得类泛型在本例中无法工作，因为这个方法是静态的）。<strong>Supplier</strong> 实现来自 <a href="book/21-Arrays.md">数组</a> 一章,并且在 <code>main()</code> 中，可以看到 <code>FillArray.fill()</code> 使用对象填充了数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/PrimitiveGenericTest.java</span></span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fill an array using a generator:</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FillArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; T[] fill(T[] a, Supplier&lt;T&gt; gen) &#123;</span><br><span class="line">        Arrays.setAll(a, n -&gt; gen.get());</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] fill(<span class="keyword">int</span>[] a, IntSupplier gen) &#123;</span><br><span class="line">        Arrays.setAll(a, n -&gt; gen.getAsInt());</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span>[] fill(<span class="keyword">long</span>[] a, LongSupplier gen) &#123;</span><br><span class="line">        Arrays.setAll(a, n -&gt; gen.getAsLong());</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span>[] fill(<span class="keyword">double</span>[] a, DoubleSupplier gen) &#123;</span><br><span class="line">        Arrays.setAll(a, n -&gt; gen.getAsDouble());</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimitiveGenericTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] strings = FillArray.fill(</span><br><span class="line">            <span class="keyword">new</span> String[<span class="number">5</span>], <span class="keyword">new</span> Rand.String(<span class="number">9</span>));</span><br><span class="line">        System.out.println(Arrays.toString(strings));</span><br><span class="line">        <span class="keyword">int</span>[] integers = FillArray.fill(</span><br><span class="line">            <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>], <span class="keyword">new</span> Rand.Pint());</span><br><span class="line">        System.out.println(Arrays.toString(integers));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[btpenpccu, xszgvgmei, nneeloztd, vewcippcy, gpoalkljl]</span></span><br><span class="line"><span class="comment">[635, 8737, 3941, 4720, 6177, 8479, 6656, 3768, 4948]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>自动装箱不适用于数组，因此我们必须创建 <code>FillArray.fill()</code> 的重载版本，或创建产生 <strong>Wrapped</strong> 输出的生成器。 <strong>FillArray</strong> 仅比 <code>java.util.Arrays.setAll()</code> 有用一点，因为它返回填充的数组。</p><h3 id="实现参数化接口"><a href="#实现参数化接口" class="headerlink" title="实现参数化接口"></a>实现参数化接口</h3><p>一个类不能实现同一个泛型接口的两种变体，由于擦除的原因，这两个变体会成为相同的接口。下面是产生这种冲突的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/MultipleInterfaceVariants.java</span></span><br><span class="line"><span class="comment">// &#123;WillNotCompile&#125;</span></span><br><span class="line"><span class="keyword">package</span> generics;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Payable</span>&lt;<span class="title">T</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Payable</span>&lt;<span class="title">Employee</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hourly</span> <span class="keyword">extends</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Payable</span>&lt;<span class="title">Hourly</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>Hourly</strong> 不能编译，因为擦除会将  <code>Payable&lt;Employe&gt;</code> 和 <code>Payable&lt;Hourly&gt;</code> 简化为相同的类 <strong>Payable</strong>，这样，上面的代码就意味着在重复两次地实现相同的接口。十分有趣的是，如果从 <strong>Payable</strong> 的两种用法中都移除掉泛型参数（就像编译器在擦除阶段所做的那样）这段代码就可以编译。</p><p>在使用某些更基本的 Java 接口，例如 <code>Comparable&lt;T&gt;</code> 时，这个问题可能会变得十分令人恼火，就像我们在本节稍后看到的那样。</p><h3 id="转型和警告"><a href="#转型和警告" class="headerlink" title="转型和警告"></a>转型和警告</h3><p>使用带有泛型类型参数的转型或 <strong>instanceof</strong> 不会有任何效果。下面的集合在内部将各个值存储为 <strong>Object</strong>，并在获取这些值时，再将它们转型回 <strong>T</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericCast.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FixedSizeStack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> Object[] storage;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    FixedSizeStack(<span class="keyword">int</span> size) &#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        storage = <span class="keyword">new</span> Object[size];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; size)</span><br><span class="line">            storage[index++] = item;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index == <span class="number">0</span> ? <span class="keyword">null</span> : (T)storage[--index];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function">Stream&lt;T&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Stream&lt;T&gt;)Arrays.stream(storage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericCast</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String[] letters = <span class="string">"ABCDEFGHIJKLMNOPQRS"</span>.split(<span class="string">""</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FixedSizeStack&lt;String&gt; strings =</span><br><span class="line">            <span class="keyword">new</span> FixedSizeStack&lt;&gt;(letters.length);</span><br><span class="line">        Arrays.stream(<span class="string">"ABCDEFGHIJKLMNOPQRS"</span>.split(<span class="string">""</span>))</span><br><span class="line">            .forEach(strings::push);</span><br><span class="line">        System.out.println(strings.pop());</span><br><span class="line">        strings.stream()</span><br><span class="line">            .map(s -&gt; s + <span class="string">" "</span>)</span><br><span class="line">            .forEach(System.out::print);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">S</span></span><br><span class="line"><span class="comment">A B C D E F G H I J K L M N O P Q R S</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>如果没有 <strong>@SuppressWarnings</strong> 注解，编译器将对 <code>pop()</code> 产生 “unchecked cast” 警告。由于擦除的原因，编译器无法知道这个转型是否是安全的，并且 <code>pop()</code> 方法实际上并没有执行任何转型。<br>这是因为，<strong>T</strong> 被擦除到它的第一个边界，默认情况下是 <strong>Object</strong> ，因此 <code>pop()</code> 实际上只是将 <strong>Object</strong> 转型为 <strong>Object</strong>。<br>有时，泛型没有消除对转型的需要，这就会由编译器产生警告，而这个警告是不恰当的。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/NeedCasting.java</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NeedCasting</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">            <span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]));</span><br><span class="line">        List&lt;Widget&gt; shapes = (List&lt;Widget&gt;)in.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如我们将在 <a href="book/Appendix-Object-Serialization.md">附录：对象序列化</a> 中学到的那样，<code>readObject()</code> 无法知道它正在读取的是什么，因此它返回的是必须转型的对象。但是当注释掉 <strong>@SuppressWarnings</strong> 注解并编译这个程序时，就会得到下面的警告。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NeedCasting.java uses unchecked or unsafe operations.</span><br><span class="line">Recompile with -Xlint:unchecked for details.</span><br><span class="line"></span><br><span class="line">And if you follow the instructions and recompile with  -</span><br><span class="line">Xlint:unchecked :(如果遵循这条指示，使用-Xlint:unchecked来重新编译：)</span><br><span class="line"></span><br><span class="line">NeedCasting.java:10: warning: [unchecked] unchecked cast</span><br><span class="line">    List&lt;Widget&gt; shapes = (List&lt;Widget&gt;)in.readObject();</span><br><span class="line">    required: List&lt;Widget&gt;</span><br><span class="line">    found: Object</span><br><span class="line">1 warning</span><br></pre></td></tr></table></figure><p>我们会被强制要求转型，但是又被告知不应该转型。为了解决这个问题，必须使用 Java 5 引入的新的转型形式，既通过泛型类来转型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ClassCasting.java</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassCasting</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">            <span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]));</span><br><span class="line">        <span class="comment">// Won't Compile:</span></span><br><span class="line">        <span class="comment">//    List&lt;Widget&gt; lw1 =</span></span><br><span class="line">        <span class="comment">//    List&lt;&gt;.class.cast(in.readObject());</span></span><br><span class="line">        List&lt;Widget&gt; lw2 = List.class.cast(in.readObject());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，不能转型到实际类型（ <code>List&lt;Widget&gt;</code> ）。也就是说，不能声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Widget&gt;.class.cast(in.readobject())</span><br></pre></td></tr></table></figure><p>甚至当我们添加一个像下面这样的另一个转型时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(List&lt;Widget&gt;)List.class.cast(in.readobject())</span><br></pre></td></tr></table></figure><p>仍旧会得到一个警告。</p><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>下面的程序是不能编译的，即使它看起来是合理的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/UseList.java</span></span><br><span class="line"><span class="comment">// &#123;WillNotCompile&#125;</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseList</span>&lt;<span class="title">W</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(List&lt;T&gt; v)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(List&lt;W&gt; v)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为擦除，所以重载方法产生了相同的类型签名。</p><p>因而，当擦除后的参数不能产生唯一的参数列表时，我们必须提供不同的方法名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/UseList2.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseList2</span>&lt;<span class="title">W</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(List&lt;T&gt; v)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(List&lt;W&gt; v)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>幸运的是，编译器可以检测到这类问题。</p><h3 id="基类劫持接口"><a href="#基类劫持接口" class="headerlink" title="基类劫持接口"></a>基类劫持接口</h3><p>假设我们有一个实现了 <strong>Comparable</strong> 接口的 <strong>Pet</strong> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ComparablePet.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparablePet</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ComparablePet</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(ComparablePet o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试缩小 <strong>ComparablePet</strong> 子类的比较类型是有意义的。例如，<strong>Cat</strong> 类可以与其他的 <strong>Cat</strong> 比较：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/HijackedInterface.java</span></span><br><span class="line"><span class="comment">// &#123;WillNotCompile&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">ComparablePet</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Cat</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// error: Comparable cannot be inherited with</span></span><br><span class="line">    <span class="comment">// different arguments: &lt;Cat&gt; and &lt;ComparablePet&gt;</span></span><br><span class="line">    <span class="comment">// class Cat</span></span><br><span class="line">    <span class="comment">// ^</span></span><br><span class="line">    <span class="comment">// 1 error</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Cat arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不幸的是，这不能工作。一旦 <strong>Comparable</strong> 的类型参数设置为 <strong>ComparablePet</strong>，其他的实现类只能比较 <strong>ComparablePet</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/RestrictedComparablePets.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hamster</span> <span class="keyword">extends</span> <span class="title">ComparablePet</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ComparablePet</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(ComparablePet arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Or just:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gecko</span> <span class="keyword">extends</span> <span class="title">ComparablePet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(ComparablePet arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Hamster</strong> 显示了重新实现 <strong>ComparableSet</strong> 中相同的接口是可能的，只要接口完全相同，包括参数类型。然而正如 <strong>Gecko</strong> 中所示，这与直接覆写基类的方法完全相同。</p><!-- Self-Bounded Types --><h2 id="自限定的类型"><a href="#自限定的类型" class="headerlink" title="自限定的类型"></a>自限定的类型</h2><p>在 Java 泛型中，有一个似乎经常性出现的惯用法，它相当令人费解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123; <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>这就像两面镜子彼此照向对方所引起的目眩效果一样，是一种无限反射。<strong>SelfBounded</strong> 类接受泛型参数 <strong>T</strong>，而 <strong>T</strong> 由一个边界类限定，这个边界就是拥有 <strong>T</strong> 作为其参数的 <strong>SelfBounded</strong>。</p><p>当我们首次看到它时，很难去解析它，它强调的是当 <strong>extends</strong> 关键字用于边界与用来创建子类明显是不同的。</p><h3 id="古怪的循环泛型"><a href="#古怪的循环泛型" class="headerlink" title="古怪的循环泛型"></a>古怪的循环泛型</h3><p>为了理解自限定类型的含义，我们从这个惯用法的一个简单版本入手，它没有自限定的边界。</p><p>不能直接继承一个泛型参数，但是，可以继承在其自己的定义中使用这个泛型参数的类。也就是说，可以声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/CuriouslyRecurringGeneric.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericType</span>&lt;<span class="title">T</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuriouslyRecurringGeneric</span></span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">GenericType</span>&lt;<span class="title">CuriouslyRecurringGeneric</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>这可以按照 Jim Coplien 在 C++ 中的<em>古怪的循环模版模式</em>的命名方式，称为古怪的循环泛型（CRG）。“古怪的循环”是指类相当古怪地出现在它自己的基类中这一事实。<br>为了理解其含义，努力大声说：“我在创建一个新类，它继承自一个泛型类型，这个泛型类型接受我的类的名字作为其参数。”当给出导出类的名字时，这个泛型基类能够实现什么呢？好吧，Java 中的泛型关乎参数和返回类型，因此它能够产生使用导出类作为其参数和返回类型的基类。它还能将导出类型用作其域类型，尽管这些将被擦除为 <strong>Object</strong> 的类型。下面是表示了这种情况的一个泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/BasicHolder.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicHolder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T element;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(T arg)</span> </span>&#123; element = arg; &#125;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> element; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(element.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个普通的泛型类型，它的一些方法将接受和产生具有其参数类型的对象，还有一个方法在其存储的域上执行操作（尽管只是在这个域上执行 <strong>Object</strong> 操作）。<br>我们可以在一个古怪的循环泛型中使用 <strong>BasicHolder</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/CRGWithBasicHolder.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subtype</span> <span class="keyword">extends</span> <span class="title">BasicHolder</span>&lt;<span class="title">Subtype</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CRGWithBasicHolder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subtype st1 = <span class="keyword">new</span> Subtype(), st2 = <span class="keyword">new</span> Subtype();</span><br><span class="line">        st1.set(st2);</span><br><span class="line">        Subtype st3 = st1.get();</span><br><span class="line">        st1.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Subtype</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>注意，这里有些东西很重要：新类 <strong>Subtype</strong> 接受的参数和返回的值具有 <strong>Subtype</strong> 类型而不仅仅是基类 <strong>BasicHolder</strong> 类型。这就是 CRG 的本质：基类用导出类替代其参数。这意味着泛型基类变成了一种其所有导出类的公共功能的模版，但是这些功能对于其所有参数和返回值，将使用导出类型。也就是说，在所产生的类中将使用确切类型而不是基类型。因此，在<strong>Subtype</strong> 中，传递给 <code>set()</code> 的参数和从 <code>get()</code> 返回的类型都是确切的 <strong>Subtype</strong>。</p><h3 id="自限定"><a href="#自限定" class="headerlink" title="自限定"></a>自限定</h3><p><strong>BasicHolder</strong> 可以使用任何类型作为其泛型参数，就像下面看到的那样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Unconstrained.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// We make no guarantees that this code is fit for any purpose.</span></span><br><span class="line"><span class="comment">// Visit http://OnJava8.com for more book information.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Other</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicOther</span> <span class="keyword">extends</span> <span class="title">BasicHolder</span>&lt;<span class="title">Other</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Unconstrained</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BasicOther b = <span class="keyword">new</span> BasicOther();</span><br><span class="line">        BasicOther b2 = <span class="keyword">new</span> BasicOther();</span><br><span class="line">        b.set(<span class="keyword">new</span> Other());</span><br><span class="line">        Other other = b.get();</span><br><span class="line">        b.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Other</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>限定将采取额外的步骤，强制泛型当作其自身的边界参数来使用。观察所产生的类可以如何使用以及不可以如何使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/SelfBounding.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    T element;</span><br><span class="line">    <span class="function">SelfBounded&lt;T&gt; <span class="title">set</span><span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">        element = arg;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> element; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">A</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">A</span>&gt; </span>&#123;&#125; <span class="comment">// Also OK</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">C</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">C <span class="title">setAndGet</span><span class="params">(C arg)</span> </span>&#123; </span><br><span class="line">        set(arg); </span><br><span class="line">        <span class="keyword">return</span> get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// Can't do this:</span></span><br><span class="line"><span class="comment">// class E extends SelfBounded&lt;D&gt; &#123;&#125;</span></span><br><span class="line"><span class="comment">// Compile error:</span></span><br><span class="line"><span class="comment">//   Type parameter D is not within its bound</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Alas, you can do this, so you cannot force the idiom:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfBounding</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        a.set(<span class="keyword">new</span> A());</span><br><span class="line">        a = a.set(<span class="keyword">new</span> A()).get();</span><br><span class="line">        a = a.get();</span><br><span class="line">        C c = <span class="keyword">new</span> C();</span><br><span class="line">        c = c.setAndGet(<span class="keyword">new</span> C());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自限定所做的，就是要求在继承关系中，像下面这样使用这个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">A</span>&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>这会强制要求将正在定义的类当作参数传递给基类。</p><p>自限定的参数有何意义呢？它可以保证类型参数必须与正在被定义的类相同。正如我们在 B 类的定义中所看到的，还可以从使用了另一个 <strong>SelfBounded</strong> 参数的 <strong>SelfBounded</strong> 中导出，尽管在 <strong>A</strong> 类看到的用法看起来是主要的用法。对定义 <strong>E</strong> 的尝试说明不能使用不是 <strong>SelfBounded</strong> 的类型参数。<br>遗憾的是， <strong>F</strong> 可以编译，不会有任何警告，因此自限定惯用法不是可强制执行的。如果它确实很重要，可以要求一个外部工具来确保不会使用原生类型来替代参数化类型。<br>注意，可以移除自限定这个限制，这样所有的类仍旧是可以编译的，但是 <strong>E</strong> 也会因此而变得可编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/NotSelfBounded.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T element;</span><br><span class="line">    <span class="function">NotSelfBounded&lt;T&gt; <span class="title">set</span><span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">        element = arg;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> element; &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span> <span class="keyword">extends</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">A2</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span> <span class="keyword">extends</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">A2</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2</span> <span class="keyword">extends</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">C2</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">C2 <span class="title">setAndGet</span><span class="params">(C2 arg)</span> </span>&#123; </span><br><span class="line">        set(arg); </span><br><span class="line">        <span class="keyword">return</span> get(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// Now this is OK:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E2</span> <span class="keyword">extends</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">D2</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>因此很明显，自限定限制只能强制作用于继承关系。如果使用自限定，就应该了解这个类所用的类型参数将与使用这个参数的类具有相同的基类型。这会强制要求使用这个类的每个人都要遵循这种形式。<br>还可以将自限定用于泛型方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/SelfBoundingMethods.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// We make no guarantees that this code is fit for any purpose.</span></span><br><span class="line"><span class="comment">// Visit http://OnJava8.com for more book information.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfBoundingMethods</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T extends SelfBounded&lt;T&gt;&gt; <span class="function">T <span class="title">f</span><span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arg.set(arg).get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = f(<span class="keyword">new</span> A());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这可以防止这个方法被应用于除上述形式的自限定参数之外的任何事物上。</p><h3 id="参数协变"><a href="#参数协变" class="headerlink" title="参数协变"></a>参数协变</h3><p>自限定类型的价值在于它们可以产生<em>协变参数类型</em>——方法参数类型会随子类而变化。</p><p>尽管自限定类型还可以产生与子类类型相同的返回类型，但是这并不十分重要，因为<em>协变返回类型</em>是在 Java 5 引入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/CovariantReturnTypes.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OrdinaryGetter</span> </span>&#123;</span><br><span class="line">    <span class="function">Base <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DerivedGetter</span> <span class="keyword">extends</span> <span class="title">OrdinaryGetter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Overridden method return type can vary:</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Derived <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantReturnTypes</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(DerivedGetter d)</span> </span>&#123;</span><br><span class="line">        Derived d2 = d.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>DerivedGetter</strong> 中的 <code>get()</code> 方法覆盖了 <strong>OrdinaryGetter</strong> 中的 <code>get()</code> ，并返回了一个从 <code>OrdinaryGetter.get()</code> 的返回类型中导出的类型。尽管这是完全合乎逻辑的事情（导出类方法应该能够返回比它覆盖的基类方法更具体的类型）但是这在早先的 Java 版本中是不合法的。</p><p>自限定泛型事实上将产生确切的导出类型作为其返回值，就像在 <code>get()</code> 中所看到的一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericsAndReturnTypes.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GenericGetter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">GenericGetter</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Getter</span> <span class="keyword">extends</span> <span class="title">GenericGetter</span>&lt;<span class="title">Getter</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsAndReturnTypes</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Getter g)</span> </span>&#123;</span><br><span class="line">        Getter result = g.get();</span><br><span class="line">        GenericGetter gg = g.get(); <span class="comment">// Also the base type</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这段代码不能编译，除非是使用囊括了协变返回类型的 Java 5。</p><p>然而，在非泛型代码中，参数类型不能随子类型发生变化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/OrdinaryArguments.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrdinarySetter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Base base)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"OrdinarySetter.set(Base)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedSetter</span> <span class="keyword">extends</span> <span class="title">OrdinarySetter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Derived derived)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"DerivedSetter.set(Derived)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrdinaryArguments</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Base base = <span class="keyword">new</span> Base();</span><br><span class="line">        Derived derived = <span class="keyword">new</span> Derived();</span><br><span class="line">        DerivedSetter ds = <span class="keyword">new</span> DerivedSetter();</span><br><span class="line">        ds.set(derived);</span><br><span class="line">        <span class="comment">// Compiles--overloaded, not overridden!:</span></span><br><span class="line">        ds.set(base);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">DerivedSetter.set(Derived)</span></span><br><span class="line"><span class="comment">OrdinarySetter.set(Base)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>set(derived)</code> 和 <code>set(base)</code> 都是合法的，因此 <code>DerivedSetter.set()</code> 没有覆盖 <code>OrdinarySetter.set()</code> ，而是重载了这个方法。从输出中可以看到，在 <strong>DerivedSetter</strong> 中有两个方法，因此基类版本仍旧是可用的，因此可以证明它被重载过。<br>但是，在使用自限定类型时，在导出类中只有一个方法，并且这个方法接受导出类型而不是基类型为参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/SelfBoundingAndCovariantArguments.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SelfBoundSetter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SelfBoundSetter</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(T arg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Setter</span> <span class="keyword">extends</span> <span class="title">SelfBoundSetter</span>&lt;<span class="title">Setter</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfBoundingAndCovariantArguments</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span></span><br><span class="line">    testA(Setter s1, Setter s2, SelfBoundSetter sbs) &#123;</span><br><span class="line">        s1.set(s2);</span><br><span class="line">        <span class="comment">//- s1.set(sbs);</span></span><br><span class="line">        <span class="comment">// error: method set in interface SelfBoundSetter&lt;T&gt;</span></span><br><span class="line">        <span class="comment">// cannot be applied to given types;</span></span><br><span class="line">        <span class="comment">//     s1.set(sbs);</span></span><br><span class="line">        <span class="comment">//       ^</span></span><br><span class="line">        <span class="comment">//   required: Setter</span></span><br><span class="line">        <span class="comment">//   found: SelfBoundSetter</span></span><br><span class="line">        <span class="comment">//   reason: argument mismatch;</span></span><br><span class="line">        <span class="comment">// SelfBoundSetter cannot be converted to Setter</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends SelfBoundSetter&lt;T&gt; declared in</span></span><br><span class="line">        <span class="comment">//     interface SelfBoundSetter</span></span><br><span class="line">        <span class="comment">// 1 error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器不能识别将基类型当作参数传递给 <code>set()</code> 的尝试，因为没有任何方法具有这样的签名。实际上，这个参数已经被覆盖。<br>如果不使用自限定类型，普通的继承机制就会介入，而我们将能够重载，就像在非泛型的情况下一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/PlainGenericInheritance.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericSetter</span>&lt;<span class="title">T</span>&gt; </span>&#123; <span class="comment">// Not self-bounded</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"GenericSetter.set(Base)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedGS</span> <span class="keyword">extends</span> <span class="title">GenericSetter</span>&lt;<span class="title">Base</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Derived derived)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"DerivedGS.set(Derived)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlainGenericInheritance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Base base = <span class="keyword">new</span> Base();</span><br><span class="line">        Derived derived = <span class="keyword">new</span> Derived();</span><br><span class="line">        DerivedGS dgs = <span class="keyword">new</span> DerivedGS();</span><br><span class="line">        dgs.set(derived);</span><br><span class="line">        dgs.set(base); <span class="comment">// Overloaded, not overridden!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">DerivedGS.set(Derived)</span></span><br><span class="line"><span class="comment">GenericSetter.set(Base)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这段代码在模仿 <strong>OrdinaryArguments.java</strong>；在那个示例中，<strong>DerivedSetter</strong> 继承自包含一个 <code>set(Base)</code> 的<strong>OrdinarySetter</strong> 。而这里，<strong>DerivedGS</strong> 继承自泛型创建的也包含有一个 <code>set(Base)</code>的 <code>GenericSetter&lt;Base&gt;</code>。就像 <strong>OrdinaryArguments.java</strong> 一样，我们可以从输出中看到， <strong>DerivedGS</strong> 包含两个  <code>set()</code> 的重载版本。如果不使用自限定，将重载参数类型。如果使用了自限定，只能获得方法的一个版本，它将接受确切的参数类型。</p><!-- Dynamic Type Safety --><h2 id="动态类型安全"><a href="#动态类型安全" class="headerlink" title="动态类型安全"></a>动态类型安全</h2><p>因为可以向 Java 5 之前的代码传递泛型集合，所以旧式代码仍旧有可能会破坏我们的集合。Java 5 的 <strong>java.util.Collections</strong> 中有一组便利工具，可以解决在这种情况下的类型检查问题，它们是：静态方法 <code>checkedCollection()</code> 、<code>checkedList()</code>、 <code>checkedMap()</code> 、 <code>checkedSet()</code> 、<code>checkedSortedMap()</code>和 <code>checkedSortedSet()</code>。这些方法每一个都会将我们希望动态检查的集合当作第一个参数接受，并将我们希望强制要求的类型作为第二个参数接受。</p><p>受检查的集合在我们试图插入类型不正确的对象时抛出 <strong>ClassCastException</strong> ，这与泛型之前的（原生）集合形成了对比，对于后者来说，当我们将对象从集合中取出时，才会通知我们出现了问题。在后一种情况中，我们知道存在问题，但是不知道罪魁祸首在哪里，如果使用受检查的集合，就可以发现谁在试图插入不良对象。<br>让我们用受检查的集合来看看“将猫插入到狗列表中”这个问题。这里，<code>oldStyleMethod()</code> 表示遗留代码，因为它接受的是原生的 <strong>List</strong> ，而 <strong>@SuppressWarnings（“unchecked”）</strong> 注解对于压制所产生的警告是必需的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/CheckedList.java</span></span><br><span class="line"><span class="comment">// Using Collection.checkedList()</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckedList</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">oldStyleMethod</span><span class="params">(List probablyDogs)</span> </span>&#123;</span><br><span class="line">        probablyDogs.add(<span class="keyword">new</span> Cat());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Dog&gt; dogs1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        oldStyleMethod(dogs1); <span class="comment">// Quietly accepts a Cat</span></span><br><span class="line">        List&lt;Dog&gt; dogs2 = Collections.checkedList(</span><br><span class="line">            <span class="keyword">new</span> ArrayList&lt;&gt;(), Dog.class);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oldStyleMethod(dogs2); <span class="comment">// Throws an exception</span></span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Expected: "</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Derived types work fine:</span></span><br><span class="line">        List&lt;Pet&gt; pets = Collections.checkedList(</span><br><span class="line">            <span class="keyword">new</span> ArrayList&lt;&gt;(), Pet.class);</span><br><span class="line">        pets.add(<span class="keyword">new</span> Dog());</span><br><span class="line">        pets.add(<span class="keyword">new</span> Cat());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Expected: java.lang.ClassCastException: Attempt to</span></span><br><span class="line"><span class="comment">insert class typeinfo.pets.Cat element into collection</span></span><br><span class="line"><span class="comment">with element type class typeinfo.pets.Dog</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>运行这个程序时，我们会发现插入一个 <strong>Cat</strong> 对于 <strong>dogs1</strong> 来说没有任何问题，而 <strong>dogs2</strong> 立即会在这个错误类型的插入操作上抛出一个异常。还可以看到，将导出类型的对象放置到将要检查基类型的受检查容器中是没有问题的。</p><!-- Exceptions --><h2 id="泛型异常"><a href="#泛型异常" class="headerlink" title="泛型异常"></a>泛型异常</h2><p>由于擦除的原因，<strong>catch</strong> 语句不能捕获泛型类型的异常，因为在编译期和运行时都必须知道异常的确切类型。泛型类也不能直接或间接继承自 <strong>Throwable</strong>（这将进一步阻止我们去定义不能捕获的泛型异常）。<br>但是，类型参数可能会在一个方法的 <strong>throws</strong> 子句中用到。这使得我们可以编写随检查型异常类型变化的泛型代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ThrowGenericException.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Processor</span>&lt;<span class="title">T</span>, <span class="title">E</span> <span class="keyword">extends</span> <span class="title">Exception</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;T&gt; resultCollector)</span> <span class="keyword">throws</span> E</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProcessRunner</span>&lt;<span class="title">T</span>, <span class="title">E</span> <span class="keyword">extends</span> <span class="title">Exception</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">Processor</span>&lt;<span class="title">T</span>, <span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">processAll</span><span class="params">()</span> <span class="keyword">throws</span> E </span>&#123;</span><br><span class="line">        List&lt;T&gt; resultCollector = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Processor&lt;T, E&gt; processor : <span class="keyword">this</span>)</span><br><span class="line">            processor.process(resultCollector);</span><br><span class="line">        <span class="keyword">return</span> resultCollector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Failure1</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Processor1</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Processor</span>&lt;<span class="title">String</span>, <span class="title">Failure1</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">3</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;String&gt; resultCollector)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Failure1 </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count-- &gt; <span class="number">1</span>)</span><br><span class="line">            resultCollector.add(<span class="string">"Hep!"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            resultCollector.add(<span class="string">"Ho!"</span>);</span><br><span class="line">        <span class="keyword">if</span>(count &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Failure1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Failure2</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Processor2</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Processor</span>&lt;<span class="title">Integer</span>, <span class="title">Failure2</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">2</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;Integer&gt; resultCollector)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Failure2 </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count-- == <span class="number">0</span>)</span><br><span class="line">            resultCollector.add(<span class="number">47</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            resultCollector.add(<span class="number">11</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Failure2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowGenericException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProcessRunner&lt;String, Failure1&gt; runner =</span><br><span class="line">            <span class="keyword">new</span> ProcessRunner&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">            runner.add(<span class="keyword">new</span> Processor1());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(runner.processAll());</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Failure1 e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ProcessRunner&lt;Integer, Failure2&gt; runner2 =</span><br><span class="line">            <span class="keyword">new</span> ProcessRunner&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">            runner2.add(<span class="keyword">new</span> Processor2());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(runner2.processAll());</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Failure2 e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[Hep!, Hep!, Ho!]</span></span><br><span class="line"><span class="comment">Failure2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>Processor</strong> 执行 <code>process()</code> 方法，并且可能会抛出具有类型 <strong>E</strong> 的异常。<code>process()</code> 的结果存储在 <code>List&lt;T&gt;resultCollector</code> 中（这被称为<em>收集参数</em>）。<strong>ProcessRunner</strong> 有一个 <code>processAll()</code> 方法，它会在所持有的每个 <strong>Process</strong> 对象执行，并返回 <strong>resultCollector</strong> 。<br>如果不能参数化所抛出的异常，那么由于检查型异常的缘故，将不能编写出这种泛化的代码。</p><!-- Mixins --><h2 id="混型"><a href="#混型" class="headerlink" title="混型"></a>混型</h2><p>术语<em>混型<em>随时间的推移好像拥有了无数的含义，但是其最基本的概念是混合多个类的能力，以产生一个可以表示混型中所有类型的类。这往往是我们最后的手段，它将使组装多个类变得简单易行。<br>混型的价值之一是它们可以将特性和行为一致地应用于多个类之上。如果想在混型类中修改某些东西，作为一种意外的好处，这些修改将会应用于混型所应用的所有类型之上。正由于此，混型有一点</em>面向切面编程</em> （AOP） 的味道，而切面经常被建议用来解决混型问题。</p><h3 id="C-中的混型"><a href="#C-中的混型" class="headerlink" title="C++ 中的混型"></a>C++ 中的混型</h3><p>在 C++ 中，使用多重继承的最大理由，就是为了使用混型。但是，对于混型来说，更有趣、更优雅的方式是使用参数化类型，因为混型就是继承自其类型参数的类。在 C++ 中，可以很容易地创建混型，因为 C++ 能够记住其模版参数的类型。<br>下面是一个 C++ 示例，它有两个混型类型：一个使得我们可以在每个对象中混入拥有一个时间戳这样的属性，而另一个可以混入一个序列号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Mixins.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">TimeStamped</span> :</span> <span class="keyword">public</span> T &#123;</span><br><span class="line">    <span class="keyword">long</span> timeStamp;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TimeStamped() &#123; timeStamp = time(<span class="number">0</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getStamp</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> timeStamp; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">SerialNumbered</span> :</span> <span class="keyword">public</span> T &#123;</span><br><span class="line">    <span class="keyword">long</span> serialNumber;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> counter;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SerialNumbered() &#123; serialNumber = counter++; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getSerialNumber</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> serialNumber; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define and initialize the static storage:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">long</span> <span class="title">SerialNumbered</span>&lt;T&gt;:</span>:counter = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Basic</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="built_in">string</span> val)</span> </span>&#123; value = val; &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TimeStamped&lt;SerialNumbered&lt;Basic&gt;&gt; mixin1, mixin2;</span><br><span class="line">    mixin1.<span class="built_in">set</span>(<span class="string">"test string 1"</span>);</span><br><span class="line">    mixin2.<span class="built_in">set</span>(<span class="string">"test string 2"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mixin1.get() &lt;&lt; <span class="string">" "</span> &lt;&lt; mixin1.getStamp() &lt;&lt;</span><br><span class="line">      <span class="string">" "</span> &lt;&lt; mixin1.getSerialNumber() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mixin2.get() &lt;&lt; <span class="string">" "</span> &lt;&lt; mixin2.getStamp() &lt;&lt;</span><br><span class="line">      <span class="string">" "</span> &lt;&lt; mixin2.getSerialNumber() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">test string 1 1452987605 1</span></span><br><span class="line"><span class="comment">test string 2 1452987605 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在 <code>main()</code> 中， <strong>mixin1</strong> 和 <strong>mixin2</strong> 所产生的类型拥有所混入类型的所有方法。可以将混型看作是一种功能，它可以将现有类映射到新的子类上。注意，使用这种技术来创建一个混型是多么的轻而易举。基本上，只需要声明“这就是我想要的”，紧跟着它就发生了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TimeStamped&lt;SerialNumbered&lt;Basic&gt;&gt; mixin1，mixin2；</span><br></pre></td></tr></table></figure><p>遗憾的是，Java 泛型不允许这样。擦除会忘记基类类型，因此</p><blockquote><p> 泛型类不能直接继承自一个泛型参数</p></blockquote><p>这突显了许多我在 Java 语言设计决策（以及与这些功能一起发布）中遇到的一大问题：处理一件事很有希望，但是当您实际尝试做一些有趣的事情时，您会发现自己做不到。</p><h3 id="与接口混合"><a href="#与接口混合" class="headerlink" title="与接口混合"></a>与接口混合</h3><p>一种更常见的推荐解决方案是使用接口来产生混型效果，就像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Mixins.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TimeStamped</span> </span>&#123; <span class="function"><span class="keyword">long</span> <span class="title">getStamp</span><span class="params">()</span></span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeStampedImp</span> <span class="keyword">implements</span> <span class="title">TimeStamped</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timeStamp;</span><br><span class="line">    TimeStampedImp() &#123;</span><br><span class="line">        timeStamp = <span class="keyword">new</span> Date().getTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getStamp</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> timeStamp; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SerialNumbered</span> </span>&#123; <span class="function"><span class="keyword">long</span> <span class="title">getSerialNumber</span><span class="params">()</span></span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerialNumberedImp</span> <span class="keyword">implements</span> <span class="title">SerialNumbered</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> serialNumber = counter++;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSerialNumber</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> serialNumber; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Basic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(String val)</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicImp</span> <span class="keyword">implements</span> <span class="title">Basic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String val)</span> </span>&#123; value = val; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mixin</span> <span class="keyword">extends</span> <span class="title">BasicImp</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">TimeStamped</span>, <span class="title">SerialNumbered</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TimeStamped timeStamp = <span class="keyword">new</span> TimeStampedImp();</span><br><span class="line">    <span class="keyword">private</span> SerialNumbered serialNumber =</span><br><span class="line">        <span class="keyword">new</span> SerialNumberedImp();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getStamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timeStamp.getStamp();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSerialNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serialNumber.getSerialNumber();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mixins</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mixin mixin1 = <span class="keyword">new</span> Mixin(), mixin2 = <span class="keyword">new</span> Mixin();</span><br><span class="line">        mixin1.set(<span class="string">"test string 1"</span>);</span><br><span class="line">        mixin2.set(<span class="string">"test string 2"</span>);</span><br><span class="line">        System.out.println(mixin1.get() + <span class="string">" "</span> +</span><br><span class="line">            mixin1.getStamp() +  <span class="string">" "</span> + mixin1.getSerialNumber());</span><br><span class="line">        System.out.println(mixin2.get() + <span class="string">" "</span> +</span><br><span class="line">            mixin2.getStamp() +  <span class="string">" "</span> + mixin2.getSerialNumber());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">test string 1 1494331663026 1</span></span><br><span class="line"><span class="comment">test string 2 1494331663027 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>Mixin</strong> 类基本上是在使用<em>委托</em>，因此每个混入类型都要求在 <strong>Mixin</strong> 中有一个相应的域，而我们必须在 <strong>Mixin</strong> 中编写所有必需的方法，将方法调用转发给恰当的对象。这个示例使用了非常简单的类，但是当使用更复杂的混型时，代码数量会急速增加。</p><h3 id="使用装饰器模式"><a href="#使用装饰器模式" class="headerlink" title="使用装饰器模式"></a>使用装饰器模式</h3><p>当我们观察混型的使用方式时，就会发现混型概念好像与<em>装饰器</em>设计模式关系很近。装饰器经常用于满足各种可能的组合，而直接子类化会产生过多的类，因此是不实际的。<br>装饰器模式使用分层对象来动态透明地向单个对象中添加责任。装饰器指定包装在最初的对象周围的所有对象都具有相同的基本接口。某些事物是可装饰的，可以通过将其他类包装在这个可装饰对象的四周，来将功能分层。这使得对装饰器的使用是透明的——无论对象是否被装饰，我们都拥有一个可以向对象发送的公共消息集。装饰类也可以添加新方法，但是正如我们所见，这将是受限的。<br>装饰器是通过使用组合和形式化结构（可装饰物/装饰器层次结构）来实现的，而混型是基于继承的。因此可以将基于参数化类型的混型当作是一种泛型装饰器机制，这种机制不需要装饰器设计模式的继承结构。<br>前面的示例可以被改写为使用装饰器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/decorator/Decoration.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;java generics.decorator.Decoration&#125;</span></span><br><span class="line"><span class="keyword">package</span> generics.decorator;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Basic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String val)</span> </span>&#123; value = val; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">Basic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Basic basic;</span><br><span class="line">    Decorator(Basic basic) &#123; <span class="keyword">this</span>.basic = basic; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String val)</span> </span>&#123; basic.set(val); &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> basic.get(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeStamped</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timeStamp;</span><br><span class="line">    TimeStamped(Basic basic) &#123;</span><br><span class="line">        <span class="keyword">super</span>(basic);</span><br><span class="line">        timeStamp = <span class="keyword">new</span> Date().getTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getStamp</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> timeStamp; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerialNumbered</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> serialNumber = counter++;</span><br><span class="line">    SerialNumbered(Basic basic) &#123; <span class="keyword">super</span>(basic); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSerialNumber</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> serialNumber; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decoration</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TimeStamped t = <span class="keyword">new</span> TimeStamped(<span class="keyword">new</span> Basic());</span><br><span class="line">        TimeStamped t2 = <span class="keyword">new</span> TimeStamped(</span><br><span class="line">            <span class="keyword">new</span> SerialNumbered(<span class="keyword">new</span> Basic()));</span><br><span class="line">        <span class="comment">//- t2.getSerialNumber(); // Not available</span></span><br><span class="line">        SerialNumbered s = <span class="keyword">new</span> SerialNumbered(<span class="keyword">new</span> Basic());</span><br><span class="line">        SerialNumbered s2 = <span class="keyword">new</span> SerialNumbered(</span><br><span class="line">            <span class="keyword">new</span> TimeStamped(<span class="keyword">new</span> Basic()));</span><br><span class="line">        <span class="comment">//- s2.getStamp(); // Not available</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>产生自泛型的类包含所有感兴趣的方法，但是由使用装饰器所产生的对象类型是最后被装饰的类型。也就是说，尽管可以添加多个层，但是最后一层才是实际的类型，因此只有最后一层的方法是可视的，而混型的类型是所有被混合到一起的类型。因此对于装饰器来说，其明显的缺陷是它只能有效地工作于装饰中的一层（最后一层），而混型方法显然会更自然一些。因此，装饰器只是对由混型提出的问题的一种局限的解决方案。</p><h3 id="与动态代理混合"><a href="#与动态代理混合" class="headerlink" title="与动态代理混合"></a>与动态代理混合</h3><p>可以使用动态代理来创建一种比装饰器更贴近混型模型的机制（查看 <a href="book/19-Type-Information.md">类型信息</a> 一章中关于 Java 的动态代理如何工作的解释）。通过使用动态代理，所产生的类的动态类型将会是已经混入的组合类型。<br>由于动态代理的限制，每个被混入的类都必须是某个接口的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/DynamicProxyMixin.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> onjava.Tuple.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MixinProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; delegatesByMethod;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    MixinProxy(Tuple2&lt;Object, Class&lt;?&gt;&gt;... pairs) &#123;</span><br><span class="line">        delegatesByMethod = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Tuple2&lt;Object, Class&lt;?&gt;&gt; pair : pairs) &#123;</span><br><span class="line">            <span class="keyword">for</span>(Method method : pair.a2.getMethods()) &#123;</span><br><span class="line">                String methodName = method.getName();</span><br><span class="line">                <span class="comment">// The first interface in the map</span></span><br><span class="line">                <span class="comment">// implements the method.</span></span><br><span class="line">                <span class="keyword">if</span>(!delegatesByMethod.containsKey(methodName))</span><br><span class="line">                    delegatesByMethod.put(methodName, pair.a1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method,</span></span></span><br><span class="line"><span class="function"><span class="params">      Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        String methodName = method.getName();</span><br><span class="line">        Object delegate = delegatesByMethod.get(methodName);</span><br><span class="line">        <span class="keyword">return</span> method.invoke(delegate, args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newInstance</span><span class="params">(Tuple2... pairs)</span> </span>&#123;</span><br><span class="line">        Class[] interfaces = <span class="keyword">new</span> Class[pairs.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pairs.length; i++) &#123;</span><br><span class="line">            interfaces[i] = (Class)pairs[i].a2;</span><br><span class="line">        &#125;</span><br><span class="line">        ClassLoader cl = pairs[<span class="number">0</span>].a1.getClass().getClassLoader();</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(cl, interfaces, <span class="keyword">new</span> MixinProxy(pairs));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyMixin</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object mixin = MixinProxy.newInstance(</span><br><span class="line">          tuple(<span class="keyword">new</span> BasicImp(), Basic.class),</span><br><span class="line">          tuple(<span class="keyword">new</span> TimeStampedImp(), TimeStamped.class),</span><br><span class="line">          tuple(<span class="keyword">new</span> SerialNumberedImp(), SerialNumbered.class));</span><br><span class="line">        Basic b = (Basic)mixin;</span><br><span class="line">        TimeStamped t = (TimeStamped)mixin;</span><br><span class="line">        SerialNumbered s = (SerialNumbered)mixin;</span><br><span class="line">        b.set(<span class="string">"Hello"</span>);</span><br><span class="line">        System.out.println(b.get());</span><br><span class="line">        System.out.println(t.getStamp());</span><br><span class="line">        System.out.println(s.getSerialNumber());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Hello</span></span><br><span class="line"><span class="comment">1494331653339</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>因为只有动态类型而不是静态类型才包含所有的混入类型，因此这仍旧不如 C++ 的方式好，因为可以在具有这些类型的对象上调用方法之前，我们被强制要求必须先将这些对象向下转型到恰当的类型。但是，它明显地更接近于真正的混型。<br>为了让 Java 支持混型，人们已经做了大量的工作朝着这个目标努力，包括创建了至少一种附加语言（ Jam 语言），它是专门用来支持混型的。</p><!-- Latent Typing --><h2 id="潜在类型机制"><a href="#潜在类型机制" class="headerlink" title="潜在类型机制"></a>潜在类型机制</h2><p>在本章的开头介绍过这样的思想，即要编写能够尽可能广泛地应用的代码。为了实现这一点，我们需要各种途径来放松对我们的代码将要作用的类型所作的限制，同时不丢失静态类型检查的好处。然后，我们就可以编写出无需修改就可以应用于更多情况的代码，即更加“泛化”的代码。</p><p>Java 泛型看起来是向这一方向迈进了一步。当我们在编写或使用只是持有对象的泛型时，这些代码将可以工作于任何类型（除了基本类型，尽管正如我们所见到的，自动装箱机制可以克服这一点）。或者，换个角度讲，“持有器”泛型能够声明：“我不关心我们是什么类型”。如果代码不关心它将要作用的类型，那么这种代码就可以真正地应用于任何地方，并因此而相当泛化。</p><p>还是正如我们所见到的，当要在泛型类型上执行操作（即调用 <strong>Object</strong> 方法之外的方法）时，就会产生问题。擦除强制要求指定可能会用到的泛型类型的边界，以安全地调用代码中的泛型对象上的具体方法。这是对“泛化”概念的一种明显的限制，因为必须限制我们的泛型类型，使它们继承自特定的类，或者实现特定的接口。在某些情况下，我们最终可能会使用普通类或普通接口，因为限定边界的泛型可能会和指定类或接口没有任何区别。</p><p>某些编程语言提供的一种解决方案称为<em>潜在类型机制</em>或<em>结构化类型机制</em>，而更古怪的术语称为<em>鸭子类型机制</em>，即“如果它走起来像鸭子，并且叫起来也像鸭子，那么我们就可以将它当作鸭子对待。”鸭子类型机制变成了一种相当流行的术语，可能是因为它不像其他的术语那样承载着历史的包袱。</p><p>泛型代码典型地只能在泛型类型上调用少量方法，而具有潜在类型机制的语言只要求实现某个方法子集，而不是某个特定类或接口，从而放松了这种限制（并且可以产生更加泛化的代码）。正由于此，潜在类型机制使得我们可以横跨类继承结构，调用不属于某个公共接口的方法。因此，实际上一段代码可以声明：“我不关心我们是什么类型，只要我们可以 <code>speak()</code> 和 <code>sit()</code> 即可。”由于不要求具体类型，因此代码就可以更加泛化。</p><p>潜在类型机制是一种代码组织和复用机制。有了它，编写出的代码相对于没有它编写出的代码，能够更容易地复用。代码组织和复用是所有计算机编程的基本手段：编写一次，多次使用，并在一个位置保存代码。因为我并未被要求去命名我的代码要操作于其上的确切接口，所以，有了潜在类型机制，我就可以编写更少的代码，并更容易地将其应用于多个地方。</p><p>支持潜在类型机制的语言包括 Python（可以从 <a href="http://www.Python.org" target="_blank" rel="noopener">www.Python.org</a> 免费下载）、C++、Ruby、SmallTalk 和 Go。Python 是动态类型语言（几乎所有的类型检查都发生在运行时），而 C++ 和 Go 是静态类型语言（类型检查发生在编译期），因此潜在类型机制不要求静态或动态类型检查。</p><h3 id="pyhton-中的潜在类型"><a href="#pyhton-中的潜在类型" class="headerlink" title="pyhton 中的潜在类型"></a>pyhton 中的潜在类型</h3><p>如果我们将上面的描述用 Python 来表示，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># generics/DogsAndRobots.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Arf!"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sit</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Sitting"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reproduce</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Robot</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Click!"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sit</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Clank!"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">oilChange</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">perform</span><span class="params">(anything)</span>:</span></span><br><span class="line">    anything.speak()</span><br><span class="line">    anything.sit()</span><br><span class="line"></span><br><span class="line">a = Dog()</span><br><span class="line">b = Robot()</span><br><span class="line">perform(a)</span><br><span class="line">perform(b)</span><br><span class="line"></span><br><span class="line">output = <span class="string">"""</span></span><br><span class="line"><span class="string">Arf!</span></span><br><span class="line"><span class="string">Sitting</span></span><br><span class="line"><span class="string">Click!</span></span><br><span class="line"><span class="string">Clank!</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>Python 使用缩进来确定作用域（因此不需要任何花括号），而冒号将表示新的作用域的开始。“<strong>#</strong>” 表示注释到行尾，就像Java中的 “ <strong>//</strong> ”。类的方法需要显式地指定 <strong>this</strong> 引用的等价物作为第一个参数，按惯例成为 <strong>self</strong> 。构造器调用不要求任何类型的“ <strong>new</strong> ”关键字，并且 Python 允许普通（非成员）函数，就像 <code>perform()</code> 所表明的那样。注意，在 <code>perform(anything)</code> 中，没有任何针对 <strong>anything</strong> 的类型，<strong>anything</strong> 只是一个标识符，它必须能够执行 <code>perform()</code> 期望它执行的操作，因此这里隐含着一个接口。但是我们从来都不必显式地写出这个接口——它是潜在的。<code>perform()</code> 不关心其参数的类型，因此我可以向它传递任何对象，只要该对象支持  <code>speak()</code> 和 <code>sit()</code> 方法。如果传递给 <code>perform()</code> 的对象不支持这些操作，那么将会得到运行时异常。</p><p>输出规定使用三重引号创建带有内嵌换行符的字符串。</p><h3 id="C-中的潜在类型"><a href="#C-中的潜在类型" class="headerlink" title="C++ 中的潜在类型"></a>C++ 中的潜在类型</h3><p>我们可以用 C++ 产生相同的效果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/DogsAndRobots.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Arf!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sitting"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reproduce</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Robot</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Click!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Clank!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">oilChange</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">perform</span>(<span class="title">T</span> <span class="title">anything</span>) &#123;</span></span><br><span class="line">    anything.speak();</span><br><span class="line">    anything.sit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Dog d;</span><br><span class="line">    Robot r;</span><br><span class="line">    perform(d);</span><br><span class="line">    perform(r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Arf!</span></span><br><span class="line"><span class="comment">Sitting</span></span><br><span class="line"><span class="comment">Click!</span></span><br><span class="line"><span class="comment">Clank!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在 Python 和 C++ 中，<strong>Dog</strong> 和 <strong>Robot</strong> 没有任何共同的东西，只是碰巧有两个方法具有相同的签名。从类型的观点看，它们是完全不同的类型。但是，<code>perform()</code> 不关心其参数的具体类型，并且潜在类型机制允许它接受这两种类型的对象。<br>C++ 确保了它实际上可以发送的那些消息，如果试图传递错误类型，编译器就会给我们一个错误消息（这些错误消息从历史上看是相当可怕和冗长的，是 C++ 的模版名声欠佳的主要原因）。尽管它们是在不同时期实现这一点的，C++ 在编译期，而 Python 在运行时，但是这两种语言都可以确保类型不会被误用，因此被认为是强类型的。潜在类型机制没有损害强类型机制。</p><h3 id="Go-中的潜在类型"><a href="#Go-中的潜在类型" class="headerlink" title="Go 中的潜在类型"></a>Go 中的潜在类型</h3><p>这里用 Go 语言编写相同的程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/dogsandrobots.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this Dog)</span> <span class="title">speak</span><span class="params">()</span></span> &#123; fmt.Printf(<span class="string">"Arf!\n"</span>)&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this Dog)</span> <span class="title">sit</span><span class="params">()</span></span> &#123; fmt.Printf(<span class="string">"Sitting\n"</span>)&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this Dog)</span> <span class="title">reproduce</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Robot <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this Robot)</span> <span class="title">speak</span><span class="params">()</span></span> &#123; fmt.Printf(<span class="string">"Click!\n"</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this Robot)</span> <span class="title">sit</span><span class="params">()</span></span> &#123; fmt.Printf(<span class="string">"Clank!\n"</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this Robot)</span> <span class="title">oilChange</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">perform</span><span class="params">(speaker <span class="keyword">interface</span> &#123; speak()</span>; <span class="title">sit</span><span class="params">()</span> &#125;)</span> &#123;</span><br><span class="line">  speaker.speak();</span><br><span class="line">  speaker.sit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  perform(Dog&#123;&#125;)</span><br><span class="line">  perform(Robot&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Arf!</span></span><br><span class="line"><span class="comment">Sitting</span></span><br><span class="line"><span class="comment">Click!</span></span><br><span class="line"><span class="comment">Clank!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>Go 没有 <strong>class</strong> 关键字，但是可以使用上述形式创建等效的基本类：它通常不定义为类，而是定义为 <strong>struct</strong> ，在其中定义数据字段（此处不存在）。 对于每种方法，都以 <strong>func</strong> 关键字开头，然后（为了将该方法附加到您的类上）放在括号中，该括号包含对象引用，该对象引用可以是任何标识符，但是我在这里使用 <strong>this</strong> 来提醒您，就像在 C ++ 或 Java 中的 <strong>this</strong> 一样。 然后，在Go中像这样定义其余的函数。</p><p>Go也没有继承关系，因此这种“面向对象的目标”形式是相对原始的，并且可能是我无法花更多的时间来学习该语言的主要原因。 但是，Go 的组成很简单。</p><p><code>perform()</code> 函数使用潜在类型：参数的确切类型并不重要，只要它包含了 <code>speak()</code> 和  <code>sit()</code> 方法即可。 该接口在此处匿名定义，内联，如 <code>perform()</code> 的参数列表所示。</p><p><code>main()</code> 证明 <code>perform()</code> 确实对其参数的确切类型不在乎，只要可以在该参数上调用 <code>talk()</code> 和 <code>sit()</code> 即可。 但是，就像 C ++ 模板函数一样，在编译时检查类型。</p><p>语法 <strong>Dog {}</strong> 和 <strong>Robot {}</strong> 创建匿名的 <strong>Dog</strong> 和 <strong>Robot</strong> 结构。</p><h3 id="java中的直接潜在类型"><a href="#java中的直接潜在类型" class="headerlink" title="java中的直接潜在类型"></a>java中的直接潜在类型</h3><p>因为泛型是在这场竞赛的后期才添加到 Java 中，因此没有任何机会可以去实现任何类型的潜在类型机制，因此 Java 没有对这种特性的支持。所以，初看起来，Java 的泛型机制比支持潜在类型机制的语言更“缺乏泛化性”。（使用擦除来实现 Java 泛型的实现有时称为第二类泛型类型）例如，在 Java 8  之前如果我们试图用 Java 实现上面 dogs-and-robots 的示例，那么就会被强制要求使用一个类或接口，并在边界表达式中指定它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Performs.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Performs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/DogsAndRobots.java</span></span><br><span class="line"><span class="comment">// No (direct) latent typing in Java</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PerformingDog</span> <span class="keyword">extends</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Performs</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Woof!"</span>); &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Sitting"</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reproduce</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Robot</span> <span class="keyword">implements</span> <span class="title">Performs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Click!"</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Clank!"</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oilChange</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Communicate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Performs&gt;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">perform</span><span class="params">(T performer)</span> </span>&#123;</span><br><span class="line">        performer.speak();</span><br><span class="line">        performer.sit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DogsAndRobots</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Communicate.perform(<span class="keyword">new</span> PerformingDog());</span><br><span class="line">        Communicate.perform(<span class="keyword">new</span> Robot());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Woof!</span></span><br><span class="line"><span class="comment">Sitting</span></span><br><span class="line"><span class="comment">Click!</span></span><br><span class="line"><span class="comment">Clank!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>但是要注意，<code>perform()</code> 不需要使用泛型来工作，它可以被简单地指定为接受一个 <strong>Performs</strong> 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/SimpleDogsAndRobots.java</span></span><br><span class="line"><span class="comment">// Removing the generic; code still works</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommunicateSimply</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perform</span><span class="params">(Performs performer)</span> </span>&#123;</span><br><span class="line">        performer.speak();</span><br><span class="line">        performer.sit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDogsAndRobots</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CommunicateSimply.perform(<span class="keyword">new</span> PerformingDog());</span><br><span class="line">        CommunicateSimply.perform(<span class="keyword">new</span> Robot());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Woof!</span></span><br><span class="line"><span class="comment">Sitting</span></span><br><span class="line"><span class="comment">Click!</span></span><br><span class="line"><span class="comment">Clank!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在本例中，泛型不是必需的，因为这些类已经被强制要求实现 <strong>Performs</strong> 接口。</p><!-- Compensating for the Lack of (Direct) Latent --><h2 id="对缺乏潜在类型机制的补偿"><a href="#对缺乏潜在类型机制的补偿" class="headerlink" title="对缺乏潜在类型机制的补偿"></a>对缺乏潜在类型机制的补偿</h2><p>尽管 Java 不直接支持潜在类型机制，但是这并不意味着泛型代码不能在不同的类型层次结构之间应用。也就是说，我们仍旧可以创建真正的泛型代码，但是这需要付出一些额外的努力。</p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>可以使用的一种方式是反射，下面的 <code>perform()</code> 方法就是用了潜在类型机制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/LatentReflection.java</span></span><br><span class="line"><span class="comment">// Using reflection for latent typing</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Does not implement Performs:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mime</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walkAgainstTheWind</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Pretending to sit"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushInvisibleWalls</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Mime"</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Does not implement Performs:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartDog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Woof!"</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Sitting"</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reproduce</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommunicateReflectively</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perform</span><span class="params">(Object speaker)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; spkr = speaker.getClass();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Method speak = spkr.getMethod(<span class="string">"speak"</span>);</span><br><span class="line">                speak.invoke(speaker);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(NoSuchMethodException e) &#123;</span><br><span class="line">                System.out.println(speaker + <span class="string">" cannot speak"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Method sit = spkr.getMethod(<span class="string">"sit"</span>);</span><br><span class="line">                sit.invoke(speaker);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(NoSuchMethodException e) &#123;</span><br><span class="line">                System.out.println(speaker + <span class="string">" cannot sit"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(SecurityException |</span><br><span class="line">            IllegalAccessException |</span><br><span class="line">            IllegalArgumentException |</span><br><span class="line">            InvocationTargetException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(speaker.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LatentReflection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CommunicateReflectively.perform(<span class="keyword">new</span> SmartDog());</span><br><span class="line">        CommunicateReflectively.perform(<span class="keyword">new</span> Robot());</span><br><span class="line">        CommunicateReflectively.perform(<span class="keyword">new</span> Mime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Woof!</span></span><br><span class="line"><span class="comment">Sitting</span></span><br><span class="line"><span class="comment">Click!</span></span><br><span class="line"><span class="comment">Clank!</span></span><br><span class="line"><span class="comment">Mime cannot speak</span></span><br><span class="line"><span class="comment">Pretending to sit</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>上例中，这些类完全是彼此分离的，没有任何公共基类（除了 <strong>Object</strong> ）或接口。通过反射, <code>CommunicateReflectively.perform()</code> 能够动态地确定所需要的方法是否可用并调用它们。它甚至能够处理 <strong>Mime</strong> 只具有一个必需的方法这一事实，并能够部分实现其目标。</p><h3 id="将一个方法应用于序列"><a href="#将一个方法应用于序列" class="headerlink" title="将一个方法应用于序列"></a>将一个方法应用于序列</h3><p>反射提供了一些有用的可能性，但是它将所有的类型检查都转移到了运行时，因此在许多情况下并不是我们所希望的。如果能够实现编译期类型检查，这通常会更符合要求。但是有可能实现编译期类型检查和潜在类型机制吗？</p><p>让我们看一个说明这个问题的示例。假设想要创建一个 <code>apply()</code> 方法，它能够将任何方法应用于某个序列中的所有对象。这种情况下使用接口不适合，因为我们想要将任何方法应用于一个对象集合，而接口不可能描述任何方法。如何用 Java 来实现这个需求呢？</p><p>最初，我们可以用反射来解决这个问题，由于有了 Java 的可变参数，这种方式被证明是相当优雅的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Apply.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apply</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, S extends Iterable&lt;T&gt;&gt;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(S seq, Method f, Object... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(T t: seq)</span><br><span class="line">                f.invoke(t, args);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IllegalAccessException |</span><br><span class="line">            IllegalArgumentException |</span><br><span class="line">            InvocationTargetException e) &#123;</span><br><span class="line">            <span class="comment">// Failures are programmer errors</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <strong>Apply.java</strong> 中，异常被转换为 <strong>RuntimeException</strong> ，因为没有多少办法可以从这种异常中恢复——在这种情况下，它们实际上代表着程序员的错误。</p><p>为什么我们不只使用 Java 8 方法参考（稍后显示）而不是反射方法 <strong>f</strong> ？ 注意，<code>invoke()</code> 和 <code>apply()</code> 的优点是它们可以接受任意数量的参数。 在某些情况下，灵活性可能至关重要。</p><p>为了测试 <strong>Apply</strong> ，我们首先创建一个 <strong>Shape</strong> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Shape.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getSimpleName() + <span class="string">" "</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span> + <span class="string">" rotate"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newSize)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span> + <span class="string">" resize "</span> + newSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被一个子类 <strong>Square</strong> 继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Square.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>通过这些，我们可以测试 <strong>Apply</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ApplyTest.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplyTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;Shape&gt; shapes =</span><br><span class="line">          Suppliers.create(ArrayList::<span class="keyword">new</span>, Shape::<span class="keyword">new</span>, <span class="number">3</span>);</span><br><span class="line">        Apply.apply(shapes, Shape.class.getMethod(<span class="string">"rotate"</span>));</span><br><span class="line">        Apply.apply(shapes, Shape.class.getMethod(<span class="string">"resize"</span>, <span class="keyword">int</span>.class), <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Square&gt; squares =</span><br><span class="line">          Suppliers.create(ArrayList::<span class="keyword">new</span>, Square::<span class="keyword">new</span>, <span class="number">3</span>);</span><br><span class="line">        Apply.apply(squares, Shape.class.getMethod(<span class="string">"rotate"</span>));</span><br><span class="line">        Apply.apply(squares, Shape.class.getMethod(<span class="string">"resize"</span>, <span class="keyword">int</span>.class), <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        Apply.apply(<span class="keyword">new</span> FilledList&lt;&gt;(Shape::<span class="keyword">new</span>, <span class="number">3</span>),</span><br><span class="line">          Shape.class.getMethod(<span class="string">"rotate"</span>));</span><br><span class="line">        Apply.apply(<span class="keyword">new</span> FilledList&lt;&gt;(Square::<span class="keyword">new</span>, <span class="number">3</span>),</span><br><span class="line">          Shape.class.getMethod(<span class="string">"rotate"</span>));</span><br><span class="line"></span><br><span class="line">        SimpleQueue&lt;Shape&gt; shapeQ = Suppliers.fill(</span><br><span class="line">          <span class="keyword">new</span> SimpleQueue&lt;&gt;(), SimpleQueue::add,</span><br><span class="line">          Shape::<span class="keyword">new</span>, <span class="number">3</span>);</span><br><span class="line">        Suppliers.fill(shapeQ, SimpleQueue::add,</span><br><span class="line">          Square::<span class="keyword">new</span>, <span class="number">3</span>);</span><br><span class="line">        Apply.apply(shapeQ, Shape.class.getMethod(<span class="string">"rotate"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Shape 0 rotate</span></span><br><span class="line"><span class="comment">Shape 1 rotate</span></span><br><span class="line"><span class="comment">Shape 2 rotate</span></span><br><span class="line"><span class="comment">Shape 0 resize 7</span></span><br><span class="line"><span class="comment">Shape 1 resize 7</span></span><br><span class="line"><span class="comment">Shape 2 resize 7</span></span><br><span class="line"><span class="comment">Square 3 rotate</span></span><br><span class="line"><span class="comment">Square 4 rotate</span></span><br><span class="line"><span class="comment">Square 5 rotate</span></span><br><span class="line"><span class="comment">Square 3 resize 7</span></span><br><span class="line"><span class="comment">Square 4 resize 7</span></span><br><span class="line"><span class="comment">Square 5 resize 7</span></span><br><span class="line"><span class="comment">Shape 6 rotate</span></span><br><span class="line"><span class="comment">Shape 7 rotate</span></span><br><span class="line"><span class="comment">Shape 8 rotate</span></span><br><span class="line"><span class="comment">Square 9 rotate</span></span><br><span class="line"><span class="comment">Square 10 rotate</span></span><br><span class="line"><span class="comment">Square 11 rotate</span></span><br><span class="line"><span class="comment">Shape 12 rotate</span></span><br><span class="line"><span class="comment">Shape 13 rotate</span></span><br><span class="line"><span class="comment">Shape 14 rotate</span></span><br><span class="line"><span class="comment">Square 15 rotate</span></span><br><span class="line"><span class="comment">Square 16 rotate</span></span><br><span class="line"><span class="comment">Square 17 rotate</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在 <strong>Apply</strong> 中，我们运气很好，因为碰巧在 Java 中内建了一个由 Java 集合类库使用的 <strong>Iterable</strong> 接口。正由于此， <code>apply()</code> 方法可以接受任何实现了 <strong>Iterable</strong> 接口的事物，包括诸如 <strong>List</strong> 这样的所有 <strong>Collection</strong> 类。但是它还可以接受其他任何事物，只要能够使这些事物是 <strong>Iterable</strong> 的——例如，在 <code>main()</code> 中使用下面定义的 <strong>SimpleQueue</strong> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/SimpleQueue.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A different kind of Iterable collection</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleQueue</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;T&gt; storage = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span> </span>&#123; storage.offer(t); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> storage.poll(); &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> storage.iterator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如反射解决方案看起来那样优雅，我们必须观察到反射（尽管在 Java 的最新版本中得到了显着改进）通常比非反射实现要慢，因为在运行时发生了很多事情。 但它不应阻止您尝试这种解决方案，这依然是值得考虑的一点。</p><p>几乎可以肯定，我们会首先使用 Java 8 的函数式方法，并且只有在解决了特殊需求时才诉诸反射。 这里对 <strong>ApplyTest.java</strong> 进行了重写，以利用 Java 8 的流和函数工具：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ApplyFunctional.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplyFunctional</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream.of(</span><br><span class="line">          Stream.generate(Shape::<span class="keyword">new</span>).limit(<span class="number">2</span>),</span><br><span class="line">          Stream.generate(Square::<span class="keyword">new</span>).limit(<span class="number">2</span>))</span><br><span class="line">        .flatMap(c -&gt; c) <span class="comment">// flatten into one stream</span></span><br><span class="line">        .peek(Shape::rotate)</span><br><span class="line">        .forEach(s -&gt; s.resize(<span class="number">7</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> FilledList&lt;&gt;(Shape::<span class="keyword">new</span>, <span class="number">2</span>)</span><br><span class="line">          .forEach(Shape::rotate);</span><br><span class="line">        <span class="keyword">new</span> FilledList&lt;&gt;(Square::<span class="keyword">new</span>, <span class="number">2</span>)</span><br><span class="line">          .forEach(Shape::rotate);</span><br><span class="line"></span><br><span class="line">        SimpleQueue&lt;Shape&gt; shapeQ = Suppliers.fill(</span><br><span class="line">          <span class="keyword">new</span> SimpleQueue&lt;&gt;(), SimpleQueue::add,</span><br><span class="line">          Shape::<span class="keyword">new</span>, <span class="number">2</span>);</span><br><span class="line">        Suppliers.fill(shapeQ, SimpleQueue::add,</span><br><span class="line">          Square::<span class="keyword">new</span>, <span class="number">2</span>);</span><br><span class="line">        shapeQ.forEach(Shape::rotate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Shape 0 rotate</span></span><br><span class="line"><span class="comment">Shape 0 resize 7</span></span><br><span class="line"><span class="comment">Shape 1 rotate</span></span><br><span class="line"><span class="comment">Shape 1 resize 7</span></span><br><span class="line"><span class="comment">Square 2 rotate</span></span><br><span class="line"><span class="comment">Square 2 resize 7</span></span><br><span class="line"><span class="comment">Square 3 rotate</span></span><br><span class="line"><span class="comment">Square 3 resize 7</span></span><br><span class="line"><span class="comment">Shape 4 rotate</span></span><br><span class="line"><span class="comment">Shape 5 rotate</span></span><br><span class="line"><span class="comment">Square 6 rotate</span></span><br><span class="line"><span class="comment">Square 7 rotate</span></span><br><span class="line"><span class="comment">Shape 8 rotate</span></span><br><span class="line"><span class="comment">Shape 9 rotate</span></span><br><span class="line"><span class="comment">Square 10 rotate</span></span><br><span class="line"><span class="comment">Square 11 rotate</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>由于使用 Java 8，因此不需要 <code>Apply.apply()</code> 。</p><p>我们首先生成两个 <strong>Stream</strong> ： 一个是 <strong>Shape</strong> ，一个是 <strong>Square</strong> ，并将它们展平为单个流。 尽管 Java 缺少功能语言中经常出现的 <code>flatten()</code> ，但是我们可以使用 <code>flatMap(c-&gt; c)</code> 产生相同的结果，后者使用身份映射将操作简化为“  <strong>flatten</strong> ”。</p><p>我们使用 <code>peek()</code> 当做对 <code>rotate()</code> 的调用，因为 <code>peek()</code> 执行一个操作（此处是出于副作用），并在未更改的情况下传递对象。</p><p>注意，使用 <strong>FilledList</strong> 和 <strong>shapeQ</strong> 调用 <code>forEach()</code> 比 <code>Apply.apply()</code> 代码整洁得多。 在代码简单性和可读性方面，结果比以前的方法好得多。 并且，现在也不可能从  <code>main()</code> 引发异常。</p><!-- Assisted Latent Typing in Java 8 --><h2 id="Java8-中的辅助潜在类型"><a href="#Java8-中的辅助潜在类型" class="headerlink" title="Java8 中的辅助潜在类型"></a>Java8 中的辅助潜在类型</h2><p>先前声明关于 Java 缺乏对潜在类型的支持在 Java 8 之前是完全正确的。但是，Java 8 中的非绑定方法引用使我们能够产生一种潜在类型的形式，以满足创建一段可工作在不相干类型上的代码。因为 Java 最初并不是如此设计，所以结果可想而知，比其他语言中要尴尬一些。但是，至少现在成为了可能，只是缺乏令人惊艳之处。</p><p>我在其他地方从没遇过这种技术，因此我将其称为辅助潜在类型。</p><p>我们将重写 <strong>DogsAndRobots.java</strong> 来演示该技术。 为使外观看起来与原始示例尽可能相似，我仅向每个原始类名添加了 <strong>A</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/DogsAndRobotMethodReferences.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// "Assisted Latent Typing"</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PerformingDogA</span> <span class="keyword">extends</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Woof!"</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Sitting"</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reproduce</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RobotA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Click!"</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Clank!"</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oilChange</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommunicateA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;P&gt; <span class="function"><span class="keyword">void</span> <span class="title">perform</span><span class="params">(P performer,</span></span></span><br><span class="line"><span class="function"><span class="params">      Consumer&lt;P&gt; action1, Consumer&lt;P&gt; action2)</span> </span>&#123;</span><br><span class="line">        action1.accept(performer);</span><br><span class="line">        action2.accept(performer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DogsAndRobotMethodReferences</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CommunicateA.perform(<span class="keyword">new</span> PerformingDogA(),</span><br><span class="line">          PerformingDogA::speak, PerformingDogA::sit);</span><br><span class="line">        CommunicateA.perform(<span class="keyword">new</span> RobotA(),</span><br><span class="line">          RobotA::speak, RobotA::sit);</span><br><span class="line">        CommunicateA.perform(<span class="keyword">new</span> Mime(),</span><br><span class="line">          Mime::walkAgainstTheWind,</span><br><span class="line">          Mime::pushInvisibleWalls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Woof!</span></span><br><span class="line"><span class="comment">Sitting</span></span><br><span class="line"><span class="comment">Click!</span></span><br><span class="line"><span class="comment">Clank!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>PerformingDogA</strong> 和 <strong>RobotA</strong> 与 <strong>DogsAndRobots.java</strong> 中的相同，不同之处在于它们不继承通用接口 <strong>Performs</strong> ，因此它们没有通用性。</p><p><code>CommunicateA.perform()</code> 在没有约束的 <strong>P</strong> 上生成。 只要可以使用 <code>Consumer &lt;P&gt;</code>，它在这里就可以是任何东西，这些 <code>Consumer&lt;P&gt;</code> 代表不带参数的 <strong>P</strong> 方法的未绑定方法引用。当您调用 <strong>Consumer</strong>  的 <code>accept()</code> 方法时，它将方法引用绑定到执行者对象并调用该方法。 由于 <a href="book/13-Functional-Programming.md">函数式编程</a> 一章中描述的“魔术”，我们可以将任何符合签名的未绑定方法引用传递给 <code>CommunicateA.perform()</code> 。</p><p>之所以称其为“辅助”，是因为您必须显式地为 <code>perform()</code> 提供要使用的方法引用。 它不能只按名称调用方法。</p><p>尽管传递未绑定的方法引用似乎要花很多力气，但潜在类型的最终目标还是可以实现的。 我们创建了一个代码片段 <code>CommunicateA.perform()</code> ，该代码可用于任何具有符合签名的方法引用的类型。 请注意，这与我们看到的其他语言中的潜在类型有所不同，因为这些语言不仅需要签名以符合规范，还需要方法名称。 因此，该技术可以说产生了更多的通用代码。</p><p>为了证明这一点，我还从 <strong>LatentReflection.java</strong> 中引入了 <strong>Mime</strong>。</p><h3 id="使用Suppliers类的通用方法"><a href="#使用Suppliers类的通用方法" class="headerlink" title="使用Suppliers类的通用方法"></a>使用<strong>Suppliers</strong>类的通用方法</h3><p>通过辅助潜在类型，我们可以定义本章其他部分中使用的 <strong>Suppliers</strong> 类。 此类包含使用生成器填充 <strong>Collection</strong> 的工具方法。 泛化这些操作很有意义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/Suppliers.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A utility to use with Suppliers</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Suppliers</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create a collection and fill it:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, C extends Collection&lt;T&gt;&gt; C</span><br><span class="line">      create(Supplier&lt;C&gt; factory, Supplier&lt;T&gt; gen, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">return</span> Stream.generate(gen)</span><br><span class="line">            .limit(n)</span><br><span class="line">            .collect(factory, C::add, C::addAll);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Fill an existing collection:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, C extends Collection&lt;T&gt;&gt;</span><br><span class="line">      <span class="function">C <span class="title">fill</span><span class="params">(C coll, Supplier&lt;T&gt; gen, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Stream.generate(gen)</span><br><span class="line">            .limit(n)</span><br><span class="line">            .forEach(coll::add);</span><br><span class="line">        <span class="keyword">return</span> coll;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Use an unbound method reference to</span></span><br><span class="line">    <span class="comment">// produce a more general method:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;H, A&gt; <span class="function">H <span class="title">fill</span><span class="params">(H holder,</span></span></span><br><span class="line"><span class="function"><span class="params">      BiConsumer&lt;H, A&gt; adder, Supplier&lt;A&gt; gen, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Stream.generate(gen)</span><br><span class="line">            .limit(n)</span><br><span class="line">            .forEach(a -&gt; adder.accept(holder, a));</span><br><span class="line">        <span class="keyword">return</span> holder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>create()</code> 为我们创建一个新的 <strong>Collection</strong> 子类型，而 <code>fill()</code> 的第一个版本将元素放入 <strong>Collection</strong> 的现有子类型中。 请注意，还会返回传入的容器的确切类型，因此不会丢失类型信息。</p><p>前两种方法一般都受约束，只能与 <strong>Collection</strong> 子类型一起使用。<code>fill()</code> 的第二个版本适用于任何类型的 <strong>holder</strong> 。 它需要一个附加参数：未绑定方法引用 <code>adder. fill()</code> ，使用辅助潜在类型来使其与任何具有添加元素方法的 <strong>holder</strong> 类型一起使用。因为此未绑定方法 <strong>adder</strong> 必须带有一个参数（要添加到 <strong>holder</strong> 的元素），所以 <strong>adder</strong> 必须是 <code>BiConsumer &lt;H，A&gt;</code> ，其中 <strong>H</strong> 是要绑定到的 <strong>holder</strong> 对象的类型，而 <strong>A</strong> 是要被添加的绑定元素类型。 对 <code>accept()</code> 的调用将使用参数 a 调用对象 <strong>holder</strong> 上的未绑定方法 <strong>holder</strong>。</p><p>在一个稍作模拟的测试中对 <strong>Suppliers</strong> 工具程序进行了测试，该仿真还使用了本章前面定义的 <strong>RandomList</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/BankTeller.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A very simple bank teller simulation</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Customer "</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teller</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Teller "</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;BankTeller&gt; tellers =</span><br><span class="line">        <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(BankTeller bt)</span> </span>&#123;</span><br><span class="line">        tellers.add(bt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankTeller</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serve</span><span class="params">(Teller t, Customer c)</span> </span>&#123;</span><br><span class="line">        System.out.println(t + <span class="string">" serves "</span> + c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Demonstrate create():</span></span><br><span class="line">        RandomList&lt;Teller&gt; tellers =</span><br><span class="line">            Suppliers.create(</span><br><span class="line">            RandomList::<span class="keyword">new</span>, Teller::<span class="keyword">new</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// Demonstrate fill():</span></span><br><span class="line">        List&lt;Customer&gt; customers = Suppliers.fill(</span><br><span class="line">            <span class="keyword">new</span> ArrayList&lt;&gt;(), Customer::<span class="keyword">new</span>, <span class="number">12</span>);</span><br><span class="line">        customers.forEach(c -&gt;</span><br><span class="line">            serve(tellers.select(), c));</span><br><span class="line">        <span class="comment">// Demonstrate assisted latent typing:</span></span><br><span class="line">        Bank bank = Suppliers.fill(</span><br><span class="line">            <span class="keyword">new</span> Bank(), Bank::put, BankTeller::<span class="keyword">new</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// Can also use second version of fill():</span></span><br><span class="line">        List&lt;Customer&gt; customers2 = Suppliers.fill(</span><br><span class="line">            <span class="keyword">new</span> ArrayList&lt;&gt;(),</span><br><span class="line">            List::add, Customer::<span class="keyword">new</span>, <span class="number">12</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Teller 3 serves Customer 1</span></span><br><span class="line"><span class="comment">Teller 2 serves Customer 2</span></span><br><span class="line"><span class="comment">Teller 3 serves Customer 3</span></span><br><span class="line"><span class="comment">Teller 1 serves Customer 4</span></span><br><span class="line"><span class="comment">Teller 1 serves Customer 5</span></span><br><span class="line"><span class="comment">Teller 3 serves Customer 6</span></span><br><span class="line"><span class="comment">Teller 1 serves Customer 7</span></span><br><span class="line"><span class="comment">Teller 2 serves Customer 8</span></span><br><span class="line"><span class="comment">Teller 3 serves Customer 9</span></span><br><span class="line"><span class="comment">Teller 3 serves Customer 10</span></span><br><span class="line"><span class="comment">Teller 2 serves Customer 11</span></span><br><span class="line"><span class="comment">Teller 4 serves Customer 12</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以看到 <code>create()</code> 生成一个新的 <strong>Collection</strong> 对象，而 <code>fill()</code> 添加到现有 <strong>Collection</strong> 中。第二个版本<code>fill()</code> 显示，它不仅与无关的新类型 <strong>Bank</strong> 一起使用，还能与 <strong>List</strong> 一起使用。因此，从技术上讲，<code>fill()</code> 的第一个版本在技术上不是必需的，但在使用 <strong>Collection</strong> 时提供了较短的语法。</p><!-- Summary: Is Casting Really So Bad? --><h2 id="总结：类型转换真的如此之糟吗？"><a href="#总结：类型转换真的如此之糟吗？" class="headerlink" title="总结：类型转换真的如此之糟吗？"></a>总结：类型转换真的如此之糟吗？</h2><p>自从 C++ 模版出现以来，我就一直在致力于解释它，我可能比大多数人都更早地提出了下面的论点。直到最近，我才停下来，去思考这个论点到底在多少时间内是有效的——我将要描述的问题到底有多少次可以穿越障碍得以解决。</p><p>这个论点就是：使用泛型类型机制的最吸引人的地方，就是在使用集合类的地方，这些类包括诸如各种 <strong>List</strong> 、各种 <strong>Set</strong> 、各种 <strong>Map</strong> 等我们在 <a href="book/12-Collections.md">集合</a> 和 <a href="book/Appendix-Collection-Topics.md">附录：集合主题</a> 这两章所见。在 Java 5 之前，当我们将一个对象放置到集合中时，这个对象就会被向上转型为 <strong>Object</strong> ，因此我们会丢失类型信息。当我们想要将这个对象从集合中取回，用它去执行某些操作时，必须将其向下转型回正确的类型。我用的示例是持有 <strong>Cat</strong> 的 <strong>List</strong> （这个示例的一种使用苹果和桔子的变体在 <a href="book/12-Collections.md">集合</a> 章节的开头展示过）。如果没有 Java 5 泛型版本的集合，我们放到容集里和从集合中取回的都是 <strong>Object</strong> 。因此，我们很可能会将一个 <strong>Dog</strong> 放置到 <strong>Cat</strong> 的 <strong>List</strong> 中。</p><p>但是，泛型出现之前的 Java 并不会让我们误用放入到集合中的对象。如果将一个 <strong>Dog</strong> 扔到 <strong>Cat</strong> 的集合中，并且试图将这个集合中的所有东西都当作 <strong>Cat</strong> 处理，那么当我们从这个 <strong>Cat</strong> 集合中取回那个 <strong>Dog</strong> 引用，并试图将其转型为 <strong>Cat</strong> 时，就会得到一个 <strong>RuntimeException</strong> 。我们仍旧可以发现问题，但是是在运行时而非编译期发现它的。</p><p>在本书以前的版本中，我曾经说过：</p><blockquote><p>这不止令人恼火，它还可能会产生难以发现的缺陷。如果这个程序的某个部分（或数个部分）向集合中插入了对象，并且通过异常，我们在程序的另一个独立的部分中发现有不良对象被放置到了集合中，那么必须发现这个不良插入到底是在何处发生的。</p></blockquote><p>但是，随着对这个论点的进一步检查，我开始怀疑它了。首先，这会多么频繁地发生呢？我记得这类事情从未发生在我身上，并且当我在会议上询问其他人时，我也从来没有听说过有人碰上过。另一本书使用了一个称为 <strong>files</strong> 的 list 示例，它包含 <strong>String</strong> 对象。在这个示例中，向 <strong>files</strong> 中添加一个 <strong>File</strong> 对象看起来相当自然，因此这个对象的名字可能叫 <strong>fileNames</strong> 更好。无论 Java 提供了多少类型检查，仍旧可能会写出晦涩的程序，而编写差劲儿的程序即便可以编译，它仍旧是编写差劲儿的程序。可能大多数人都会使用命名良好的集合，例如 <strong>cats</strong> ，因为它们可以向试图添加非 <strong>Cat</strong> 对象的程序员提供可视的警告。并且即便这类事情发生了，它真正又能潜伏多久呢？只要我们开始用真实数据来运行测试，就会非常快地看到异常。</p><p>有一位作者甚至断言，这样的缺陷将“<em>潜伏数年</em>”。但是我不记得有任何大量的相关报告，来说明人们在查找“狗在猫列表中”这类缺陷时困难重重，或者是说明人们会非常频繁地产生这种错误。然而，我们将在 <a href="book/24-Concurrent-Programming.md">多线程编程</a> 章节中看到，在使用线程时，出现那些可能看起来极罕见的缺陷，是很寻常并容易发生的事，而且，对于到底出了什么错，这些缺陷只能给我们一个很模糊的概念。因此，对于泛型是添加到 Java 中的非常显著和相当复杂的特性这一点，“狗在猫列表中”这个论据真的能够成为它的理由吗？<br>我相信被称为<em>泛型</em>的通用语言特性（并非必须是其在 Java 中的特定实现）的目的在于可表达性，而不仅仅是为了创建类型安全的集合。类型安全的集合是能够创建更通用代码这一能力所带来的副作用。<br>因此，即便“狗在猫列表中”这个论据经常被用来证明泛型是必要的，但是它仍旧是有问题的。就像我在本章开头声称的，我不相信这就是泛型这个概念真正的含义。相反，泛型正如其名称所暗示的：它是一种方法，通过它可以编写出更“泛化”的代码，这些代码对于它们能够作用的类型具有更少的限制，因此单个的代码段可以应用到更多的类型上。正如我们在本章中看到的，编写真正泛化的“持有器”类（ Java 的容器就是这种类）相当简单，但是编写出能够操作其泛型类型的泛化代码就需要额外的努力了，这些努力需要类创建者和类消费者共同付出，他们必须理解这些代码的概念和实现。这些额外的努力会增加使用这种特性的难度，并可能会因此而使其在某些场合缺乏可应用性，而在这些场合中，它可能会带来附加的价值。</p><p>还要注意到，因为泛型是后来添加到 Java 中，而不是从一开始就设计到这种语言中的，所以某些容器无法达到它们应该具备的健壮性。例如，观察一下 <strong>Map</strong> ，在特定的方法 <code>containsKey(Object key)</code>和 <code>get(Object key)</code> 中就包含这类情况。如果这些类是使用在它们之前就存在的泛型设计的，那么这些方法将会使用参数化类型而不是 <strong>Object</strong> ，因此也就可以提供这些泛型假设会提供的编译期检查。例如，在 C++ 的 <strong>map</strong> 中，键的类型总是在编译期检查的。</p><p>有一件事很明显：在一种语言已经被广泛应用之后，在其较新的版本中引入任何种类的泛型机制，都会是一项非常非常棘手的任务，并且是一项不付出艰辛就无法完成的任务。在 C++ 中，模版是在其最初的 ISO 版本中就引入的（即便如此，也引发了阵痛，因为在第一个标准 C++ 出现之前，有很多非模版版本在使用），因此实际上模版一直都是这种语言的一部分。在 Java 中，泛型是在这种语言首次发布大约 10 年之后才引入的，因此向泛型迁移的问题特别多，并且对泛型的设计产生了明显的影响。其结果就是，程序员将承受这些痛苦，而这一切都是由于 Java 设计者在设计 1.0 版本时所表现出来的短视造成的。当 Java 最初被创建时，它的设计者们当然了解 C++ 的模版，他们甚至考虑将其囊括到 Java 语言中，但是出于这样或那样的原因，他们决定将模版排除在外（其迹象就是他们过于匆忙）。因此， Java 语言和使用它的程序员都将承受这些痛苦。只有时间将会说明 Java 的泛型方式对这种语言所造成的最终影响。<br>某些语言，已经融入了更简洁、影响更小的方式，来实现参数化类型。我们不可能不去想象这样的语言将会成为 Java 的继任者，因为它们采用的方式，与 C++ 通过 C 来实现的方式相同：按原样使用它，然后对其进行改进。</p><h2 id="进阶阅读"><a href="#进阶阅读" class="headerlink" title="进阶阅读"></a>进阶阅读</h2><p>泛型的入门文档是 《Generics in the Java Programming Language》，作者是 Gilad Bracha，可以从 <a href="http://java.oracle.com" target="_blank" rel="noopener">http://java.oracle.com</a> 获取。</p><p>Angelika Langer 的《Java Generics FAQs》是一份非常有帮助的资料，可以从 <a href="http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html" target="_blank" rel="noopener">http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html</a> 获取。</p><p>我们可以从 《Adding Wildcards to the Java Programming Language》中学到更多关于通配符的知识，作者是 Torgerson、Ernst、Hansen、von der Ahe、Bracha 和 Gafter，地址是 <a href="http://www.jot.fm/issues/issue_2004_12/article5。" target="_blank" rel="noopener">http://www.jot.fm/issues/issue_2004_12/article5。</a></p><p>Neal After 对于 Java 问题（尤其是擦除）的看法可以从这里找到：<a href="http://www.infoq.com/articles/neal-gafter-on-java。" target="_blank" rel="noopener">http://www.infoq.com/articles/neal-gafter-on-java。</a></p><!-- 分页 --><div style="page-break-after: always;"></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接口和抽象类提供了一种将接口与实现分离的更加结构化的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>79. 单词搜索</title>
    <link href="http://yoursite.com/2020/06/27/79.%20%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/"/>
    <id>http://yoursite.com/2020/06/27/79. 单词搜索/</id>
    <published>2020-06-26T17:12:12.000Z</published>
    <updated>2020-06-28T09:09:01.023Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二维网格和一个单词，找出该单词是否存在于网格中</p><a id="more"></a><p>这道题已经做过两次，这次决定完全不看提示自己写，做到晚上三点多还是有小问题，静下心调试了一次才彻底解决。更精简版的官方解法可以见<a href="https://leetcode-cn.com/problems/word-search/solution/zai-er-wei-ping-mian-shang-shi-yong-hui-su-fa-pyth/" target="_blank" rel="noopener">^1</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p>示例:</p><pre><code>board =[  [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;],  [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;],  [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]]给定 word = &quot;ABCCED&quot;, 返回 true给定 word = &quot;SEE&quot;, 返回 true给定 word = &quot;ABCB&quot;, 返回 false</code></pre><p>提示：</p><ul><li>board 和 word 中只包含大写和小写英文字母。</li><li>1 &lt;= board.length &lt;= 200</li><li>1 &lt;= board[i].length &lt;= 200</li><li>1 &lt;= word.length &lt;= 10^3</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>首先想到用dfs来解决：</p><h2 id="第一版代码-错误-："><a href="#第一版代码-错误-：" class="headerlink" title="第一版代码(错误)："></a>第一版代码(错误)：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean exist(char[][] board, String word) &#123;</span><br><span class="line">    if (board.length == 0 || board[0].length == 0 || board == null || word == null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean[][] visit = new boolean[board.length][board[0].length];</span><br><span class="line">    for (int i = 0; i &lt; board.length; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; board[i].length; j++) &#123;</span><br><span class="line">            if (existHelper(board, visit, word, 0, i, j)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    public boolean existHelper(char[][] board, boolean[][] visit, String s, int index, int i, int j) &#123;</span><br><span class="line">        if (i &lt; 0 || i &gt;= board.length || j &lt; 0 || j &gt;= board[i].length) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (index &lt; s.length() - 1) &#123;</span><br><span class="line">            if (s.charAt(index) == board[i][j] &amp;&amp; visit[i][j] == false) &#123;</span><br><span class="line">                visit[i][j] = true;</span><br><span class="line">                return existHelper(board, visit, s, index + 1, i - 1, j) || existHelper(board, visit, s, index + 1, i + 1, j) || existHelper(board, visit, s, index + 1, i, j - 1) || existHelper(board, visit, s, index + 1, i, j + 1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (s.charAt(index) == board[i][j] &amp;&amp; visit[i][j] == false) &#123;</span><br><span class="line">                visit[i][j] = true;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                visit[i][j] = false;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//total_testcases:89</span><br><span class="line">//total_correct:80</span><br><span class="line">//input_formatted:[[&quot;C&quot;,&quot;A&quot;,&quot;A&quot;],[&quot;A&quot;,&quot;A&quot;,&quot;A&quot;],[&quot;B&quot;,&quot;C&quot;,&quot;D&quot;]], &quot;AAB&quot;</span><br><span class="line">//expected_output:true</span><br><span class="line">//code_output:false</span><br></pre></td></tr></table></figure><p>错误原因，因为没有每次开始访问都初始化visit数组，所以把visit数组的初始化放到每次开始遍历的前面，即：</p><h2 id="第二版代码（错误）"><a href="#第二版代码（错误）" class="headerlink" title="第二版代码（错误）"></a>第二版代码（错误）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean exist(char[][] board, String word) &#123;</span><br><span class="line">    if (board.length == 0 || board[0].length == 0 || board == null || word == null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; board.length; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; board[i].length; j++) &#123;</span><br><span class="line">            boolean[][] visit = new boolean[board.length][board[0].length];</span><br><span class="line">            if (existHelper(board, visit, word, 0, i, j)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean existHelper(char[][] board, boolean[][] visit, String s, int index, int i, int j) &#123;</span><br><span class="line">        if (i &lt; 0 || i &gt;= board.length || j &lt; 0 || j &gt;= board[i].length) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (index &lt; s.length() - 1) &#123;</span><br><span class="line">            if (s.charAt(index) == board[i][j] &amp;&amp; visit[i][j] == false) &#123;</span><br><span class="line">                visit[i][j] = true;</span><br><span class="line">                return existHelper(board, visit, s, index + 1, i - 1, j) || existHelper(board, visit, s, index + 1, i + 1, j) || existHelper(board, visit, s, index + 1, i, j - 1) || existHelper(board, visit, s, index + 1, i, j + 1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (s.charAt(index) == board[i][j] &amp;&amp; visit[i][j] == false) &#123;</span><br><span class="line">                visit[i][j] = true;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                visit[i][j] = false;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//total_testcases:89</span><br><span class="line">//total_correct:85</span><br><span class="line">//input_formatted:[[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;E&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], &quot;ABCESEEEFS&quot;</span><br><span class="line">//expected_output:true</span><br><span class="line">//code_output:false</span><br></pre></td></tr></table></figure><p>又有问题，找到第（1，3）位置的S时再找E时会将四周的E都置为true，没有在返回前将其恢复。我们简化一下代码，加入每次回溯完恢复现场的代码：</p><h2 id="第三版代码（错误）"><a href="#第三版代码（错误）" class="headerlink" title="第三版代码（错误）"></a>第三版代码（错误）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    private static int[][] dires = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;;</span><br><span class="line">    private int row, col;</span><br><span class="line">    //用于标记是否已经找到解</span><br><span class="line">    private boolean hasFind;</span><br><span class="line">    private boolean[][] visit;</span><br><span class="line"></span><br><span class="line">    public boolean exist(char[][] board, String word) &#123;</span><br><span class="line">        if (board.length == 0 || board[0].length == 0 || board == null || word == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        row = board.length;</span><br><span class="line">        col = board[0].length;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; row; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; col; j++) &#123;</span><br><span class="line">                visit = new boolean[row][col];</span><br><span class="line">                if (existHelper(board, visit, word, 0, i, j)) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean existHelper(char[][] board, boolean[][] visit, String s, int index, int i, int j) &#123;</span><br><span class="line">        if (!isIn(i, j)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (index &lt; s.length() - 1) &#123;</span><br><span class="line">            if (s.charAt(index) == board[i][j] &amp;&amp; visit[i][j] == false) &#123;</span><br><span class="line">                visit[i][j] = true;</span><br><span class="line">                boolean res1 = existHelper(board, visit, s, index + 1, i - 1, j);</span><br><span class="line">                boolean res2 = existHelper(board, visit, s, index + 1, i + 1, j);</span><br><span class="line">                boolean res3 = existHelper(board, visit, s, index + 1, i, j - 1);</span><br><span class="line">                boolean res4 = existHelper(board, visit, s, index + 1, i, j + 1);</span><br><span class="line">                //对于这个分支的DFS已经完成了，需要回溯还原现场</span><br><span class="line">                if (res1 || res2 || res3 || res4) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    visit[i][j] = false;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (s.charAt(index) == board[i][j] &amp;&amp; visit[i][j] == false) &#123;</span><br><span class="line">                visit[i][j] = true;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                visit[i][j] = false;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean isIn(int i, int j) &#123;</span><br><span class="line">        if (i &lt; 0 || i &gt;= row || j &lt; 0 || j &gt;= col) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//total_testcases:89</span><br><span class="line">//total_correct:86</span><br><span class="line">//input_formatted:[[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]], &quot;aaaaaaaaaaaaa&quot;</span><br><span class="line">//expected_output:false</span><br><span class="line">//code_output:true</span><br></pre></td></tr></table></figure><p>13个a，理论上应该返回false的，但是我没有做这种情况的判断</p><p>修改后双错了</p><h2 id="第四版代码（错误）"><a href="#第四版代码（错误）" class="headerlink" title="第四版代码（错误）"></a>第四版代码（错误）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    private static int[][] dires = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;;</span><br><span class="line">    private int row, col;</span><br><span class="line">    //用于标记是否已经找到解</span><br><span class="line">    private boolean hasFind;</span><br><span class="line">    private boolean[][] visit;</span><br><span class="line"></span><br><span class="line">    public boolean exist(char[][] board, String word) &#123;</span><br><span class="line">        if (board.length == 0 || board[0].length == 0 || board == null || word == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        row = board.length;</span><br><span class="line">        col = board[0].length;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; row; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; col; j++) &#123;</span><br><span class="line">                visit = new boolean[row][col];</span><br><span class="line">                if (existHelper(board, visit, word, 0, i, j)) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean existHelper(char[][] board, boolean[][] visit, String s, int index, int i, int j) &#123;</span><br><span class="line">        if (!isIn(i, j, s)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (index &lt; s.length() - 1) &#123;</span><br><span class="line">            if (s.charAt(index) == board[i][j] &amp;&amp; visit[i][j] == false) &#123;</span><br><span class="line">                visit[i][j] = true;</span><br><span class="line">                boolean res1 = existHelper(board, visit, s, index + 1, i - 1, j);</span><br><span class="line">                boolean res2 = existHelper(board, visit, s, index + 1, i + 1, j);</span><br><span class="line">                boolean res3 = existHelper(board, visit, s, index + 1, i, j - 1);</span><br><span class="line">                boolean res4 = existHelper(board, visit, s, index + 1, i, j + 1);</span><br><span class="line">                //对于这个分支的DFS已经完成了，需要回溯还原现场</span><br><span class="line">                if (res1 || res2 || res3 || res4) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    visit[i][j] = false;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (s.charAt(index) == board[i][j] &amp;&amp; visit[i][j] == false) &#123;</span><br><span class="line">                visit[i][j] = true;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                visit[i][j] = false;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean isIn(int i, int j, String s) &#123;</span><br><span class="line">        if (i &lt; 0 || i &gt;= row || j &lt; 0 || j &gt;= col || col * row &lt; s.length()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//total_testcases:89</span><br><span class="line">//total_correct:87</span><br><span class="line">//input_formatted:[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;a&quot;],[&quot;b&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;a&quot;,&quot;b&quot;,&quot;a&quot;],[&quot;b&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]], &quot;bbbaabbbbbab&quot;</span><br><span class="line">//expected_output:false</span><br><span class="line">//code_output:true</span><br></pre></td></tr></table></figure><p>叒错了，这次调试后发现是到最后一步时dfs回退时把本为true的visit数组元素置为了false，为了避免叕错，把最后一步处理的置为false的代码去掉终于可以通过了，泪牛满面呜呜呜。</p><h2 id="第五版代码（正确）"><a href="#第五版代码（正确）" class="headerlink" title="第五版代码（正确）"></a>第五版代码（正确）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    private static int[][] dires = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;;</span><br><span class="line">    private int row, col;</span><br><span class="line">    private boolean[][] visit;</span><br><span class="line"></span><br><span class="line">    public boolean exist(char[][] board, String word) &#123;</span><br><span class="line">        if (board.length == 0 || board[0].length == 0 || board == null || word == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        row = board.length;</span><br><span class="line">        col = board[0].length;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; row; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; col; j++) &#123;</span><br><span class="line">                visit = new boolean[row][col];</span><br><span class="line">                if (existHelper(board, visit, word, 0, i, j)) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean existHelper(char[][] board, boolean[][] visit, String s, int index, int i, int j) &#123;</span><br><span class="line">        if (!isIn(i, j)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (index &lt; s.length() - 1) &#123;</span><br><span class="line">            if (s.charAt(index) == board[i][j] &amp;&amp; visit[i][j] == false) &#123;</span><br><span class="line">                visit[i][j] = true;</span><br><span class="line">                boolean res1 = existHelper(board, visit, s, index + 1, i - 1, j);</span><br><span class="line">                boolean res2 = existHelper(board, visit, s, index + 1, i + 1, j);</span><br><span class="line">                boolean res3 = existHelper(board, visit, s, index + 1, i, j - 1);</span><br><span class="line">                boolean res4 = existHelper(board, visit, s, index + 1, i, j + 1);</span><br><span class="line">                //对于这个分支的DFS已经完成了，需要回溯还原现场</span><br><span class="line">                if (res1 || res2 || res3 || res4) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    visit[i][j] = false;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (s.charAt(index) == board[i][j] &amp;&amp; visit[i][j] == false ) &#123;</span><br><span class="line">                visit[i][j] = true;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean isIn(int i, int j) &#123;</span><br><span class="line">        if (i &lt; 0 || i &gt;= row || j &lt; 0 || j &gt;= col) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个二维网格和一个单词，找出该单词是否存在于网格中&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>Java之数组</title>
    <link href="http://yoursite.com/2020/06/26/Java%E4%B9%8B%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2020/06/26/Java之数组/</id>
    <published>2020-06-26T11:30:12.000Z</published>
    <updated>2020-06-28T09:09:07.167Z</updated>
    
    <content type="html"><![CDATA[<p>数组对于每一门编程语言来说都是重要的数据结构之一，当然不同语言对数组的实现及处理也不尽相同。</p><p>Java 语言中提供的数组是用来存储固定大小的同类型元素。</p><a id="more"></a><h2 id="声明数组变量"><a href="#声明数组变量" class="headerlink" title="声明数组变量"></a>声明数组变量</h2><p>首先必须声明数组变量，才能在程序中使用数组。下面是声明数组变量的语法：</p><pre><code>dataType[] arrayRefVar;   // 首选的方法</code></pre><p>或</p><pre><code>dataType arrayRefVar[];  // 效果相同，但不是首选方法</code></pre><p>注意: 建议使用 dataType[] arrayRefVar 的声明风格声明数组变量。 dataType arrayRefVar[] 风格是来自 C/C++ 语言 ，在Java中采用是为了让 C/C++ 程序员能够快速理解java语言。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>下面是这两种语法的代码示例：</p><pre><code>double[] myList;         // 首选的方法</code></pre><p>或</p><pre><code>double myList[];         //  效果相同，但不是首选方法</code></pre><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组，例如：</p><pre><code>String str[][] = new String[3][4];</code></pre><h3 id="多维数组的动态初始化（以二维数组为例）"><a href="#多维数组的动态初始化（以二维数组为例）" class="headerlink" title="多维数组的动态初始化（以二维数组为例）"></a>多维数组的动态初始化（以二维数组为例）</h3><ol><li><p>直接为每一维分配空间，格式如下：</p><p> type[][] typeName = new type[typeLength1][typeLength2];<br>type 可以为基本数据类型和复合数据类型，arraylength1 和 arraylength2 必须为正整数，arraylength1 为行数，arraylength2 为列数。</p></li></ol><p>例如：</p><pre><code>int a[][] = new int[2][3];</code></pre><p>解析：</p><p>二维数组 a 可以看成一个两行三列的数组。</p><ol start="2"><li>从最高维开始，分别为每一维分配空间，例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String s[][] = new String[2][];</span><br><span class="line">s[0] = new String[2];</span><br><span class="line">s[1] = new String[3];</span><br><span class="line">s[0][0] = new String(&quot;Good&quot;);</span><br><span class="line">s[0][1] = new String(&quot;Luck&quot;);</span><br><span class="line">s[1][0] = new String(&quot;to&quot;);</span><br><span class="line">s[1][1] = new String(&quot;you&quot;);</span><br><span class="line">s[1][2] = new String(&quot;!&quot;);</span><br></pre></td></tr></table></figure></li></ol><p>解析：</p><pre><code>s[0]=new String[2] 和 s[1]=new String[3] </code></pre><p>是为最高维分配引用空间，也就是为最高维限制其能保存数据的最长的长度，然后再为其每个数组元素单独分配空间 s0=new String(“Good”) 等操作。</p><h1 id="Arrays-类"><a href="#Arrays-类" class="headerlink" title="Arrays 类"></a>Arrays 类</h1><p>java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。</p><p>具有以下功能：</p><pre><code>给数组赋值：通过 fill 方法。对数组排序：通过 sort 方法,按升序。比较数组：通过 equals 方法比较数组中元素值是否相等。查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。</code></pre><ol><li>public static int binarySearch(Object[] a, Object key)</li></ol><p>用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(插入点) - 1)。<br>2.    public static boolean equals(long[] a, long[] a2)</p><p>如果两个指定的 long 型数组彼此相等，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。<br>3.    public static void fill(int[] a, int val)</p><p>将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。<br>4.    public static void sort(Object[] a)</p><p>对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数组对于每一门编程语言来说都是重要的数据结构之一，当然不同语言对数组的实现及处理也不尽相同。&lt;/p&gt;
&lt;p&gt;Java 语言中提供的数组是用来存储固定大小的同类型元素。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>《生事之屋：白宫回忆录》节选</title>
    <link href="http://yoursite.com/2020/06/26/%E3%80%8A%E7%94%9F%E4%BA%8B%E4%B9%8B%E5%B1%8B%EF%BC%9A%E7%99%BD%E5%AE%AB%E5%9B%9E%E5%BF%86%E5%BD%95%E3%80%8B%E8%8A%82%E9%80%89/"/>
    <id>http://yoursite.com/2020/06/26/《生事之屋：白宫回忆录》节选/</id>
    <published>2020-06-26T04:23:12.000Z</published>
    <updated>2020-06-26T04:25:04.208Z</updated>
    
    <content type="html"><![CDATA[<p>粽子节快乐！</p><a id="more"></a><p>端午假期看了前美国国家安全顾问博尔顿的白宫回忆录部分章节，这本6月23号出版的新书打着“特朗普不想让你们读的书”的名号反向营销，书中的一些内容还是挺有意思的。</p><p>例如用UC震惊体可以编条标题《震惊! 特朗普竟视孟晚舟为义女》，书中揭出了总统诸多黑料，也难怪特朗普痛批博尔顿是“被解雇的可怜的战争贩子”、“心怀不满的无聊傻子”。</p><p>这里节选部分涉及中国的片段：</p><ol><li>在12月7日的白宫圣诞晚宴上，特朗普提到孟晚舟的被捕，称这给中国带来了巨大的压力。他在桌子对面对我（博尔顿）说，我们刚刚逮捕了”中国的伊万卡·特朗普”。</li></ol><p>At the December 7 White House Christmas dinner, Trump raised Meng’s arrest, riffing about how much pressure this put on China. He said to me across the table that we had just arrested “the Ivanka Trump of China.”</p><ol start="2"><li>双方领导人谈话中提到凡尔赛条约，特朗普明显对此没概念（考虑到他曾在二战爆发纪念日祝贺波兰，不知道凡尔赛条约很正常）</li></ol><p>XI answered by comparing the impact of an unequal deal with us to the “humiliation” of the Treaty of Versailles, which had taken Shandong province from Germany but given it to Japan. XI said with a straight face that if China suffered the same humiliation in our trade negotiations, there would be an upsurge of patriotic feeling in China, implicitly indicating that that feeling would be directed against the United States. Trump manifestly had no idea what XI was referring to,</p><ol start="3"><li>（农产品谈判取得进展后）”你是三百年来最伟大的中国领导人！” 特朗普兴高采烈地说，几分钟后，特朗普将其修改为”中国历史上最伟大的领导人”。</li></ol><p>“You’re the greatest Chinese leader in three hundred years!” exulted Trump, amending it a few minutes later to be “the greatest leader in Chinese history.”</p><ol start="4"><li>（贸易战谈判期间）特朗普最后说，莱特希泽将负责交易，库什纳（驸马爷）也将参与其中，此时所有的中国人都露出了笑容。</li></ol><p>Trump closed by saying Lighthizer would be in charge of the deal-making, and Kushner would also be involved, at which point all the Chinese perked up and smiled.</p><ol start="5"><li>（提到香港问题时）”这是一个大问题，”他（特朗普）说，但立即补充说，”我不想参与”，和”我们也有人权问题”。</li></ol><p>“That’s a big deal,” he said, but immediately added, “I don’t want to get involved,” and “We have human-rights problems too.” </p><ol start="6"><li>(某个三十周年纪念日)特朗普拒绝发表白宫声明。姆努钦告诉特朗普，他担心声明草案对贸易谈判的影响，并想淡化它。这已经够糟了， 但特朗普说他一点也不想要任何声明。”那是十五年前的事了，”他说，不准确。”谁在乎呢？我想做个交易我不要任何东西”</li></ol><p>Trump refused to issue a White House statement. Mnuchin told Trump he worried about the effects of the draft statement on the trade negotiations and wanted to water it down. That was bad enough, but Trump said he didn’t want any statement at all. “That was fifteen years ago,” he said, inaccurately. “Who cares about it? I’m trying to make a deal. I don’t want anything.” </p><ol start="7"><li>特朗普最喜欢的对比之一是指着他的笔尖，并说，”这是台湾，”然后指着坚毅桌说，”这是中国”</li></ol><p>“Although it came in several variations, one of Trump’s favorite comparisons was to point to the tip of one of his Sharpies and say, “This is Taiwan,” then point to the Resolute desk and say, “This is China.”</p><ol start="8"><li>特朗普想废除两任总统任期的宪法限制</li></ol><p>One highlight came when Xi said he wanted to work with Trump for six more years, and Trump replied that people were saying that the two-term constitutional limit on Presidents should be repealed for him. I was aware of no such chatter. Knowing Xi was effectively “President for life” in China, Trump was trying to compete with him. Later in the dinner, Xi said the US had too many elections, because he didn’t want to switch away from Trump, who nodded approvingly. (Indeed, in a subsequent telephone conversation on December 29, Xi said expressly that China hoped Trump would have another term by amending the Constitution so he could stay longer.)</p><ol start="9"><li>然后，他(特朗普)令人吃惊地将谈话转向了即将到来的美国总统大选，暗示中国的经济能力会影响正在进行的竞选活动，恳求习确保他获胜。他强调了农民和中国增加购买大豆和小麦在选举结果中的重要性。</li></ol><p>He then, stunningly, turned the conversation to the coming US presidential election, alluding to China’s economic capability to affect the ongoing campaigns, pleading with Xi to ensure he’d win. He stressed the importance of farmers, and increased Chinese purchases of soybeans and wheat in the electoral outcome.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;粽子节快乐！&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="blog" scheme="http://yoursite.com/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>208. 实现 Trie (前缀树)</title>
    <link href="http://yoursite.com/2020/06/24/208.%20%E5%AE%9E%E7%8E%B0%20Trie%20(%E5%89%8D%E7%BC%80%E6%A0%91)/"/>
    <id>http://yoursite.com/2020/06/24/208. 实现 Trie (前缀树)/</id>
    <published>2020-06-24T10:17:12.000Z</published>
    <updated>2020-06-26T10:44:55.725Z</updated>
    
    <content type="html"><![CDATA[<p>实现一个 Trie (前缀树)，包含insert,search, 和startsWith这三个操作。</p><a id="more"></a><p>Trie树这部分上次做已经是两年前了，现在回过头来看很多内容已经生疏，重新整理一下。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Trie trie = new Trie();</span><br><span class="line"></span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   // 返回 true</span><br><span class="line">trie.search(&quot;app&quot;);     // 返回 false</span><br><span class="line">trie.startsWith(&quot;app&quot;); // 返回 true</span><br><span class="line">trie.insert(&quot;app&quot;);   </span><br><span class="line">trie.search(&quot;app&quot;);     // 返回 true</span><br></pre></td></tr></table></figure><p>说明:</p><p>你可以假设所有的输入都是由小写字母 a-z 构成的。<br>保证所有输入均为非空字符串。</p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>Trie (发音为 “try”) 或前缀树是一种树数据结构，用于检索字符串数据集中的键。这一高效的数据结构有多种应用<a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/shi-xian-trie-qian-zhui-shu-by-leetcode/" target="_blank" rel="noopener">^1</a>：</p><ol><li>自动补全  </li><li>拼写检查 </li><li>IP 路由 (最长前缀匹配)</li><li>T9 (九宫格) 打字预测</li><li>单词游戏</li><li>字符串检索<a href="https://songlee24.github.io/2015/05/09/prefix-tree/" target="_blank" rel="noopener">^2</a></li></ol><p>检索/查询功能是Trie树最原始的功能。思路就是从根节点开始一个一个字符进行比较：</p><p>如果沿路比较，发现不同的字符，则表示该字符串在集合中不存在。</p><p>如果所有的字符全部比较完并且全部相同，还需判断最后一个节点的标志位（标记该节点是否代表一个关键字）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct trie_node</span><br><span class="line">&#123;</span><br><span class="line">    bool isKey;   // 标记该节点是否代表一个关键字</span><br><span class="line">    trie_node *children[26]; // 各个子节点 </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="7"><li>词频统计</li></ol><p>Trie树常被搜索引擎系统用于文本词频统计 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct trie_node</span><br><span class="line">&#123;</span><br><span class="line">    int count;   // 记录该节点代表的单词的个数</span><br><span class="line">    trie_node *children[26]; // 各个子节点 </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>思路：为了实现词频统计，我们修改了节点结构，用一个整型变量count来计数。对每一个关键字执行插入操作，若已存在，计数加1，若不存在，插入后count置1。</p><p>注意：第一、第二种应用也都可以用 hash table 来做。</p><ol start="8"><li>字符串排序</li></ol><p>Trie树可以对大量字符串按字典序进行排序，思路也很简单：遍历一次所有关键字，将它们全部插入trie树，树的每个结点的所有儿子很显然地按照字母表排序，然后先序遍历输出Trie树中所有关键字即可。</p><ol start="9"><li>前缀匹配</li></ol><p>例如：找出一个字符串集合中所有以ab开头的字符串。我们只需要用所有字符串构造一个trie树，然后输出以a-&gt;b-&gt;开头的路径上的关键字即可。</p><p>trie树前缀匹配常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。</p><p>还有其他的数据结构，如平衡树和哈希表，使我们能够在字符串数据集中搜索单词。为什么我们还需要 Trie 树呢？尽管哈希表可以在 <em>O(1)</em> 时间内寻找键值，却无法高效的完成以下操作：</p><ul><li>找到具有同一前缀的全部键值。</li><li>按词典序枚举字符串的数据集。</li></ul><p>Trie 树优于哈希表的另一个理由是，随着哈希表大小增加，会出现大量的冲突，时间复杂度可能增加到 <em>O(n)*，其中 *n</em> 是插入的键的数量。与哈希表相比，Trie 树在存储多个具有相同前缀的键时可以使用较少的空间。此时 Trie 树只需要 <em>O(m)</em> 的时间复杂度，其中 <em>m</em> 为键长。而在平衡树中查找键值需要 O(m\logn)时间复杂度。</p><h4 id="Trie-树的结点结构"><a href="#Trie-树的结点结构" class="headerlink" title="Trie 树的结点结构"></a>Trie 树的结点结构</h4><p>Trie 树是一个有根的树，其结点具有以下字段：。</p><ul><li>最多 <em>R</em> 个指向子结点的链接，其中每个链接对应字母表数据集中的一个字母。<br>本文中假定 <em>R</em> 为 26，小写拉丁字母的数量。</li><li>布尔字段，以指定节点是对应键的结尾还是只是键前缀。</li></ul><p> <a href="https://pic.leetcode-cn.com/3463d9e7cb323911aa67cbd94910a34d88c9402a1ab41bbea10852cd0a74f2af-file_1562596867185" target="_blank" rel="noopener">单词 “leet” 在 Trie 树中的表</a></p><figure class="highlight java"><figcaption><span>[solution 1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R links to node children</span></span><br><span class="line">    <span class="keyword">private</span> TrieNode[] links;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> R = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        links = <span class="keyword">new</span> TrieNode[R];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> links[ch -<span class="string">'a'</span>] != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TrieNode <span class="title">get</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> links[ch -<span class="string">'a'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">char</span> ch, TrieNode node)</span> </span>&#123;</span><br><span class="line">        links[ch -<span class="string">'a'</span>] = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isEnd = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Trie 树中最常见的两个操作是键的插入和查找。</p><h4 id="向-Trie-树中插入键"><a href="#向-Trie-树中插入键" class="headerlink" title="向 Trie 树中插入键"></a>向 Trie 树中插入键</h4><p>我们通过搜索 Trie 树来插入一个键。我们从根开始搜索它对应于第一个键字符的链接。有两种情况：</p><ul><li>链接存在。沿着链接移动到树的下一个子层。算法继续搜索下一个键字符。</li><li>链接不存在。创建一个新的节点，并将它与父节点的链接相连，该链接与当前的键字符相匹配。</li></ul><p>重复以上步骤，直到到达键的最后一个字符，然后将当前节点标记为结束节点，算法完成。</p><p> <a href="https://pic.leetcode-cn.com/0cddad836ee9a200b150a3d89f96035f44f3643c4fba0cb1f329e2307c714895-file_1562596867185" target="_blank" rel="noopener">向 Trie 树中插入键</a></p><figure class="highlight java"><figcaption><span>[solution 2]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inserts a word into the trie.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> currentChar = word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!node.containsKey(currentChar)) &#123;</span><br><span class="line">                node.put(currentChar, <span class="keyword">new</span> TrieNode());</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.get(currentChar);</span><br><span class="line">        &#125;</span><br><span class="line">        node.setEnd();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(m)*，其中 *m</em> 为键长。在算法的每次迭代中，我们要么检查要么创建一个节点，直到到达键尾。只需要 <em>m</em> 次操作。</p></li><li><p>空间复杂度：<em>O(m)*。最坏的情况下，新插入的键和 Trie 树中已有的键没有公共前缀。此时需要添加 *m</em> 个结点，使用 <em>O(m)</em> 空间。</p></li></ul><h4 id="在-Trie-树中查找键"><a href="#在-Trie-树中查找键" class="headerlink" title="在 Trie 树中查找键"></a>在 Trie 树中查找键</h4><p>每个键在 trie 中表示为从根到内部节点或叶的路径。我们用第一个键字符从根开始，。检查当前节点中与键字符对应的链接。有两种情况：</p><ul><li><p>存在链接。我们移动到该链接后面路径中的下一个节点，并继续搜索下一个键字符。</p></li><li><p>不存在链接。若已无键字符，且当前结点标记为 <code>isEnd</code>，则返回 true。否则有两种可能，均返回 false :</p><ul><li>还有键字符剩余，但无法跟随 Trie 树的键路径，找不到键。</li><li>没有键字符剩余，但当前结点没有标记为 <code>isEnd</code>。也就是说，待查找键只是Trie树中另一个键的前缀。</li></ul><p><a href="https://pic.leetcode-cn.com/ba775065813363474d982b509ae99aa5423418a3ee7e5aa71f9aa4d062b6e19e-image.png" target="_blank" rel="noopener">在 Trie 树中查找键</a></p></li></ul><figure class="highlight java"><figcaption><span>[solution 3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// search a prefix or whole key in trie and</span></span><br><span class="line">    <span class="comment">// returns the node where search ends</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TrieNode <span class="title">searchPrefix</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">           <span class="keyword">char</span> curLetter = word.charAt(i);</span><br><span class="line">           <span class="keyword">if</span> (node.containsKey(curLetter)) &#123;</span><br><span class="line">               node = node.get(curLetter);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if the word is in the trie.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">       TrieNode node = searchPrefix(word);</span><br><span class="line">       <span class="keyword">return</span> node != <span class="keyword">null</span> &amp;&amp; node.isEnd();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 : <em>O(m)*。算法的每一步均搜索下一个键字符。最坏的情况下需要 *m</em> 次操作。</li><li>空间复杂度 : <em>O(1)</em>。</li></ul><h4 id="查找-Trie-树中的键前缀"><a href="#查找-Trie-树中的键前缀" class="headerlink" title="查找 Trie 树中的键前缀"></a>查找 Trie 树中的键前缀</h4><p>该方法与在 Trie 树中搜索键时使用的方法非常相似。我们从根遍历 Trie 树，直到键前缀中没有字符，或者无法用当前的键字符继续 Trie 中的路径。与上面提到的“搜索键”算法唯一的区别是，到达键前缀的末尾时，总是返回 true。我们不需要考虑当前 Trie 节点是否用 “isend” 标记，因为我们搜索的是键的前缀，而不是整个键。</p><p> <a href="https://pic.leetcode-cn.com/7cc64e93088feeedece697a7cae0c7240245e4c5e05de22634b610d7dddb31c8-image.png" target="_blank" rel="noopener">查找 Trie 树中的键前缀</a></p><figure class="highlight java"><figcaption><span>[solution 4]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if there is any word in the trie</span></span><br><span class="line">    <span class="comment">// that starts with the given prefix.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode node = searchPrefix(prefix);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 : <em>O(m)</em>。</li><li>空间复杂度 : <em>O(1)</em>。</li></ul><h1 id="Java参考代码"><a href="#Java参考代码" class="headerlink" title="Java参考代码"></a>Java参考代码</h1><figure class="highlight java"><figcaption><span>[solution 5]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">        <span class="comment">// R links to node children</span></span><br><span class="line">        <span class="keyword">private</span> TrieNode[] links;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> R = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> isEnd;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            links = <span class="keyword">new</span> TrieNode[R];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> links[ch - <span class="string">'a'</span>] != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TrieNode <span class="title">get</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> links[ch - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">char</span> ch, TrieNode node)</span> </span>&#123;</span><br><span class="line">            links[ch - <span class="string">'a'</span>] = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            isEnd = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> isEnd;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initialize your data structure here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts a word into the trie.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> currentChar = word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!node.containsKey(currentChar)) &#123;</span><br><span class="line">                node.put(currentChar, <span class="keyword">new</span> TrieNode());</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.get(currentChar);</span><br><span class="line">        &#125;</span><br><span class="line">        node.setEnd();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//search a prefix or whole key in trie and returns the node where search ends</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TrieNode <span class="title">searchPrefix</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> curLetter = word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (node.containsKey(curLetter)) &#123;</span><br><span class="line">                node = node.get(curLetter);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns if the word is in the trie.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode node = searchPrefix(word);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="keyword">null</span> &amp;&amp; node.isEnd();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns if there is any word in the trie that starts with the given prefix.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode node = searchPrefix(prefix);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-参考代码"><a href="#C-参考代码" class="headerlink" title="C++参考代码"></a>C++参考代码</h1><figure class="highlight c++"><figcaption><span>[solution 6]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span>&#123;</span></span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>,TrieNode*&gt; myMap;<span class="comment">//理解为char 是当前节点值，TrieNode*是指针</span></span><br><span class="line">        <span class="keyword">bool</span> eoF;  <span class="comment">//标记该结点处是否构成单词 </span></span><br><span class="line">    &#125;;</span><br><span class="line">    TrieNode *root;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    Trie() &#123;</span><br><span class="line">        root=<span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">         TrieNode *current=root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;word.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(current-&gt;myMap.find(word[i])!=current-&gt;myMap.end())&#123; <span class="comment">//word 中第i个字符已经存在</span></span><br><span class="line">                current=current-&gt;myMap[word[i]];</span><br><span class="line">                <span class="keyword">if</span>(i==word.size()<span class="number">-1</span>) current-&gt;eoF=<span class="literal">true</span>;<span class="comment">//当前节点是一个单词的结尾</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                TrieNode *temp=<span class="keyword">new</span> TrieNode();</span><br><span class="line">                temp-&gt;eoF=(i==word.size()<span class="number">-1</span>) ? <span class="literal">true</span>: <span class="literal">false</span>;</span><br><span class="line">                current-&gt;myMap[word[i]]=temp;</span><br><span class="line">                current=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        TrieNode *current=root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;word.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(current-&gt;myMap.find(word[i])!=current-&gt;myMap.end())&#123; <span class="comment">//word 中第i个字符已经存在</span></span><br><span class="line">                current=current-&gt;myMap[word[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> current-&gt;eoF? <span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode *current=root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prefix.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(current-&gt;myMap.find(prefix[i])!=current-&gt;myMap.end()) <span class="comment">//prefix 中第i个字符已经存在</span></span><br><span class="line">                current=current-&gt;myMap[prefix[i]];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="练习题目"><a href="#练习题目" class="headerlink" title="练习题目"></a>练习题目</h2><p>下面是一些很好的问题，供练习使用 Trie 数据结构。</p><ol><li><a href="https://leetcode-cn.com/problems/add-and-search-word-data-structure-design/" target="_blank" rel="noopener">添加与搜索单词</a> - 一个 Trie 树的直接应用。</li><li><a href="https://leetcode-cn.com/problems/word-search-ii/" target="_blank" rel="noopener">单词搜索 II</a> - 类似 Boggle 的游戏。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实现一个 Trie (前缀树)，包含insert,search, 和startsWith这三个操作。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Trie" scheme="http://yoursite.com/tags/Trie/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Design" scheme="http://yoursite.com/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>数据库学习笔记-Sql_Mode</title>
    <link href="http://yoursite.com/2020/06/23/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Sql_Mode/"/>
    <id>http://yoursite.com/2020/06/23/数据库学习笔记-Sql_Mode/</id>
    <published>2020-06-23T02:12:12.000Z</published>
    <updated>2020-06-26T04:58:38.718Z</updated>
    
    <content type="html"><![CDATA[<p>sql_mode是个很容易被忽视的变量,默认值是空值,在这种设置下是可以允许一些非法操作的,比如允许一些非法数据的插入。在生产环境必须将这个值设置为严格模式,所以开发、测试环境的数据库也必须要设置,这样在开发测试阶段就可以发现问题.</p><a id="more"></a><p>sql model 常用来解决下面几类问题</p><p>(1) 通过设置sql mode, 可以完成不同严格程度的数据校验，有效地保障数据准备性。</p><p>(2) 通过设置sql model 为宽松模式，来保证大多数sql符合标准的sql语法，这样应用在不同数据库之间进行迁移时，则不需要对业务sql 进行较大的修改。</p><p>(3) 在不同数据库之间进行数据迁移之前，通过设置SQL Mode 可以使MySQL 上的数据更方便地迁移到目标数据库中。</p><h2 id="实际遇到问题"><a href="#实际遇到问题" class="headerlink" title="实际遇到问题"></a>实际遇到问题</h2><p>执行到查询语句时报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;selectByQuery&quot; parameterType=&quot;com.microloan.boss.jhjj.model.form.UserQuery&quot; resultType=&quot;com.microloan.boss.jhjj.model.vo.UserVO&quot;&gt;</span><br><span class="line">    select a.id as userId, name as userName, phone, email, identity_id as identityId, sys_type as sysType,</span><br><span class="line">    a.created_at as createdAt, ip, device_id as deviceId, nick_name as nickName, a.user_type as userType, b.id as wechatId</span><br><span class="line">    from users as a</span><br><span class="line">    &lt;if test=&quot;1 != wechat&quot;&gt;</span><br><span class="line">      left</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    join wechat_users as b</span><br><span class="line">    on a.id = b.user_id</span><br><span class="line">    where 1 = 1</span><br><span class="line">    &lt;if test=&quot;0 == wechat&quot;&gt;</span><br><span class="line">      and b.id is null</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;userId != null and userId != &apos;&apos;&quot;&gt;</span><br><span class="line">      and a.id = #&#123;userId&#125;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;userName != null and userName != &apos;&apos;&quot;&gt;</span><br><span class="line">      and name = #&#123;userName&#125;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;phone != null and phone != &apos;&apos;&quot;&gt;</span><br><span class="line">      and phone = #&#123;phone&#125;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;identityId != null and identityId != &apos;&apos;&quot;&gt;</span><br><span class="line">      and identity_id = #&#123;identityId&#125;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;sysType != null and sysType != &apos;&apos;&quot;&gt;</span><br><span class="line">      and a.sys_type = #&#123;sysType&#125;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;ip != null and ip != &apos;&apos;&quot;&gt;</span><br><span class="line">      and ip = #&#123;ip&#125;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;deviceId != null and deviceId != &apos;&apos;&quot;&gt;</span><br><span class="line">      and device_id = #&#123;deviceId&#125;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;fromDate != null and fromDate != &apos;&apos;&quot;&gt;</span><br><span class="line">      and a.created_at &amp;gt;= #&#123;fromDate&#125;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;toDate != null and toDate != &apos;&apos;&quot;&gt;</span><br><span class="line">      and a.created_at &amp;lt;= #&#123;toDate&#125;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    group by a.id</span><br><span class="line">  &lt;/select&gt;</span><br></pre></td></tr></table></figure><p>错误信息为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;status&quot;:&quot;fail&quot;,&quot;msg&quot;:&quot;\n### Error querying database.  Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: Expression #10 of SELECT list is not in GROUP BY clause and contains nonaggregated column &apos;microloan.b.nick_name&apos; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by\n### The error may involve com.microloan.boss.jhjj.mapper.UsersMapper.selectByQuery-Inline\n### The error occurred while setting parameters\n### Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: Expression #10 of SELECT list is not in GROUP BY clause and contains nonaggregated column &apos;microloan.b.nick_name&apos; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by\n; bad SQL grammar []; nested exception is com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: Expression #10 of SELECT list is not in GROUP BY clause and contains nonaggregated column &apos;microloan.b.nick_name&apos; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by&quot;,&quot;data&quot;:null&#125;</span><br></pre></td></tr></table></figure><h2 id="解决方法-1："><a href="#解决方法-1：" class="headerlink" title="解决方法^1："></a>解决方法<a href="https://blog.csdn.net/Abysscarry/article/details/79468411" target="_blank" rel="noopener">^1</a>：</h2><p>通过报错信息可以看到是 sql_mode=only_full_group_by 问题，</p><p>于是我们在mysql命令行输入：select @@sql_mode 查询当前数据库的默认sql_mode：</p><h1 id="sql-mode-配置解析"><a href="#sql-mode-配置解析" class="headerlink" title="sql_mode 配置解析"></a>sql_mode 配置解析</h1><h3 id="ONLY-FULL-GROUP-BY"><a href="#ONLY-FULL-GROUP-BY" class="headerlink" title="ONLY_FULL_GROUP_BY"></a>ONLY_FULL_GROUP_BY</h3><p>对于GROUP BY聚合操作，如果在SELECT中的列，没有在GROUP BY中出现，那么这个SQL是不合法的，因为列不在GROUP BY从句中。简而言之，就是SELECT后面接的列必须被GROUP BY后面接的列所包含。如：<br>select a,b from table group by a,b,c; (正确)<br>select a,b,c from table group by a,b; (错误)<br>这个配置会使得GROUP BY语句环境变得十分狭窄，所以一般都不加这个配置</p><h3 id="NO-AUTO-VALUE-ON-ZERO"><a href="#NO-AUTO-VALUE-ON-ZERO" class="headerlink" title="NO_AUTO_VALUE_ON_ZERO"></a>NO_AUTO_VALUE_ON_ZERO</h3><p>该值影响自增长列的插入。默认设置下，插入0或NULL代表生成下一个自增长值。（不信的可以试试，默认的sql_mode你在自增主键列设置为0，该字段会自动变为最新的自增值，效果和null一样），如果用户希望插入的值为0（不改变），该列又是自增长的，那么这个选项就有用了。</p><h3 id="STRICT-TRANS-TABLES"><a href="#STRICT-TRANS-TABLES" class="headerlink" title="STRICT_TRANS_TABLES"></a>STRICT_TRANS_TABLES</h3><p>在该模式下，如果一个值不能插入到一个事务表中，则中断当前的操作，对非事务表不做限制。（InnoDB默认事务表，MyISAM默认非事务表；MySQL事务表支持将批处理当做一个完整的任务统一提交或回滚，即对包含在事务中的多条语句要么全执行，要么全部不执行。非事务表则不支持此种操作，批处理中的语句如果遇到错误，在错误前的语句执行成功，之后的则不执行；MySQL事务表有表锁与行锁非事务表则只有表锁）</p><h3 id="NO-ZERO-IN-DATE"><a href="#NO-ZERO-IN-DATE" class="headerlink" title="NO_ZERO_IN_DATE"></a>NO_ZERO_IN_DATE</h3><p>在严格模式下，不允许日期和月份为零</p><h3 id="NO-ZERO-DATE"><a href="#NO-ZERO-DATE" class="headerlink" title="NO_ZERO_DATE"></a>NO_ZERO_DATE</h3><p>设置该值，mysql数据库不允许插入零日期，插入零日期会抛出错误而不是警告。</p><h3 id="ERROR-FOR-DIVISION-BY-ZERO"><a href="#ERROR-FOR-DIVISION-BY-ZERO" class="headerlink" title="ERROR_FOR_DIVISION_BY_ZERO"></a>ERROR_FOR_DIVISION_BY_ZERO</h3><p>在INSERT或UPDATE过程中，如果数据被零除，则产生错误而非警告。如 果未给出该模式，那么数据被零除时MySQL返回NULL</p><h3 id="NO-AUTO-CREATE-USER"><a href="#NO-AUTO-CREATE-USER" class="headerlink" title="NO_AUTO_CREATE_USER"></a>NO_AUTO_CREATE_USER</h3><p>禁止GRANT创建密码为空的用户</p><h3 id="NO-ENGINE-SUBSTITUTION"><a href="#NO-ENGINE-SUBSTITUTION" class="headerlink" title="NO_ENGINE_SUBSTITUTION"></a>NO_ENGINE_SUBSTITUTION</h3><p>如果需要的存储引擎被禁用或未编译，那么抛出错误。不设置此值时，用默认的存储引擎替代，并抛出一个异常</p><h3 id="PIPES-AS-CONCAT"><a href="#PIPES-AS-CONCAT" class="headerlink" title="PIPES_AS_CONCAT"></a>PIPES_AS_CONCAT</h3><p>将”||”视为字符串的连接操作符而非或运算符，这和Oracle数据库是一样的，也和字符串的拼接函数Concat相类似</p><h3 id="ANSI-QUOTES"><a href="#ANSI-QUOTES" class="headerlink" title="ANSI_QUOTES"></a>ANSI_QUOTES</h3><p>启用ANSI_QUOTES后，不能用双引号来引用字符串，因为它被解释为识别符</p><h2 id="去除sql-mode中的ONLY-FULL-GROUP-BY-2"><a href="#去除sql-mode中的ONLY-FULL-GROUP-BY-2" class="headerlink" title="去除sql_mode中的ONLY_FULL_GROUP_BY^2"></a>去除sql_mode中的ONLY_FULL_GROUP_BY<a href="https://cloud.tencent.com/developer/article/1338284" target="_blank" rel="noopener">^2</a></h2><p>首先查询当前的sql_mode，分为全局的和当前session的。</p><h3 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select @@session.sql_mode;</span><br><span class="line"></span><br><span class="line">set session sql_mode = &apos;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&apos;;</span><br></pre></td></tr></table></figure><p>此方法只在当前会话中生效，关闭当前会话就不生效了。</p><h3 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select @@global.sql_mode;</span><br><span class="line"></span><br><span class="line">set global sql_mode = &apos;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&apos;;</span><br></pre></td></tr></table></figure><p>此方法在当前服务中生效，重新MySQL服务后失效</p><h3 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h3><p>在mysql的安装目录下，或my.cnf文件(windows系统是my.ini文件)，新增 sql_mode = ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION，</p><p>添加my.cnf如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"></span><br><span class="line">sql_mode=ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER</span><br></pre></td></tr></table></figure><p>然后重启mysql。</p><p>此方法永久生效.当然生产环境上是禁止重启MySQL服务的，所以采用方式二加方式三来解决线上的问题，那么即便是有一天真的重启了MySQL服务，也会永久生效了。</p><p>如果设置的是宽松模式，那么我们在插入数据的时候，即便是给了一个错误的数据，也可能会被接受，并且不报错，例如：在创建一个表时，该表中有一个字段为name，给name设置的字段类型时char(10)，如果我在插入数据的时候，其中name这个字段对应的有一条数据的长度超过了10，例如’1234567890abc’，超过了设定的字段长度10，那么不会报错，并且取前十个字符存上，也就是说这个数据被存为了’1234567890’,而’abc’就没有了，但是我们知道，我们给的这条数据是错误的，因为超过了字段长度，但是并没有报错，并且mysql自行处理并接受了，这就是宽松模式的效果，其实在开发、测试、生产等环境中，我们应该采用的是严格模式，出现这种错误，应该报错才对，所以MySQL5.7版本就将sql_mode默认值改为了严格模式，并且我们即便是用的MySQL5.6，也应该自行将其改为严格模式，而MySQL等等的这些数据库，都是想把关于数据的所有操作都自己包揽下来，包括数据的校验，其实好多时候，我们应该在自己开发的项目程序级别将这些校验给做了，虽然写项目的时候麻烦了一些步骤，但是这样做之后，我们在进行数据库迁移或者在项目的迁移时，就会方便很多。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;sql_mode是个很容易被忽视的变量,默认值是空值,在这种设置下是可以允许一些非法操作的,比如允许一些非法数据的插入。在生产环境必须将这个值设置为严格模式,所以开发、测试环境的数据库也必须要设置,这样在开发测试阶段就可以发现问题.&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Database" scheme="http://yoursite.com/tags/Database/"/>
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Java之String类</title>
    <link href="http://yoursite.com/2020/06/18/%20Java%E4%B9%8BString%E7%B1%BB/"/>
    <id>http://yoursite.com/2020/06/18/ Java之String类/</id>
    <published>2020-06-18T07:30:12.000Z</published>
    <updated>2020-06-28T09:09:51.142Z</updated>
    
    <content type="html"><![CDATA[<p>介绍Java的String类及其常用方法例如substring()方法。</p><a id="more"></a><p>字符串广泛应用 在 Java 编程中，在 Java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。<a href="https://www.runoob.com/java/java-string.html" target="_blank" rel="noopener">^1</a></p><h1 id="String方法"><a href="#String方法" class="headerlink" title="String方法"></a>String方法</h1><h2 id="substring-方法-2"><a href="#substring-方法-2" class="headerlink" title="substring() 方法^2"></a>substring() 方法<a href="https://www.runoob.com/java/java-string-substring.html" target="_blank" rel="noopener">^2</a></h2><p>substring() 方法返回字符串的子字符串。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre><code>public String substring(int beginIndex)或public String substring(int beginIndex, int endIndex)</code></pre><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><pre><code>beginIndex -- 起始索引（包括）, 索引从 0 开始。endIndex -- 结束索引（不包括）。</code></pre><p>返回值</p><p>子字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        String Str = new String(&quot;www.runoob.com&quot;);</span><br><span class="line"> </span><br><span class="line">        System.out.print(&quot;返回值 :&quot; );</span><br><span class="line">        System.out.println(Str.substring(4) );</span><br><span class="line"> </span><br><span class="line">        System.out.print(&quot;返回值 :&quot; );</span><br><span class="line">        System.out.println(Str.substring(4, 10) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序执行结果为：</p><pre><code>返回值 :runoob.com返回值 :runoob</code></pre><h2 id="Java-toCharArray-方法-3"><a href="#Java-toCharArray-方法-3" class="headerlink" title="Java toCharArray() 方法^3"></a>Java toCharArray() 方法<a href="https://www.runoob.com/java/java-string-tochararray.html" target="_blank" rel="noopener">^3</a></h2><p>toCharArray() 方法将字符串转换为字符数组。</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>public char[] toCharArray()</p><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><p>无</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>字符数组。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        String Str = new String(&quot;www.runoob.com&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.print(&quot;返回值 :&quot; );</span><br><span class="line">        System.out.println( Str.toCharArray() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序执行结果为：</p><pre><code>返回值 :www.runoob.com</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍Java的String类及其常用方法例如substring()方法。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java之可变参数</title>
    <link href="http://yoursite.com/2020/06/18/Java%E4%B9%8B%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/"/>
    <id>http://yoursite.com/2020/06/18/Java之可变参数/</id>
    <published>2020-06-18T07:30:12.000Z</published>
    <updated>2020-06-26T09:45:27.641Z</updated>
    
    <content type="html"><![CDATA[<p>在 Java 5 中提供了变长参数，允许在调用方法时传入不定长度的参数。变长参数是 Java 的一个语法糖，本质上还是基于数组的实现</p><a id="more"></a><h1 id="定义方法-1"><a href="#定义方法-1" class="headerlink" title="定义方法^1"></a>定义方法<a href="https://www.runoob.com/w3cnote/java-varargs-parameter.html" target="_blank" rel="noopener">^1</a></h1><p>在定义方法时，在最后一个形参后加上三点 …，就表示该形参可以接受多个参数值，多个参数值被当成数组传入。上述定义有几个要点需要注意：</p><p>可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数</p><p>由于可变参数必须是最后一个参数，所以一个函数最多只能有一个可变参数</p><p>Java的可变参数，会被编译器转型为一个数组</p><p>变长参数在编译为字节码后，在方法签名中就是以数组形态出现的。这两个方法的签名是一致的，不能作为方法的重载。如果同时出现，是不能编译通过的。可变参数可以兼容数组，反之则不成立</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void foo(String...varargs)&#123;&#125;</span><br><span class="line"></span><br><span class="line">foo(&quot;arg1&quot;, &quot;arg2&quot;, &quot;arg3&quot;);</span><br><span class="line"></span><br><span class="line">//上述过程和下面的调用是等价的</span><br><span class="line">foo(new String[]&#123;&quot;arg1&quot;, &quot;arg2&quot;, &quot;arg3&quot;&#125;);</span><br></pre></td></tr></table></figure><p>J2SE 1.5 中新增了”泛型”的机制，可以在一定条件下把一个类型参数化。例如，可以在编写一个类的时候，把一个方法的形参的类型用一个标识符（如T）来代表， 至于这个标识符到底表示什么类型，则在生成这个类的实例的时候再行指定。这一机制可以用来提供更充分的代码重用和更严格的编译时类型检查。不过泛型机制却不能和个数可变的形参配合使用。如果把一个能和不确定个实参相匹配的形参的类型，用一个标识符来代表，那么编译器会给出一个 “generic array creation” 的错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Varargs &#123;</span><br><span class="line"></span><br><span class="line">    public static void test(String... args) &#123;</span><br><span class="line">        for(String arg : args) &#123;//当作数组用foreach遍历</span><br><span class="line">            System.out.println(arg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //Compile error</span><br><span class="line">    //The variable argument type Object of the method must be the last parameter</span><br><span class="line">    //public void error1(String... args, Object o) &#123;&#125;</span><br><span class="line">    //public void error2(String... args, Integer... i) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    //Compile error</span><br><span class="line">    //Duplicate method test(String...) in type Varargs</span><br><span class="line">    //public void test(String[] args)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="可变参数方法的调用"><a href="#可变参数方法的调用" class="headerlink" title="可变参数方法的调用"></a>可变参数方法的调用</h1><p>调用可变参数方法，可以给出零到任意多个参数，编译器会将可变参数转化为一个数组。也可以直接传递一个数组，示例如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Varargs &#123;</span><br><span class="line"></span><br><span class="line">    public static void test(String... args) &#123;</span><br><span class="line">        for(String arg : args) &#123;</span><br><span class="line">            System.out.println(arg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        test();//0个参数</span><br><span class="line">        test(&quot;a&quot;);//1个参数</span><br><span class="line">        test(&quot;a&quot;,&quot;b&quot;);//多个参数</span><br><span class="line">        test(new String[] &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;);//直接传递数组</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h1><h2 id="优先匹配固定参数"><a href="#优先匹配固定参数" class="headerlink" title="优先匹配固定参数"></a>优先匹配固定参数</h2><p>调用一个被重载的方法时，如果此调用既能够和固定参数的重载方法匹配，也能够与可变长参数的重载方法匹配，则选择固定参数的方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Varargs &#123;</span><br><span class="line"></span><br><span class="line">    public static void test(String... args) &#123;</span><br><span class="line">        System.out.println(&quot;version 1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void test(String arg1, String arg2) &#123;</span><br><span class="line">        System.out.println(&quot;version 2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        test(&quot;a&quot;,&quot;b&quot;);//version 2 优先匹配固定参数的重载方法</span><br><span class="line">                test();//version 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匹配多个可变参数"><a href="#匹配多个可变参数" class="headerlink" title="匹配多个可变参数"></a>匹配多个可变参数</h2><p>调用一个被重载的方法时，如果此调用能够和两个可变长参数的重载方法匹配，则编译出错:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Varargs &#123;</span><br><span class="line"></span><br><span class="line">    public static void test(String... args) &#123;</span><br><span class="line">        System.out.println(&quot;version 1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void test(String arg1, String... arg2) &#123;</span><br><span class="line">        System.out.println(&quot;version 2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        test(&quot;a&quot;,&quot;b&quot;);//Compile error</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h1><h2 id="避免带有变长参数的方法重载"><a href="#避免带有变长参数的方法重载" class="headerlink" title="避免带有变长参数的方法重载"></a>避免带有变长参数的方法重载</h2><p>即便编译器可以按照优先匹配固定参数的方式确定具体的调用方法，但在阅读代码的依然容易掉入陷阱。要慎重考虑变长参数的方法重载。</p><h2 id="别让-null-值和空值威胁到变长方法"><a href="#别让-null-值和空值威胁到变长方法" class="headerlink" title="别让 null 值和空值威胁到变长方法"></a>别让 null 值和空值威胁到变长方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;  </span><br><span class="line">     public void methodA(String str,Integer... is)&#123;       </span><br><span class="line">     &#125;  </span><br><span class="line"></span><br><span class="line">     public void methodA(String str,String... strs)&#123;          </span><br><span class="line">     &#125;  </span><br><span class="line"></span><br><span class="line">     public static void main(String[] args) &#123;  </span><br><span class="line">           Client client = new Client();  </span><br><span class="line">           client.methodA(&quot;China&quot;, 0);  </span><br><span class="line">           client.methodA(&quot;China&quot;, &quot;People&quot;);  </span><br><span class="line">           client.methodA(&quot;China&quot;);  //compile error</span><br><span class="line">           client.methodA(&quot;China&quot;,null);  //compile error</span><br><span class="line">     &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;  </span><br><span class="line">     Client client = new Client();  </span><br><span class="line">     String[] strs = null;  </span><br><span class="line">     client.methodA(&quot;China&quot;,strs);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让编译器知道这个null值是String类型的，编译即可顺利通过，也就减少了错误的发生。</p><h2 id="覆写变长方法也要循规蹈矩"><a href="#覆写变长方法也要循规蹈矩" class="headerlink" title="覆写变长方法也要循规蹈矩"></a>覆写变长方法也要循规蹈矩</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com;</span><br><span class="line">public class VarArgsTest2 &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param args</span><br><span class="line">     */</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        // 向上转型</span><br><span class="line">        Base base = new Sub();</span><br><span class="line">        base.print(&quot;hello&quot;);</span><br><span class="line">        // 不转型</span><br><span class="line">        Sub sub = new Sub();</span><br><span class="line">        sub.print(&quot;hello&quot;);//compile error</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 基类</span><br><span class="line">class Base &#123;</span><br><span class="line">    void print(String... args) &#123;</span><br><span class="line">        System.out.println(&quot;Base......test&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 子类，覆写父类方法</span><br><span class="line">class Sub extends Base &#123;</span><br><span class="line">    @Override</span><br><span class="line">    void print(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;Sub......test&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个能编译通过，这是为什么呢？事实上，base 对象把子类对象 sub 做了向上转型，形参列表是由父类决定的，当然能通过。而看看子类直接调用的情况，这时编译器看到子类覆写了父类的 print 方法，因此肯定使用子类重新定义的 print 方法，尽管参数列表不匹配也不会跑到父类再去匹配下，因为找到了就不再找了，因此有了类型不匹配的错误。</p><p>这是个特例，覆写的方法参数列表竟然可以与父类不相同，这违背了覆写的定义，并且会引发莫名其妙的错误。</p><p>这里，总结下覆写必须满足的条件：</p><ul><li>覆写方法不能缩小访问权限</li><li>参数列表必须与被覆写方法相同（包括显示形式）</li><li>返回类型必须与被覆写方法的相同或是其子类</li><li>覆写方法不能抛出新的检查异常，或者超出父类范围的异常，但是可以抛出更少、更有限的异常，或者不抛出异常</li></ul><h1 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h1><p>使用 Object… 作为变长参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void foo(Object... args) &#123;</span><br><span class="line">    System.out.println(args.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(new String[]&#123;&quot;arg1&quot;, &quot;arg2&quot;, &quot;arg3&quot;&#125;); //3</span><br><span class="line">foo(100, new String[]&#123;&quot;arg1&quot;, &quot;arg1&quot;&#125;); //2</span><br><span class="line"></span><br><span class="line">foo(new Integer[]&#123;1, 2, 3&#125;); //3</span><br><span class="line">foo(100, new Integer[]&#123;1, 2, 3&#125;); //2</span><br><span class="line">foo(1, 2, 3); //3</span><br><span class="line">foo(new int[]&#123;1, 2, 3&#125;); //1</span><br></pre></td></tr></table></figure><p>int[] 无法转型为 Object[], 因而被当作一个单纯的数组对象 ; Integer[] 可以转型为 Object[], 可以作为一个对象数组。</p><h1 id="反射方法调用时的注意事项"><a href="#反射方法调用时的注意事项" class="headerlink" title="反射方法调用时的注意事项"></a>反射方法调用时的注意事项</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void foo(String... varargs)&#123;</span><br><span class="line">        System.out.println(args.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        String[] varArgs = new String[]&#123;&quot;arg1&quot;, &quot;arg2&quot;&#125;;</span><br><span class="line">        try&#123;</span><br><span class="line">            Method method = Test.class.getMethod(&quot;foo&quot;, String[].class);</span><br><span class="line">            method.invoke(null, varArgs);</span><br><span class="line">            method.invoke(null, (Object[])varArgs);</span><br><span class="line">            method.invoke(null, (Object)varArgs);</span><br><span class="line">            method.invoke(null, new Object[]&#123;varArgs&#125;);</span><br><span class="line">        &#125; catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的四个调用中，前两个都会在运行时抛出 java.lang.IllegalArgumentException: wrong number of arguments 异常，后两个则正常调用。</p><p>反射是运行时获取的，在运行时看来，可变长参数和数组是一致的，因而方法签名为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//方法签名</span><br><span class="line">([Ljava/lang/String;)V // public void foo(String[] varargs)</span><br></pre></td></tr></table></figure><p>再来看一下 Method 对象的方法声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object invoke(Object obj, Object... args)</span><br></pre></td></tr></table></figure><p>args 虽然是一个可变长度的参数，但是 args 的长度是受限于该方法对象代表的真实方法的参数列表长度的，而从运行时签名来看，([Ljava/lang/String;)V 实际上只有一个形参，即 String[] varargs，因而 invoke(Object obj, Object… args) 中可变参数 args 的实参长度只能为1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//Object invoke(Object obj, Object... args)</span><br><span class="line">//String[] varArgs = new String[]&#123;&quot;arg1&quot;, &quot;arg2&quot;&#125;;</span><br><span class="line">method.invoke(null, varArgs); //varArgs长度为2，错误</span><br><span class="line">method.invoke(null, (Object[])varArgs); //将String[]转换为Object[],长度为2的，错误</span><br><span class="line">method.invoke(null, (Object)varArgs);//将整个String[] 转为Object，长度为1，符合</span><br><span class="line">method.invoke(null, new Object[]&#123;varArgs&#125;);//Object[]长度为1，正确。上一个和这个是等价的</span><br></pre></td></tr></table></figure><h1 id="什么时候使用可变长参数？"><a href="#什么时候使用可变长参数？" class="headerlink" title="什么时候使用可变长参数？"></a>什么时候使用可变长参数？</h1><p>Stack Overflow 上有个关于变长参数使用的问题。简单地说，</p><p>在不确定方法需要处理的对象的数量时可以使用可变长参数，会使得方法调用更简单，无需手动创建数组 new T[]{…}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Java 5 中提供了变长参数，允许在调用方法时传入不定长度的参数。变长参数是 Java 的一个语法糖，本质上还是基于数组的实现&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java之Queue、Deque、ArrayDeque</title>
    <link href="http://yoursite.com/2020/06/15/Java%E4%B9%8BQueue%E3%80%81Deque%E3%80%81ArrayDeque/"/>
    <id>http://yoursite.com/2020/06/15/Java之Queue、Deque、ArrayDeque/</id>
    <published>2020-06-15T12:16:12.000Z</published>
    <updated>2020-06-17T06:45:14.867Z</updated>
    
    <content type="html"><![CDATA[<p>对Java集合中的Queue、Deque、ArrayDeque源码进行分析。</p><a id="more"></a><p>Java里有一个叫做Stack的类，却没有叫做Queue的类（它是个接口名字）。</p><p>当需要使用栈时，Java已不推荐使用Stack，而是推荐使用更高效的ArrayDeque；既然Queue只是一个接口，当需要使用队列时也就首选ArrayDeque了（次选是LinkedList）<a href="https://www.cnblogs.com/CarpenterLee/p/5468803.html" target="_blank" rel="noopener">^1</a>。</p><h1 id="队列Queue"><a href="#队列Queue" class="headerlink" title="队列Queue"></a>队列Queue</h1><p>Queue是具有队列特性的接口<a href="https://blog.csdn.net/qq_30379689/article/details/80558771" target="_blank" rel="noopener">^2</a></p><p>Queue具有先进先出的特点</p><p>Queue所有新元素都插入队列的末尾，移除元素都移除队列的头部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public interface Queue&lt;E&gt; extends Collection&lt;E&gt; &#123;</span><br><span class="line">    //往队列插入元素，如果出现异常会抛出异常</span><br><span class="line">    boolean add(E e);</span><br><span class="line">    //往队列插入元素，如果出现异常则返回false</span><br><span class="line">    boolean offer(E e);</span><br><span class="line">    //移除队列元素，如果出现异常会抛出异常</span><br><span class="line">    E remove();</span><br><span class="line">    //移除队列元素，如果出现异常则返回null</span><br><span class="line">    E poll();</span><br><span class="line">    //获取队列头部元素，如果出现异常会抛出异常</span><br><span class="line">    E element();</span><br><span class="line">    //获取队列头部元素，如果出现异常则返回null</span><br><span class="line">    E peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用表格形式来表现：</p><pre><code>操作        抛出异常        返回特殊值插入        add()            offer()删除        remove()        poll()查询        element()        peek()</code></pre><h1 id="双端队列Deque-Double-Ended-Queue"><a href="#双端队列Deque-Double-Ended-Queue" class="headerlink" title="双端队列Deque(Double Ended Queue)"></a>双端队列Deque(Double Ended Queue)</h1><p>Deque是一个双端队列</p><p>Deque继承自Queue,Deque也是Queue，Deque也能当Queue用，没有太多额外开销。所以jdk没有单独实现Queue。</p><p>Deque具有先进先出或后进先出的特点</p><p>Deque支持所有元素在头部和尾部进行插入、删除、获取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public interface Deque&lt;E&gt; extends Queue&lt;E&gt; &#123;</span><br><span class="line">    void addFirst(E e);//插入头部，异常会报错</span><br><span class="line">    boolean offerFirst(E e);//插入头部，异常返回false</span><br><span class="line">    E getFirst();//获取头部，异常会报错</span><br><span class="line">    E peekFirst();//获取头部，异常不报错</span><br><span class="line">    E removeFirst();//移除头部，异常会报错</span><br><span class="line">    E pollFirst();//移除头部，异常不报错</span><br><span class="line">    </span><br><span class="line">    void addLast(E e);//插入尾部，异常会报错</span><br><span class="line">    boolean offerLast(E e);//插入尾部，异常返回false</span><br><span class="line">    E getLast();//获取尾部，异常会报错</span><br><span class="line">    E peekLast();//获取尾部，异常不报错</span><br><span class="line">    E removeLast();//移除尾部，异常会报错</span><br><span class="line">    E pollLast();//移除尾部，异常不报错</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h1><p>实现于Deque，拥有队列或者栈特性的接口</p><p>实现于Cloneable，拥有克隆对象的特性</p><p>实现于Serializable，拥有序列化的能力</p><p>Deque有两种实现类：</p><ol><li><p>LinkedList。也就是链表，java的链表同时实现了Deque。</p></li><li><p>ArrayDeque。Deque的数组实现,官方更推荐使用AarryDeque用作栈和队列。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayDeque&lt;E&gt; extends AbstractCollection&lt;E&gt;</span><br><span class="line">                       implements Deque&lt;E&gt;, Cloneable, Serializable&#123;&#125;</span><br></pre></td></tr></table></figure><p>从名字可以看出ArrayDeque底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即循环数组（circular array），也就是说数组的任何一点都可能被看作起点或者终点。ArrayDeque是非线程安全的（not thread-safe），当多个线程同时使用的时候，需要程序员手动同步；另外，该容器不允许放入null元素。</p><p>先来总结下ArrayDeque的实现思路。<a href="https://segmentfault.com/a/1190000016330001" target="_blank" rel="noopener">^3</a></p><p>首先，ArrayDeque内部是拥有一个内部数组用于存储数据。</p><p>其次，假设采用简单的方案，即队列数组按顺序在数组里排开，那么：</p><p>由于ArrayDeque的两端都能增删数据，那么把数据插入到队列头部也就是数组头部，会造成O(N)的时间复杂度。</p><p>假设只在队尾加入而只从队头删除，队头就会空出越来越多的空间。</p><p>那么该怎么实现？也很简单。将物理上的连续数组回绕，形成逻辑上的一个 环形结构。即a[size - 1]的下一个位置是a[0].</p><p>之后，使用头尾指针标识队列头尾，在队列头尾增删元素，反映在头尾指针上就是这两个指针绕着环赛跑。</p><p>这个是大体思路，具体的还有一些细节，后面代码里分析：</p><ul><li>head和tail的具体概念是如何界定？</li><li>如果判断队满和队空？</li><li>数组满了怎么办？</li></ul><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>先来看内部属性。elements域就是存储数据的原生数组。</p><p>head和tail分别分别为头尾指针。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">transient Object[] elements; // non-private to simplify nested class access</span><br><span class="line"></span><br><span class="line">transient int head;</span><br><span class="line"></span><br><span class="line">transient int tail;</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public ArrayDeque() &#123;</span><br><span class="line">    elements = new Object[16];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ArrayDeque(int numElements) &#123;</span><br><span class="line">    allocateElements(numElements);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void allocateElements(int numElements) &#123;</span><br><span class="line">    elements = new Object[calculateSize(numElements)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>如果没有指定内部数组的初始大小，默认为16.</p></li><li><p>如果指定了内部数组的初始大小，则通过calculateSize函数二次计算出大小。</p></li></ol><p>来看calculateSize函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private static final int MIN_INITIAL_CAPACITY = 8;</span><br><span class="line"></span><br><span class="line">   private static int calculateSize(int numElements) &#123;</span><br><span class="line">       int initialCapacity = MIN_INITIAL_CAPACITY;</span><br><span class="line">       // Find the best power of two to hold elements.</span><br><span class="line">       // Tests &quot;&lt;=&quot; because arrays aren&apos;t kept full.</span><br><span class="line">       if (numElements &gt;= initialCapacity) &#123;</span><br><span class="line">           initialCapacity = numElements;</span><br><span class="line">           initialCapacity |= (initialCapacity &gt;&gt;&gt;  1);</span><br><span class="line">           initialCapacity |= (initialCapacity &gt;&gt;&gt;  2);</span><br><span class="line">           initialCapacity |= (initialCapacity &gt;&gt;&gt;  4);</span><br><span class="line">           initialCapacity |= (initialCapacity &gt;&gt;&gt;  8);</span><br><span class="line">           initialCapacity |= (initialCapacity &gt;&gt;&gt; 16);</span><br><span class="line">           initialCapacity++;</span><br><span class="line"></span><br><span class="line">           if (initialCapacity &lt; 0)   // Too many elements, must back off</span><br><span class="line">               initialCapacity &gt;&gt;&gt;= 1;// Good luck allocating 2 ^ 30 elements</span><br><span class="line">       &#125;</span><br><span class="line">       return initialCapacity;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>如果小于8，那么大小就为8.</li><li>如果大于等于8，则按照2的幂对齐。</li></ul><p>在初始化中，数组要求的大小必须为2^n，所以有这么一个算法，如果当前的大小大于默认规定的大小时，就会去计算出新的大小，那么这个计算过程是怎么样的呢？我们举一个例子进行分析:</p><p>如果initialCapacity为10的时候，那么二进制为 1010</p><p>经过initialCapacity |= (initialCapacity &gt;&gt;&gt;  1)时，那么二进制为 1010 | 0101 = 1111</p><p>经过initialCapacity |= (initialCapacity &gt;&gt;&gt;  2)时，那么二进制为 1111 | 0011 = 1111</p><p>后面计算的结果都是1111，可以理解为将二进制的低位数都补上1，这样出来的结果都是2^n-1</p><p>最后initialCapacity++，2^n-1+1出来的结果就是2^n</p><h2 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h2><p>看两个入队方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void addFirst(E e) &#123;</span><br><span class="line">    if (e == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    elements[head = (head - 1) &amp; (elements.length - 1)] = e;</span><br><span class="line">    if (head == tail)</span><br><span class="line">        doubleCapacity();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void addLast(E e) &#123;</span><br><span class="line">    if (e == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    elements[tail] = e;</span><br><span class="line">    if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head)</span><br><span class="line">        doubleCapacity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>addFirst是从队头插入，addLast是从队尾插入。</p><p>从该代码能够分析出head和tail指针的含义：</p><p>head指针指向的是队头元素的位置，除非队列为空。<br>tail指针指向的是队尾元素后一格的位置，即尾后指针。<br>因此：</p><p>如果队列没有满，tail指向的是空位置，head指向的是队头元素，永远不可能一样。</p><p>但是当队列满时，tail回绕会追上head，当tail等于head时，表示队列满了。</p><p>理清楚了这一点，上面的代码也就十分容易理解了：</p><p>对应位置插入位置，移动指针。</p><p>当tail和head相等时，扩容。</p><p>最后，这句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(head - 1) &amp; (elements.length - 1)</span><br></pre></td></tr></table></figure><p>假如被余数是2的幂次方，那么模运算就能够优化成按位与运算。</p><p>也即相当于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(head - 1) % elements.length</span><br></pre></td></tr></table></figure><h2 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public E pollFirst() &#123;</span><br><span class="line">    int h = head;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    E result = (E) elements[h];</span><br><span class="line">    // Element is null if deque empty</span><br><span class="line">    if (result == null)</span><br><span class="line">        return null;</span><br><span class="line">    elements[h] = null;     // Must null out slot</span><br><span class="line">    head = (h + 1) &amp; (elements.length - 1);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public E pollLast() &#123;</span><br><span class="line">    int t = (tail - 1) &amp; (elements.length - 1);</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    E result = (E) elements[t];</span><br><span class="line">    if (result == null)</span><br><span class="line">        return null;</span><br><span class="line">    elements[t] = null;</span><br><span class="line">    tail = t;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出队的代码很显然，不多解释。</p><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void doubleCapacity() &#123;</span><br><span class="line">    assert head == tail;</span><br><span class="line">    int p = head;</span><br><span class="line">    int n = elements.length;</span><br><span class="line">    int r = n - p; // number of elements to the right of p</span><br><span class="line">    int newCapacity = n &lt;&lt; 1;</span><br><span class="line">    // 扩容后的大小小于0（溢出），也即队列最大应该是2的30次方</span><br><span class="line">    if (newCapacity &lt; 0)</span><br><span class="line">        throw new IllegalStateException(&quot;Sorry, deque too big&quot;);</span><br><span class="line">    Object[] a = new Object[newCapacity];</span><br><span class="line">    System.arraycopy(elements, p, a, 0, r);</span><br><span class="line">    System.arraycopy(elements, 0, a, r, p);</span><br><span class="line">    elements = a;</span><br><span class="line">    head = 0;</span><br><span class="line">    tail = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容的实现为按 两倍 扩容原数组，将原数倍拷贝过去。</p><p>其中值得注意的是对数组大小溢出的处理。</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>容器的实现中，所有修改过容器结构的操作都需要修改modCount字段。</p><p>这样迭代器迭代过程中，通过前后比对该字段来判断容器是否被动过，及时抛出异常终止迭代以免造成不可预测的问题。</p><p>不过，在ArrayDeque的插入方法中并没有修改modeCount字段。从ArrayDeque的迭代器的实现中可以看出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private class DeqIterator implements Iterator&lt;E&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Index of element to be returned by subsequent call to next.</span><br><span class="line">     */</span><br><span class="line">    private int cursor = head;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Tail recorded at construction (also in remove), to stop</span><br><span class="line">     * iterator and also to check for comodification.</span><br><span class="line">     */</span><br><span class="line">    private int fence = tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来，ArrayDeque直接使用了head和tail头尾指针，就能判断出迭代过程中是否发生了变化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对Java集合中的Queue、Deque、ArrayDeque源码进行分析。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java之instanceof关键字</title>
    <link href="http://yoursite.com/2020/06/15/Java%E4%B9%8Binstanceof%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2020/06/15/Java之instanceof关键字/</id>
    <published>2020-06-15T07:55:12.000Z</published>
    <updated>2020-06-15T07:21:22.977Z</updated>
    
    <content type="html"><![CDATA[<p>instanceof 是 Java 的一个二元操作符，类似于 ==，&gt;，&lt; 等操作符。</p><p>instanceof 是 Java 的保留关键字。它的作用是测试它左边的对象是否是它右边的类的实例，返回 boolean 的数据类型。</p><a id="more"></a><p>以下实例创建了 displayObjectClass() 方法来演示 Java instanceof 关键字用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Vector;</span><br><span class="line"> </span><br><span class="line">public class Main &#123;</span><br><span class="line"> </span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">   Object testObject = new ArrayList();</span><br><span class="line">      displayObjectClass(testObject);</span><br><span class="line">   &#125;</span><br><span class="line">   public static void displayObjectClass(Object o) &#123;</span><br><span class="line">      if (o instanceof Vector)</span><br><span class="line">      System.out.println(&quot;对象是 java.util.Vector 类的实例&quot;);</span><br><span class="line">      else if (o instanceof ArrayList)</span><br><span class="line">      System.out.println(&quot;对象是 java.util.ArrayList 类的实例&quot;);</span><br><span class="line">      else</span><br><span class="line">      System.out.println(&quot;对象是 &quot; + o.getClass() + &quot; 类的实例&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码运行输出结果为：</p><pre><code>对象是 java.util.ArrayList 类的实例</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;instanceof 是 Java 的一个二元操作符，类似于 ==，&amp;gt;，&amp;lt; 等操作符。&lt;/p&gt;
&lt;p&gt;instanceof 是 Java 的保留关键字。它的作用是测试它左边的对象是否是它右边的类的实例，返回 boolean 的数据类型。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java之transient关键字</title>
    <link href="http://yoursite.com/2020/06/14/Java%E4%B9%8Btransient%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2020/06/14/Java之transient关键字/</id>
    <published>2020-06-14T05:55:12.000Z</published>
    <updated>2020-06-15T03:35:30.142Z</updated>
    
    <content type="html"><![CDATA[<p>transient关键字的作用是需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。</p><a id="more"></a><h1 id="transient的作用及使用方法-1"><a href="#transient的作用及使用方法-1" class="headerlink" title="transient的作用及使用方法^1"></a>transient的作用及使用方法<a href="https://www.cnblogs.com/lanxuezaipiao/p/3369962.html" target="_blank" rel="noopener">^1</a></h1><p>我们都知道一个对象只要实现了Serilizable接口，这个对象就可以被序列化，java的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了Serilizable接口，这个类的所有属性和方法都会自动序列化。</p><p>然而在实际开发过程中，我们常常会遇到这样的问题，这个类的有些属性需要序列化，而其他属性不需要被序列化，打个比方，如果一个用户有一些敏感信息（如密码，银行卡号等），为了安全起见，不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输，这些信息对应的变量就可以加上transient关键字。换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。</p><p>总之，java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @description 使用transient关键字不序列化某个变量</span><br><span class="line"> *        注意读取的时候，读取数据的顺序一定要和存放数据的顺序保持一致</span><br><span class="line"> *        </span><br><span class="line"> * @author Alexia</span><br><span class="line"> * @date  2013-10-15</span><br><span class="line"> */</span><br><span class="line">public class TransientTest &#123;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        </span><br><span class="line">        User user = new User();</span><br><span class="line">        user.setUsername(&quot;Alexia&quot;);</span><br><span class="line">        user.setPasswd(&quot;123456&quot;);</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;read before Serializable: &quot;);</span><br><span class="line">        System.out.println(&quot;username: &quot; + user.getUsername());</span><br><span class="line">        System.err.println(&quot;password: &quot; + user.getPasswd());</span><br><span class="line">        </span><br><span class="line">        try &#123;</span><br><span class="line">            ObjectOutputStream os = new ObjectOutputStream(</span><br><span class="line">                    new FileOutputStream(&quot;C:/user.txt&quot;));</span><br><span class="line">            os.writeObject(user); // 将User对象写进文件</span><br><span class="line">            os.flush();</span><br><span class="line">            os.close();</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            ObjectInputStream is = new ObjectInputStream(new FileInputStream(</span><br><span class="line">                    &quot;C:/user.txt&quot;));</span><br><span class="line">            user = (User) is.readObject(); // 从流中读取User的数据</span><br><span class="line">            is.close();</span><br><span class="line">            </span><br><span class="line">            System.out.println(&quot;\nread after Serializable: &quot;);</span><br><span class="line">            System.out.println(&quot;username: &quot; + user.getUsername());</span><br><span class="line">            System.err.println(&quot;password: &quot; + user.getPasswd());</span><br><span class="line">            </span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class User implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 8294180014912103005L;  </span><br><span class="line">    </span><br><span class="line">    private String username;</span><br><span class="line">    private transient String passwd;</span><br><span class="line">    </span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setUsername(String username) &#123;</span><br><span class="line">        this.username = username;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getPasswd() &#123;</span><br><span class="line">        return passwd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setPasswd(String passwd) &#123;</span><br><span class="line">        this.passwd = passwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">read before Serializable: </span><br><span class="line">username: Alexia</span><br><span class="line">password: 123456</span><br><span class="line"></span><br><span class="line">read after Serializable: </span><br><span class="line">username: Alexia</span><br><span class="line">password: null</span><br></pre></td></tr></table></figure><p>密码字段为null，说明反序列化时根本没有从文件中获取到信息。</p><h1 id="transient使用小结"><a href="#transient使用小结" class="headerlink" title="transient使用小结"></a>transient使用小结</h1><p>1）一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。</p><p>2）transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。</p><p>3）被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。</p><p>第三点可能有些人很迷惑，因为发现在User类中的username字段前加上static关键字后，程序运行结果依然不变，即static类型的username也读出来为“Alexia”了，这不与第三点说的矛盾吗？实际上是这样的：第三点确实没错（一个静态变量不管是否被transient修饰，均不能被序列化），反序列化后类中static型变量username的值为当前JVM中对应static变量的值，这个值是JVM中的不是反序列化得出的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @description 使用transient关键字不序列化某个变量</span><br><span class="line"> *        注意读取的时候，读取数据的顺序一定要和存放数据的顺序保持一致</span><br><span class="line"> *        </span><br><span class="line"> * @author Alexia</span><br><span class="line"> * @date  2013-10-15</span><br><span class="line"> */</span><br><span class="line">public class TransientTest &#123;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        </span><br><span class="line">        User user = new User();</span><br><span class="line">        user.setUsername(&quot;Alexia&quot;);</span><br><span class="line">        user.setPasswd(&quot;123456&quot;);</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;read before Serializable: &quot;);</span><br><span class="line">        System.out.println(&quot;username: &quot; + user.getUsername());</span><br><span class="line">        System.err.println(&quot;password: &quot; + user.getPasswd());</span><br><span class="line">        </span><br><span class="line">        try &#123;</span><br><span class="line">            ObjectOutputStream os = new ObjectOutputStream(</span><br><span class="line">                    new FileOutputStream(&quot;C:/user.txt&quot;));</span><br><span class="line">            os.writeObject(user); // 将User对象写进文件</span><br><span class="line">            os.flush();</span><br><span class="line">            os.close();</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 在反序列化之前改变username的值</span><br><span class="line">            User.username = &quot;jmwang&quot;;</span><br><span class="line">            </span><br><span class="line">            ObjectInputStream is = new ObjectInputStream(new FileInputStream(</span><br><span class="line">                    &quot;C:/user.txt&quot;));</span><br><span class="line">            user = (User) is.readObject(); // 从流中读取User的数据</span><br><span class="line">            is.close();</span><br><span class="line">            </span><br><span class="line">            System.out.println(&quot;\nread after Serializable: &quot;);</span><br><span class="line">            System.out.println(&quot;username: &quot; + user.getUsername());</span><br><span class="line">            System.err.println(&quot;password: &quot; + user.getPasswd());</span><br><span class="line">            </span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class User implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 8294180014912103005L;  </span><br><span class="line">    </span><br><span class="line">    public static String username;</span><br><span class="line">    private transient String passwd;</span><br><span class="line">    </span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setUsername(String username) &#123;</span><br><span class="line">        this.username = username;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getPasswd() &#123;</span><br><span class="line">        return passwd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setPasswd(String passwd) &#123;</span><br><span class="line">        this.passwd = passwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">read before Serializable: </span><br><span class="line">username: Alexia</span><br><span class="line">password: 123456</span><br><span class="line"></span><br><span class="line">read after Serializable: </span><br><span class="line">username: jmwang</span><br><span class="line">password: null</span><br></pre></td></tr></table></figure><p>这说明反序列化后类中static型变量username的值为当前JVM中对应static变量的值，为修改后jmwang，而不是序列化时的值Alexia</p><h1 id="transient使用细节——被transient关键字修饰的变量真的不能被序列化吗"><a href="#transient使用细节——被transient关键字修饰的变量真的不能被序列化吗" class="headerlink" title="transient使用细节——被transient关键字修饰的变量真的不能被序列化吗"></a>transient使用细节——被transient关键字修饰的变量真的不能被序列化吗</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import java.io.Externalizable;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.ObjectInput;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutput;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @descripiton Externalizable接口的使用</span><br><span class="line"> * </span><br><span class="line"> * @author Alexia</span><br><span class="line"> * @date 2013-10-15</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class ExternalizableTest implements Externalizable &#123;</span><br><span class="line"></span><br><span class="line">    private transient String content = &quot;是的，我将会被序列化，不管我是否被transient关键字修饰&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void writeExternal(ObjectOutput out) throws IOException &#123;</span><br><span class="line">        out.writeObject(content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void readExternal(ObjectInput in) throws IOException,</span><br><span class="line">            ClassNotFoundException &#123;</span><br><span class="line">        content = (String) in.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        </span><br><span class="line">        ExternalizableTest et = new ExternalizableTest();</span><br><span class="line">        ObjectOutput out = new ObjectOutputStream(new FileOutputStream(</span><br><span class="line">                new File(&quot;test&quot;)));</span><br><span class="line">        out.writeObject(et);</span><br><span class="line"></span><br><span class="line">        ObjectInput in = new ObjectInputStream(new FileInputStream(new File(</span><br><span class="line">                &quot;test&quot;)));</span><br><span class="line">        et = (ExternalizableTest) in.readObject();</span><br><span class="line">        System.out.println(et.content);</span><br><span class="line"></span><br><span class="line">        out.close();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>content变量会被序列化吗?运行结果就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">是的，我将会被序列化，不管我是否被transient关键字修饰</span><br></pre></td></tr></table></figure><p>这是为什么呢，不是说类的变量被transient关键字修饰以后将不能序列化了吗？</p><p>在Java中，对象的序列化可以通过实现两种接口来实现，若实现的是Serializable接口，则所有的序列化将会自动进行，若实现的是Externalizable接口，则没有任何东西可以自动序列化，需要在writeExternal方法中进行手工指定所要序列化的变量，这与是否被transient修饰无关。因此第二个例子输出的是变量content初始化的内容，而不是null。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;transient关键字的作用是需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java编程思想-第十章 接口阅读笔记</title>
    <link href="http://yoursite.com/2020/06/13/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E6%8E%A5%E5%8F%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/06/13/Java编程思想-第十章 接口阅读笔记/</id>
    <published>2020-06-13T13:55:12.000Z</published>
    <updated>2020-06-13T16:06:51.498Z</updated>
    
    <content type="html"><![CDATA[<p>接口和抽象类提供了一种将接口与实现分离的更加结构化的方法。</p><a id="more"></a><p>[TOC]</p><!-- Interfaces --><h1 id="第十章-接口"><a href="#第十章-接口" class="headerlink" title="第十章 接口"></a>第十章 接口</h1><p>这种机制在编程语言中不常见，例如 C++ 只对这种概念有间接的支持。而在 Java 中存在这些关键字，说明这些思想很重要，Java 为它们提供了直接支持。</p><p>首先，我们将学习抽象类，一种介于普通类和接口之间的折中手段。尽管你的第一想法是创建接口，但是对于构建具有属性和未实现方法的类来说，抽象类也是重要且必要的工具。你不可能总是使用纯粹的接口<a href="https://lingcoder.github.io/OnJava8/#/book/10-Interfaces" target="_blank" rel="noopener">^1</a>。</p><!-- Abstract Classes and Methods --><h2 id="抽象类和方法"><a href="#抽象类和方法" class="headerlink" title="抽象类和方法"></a>抽象类和方法</h2><p>在上一章的乐器例子中，基类 <strong>Instrument</strong> 中的方法往往是“哑”方法。如果调用了这些方法，就会出现一些错误。这是因为接口的目的是为它的派生类创建一个通用接口。</p><p>在那些例子中，创建这个通用接口的唯一理由是，不同的子类可以用不同的方式表示此接口。通用接口建立了一个基本形式，以此表达所有派生类的共同部分。另一种说法把 <strong>Instrument</strong> 称为抽象基类，或简称抽象类。</p><p>对于像 <strong>Instrument</strong> 那样的抽象类来说，它的对象几乎总是没有意义的。创建一个抽象类是为了通过通用接口操纵一系列类。因此，<strong>Instrument</strong> 只是表示接口，不是具体实现，所以创建一个 <strong>Instrument</strong> 的对象毫无意义，我们可能希望阻止用户这么做。通过让 <strong>Instrument</strong> 所有的方法产生错误，就可以达到这个目的，但是这么做会延迟到运行时才能得知错误信息，并且需要用户进行可靠、详尽的测试。最好能在编译时捕捉问题。</p><p>Java 提供了一个叫做<em>抽象方法</em>的机制，这个方法是不完整的：它只有声明没有方法体。下面是抽象方法的声明语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>包含抽象方法的类叫做<em>抽象类</em>。如果一个类包含一个或多个抽象方法，那么类本身也必须限定为抽象的，否则，编译器会报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interface/Basic.java</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Basic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">unimplemented</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个抽象类是不完整的，当试图创建这个类的对象时，Java 会怎么做呢？它不会创建抽象类的对象，所以我们只会得到编译器的错误信息。这样保证了抽象类的纯粹性，我们不用担心误用它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/AttemptToUseBasic.java</span></span><br><span class="line"><span class="comment">// &#123;WillNotCompile&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AttemptToUseBasic</span> </span>&#123;</span><br><span class="line">    Basic b = <span class="keyword">new</span> Basic();</span><br><span class="line">    <span class="comment">// error: Basic is abstract; cannot be instantiated</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果创建一个继承抽象类的新类并为之创建对象，那么就必须为基类的所有抽象方法提供方法定义。如果不这么做（可以选择不做），新类仍然是一个抽象类，编译器会强制我们为新类加上 <strong>abstract</strong> 关键字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/Basic2.java</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Basic2</span> <span class="keyword">extends</span> <span class="title">Basic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">111</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// unimplemented() still not implemented</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以将一个不包含任何抽象方法的类指明为 <strong>abstract</strong>，在类中的抽象方法没啥意义但想阻止创建类的对象时，这么做就很有用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/AbstractWithoutAbstracts.java</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Basic3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">111</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// No abstract methods</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractWithoutAbstracts</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Basic b3 = new Basic3();</span></span><br><span class="line">    <span class="comment">// error: Basic 3 is abstract; cannot be instantiated</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了创建可初始化的类，就要继承抽象类，并提供所有抽象方法的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/Instantiable.java</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Uninstantiable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Instantiable</span> <span class="keyword">extends</span> <span class="title">Uninstantiable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"f()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">22</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Uninstantiable ui = <span class="keyword">new</span> Instantiable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>留意 <code>@Override</code> 的使用。没有这个注解的话，如果你没有定义相同的方法名或签名，抽象机制会认为你没有实现抽象方法从而产生编译时错误。因此，你可能认为这里的 <code>@Override</code> 是多余的。但是，<code>@Override</code> 还提示了这个方法被覆写——我认为这是有用的，所以我会使用 <code>@Override</code>，即使在没有这个注解，编译器告诉我错误的时候。 </p><p>记住，事实上的访问权限是“friendly”。你很快会看到接口自动将其方法指明为 <strong>public</strong>。事实上，接口只允许 <strong>public</strong> 方法，如果不加访问修饰符的话，接口的方法不是 <strong>friendly</strong> 而是 <strong>public</strong>。然而，抽象类允许每件事：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/AbstractAccess.java</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAccess</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// private abstract void m1a(); // illegal</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">m2a</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">m3a</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m4</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">m4a</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>private abstract</strong> 被禁止了是有意义的，因为你不可能在 <strong>AbstractAccess</strong> 的任何子类中合法地定义它。</p><p>上一章的 <strong>Instrument</strong> 类可以很轻易地转换为一个抽象类。只需要部分方法是 <strong>abstract</strong> 即可。将一个类指明为 <strong>abstract</strong> 并不强制类中的所有方法必须都是抽象方法。</p><p>下面是修改成使用抽象类和抽象方法的管弦乐器的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/music4/Music4.java</span></span><br><span class="line"><span class="comment">// Abstract classes and methods</span></span><br><span class="line"><span class="comment">// &#123;java interfaces.music4.Music4&#125;</span></span><br><span class="line"><span class="keyword">package</span> interfaces.music4;</span><br><span class="line"><span class="keyword">import</span> polymorphism.music.Note;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i; <span class="comment">// Storage allocated for each</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">what</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Instrument"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wind</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Wind.play() "</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">what</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Wind"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Adjusting Wind"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Percussion</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Percussion.play() "</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">what</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Percussion"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Adjusting Percussion"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stringed</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Stringed.play() "</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">what</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Stringed"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Adjusting Stringed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Brass</span> <span class="keyword">extends</span> <span class="title">Wind</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Brass.play() "</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Adjusting Brass"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woodwind</span> <span class="keyword">extends</span> <span class="title">Wind</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Woodwind.play() "</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">what</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Woodwind"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music4</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Doesn't care about type, so new types</span></span><br><span class="line">    <span class="comment">// added to system still work right:</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Instrument i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        i.play(Note.MIDDLE_C);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tuneAll</span><span class="params">(Instrument[] e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Instrument i: e) &#123;</span><br><span class="line">            tune(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Upcasting during addition to the array:</span></span><br><span class="line">        Instrument[] orchestra = &#123;</span><br><span class="line">            <span class="keyword">new</span> Wind(),</span><br><span class="line">            <span class="keyword">new</span> Percussion(),</span><br><span class="line">            <span class="keyword">new</span> Stringed(),</span><br><span class="line">            <span class="keyword">new</span> Brass(),</span><br><span class="line">            <span class="keyword">new</span> Woodwind()</span><br><span class="line">        &#125;;</span><br><span class="line">        tuneAll(orchestra);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Wind.play() MIDDLE_C</span><br><span class="line">Percussion.play() MIDDLE_C</span><br><span class="line">Stringed.play() MIDDLE_C</span><br><span class="line">Brass.play() MIDDLE_C</span><br><span class="line">Woodwind.play() MIDDLE_C</span><br></pre></td></tr></table></figure><p>除了 <strong>Instrument</strong>，基本没区别。</p><p>创建抽象类和抽象方法是有帮助的，因为它们使得类的抽象性很明确，并能告知用户和编译器使用意图。抽象类同时也是一种有用的重构工具，使用它们使得我们很容易地将沿着继承层级结构上移公共方法。</p><!-- Interfaces --><h2 id="接口创建"><a href="#接口创建" class="headerlink" title="接口创建"></a>接口创建</h2><p>使用 <strong>interface</strong> 关键字创建接口。在本书中，interface 和 class 一样随处常见，除非特指关键字 <strong>interface</strong>，其他情况下都采用正常字体书写 interface。</p><p>描述 Java 8 之前的接口更加容易，因为它们只允许抽象方法。像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/PureInterface.java</span></span><br><span class="line"><span class="comment">// Interface only looked like this before Java 8</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PureInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">m1</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">m3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们甚至不用为方法加上 <strong>abstract</strong> 关键字，因为方法在接口中。Java 知道这些方法不能有方法体（仍然可以为方法加上 <strong>abstract</strong> 关键字，但是看起来像是不明白接口，徒增难堪罢了）。</p><p>因此，在 Java 8之前我们可以这么说：<strong>interface</strong> 关键字产生一个完全抽象的类，没有提供任何实现。我们只能描述类应该像什么，做什么，但不能描述怎么做，即只能决定方法名、参数列表和返回类型，但是无法确定方法体。接口只提供形式，通常来说没有实现，尽管在某些受限制的情况下可以有实现。</p><p>一个接口表示：所有实现了该接口的类看起来都像这样。因此，任何使用某特定接口的代码都知道可以调用该接口的哪些方法，而且仅需知道这些。所以，接口被用来建立类之间的协议。（一些面向对象编程语言中，使用 protocol 关键字完成相同的功能。）</p><p>Java 8 中接口稍微有些变化，因为 Java 8 允许接口包含默认方法和静态方法——基于某些重要原因，看到后面你会理解。接口的基本概念仍然没变，介于类型之上、实现之下。接口与抽象类最明显的区别可能就是使用上的惯用方式。接口的典型使用是代表一个类的类型或一个形容词，如 Runnable 或 Serializable，而抽象类通常是类层次结构的一部分或一件事物的类型，如 String 或 ActionHero。</p><p>使用关键字 <strong>interface</strong> 而不是 <strong>class</strong> 来创建接口。和类一样，需要在关键字 <strong>interface</strong> 前加上 <strong>public</strong> 关键字（但只是在接口名与文件名相同的情况下），否则接口只有包访问权限，只能在接口相同的包下才能使用它。</p><p>接口同样可以包含属性，这些属性被隐式指明为 <strong>static</strong> 和 <strong>final</strong>。</p><p>使用 <strong>implements</strong> 关键字使一个类遵循某个特定接口（或一组接口），它表示：接口只是外形，现在我要说明它是如何工作的。除此之外，它看起来像继承。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/ImplementingAnInterface.java</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Concept</span> </span>&#123; <span class="comment">// Package access</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">idea1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">idea2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implementation</span> <span class="keyword">implements</span> <span class="title">Concept</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">idea1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"idea1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">idea2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"idea2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以选择显式地声明接口中的方法为 <strong>public</strong>，但是即使你不这么做，它们也是 <strong>public</strong> 的。所以当实现一个接口时，来自接口中的方法必须被定义为 <strong>public</strong>。否则，它们只有包访问权限，这样在继承时，它们的可访问权限就被降低了，这是 Java 编译器所不允许的。</p><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>Java 8 为关键字 <strong>default</strong> 增加了一个新的用途（之前只用于 <strong>switch</strong> 语句和注解中）。当在接口中使用它时，任何实现接口却没有定义方法的时候可以使用 <strong>default</strong> 创建的方法体。默认方法比抽象类中的方法受到更多的限制，但是非常有用，我们将在“流式编程”一章中看到。现在让我们看下如何使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/AnInterface.java</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AnInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">firstMethod</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">secondMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以像这样实现接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/AnImplementation.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnImplementation</span> <span class="keyword">implements</span> <span class="title">AnInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">firstMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"firstMethod"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">secondMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"secondMethod"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnInterface i = <span class="keyword">new</span> AnImplementation();</span><br><span class="line">        i.firstMethod();</span><br><span class="line">        i.secondMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firstMethod</span><br><span class="line">secondMethod</span><br></pre></td></tr></table></figure><p>如果我们在 <strong>AnInterface</strong> 中增加一个新方法 <code>newMethod()</code>，而在 <strong>AnImplementation</strong> 中没有实现它，编译器就会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AnImplementation.java:3:error: AnImplementation is not abstract and does not override abstract method newMethod() in AnInterface</span><br><span class="line">public class AnImplementation implements AnInterface &#123;</span><br><span class="line">^</span><br><span class="line">1 error</span><br></pre></td></tr></table></figure><p>如果我们使用关键字 <strong>default</strong> 为 <code>newMethod()</code> 方法提供默认的实现，那么所有与接口有关的代码能正常工作，不受影响，而且这些代码还可以调用新的方法 <code>newMethod()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/InterfaceWithDefault.java</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceWithDefault</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">firstMethod</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">secondMethod</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">newMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"newMethod"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键字 <strong>default</strong> 允许在接口中提供方法实现——在 Java 8 之前被禁止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/Implementation2.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Implementation2</span> <span class="keyword">implements</span> <span class="title">InterfaceWithDefault</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">firstMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"firstMethod"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">secondMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"secondMethod"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InterfaceWithDefault i = <span class="keyword">new</span> Implementation2();</span><br><span class="line">        i.firstMethod();</span><br><span class="line">        i.secondMethod();</span><br><span class="line">        i.newMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firstMethod</span><br><span class="line">secondMethod</span><br><span class="line">newMethod</span><br></pre></td></tr></table></figure><p>尽管 <strong>Implementation2</strong> 中未定义 <code>newMethod()</code>，但是可以使用 <code>newMethod()</code> 了。 </p><p>增加默认方法的极具说服力的理由是它允许在不破坏已使用接口的代码的情况下，在接口中增加新的方法。默认方法有时也被称为<em>守卫方法</em>或<em>虚拟扩展方法</em>。</p><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>多继承意味着一个类可能从多个父类型中继承特征和特性。</p><p>Java 在设计之初，C++ 的多继承机制饱受诟病。Java 过去是一种严格要求单继承的语言：只能继承自一个类（或抽象类），但可以实现任意多个接口。在 Java 8 之前，接口没有包袱——它只是方法外貌的描述。</p><p>多年后的现在，Java 通过默认方法具有了某种多继承的特性。结合带有默认方法的接口意味着结合了多个基类中的行为。因为接口中仍然不允许存在属性（只有静态属性，不适用），所以属性仍然只会来自单个基类或抽象类，也就是说，不会存在状态的多继承。正如下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/MultipleInheritance.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">One</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"first"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Two</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"second"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Three</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">third</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"third"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MI</span> <span class="keyword">implements</span> <span class="title">One</span>, <span class="title">Two</span>, <span class="title">Three</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultipleInheritance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MI mi = <span class="keyword">new</span> MI();</span><br><span class="line">        mi.first();</span><br><span class="line">        mi.second();</span><br><span class="line">        mi.third();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">first</span><br><span class="line">second</span><br><span class="line">third</span><br></pre></td></tr></table></figure><p>现在我们做些在 Java 8 之前不可能完成的事：结合多个源的实现。只要基类方法中的方法名和参数列表不同，就能工作得很好，否则会得到编译器错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interface/MICollision.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Bob1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">bob</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Bob1::bob"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Bob2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">bob</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Bob2::bob"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class Bob implements Bob1, Bob2 &#123;&#125;</span></span><br><span class="line"><span class="comment">/* Produces:</span></span><br><span class="line"><span class="comment">error: class Bob inherits unrelated defaults</span></span><br><span class="line"><span class="comment">for bob() from types Bob1 and Bob2</span></span><br><span class="line"><span class="comment">class Bob implements Bob1, Bob2 &#123;&#125;</span></span><br><span class="line"><span class="comment">^</span></span><br><span class="line"><span class="comment">1 error</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Sam1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">sam</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sam1::sam"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Sam2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">sam</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        System.out.println(i * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This works because the argument lists are distinct:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sam</span> <span class="keyword">implements</span> <span class="title">Sam1</span>, <span class="title">Sam2</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Max1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Max1::max"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Max2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">47</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class Max implements Max1, Max2 &#123;&#125;</span></span><br><span class="line"><span class="comment">/* Produces:</span></span><br><span class="line"><span class="comment">error: types Max2 and Max1 are imcompatible;</span></span><br><span class="line"><span class="comment">both define max(), but with unrelated return types</span></span><br><span class="line"><span class="comment">class Max implements Max1, Max2 &#123;&#125;</span></span><br><span class="line"><span class="comment">^</span></span><br><span class="line"><span class="comment">1 error</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>Sam</strong> 类中的两个 <code>sam()</code> 方法有相同的方法名但是签名不同——方法签名包括方法名和参数类型，编译器也是用它来区分方法。但是从 <strong>Max</strong> 类可看出，返回类型不是方法签名的一部分，因此不能用来区分方法。为了解决这个问题，需要覆写冲突的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/Jim.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Jim1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">jim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Jim1::jim"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Jim2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">jim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Jim2::jim"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jim</span> <span class="keyword">implements</span> <span class="title">Jim1</span>, <span class="title">Jim2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Jim2.<span class="keyword">super</span>.jim();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Jim().jim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Jim2::jim</span><br></pre></td></tr></table></figure><p>当然，你可以重定义 <code>jim()</code> 方法，但是也能像上例中那样使用 <strong>super</strong> 关键字选择基类实现中的一种。</p><h3 id="接口中的静态方法"><a href="#接口中的静态方法" class="headerlink" title="接口中的静态方法"></a>接口中的静态方法</h3><p>Java 8 允许在接口中添加静态方法。这么做能恰当地把工具功能置于接口中，从而操作接口，或者成为通用的工具：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/Operations.java</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Operations</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runOps</span><span class="params">(Operations... ops)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Operations op: ops) &#123;</span><br><span class="line">            op.execute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是模版方法设计模式的一个版本（在“设计模式”一章中详细描述），<code>runOps()</code> 是一个模版方法。<code>runOps()</code> 使用可变参数列表，因而我们可以传入任意多的 <strong>Operation</strong> 参数并按顺序运行它们：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interface/Machine.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> onjava.Operations;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bing</span> <span class="keyword">implements</span> <span class="title">Operations</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Operations.show(<span class="string">"Bing"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Crack</span> <span class="keyword">implements</span> <span class="title">Operations</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Operations.show(<span class="string">"Crack"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Twist</span> <span class="keyword">implements</span> <span class="title">Operations</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Operations.show(<span class="string">"Twist"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Machine</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Operations.runOps(</span><br><span class="line">        <span class="keyword">new</span> Bing(), <span class="keyword">new</span> Crack(), <span class="keyword">new</span> Twist());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bing</span><br><span class="line">Crack</span><br><span class="line">Twist</span><br></pre></td></tr></table></figure><p>这里展示了创建 <strong>Operations</strong> 的不同方式：一个外部类(Bing)，一个匿名类，一个方法引用和 lambda 表达式——毫无疑问用在这里是最好的解决方法。</p><p>这个特性是一项改善，因为它允许把静态方法放在更合适的地方。</p><h3 id="Instrument-作为接口"><a href="#Instrument-作为接口" class="headerlink" title="Instrument 作为接口"></a>Instrument 作为接口</h3><p>回顾下乐器的例子，使用接口的话：</p><p>类 <strong>Woodwind</strong> 和 <strong>Brass</strong> 说明一旦实现了某个接口，那么其实现就变成一个普通类，可以按常规方式扩展它。</p><p>接口的工作方式使得我们不需要显式声明其中的方法为 <strong>public</strong>，它们自动就是 <strong>public</strong> 的。<code>play()</code> 和 <code>adjust()</code> 使用 <strong>default</strong> 关键字定义实现。在 Java 8 之前，这些定义要在每个实现中重复实现，显得多余且令人烦恼：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/music5/Music5.java</span></span><br><span class="line"><span class="comment">// &#123;java interfaces.music5.Music5&#125;</span></span><br><span class="line"><span class="keyword">package</span> interfaces.music5;</span><br><span class="line"><span class="keyword">import</span> polymorphism.music.Note;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Compile-time constant:</span></span><br><span class="line">    <span class="keyword">int</span> VALUE = <span class="number">5</span>; <span class="comment">// static &amp; final</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span>  <span class="comment">// Automatically public </span></span></span><br><span class="line"><span class="function">        System.out.<span class="title">println</span><span class="params">(<span class="keyword">this</span> + <span class="string">".play() "</span> + n)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Adjusting "</span> + <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wind</span> <span class="keyword">implements</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Wind"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Percussion</span> <span class="keyword">implements</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Percussion"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stringed</span> <span class="keyword">implements</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Stringed"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Brass</span> <span class="keyword">extends</span> <span class="title">Wind</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Brass"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woodwind</span> <span class="keyword">extends</span> <span class="title">Wind</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Woodwind"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music5</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Doesn't care about type, so new types</span></span><br><span class="line">    <span class="comment">// added to the system still work right:</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Instrument i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        i.play(Note.MIDDLE_C);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tuneAll</span><span class="params">(Instrument[] e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Instrument i: e) &#123;</span><br><span class="line">            tune(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Upcasting during addition to the array:</span></span><br><span class="line">        Instrument[] orchestra = &#123;</span><br><span class="line">            <span class="keyword">new</span> Wind(),</span><br><span class="line">            <span class="keyword">new</span> Percussion(),</span><br><span class="line">            <span class="keyword">new</span> Stringed(),</span><br><span class="line">            <span class="keyword">new</span> Brass(),</span><br><span class="line">            <span class="keyword">new</span> Woodwind()</span><br><span class="line">        &#125;</span><br><span class="line">        tuneAll(orchestra);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Wind.play() MIDDLE_C</span><br><span class="line">Percussion.play() MIDDLE_C</span><br><span class="line">Stringed.play() MIDDLE_C</span><br><span class="line">Brass.play() MIDDLE_C</span><br><span class="line">Woodwind.play() MIDDLE_C</span><br></pre></td></tr></table></figure><p>这个版本的例子的另一个变化是：<code>what()</code> 被修改为 <code>toString()</code> 方法，因为 <code>toString()</code> 实现的正是 <code>what()</code> 方法要实现的逻辑。因为 <code>toString()</code> 是根基类 <strong>Object</strong> 的方法，所以它不需要出现在接口中。</p><p>注意到，无论是将其向上转型为称作 <strong>Instrument</strong> 的普通类，或称作 <strong>Instrument</strong> 的抽象类，还是叫作 <strong>Instrument</strong> 的接口，其行为都是相同的。事实上，从 <code>tune()</code> 方法上看不出来 <strong>Instrument</strong> 到底是一个普通类、抽象类，还是一个接口。</p><!-- Abstract Classes vs. Interfaces --><h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><p>尤其是在 Java 8 引入 <strong>default</strong> 方法之后，选择用抽象类还是用接口变得更加令人困惑。下表做了明确的区分：</p><table><thead><tr><th align="center">特性</th><th align="center">接口</th><th align="center">抽象类</th></tr></thead><tbody><tr><td align="center">组合</td><td align="center">新类可以组合多个接口</td><td align="center">只能继承单一抽象类</td></tr><tr><td align="center">状态</td><td align="center">不能包含属性（除了静态属性，不支持对象状态）</td><td align="center">可以包含属性，非抽象方法可能引用这些属性</td></tr><tr><td align="center">默认方法 和 抽象方法</td><td align="center">不需要在子类中实现默认方法。默认方法可以引用其他接口的方法</td><td align="center">必须在子类中实现抽象方法</td></tr><tr><td align="center">构造器</td><td align="center">没有构造器</td><td align="center">可以有构造器</td></tr><tr><td align="center">可见性</td><td align="center">隐式 <strong>public</strong></td><td align="center">可以是 <strong>protected</strong> 或友元</td></tr></tbody></table><p>抽象类仍然是一个类，在创建新类时只能继承它一个。而创建类的过程中可以实现多个接口。</p><p>有一条实际经验：尽可能地抽象。因此，更倾向使用接口而不是抽象类。只有当必要时才使用抽象类。除非必须使用，否则不要用接口和抽象类。大多数时候，普通类已经做得很好，如果不行的话，再移动到接口或抽象类中。</p><!-- Complete Decoupling --><h2 id="完全解耦"><a href="#完全解耦" class="headerlink" title="完全解耦"></a>完全解耦</h2><p>当方法操纵的是一个类而非接口时，它就只能作用于那个类或其子类。如果想把方法应用于那个继承层级结构之外的类，就会触霉头。接口在很大程度上放宽了这个限制，因而使用接口可以编写复用性更好的代码。</p><p>例如有一个类 <strong>Process</strong> 有两个方法 <code>name()</code> 和 <code>process()</code>。<code>process()</code> 方法接受输入，修改并输出。把这个类作为基类用来创建各种不同类型的 <strong>Processor</strong>。下例中，<strong>Processor</strong> 的各个子类修改 String 对象（注意，返回类型可能是协变类型而非参数类型）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/Applicator.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getSimpleName();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Upcase</span> <span class="keyword">extends</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回协变类型</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">process</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((String) input).toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Downcase</span> <span class="keyword">extends</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">process</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((String) input).toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Splitter</span> <span class="keyword">extends</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">process</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// split() divides a String into pieces:</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.toString(((String) input).split(<span class="string">" "</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Applicator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(Processor p, Object s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Using Processor "</span> + p.name());</span><br><span class="line">        System.out.println(p.process(s));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"We are such stuff as dreams are made on"</span>;</span><br><span class="line">        apply(<span class="keyword">new</span> Upcase(), s);</span><br><span class="line">        apply(<span class="keyword">new</span> Downcase(), s);</span><br><span class="line">        apply(<span class="keyword">new</span> Splitter(), s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Using Processor Upcase</span><br><span class="line">WE ARE SUCH STUFF AS DREAMS ARE MADE ON</span><br><span class="line">Using Processor Downcase</span><br><span class="line">we are such stuff as dreams are made on</span><br><span class="line">Using Processor Splitter</span><br><span class="line">[We, are, such, stuff, as, dreams, are, made, on]</span><br></pre></td></tr></table></figure><p><strong>Applicator</strong> 的 <code>apply()</code> 方法可以接受任何类型的 <strong>Processor</strong>，并将其应用到一个 <strong>Object</strong> 对象上输出结果。像本例中这样，创建一个能根据传入的参数类型从而具备不同行为的方法称为<em>策略</em>设计模式。方法包含算法中不变的部分，策略包含变化的部分。策略就是传入的对象，它包含要执行的代码。在这里，<strong>Processor</strong> 对象是策略，<code>main()</code> 方法展示了三种不同的应用于 <strong>String s</strong> 上的策略。</p><p><code>split()</code> 是 <strong>String</strong> 类中的方法，它接受 <strong>String</strong> 类型的对象并以传入的参数作为分割界限，返回一个数组 <strong>String[]</strong>。在这里用它是为了更快地创建 <strong>String</strong> 数组。</p><p>假设现在发现了一组电子滤波器，它们看起来好像能使用 <strong>Applicator</strong> 的 <code>apply()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/filters/Waveform.java</span></span><br><span class="line"><span class="keyword">package</span> interfaces.filters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Waveform</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Waveform "</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interfaces/filters/Filter.java</span></span><br><span class="line"><span class="keyword">package</span> interfaces.filters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getSimpleName();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Waveform <span class="title">process</span><span class="params">(Waveform input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interfaces/filters/LowPass.java</span></span><br><span class="line"><span class="keyword">package</span> interfaces.filters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LowPass</span> <span class="keyword">extends</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> cutoff;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LowPass</span><span class="params">(<span class="keyword">double</span> cutoff)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cutoff = cutoff;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Waveform <span class="title">process</span><span class="params">(Waveform input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input; <span class="comment">// Dummy processing 哑处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interfaces/filters/HighPass.java</span></span><br><span class="line"><span class="keyword">package</span> interfaces.filters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HighPass</span> <span class="keyword">extends</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> cutoff;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HighPass</span><span class="params">(<span class="keyword">double</span> cutoff)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cutoff = cutoff;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Waveform <span class="title">process</span><span class="params">(Waveform input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interfaces/filters/BandPass.java</span></span><br><span class="line"><span class="keyword">package</span> interfaces.filters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BandPass</span> <span class="keyword">extends</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> lowCutoff, highCutoff;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BandPass</span><span class="params">(<span class="keyword">double</span> lowCut, <span class="keyword">double</span> highCut)</span> </span>&#123;</span><br><span class="line">        lowCutoff = lowCut;</span><br><span class="line">        highCutoff = highCut;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Waveform <span class="title">process</span><span class="params">(Waveform input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Filter</strong> 类与 <strong>Processor</strong> 类具有相同的接口元素，但是因为它不是继承自 <strong>Processor</strong> —— 因为 <strong>Filter</strong> 类的创建者根本不知道你想将它当作 <strong>Processor</strong> 使用 —— 因此你不能将 <strong>Applicator</strong> 的 <code>apply()</code> 方法应用在 <strong>Filter</strong> 类上，即使这样做也能正常运行。主要是因为 <strong>Applicator</strong> 的 <code>apply()</code> 方法和 <strong>Processor</strong> 过于耦合，这阻止了 <strong>Applicator</strong> 的 <code>apply()</code> 方法被复用。另外要注意的一点是 Filter 类中 <code>process()</code> 方法的输入输出都是 <strong>Waveform</strong>。</p><p>但如果 <strong>Processor</strong> 是一个接口，那么限制就会变得松动到足以复用 <strong>Applicator</strong> 的 <code>apply()</code> 方法，用来接受那个接口参数。下面是修改后的 <strong>Processor</strong> 和 <strong>Applicator</strong> 版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/interfaceprocessor/Processor.java</span></span><br><span class="line"><span class="keyword">package</span> interfaces.interfaceprocessor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getSimpleName();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Object <span class="title">process</span><span class="params">(Object input)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interfaces/interfaceprocessor/Applicator.java</span></span><br><span class="line"><span class="keyword">package</span> interfaces.interfaceprocessor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Applicator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(Processor p, Object s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Using Processor "</span> + p.name());</span><br><span class="line">        System.out.println(p.process(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复用代码的第一种方式是客户端程序员遵循接口编写类，像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/interfaceprocessor/StringProcessor.java</span></span><br><span class="line"><span class="comment">// &#123;java interfaces.interfaceprocessor.StringProcessor&#125;</span></span><br><span class="line"><span class="keyword">package</span> interfaces.interfaceprocessor;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">StringProcessor</span> <span class="keyword">extends</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">process</span><span class="params">(Object input)</span></span>; <span class="comment">// [1]</span></span><br><span class="line">    String S = <span class="string">"If she weighs the same as a duck, she's made of wood"</span>; <span class="comment">// [2]</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; <span class="comment">// [3]</span></span><br><span class="line">        Applicator.apply(<span class="keyword">new</span> Upcase(), S);</span><br><span class="line">        Applicator.apply(<span class="keyword">new</span> Downcase(), S);</span><br><span class="line">        Applicator.apply(<span class="keyword">new</span> Splitter(), S);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Upcase</span> <span class="keyword">implements</span> <span class="title">StringProcessor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回协变类型</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">process</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((String) input).toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Downcase</span> <span class="keyword">implements</span> <span class="title">StringProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">process</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((String) input).toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Splitter</span> <span class="keyword">implements</span> <span class="title">StringProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">process</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.toString(((String) input).split(<span class="string">" "</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Using Processor Upcase</span><br><span class="line">IF SHE WEIGHS THE SAME AS A DUCK, SHE&apos;S MADE OF WOOD</span><br><span class="line">Using Processor Downcase</span><br><span class="line">if she weighs the same as a duck, she&apos;s made of wood</span><br><span class="line">Using Processor Splitter</span><br><span class="line">[If, she, weighs, the, same, as, a, duck,, she&apos;s, made, of, wood]</span><br></pre></td></tr></table></figure><blockquote><p>[1] 该声明不是必要的，即使移除它，编译器也不会报错。但是注意这里的协变返回类型从 Object 变成了 String。</p><p>[2] S 自动就是 final 和 static 的，因为它是在接口中定义的。</p><p>[3] 可以在接口中定义 <code>main()</code> 方法。</p></blockquote><p>这种方式运作得很好，然而你经常遇到的情况是无法修改类。例如在电子滤波器的例子中，类库是被发现而不是创建的。在这些情况下，可以使用<em>适配器</em>设计模式。适配器允许代码接受已有的接口产生需要的接口，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/interfaceprocessor/FilterProcessor.java</span></span><br><span class="line"><span class="comment">// &#123;java interfaces.interfaceprocessor.FilterProcessor&#125;</span></span><br><span class="line"><span class="keyword">package</span> interfaces.interfaceprocessor;</span><br><span class="line"><span class="keyword">import</span> interfaces.filters.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterAdapter</span> <span class="keyword">implements</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line">    Filter filter;</span><br><span class="line">    </span><br><span class="line">    FilterAdapter(Filter filter) &#123;</span><br><span class="line">        <span class="keyword">this</span>.filter = filter;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> filter.name();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Waveform <span class="title">process</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> filter.process((Waveform) input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterProcessor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Waveform w = <span class="keyword">new</span> Waveform();</span><br><span class="line">        Applicator.apply(<span class="keyword">new</span> FilterAdapter(<span class="keyword">new</span> LowPass(<span class="number">1.0</span>)), w);</span><br><span class="line">        Applicator.apply(<span class="keyword">new</span> FilterAdapter(<span class="keyword">new</span> HighPass(<span class="number">2.0</span>)), w);</span><br><span class="line">        Applicator.apply(<span class="keyword">new</span> FilterAdapter(<span class="keyword">new</span> BandPass(<span class="number">3.0</span>, <span class="number">4.0</span>)), w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Using Processor LowPass</span><br><span class="line">Waveform 0</span><br><span class="line">Using Processor HighPass</span><br><span class="line">Waveform 0</span><br><span class="line">Using Processor BandPass</span><br><span class="line">Waveform 0</span><br></pre></td></tr></table></figure><p>在这种使用适配器的方式中，<strong>FilterAdapter</strong> 的构造器接受已有的接口 <strong>Filter</strong>，继而产生需要的 <strong>Processor</strong> 接口的对象。你可能还注意到 <strong>FilterAdapter</strong> 中使用了委托。</p><p>协变允许我们从 <code>process()</code> 方法中产生一个 <strong>Waveform</strong> 而非 <strong>Object</strong> 对象。</p><p>将接口与实现解耦使得接口可以应用于多种不同的实现，因而代码更具可复用性。</p><!-- Combining Multiple Interfaces --><h2 id="多接口结合"><a href="#多接口结合" class="headerlink" title="多接口结合"></a>多接口结合</h2><p>接口没有任何实现——也就是说，没有任何与接口相关的存储——因此无法阻止结合的多接口。这是有价值的，因为你有时需要表示“一个 <strong>x</strong> 是一个 <strong>a</strong> 和一个 <strong>b</strong> 以及一个 <strong>c</strong>”。</p><p><img src="../images/1562999314238.png" alt="类图"></p><p>派生类并不要求必须继承自抽象的或“具体的”（没有任何抽象方法）的基类。如果继承一个非接口的类，那么只能继承一个类，其余的基元素必须都是接口。需要将所有的接口名称置于 <strong>implements</strong> 关键字之后且用逗号分隔。可以有任意多个接口，并可以向上转型为每个接口，因为每个接口都是独立的类型。下例展示了一个由多个接口组合而成的具体类产生的新类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/Adventure.java</span></span><br><span class="line"><span class="comment">// Multiple interfaces</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CanFight</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CanSwim</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CanFly</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActionCharacter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hero</span> <span class="keyword">extends</span> <span class="title">ActionCharacter</span> <span class="keyword">implements</span> <span class="title">CanFight</span>, <span class="title">CanSwim</span>, <span class="title">CanFly</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adventure</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">t</span><span class="params">(CanFight x)</span> </span>&#123;</span><br><span class="line">        x.fight();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">u</span><span class="params">(CanSwim x)</span> </span>&#123;</span><br><span class="line">        x.swim();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">v</span><span class="params">(CanFly x)</span> </span>&#123;</span><br><span class="line">        x.fly();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">w</span><span class="params">(ActionCharacter x)</span> </span>&#123;</span><br><span class="line">        x.fight();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Hero h = <span class="keyword">new</span> Hero();</span><br><span class="line">        t(h); <span class="comment">// Treat it as a CanFight</span></span><br><span class="line">        u(h); <span class="comment">// Treat it as a CanSwim</span></span><br><span class="line">        v(h); <span class="comment">// Treat it as a CanFly</span></span><br><span class="line">        w(h); <span class="comment">// Treat it as an ActionCharacter</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类 <strong>Hero</strong> 结合了具体类 <strong>ActionCharacter</strong> 和接口 <strong>CanFight</strong>、<strong>CanSwim</strong> 和 <strong>CanFly</strong>。当通过这种方式结合具体类和接口时，需要将具体类放在前面，后面跟着接口（否则编译器会报错）。</p><p>接口 <strong>CanFight</strong> 和类 <strong>ActionCharacter</strong> 中的 <code>fight()</code> 方法签名相同，而在类 Hero 中也没有提供 <code>fight()</code> 的定义。可以扩展一个接口，但是得到的是另一个接口。当想创建一个对象时，所有的定义必须首先都存在。类 <strong>Hero</strong> 中没有显式地提供 <code>fight()</code> 的定义，是由于该方法在类 <strong>ActionCharacter</strong> 中已经定义过，这样才使得创建 <strong>Hero</strong> 对象成为可能。</p><p>在类 <strong>Adventure</strong> 中可以看到四个方法，它们把不同的接口和具体类作为参数。当创建一个 <strong>Hero</strong> 对象时，它可以被传入这些方法中的任意一个，意味着它可以依次向上转型为每个接口。Java 中这种接口的设计方式，使得程序员不需要付出特别的努力。</p><p>记住，前面例子展示了使用接口的核心原因之一：为了能够向上转型为多个基类型（以及由此带来的灵活性）。然而，使用接口的第二个原因与使用抽象基类相同：防止客户端程序员创建这个类的对象，确保这仅仅只是一个接口。这带来了一个问题：应该使用接口还是抽象类呢？如果创建不带任何方法定义或成员变量的基类，就选择接口而不是抽象类。事实上，如果知道某事物是一个基类，可以考虑用接口实现它（这个主题在本章总结会再次讨论）。</p><!-- Extending an Interface with Inheritance --><h2 id="使用继承扩展接口"><a href="#使用继承扩展接口" class="headerlink" title="使用继承扩展接口"></a>使用继承扩展接口</h2><p>通过继承，可以很容易在接口中增加方法声明，还可以在新接口中结合多个接口。这两种情况都可以得到新接口，如下例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/HorrorShow.java</span></span><br><span class="line"><span class="comment">// Extending an interface with inheritance</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Monster</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">menace</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DangerousMonster</span> <span class="keyword">extends</span> <span class="title">Monster</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Lethal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">kill</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DragonZilla</span> <span class="keyword">implements</span> <span class="title">DangerousMonster</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">menace</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Vampire</span> <span class="keyword">extends</span> <span class="title">DangerousMonster</span>, <span class="title">Lethal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drinkBlood</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VeryBadVampire</span> <span class="keyword">implements</span> <span class="title">Vampire</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">menace</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">kill</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drinkBlood</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HorrorShow</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">u</span><span class="params">(Monster b)</span> </span>&#123;</span><br><span class="line">        b.menace();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">v</span><span class="params">(DangerousMonster d)</span> </span>&#123;</span><br><span class="line">        d.menace();</span><br><span class="line">        d.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">w</span><span class="params">(Lethal l)</span> </span>&#123;</span><br><span class="line">        l.kill();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DangerousMonster barney = <span class="keyword">new</span> DragonZilla();</span><br><span class="line">        u(barney);</span><br><span class="line">        v(barney);</span><br><span class="line">        Vampire vlad = <span class="keyword">new</span> VeryBadVampire();</span><br><span class="line">        u(vlad);</span><br><span class="line">        v(vlad);</span><br><span class="line">        w(vlad);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口 <strong>DangerousMonster</strong> 是 <strong>Monster</strong> 简单扩展的一个新接口，类 <strong>DragonZilla</strong> 实现了这个接口。</p><p><strong>Vampire</strong> 中使用的语法仅适用于接口继承。通常来说，<strong>extends</strong> 只能用于单一类，但是在构建接口时可以引用多个基类接口。注意到，接口名之间用逗号分隔。</p><h3 id="结合接口时的命名冲突"><a href="#结合接口时的命名冲突" class="headerlink" title="结合接口时的命名冲突"></a>结合接口时的命名冲突</h3><p>当实现多个接口时可能会存在一个小陷阱。在前面的例子中，<strong>CanFight</strong> 和 <strong>ActionCharacter</strong> 具有完全相同的 <code>fight()</code> 方法。完全相同的方法没有问题，但是如果它们的签名或返回类型不同会怎么样呢？这里有一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/InterfaceCollision.java</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2</span> <span class="keyword">implements</span> <span class="title">I1</span>, <span class="title">I2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 重载</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C3</span> <span class="keyword">extends</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">I2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 重载</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C4</span> <span class="keyword">extends</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">I3</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 完全相同，没问题</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法的返回类型不同</span></span><br><span class="line"><span class="comment">//- class C5 extends C implements I1 &#123;&#125;</span></span><br><span class="line"><span class="comment">//- interface I4 extends I1, I3 &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>覆写、实现和重载令人不快地搅和在一起带来了困难。同时，重载方法仅根据返回类型是区分不了的。当不注释最后两行时，报错信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">error: C5 is not abstract and does not override abstract</span><br><span class="line">method f() in I1</span><br><span class="line">class C5 extends C implements I1 &#123;&#125;</span><br><span class="line">error: types I3 and I1 are incompatible; both define f(),</span><br><span class="line">but with unrelated return types</span><br><span class="line">interfacce I4 extends I1, I3 &#123;&#125;</span><br></pre></td></tr></table></figure><p>当打算组合接口时，在不同的接口中使用相同的方法名通常会造成代码可读性的混乱，尽量避免这种情况。</p><!-- Adapting to an Interface --><h2 id="接口适配"><a href="#接口适配" class="headerlink" title="接口适配"></a>接口适配</h2><p>接口最吸引人的原因之一是相同的接口可以有多个实现。在简单情况下体现在一个方法接受接口作为参数，该接口的实现和传递对象给方法则交由你来做。</p><p>因此，接口的一种常见用法是前面提到的<em>策略</em>设计模式。编写一个方法执行某些操作并接受一个指定的接口作为参数。可以说：“只要对象遵循接口，就可以调用方法” ，这使得方法更加灵活，通用，并更具可复用性。</p><p>例如，类 <strong>Scanner</strong> 的构造器接受的是一个 <strong>Readable</strong> 接口（在“字符串”一章中学习更多相关内容）。你会发现 <strong>Readable</strong> 没有用作 Java 标准库中其他任何方法的参数——它是单独为 <strong>Scanner</strong> 创建的，因此 <strong>Scanner</strong> 没有将其参数限制为某个特定类。通过这种方式，<strong>Scanner</strong> 可以与更多的类型协作。如果你创建了一个新类并想让 <strong>Scanner</strong> 作用于它，就让它实现 <strong>Readable</strong> 接口，像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/RandomStrings.java</span></span><br><span class="line"><span class="comment">// Implementing an interface to conform to a method</span></span><br><span class="line"><span class="keyword">import</span> java.nio.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomStrings</span> <span class="keyword">implements</span> <span class="title">Readable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span>[] CAPITALS = <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>.toCharArray();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span>[] LOWERS = <span class="string">"abcdefghijklmnopqrstuvwxyz"</span>.toCharArray();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span>[] VOWELS = <span class="string">"aeiou"</span>.toCharArray();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomStrings</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(CharBuffer cb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count-- == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// indicates end of input</span></span><br><span class="line">        &#125;</span><br><span class="line">        cb.append(CAPITALS[rand.nextInt(CAPITALS.length)]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            cb.append(VOWELS[rand.nextInt(VOWELS.length)]);</span><br><span class="line">            cb.append(LOWERS[rand.nextInt(LOWERS.length)]);</span><br><span class="line">        &#125;</span><br><span class="line">        cb.append(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>; <span class="comment">// Number of characters appended</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner s = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> RandomStrings(<span class="number">10</span>));</span><br><span class="line">        <span class="keyword">while</span> (s.hasNext()) &#123;</span><br><span class="line">            System.out.println(s.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Yazeruyac</span><br><span class="line">Fowenucor</span><br><span class="line">Goeazimom</span><br><span class="line">Raeuuacio</span><br><span class="line">Nuoadesiw</span><br><span class="line">Hageaikux</span><br><span class="line">Ruqicibui</span><br><span class="line">Numasetih</span><br><span class="line">Kuuuuozog</span><br><span class="line">Waqizeyoy</span><br></pre></td></tr></table></figure><p><strong>Readable</strong> 接口只需要实现 <code>read()</code> 方法（注意 <code>@Override</code> 注解的突出方法）。在 <code>read()</code> 方法里，将输入内容添加到 <strong>CharBuffer</strong> 参数中（有多种方法可以实现，查看 <strong>CharBuffer</strong> 文档），或在没有输入时返回 <strong>-1</strong>。</p><p>假设你有一个类没有实现 <strong>Readable</strong> 接口，怎样才能让 <strong>Scanner</strong> 作用于它呢？下面是一个产生随机浮点数的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/RandomDoubles.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RandomDoubles</span> </span>&#123;</span><br><span class="line">    Random RAND = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">double</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RAND.nextDouble();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RandomDoubles rd = <span class="keyword">new</span> RandomDoubles()&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            System.out.println(rd.next() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0.7271157860730044 </span><br><span class="line">0.5309454508634242 </span><br><span class="line">0.16020656493302599 </span><br><span class="line">0.18847866977771732 </span><br><span class="line">0.5166020801268457 </span><br><span class="line">0.2678662084200585 </span><br><span class="line">0.2613610344283964</span><br></pre></td></tr></table></figure><p>我们可以再次使用适配器模式，但这里适配器类可以实现两个接口。因此，通过关键字 <strong>interface</strong> 提供的多继承，我们可以创建一个既是 <strong>RandomDoubles</strong>，又是 <strong>Readable</strong> 的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/AdaptedRandomDoubles.java</span></span><br><span class="line"><span class="comment">// creating an adapter with inheritance</span></span><br><span class="line"><span class="keyword">import</span> java.nio.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdaptedRandomDoubles</span> <span class="keyword">implements</span> <span class="title">RandomDoubles</span>, <span class="title">Readable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AdaptedRandomDoubles</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(CharBuffer cb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count-- == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String result = Double.toString(next()) + <span class="string">" "</span>;</span><br><span class="line">        cb.append(result);</span><br><span class="line">        <span class="keyword">return</span> result.length();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner s = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> AdaptedRandomDoubles(<span class="number">7</span>));</span><br><span class="line">        <span class="keyword">while</span> (s.hasNextDouble()) &#123;</span><br><span class="line">            System.out.print(s.nextDouble() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0.7271157860730044 0.5309454508634242 </span><br><span class="line">0.16020656493302599 0.18847866977771732 </span><br><span class="line">0.5166020801268457 0.2678662084200585 </span><br><span class="line">0.2613610344283964</span><br></pre></td></tr></table></figure><p>因为你可以以这种方式在已有类中增加新接口，所以这就意味着一个接受接口类型的方法提供了一种让任何类都可以与该方法进行适配的方式。这就是使用接口而不是类的强大之处。</p><!-- Fields in Interfaces --><h2 id="接口字段"><a href="#接口字段" class="headerlink" title="接口字段"></a>接口字段</h2><p>因为接口中的字段都自动是 <strong>static</strong> 和 <strong>final</strong> 的，所以接口就成为了创建一组常量的方便的工具。在 Java 5 之前，这是产生与 C 或 C++ 中的 enum (枚举类型) 具有相同效果的唯一方式。所以你可能在 Java 5 之前的代码中看到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/Months.java</span></span><br><span class="line"><span class="comment">// Using interfaces to create groups of constants</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Months</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> </span><br><span class="line">    JANUARY = <span class="number">1</span>, FEBRUARY = <span class="number">2</span>, MARCH = <span class="number">3</span>,</span><br><span class="line">    APRIL = <span class="number">4</span>, MAY = <span class="number">5</span>, JUNE = <span class="number">6</span>, JULY = <span class="number">7</span>,</span><br><span class="line">    AUGUST = <span class="number">8</span>, SEPTEMBER = <span class="number">9</span>, OCTOBER = <span class="number">10</span>,</span><br><span class="line">    NOVEMBER = <span class="number">11</span>, DECEMBER = <span class="number">12</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 Java 中使用大写字母的风格定义具有初始化值的 <strong>static</strong> <strong>final</strong> 变量。接口中的字段自动是 <strong>public</strong> 的，所以没有显式指明这点。</p><p>自 Java 5 开始，我们有了更加强大和灵活的关键字 <strong>enum</strong>，那么在接口中定义常量组就显得没什么意义了。然而当你阅读遗留的代码时，在很多场合你还会碰到这种旧的习惯用法。在“枚举”一章中你会学习到更多关于枚举的内容。</p><h3 id="初始化接口中的字段"><a href="#初始化接口中的字段" class="headerlink" title="初始化接口中的字段"></a>初始化接口中的字段</h3><p>接口中定义的字段不能是“空 <strong>final</strong>“，但是可以用非常量表达式初始化。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/RandVals.java</span></span><br><span class="line"><span class="comment">// Initializing interface fields with</span></span><br><span class="line"><span class="comment">// non-constant initializers</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RandVals</span> </span>&#123;</span><br><span class="line">    Random RAND = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">int</span> RANDOM_INT = RAND.nextInt(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">long</span> RANDOM_LONG = RAND.nextLong() * <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">float</span> RANDOM_FLOAT = RAND.nextLong() * <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">double</span> RANDOM_DOUBLE = RAND.nextDouble() * <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为字段是 <strong>static</strong> 的，所以它们在类第一次被加载时初始化，这发生在任何字段首次被访问时。下面是个简单的测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/TestRandVals.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRandVals</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(RandVals.RANDOM_INT);</span><br><span class="line">        System.out.println(RandVals.RANDOM_LONG);</span><br><span class="line">        System.out.println(RandVals.RANDOM_FLOAT);</span><br><span class="line">        System.out.println(RandVals.RANDOM_DOUBLE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">-32032247016559954</span><br><span class="line">-8.5939291E18</span><br><span class="line">5.779976127815049</span><br></pre></td></tr></table></figure><p>这些字段不是接口的一部分，它们的值被存储在接口的静态存储区域中。</p><!-- Nesting Interfaces --><h2 id="接口嵌套"><a href="#接口嵌套" class="headerlink" title="接口嵌套"></a>接口嵌套</h2><p>接口可以嵌套在类或其他接口中。下面揭示一些有趣的特性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/nesting/NestingInterfaces.java</span></span><br><span class="line"><span class="comment">// &#123;java interfaces.nesting.NestingInterfaces&#125;</span></span><br><span class="line"><span class="keyword">package</span> interfaces.nesting;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BImp</span> <span class="keyword">implements</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BImp2</span> <span class="keyword">implements</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CImp</span> <span class="keyword">implements</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CImp2</span> <span class="keyword">implements</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DImp</span> <span class="keyword">implements</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DImp2</span> <span class="keyword">implements</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> D <span class="title">getD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DImp2();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> D dRef;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveD</span><span class="params">(D d)</span> </span>&#123;</span><br><span class="line">        dRef = d;</span><br><span class="line">        dRef.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">E</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">G</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Redundant "public"</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">H</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// Cannot be private within an interface</span></span><br><span class="line">    <span class="comment">//- private interface I &#123;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NestingInterfaces</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BImp</span> <span class="keyword">implements</span> <span class="title">A</span>.<span class="title">B</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CImp</span> <span class="keyword">implements</span> <span class="title">A</span>.<span class="title">C</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Cannot implements a private interface except</span></span><br><span class="line">    <span class="comment">// within that interface's defining class:</span></span><br><span class="line">    <span class="comment">//- class DImp implements A.D &#123;</span></span><br><span class="line">    <span class="comment">//- public void f() &#123;&#125;</span></span><br><span class="line">    <span class="comment">//- &#125;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">EImp</span> <span class="keyword">implements</span> <span class="title">E</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">EGImp</span> <span class="keyword">implements</span> <span class="title">E</span>.<span class="title">G</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">EImp2</span> <span class="keyword">implements</span> <span class="title">E</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">EG</span> <span class="keyword">implements</span> <span class="title">E</span>.<span class="title">G</span> </span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        <span class="comment">// Can't access to A.D:</span></span><br><span class="line">        <span class="comment">//- A.D ad = a.getD();</span></span><br><span class="line">        <span class="comment">// Doesn't return anything but A.D:</span></span><br><span class="line">        <span class="comment">//- A.DImp2 di2 = a.getD();</span></span><br><span class="line">        <span class="comment">// cannot access a member of the interface:</span></span><br><span class="line">        <span class="comment">//- a.getD().f();</span></span><br><span class="line">        <span class="comment">// Only another A can do anything with getD():</span></span><br><span class="line">        A a2 = <span class="keyword">new</span> A();</span><br><span class="line">        a2.receiveD(a.getD());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类中嵌套接口的语法是相当显而易见的。就像非嵌套接口一样，它们具有 <strong>public</strong> 或包访问权限的可见性。</p><p>作为一种新添加的方式，接口也可以是 <strong>private</strong> 的，例如 <strong>A.D</strong>（同样的语法同时适用于嵌套接口和嵌套类）。那么 <strong>private</strong> 嵌套接口有什么好处呢？你可能猜测它只是被用来实现一个 <strong>private</strong> 内部类，就像 <strong>DImp</strong>。然而 <strong>A.DImp2</strong> 展示了它可以被实现为 <strong>public</strong> 类，但是 <strong>A.DImp2</strong> 只能被自己使用，你无法说它实现了 <strong>private</strong> 接口 <strong>D</strong>，所以实现 <strong>private</strong> 接口是一种可以强制该接口中的方法定义不会添加任何类型信息（即不可以向上转型）的方式。</p><p><code>getD()</code> 方法产生了一个与 <strong>private</strong> 接口有关的窘境。它是一个 <strong>public</strong> 方法却返回了对 <strong>private</strong> 接口的引用。能对这个返回值做些什么呢？<code>main()</code> 方法里进行了一些使用返回值的尝试但都失败了。返回值必须交给有权使用它的对象，本例中另一个 <strong>A</strong> 通过 <code>receiveD()</code> 方法接受了它。</p><p>接口 <strong>E</strong> 说明了接口之间也能嵌套。然而，作用于接口的规则——尤其是，接口中的元素必须是 <strong>public</strong> 的——在此都会被严格执行，所以嵌套在另一个接口中的接口自动就是 <strong>public</strong> 的，不能指明为 <strong>private</strong>。</p><p>类 <strong>NestingInterfaces</strong> 展示了嵌套接口的不同实现方式。尤其是当实现某个接口时，并不需要实现嵌套在其内部的接口。同时，<strong>private</strong> 接口不能在定义它的类之外被实现。</p><p>添加这些特性的最初原因看起来像是出于对严格的语法一致性的考虑，但是我通常认为，一旦你了解了某种特性，就总能找到其用武之地。</p><!-- Interfaces and Factories --><h2 id="接口和工厂方法模式"><a href="#接口和工厂方法模式" class="headerlink" title="接口和工厂方法模式"></a>接口和工厂方法模式</h2><p>接口是多实现的途径，而生成符合某个接口的对象的典型方式是<em>工厂方法</em>设计模式。不同于直接调用构造器，只需调用工厂对象中的创建方法就能生成对象的实现——理论上，通过这种方式可以将接口与实现的代码完全分离，使得可以透明地将某个实现替换为另一个实现。这里是一个展示工厂方法结构的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/Factories.java</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Service <span class="title">getService</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service1</span> <span class="keyword">implements</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    Service1() &#123;&#125; <span class="comment">// Package access</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Service1 method1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Service1 method2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service1Factory</span> <span class="keyword">implements</span> <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Service <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Service1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service2</span> <span class="keyword">implements</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    Service2() &#123;&#125; <span class="comment">// Package access</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Service2 method1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Service2 method2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service2Factory</span> <span class="keyword">implements</span> <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Service <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Service2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factories</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serviceConsumer</span><span class="params">(ServiceFactory fact)</span> </span>&#123;</span><br><span class="line">        Service s = fact.getService();</span><br><span class="line">        s.method1();</span><br><span class="line">        s.method2();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        serviceConsumer(<span class="keyword">new</span> Service1Factory());</span><br><span class="line">        <span class="comment">// Services are completely interchangeable:</span></span><br><span class="line">        serviceConsumer(<span class="keyword">new</span> Service2Factory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Service1 method1</span><br><span class="line">Service1 method2</span><br><span class="line">Service2 method1</span><br><span class="line">Service2 method2</span><br></pre></td></tr></table></figure><p>如果没有工厂方法，代码就必须在某处指定将要创建的 <strong>Service</strong> 的确切类型，从而调用恰当的构造器。</p><p>为什么要添加额外的间接层呢？一个常见的原因是创建框架。假设你正在创建一个游戏系统；例如，在相同的棋盘下国际象棋和西洋跳棋：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/Games.java</span></span><br><span class="line"><span class="comment">// A Game framework using Factory Methods</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GameFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Game <span class="title">getGame</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Checkers</span> <span class="keyword">implements</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> moves = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVES = <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Checkers move "</span> + moves);</span><br><span class="line">        <span class="keyword">return</span> ++moves != MOVES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckersFactory</span> <span class="keyword">implements</span> <span class="title">GameFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Game <span class="title">getGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Checkers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chess</span> <span class="keyword">implements</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> moves = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVES = <span class="number">4</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Chess move "</span> + moves);</span><br><span class="line">        <span class="keyword">return</span> ++moves != MOVES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChessFactory</span> <span class="keyword">implements</span> <span class="title">GameFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Game <span class="title">getGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Chess();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Games</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">(GameFactory factory)</span> </span>&#123;</span><br><span class="line">        Game s = factory.getGame();</span><br><span class="line">        <span class="keyword">while</span> (s.move()) &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        playGame(<span class="keyword">new</span> CheckersFactory());</span><br><span class="line">        playGame(<span class="keyword">new</span> ChessFactory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Checkers move 0</span><br><span class="line">Checkers move 1</span><br><span class="line">Checkers move 2</span><br><span class="line">Chess move 0</span><br><span class="line">Chess move 1</span><br><span class="line">Chess move 2</span><br><span class="line">Chess move 3</span><br></pre></td></tr></table></figure><p>如果类 <strong>Games</strong> 表示一段很复杂的代码，那么这种方式意味着你可以在不同类型的游戏里复用这段代码。你可以再想象一些能够从这个模式中受益的更加精巧的游戏。</p><p>在下一章，你将会看到一种更加优雅的使用匿名内部类的工厂实现方式。</p><!-- Summary --><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>认为接口是好的选择，从而使用接口不用具体类，这具有诱惑性。几乎任何时候，创建类都可以替代为创建一个接口和工厂。</p><p>很多人都掉进了这个陷阱，只要有可能就创建接口和工厂。这种逻辑看起来像是可能会使用不同的实现，所以总是添加这种抽象性。这变成了一种过早的设计优化。</p><p>任何抽象性都应该是由真正的需求驱动的。当有必要时才应该使用接口进行重构，而不是到处添加额外的间接层，从而带来额外的复杂性。这种复杂性非常显著，如果你让某人去处理这种复杂性，只是因为你意识到“以防万一”而添加新接口，而没有其他具有说服力的原因——好吧，如果我碰上了这种设计，就会质疑此人所作的所有其他设计了。</p><p>恰当的原则是优先使用类而不是接口。从类开始，如果使用接口的必要性变得很明确，那么就重构。接口是一个伟大的工具，但它们容易被滥用。</p><!-- 分页 --><div style="page-break-after: always;"></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接口和抽象类提供了一种将接口与实现分离的更加结构化的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
</feed>
