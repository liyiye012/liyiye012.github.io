<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-12-31T07:09:00.775Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Effctive-Java阅读笔记III</title>
    <link href="http://yoursite.com/2019/12/31/Effctive-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0III/"/>
    <id>http://yoursite.com/2019/12/31/Effctive-Java阅读笔记III/</id>
    <published>2019-12-31T07:06:12.000Z</published>
    <updated>2019-12-31T07:09:00.775Z</updated>
    
    <content type="html"><![CDATA[<p>第二章阅读：创建和销毁对象<br>05.依赖注入优于硬连接资源（hardwiring resources）</p><a id="more"></a><p>　许多类依赖于一个或多个底层资源。例如，拼写检查器依赖于字典。将此类类实现为静态工具类并不少见 （详见第 4 条）:</p><pre><code>// Inappropriate use of static utility - inflexible &amp; untestable!public class SpellChecker {    private static final Lexicon dictionary = ...;    private SpellChecker() {} // Noninstantiable    public static boolean isValid(String word) { ... }    public static List&lt;String&gt; suggestions(String typo) { ... }}</code></pre><p>同样地，将它们实现为单例的做法也并不少见（详见第 3 条）：</p><pre><code>// Inappropriate use of singleton - inflexible &amp; untestable!public class SpellChecker {    private final Lexicon dictionary = ...;    private SpellChecker(...) {}    public static INSTANCE = new SpellChecker(...);    public boolean isValid(String word) { ... }    public List&lt;String&gt; suggestions(String typo) { ... }}</code></pre><p>#参考资料</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二章阅读：创建和销毁对象&lt;br&gt;05.依赖注入优于硬连接资源（hardwiring resources）&lt;/p&gt;
    
    </summary>
    
      <category term="2019年12月" scheme="http://yoursite.com/categories/2019%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Design Pattern，Java" scheme="http://yoursite.com/tags/Design-Pattern%EF%BC%8CJava/"/>
    
  </entry>
  
  <entry>
    <title>Effctive-Java阅读笔记II</title>
    <link href="http://yoursite.com/2019/12/31/Effctive-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0II/"/>
    <id>http://yoursite.com/2019/12/31/Effctive-Java阅读笔记II/</id>
    <published>2019-12-31T03:30:12.000Z</published>
    <updated>2019-12-31T07:07:10.561Z</updated>
    
    <content type="html"><![CDATA[<p>第二章阅读：创建和销毁对象<br>03.使用私有构造方法或枚类实现 Singleton 属性<br>04.使用私有构造器执行非实例化<br>（这两部分理解有困难，需要再查阅相关资料）<br><a id="more"></a></p><h1 id="使用私有构造方法或枚类实现-Singleton-属性"><a href="#使用私有构造方法或枚类实现-Singleton-属性" class="headerlink" title="使用私有构造方法或枚类实现 Singleton 属性"></a>使用私有构造方法或枚类实现 Singleton 属性</h1><p>单例是一个仅实例化一次的类，详细描述参见笔记：《设计模式面试高频题》。单例对象通常表示无状态对象，如函数 (条目 24) 或一个本质上唯一的系统组件。让一个类成为单例会使测试它的客户变得困难，因为除非实现一个作为它类型的接口，否则不可能用一个模拟实现替代单例。</p><p>　有两种常见的方法来实现单例。两者都基于保持构造方法私有和导出公共静态成员以提供对唯一实例的访问。在第一种方法中，成员是 final 修饰的属性：</p><pre><code>// Singleton with public final fieldpublic class Elvis {    public static final Elvis INSTANCE = new Elvis();    private Elvis() { ... }    public void leaveTheBuilding() { ... }}</code></pre><p>私有构造方法只调用一次，来初始化公共静态 final Elvis.INSTANCE 属性。缺少一个公共的或受保护的构造方法，保证了全局的唯一性：一旦 Elvis 类被初始化，一个 Elvis 的实例就会存在——不多也不少。客户端所做的任何事情都不能改变这一点，但需要注意的是：特权客户端可以使用 AccessibleObject.setAccessible 方法，以反射方式调用私有构造方法（详见第 65 条）。如果需要防御此攻击，请修改构造函数，使其在请求创建第二个实例时抛出异常。<br>　在第二个实现单例的方法中，公共成员是一个静态的工厂方法：</p><pre><code>// Singleton with static factorypublic class Elvis {    private static final Elvis INSTANCE = new Elvis();    private Elvis() { ... }    public static Elvis getInstance() { return INSTANCE; }    public void leaveTheBuilding() { ... }}</code></pre><p>所有对 Elvis.getInstance 的调用都返回相同的对象引用，并且不会创建其他的 Elvis 实例（与前面提到的警告相同）。</p><p>　　公共属性方法的主要优点是 API 明确表示该类是一个单例：公共静态属性是 final 的，所以它总是包含相同的对象引用。 第二个好处是它更简单。</p><p>　　静态工厂方法的优势之一在于，它提供了灵活性：在不改变其 API 的前提下，我们可以改变该类是否应该为单例的想法。工厂方法返回该类的唯一实例，但是，它很容易被修改，比如，改为每个调用该方法的线程返回一个唯一的实例。 第二个好处是，如果你的应用程序需要它，可以编写一个泛型单例工厂（generic singleton factory ）（详见第30 条）。 使用静态工厂的最后一个优点是，可以通过方法引用（method reference）作为提供者，例如 Elvis::instance 等同于 Supplier<elvis>。 除非满足以上任意一种优势，否则还是优先考虑公有域（public-field）的方法。</elvis></p><p>　　为了将上述方法中实现的单例类变成是可序列化的 （第 12 章），仅仅将 implements Serializable 添加到声明中是不够的。为了保证单例模式不被破坏，必须声明所有的实例字段为 transient，并提供一个 readResolve 方法（详见第 89 条）。否则，每当序列化的实例被反序列化时，就会创建一个新的实例，在我们的例子中，导致出现新的 Elvis 实例。为了防止这种情况发生，将如下的 readResolve 方法添加到 Elvis 类：</p><pre><code>// readResolve method to preserve singleton propertyprivate Object readResolve() {     // Return the one true Elvis and let the garbage collector     // take care of the Elvis impersonator.    return INSTANCE;}</code></pre><p>实现一个单例的第三种方法是声明单一元素的枚举类：</p><pre><code>// Enum singleton - the preferred approachpublic enum Elvis {    INSTANCE;    public void leaveTheBuilding() { ... }}</code></pre><p>　这种方式类似于公共属性方法，但更简洁，无偿地提供了序列化机制，并提供了防止多个实例化的坚固保证，即使是在复杂的序列化或反射攻击的情况下。这种方法可能感觉有点不自然，但是 单一元素枚举类通常是实现单例的最佳方式。注意，如果单例必须继承 Enum 以外的父类 (尽管可以声明一个 Enum 来实现接口)，那么就不能使用这种方法。</p><h1 id="使用私有构造器执行非实例化"><a href="#使用私有构造器执行非实例化" class="headerlink" title="使用私有构造器执行非实例化"></a>使用私有构造器执行非实例化</h1><p>试图通过创建抽象类来强制执行非实例化是行不通的。 该类可以被子类化，并且子类可以被实例化。此外，它误导用户认为该类是为继承而设计的（详见第 19 条）。不过，有一个简单的方法来确保非实例化。只有当类不包含显式构造器时，才会生成一个默认构造器，因此可以通过包含一个私有构造器来实现类的非实例化：</p><pre><code>// Noninstantiable utility classpublic class UtilityClass {    // Suppress default constructor for noninstantiability    private UtilityClass() {        throw new AssertionError();    }    ... // Remainder omitted}</code></pre><p>因为显式构造器是私有的，所以不可以在类的外部访问它。AssertionError 异常不是严格要求的，但是它可以避免不小心在类的内部调用构造器。它保证类在任何情况下都不会被实例化。这个习惯用法有点违反直觉，好像构造器就是设计成不能调用的一样。因此，如前面所示，添加注释是种明智的做法。</p><p>　　这种习惯有一个副作用，就是使得一个类不能子类化。所有的构造器都必须显式或隐式地调用父类构造器，而在这群情况下子类则没有可访问的父类构造器来调用。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二章阅读：创建和销毁对象&lt;br&gt;03.使用私有构造方法或枚类实现 Singleton 属性&lt;br&gt;04.使用私有构造器执行非实例化&lt;br&gt;（这两部分理解有困难，需要再查阅相关资料）&lt;br&gt;
    
    </summary>
    
      <category term="2019年12月" scheme="http://yoursite.com/categories/2019%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Design Pattern，Java" scheme="http://yoursite.com/tags/Design-Pattern%EF%BC%8CJava/"/>
    
  </entry>
  
  <entry>
    <title>设计模式学习笔记III</title>
    <link href="http://yoursite.com/2019/12/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0III/"/>
    <id>http://yoursite.com/2019/12/30/设计模式学习笔记III/</id>
    <published>2019-12-30T08:55:12.000Z</published>
    <updated>2019-12-30T10:12:54.670Z</updated>
    
    <content type="html"><![CDATA[<p>静态静态工厂方法</p><a id="more"></a><h1 id="序：什么是静态工厂方法"><a href="#序：什么是静态工厂方法" class="headerlink" title="序：什么是静态工厂方法"></a>序：什么是静态工厂方法</h1><p>在 Java 中，获得一个类实例最简单的方法就是使用 new 关键字，通过构造函数来实现对象的创建。<br>就像这样：</p><pre><code>Fragment fragment = new MyFragment();// orDate date = new Date();</code></pre><p>不过在实际的开发中，我们经常还会见到另外一种获取类实例的方法：</p><pre><code>Fragment fragment = MyFragment.newIntance();// orCalendar calendar = Calendar.getInstance();// orInteger number = Integer.valueOf(&quot;3&quot;);</code></pre><p> <strong><em>像这样的：不通过 new，而是用一个静态方法来对外提供自身实例的方法，即为我们所说的静态工厂方法(Static factory method)。</em></strong></p><h2 id="知识点：new-究竟做了什么"><a href="#知识点：new-究竟做了什么" class="headerlink" title="知识点：new 究竟做了什么?"></a>知识点：new 究竟做了什么?</h2><p>简单来说：当我们使用 new 来构造一个新的类实例时，其实是告诉了 JVM 我需要一个新的实例。JVM 就会自动在内存中开辟一片空间，然后调用构造函数来初始化成员变量，最终把引用返回给调用方。</p><h1 id="Effective-Java"><a href="#Effective-Java" class="headerlink" title="Effective Java"></a>Effective Java</h1><p>在关于 Java 中书籍中，《Effective Java》绝对是最负盛名几本的之一，在此书中，作者总结了几十条改善 Java 程序设计的金玉良言。其中开篇第一条就是『考虑使用静态工厂方法代替构造器』，关于其原因，作者总结了几条，我们先来逐个看一下。</p><h2 id="静态工厂方法与构造器不同的第一优势在于，它们有名字"><a href="#静态工厂方法与构造器不同的第一优势在于，它们有名字" class="headerlink" title="静态工厂方法与构造器不同的第一优势在于，它们有名字"></a>静态工厂方法与构造器不同的第一优势在于，它们有名字</h2><p>由于语言的特性，Java 的构造函数都是跟类名一样的。这导致的一个问题是构造函数的名称不够灵活，经常不能准确地描述返回值，在有多个重载的构造函数时尤甚，如果参数类型、数目又比较相似的话，那更是很容易出错。</p><p>比如，如下的一段代码 ：</p><pre><code>Date date0 = new Date();Date date1 = new Date(0L);Date date2 = new Date(&quot;0&quot;);Date date3 = new Date(1,2,1);Date date4 = new Date(1,2,1,1,1);Date date5 = new Date(1,2,1,1,1,1);</code></pre><p>Date 类有很多重载函数，对于开发者来说，假如不是特别熟悉的话，恐怕是需要犹豫一下，才能找到合适的构造函数的。而对于其他的代码阅读者来说，估计更是需要查看文档，才能明白每个参数的含义了。</p><p>（当然，Date 类在目前的 Java 版本中，只保留了一个无参和一个有参的构造函数，其他的都已经标记为 @Deprecated 了）</p><p>而如果使用静态工厂方法，就可以给方法起更多有意义的名字，比如前面的 valueOf、newInstance、getInstance 等，对于代码的编写和阅读都能够更清晰。</p><h2 id="第二个优势，不用每次被调用时都创建新对象"><a href="#第二个优势，不用每次被调用时都创建新对象" class="headerlink" title="第二个优势，不用每次被调用时都创建新对象"></a>第二个优势，不用每次被调用时都创建新对象</h2><p>这个很容易理解了，有时候外部调用者只需要拿到一个实例，而不关心是否是新的实例；又或者我们想对外提供一个单例时如果使用工厂方法，就可以很容易的在内部控制，防止创建不必要的对象，减少开销。</p><p>在实际的场景中，单例的写法也大都是用静态工厂方法来实现的。</p><p>如果你想对单例有更多了解，可以看一下这里：☞《Hi，我们再来聊一聊Java的单例吧》[2]</p><h2 id="第三个优势，可以返回原返回类型的子类"><a href="#第三个优势，可以返回原返回类型的子类" class="headerlink" title="第三个优势，可以返回原返回类型的子类"></a>第三个优势，可以返回原返回类型的子类</h2><p>这条不用多说，设计模式中的基本的原则之一——『里氏替换』原则，就是说子类应该能替换父类。<br>显然，构造方法只能返回确切的自身类型，而静态工厂方法则能够更加灵活，可以根据需要方便地返回任何它的子类型的实例。</p><pre><code>Class Person {    public static Person getInstance(){        return new Person();        // 这里可以改为 return new Player() / Cooker()    }}Class Player extends Person{}Class Cooker extends Person{}</code></pre><p>比如上面这段代码，Person 类的静态工厂方法可以返回 Person 的实例，也可以根据需要返回它的子类 Player 或者 Cooker。（当然，这只是为了演示，在实际的项目中，一个类是不应该依赖于它的子类的。但如果这里的 getInstance () 方法位于其他的类中，就更具有的实际操作意义了）</p><h2 id="静态工厂的第四个优点是返回对象的类可以根据输入参数的不同而不同"><a href="#静态工厂的第四个优点是返回对象的类可以根据输入参数的不同而不同" class="headerlink" title="静态工厂的第四个优点是返回对象的类可以根据输入参数的不同而不同"></a>静态工厂的第四个优点是返回对象的类可以根据输入参数的不同而不同</h2><p>EnumSet 类（详见第 36 条）没有公共构造方法，只有静态工厂。 在 OpenJDK 实现中，它们根据底层枚举类型的大小返回两个子类中的一个的实例：大多数枚举类型具有 64 个或更少的元素，静态工厂将返回一个 RegularEnumSet 实例， 底层是long 类型；如果枚举类型具有六十五个或更多元素，则工厂将返回一个 JumboEnumSet 实例，底层是long 类型的数组。</p><pre><code>/**     * Creates an empty enum set with the specified element type.     *     * @param &lt;E&gt; The class of the elements in the set     * @param elementType the class object of the element type for this enum     *     set     * @return An empty enum set of the specified type.     * @throws NullPointerException if &lt;tt&gt;elementType&lt;/tt&gt; is null     ** /    public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; noneOf(Class&lt;E&gt; elementType) {        Enum&lt;?&gt;[] universe = getUniverse(elementType);        if (universe == null)            throw new ClassCastException(elementType + &quot; not an enum&quot;);        if (universe.length &lt;= 64)            return new RegularEnumSet&lt;&gt;(elementType, universe);        else            return new JumboEnumSet&lt;&gt;(elementType, universe);    }</code></pre><p>　　这两个实现类的存在对于客户端而言是不可见的。 如果 RegularEnumSet 对于小的枚举类型不再具有性能优势，则可以在未来版本中将其淘汰，且不会产生任何不良影响。 同样，如果可以证明添加 EnumSet 的更多的实现可以提高性能，那么在未来的版本可能就会这样做。 客户既不知道也不关心他们从工厂返回的对象的类别; 他们只需要知道它是 EnumSet 的子类。</p><h2 id="第五个优势是，在编写包含该方法的类时，返回的对象的类不需要存在。"><a href="#第五个优势是，在编写包含该方法的类时，返回的对象的类不需要存在。" class="headerlink" title="第五个优势是，在编写包含该方法的类时，返回的对象的类不需要存在。"></a>第五个优势是，在编写包含该方法的类时，返回的对象的类不需要存在。</h2><p>这种灵活的静态工厂方法构成了服务提供者框架的基础，比如 Java 数据库连接 AP（JDBC）。服务提供者框架是提供者实现服务的系统，并且系统使得实现对客户端可用，从而将客户端从实现中分离出来。</p><p>书中这段读起来比较晦涩，对服务提供者框架在参考资料[3]中有解释，<br>　　<br><img src="assets/markdown-img-paste-20191230175836971.png" alt=""></p><p>服务提供者框架中有三个基本组：服务接口，它表示实现；提供者注册 API，提供者用来注册实现；以及服务访问 API，客户端使用该 API 获取服务的实例。服务访问 API 允许客户指定选择实现的标准。在缺少这样的标准的情况下，API 返回一个默认实现的实例，或者允许客户通过所有可用的实现进行遍历。服务访问 API 是灵活的静态工厂，它构成了服务提供者框架的基础。</p><p>  Class.forName(“com.mysql.jdbc.Driver”);</p><p>这样一个语句会实例化一个Driver类（提供服务者实现类），并将这个类的实例注册到DriverManager（服务提供者注册类）。</p><p>  DriverManager.getConnection(“jdbc:mysql://…”,”…”,”…”);<br>这里通过建立连接的URL等信息来获取数据库连接。DriverManager通过传进来的url信息判断出你是要获取那个服务提供者提供的服务。因为前面已经将提供服务者实现类注册到DriverManager了，DriverManager获取到这个服务提供者实现类对象之后，通过调用它的getService（mysql里面是connect方法）方法获取到服务具体实现类对象，返回的却是java.sql.Connection接口对象（因为服务具体实现类实现了Connection接口），这样把服务具体实现类对象隐藏了。提供了很好的扩展性。</p><p>　　服务提供者框架的一个可选的第四个组件是一个服务提供者接口，它描述了一个生成服务接口实例的工厂对象。在没有服务提供者接口的情况下，必须对实现进行反射实例化（详见第 65 条）。在 JDBC 的情况下，Connection 扮演服务接口的一部分，DriverManager.registerDriver 提供程序注册 API、DriverManager.getConnection 是服务访问 API，Driver 是服务提供者接口。</p><p>服务提供者框架模式有许多变种。 例如，服务访问 API 可以向客户端返回比提供者提供的更丰富的服务接口。 这是桥接模式。 依赖注入框架（详见第 5 条）可以被看作是强大的服务提供者。 从 Java 6 开始，平台包含一个通用的服务提供者框架 java.util.ServiceLoader，所以你不需要，一般也不应该自己编写（详见第 59 条）。 JDBC 不使用 ServiceLoader，因为前者早于后者。</p><h2 id="另一个优势，在创建带泛型的实例时，能使代码变得简洁"><a href="#另一个优势，在创建带泛型的实例时，能使代码变得简洁" class="headerlink" title="另一个优势，在创建带泛型的实例时，能使代码变得简洁"></a>另一个优势，在创建带泛型的实例时，能使代码变得简洁</h2><p>这条主要是针对带泛型类的繁琐声明而说的，需要重复书写两次泛型参数：</p><p>Map&lt;String,Date&gt; map = new HashMap&lt;String,Date&gt;();<br>不过自从 java7 开始，这种方式已经被优化过了 —— 对于一个已知类型的变量进行赋值时，由于泛型参数是可以被推导出，所以可以在创建实例时省略掉泛型参数。</p><p>Map&lt;String,Date&gt; map = new HashMap&lt;&gt;();</p><h1 id="除此之外"><a href="#除此之外" class="headerlink" title="除此之外"></a>除此之外</h1><p>以上是《Effective Java》中总结的几条应该使用静态工厂方法代替构造器的原因，除了上面总结的几条之外，静态工厂方法实际上还有更多的优势。</p><h2 id="可以有多个参数相同但名称不同的工厂方法"><a href="#可以有多个参数相同但名称不同的工厂方法" class="headerlink" title="可以有多个参数相同但名称不同的工厂方法"></a>可以有多个参数相同但名称不同的工厂方法</h2><p>构造函数虽然也可以有多个，但是由于函数名已经被固定，所以就要求参数必须有差异时（类型、数量或者顺序）才能够重载了。<br>举例来说：</p><pre><code>class Child{    int age = 10;    int weight = 30;    public Child(int age, int weight) {        this.age = age;        this.weight = weight;    }    public Child(int age) {        this.age = age;    }}</code></pre><p>Child 类有 age 和 weight 两个属性，如代码所示，它已经有了两个构造函数：Child(int age, int weight) 和 Child(int age)，这时候如果我们想再添加一个指定 wegiht 但不关心 age 的构造函数，一般是这样：</p><pre><code>public Child( int weight) {    this.weight = weight;}</code></pre><p>但要把这个构造函数添加到 Child 类中，我们都知道是行不通的，因为 java 的函数签名是忽略参数名称的，所以 Child(int age) 跟 Child(int weight) 会冲突。</p><p>这时候，静态工厂方法就可以登场了。</p><pre><code>class Child{    int age = 10;    int weight = 30;    public static Child newChild(int age, int weight) {        Child child = new Child();        child.weight = weight;        child.age = age;        return child;    }    public static Child newChildWithWeight(int weight) {        Child child = new Child();        child.weight = weight;        return child;    }    public static Child newChildWithAge(int age) {        Child child = new Child();        child.age = age;        return child;    }}</code></pre><p>其中的 newChildWithWeight 和 newChildWithAge，就是两个参数类型相同的的方法，但是作用不同，如此，就能够满足上面所说的类似Child(int age) 跟 Child(int weight)同时存在的需求。<br>（另外，这两个函数名字也是自描述的，相对于一成不变的构造函数更能表达自身的含义，这也是上面所说的第一条优势 —— 『它们有名字』）</p><h2 id="可以减少对外暴露的属性"><a href="#可以减少对外暴露的属性" class="headerlink" title="可以减少对外暴露的属性"></a>可以减少对外暴露的属性</h2><p>软件开发中有一条很重要的经验：对外暴露的属性越多，调用者就越容易出错。所以对于类的提供者，一般来说，应该努力减少对外暴露属性，从而降低调用者出错的机会。</p><p>考虑一下有如下一个 Player 类：</p><pre><code>// Player : Version 1class Player {    public static final int TYPE_RUNNER = 1;    public static final int TYPE_SWIMMER = 2;    public static final int TYPE_RACER = 3;    protected int type;    public Player(int type) {        this.type = type;    }}</code></pre><p>Player 对外提供了一个构造方法，让使用者传入一个 type 来表示类型。那么这个类期望的调用方式就是这样的：</p><pre><code>Player player1 = new Player(Player.TYPE_RUNNER);Player player2 = new Player(Player.TYPE_SWEIMMER);</code></pre><p>但是，我们知道，提供者是无法控制调用方的行为的，实际中调用方式可能是这样的：</p><pre><code>Player player3 = new Player(0);Player player4 = new Player(-1);Player player5 = new Player(10086);</code></pre><p>提供者期望的构造函数传入的值是事先定义好的几个常量之一，但如果不是，就很容易导致程序错误。</p><p>—— 要避免这种错误，使用枚举来代替常量值是常见的方法之一，当然如果不想用枚举的话，使用我们今天所说的主角静态工厂方法也是一个很好的办法。</p><p>插一句：<br>实际上，使用枚举也有一些缺点，比如增大了调用方的成本；如果枚举类成员增加，会导致一些需要完备覆盖所有枚举的调用场景出错等。<br>如果把以上需求用静态工厂方法来实现，代码大致是这样的：</p><pre><code>// Player : Version 2class Player {    public static final int TYPE_RUNNER = 1;    public static final int TYPE_SWIMMER = 2;    public static final int TYPE_RACER = 3;    int type;    private Player(int type) {        this.type = type;    }    public static Player newRunner() {        return new Player(TYPE_RUNNER);    }    public static Player newSwimmer() {        return new Player(TYPE_SWIMMER);    }    public static Player newRacer() {        return new Player(TYPE_RACER);    }}</code></pre><p>注意其中的构造方法被声明为了 private，这样可以防止它被外部调用，于是调用方在使用 Player 实例的时候，基本上就必须通过 newRunner、newSwimmer、newRacer 这几个静态工厂方法来创建，调用方无须知道也无须指定 type 值 —— 这样就能把 type 的赋值的范围控制住，防止前面所说的异常值的情况。</p><p>插一句：<br>严谨一些的话，通过反射仍能够绕过静态工厂方法直接调用构造函数，甚至直接修改一个已创建的 Player 实例的 type 值，但本文暂时不讨论这种非常规情况。</p><h2 id="多了一层控制，方便统一修改"><a href="#多了一层控制，方便统一修改" class="headerlink" title="多了一层控制，方便统一修改"></a>多了一层控制，方便统一修改</h2><p>我们在开发中一定遇到过很多次这样的场景：在写一个界面时，服务端的数据还没准备好，这时候我们经常就需要自己在客户端编写一个测试的数据，来进行界面的测试，像这样：</p><pre><code>// 创建一个测试数据User tester = new User();tester.setName(&quot;隔壁老王&quot;);tester.setAge(25);tester.setDescription(&quot;我住隔壁我姓王！&quot;);// use testerbindUI(tester);……</code></pre><p>要写一连串的测试代码，如果需要测试的界面有多个，那么这一连串的代码可能还会被复制多次到项目的多个位置。</p><p>这种写法的缺点呢，首先是代码臃肿、混乱；其次是万一上线的时候漏掉了某一处，忘记修改，那就可以说是灾难了……</p><p>但是如果你像我一样，习惯了用静态工厂方法代替构造器的话，则会很自然地这么写，先在 User 中定义一个 newTestInstance 方法：</p><pre><code>static class User{    String name ;    int age ;    String description;    public static User newTestInstance() {        User tester = new User();        tester.setName(&quot;隔壁老王&quot;);        tester.setAge(25);        tester.setDescription(&quot;我住隔壁我姓王！&quot;);        return tester;    }}</code></pre><p>然后调用的地方就可以这样写了：</p><pre><code>// 创建一个测试数据User tester = User.newTestInstance();// use testerbindUI(tester);</code></pre><p>是不是瞬间就觉得优雅了很多？！</p><p>而且不只是代码简洁优雅，由于所有测试实例的创建都是在这一个地方，所以在需要正式数据的时候，也只需把这个方法随意删除或者修改一下，所有调用者都会编译不通过，彻底杜绝了由于疏忽导致线上还有测试代码的情况。</p><h1 id="缺点：没有公共或受保护构造方法的类不能被子类化"><a href="#缺点：没有公共或受保护构造方法的类不能被子类化" class="headerlink" title="缺点：没有公共或受保护构造方法的类不能被子类化"></a>缺点：没有公共或受保护构造方法的类不能被子类化</h1><p>例如，要想将 Collections 框架中任何遍历的实现类进行子类化，是不可能的。但是这样也会因祸得福，因为它鼓励程序员使用组合（composition）而不是继承（详见第 18 条），并且是不可变类型锁需要的（详见第 17 条）。</p><h1 id="静态工厂方法的第二个缺点是，程序员很难找到它们"><a href="#静态工厂方法的第二个缺点是，程序员很难找到它们" class="headerlink" title="静态工厂方法的第二个缺点是，程序员很难找到它们"></a>静态工厂方法的第二个缺点是，程序员很难找到它们</h1><p>它们不像构造方法那样在 API 文档中明确的标注出来。因此，对于提供了静态方法而不是构造器的类来说，想要查明如何实例化一个类是十分困难的。</p><p>通过关注类或者接口的文档中静态方法，并且遵守标准的命名习惯，也可以弥补这一劣势。下面是一些静态工厂方法的常用名称。以下清单这是列出了其中的一小部分：</p><p>from —— 类型转换方法，它接受单个参数并返回此类型的相应实例，例如：</p><pre><code>Date d = Date.from(instant);</code></pre><p>of —— 聚合方法，接受多个参数并返回该类型的实例，并把他们合并在一起，例如：</p><pre><code>Set faceCards = EnumSet.of(JACK, QUEEN, KING);</code></pre><p>valueOf —— from 和 to 更为详细的替代 方式，例如：</p><pre><code>BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);</code></pre><p>instance 或 getinstance —— 返回一个由其参数 (如果有的话) 描述的实例，但不能说它具有相同的值，例如：</p><pre><code>StackWalker luke = StackWalker.getInstance(options);</code></pre><p>create 或 newInstance —— 与 instance 或 getInstance 类似，除此之外该方法保证每次调用返回一个新的实例，例如：</p><pre><code>Object newArray = Array.newInstance(classObject, arrayLen);</code></pre><p>getType —— 与 getInstance 类似，但是在工厂方法处于不同的类中的时候使用。getType 中的 Type 是工厂方法返回的对象类型，例如：</p><pre><code>FileStore fs = Files.getFileStore(path);</code></pre><p>newType —— 与 newInstance 类似，但是在工厂方法处于不同的类中的时候使用。newType中的 Type 是工厂方法返回的对象类型，例如：</p><pre><code>BufferedReader br = Files.newBufferedReader(path);</code></pre><p>type —— getType 和 newType 简洁的替代方式，例如：</p><pre><code>List litany = Collections.list(legacyLitany);</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>静态工厂方法和公共构造方法都有它们的用途，并且了解它们的相对优点是值得的。通常，静态工厂更可取，因此避免在没有考虑静态工厂的情况下直接选择使用公共构造方法</p><p>总体来说，『考虑使用静态工厂方法代替构造器』这点，除了有名字、可以用子类等这些语法层面上的优势之外，更多的是在工程学上的意义，它实质上的最主要作用是：能够增大类的提供者对自己所提供的类的控制力。</p><p>作为一个开发者，当我们作为调用方，使用别人提供的类时，如果要使用 new 关键字来为其创建一个类实例，如果对类不是特别熟悉，那么一定是要特别慎重的 —— new 实在是太好用了，以致于它经常被滥用，随时随地的 new 是有很大风险的，除了可能导致性能、内存方面的问题外，也经常会使得代码结构变得混乱。</p><p>而当我们在作为类的提供方时，无法控制调用者的具体行为，但是我们可以尝试使用一些方法来增大自己对类的控制力，减少调用方犯错误的机会，这也是对代码更负责的具体体现。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】 <a href="https://www.diycode.cc/topics/1027" target="_blank" rel="noopener">https://www.diycode.cc/topics/1027</a><br>【2】 <a href="https://www.jianshu.com/p/eb30a388c5fc" target="_blank" rel="noopener">https://www.jianshu.com/p/eb30a388c5fc</a><br>【3】 <a href="https://juejin.im/post/5d6a0652f265da03df5f285d" target="_blank" rel="noopener">https://juejin.im/post/5d6a0652f265da03df5f285d</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;静态静态工厂方法&lt;/p&gt;
    
    </summary>
    
      <category term="2019年12月" scheme="http://yoursite.com/categories/2019%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Design Pattern，Java" scheme="http://yoursite.com/tags/Design-Pattern%EF%BC%8CJava/"/>
    
  </entry>
  
  <entry>
    <title>Effctive-Java阅读笔记I</title>
    <link href="http://yoursite.com/2019/12/30/Effctive-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0I/"/>
    <id>http://yoursite.com/2019/12/30/Effctive-Java阅读笔记I/</id>
    <published>2019-12-30T08:30:12.000Z</published>
    <updated>2019-12-31T03:50:26.601Z</updated>
    
    <content type="html"><![CDATA[<p>第二章阅读：创建和销毁对象：<br>01.考虑使用静态工厂方法替代构造方法<br>02.当构造方法参数过多时使用 builder 模式</p><a id="more"></a><h1 id="考虑使用静态工厂方法替代构造方法"><a href="#考虑使用静态工厂方法替代构造方法" class="headerlink" title="考虑使用静态工厂方法替代构造方法"></a>考虑使用静态工厂方法替代构造方法</h1><p>此处详见设计模式学习笔记III-静态工厂方法。</p><h1 id="当构造方法参数过多时使用-builder-模式"><a href="#当构造方法参数过多时使用-builder-模式" class="headerlink" title="当构造方法参数过多时使用 builder 模式"></a>当构造方法参数过多时使用 builder 模式</h1><p>静态工厂和构造方法都有一个限制：它们不能很好地扩展到很多可选参数的情景。传统上，程序员使用了可伸缩（telescoping constructor）构造方法模式。<br>在这种模式中，首先提供一个只有必需参数的构造方法，接着提供增加了一个可选参数的构造函数，然后提供增加了两个可选参数的构造函数，等等，最终在构造函数中包含所有必需和可选参数。以下就是它在实践中的样子。为了简便起见，只显示了四个可选属性：</p><pre><code>// Telescoping constructor pattern - does not scale well!public class NutritionFacts {    private final int servingSize;  // (mL)            required    private final int servings;     // (per container) required    private final int calories;     // (per serving)   optional    private final int fat;          // (g/serving)     optional    private final int sodium;       // (mg/serving)    optional    private final int carbohydrate; // (g/serving)     optional    public NutritionFacts(int servingSize, int servings) {        this(servingSize, servings, 0);    }    public NutritionFacts(int servingSize, int servings,            int calories) {        this(servingSize, servings, calories, 0);    }    public NutritionFacts(int servingSize, int servings,            int calories, int fat) {        this(servingSize, servings, calories, fat, 0);    }    public NutritionFacts(int servingSize, int servings,            int calories, int fat, int sodium) {        this(servingSize, servings, calories, fat, sodium, 0);    }    public NutritionFacts(int servingSize, int servings,           int calories, int fat, int sodium, int carbohydrate) {        this.servingSize  = servingSize;        this.servings     = servings;        this.calories     = calories;        this.fat          = fat;        this.sodium       = sodium;        this.carbohydrate = carbohydrate;    }}</code></pre><p>当想要创建一个实例时，可以使用包含所有要设置的参数的最短参数列表的构造方法：</p><pre><code>NutritionFacts cocaCola = new NutritionFacts(240, 8, 100, 0, 35, 27);</code></pre><p>通常情况下，这个构造方法的调用需要许多你不想设置的参数，但是你不得不为它们传递一个值。 在这种情况下，我们为 fat 属性传递了 0 值。「只有」六个参数可能看起来并不那么糟糕，但随着参数数量的增加，它很快就会失控。</p><p>　　简而言之，可伸缩构造方法模式是有效的，但是当有很多参数时，很难编写客户端代码，而且很难读懂它。</p><p>当在构造方法中遇到许多可选参数时，另一种选择是 JavaBeans 模式，在这种模式中，调用一个无参的构造方法来创建对象，然后调用 setter 方法来设置每个必需的参数和可选参数：</p><pre><code>// JavaBeans Pattern - allows inconsistency, mandates mutabilitypublic class NutritionFacts {// Parameters initialized to default values (if any)private int servingSize  = -1; // Required; no default valueprivate int servings     = -1; // Required; no default valueprivate int calories     = 0;private int fat          = 0;private int sodium       = 0;private int carbohydrate = 0;public NutritionFacts() { }// Setterspublic void setServingSize(int val)  { servingSize = val; }public void setServings(int val)    { servings = val; }public void setCalories(int val)    { calories = val; }public void setFat(int val)         { fat = val; }public void setSodium(int val)      { sodium = val; }public void setCarbohydrate(int val) { carbohydrate = val; }}</code></pre><p>这种模式没有伸缩构造方法模式的缺点。有点冗长，但创建实例很容易，并且易于阅读所生成的代码:</p><pre><code>NutritionFacts cocaCola = new NutritionFacts();cocaCola.setServingSize(240);cocaCola.setServings(8);cocaCola.setCalories(100);cocaCola.setSodium(35);cocaCola.setCarbohydrate(27);</code></pre><p>JavaBeans 模式本身有严重的缺陷。由于构造方法被分割成了多次调用，所以在构造过程中 JavaBean 可能处于不一致的状态。该类没有通过检查构造参数参数的有效性来强制一致性的选项。在不一致的状态下尝试使用对象可能会导致一些错误，这些错误与平常代码的BUG很是不同，因此很难调试。一个相关的缺点是，JavaBeans 模式排除了让类不可变的可能性（详见第 17 条），并且需要程序员增加工作以确保线程安全。</p><p>　　通过在对象构建完成时手动「冻结」对象，并且不允许它在解冻之前使用，可以减少这些缺点，但是这种变体在实践中很难使用并且很少使用。 而且，在运行时会导致错误，因为编译器无法确保程序员会在使用对象之前调用 freeze 方法。</p><p>　　幸运的是，还有第三种选择，它结合了可伸缩构造方法模式的安全性和 JavaBean 模式的可读性。 它是 Builder 模式[Gamma95] 的一种形式。客户端不直接构造所需的对象，而是调用一个包含所有必需参数的构造方法 (或静态工厂)得到获得一个 builder 对象。以下是它在实践中的示例：</p><pre><code>// Builder Patternpublic class NutritionFacts {    private final int servingSize;    private final int servings;    private final int calories;    private final int fat;    private final int sodium;    private final int carbohydrate;    public static class Builder {        // Required parameters        private final int servingSize;        private final int servings;        // Optional parameters - initialized to default values        private int calories      = 0;        private int fat           = 0;        private int sodium        = 0;        private int carbohydrate  = 0;        public Builder(int servingSize, int servings) {            this.servingSize = servingSize;            this.servings    = servings;        }        public Builder calories(int val) {            calories = val;                  return this;        }        public Builder fat(int val) {           fat = val;                      return this;        }        public Builder sodium(int val) {           sodium = val;                   return this;        }        public Builder carbohydrate(int val) {           carbohydrate = val;             return this;        }        public NutritionFacts build() {            return new NutritionFacts(this);        }    }    private NutritionFacts(Builder builder) {        servingSize  = builder.servingSize;        servings     = builder.servings;        calories     = builder.calories;        fat          = builder.fat;        sodium       = builder.sodium;        carbohydrate = builder.carbohydrate;    }}</code></pre><p>然后，客户端调用 builder 对象的与 setter 相似方法来设置你想设置的可选参数。最后，客户端调用builder对象的一个无参的 build 方法来生成对象，该对象通常是不可变的。Builder 通常是它所构建的类的一个静态成员类（详见第 24 条）。<br>　　NutritionFacts 类是不可变的，所有的参数默认值都在一个地方。builder 的 setter 方法返回 builder 本身，这样就可以进行链式调用，从而生成一个流畅的 API。下面是客户端代码的示例：</p><pre><code>NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8).calories(100).sodium(35).carbohydrate(27).build();</code></pre><p>为了简洁起见，省略了有效性检查。 要尽快检测无效参数，检查 builder 的构造方法和方法中的参数有效性。 在 build 方法调用的构造方法中检查包含多个参数的不变性。为了确保这些不变性不受攻击，在从 builder 复制参数后对对象属性进行检查（详见第 50 条）。 如果检查失败，则抛出 IllegalArgumentException 异常（详见第 72 条），其详细消息指示哪些参数无效（详见第 75 条）。</p><p>Builder 模式非常适合类层次结构。 使用平行层次的 builder，每个builder嵌套在相应的类中。 抽象类有抽象的 builder；具体的类有具体的 builder。 例如，考虑代表各种比萨饼的根层次结构的抽象类：</p><pre><code>// Builder pattern for class hierarchiesimport java.util.EnumSet;import java.util.Objects;import java.util.Set;public abstract class Pizza {  //配料枚举：火腿，蘑菇，洋葱，辣椒，香肠    public enum Topping {HAM, MUSHROOM, ONION, PEPPER, SAUSAGE}    final Set&lt;Topping&gt; toppings;    abstract static class Builder&lt;T extends Builder&lt;T&gt;&gt; {        EnumSet&lt;Topping&gt; toppings = EnumSet.noneOf(Topping.class);        public T addTopping(Topping topping) {            toppings.add(Objects.requireNonNull(topping));            return self();        }        abstract Pizza build();        // Subclasses must override this method to return &quot;this&quot;        protected abstract T self();    }    Pizza(Builder&lt;?&gt; builder) {        toppings = builder.toppings.clone(); // See Item 50    }}</code></pre><p>请注意，Pizza.Builder 是一个带有递归类型参数（ recursive type parameter）（详见第 30 条）的泛型类型。 这与抽象的 self 方法一起，允许方法链在子类中正常工作，而不需要强制转换。 Java 缺乏自我类型的这种变通解决方法被称为模拟自我类型（simulated self-type）。</p><p>　　这里有两个具体的 Pizza 的子类，其中一个代表标准的纽约风格的披萨，另一个是半圆形烤乳酪馅饼。前者有一个所需的尺寸参数，而后者则允许指定酱汁是否应该在里面或在外面：</p><pre><code>import java.util.Objects;public class NyPizza extends Pizza {    public enum Size { SMALL, MEDIUM, LARGE }    private final Size size;    public static class Builder extends Pizza.Builder&lt;Builder&gt; {        private final Size size;        public Builder(Size size) {            this.size = Objects.requireNonNull(size);        }        @Override public NyPizza build() {            return new NyPizza(this);        }        @Override protected Builder self() {            return this;        }    }    private NyPizza(Builder builder) {        super(builder);        size = builder.size;    }}public class Calzone extends Pizza {    private final boolean sauceInside; //内部的酱料    public static class Builder extends Pizza.Builder&lt;Builder&gt; {        private boolean sauceInside = false; // Default        public Builder sauceInside() {            sauceInside = true;            return this;        }        @Override public Calzone build() {            return new Calzone(this);        }        @Override protected Builder self() {            return this;        }    }    private Calzone(Builder builder) {        super(builder);        sauceInside = builder.sauceInside;    }}</code></pre><p>请注意，每个子类 builder 中的 build 方法被声明为返回正确的子类：NyPizza.Builder 的 build 方法返回 NyPizza，而 Calzone.Builder 中的 build 方法返回 Calzone。 这种技术，其一个子类的方法被声明为返回在超类中声明的返回类型的子类型，称为协变返回类型（covariant return typing）。 它允许客户端使用这些 builder，而不需要强制转换。</p><p>　　这些「分层 builder（hierarchical builders）」的客户端代码基本上与简单的 NutritionFacts builder 的代码相同。为了简洁起见，下面显示的示例客户端代码假设枚举常量的静态导入：</p><pre><code>NyPizza pizza = new NyPizza.Builder(SMALL)        .addTopping(SAUSAGE).addTopping(ONION).build();Calzone calzone = new Calzone.Builder()        .addTopping(HAM).sauceInside().build();</code></pre><p>builder 对构造方法的一个微小的优势是，builder 可以有多个可变参数，因为每个参数都是在它自己的方法中指定的。或者，builder 可以将传递给多个调用的参数聚合到单个属性中，如前面的 addTopping 方法所演示的那样。</p><p>　　Builder 模式非常灵活。 单个 builder 可以重复使用来构建多个对象。 builder 的参数可以在构建方法的调用之间进行调整，以改变创建的对象。 builder 可以在创建对象时自动填充一些属性，例如每次创建对象时增加的序列号。</p><p>　　Builder 模式也有缺点。为了创建对象，首先必须创建它的 builder。虽然创建这个 builder 的成本在实践中不太可能被注意到，但在看中性能的场合下这可能就是一个问题。而且，builder 模式比伸缩构造方法模式更冗长，因此只有在有足够的参数时才值得使用它，比如四个或更多。但是请记住，你可能在以后会想要添加更多的参数。但是，如果你一开始是使用的构造方法或静态工厂，当类演化到参数数量失控的时候再转到Builder模式，过时的构造方法或静态工厂就会面临尴尬的处境。因此，通常最好从一开始就创建一个 builder。</p><p>　　总而言之，当设计类的构造方法或静态工厂的参数超过几个时，Builder 模式是一个不错的选择，特别是如果许多参数是可选的或相同类型的。builder模式客户端代码比使用伸缩构造方法（telescoping constructors）更容易读写，并且builder模式比 JavaBeans 更安全。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="https://sjsdfg.github.io/effective-java-3rd-chinese/#/" target="_blank" rel="noopener">https://sjsdfg.github.io/effective-java-3rd-chinese/#/</a><br>【2】<a href="https://lingcoder.github.io/OnJava8/#/" target="_blank" rel="noopener">https://lingcoder.github.io/OnJava8/#/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二章阅读：创建和销毁对象：&lt;br&gt;01.考虑使用静态工厂方法替代构造方法&lt;br&gt;02.当构造方法参数过多时使用 builder 模式&lt;/p&gt;
    
    </summary>
    
      <category term="2019年12月" scheme="http://yoursite.com/categories/2019%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Design Pattern，Java" scheme="http://yoursite.com/tags/Design-Pattern%EF%BC%8CJava/"/>
    
  </entry>
  
  <entry>
    <title>Scala学习笔记V</title>
    <link href="http://yoursite.com/2019/12/27/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0V/"/>
    <id>http://yoursite.com/2019/12/27/Scala学习笔记V/</id>
    <published>2019-12-27T06:08:12.000Z</published>
    <updated>2019-12-27T06:29:21.578Z</updated>
    
    <content type="html"><![CDATA[<p>scala中下划线_的用途</p><a id="more"></a><h1 id="初始化。"><a href="#初始化。" class="headerlink" title="初始化。"></a>初始化。</h1><pre><code>object Sample { var name:String=_ def main (args: Array[String]){ name=&quot;hello world&quot;  println(name) }</code></pre><p>在这里，name也可以声明为null，例：var name:String=null。这里的下划线和null的作用是一样的。</p><h1 id="引入时"><a href="#引入时" class="headerlink" title="引入时"></a>引入时</h1><pre><code>import math._object Sample {   def main (args: Array[String]){    println(BigInt(123))   }}</code></pre><p>这里的math._就相当于Java中的math.*; 即“引用包中的所有内容”。</p><h1 id="集合中使用。（最典型，最常用）"><a href="#集合中使用。（最典型，最常用）" class="headerlink" title="集合中使用。（最典型，最常用）"></a>集合中使用。（最典型，最常用）</h1><pre><code> object Sample {   def main (args: Array[String]){    val newArry= (1 to 10).map(_*2)   println(newArry)   }}</code></pre><p>这里的下划线代表了集合中的“某（this）”一个元素。这个用法很常见，在foreach等语句中也可以使用。</p><h1 id="模式匹配。"><a href="#模式匹配。" class="headerlink" title="模式匹配。"></a>模式匹配。</h1><pre><code> object Sample {   def main (args: Array[String]){     val value=&quot;a&quot;  val result=  value match{       case &quot;a&quot; =&gt; 1       case &quot;b&quot; =&gt; 2       case _ =&gt;&quot;result&quot;     }     println(result)   }}</code></pre><p>在这里的下划线相当于“others”的意思，就像Java  switch语句中的“default”。</p><p>还有一种写法，是被Some“包”起来的，说明Some里面是有值的，而不是None。<br>    object Sample {<br>      def main (args: Array[String]){<br>        val value=Some(“a”)<br>        val result=  value match{<br>          case Some(_) =&gt; 1<br>          case _ =&gt;”result”<br>        }<br>        println(result)<br>      }</p><p>还有一种表示队列</p><pre><code>object Sample {  def main (args: Array[String]){    val value=1 to 5    val result=  value match{      case Seq(_,_*) =&gt; 1      case _ =&gt;&quot;result&quot;    }    println(result)  }}</code></pre><h1 id="函数中使用。"><a href="#函数中使用。" class="headerlink" title="函数中使用。"></a>函数中使用。</h1><pre><code>object Sample {   def main (args: Array[String]){    val set=setFunction(3.0,_:Double)     println(set(7.1))   }  def setFunction(parm1:Double,parm2:Double): Double = parm1+parm2}</code></pre><p>这是Scala特有的“偏函数”用法。</p><h1 id="元组Tuple。（如果这也算是的话）"><a href="#元组Tuple。（如果这也算是的话）" class="headerlink" title="元组Tuple。（如果这也算是的话）"></a>元组Tuple。（如果这也算是的话）</h1><pre><code>object Sample {   def main (args: Array[String])={     val value=(1,2)     print(value._1)   }}</code></pre><h1 id="传参。"><a href="#传参。" class="headerlink" title="传参。"></a>传参。</h1><pre><code>object Sample {   def main (args: Array[String])={    val result=sum(1 to 5:_*)     println(result)   }  def sum(parms:Int*)={    var result=0    for(parm &lt;- parms)result+=parm    result  }}</code></pre><p>当函数接收的参数不定长的时候，假如你想输入一个队列，可以在一个队列后加入“:_*”，因此，这里的“1 to 5”也可以改写为：“Seq(1,2,3,4,5)”。这算是一个小的用法吧</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://blog.csdn.net/i6448038/article/details/50017427" target="_blank" rel="noopener">https://blog.csdn.net/i6448038/article/details/50017427</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;scala中下划线_的用途&lt;/p&gt;
    
    </summary>
    
      <category term="2019年12月" scheme="http://yoursite.com/categories/2019%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记XII</title>
    <link href="http://yoursite.com/2019/12/24/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0XII/"/>
    <id>http://yoursite.com/2019/12/24/Java学习笔记XII/</id>
    <published>2019-12-24T03:21:12.000Z</published>
    <updated>2019-12-25T08:52:45.588Z</updated>
    
    <content type="html"><![CDATA[<p>使用Java批量转换文件夹中的文件编码格式，删除文件中的代码</p><a id="more"></a><p>用Java将某个文件夹中UTF-8格式的文件批量转换为GBK格式的文件，代码如下：</p><p>   private static String sourcePath = “/Users/liyiye/Documents/课程代码”;// 文件夹源路径<br>   private static String destPath = “/Users/liyiye/Documents/ANSI格式课程代码”;<br>   private static void utf8ToANSI(){<br>       try {<br>           File sourceDirectory = new File(sourcePath);<br>           File destDirectory = new File(destPath);<br>           if (!sourceDirectory.isDirectory()) {<br>               return;<br>           }<br>           // 获取文件夹中的所有.cpp文件，包括所有子级文件夹中的文件<br>           Collection<file> files = FileUtils.listFiles(sourceDirectory, new String[] { “cpp”, “CPP” }, true);<br>           for (File file : files) {<br>               String absolutePath = file.getAbsolutePath();<br>               String newDir = absolutePath.replace(sourceDirectory.getName(), destDirectory.getName());<br>               // 把单个文件从utf-8编码转化到gbk编码，生成新文件，可以自动创建父级目录<br>               FileUtils.writeLines(new File(newDir), “GBK”, FileUtils.readLines(file, “UTF-8”));<br>           }<br>           // 删除源目录,子文件都删除<br>           // FileUtils.deleteQuietly(sourceDirectory);<br>           // 把生成文件目录重命名成源目录名<br>           destDirectory.renameTo(new File(sourceDirectory.getAbsolutePath()));<br>           System.out.println(“success”);<br>       } catch (IOException e) {<br>           e.printStackTrace();<br>       }<br>   }</file></p><p>批量删除代码中的注释</p><pre><code>private static int count = 0;/** * 删除文件中的各种注释，包含//、/* * /等 * * @param charset *            文件编码 * @param file *            文件 */public static void clearComment(File file, String charset) {    try {        // 递归处理文件夹        if (!file.exists()) {            return;        }        if (file.isDirectory()) {            File[] files = file.listFiles();            for (File f : files) {                clearComment(f, charset); // 递归调用            }            return;        } else if (!file.getName().endsWith(&quot;.cpp&quot;)) {            // 非java文件直接返回            return;        }        System.out.println(&quot;-----开始处理文件：&quot; + file.getAbsolutePath());        // 根据对应的编码格式读取        BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(file), charset));        StringBuffer content = new StringBuffer();        String tmp = null;        while ((tmp = reader.readLine()) != null) {            content.append(tmp);            content.append(&quot;\n&quot;);        }        reader.close();        String target = content.toString();        // String s =        // target.replaceAll(&quot;\\/\\/[^\\n]*|\\/\\*([^\\*^\\/]*|[\\*^\\/*]*|[^\\**\\/]*)*\\*\\/&quot;,        // &quot;&quot;); //本段正则摘自网上，有一种情况无法满足（/* ...**/），略作修改        String s = target.replaceAll(&quot;\\/\\/[^\\n]*|\\/\\*([^\\*^\\/]*|[\\*^\\/*]*|[^\\**\\/]*)*\\*+\\/&quot;, &quot;&quot;);        // System.out.println(s);        // 使用对应的编码格式输出        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), charset));        out.write(s);        out.flush();        out.close();        count++;        System.out.println(&quot;-----文件处理完成---&quot; + count);    } catch (Exception e) {        e.printStackTrace();    }}public static void clearComment(String filePath, String charset) {    clearComment(new File(filePath), charset);}public static void clearComment(String filePath) {    clearComment(new File(filePath), &quot;GBK&quot;);}public static void clearComment(File file) {    clearComment(file, &quot;GBK&quot;);}public  static   void  main(String[] args){    clearComment(destPath);}</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="https://blog.csdn.net/qq1032355091/article/details/51803496" target="_blank" rel="noopener">https://blog.csdn.net/qq1032355091/article/details/51803496</a><br>【2】<a href="https://www.cnblogs.com/hfultrastrong/p/7689630.html" target="_blank" rel="noopener">https://www.cnblogs.com/hfultrastrong/p/7689630.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Java批量转换文件夹中的文件编码格式，删除文件中的代码&lt;/p&gt;
    
    </summary>
    
      <category term="2019年12月" scheme="http://yoursite.com/categories/2019%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Scala学习笔记IV</title>
    <link href="http://yoursite.com/2019/12/23/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0IV/"/>
    <id>http://yoursite.com/2019/12/23/Scala学习笔记IV/</id>
    <published>2019-12-23T10:08:12.000Z</published>
    <updated>2019-12-23T10:19:25.471Z</updated>
    
    <content type="html"><![CDATA[<p>数据库连接和事务处理</p><a id="more"></a><h1 id="Session-管理"><a href="#Session-管理" class="headerlink" title="Session 管理"></a>Session 管理</h1><p>现在有了一个数据库对象可以打开一个数据库（Slick 函数库封装了一个 Session 对象）</p><p>Database 的 withSession 方法，创建一个 Session 对象，它可以传递给一个函数，函数返回时自动关闭这个 Session 对象，如果你使用连接池，关闭 Session 对象，自动将连接退回连接池。</p><pre><code>val query = for (c &lt;- coffees) yield c.nameval result = db.withSession {    session =&gt;    query.list()( session )}</code></pre><p>可以看到，我们可以在 withSession 之外定义查询，只有在实际执行查询时才需要一个 Session 对象，要注意的是 Session 的缺省模式为自动提交（auto-commit )模式。每个数据库指令（比如 insert )都自动提交给数据库。 如果需要将几个指令作为一个整体，那么就需要使用事务处理（Transaction） 上面的例子，我们在执行查询时，明确指明了 session 对象，你可以使用隐含对象来避免这种情况，比如：</p><pre><code>val query = for (c &lt;- coffees) yield c.nameval result = db.withSession {    implicit session =&gt;    query.list // &lt;- takes session implicitly}// query.list // &lt;- would not compile, no implicit value of type Session</code></pre><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="http://wiki.jikexueyuan.com/project/slick-guide/database-and-transaction-processing.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/slick-guide/database-and-transaction-processing.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据库连接和事务处理&lt;/p&gt;
    
    </summary>
    
      <category term="2019年12月" scheme="http://yoursite.com/categories/2019%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记XI</title>
    <link href="http://yoursite.com/2019/12/23/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0XI/"/>
    <id>http://yoursite.com/2019/12/23/Java学习笔记XI/</id>
    <published>2019-12-23T07:41:12.000Z</published>
    <updated>2019-12-23T08:22:59.724Z</updated>
    
    <content type="html"><![CDATA[<p>Java中静态方法和实例方法的异同</p><a id="more"></a><h1 id="类方法（静态方法）："><a href="#类方法（静态方法）：" class="headerlink" title="类方法（静态方法）："></a>类方法（静态方法）：</h1><p>用static修饰的方法，也称为静态方法，类方法属类本身的方法，不属于类的某一个实例（对象）。类方法中不可直接使用实例变量。其调用方式有三种：可直接调用、类名.方法名、对象名.方法名。</p><p>类方法体有如下限制：</p><p>1.类方法中不能引用对象变量；</p><p>2.类方法中不能调用类的对象方法；</p><p>3.在类方法中不能调使用super，this关键字；</p><p>4.类方法不能被覆盖。</p><h1 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h1><p>指的是不用static关键字修饰的方法。每个实例对象都有自身的实例方法，互相独立，不共享一个。其调用方式只能是对象名.方法名。</p><p>用修饰符static声明的方法为静态方法，不用修饰符static声明的方法为实例方法。</p><p>不管类生成或未生成对象，类的静态方法都可以被使用，使用格式为：类名.静态方法名。静态方法只能使用该静态方法所在类的静态数据成员和静态方法。这是因为使用静态方法时，该静态方法所在类可能还没有对象，即使有对象，由于用类名.静态方法名方式调用静态方法，静态方法没有this指针来存放对象的地址，无法判定应访问哪个对象的数据成员。在类创建对象后，实例方法才能被使用，使用格式为：对象名.实例方法名。实例方法可以使用该方法所在类的所有静态成员和实例成员。 </p><p>1.实例方法中可以引用对象变量，也可以引用类变量；</p><p>2.实例方法中可以调用类方法；</p><p>3.对象方法中可以使用super，this关键字。</p><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>当类的字节码文件被加载到内存时，类的实例方法不会被分配入口地址，当该类创建对象后，类中的实例方法才分配入口地址，从而实例方法可以被类创建的任何对象调用执行。需要注意的是，当我们创建第一个对象时，类中的实例方法就分配了入口地址，当再创建对象时，不再分配入口地址，也就是说，方法的入口地址被所有的对象共享，当所有的对象都不存在时，方法的入口地址才被取消。</p><p>对于类中的类方法，在该类被加载到内存时，就分配了相应的入口地址。从而类方法不仅可以被类创建的任何对象调用执行，也可以直接通过类名调用。类方法的入口地址直到程序退出时才被取消。</p><p>类方法在类的字节码加载到内存时就分配了入口地址。因此，Java语言允许通过类名直接调用类方法，而实例方法不能通过类名调用。在Java语言中，类中的类方法不可以操作实例变量，也不可以调用实例方法，这是因为在类创建对象之前，实例成员变量还没有分配内存，而且实例方法也没有入口地址。</p><h1 id="何时用静态方法，何时用实例方法？"><a href="#何时用静态方法，何时用实例方法？" class="headerlink" title="何时用静态方法，何时用实例方法？"></a>何时用静态方法，何时用实例方法？</h1><p>先说实例方法，当给一个类写一个方法，如果该方法需要访问某个实例的成员变量时，那么就将该方法定义成实例方法。一类的实例通常有一些成员变量，其中含有该实例的状态信息。而该方法需要改变这些状态。那么该方法需要声明成实例方法。</p><p>静态方法正好相反，它不需要访问某个实例的成员变量，它不需要去改变某个实例的状态。我们把该方法定义成静态方法。</p><h1 id="关于静态方法和实例方法的一些误区。"><a href="#关于静态方法和实例方法的一些误区。" class="headerlink" title="关于静态方法和实例方法的一些误区。"></a>关于静态方法和实例方法的一些误区。</h1><p>误区一、静态方法常驻内存，实例方法不是，所以静态方法效率高但占内存。</p><p>事实上，方法都是一样的，在加载时机和占用内存上，静态方法和实例方法是一样的，在类型第一次被使用时加载。调用的速度基本上没有差别。 </p><p>误区二、静态方法在堆上分配内存，实例方法在堆栈上。 </p><p>事实上所有的方法都不可能在堆或者堆栈上分配内存，方法作为代码是被加载到特殊的代码内存区域，这个内存区域是不可写的。 </p><p>误区三、实例方法需要先创建实例才可以调用，比较麻烦，静态方法不用，比较简单。 </p><pre><code>事实上如果一个方法与他所在类型的实例无关，那么它就应该是静态的，决不会有人把它写成实例方法。所以所有的实例方法都与实例有关，既然与实例有关，那么创建实例就是必然的步骤，没有麻烦简单一说。实际上上你可以把所有的实例方法都写成静态的，将实例作为参数传入即可。 </code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="https://blog.csdn.net/klyz1314/article/details/16845679" target="_blank" rel="noopener">https://blog.csdn.net/klyz1314/article/details/16845679</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java中静态方法和实例方法的异同&lt;/p&gt;
    
    </summary>
    
      <category term="2019年12月" scheme="http://yoursite.com/categories/2019%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Scala学习笔记III</title>
    <link href="http://yoursite.com/2019/12/23/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0III/"/>
    <id>http://yoursite.com/2019/12/23/Scala学习笔记III/</id>
    <published>2019-12-23T07:08:12.000Z</published>
    <updated>2019-12-23T09:39:43.100Z</updated>
    
    <content type="html"><![CDATA[<p>Scala学习：伴生对象中的apply方法</p><a id="more"></a><h1 id="单例对象"><a href="#单例对象" class="headerlink" title="单例对象"></a>单例对象</h1><p>Scala没有静态方法或字段，可以用object语法定义结构，对象定义了类的单个实例。<br>对象的构造器在该对象第一次使用时被调用。<br>不能提供构造器参数。<br>作为存放工具函数或常量的地方。<br>高效地共享单个不可变实例。</p><h1 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h1><p>在Scala中，可通过类和类同名的“伴生”对象来达到静态方法的目的。<br>类和它的伴生对象可以相互访问私有特性，它们必须存在于同一个源文件中</p><p>示例：</p><p>  class Account {</p><pre><code>val id = Account.newUniqueNumber()private var balance = 0.0def deposit(amount: Double): Double = {  balance += amount  balance}def nowBalance = balance;</code></pre><p>  }</p><p>  object Account {<br>    private var lastNumber = 0</p><pre><code>private def newUniqueNumber() = {  lastNumber += 1  lastNumber}</code></pre><p>  }</p><p>  object Main {<br>    def main(args: Array[String]): Unit = {<br>      val account = new Account<br>      println(account.deposit(1))<br>      println(“=” * 10)</p><pre><code>  val account1 = new Account  println(account1.id)  println(account1.deposit(10))  println(&quot;=&quot; * 10)  println(&quot;a &quot; + account.nowBalance + &quot;; b &quot; + account1.nowBalance)}</code></pre><p>  }</p><p>执行结果</p><p>  1</p><h1 id="1-0"><a href="#1-0" class="headerlink" title="  1.0"></a>  1.0</h1><p>  2</p><h1 id="10-0"><a href="#10-0" class="headerlink" title="  10.0"></a>  10.0</h1><p>  a 1.0; b 10.0</p><h1 id="apply方法"><a href="#apply方法" class="headerlink" title="apply方法"></a>apply方法</h1><p>一般在伴生对象中定义apply方法<br>常用于初始化操作或创建单例对象<br>在生成这个类的对象时，就省去了new关键字<br>在遇到Object(参数1，参数2，……，参数n)时就会自动调用apply()方法<br>    class Student private (val studentID: Int, val name: String){</p><pre><code>  override def toString: String = {    &quot;studentID &quot; + studentID + &quot; name &quot; + name  }}object Student {  private var studentID = 0  private def newSno = {    studentID += 1    studentID  }  def apply(name: String): Student = {    println(&quot;call apply method...&quot;)    new Student(newSno, name)  }}object StudentMain extends App {  // no new  val student1 = Student(&quot;YiyeLi&quot;)  println(student1.toString)  println(&quot;*&quot; * 10)  val student2 = Student(&quot;YiyeLi&quot;)  println(student2.toString)}</code></pre><p>执行结果：</p><pre><code>call apply method...studentID 1 name YiyeLi**********call apply method...studentID 2 name YiyeLi</code></pre><p>再举一个例子，一个trait可以看作是一个Java接口。我们使用一个伴生类Shape和一个伴生对象Shape，作为一个工厂。</p><pre><code>trait Shape {  def area :Double}object Shape {  private class Circle(radius: Double) extends Shape{    override val area = 3.14*radius*radius  }  private class Rectangle (height: Double, length: Double)extends Shape{    override val area = height * length  }  private class cube (x:Double,y:Double,z:Double) extends Shape{    override val area= x * y * z  }  def apply(height :Double , length :Double ) : Shape = new Rectangle(height,length)  def apply(radius :Double) : Shape = new Circle(radius)  def apply(x:Double,y:Double,z:Double): Shape = new cube(x,y,z)}object Main extends App {  val circle = Shape(2)  println(circle.area)  val rectangle = Shape(2,3)  println(rectangle.area)  val cube=Shape(3,4,5)  println(cube.area)}</code></pre><p>执行结果：</p><p>  12.56<br>  6.0<br>  60.0</p><h1 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h1><p>Scala程序必须从一个对象的main方法开始<br>有两种方法定义<br>  // 执行println语句<br>  object Main {<br>    def main(args: Array[String]): Unit = {</p><pre><code>  println(&quot;=&quot; * 10)}</code></pre><p>  }</p><p>  // 扩展App特质<br>  object Main extends App {<br>    println(“=” * 10)<br>  }</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://zhuanlan.zhihu.com/p/32834063" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32834063</a><br>【2】<a href="https://www.w3cschool.cn/scala/scala-companion-objects.html" target="_blank" rel="noopener">https://www.w3cschool.cn/scala/scala-companion-objects.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Scala学习：伴生对象中的apply方法&lt;/p&gt;
    
    </summary>
    
      <category term="2019年12月" scheme="http://yoursite.com/categories/2019%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记X</title>
    <link href="http://yoursite.com/2019/12/17/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0X/"/>
    <id>http://yoursite.com/2019/12/17/Java学习笔记X/</id>
    <published>2019-12-17T10:05:12.000Z</published>
    <updated>2019-12-19T10:25:15.159Z</updated>
    
    <content type="html"><![CDATA[<p>Java中前后端交互例如使用ajax异步传值。</p><a id="more"></a><p>AJAX（Asynchronous JavaScript and XML）意思就是用JavaScript执行异步网络请求。如果仔细观察一个Form的提交，你就会发现，一旦用户点击“Submit”按钮，表单开始提交，浏览器就会刷新页面，然后在新页面里告诉你操作是成功了还是失败了。如果不幸由于网络太慢或者其他原因，就会得到一个404页面。</p><p>这就是Web的运作原理：一次HTTP请求对应一个页面。</p><p>如果要让用户留在当前页面中，同时发出新的HTTP请求，就必须用JavaScript发送这个新请求，接收到数据后，再用JavaScript更新页面，这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断地更新。</p><p>前端代码：</p><p>  function sendMessage(tokenType){<br>     console.log(tokenType);<br>     var serverURL=”[[${serverURL}]]”;//从后端的map中获取<br>     //token服务地址<br>     var url = “/getToken”;<br>     $.ajax({<br>         type : “post”,<br>         data :{<br>         “tokenType”:tokenType<br>         },<br>         dataType:”json”,<br>         async : true,<br>         url : url,<br>         success:function(token){<br>               console.log(token)<br>               window.frames[0].postMessage(token.data,serverURL);<br>         },<br>         error: function() {<br>            alert(“获取token失败，请稍后再试！”);<br>          }<br>       });<br>后端代码：</p><pre><code>@Value(&quot;${cm.bussinessName}&quot;)//从application.yml中获取private String bussinessName;@Value(&quot;${cm.bussinessID}&quot;)private String bussinessID;@Value(&quot;${cm.sysID}&quot;)private String sysID;@Value(&quot;${cm.userName}&quot;)private String userName;@Value(&quot;${cm.serverURL}&quot;)private String serverURL;@ApiOperation(value = &quot;cm5页面接入接口&quot;)@GetMapping(&quot;/cm5&quot;)public String getCm5(ModelMap map) { String scanTargetUrl= String.format(&quot;%s/interaction/queryFile?clientId=$$$&amp;batchId=###&amp;bussinessId=%s&amp;bussTableName=%s&amp;userID=%s&amp;sysid=%s&quot;,serverURL,bussinessID,bussinessName,userName,sysID); String uploadTargetUrl=String.format(&quot;%s/interaction/operateParam?clientId=$$$&amp;batchId=###&amp;bussinessId=%s&amp;bussTableName=%s&amp;userID=longruntest&amp;sysid=%s&quot;,serverURL,bussinessID,bussinessName,sysID); map.put(&quot;scanTargetUrl&quot;,scanTargetUrl); map.put(&quot;uploadTargetUrl&quot;,uploadTargetUrl); map.put(&quot;serverURL&quot;,serverURL); return &quot;/cm5/cm5&quot;;}@PostMapping(&quot;/getToken&quot;)@ResponseBodypublic String getToken( String tokenType){    CMPlusClient cmclient = cm5UtilService.getCmPlusClient();    return cmclient.getToken(tokenType);}</code></pre><p>由于后端传递的targetUrl中的&amp;会被转义为&amp;，所以添加过滤函数</p><pre><code> function unescapeHTML(a){  a = &quot;&quot; + a;  return a.replace(/&amp;lt;/g, &quot;&lt;&quot;).replace(/&amp;gt;/g, &quot;&gt;&quot;).replace(/&amp;amp;/g, &quot;&amp;&quot;).replace(/&amp;quot;/g, &apos;&quot;&apos;).replace(/&amp;apos;/g, &quot;&apos;&quot;);}</code></pre><p>前端页面cm5.html中要注意js脚本的路径是否存在：<br>    <script src="static/js/jquery-1.11.1.min.js" type="text/javascript"></script></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="https://my.oschina.net/smfx1314/blog/3053056" target="_blank" rel="noopener">https://my.oschina.net/smfx1314/blog/3053056</a><br>【2】<a href="https://www.jianshu.com/p/35020e29206c" target="_blank" rel="noopener">https://www.jianshu.com/p/35020e29206c</a><br>【3】<a href="http://xbhong.top/2018/02/28/ajax/" target="_blank" rel="noopener">http://xbhong.top/2018/02/28/ajax/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java中前后端交互例如使用ajax异步传值。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年12月" scheme="http://yoursite.com/categories/2019%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>数据库学习笔记VI</title>
    <link href="http://yoursite.com/2019/11/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0VI/"/>
    <id>http://yoursite.com/2019/11/05/数据库学习笔记VI/</id>
    <published>2019-11-05T03:54:12.000Z</published>
    <updated>2019-12-26T11:00:23.385Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL优化及常用函数</p><a id="more"></a><h1 id="SQL-CONCAT-函数"><a href="#SQL-CONCAT-函数" class="headerlink" title="SQL CONCAT 函数"></a>SQL CONCAT 函数</h1><p>CONCAT 函数用于将两个字符串连接为一个字符串，试一下下面这个例子：</p><pre><code>SQL&gt; SELECT CONCAT(&apos;FIRST &apos;, &apos;SECOND&apos;);+----------------------------+| CONCAT(&apos;FIRST &apos;, &apos;SECOND&apos;) |+----------------------------+| FIRST SECOND               |+----------------------------+1 row in set (0.00 sec)</code></pre><h1 id="case-when-then-else-end用法"><a href="#case-when-then-else-end用法" class="headerlink" title="case when then else end用法"></a>case when then else end用法</h1><pre><code>-简单case函数case sex  when &apos;1&apos; then &apos;男&apos;  when &apos;2&apos; then &apos;女’  else &apos;其他&apos; end--case搜索函数case when sex = &apos;1&apos; then &apos;男&apos;     when sex = &apos;2&apos; then &apos;女&apos;     else &apos;其他&apos; end  </code></pre><p>需要注重的问题，case函数只返回第一个符合条件的值，剩下的case部分将会被自动忽略。</p><h1 id="GROUP-BY-语句"><a href="#GROUP-BY-语句" class="headerlink" title="GROUP BY 语句"></a>GROUP BY 语句</h1><p>GROUP BY 语句用于结合合计函数，根据一个或多个列对结果集进行分组。</p><p>实例<br>我们拥有下面这个 “Orders” 表：</p><pre><code>O_Id    OrderDate    OrderPrice    Customer1    2008/12/29    1000    Bush2    2008/11/23    1600    Carter3    2008/10/05    700    Bush4    2008/09/28    300    Bush5    2008/08/06    2000    Adams6    2008/07/21    100    Carter</code></pre><p>现在，我们希望查找每个客户的总金额（总订单）。</p><p>我们想要使用 GROUP BY 语句对客户进行组合。</p><p>我们使用下列 SQL 语句：</p><pre><code>SELECT Customer,SUM(OrderPrice) FROM OrdersGROUP BY Customer</code></pre><p>结果集类似这样：</p><pre><code>Customer    SUM(OrderPrice)Bush    2000Carter    1700Adams    2000</code></pre><p>#参考资料<br>【1】 <a href="https://tech.meituan.com/2014/06/30/mysql-index.html" target="_blank" rel="noopener">https://tech.meituan.com/2014/06/30/mysql-index.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL优化及常用函数&lt;/p&gt;
    
    </summary>
    
      <category term="2019年11月" scheme="http://yoursite.com/categories/2019%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>设计模式学习笔记II</title>
    <link href="http://yoursite.com/2019/11/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0II/"/>
    <id>http://yoursite.com/2019/11/05/设计模式学习笔记II/</id>
    <published>2019-11-05T03:12:12.000Z</published>
    <updated>2019-12-30T08:47:51.583Z</updated>
    
    <content type="html"><![CDATA[<p>工厂模式</p><a id="more"></a><p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p><p>介绍<br>意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p><p>主要解决：主要解决接口选择的问题。</p><p>何时使用：我们明确地计划不同条件下创建不同实例时。</p><p>如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。</p><p>关键代码：创建过程在其子类执行。</p><p>应用实例： 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。</p><p>优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。</p><p>缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</p><p>使用场景： 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。</p><p>注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</p><p>实现<br>我们将创建一个 Shape 接口和实现 Shape 接口的实体类。下一步是定义工厂类 ShapeFactory。</p><p>FactoryPatternDemo，我们的演示类使用 ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。</p><p>步骤 1<br>创建一个接口:</p><p>Shape.java</p><pre><code>public interface Shape {   void draw();}</code></pre><p>步骤 2<br>创建实现接口的实体类。</p><p>Rectangle.java</p><pre><code>public class Rectangle implements Shape {   @Override   public void draw() {      System.out.println(&quot;Inside Rectangle::draw() method.&quot;);   }}Square.javapublic class Square implements Shape {   @Override   public void draw() {      System.out.println(&quot;Inside Square::draw() method.&quot;);   }}Circle.javapublic class Circle implements Shape {   @Override   public void draw() {      System.out.println(&quot;Inside Circle::draw() method.&quot;);   }}</code></pre><p>步骤 3<br>创建一个工厂，生成基于给定信息的实体类的对象。</p><p>ShapeFactory.java</p><pre><code>public class ShapeFactory {   //使用 getShape 方法获取形状类型的对象   public Shape getShape(String shapeType){      if(shapeType == null){         return null;      }              if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;)){         return new Circle();      } else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;)){         return new Rectangle();      } else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;)){         return new Square();      }      return null;   }}</code></pre><p>步骤 4<br>使用该工厂，通过传递类型信息来获取实体类的对象。</p><p>FactoryPatternDemo.java</p><pre><code>public class FactoryPatternDemo {   public static void main(String[] args) {      ShapeFactory shapeFactory = new ShapeFactory();      //获取 Circle 的对象，并调用它的 draw 方法      Shape shape1 = shapeFactory.getShape(&quot;CIRCLE&quot;);      //调用 Circle 的 draw 方法      shape1.draw();      //获取 Rectangle 的对象，并调用它的 draw 方法      Shape shape2 = shapeFactory.getShape(&quot;RECTANGLE&quot;);      //调用 Rectangle 的 draw 方法      shape2.draw();      //获取 Square 的对象，并调用它的 draw 方法      Shape shape3 = shapeFactory.getShape(&quot;SQUARE&quot;);      //调用 Square 的 draw 方法      shape3.draw();   }}</code></pre><p>步骤 5<br>执行程序，输出结果：</p><pre><code>Inside Circle::draw() method.Inside Rectangle::draw() method.Inside Square::draw() method.</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】 <a href="https://www.runoob.com/design-pattern/factory-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/factory-pattern.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工厂模式&lt;/p&gt;
    
    </summary>
    
      <category term="2019年11月" scheme="http://yoursite.com/categories/2019%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Design Pattern，Java" scheme="http://yoursite.com/tags/Design-Pattern%EF%BC%8CJava/"/>
    
  </entry>
  
  <entry>
    <title>设计模式学习笔记I</title>
    <link href="http://yoursite.com/2019/10/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0I/"/>
    <id>http://yoursite.com/2019/10/17/设计模式学习笔记I/</id>
    <published>2019-10-17T02:56:12.000Z</published>
    <updated>2019-10-17T03:06:59.684Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式学习笔记</p><a id="more"></a><h1 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h1><p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</p><p>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</p><p>我们通过下面的实例来演示装饰器模式的用法。其中，我们将把一个形状装饰上不同的颜色，同时又不改变形状类。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>意图：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p><p>主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。</p><p>何时使用：在不想增加很多子类的情况下扩展类。</p><p>如何解决：将具体功能职责划分，同时继承装饰者模式。</p><p>关键代码： 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。</p><p>应用实例： 1、孙悟空有 72 变，当他变成”庙宇”后，他的根本还是一只猴子，但是他又有了庙宇的功能。 2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。</p><p>优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p><p>缺点：多层装饰比较复杂。</p><p>使用场景： 1、扩展一个类的功能。 2、动态增加功能，动态撤销。</p><p>注意事项：可代替继承。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>我们将创建一个 Shape 接口和实现了 Shape 接口的实体类。然后我们创建一个实现了 Shape 接口的抽象装饰类 ShapeDecorator，并把 Shape 对象作为它的实例变量。</p><p>RedShapeDecorator 是实现了 ShapeDecorator 的实体类。</p><p>DecoratorPatternDemo，我们的演示类使用 RedShapeDecorator 来装饰 Shape 对象。<br><a href="https://www.runoob.com/wp-content/uploads/2014/08/decorator_pattern_uml_diagram.jpg" target="_blank" rel="noopener">https://www.runoob.com/wp-content/uploads/2014/08/decorator_pattern_uml_diagram.jpg</a></p><h2 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h2><p>创建一个接口：</p><p>Shape.java</p><pre><code>public interface Shape {   void draw();}</code></pre><h2 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h2><p>创建实现接口的实体类。</p><p>Rectangle.java</p><pre><code>public class Rectangle implements Shape {   @Override   public void draw() {      System.out.println(&quot;Shape: Rectangle&quot;);   }}</code></pre><p>Circle.java</p><pre><code>public class Circle implements Shape {   @Override   public void draw() {      System.out.println(&quot;Shape: Circle&quot;);   }}</code></pre><h2 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a>步骤 3</h2><p>创建实现了 Shape 接口的抽象装饰类。</p><p>ShapeDecorator.java</p><pre><code>public abstract class ShapeDecorator implements Shape {   protected Shape decoratedShape;   public ShapeDecorator(Shape decoratedShape){      this.decoratedShape = decoratedShape;   }   public void draw(){      decoratedShape.draw();   }  }</code></pre><h2 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤 4"></a>步骤 4</h2><p>创建扩展了 ShapeDecorator 类的实体装饰类。</p><p>RedShapeDecorator.java</p><pre><code>public class RedShapeDecorator extends ShapeDecorator {   public RedShapeDecorator(Shape decoratedShape) {      super(decoratedShape);        }   @Override   public void draw() {      decoratedShape.draw();               setRedBorder(decoratedShape);   }   private void setRedBorder(Shape decoratedShape){      System.out.println(&quot;Border Color: Red&quot;);   }}</code></pre><h2 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤 5"></a>步骤 5</h2><p>使用 RedShapeDecorator 来装饰 Shape 对象。</p><p>DecoratorPatternDemo.java</p><pre><code>public class DecoratorPatternDemo {   public static void main(String[] args) {      Shape circle = new Circle();      ShapeDecorator redCircle = new RedShapeDecorator(new Circle());      ShapeDecorator redRectangle = new RedShapeDecorator(new Rectangle());      //Shape redCircle = new RedShapeDecorator(new Circle());      //Shape redRectangle = new RedShapeDecorator(new Rectangle());      System.out.println(&quot;Circle with normal border&quot;);      circle.draw();      System.out.println(&quot;\nCircle of red border&quot;);      redCircle.draw();      System.out.println(&quot;\nRectangle of red border&quot;);      redRectangle.draw();   }}</code></pre><h2 id="步骤-6"><a href="#步骤-6" class="headerlink" title="步骤 6"></a>步骤 6</h2><p>执行程序，输出结果：</p><pre><code>Circle with normal borderShape: CircleCircle of red borderShape: CircleBorder Color: RedRectangle of red borderShape: RectangleBorder Color: Red</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】 <a href="https://www.runoob.com/design-pattern/decorator-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/decorator-pattern.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计模式学习笔记&lt;/p&gt;
    
    </summary>
    
      <category term="2019年10月" scheme="http://yoursite.com/categories/2019%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Design Pattern，Java" scheme="http://yoursite.com/tags/Design-Pattern%EF%BC%8CJava/"/>
    
  </entry>
  
  <entry>
    <title>Scala学习笔记II</title>
    <link href="http://yoursite.com/2019/09/25/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0II/"/>
    <id>http://yoursite.com/2019/09/25/Scala学习笔记II/</id>
    <published>2019-09-25T07:17:12.000Z</published>
    <updated>2019-09-27T09:36:36.534Z</updated>
    
    <content type="html"><![CDATA[<p>Scala学习：=&gt;语法糖,模式匹配</p><a id="more"></a><h1 id="Scala的“-gt-”符号简介"><a href="#Scala的“-gt-”符号简介" class="headerlink" title="Scala的“=&gt;”符号简介"></a>Scala的“=&gt;”符号简介</h1><p>Scala中的=&gt;符号可以看做是创建函数实例的语法糖。例如：A =&gt; T，A,B =&gt; T表示一个函数的输入参数类型是“A”，“A,B”，返回值类型是T。请看下面这个实例：</p><pre><code>scala&gt; val f: Int =&gt; String = myInt =&gt; &quot;The value of myInt is: &quot; + myInt.toString()f: Int =&gt; String = &lt;function1&gt;scala&gt; println(f(3))The value of myInt is: 3</code></pre><p>另外，() =&gt; T表示函数输入参数为空，而A =&gt; Unit则表示函数没有返回值。</p><pre><code>object HelloScala {  def main(args: Array[String])  {    /**      * 首先定义函数d,参数类型是Int=&gt;Int的函数,返回值根据上下文推算是Int。      * 返回值: 发现没有,返回值是x(2),它调用了传入函数。结果自然就是6了。      */    def d(x: (Int) =&gt; Int) = x(2);    println(d((x: Int) =&gt; x * 3));    // 继续增加难度,设置2个值。仔细看变化,你会明白的    def c(x: (Int, Int) =&gt; Int) = x(2, 3);    println(c((x: Int, y: Int) =&gt; x * y * 3));    // 加深难度,b第一次调用返回函数(y: Int) =&gt; x + y,在一次调用返回结果。    // 相关文章参考快学scala 第十二章 高阶函数 145页    val b = (x: Int) =&gt; (y: Int) =&gt; x + y;    println(b.apply(5).apply(6));  }}</code></pre><h1 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h1><pre><code>object scala {    def main(args: Array[String]):Unit={        println(matchTest(3))    }    def matchTest(x:Int):String =x match{      case 1=&gt;&quot;one&quot;      case 2=&gt;&quot;two&quot;      case _=&gt;&quot;many&quot;    }}</code></pre><p>match 对应 Java 里的 switch，但是写在选择器表达式之后。即： 选择器 match {备选项}。</p><p>match 表达式通过以代码编写的先后次序尝试每个模式来完成计算，只要发现有一个匹配的case，剩下的case不会继续匹配。</p><p>接下来我们来看一个不同数据类型的模式匹配：</p><pre><code>object scala {    def main(args: Array[String]):Unit={      println(matchTest(&quot;two&quot;))      println(matchTest(&quot;test&quot;))      println(matchTest(1))      println(matchTest(6))    }    def matchTest(x:Any) : Any=x match {      case 1=&gt;&quot;one&quot;      case &quot;two&quot;=&gt;2      case y:Int=&gt;&quot;scala.Int&quot;      case _=&gt;&quot;many&quot;    }}</code></pre><p>输出结果为：</p><pre><code>2manyonescala.Int</code></pre><p>实例中第一个 case 对应整型数值 1，第二个 case 对应字符串值 two，第三个 case 对应类型模式，用于判断传入的值是否为整型，相比使用isInstanceOf来判断类型，使用模式匹配更好。第四个 case 表示默认的全匹配备选项，即没有找到其他匹配时的匹配项，类似 switch 中的 default。</p><h2 id="使用样例类"><a href="#使用样例类" class="headerlink" title="使用样例类"></a>使用样例类</h2><p>使用了case关键字的类定义就是就是样例类(case classes)，样例类是种特殊的类，经过优化以用于模式匹配。</p><p>以下是样例类的简单实例:</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】 <a href="https://www.orchome.com/401" target="_blank" rel="noopener">https://www.orchome.com/401</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Scala学习：=&amp;gt;语法糖,模式匹配&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记IX</title>
    <link href="http://yoursite.com/2019/09/20/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0IX/"/>
    <id>http://yoursite.com/2019/09/20/Java学习笔记IX/</id>
    <published>2019-09-20T10:32:12.000Z</published>
    <updated>2019-09-20T10:46:42.351Z</updated>
    
    <content type="html"><![CDATA[<p>Java8 中的新特性：Optional类</p><a id="more"></a><p>看到代码中出现的Optional，所以来研究一下：</p><pre><code>Optional&lt;LoanPostloanInfosEntity&gt; postloanInfo = loanPostloanInfosRepository.getByContractId(contractId);</code></pre><p>  Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</p><p>  Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</p><p>  Optional 类的引入很好的解决空指针异常。</p><h1 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h1><p>  以下是一个 java.util.Optional<t> 类的声明：</t></p><pre><code>public final class Optional&lt;T&gt;extends Object</code></pre><h1 id="Optional实例"><a href="#Optional实例" class="headerlink" title="Optional实例"></a>Optional实例</h1><pre><code>import java.util.Optional;public class Java8Tester {    public static void optionalPrac(){        Integer value1 = null;        Integer value2 = new Integer(10);        // Optional.ofNullable - 允许传递为 null 参数        Optional&lt;Integer&gt; a = Optional.ofNullable(value1);        // Optional.of - 如果传递的参数是 null，抛出异常 NullPointerException        Optional&lt;Integer&gt; b = Optional.of(value2);        System.out.println(sum(a,b));    }    public static Integer sum(Optional&lt;Integer&gt; a, Optional&lt;Integer&gt; b){        // Optional.isPresent - 判断值是否存在        System.out.println(&quot;第一个参数值存在: &quot; + a.isPresent());        System.out.println(&quot;第二个参数值存在: &quot; + b.isPresent());        // Optional.orElse - 如果值存在，返回它，否则返回默认值        Integer value1 = a.orElse(new Integer(0));        //Optional.get - 获取值，值需要存在        Integer value2 = b.get();        return value1 + value2;    }    public static void main(String args[]){        optionalPrac();}</code></pre><p>}</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<br><a href="https://www.runoob.com/java/java8-optional-class.html" target="_blank" rel="noopener">https://www.runoob.com/java/java8-optional-class.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java8 中的新特性：Optional类&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Shell学习笔记I</title>
    <link href="http://yoursite.com/2019/09/16/Shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0I/"/>
    <id>http://yoursite.com/2019/09/16/Shell学习笔记I/</id>
    <published>2019-09-16T10:51:12.000Z</published>
    <updated>2019-09-17T06:20:30.433Z</updated>
    
    <content type="html"><![CDATA[<p>Shell脚本编程，懒虫的最爱。</p><a id="more"></a><p>世界的进步是由一群聪明的懒人推动的，可惜自己不但不聪明，还很懒。每次写完博客总打着熟悉git操作的旗号手动部署，终于洗心革面决定写个脚本来自动部署。</p><pre><code>#!/bin/bashcd /Users/liyiye/yiye-project/liyiye012.github.iogit add .git commit -m &quot;github.io 自动部署&quot;git pushhexo cleanhexo ghexo d</code></pre><p>这里写下Shell脚本学习的过程。</p><h1 id="What-is-Shell-and-Shell-Script"><a href="#What-is-Shell-and-Shell-Script" class="headerlink" title="What is Shell and Shell Script"></a>What is Shell and Shell Script</h1><p>shell是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。Ken Thompson的sh是第一种Unix Shell，Windows Explorer是一个典型的图形界面Shell。</p><p>Shell脚本(Shell script)是一种电脑程序与文本文件，内容由一连串的shell命令组成，经由Unix Shell直译其内容后运作。</p><p>被当成是一种脚本语言来设计，其运作方式与直译语言相当，由Unix shell扮演命令行解释器的角色，在读取shell script之后，依序运行其中的shell命令，之后输出结果。利用Shell script可以进行系统管理，文件操作等。</p><p>业界所说的shell通常都是指shell脚本，但读者朋友要知道，shell和shell script是两个不同的概念。由于习惯的原因，简洁起见，本文出现的“shell编程”都是指shell脚本编程，不是指开发shell自身（如Windows Explorer扩展开发）</p><p>打开文本编辑器，新建一个文本文件，并命名为 test.sh。</p><p>扩展名sh代表 shell，扩展名并不影响脚本执行，见名知意就好，如果用 php 写 shell 脚本，扩展名也可以用php。</p><h2 id="第一个shell脚本-Hello-World"><a href="#第一个shell脚本-Hello-World" class="headerlink" title="第一个shell脚本 Hello World"></a>第一个shell脚本 Hello World</h2><p>在 test.sh 中输入代码：</p><pre><code>#!/bin/bashecho &quot;Hello World !&quot;  #这是一条语句</code></pre><p>第 1 行的#!是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell；后面的/bin/bash就是指明了解释器的具体位置。</p><p>第 2 行的 echo 命令用于向标准输出文件（Standard Output，stdout，一般就是指显示器）输出文本。在.sh文件中使用命令与在终端直接输入命令的效果是一样的。</p><p>第 2 行的#及其后面的内容是注释。Shell 脚本中所有以#开头的都是注释（当然以#!开头的除外）</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>运行Shell脚本有两种方法：</p><h3 id="作为可执行程序"><a href="#作为可执行程序" class="headerlink" title="作为可执行程序"></a>作为可执行程序</h3><pre><code>chmod +x test.sh./test.sh</code></pre><p>注意，一定要写成./test.sh，而不是test.sh，运行其它二进制的程序也一样，直接写test.sh，linux系统会去PATH里寻找有没有叫test.sh的，而只有/bin, /sbin, /usr/bin，/usr/sbin等在PATH里，你的当前目录通常不在PATH里，所以写成test.sh是会找不到命令的，要用./test.sh告诉系统说，就在当前目录找。</p><p>通过这种方式运行bash脚本，第一行一定要写对，好让系统查找到正确的解释器。</p><p>这里的”系统”，其实就是shell这个应用程序（想象一下Windows Explorer），但我故意写成系统，是方便理解，既然这个系统就是指shell，那么一个使用/bin/sh作为解释器的脚本是不是可以省去第一行呢？是的。</p><h3 id="作为解释器参数"><a href="#作为解释器参数" class="headerlink" title="作为解释器参数"></a>作为解释器参数</h3><p>这种运行方式是，直接运行解释器，其参数就是shell脚本的文件名，如：</p><pre><code>/bin/sh test.sh/bin/php test.php</code></pre><p>这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。</p><h2 id="stdin"><a href="#stdin" class="headerlink" title="stdin"></a>stdin</h2><pre><code>#!/bin/bashecho &quot;What is your name?&quot;read PERSONecho &quot;Hello, $PERSON&quot;</code></pre><p>第 3 行中表示从终端读取用户输入的数据，并赋值给 PERSON 变量。read 命令用来从标准输入文件（Standard Input，stdin，一般就是指键盘）读取用户输入的数据。</p><p>第 4 行表示输出变量 PERSON 的内容。注意在变量名前边要加上$，否则变量名会作为字符串的一部分处理。</p><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><pre><code>#!/bin/shcd ~mkdir shell_tutcd shell_tutfor ((i=0; i&lt;10; i++)); do    touch test_$i.txtdone</code></pre><p>示例解释</p><pre><code>第1行：指定脚本解释器，这里是用/bin/sh做解释器的第2行：切换到当前用户的home目录第3行：创建一个目录shell_tut第4行：切换到shell_tut目录第5行：循环条件，一共循环10次第6行：创建一个test_0…9.txt文件第7行：循环体结束</code></pre><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><p>定义变量时，变量名不加美元符号（$），如：</p><pre><code>your_name=&quot;qinjx&quot;</code></pre><p>注意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。</p><p>除了显式地直接赋值，还可以用语句给变量赋值，如：</p><pre><code>for file in `ls /etc`</code></pre><h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><p>使用一个定义过的变量，只要在变量名前面加美元符号即可，如：</p><pre><code>your_name=&quot;qinjx&quot;echo $your_nameecho ${your_name}</code></pre><p>变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：</p><pre><code>for skill in Ada Coffe Action Java; do    echo &quot;I am good at ${skill}Script&quot;done</code></pre><p>如果不给skill变量加花括号，写成echo “I am good at $skillScript”，解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。</p><p>推荐给所有变量加上花括号，这是个好的编程习惯。IntelliJ IDEA编写shell script时，IDE就会提示加花括号。</p><h2 id="重定义变量"><a href="#重定义变量" class="headerlink" title="重定义变量"></a>重定义变量</h2><p>已定义的变量，可以被重新定义，如：</p><pre><code>your_name=&quot;qinjx&quot;echo $your_nameyour_name=&quot;alibaba&quot;echo $your_name</code></pre><p>这样写是合法的，但注意，第二次赋值的时候不能写$your_name=”alibaba”，使用变量的时候才加美元符。</p><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>以“#”开头的行就是注释，会被解释器忽略。</p><p>##多行注释<br>sh里没有多行注释，只能每一行加一个#号。</p><p>如果在开发过程中，遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？每一行加个#符号太费力了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。</p><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>字符串是shell编程中最常用最有用的数据类型，字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟PHP类似。</p><h2 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h2><pre><code>str=&apos;this is a string&apos;</code></pre><h3 id="单引号字符串的限制："><a href="#单引号字符串的限制：" class="headerlink" title="单引号字符串的限制："></a>单引号字符串的限制：</h3><p>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的</p><p>单引号字串中不能出现单引号（对单引号使用转义符后也不行）</p><h2 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h2><pre><code>your_name=&apos;qinjx&apos;str=&quot;Hello, I know your are \&quot;$your_name\&quot;! \n&quot;</code></pre><p>双引号里可以有变量</p><p>双引号里可以出现转义字符</p><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h3><pre><code>your_name=&quot;qinjx&quot;greeting=&quot;hello, &quot;$your_name&quot; !&quot;greeting_1=&quot;hello, ${your_name} !&quot;echo $greeting $greeting_1</code></pre><h3 id="获取字符串长度："><a href="#获取字符串长度：" class="headerlink" title="获取字符串长度："></a>获取字符串长度：</h3><pre><code>string=&quot;abcd&quot;echo ${#string} #输出：4</code></pre><h3 id="提取子字符串"><a href="#提取子字符串" class="headerlink" title="提取子字符串"></a>提取子字符串</h3><pre><code>string=&quot;alibaba is a great company&quot;echo ${string:1:4} #输出：liba</code></pre><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><h1 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h1><h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><p>和Java、PHP等语言不一样，sh的流程控制不可为空，如：</p><pre><code>&lt;?phpif (isset($_GET[&quot;q&quot;])) {    search(q);}else {    //do nothing}</code></pre><p>在sh/bash里可不能这么写，如果else分支没有语句执行，就不要写这个else。</p><p>还要注意，sh里的if [ $foo -eq 0 ]，这个方括号跟Java/PHP里if后面的圆括号大不相同，它是一个可执行程序（和ls, grep一样），想不到吧？在CentOS上，它在/usr/bin目录下：</p><pre><code>ll /usr/bin/[-rwxr-xr-x. 1 root root 33408 6月  22 2012 /usr/bin/[</code></pre><p>正因为方括号在这里是一个可执行程序，方括号后面必须加空格，不能写成if [$foo -eq 0]</p><h2 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><pre><code>if conditionthen    command1    command2    ...    commandNfi</code></pre><p>写成一行（适用于终端命令提示符）：</p><pre><code>if `ps -ef | grep ssh`;  then echo hello; fi</code></pre><p>末尾的fi就是if倒过来拼写，后面还会遇到类似的</p><h3 id="if-else-1"><a href="#if-else-1" class="headerlink" title="if else"></a>if else</h3><pre><code>if conditionthen    command1    command2    ...    commandNelse    commandfi</code></pre><h3 id="if-else-if-else"><a href="#if-else-if-else" class="headerlink" title="if else-if else"></a>if else-if else</h3><pre><code>if condition1then    command1elif condition2    command2else    commandNfi</code></pre><h2 id="for-while"><a href="#for-while" class="headerlink" title="for while"></a>for while</h2><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>在开篇的示例里演示过了：</p><pre><code>for var in item1 item2 ... itemNdo    command1    command2    ...    commandNdone</code></pre><p>写成一行：</p><pre><code>for var in item1 item2 ... itemN; do command1; command2… done;</code></pre><h3 id="C风格的for"><a href="#C风格的for" class="headerlink" title="C风格的for"></a>C风格的for</h3><pre><code>for (( EXP1; EXP2; EXP3 ))do    command1    command2    command3done</code></pre><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><pre><code>while conditiondo    commanddone</code></pre><h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h3><pre><code>while :do    commanddone</code></pre><p>或者</p><pre><code>while truedo    commanddone</code></pre><p>或者</p><pre><code>for (( ; ; ))</code></pre><h3 id="until"><a href="#until" class="headerlink" title="until"></a>until</h3><pre><code>until conditiondo    commanddone</code></pre><h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><pre><code>case &quot;${opt}&quot; in    &quot;Install-Puppet-Server&quot; )        install_master $1        exit    ;;    &quot;Install-Puppet-Client&quot; )        install_client $1        exit    ;;    &quot;Config-Puppet-Server&quot; )        config_puppet_master        exit    ;;    &quot;Config-Puppet-Client&quot; )        config_puppet_client        exit    ;;    &quot;Exit&quot; )        exit    ;;    * ) echo &quot;Bad option, please choose again&quot;esac</code></pre><p>case的语法和C family语言差别很大，它需要一个esac（就是case反过来）作为结束标记，每个case分支用右圆括号，用两个分号表示break</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><p>可以使用source和.关键字，如：</p><pre><code>source ./function.sh. ./function.sh</code></pre><p>在bash里，source和.是等效的，他们都是读入function.sh的内容并执行其内容（类似PHP里的include），为了更好的可移植性，推荐使用第二种写法。</p><p>包含一个文件和执行一个文件一样，也要写这个文件的路径，不能光写文件名，比如上述例子中:</p><p>  . ./function.sh<br>不可以写作：</p><p>  . function.sh<br>如果function.sh是用户传入的参数，如何获得它的绝对路径呢？方法是：</p><pre><code>real_path=`readlink -f $1`#$1是用户输入的参数，如function.sh. $real_path</code></pre><h1 id="用户输入"><a href="#用户输入" class="headerlink" title="用户输入"></a>用户输入</h1><h2 id="执行脚本时传入"><a href="#执行脚本时传入" class="headerlink" title="执行脚本时传入"></a>执行脚本时传入</h2><h2 id="脚本运行中输入"><a href="#脚本运行中输入" class="headerlink" title="脚本运行中输入"></a>脚本运行中输入</h2><h2 id="select菜单"><a href="#select菜单" class="headerlink" title="select菜单"></a>select菜单</h2><h2 id="stdin和stdout"><a href="#stdin和stdout" class="headerlink" title="stdin和stdout"></a>stdin和stdout</h2><h1 id="常用的命令"><a href="#常用的命令" class="headerlink" title="常用的命令"></a>常用的命令</h1><p>sh脚本结合系统命令便有了强大的威力，在字符处理领域，有grep、awk、sed三剑客，grep负责找出特定的行，awk能将行拆分成多个字段，sed则可以实现更新插入删除等写操作。</p><h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p>查看进程列表</p><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>排除grep自身<br>查找与target相邻的结果</p><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><h2 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h2><h1 id="脚本解释器"><a href="#脚本解释器" class="headerlink" title="脚本解释器"></a>脚本解释器</h1><h2 id="sh"><a href="#sh" class="headerlink" title="sh"></a>sh</h2><p>即Bourne shell，POSIX（Portable Operating System Interface）标准的shell解释器，它的二进制文件路径通常是/bin/sh，由Bell Labs开发。</p><p>下面讲的是sh，如果使用其它语言用作shell编程，请参考相应语言的文档。</p><h2 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h2><p>Bash是Bourne shell的替代品，属GNU Project，二进制文件路径通常是/bin/bash。业界通常混用bash、sh、和shell，比如你会经常在招聘运维工程师的文案中见到：熟悉Linux Bash编程，精通Shell编程。</p><p>在CentOS里，/bin/sh是一个指向/bin/bash的符号链接:</p><pre><code>[root@centosraw ~]# ls -l /bin/*sh-rwxr-xr-x. 1 root root 903272 Feb 22 05:09 /bin/bash-rwxr-xr-x. 1 root root 106216 Oct 17  2012 /bin/dashlrwxrwxrwx. 1 root root      4 Mar 22 10:22 /bin/sh -&gt; bash</code></pre><p>但在Mac OS上不是，/bin/sh和/bin/bash是两个不同的文件，尽管它们的大小只相差100字节左右:</p><pre><code>iMac:~ wuxiao$ ls -l /bin/*sh-r-xr-xr-x  1 root  wheel  1371648  6 Nov 16:52 /bin/bash-rwxr-xr-x  2 root  wheel   772992  6 Nov 16:52 /bin/csh-r-xr-xr-x  1 root  wheel  2180736  6 Nov 16:52 /bin/ksh-r-xr-xr-x  1 root  wheel  1371712  6 Nov 16:52 /bin/sh-rwxr-xr-x  2 root  wheel   772992  6 Nov 16:52 /bin/tcsh-rwxr-xr-x  1 root  wheel  1103984  6 Nov 16:52 /bin/zsh</code></pre><h1 id="高级编程语言"><a href="#高级编程语言" class="headerlink" title="高级编程语言"></a>高级编程语言</h1><p>理论上讲，只要一门语言提供了解释器（而不仅是编译器），这门语言就可以胜任脚本编程，常见的解释型语言都是可以用作脚本编程的，如：Perl、Tcl、Python、PHP、Ruby。Perl是最老牌的脚本编程语言了，Python这些年也成了一些linux发行版的预置解释器。</p><p>编译型语言，只要有解释器，也可以用作脚本编程，如C shell是内置的（/bin/csh），Java有第三方解释器Jshell，Ada有收费的解释器AdaScript。</p><h1 id="如何选择shell编程语言"><a href="#如何选择shell编程语言" class="headerlink" title="如何选择shell编程语言"></a>如何选择shell编程语言</h1><h2 id="熟悉-vs-陌生"><a href="#熟悉-vs-陌生" class="headerlink" title="熟悉 vs 陌生"></a>熟悉 vs 陌生</h2><p>如果你已经掌握了一门编程语言（如PHP、Python、Java、JavaScript），建议你就直接使用这门语言编写脚本程序，虽然某些地方会有点啰嗦，但你能利用在这门语言领域里的经验（单元测试、单步调试、IDE、第三方类库）。</p><p>新增的学习成本很小，只要学会怎么使用shell解释器（Jshell、AdaScript）就可以了。</p><h2 id="简单-vs-高级"><a href="#简单-vs-高级" class="headerlink" title="简单 vs 高级"></a>简单 vs 高级</h2><p>如果你觉得自己熟悉的语言（如Java、C）写shell脚本实在太啰嗦，你只是想做一些备份文件、安装软件、下载数据之类的事情，学着使用sh，bash会是一个好主意。</p><p>shell只定义了一个非常简单的编程语言，所以，如果你的脚本程序复杂度较高，或者要操作的数据结构比较复杂，那么还是应该使用Python、Perl这样的脚本语言，或者是你本来就已经很擅长的高级语言。因为sh和bash在这方面很弱，比如说：</p><p><strong><em>它的函数只能返回字串，无法返回数组</em></strong></p><p><strong><em>它不支持面向对象，你无法实现一些优雅的设计模式</em></strong></p><p><strong><em>它是解释型的，一边解释一边执行，连PHP那种预编译都不是，如果你的脚本包含错误(例如调用了不存在的函数)，只要没执行到这一行，就不会报错</em></strong></p><h2 id="环境兼容性"><a href="#环境兼容性" class="headerlink" title="环境兼容性"></a>环境兼容性</h2><p>如果你的脚本是提供给别的用户使用，使用sh或者bash，你的脚本将具有最好的环境兼容性，perl很早就是linux标配了，python这些年也成了一些linux发行版的标配，至于mac os，它默认安装了perl、python、ruby、php、java等主流编程语言。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】 <a href="https://www.runoob.com/w3cnote/shell-quick-start.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/shell-quick-start.html</a></p><p>【2】 <a href="https://github.com/qinjx/30min_guides/blob/master/shell.md" target="_blank" rel="noopener">https://github.com/qinjx/30min_guides/blob/master/shell.md</a></p><p>【3】 <a href="http://c.biancheng.net/view/735.html" target="_blank" rel="noopener">http://c.biancheng.net/view/735.html</a></p><p>【4】 <a href="http://tldp.org/LDP/abs/html/" target="_blank" rel="noopener">http://tldp.org/LDP/abs/html/</a> ，非常详细，非常易读，大量example，既可以当入门教材，也可以当做工具书查阅</p><p>【5】 <a href="http://www.tutorialspoint.com/unix/unix-shell.htm" target="_blank" rel="noopener">http://www.tutorialspoint.com/unix/unix-shell.htm</a></p><p>【6】 <a href="https://bash.cyberciti.biz/guide/Main_Page" target="_blank" rel="noopener">https://bash.cyberciti.biz/guide/Main_Page</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Shell脚本编程，懒虫的最爱。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Shell" scheme="http://yoursite.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Scala学习笔记I</title>
    <link href="http://yoursite.com/2019/09/10/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0I/"/>
    <id>http://yoursite.com/2019/09/10/Scala学习笔记I/</id>
    <published>2019-09-10T03:32:12.000Z</published>
    <updated>2019-09-25T07:17:36.347Z</updated>
    
    <content type="html"><![CDATA[<p>Scala学习：集合，柯里化，implicit关键字</p><a id="more"></a><h1 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h1><h1 id="fold-foldLeft和foldRight区别与联系"><a href="#fold-foldLeft和foldRight区别与联系" class="headerlink" title="fold,foldLeft和foldRight区别与联系"></a>fold,foldLeft和foldRight区别与联系</h1><p>从本质上说，fold函数将一种格式的输入数据转化成另外一种格式返回。</p><pre><code>def fold(){  val a=List(1,2,3,4)  val res=a.fold(0){    (z,i) =&gt; z+i  }  println(res)  //res=10}</code></pre><p>List中的fold方法需要输入两个参数：初始值以及一个函数。输入的函数也需要输入两个参数：累加值和当前item的索引。那么上面的代码片段发生了什么事？</p><p>代码开始运行的时候，初始值0作为第一个参数传进到fold函数中，list中的第一个item作为第二个参数传进fold函数中。</p><p>1、fold函数开始对传进的两个参数进行计算，在本例中，仅仅是做加法计算，然后返回计算的值；</p><p>2、Fold函数然后将上一步返回的值作为输入函数的第一个参数，并且把list中的下一个item作为第二个参数传进继续计算，同样返回计算的值；</p><p>3、第2步将重复计算，直到list中的所有元素都被遍历之后，返回最后的计算值，整个过程结束；</p><p>4、这虽然是一个简单的例子，让我们来看看一些比较有用的东西。早在后面将会介绍foldLeft函数，并解释它和fold之间的区别，目前，你只需要想象foldLeft函数和fold函数运行过程一样。</p><h1 id="Scala-函数柯里化-Currying"><a href="#Scala-函数柯里化-Currying" class="headerlink" title="Scala 函数柯里化(Currying)"></a>Scala 函数柯里化(Currying)</h1><p>柯里化(Currying)指的是将原来接受两个参数的函数变成新的接受一个参数的函数的过程。新的函数返回一个以原有第二个参数为参数的函数。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>首先我们定义一个函数:</p><pre><code>def add(x:Int,y:Int)=x+y</code></pre><p>那么我们应用的时候，应该是这样用：add(1,2)</p><p>现在我们把这个函数变一下形：</p><pre><code>def add(x:Int)(y:Int) = x + y</code></pre><p>那么我们应用的时候，应该是这样用：add(1)(2),最后结果都一样是3，这种方式（过程）就叫柯里化。</p><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>add(1)(2) 实际上是依次调用两个普通函数（非柯里化函数），第一次调用使用一个参数 x，返回一个函数类型的值，第二次使用参数y调用这个函数类型的值。</p><p>实质上最先演变成这样一个方法：</p><pre><code>def add(x:Int)=(y:Int)=&gt;x+y</code></pre><p>那么这个函数是什么意思呢？ 接收一个x为参数，返回一个匿名函数，该匿名函数的定义是：接收一个Int型参数y，函数体为x+y。现在我们来对这个方法进行调用。</p><pre><code>val result = add(1)</code></pre><p>返回一个result，那result的值应该是一个匿名函数：(y:Int)=&gt;1+y</p><p>所以为了得到结果，我们继续调用result。</p><pre><code>val sum = result(2)</code></pre><p>最后打印出来的结果就是3。</p><h1 id="Implicit详解"><a href="#Implicit详解" class="headerlink" title="Implicit详解"></a>Implicit详解</h1><p>在 Scala 中的 implicit 定义指编译器在需要修复类型匹配时可以用来自动插入的定义。比如说，如果 x+y 类型不匹配，那么编译器可能试着使用 convert(x) + y， 其中 convert 由某个 implicit 定义的，这有点类似一个整数和一个浮点数相加，编译器可以自动把整数转换为浮点数。Scala 的 implicit 定义是对这种情况的一个推广，你可以定义一个类型在需要时，如何自动转换成另外一种类型。</p><p>Scala 的 implicit 定义符合下面一些规则：</p><h2 id="标记规则"><a href="#标记规则" class="headerlink" title="标记规则"></a>标记规则</h2><p>只有哪些使用 implicit 关键字的定义才是可以使用的隐式定义。关键字 implicit 用来标记一个隐式定义。编译器才可以选择它作为隐式变化的候选项。你可以使用 implicit 来标记任意变量，函数或是对象。</p><p>例如下面为一个隐式函数定义：</p><pre><code>implicit def intToString(x:Int) : x.toString</code></pre><p>编译器只有在 convert 被标记成 implicit 才会将 x + y 改成convert(x) + y 。当然这是在 x + y 类型不匹配时。</p><h2 id="范围规则"><a href="#范围规则" class="headerlink" title="范围规则"></a>范围规则</h2><p>编译器在选择备选 implicit 定义时，只会选取当前作用域的定义，比如说编译器不会去调用 someVariable.convert。如果你需要使用 someVariable.convert，你必须把 someVarible 引入到当前作用域。也就是说编译器在选择备选 implicit 时，只有当 convert 是当前作用域下单个标志符时才会作为备选 implicit。比如说，对于一个函数库来说，在一个 Preamble 对象中定义一些常用的隐式类型转换非常常见，因此需要使用 Preamble 的代码可以使用 “import Preamble._”  把这些 implicit 定义引入到当前作用域才可以。</p><p>这个规则有一个例外，编译器也会在类的伙伴对象定义中查找所需的 implicit 定义。例如下面的定义：</p><pre><code>object Dollar {    implicit def dollarToEuro(x:Dollar):Euro = ...    ...}class Dollar {   ...}</code></pre><p>如果在 class Dollar 的方法有需要 Euro 类型，但输入数据使用的是 Dollar，编译器会在其伙伴对象 object Dollar 查找所需的隐式类型转换，本例定义一个从 Dollar 到 Euro 的 implicit 定义可以使用。</p><h2 id="一次规则"><a href="#一次规则" class="headerlink" title="一次规则"></a>一次规则</h2><p>编译器在需要使用 implicit 定义时，只会试图转换一次，也就是编译器永远不会把 x + y 改写成 convert1(convert2(x)) + y。</p><h2 id="优先规则"><a href="#优先规则" class="headerlink" title="优先规则"></a>优先规则</h2><p>编译器不会在 x+y 已经是合法的情况下去调用 implicit 规则。</p><h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><p>你可以为 implicit 定义任意的名称。通常情况下你可以任意命名，implicit 的名称只在两种情况下有用：一是你想在一个方法中明确指明，另外一个是想把那一个引入到当前作用域。比如我们定义一个对象，包含两个 implicit定义：</p><pre><code>object MyConversions {    implicit def stringWrapper(s:String):IndexedSeq[Char] = ...    implicit def intToString(x:Int):String = ...}</code></pre><p>在你的应用中，你想使用 stringWrapper 变换，而不想把整数自动转换成字符串，你可以只引入 stringWrapper。</p><pre><code>import  MyConversions.stringWrapper</code></pre><h2 id="编译器使用-implicit-的几种情况"><a href="#编译器使用-implicit-的几种情况" class="headerlink" title="编译器使用 implicit 的几种情况"></a>编译器使用 implicit 的几种情况</h2><p>有三种情况使用 implicit: 一是转换成预期的数据类型，二是转换 selection 的 receiver，三是隐含参数。转换成预期的数据类型比如你有一个方法参数类型是 IndexedSeq[Char]，在你传入 String 时，编译器发现类型不匹配，就检查当前作用域是否有从 String 到 IndexedSeq 隐式转换。</p><p>转换 selection 的 receiver 允许你适应某些方法调用，比如 “abc”.exist ，”abc”类型为 String，本身没有定义 exist 方法，这时编辑器就检查当前作用域内 String 的隐式转换后的类型是否有 exist 方法，发现 stringWrapper 转换后成 IndexedSeq 类型后，可以有 exist 方法，这个和 C# 静态扩展方法功能类似。</p><p>隐含参数有点类似是缺省参数，如果在调用方法时没有提供某个参数，编译器会查找当前作用域是否有符合条件的 implicit 对象作为参数传入（有点类似 dependency injection)。</p><h2 id="implicit-function-隐式函数"><a href="#implicit-function-隐式函数" class="headerlink" title="implicit function 隐式函数"></a>implicit function 隐式函数</h2><h3 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h3><p>第一种implicit的用法，是将其加在function定义的前面，形式为:</p><pre><code>implicit def int2String(someInt: Int): String = {  //...}</code></pre><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>这种用法可以用来进行implicit conversion，隐式转换，也就是说，编译器可以选择在合适的时候调用这些函数来进行一个转换，来保证类型的正确性，比如我可以通过定义一个implicit的转换函数将java的类型转换为scala的类型，这样在需要scala类型但是却使用java类型作为参数的时候，编译器会自动加入这个转换函数.</p><pre><code>object HelloScala {  implicit def conv(a: Int) = {    println(&quot;in conv&quot;)    a.toString  }  def say(b: String) = println(b)  def main(args: Array[String])  {    say(5)  }}//输出结果:// in conv// 5//这说明过程是say(conv(5))//原因是编译器在检查的时候发现需要一个String类型的参数，但是代入的是一个Int，于是//他会在范围内寻找implicit的function，找到了符合这个要求的String =&gt; Int的function，于是调用</code></pre><h2 id="implicit-parameter-amp-implicit-value-隐式参数和隐式值"><a href="#implicit-parameter-amp-implicit-value-隐式参数和隐式值" class="headerlink" title="implicit parameter &amp; implicit value 隐式参数和隐式值"></a>implicit parameter &amp; implicit value 隐式参数和隐式值</h2><h3 id="形式-1"><a href="#形式-1" class="headerlink" title="形式"></a>形式</h3><h3 id="隐式参数"><a href="#隐式参数" class="headerlink" title="隐式参数"></a>隐式参数</h3><p>隐式参数是在函数中，将参数标志出implicit，形式为:</p><pre><code>def func(implicit x: Int)def func2(x: Int)(implicit y: Int)def func3(implicit x: Int, y: Int)</code></pre><p>这三种形式是有区别的，在参数中implicit只能出现一次，而在此之后，所有的参数都会变为implicit。</p><pre><code>func: x是implicit的func2: 只有y是implicit的func3: x和y都是implicit的</code></pre><p>注意避免以下几种错误写法:<br>      //以下三种情况无法编译通过<br>      def err(x: Int, implicit y: Int)<br>      def err(implicit x: Int)(implicit y: Int)<br>      def err(implicit x: Int)(y: Int)<br>这三种情况都是无法编译通过的</p><h2 id="隐式值"><a href="#隐式值" class="headerlink" title="隐式值"></a>隐式值</h2><pre><code>implicit object Testimplicit val x = 5implicit var y</code></pre><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>这种用法的作用主要是两种用法搭配起来来达到一个效果，隐式参数表明这个参数是可以缺少的，也就是说在调用的时候这个参数可以不用出现，那么这个值由什么填充呢？ 那就是用隐式的值了，以下的例子说明了这一点:<br>    object HelloScala {<br>      abstract class Sayable{<br>        def say<br>      }<br>      implicit object hello extends Sayable{<br>        override def say()={<br>          println(“hello”)<br>        }<br>      }<br>      def func(implicit x:Sayable): Unit ={<br>        x.say<br>      }<br>      implicit val impVal=5<br>      def func1(implicit x:Int)={<br>        println(x)<br>      }<br>      def main(args: Array[String])  {<br>        func<br>        func1<br>      }<br>    }</p><p>输出结果为:</p><pre><code>im in hello5</code></pre><p>因为object的类型并不是object的名字，所以使用了一个抽象class来指明type。</p><p>在调用func的时候，没有代入参数，其参数是由编译器检查之后决定的，而这里决定的就是唯一的可能，hello那个object，所以这里的say调用的就是hello object里的say</p><p>在调用func1的时候，同样没有代入参数，需要一个Int作为参数，编译器寻找值的时候寻找到impVal是implicit的值，所以这里选择impVal作为他的值，输出了5</p><h2 id="implicit-class-隐式类"><a href="#implicit-class-隐式类" class="headerlink" title="implicit class 隐式类"></a>implicit class 隐式类</h2><p>这是一个在scala 2.10中新增的用法</p><h3 id="形式-2"><a href="#形式-2" class="headerlink" title="形式"></a>形式</h3><pre><code>implicit class MyClass(x: Int)</code></pre><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><p>这里的作用主要是其主构造函数可以作为隐式转换的参数，相当于其主构造函数可以用来当做一个implicit的function，下面举例说明一下:</p><pre><code>object HelloScala {  implicit class MyName(x: Int) {    println(&quot;im in cons&quot;)    val y = x  }  def say(x: MyName) = {    println(x.y)  }  def main(args: Array[String])  {    say(5)  }}</code></pre><p>输出结果:</p><pre><code>im in cons5</code></pre><p>这里的MyName是一个隐式类，其主构造函数可以用作隐式转换，所以say需要一个MyName类型的参数，但是调用的时候给的是一个Int，这里就会调用MyName的主构造函数转换为一个MyName的对象，然后再println其y的值</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】 <a href="https://www.iteblog.com/archives/1228.html" target="_blank" rel="noopener">https://www.iteblog.com/archives/1228.html</a><br>【2】 <a href="https://www.runoob.com/scala/currying-functions.html" target="_blank" rel="noopener">https://www.runoob.com/scala/currying-functions.html</a><br>【3】 <a href="https://blog.csdn.net/qq_29343201/article/details/58588470" target="_blank" rel="noopener">https://blog.csdn.net/qq_29343201/article/details/58588470</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Scala学习：集合，柯里化，implicit关键字&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记VIII</title>
    <link href="http://yoursite.com/2019/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0VIII/"/>
    <id>http://yoursite.com/2019/09/06/Java学习笔记VIII/</id>
    <published>2019-09-06T10:43:12.000Z</published>
    <updated>2019-09-16T09:04:07.370Z</updated>
    
    <content type="html"><![CDATA[<p>使用Quzrtz 及Cron定时表达式语法解析</p><a id="more"></a><h1 id="Cron表达式范例："><a href="#Cron表达式范例：" class="headerlink" title="Cron表达式范例："></a>Cron表达式范例：</h1><pre><code>*/10 * * * * ?  每隔10秒执行一次0 */1 * * * ?  每隔1分钟执行一次0 0 23 * * ?  每天23点执行一次0 0 1 * * ?  每天凌晨1点执行一次：0 0 1 1 * ?  每月1号凌晨1点执行一次0 0 23 L * ?  每月最后一天23点执行一次0 0 1 ? * L  每周星期天凌晨1点实行一次0 26,29,33 * * * ?  在26分、29分、33分执行一次0 0 0,13,18,21 * * ? 每天的0点、13点、18点、21点都执行一次</code></pre><h1 id="Cron-表达式"><a href="#Cron-表达式" class="headerlink" title="Cron 表达式"></a>Cron 表达式</h1><p>Cron表达式由7个部分组成，各部分用空格隔开，例如0 0 12 ? * WED（每星期三下午12:00 执行）</p><p>Cron表达式的7个部分从左到右代表的含义如下</p><pre><code>Seconds Minutes Hours Day-of-Month Month Day-of-Week Year</code></pre><p>其中Year是可选的</p><h1 id="Cron表达式可选的值"><a href="#Cron表达式可选的值" class="headerlink" title="Cron表达式可选的值"></a>Cron表达式可选的值</h1><pre><code>Seconds秒：数字0－59Minutes分：数字0－59Hours时 ：数字0-23Day-of-Month月中的几号 ：可以用数字1-31 中的任一一个值，但要注意一些特别的月份Month一年中的几月：可以用0-11 或用字符串 “JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV and DEC” 表示Day-of-Week每周：数字1-7（1 ＝ 星期日），或用字符口串“SUN, MON, TUE, WED, THU, FRI and SAT”字段名                 允许的值                        允许的特殊字符  秒                    0-59                            , - * /  分                    0-59                            , - * /  小时                  0-23                            , - * /  日                    1-31                            , - * ? / L W C  月                    1-12 or JAN-DEC                 , - * /  周几                  1-7 or SUN-SAT                   , - * ? / L C #  年 (可选字段)          empty, 1970-2099                 , - * /</code></pre><h1 id="Cron中的符号"><a href="#Cron中的符号" class="headerlink" title="Cron中的符号"></a>Cron中的符号</h1><pre><code>* ：代表整个时间段./ ：表示每多长时间执行一次0/15表示每隔15分钟执行一次,“0”表示为从“0”分开始；3/20表示每隔20分钟执行一次，“3”表示从第3分钟开始执行? ：表示每月的某一天，或第几周的某一天L ：“6L”表示“每月的最后一个星期五”W：表示为最近工作日如“15W”放在每月（day-of-month）字段上表示为“到本月15日最近的工作日”#：是用来指定“的”每月第n个工作日&quot;6#3&quot;或者&quot;FRI#3&quot;:在每周（day-of-week）中表示“每月第三个星期五”问号(?)就是用来对日期和星期字段做互斥的，问号(?)的作用是指明该字段‘没有特定的值’，星号(*)和其它值，比如数字，都是给该字段指明特定的值，而星号(*)代表所有，在天时表示每一天。“?”字符：表示不确定的值“,”字符：指定数个值“-”字符：指定一个值的范围“/”字符：指定一个值的增加幅度。n/m表示从n开始，每次增加m“L”字符：用在日表示一个月中的最后一天，用在周表示该月最后一个星期X“W”字符：指定离给定日期最近的工作日(周一到周五)“#”字符：表示该月第几个周X。6#3表示该月第3个周五</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<br><a href="https://www.jianshu.com/p/f03b1497122a" target="_blank" rel="noopener">https://www.jianshu.com/p/f03b1497122a</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Quzrtz 及Cron定时表达式语法解析&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记VII</title>
    <link href="http://yoursite.com/2019/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0VII/"/>
    <id>http://yoursite.com/2019/09/06/Java学习笔记VII/</id>
    <published>2019-09-06T07:12:12.000Z</published>
    <updated>2019-09-06T07:43:28.956Z</updated>
    
    <content type="html"><![CDATA[<p>Java并发编程中synchronized的概念</p><a id="more"></a><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>synchronized 是 Java 中的关键字，是利用锁的机制来实现同步的。<br>锁机制有如下两种特性：</p><h2 id="互斥性："><a href="#互斥性：" class="headerlink" title="互斥性："></a>互斥性：</h2><p>即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程中的协调机制，这样在同一时间只有一个线程对需同步的代码块(复合操作)进行访问。互斥性我们也往往称为操作的原子性。</p><h2 id="可见性："><a href="#可见性：" class="headerlink" title="可见性："></a>可见性：</h2><p>必须确保在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的（即在获得锁时应获得最新共享变量的值），否则另一个线程可能是在本地缓存的某个副本上继续操作从而引起不一致。</p><h1 id="对象锁和类锁"><a href="#对象锁和类锁" class="headerlink" title="对象锁和类锁"></a>对象锁和类锁</h1><h2 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h2><p>在 Java 中，每个对象都会有一个 monitor 对象，这个对象其实就是 Java 对象的锁，通常会被称为“内置锁”或“对象锁”。类的对象可以有多个，所以每个对象有其独立的对象锁，互不干扰。</p><h2 id="类锁"><a href="#类锁" class="headerlink" title="类锁"></a>类锁</h2><p>在 Java 中，针对每个类也有一个锁，可以称为“类锁”，类锁实际上是通过对象锁实现的，即类的 Class 对象锁。每个类只有一个 Class 对象，所以每个类只有一个类锁。</p><h1 id="synchronized-的用法分类"><a href="#synchronized-的用法分类" class="headerlink" title="synchronized 的用法分类"></a>synchronized 的用法分类</h1><p>synchronized 的用法可以从两个维度上面分类：</p><h2 id="根据修饰对象分类"><a href="#根据修饰对象分类" class="headerlink" title="根据修饰对象分类"></a>根据修饰对象分类</h2><p>synchronized 可以修饰方法和代码块</p><h3 id="修饰代码块"><a href="#修饰代码块" class="headerlink" title="修饰代码块"></a>修饰代码块</h3><pre><code>synchronized(this|object) {}synchronized(类.class) {}</code></pre><h3 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h3><p>修饰非静态方法</p><p>修饰静态方法</p><h2 id="根据获取的锁分类"><a href="#根据获取的锁分类" class="headerlink" title="根据获取的锁分类"></a>根据获取的锁分类</h2><h3 id="获取对象锁"><a href="#获取对象锁" class="headerlink" title="获取对象锁"></a>获取对象锁</h3><pre><code>synchronized(this|object) {}</code></pre><p>修饰非静态方法</p><h3 id="获取类锁"><a href="#获取类锁" class="headerlink" title="获取类锁"></a>获取类锁</h3><pre><code>synchronized(类.class) {}</code></pre><p>修饰静态方法</p><h1 id="synchronized-的用法详解"><a href="#synchronized-的用法详解" class="headerlink" title="synchronized 的用法详解"></a>synchronized 的用法详解</h1><p>这里根据获取的锁分类来分析 synchronized 的用法</p><h2 id="获取对象锁-1"><a href="#获取对象锁-1" class="headerlink" title="获取对象锁"></a>获取对象锁</h2><h3 id="对于同一对象"><a href="#对于同一对象" class="headerlink" title="对于同一对象"></a>对于同一对象</h3><p>同步线程类：</p><pre><code>class SyncThread implements Runnable {    @Override    public void run() {        String threadName = Thread.currentThread().getName();        if (threadName.startsWith(&quot;A&quot;)) {            async();        } else if (threadName.startsWith(&quot;B&quot;)) {            sync1();        } else if (threadName.startsWith(&quot;C&quot;)) {            sync2();        }    }    /**     * 异步方法     */    private void async() {        try {            System.out.println(Thread.currentThread().getName() + &quot;_Async_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            Thread.sleep(2000);            System.out.println(Thread.currentThread().getName() + &quot;_Async_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));        } catch (InterruptedException e) {            e.printStackTrace();        }    }    /**     * 方法中有 synchronized(this|object) {} 同步代码块     */    private void sync1() {        System.out.println(Thread.currentThread().getName() + &quot;_Sync1: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));        synchronized (this) {            try {                System.out.println(Thread.currentThread().getName() + &quot;_Sync1_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));                Thread.sleep(2000);                System.out.println(Thread.currentThread().getName() + &quot;_Sync1_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }    /**     * synchronized 修饰非静态方法     */    private synchronized void sync2() {        System.out.println(Thread.currentThread().getName() + &quot;_Sync2: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));        try {            System.out.println(Thread.currentThread().getName() + &quot;_Sync2_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            Thread.sleep(2000);            System.out.println(Thread.currentThread().getName() + &quot;_Sync2_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><p>测试代码：</p><pre><code>public class SyncTest {    public static void main(String... args) {        SyncThread syncThread = new SyncThread();        Thread A_thread1 = new Thread(syncThread, &quot;A_thread1&quot;);        Thread A_thread2 = new Thread(syncThread, &quot;A_thread2&quot;);        Thread B_thread1 = new Thread(syncThread, &quot;B_thread1&quot;);        Thread B_thread2 = new Thread(syncThread, &quot;B_thread2&quot;);        Thread C_thread1 = new Thread(syncThread, &quot;C_thread1&quot;);        Thread C_thread2 = new Thread(syncThread, &quot;C_thread2&quot;);        A_thread1.start();        A_thread2.start();        B_thread1.start();        B_thread2.start();        C_thread1.start();        C_thread2.start();    }}</code></pre><p>运行结果：</p><pre><code>B_thread2_Sync1: 14:44:20A_thread1_Async_Start: 14:44:20B_thread1_Sync1: 14:44:20C_thread1_Sync2: 14:44:20A_thread2_Async_Start: 14:44:20C_thread1_Sync2_Start: 14:44:20A_thread1_Async_End: 14:44:22A_thread2_Async_End: 14:44:22C_thread1_Sync2_End: 14:44:22B_thread1_Sync1_Start: 14:44:22B_thread1_Sync1_End: 14:44:24B_thread2_Sync1_Start: 14:44:24B_thread2_Sync1_End: 14:44:26C_thread2_Sync2: 14:44:26C_thread2_Sync2_Start: 14:44:26C_thread2_Sync2_End: 14:44:28</code></pre><p>结果分析：</p><p>A 类线程访问方法中没有同步代码块，A 类线程是异步的，所以有线程访问对象的同步代码块时，另外的线程可以访问该对象的非同步代码块：</p><pre><code>A_thread1_Async_Start: 14:44:20A_thread2_Async_Start: 14:44:20A_thread1_Async_End: 14:44:22A_thread2_Async_End: 14:44:22</code></pre><p>B 类线程访问的方法中有同步代码块，B 类线程是同步的，一个线程在访问对象的同步代码块，另一个访问对象的同步代码块的线程会被阻塞：</p><pre><code>B_thread1_Sync1_End: 14:44:24B_thread2_Sync1_Start: 14:44:24B_thread2_Sync1_End: 14:44:26synchronized(this|object) {} 代码块 {} 之外的代码依然是异步的：B_thread2_Sync1: 14:44:20B_thread1_Sync1: 14:44:20</code></pre><p>C 类线程访问的是 synchronized 修饰非静态方法，C 类线程是同步的，一个线程在访问对象的同步代方法，另一个访问对象同步方法的线程会被阻塞：</p><pre><code>C_thread1_Sync2_Start: 14:44:20C_thread1_Sync2_End: 14:44:22C_thread2_Sync2_Start: 14:44:26C_thread2_Sync2_End: 14:44:28</code></pre><p>synchronized 修饰非静态方法，作用范围是整个方法，所以方法中所有的代码都是同步的：</p><pre><code>C_thread1_Sync2: 14:44:20C_thread2_Sync2: 14:44:26</code></pre><p>由结果可知 B 类和 C 类线程顺序执行，类中 synchronized(this|object) {} 代码块和 synchronized 修饰非静态方法获取的锁是同一个锁，即该类的对象的对象锁。所以 B 类线程和 C 类线程也是同步的：</p><pre><code>B_thread1_Sync1_Start: 14:44:22B_thread1_Sync1_End: 14:44:24C_thread1_Sync2_Start: 14:44:20C_thread1_Sync2_End: 14:44:22B_thread2_Sync1_Start: 14:44:24B_thread2_Sync1_End: 14:44:26C_thread2_Sync2_Start: 14:44:26C_thread2_Sync2_End: 14:44:28</code></pre><h3 id="对于不同对象"><a href="#对于不同对象" class="headerlink" title="对于不同对象"></a>对于不同对象</h3><p>修改测试代码为：</p><pre><code>public class SyncTest {    public static void main(String... args) {        Thread A_thread1 = new Thread(new SyncThread(), &quot;A_thread1&quot;);        Thread A_thread2 = new Thread(new SyncThread(), &quot;A_thread2&quot;);        Thread B_thread1 = new Thread(new SyncThread(), &quot;B_thread1&quot;);        Thread B_thread2 = new Thread(new SyncThread(), &quot;B_thread2&quot;);        Thread C_thread1 = new Thread(new SyncThread(), &quot;C_thread1&quot;);        Thread C_thread2 = new Thread(new SyncThread(), &quot;C_thread2&quot;);        A_thread1.start();        A_thread2.start();        B_thread1.start();        B_thread2.start();        C_thread1.start();        C_thread2.start();    }}</code></pre><p>运行结果：</p><pre><code>A_thread2_Async_Start: 15:01:34C_thread2_Sync2: 15:01:34B_thread2_Sync1: 15:01:34C_thread1_Sync2: 15:01:34B_thread2_Sync1_Start: 15:01:34B_thread1_Sync1: 15:01:34C_thread1_Sync2_Start: 15:01:34A_thread1_Async_Start: 15:01:34C_thread2_Sync2_Start: 15:01:34B_thread1_Sync1_Start: 15:01:34C_thread1_Sync2_End: 15:01:36A_thread1_Async_End: 15:01:36C_thread2_Sync2_End: 15:01:36B_thread2_Sync1_End: 15:01:36B_thread1_Sync1_End: 15:01:36A_thread2_Async_End: 15:01:36</code></pre><p>结果分析：</p><p>两个线程访问不同对象的 synchronized(this|object) {} 代码块和 synchronized 修饰非静态方法是异步的，同一个类的不同对象的对象锁互不干扰。</p><h2 id="获取类锁-1"><a href="#获取类锁-1" class="headerlink" title="获取类锁"></a>获取类锁</h2><h3 id="对于同一对象-1"><a href="#对于同一对象-1" class="headerlink" title="对于同一对象"></a>对于同一对象</h3><p>同步线程类：</p><pre><code>class SyncThread implements Runnable {    @Override    public void run() {        String threadName = Thread.currentThread().getName();        if (threadName.startsWith(&quot;A&quot;)) {            async();        } else if (threadName.startsWith(&quot;B&quot;)) {            sync1();        } else if (threadName.startsWith(&quot;C&quot;)) {            sync2();        }    }    /**     * 异步方法     */    private void async() {        try {            System.out.println(Thread.currentThread().getName() + &quot;_Async_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            Thread.sleep(2000);            System.out.println(Thread.currentThread().getName() + &quot;_Async_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));        } catch (InterruptedException e) {            e.printStackTrace();        }    }    /**     * 方法中有 synchronized(类.class) {} 同步代码块     */    private void sync1() {        System.out.println(Thread.currentThread().getName() + &quot;_Sync1: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));        synchronized (SyncThread.class) {            try {                System.out.println(Thread.currentThread().getName() + &quot;_Sync1_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));                Thread.sleep(2000);                System.out.println(Thread.currentThread().getName() + &quot;_Sync1_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }    /**     * synchronized 修饰静态方法     */    private synchronized static void sync2() {        System.out.println(Thread.currentThread().getName() + &quot;_Sync2: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));        try {            System.out.println(Thread.currentThread().getName() + &quot;_Sync2_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            Thread.sleep(2000);            System.out.println(Thread.currentThread().getName() + &quot;_Sync2_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><p>测试代码：</p><pre><code>public class SyncTest {    public static void main(String... args) {        SyncThread syncThread = new SyncThread();        Thread A_thread1 = new Thread(syncThread, &quot;A_thread1&quot;);        Thread A_thread2 = new Thread(syncThread, &quot;A_thread2&quot;);        Thread B_thread1 = new Thread(syncThread, &quot;B_thread1&quot;);        Thread B_thread2 = new Thread(syncThread, &quot;B_thread2&quot;);        Thread C_thread1 = new Thread(syncThread, &quot;C_thread1&quot;);        Thread C_thread2 = new Thread(syncThread, &quot;C_thread2&quot;);        A_thread1.start();        A_thread2.start();        B_thread1.start();        B_thread2.start();        C_thread1.start();        C_thread2.start();    }}</code></pre><p>运行结果：</p><pre><code>B_thread1_Sync1: 15:08:13C_thread1_Sync2: 15:08:13B_thread2_Sync1: 15:08:13A_thread1_Async_Start: 15:08:13C_thread1_Sync2_Start: 15:08:13A_thread2_Async_Start: 15:08:13C_thread1_Sync2_End: 15:08:15A_thread2_Async_End: 15:08:15A_thread1_Async_End: 15:08:15B_thread2_Sync1_Start: 15:08:15B_thread2_Sync1_End: 15:08:17B_thread1_Sync1_Start: 15:08:17B_thread1_Sync1_End: 15:08:19C_thread2_Sync2: 15:08:19C_thread2_Sync2_Start: 15:08:19C_thread2_Sync2_End: 15:08:21</code></pre><p>结果分析：</p><p>由结果可以看出，在同一对象的情况下，synchronized(类.class) {} 代码块或 synchronized 修饰静态方法和 synchronized(this|object) {} 代码块和 synchronized 修饰非静态方法的行为一致。</p><h3 id="对于不同对象-1"><a href="#对于不同对象-1" class="headerlink" title="对于不同对象"></a>对于不同对象</h3><p>修改测试代码为：</p><pre><code>public class SyncTest {    public static void main(String... args) {        Thread A_thread1 = new Thread(new SyncThread(), &quot;A_thread1&quot;);        Thread A_thread2 = new Thread(new SyncThread(), &quot;A_thread2&quot;);        Thread B_thread1 = new Thread(new SyncThread(), &quot;B_thread1&quot;);        Thread B_thread2 = new Thread(new SyncThread(), &quot;B_thread2&quot;);        Thread C_thread1 = new Thread(new SyncThread(), &quot;C_thread1&quot;);        Thread C_thread2 = new Thread(new SyncThread(), &quot;C_thread2&quot;);        A_thread1.start();        A_thread2.start();        B_thread1.start();        B_thread2.start();        C_thread1.start();        C_thread2.start();    }}</code></pre><p>运行结果：</p><pre><code>A_thread2_Async_Start: 15:17:28B_thread2_Sync1: 15:17:28A_thread1_Async_Start: 15:17:28B_thread1_Sync1: 15:17:28C_thread1_Sync2: 15:17:28C_thread1_Sync2_Start: 15:17:28C_thread1_Sync2_End: 15:17:30A_thread2_Async_End: 15:17:30B_thread1_Sync1_Start: 15:17:30A_thread1_Async_End: 15:17:30B_thread1_Sync1_End: 15:17:32B_thread2_Sync1_Start: 15:17:32B_thread2_Sync1_End: 15:17:34C_thread2_Sync2: 15:17:34C_thread2_Sync2_Start: 15:17:34C_thread2_Sync2_End: 15:17:36</code></pre><p>结果分析：</p><p>两个线程访问不同对象的 synchronized(类.class) {} 代码块或 synchronized 修饰静态方法还是同步的，类中 synchronized(类.class) {} 代码块和 synchronized 修饰静态方法获取的锁是类锁。对于同一个类的不同对象的类锁是同一个。</p><h2 id="类中同时有-synchronized-类-class-代码块或-synchronized-修饰静态方法和-synchronized-this-object-代码块和-synchronized-修饰非静态方法时会怎样？"><a href="#类中同时有-synchronized-类-class-代码块或-synchronized-修饰静态方法和-synchronized-this-object-代码块和-synchronized-修饰非静态方法时会怎样？" class="headerlink" title="类中同时有 synchronized(类.class) {} 代码块或 synchronized 修饰静态方法和 synchronized(this|object) {} 代码块和 synchronized 修饰非静态方法时会怎样？"></a>类中同时有 synchronized(类.class) {} 代码块或 synchronized 修饰静态方法和 synchronized(this|object) {} 代码块和 synchronized 修饰非静态方法时会怎样？</h2><p>修改同步线程类：</p><pre><code>class SyncThread implements Runnable {    @Override    public void run() {        String threadName = Thread.currentThread().getName();        if (threadName.startsWith(&quot;A&quot;)) {            async();        } else if (threadName.startsWith(&quot;B&quot;)) {            sync1();        } else if (threadName.startsWith(&quot;C&quot;)) {            sync2();        }    }    /**     * 异步方法     */    private void async() {        try {            System.out.println(Thread.currentThread().getName() + &quot;_Async_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            Thread.sleep(2000);            System.out.println(Thread.currentThread().getName() + &quot;_Async_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));        } catch (InterruptedException e) {            e.printStackTrace();        }    }    /**     * synchronized 修饰非静态方法     */    private synchronized void sync1() {        try {            System.out.println(Thread.currentThread().getName() + &quot;_Sync1_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            Thread.sleep(2000);            System.out.println(Thread.currentThread().getName() + &quot;_Sync1_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));        } catch (InterruptedException e) {            e.printStackTrace();        }    }    /**     * synchronized 修饰静态方法     */    private synchronized static void sync2() {        try {            System.out.println(Thread.currentThread().getName() + &quot;_Sync2_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            Thread.sleep(2000);            System.out.println(Thread.currentThread().getName() + &quot;_Sync2_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><p>修改测试代码：</p><pre><code>public class SyncTest {    public static void main(String... args) {        Thread B_thread1 = new Thread(syncThread, &quot;B_thread1&quot;);        Thread C_thread1 = new Thread(syncThread, &quot;C_thread1&quot;);        B_thread1.start();        C_thread1.start();    }}</code></pre><p>运行结果：</p><pre><code>B_thread1_Sync1_Start: 15:35:21C_thread1_Sync2_Start: 15:35:21B_thread1_Sync1_End: 15:35:23C_thread1_Sync2_End: 15:35:23</code></pre><p>运行结果分析：</p><p>由结果可以看到 B 类线程和 C 类线程是异步的，即 synchronized 修饰静态方法和 synchronized 修饰非静态方法是异步的，对于 synchronized(类.class) {} 代码块和 synchronized(this|object) {} 代码块也是一样的。所以对象锁和类锁是独立的，互不干扰。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>synchronized关键字不能继承。</p><p> 对于父类中的 synchronized 修饰方法，子类在覆盖该方法时，默认情况下不是同步的，必须显示的使用 synchronized 关键字修饰才行。</p><p>在定义接口方法时不能使用synchronized关键字。</p><p>构造方法不能使用synchronized关键字，但可以使用synchronized代码块来进行同步。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】 <a href="https://juejin.im/post/594a24defe88c2006aa01f1c" target="_blank" rel="noopener">https://juejin.im/post/594a24defe88c2006aa01f1c</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java并发编程中synchronized的概念&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记VI</title>
    <link href="http://yoursite.com/2019/09/05/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0VI/"/>
    <id>http://yoursite.com/2019/09/05/Java学习笔记VI/</id>
    <published>2019-09-05T07:12:12.000Z</published>
    <updated>2019-09-05T07:37:21.245Z</updated>
    
    <content type="html"><![CDATA[<p>Java基本数据类型和包装类的区别,不同类型为空的异常判断，集合操作</p><a id="more"></a><p>在实际的工程项目开发中，常遇到对于传入参数的异常处理，对于不同类型的参数需要进行不同的判断，例如有时int，long类型的参数需要判断是否为0，而Integer和Long类型的参数需要判断是否为空。String类型的需要使用StringUtils.isEmpty()</p><h1 id="StringUtils类中isEmpty与isBlank的区别"><a href="#StringUtils类中isEmpty与isBlank的区别" class="headerlink" title="StringUtils类中isEmpty与isBlank的区别"></a>StringUtils类中isEmpty与isBlank的区别</h1><p>org.apache.commons.lang.StringUtils类提供了String的常用操作,最为常用的判空有如下两种isEmpty(String str)和isBlank(String str)。</p><p>StringUtils.isEmpty(String str) 判断某字符串是否为空，为空的标准是 str==null 或 str.length()==0</p><pre><code>System.out.println(StringUtils.isEmpty(null));        //trueSystem.out.println(StringUtils.isEmpty(&quot;&quot;));          //trueSystem.out.println(StringUtils.isEmpty(&quot;   &quot;));       //falseSystem.out.println(StringUtils.isEmpty(&quot;dd&quot;));        //falseStringUtils.isNotEmpty(String str) 等价于 !isEmpty(String str)</code></pre><p>StringUtils.isBlank(String str) 判断某字符串是否为空或长度为0或由空白符(whitespace) 构成</p><pre><code>System.out.println(StringUtils.isBlank(null));        //trueSystem.out.println(StringUtils.isBlank(&quot;&quot;));          //trueSystem.out.println(StringUtils.isBlank(&quot;   &quot;));       //trueSystem.out.println(StringUtils.isBlank(&quot;dd&quot;));        //false    </code></pre><p>StringUtils.isBlank(String str) 等价于 !isBlank(String str)</p><h1 id="集合操作-CollectionUtils"><a href="#集合操作-CollectionUtils" class="headerlink" title="集合操作 CollectionUtils"></a>集合操作 CollectionUtils</h1><p>对于查询到的集合例如：</p><pre><code>List&lt;TblJobsEntity&gt; tblJobsEntityList = tblJobsEntityMapper.selectByExample(tblJobsEntityExample);</code></pre><p>进行判断时，不能使用</p><pre><code>if(tblJobsEntityList.isEmpty())</code></pre><p>因为若查询到的tblJobsEntityList为null，则null.isEmpty()会出现空指针异常，如</p><pre><code>Exception in thread &quot;main&quot; java.lang.NullPointerException</code></pre><p>需要使用CollectionUtils.isEmpty(tblJobsEntityList)来进行判断</p><h2 id="集合判断："><a href="#集合判断：" class="headerlink" title="集合判断："></a>集合判断：</h2><h3 id="判断集合是否为空"><a href="#判断集合是否为空" class="headerlink" title="判断集合是否为空:"></a>判断集合是否为空:</h3><pre><code>CollectionUtils.isEmpty(null): trueCollectionUtils.isEmpty(new ArrayList()): trueCollectionUtils.isEmpty({a,b}): false</code></pre><h3 id="判断集合是否不为空"><a href="#判断集合是否不为空" class="headerlink" title="判断集合是否不为空:"></a>判断集合是否不为空:</h3><pre><code>CollectionUtils.isNotEmpty(null): falseCollectionUtils.isNotEmpty(new ArrayList()): falseCollectionUtils.isNotEmpty({a,b}): true</code></pre><h3 id="2个集合间的操作："><a href="#2个集合间的操作：" class="headerlink" title="2个集合间的操作："></a>2个集合间的操作：</h3><pre><code>集合a: {1,2,3,3,4,5}集合b: {3,4,4,5,6,7}CollectionUtils.union(a, b)(并集): {1,2,3,3,4,4,5,6,7}CollectionUtils.intersection(a, b)(交集): {3,4,5}CollectionUtils.disjunction(a, b)(交集的补集): {1,2,3,4,6,7}CollectionUtils.disjunction(b, a)(交集的补集): {1,2,3,4,6,7}CollectionUtils.subtract(a, b)(A与B的差): {1,2,3}CollectionUtils.subtract(b, a)(B与A的差): {4,6,7}</code></pre><h1 id="Java基本数据类型和包装类的区别"><a href="#Java基本数据类型和包装类的区别" class="headerlink" title="Java基本数据类型和包装类的区别"></a>Java基本数据类型和包装类的区别</h1><p>Java的数据类型分两种：</p><p>基本类型：byte，short，int，long，boolean，float，double，char</p><p>引用类型：所有class和interface类型</p><p>引用类型可以赋值为null，表示空，但基本类型不能赋值为null：</p><pre><code>String s = null;int n = null; // compile error!</code></pre><p>如何把一个基本类型视为对象（引用类型）？</p><h2 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h2><p>比如，想要把int基本类型变成一个引用类型，我们可以定义一个Integer类，它只包含一个实例字段int，这样，Integer类就可以视为int的包装类（Wrapper Class）：</p><pre><code>public class Integer {    private int value;    public Integer(int value) {        this.value = value;    }    public int intValue() {        return this.value;    }}</code></pre><p>定义好了Integer类，我们就可以把int和Integer互相转换：</p><pre><code>Integer n = null;Integer n2 = new Integer(99);int n3 = n2.intValue();</code></pre><p>实际上，因为包装类型非常有用，Java核心库为每种基本类型都提供了对应的包装类型：</p><pre><code>基本类型      对应的引用类型boolean       java.lang.Booleanbyte         java.lang.Byteshort         java.lang.Shortint           java.lang.Integerlong         java.lang.Longfloat         java.lang.Floatdouble       java.lang.Doublechar         java.lang.Character</code></pre><p>我们可以直接使用，并不需要自己去定义：</p><pre><code>// Integer:public class Main {    public static void main(String[] args) {        int i = 100;        // 通过new操作符创建Integer实例(不推荐使用,会有编译警告):        Integer n1 = new Integer(i);        // 通过静态方法valueOf(int)创建Integer实例:        Integer n2 = Integer.valueOf(i);        // 通过静态方法valueOf(String)创建Integer实例:        Integer n3 = Integer.valueOf(&quot;100&quot;);        System.out.println(n3.intValue());    }}</code></pre><h2 id="Auto-Boxing"><a href="#Auto-Boxing" class="headerlink" title="Auto Boxing"></a>Auto Boxing</h2><p>因为int和Integer可以互相转换：</p><pre><code>int i = 100;Integer n = Integer.valueOf(i);int x = n.intValue();</code></pre><p>所以，Java编译器可以帮助我们自动在int和Integer之间转型：</p><pre><code>Integer n = 100; // 编译器自动使用Integer.valueOf(int)int x = n; // 编译器自动使用Integer.intValue()</code></pre><p>这种直接把int变为Integer的赋值写法，称为自动装箱（Auto Boxing），反过来，把Integer变为int的赋值写法，称为自动拆箱（Auto Unboxing）。</p><p>注意：自动装箱和自动拆箱只发生在编译阶段，目的是为了少写代码。</p><p>装箱和拆箱会影响代码的执行效率，因为编译后的class代码是严格区分基本类型和引用类型的。并且，自动拆箱执行时可能会报NullPointerException：</p><pre><code>// NullPointerExceptionpublic class Main {    public static void main(String[] args) {        Integer n = null;        int i = n;    }}</code></pre><h2 id="不变类"><a href="#不变类" class="headerlink" title="不变类"></a>不变类</h2><p>所有的包装类型都是不变类。我们查看Integer的源码可知，它的核心代码如下：</p><pre><code>public final class Integer {    private final int value;}</code></pre><p>因此，一旦创建了Integer对象，该对象就是不变的。</p><p>对两个Integer实例进行比较要特别注意：绝对不能用==比较，因为Integer是引用类型，必须使用equals()比较：</p><pre><code>// == or equals?public class Main {    public static void main(String[] args) {        Integer x = 127;        Integer y = 127;        Integer m = 99999;        Integer n = 99999;        System.out.println(&quot;x == y: &quot; + (x==y)); // true        System.out.println(&quot;m == n: &quot; + (m==n)); // false        System.out.println(&quot;x.equals(y): &quot; + x.equals(y)); // true        System.out.println(&quot;m.equals(n): &quot; + m.equals(n)); // true    }}</code></pre><p>仔细观察结果的童鞋可以发现，==比较，较小的两个相同的Integer返回true，较大的两个相同的Integer返回false，这是因为Integer是不变类，编译器把Integer x = 127;自动变为Integer x = Integer.valueOf(127);</p><p>为了节省内存，Integer.valueOf()对于较小的数，始终返回相同的实例，因此，==比较“恰好”为true，但我们绝不能因为Java标准库的Integer内部有缓存优化就用==比较，必须用equals()方法比较两个Integer。</p><p>按照语义编程，而不是针对特定的底层实现去“优化”。</p><p>因为Integer.valueOf()可能始终返回同一个Integer实例，因此，在我们自己创建Integer的时候，以下两种方法：</p><pre><code>方法1：Integer n = new Integer(100);方法2：Integer n = Integer.valueOf(100);</code></pre><p>方法2更好，因为方法1总是创建新的Integer实例，方法2把内部优化留给Integer的实现者去做，即使在当前版本没有优化，也有可能在下一个版本进行优化。</p><p>我们把能创建“新”对象的静态方法称为静态工厂方法。Integer.valueOf()就是静态工厂方法，它尽可能地返回缓存的实例以节省内存。</p><p> 创建新对象时，优先选用静态工厂方法而不是new操作符。</p><p>如果我们考察Byte.valueOf()方法的源码，可以看到，标准库返回的Byte实例全部是缓存实例，但调用者并不关心静态工厂方法以何种方式创建新实例还是直接返回缓存的实例。</p><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><p>Integer类本身还提供了大量方法，例如，最常用的静态方法parseInt()可以把字符串解析成一个整数：</p><pre><code>int x1 = Integer.parseInt(&quot;100&quot;); // 100int x2 = Integer.parseInt(&quot;100&quot;, 16); // 256,因为按16进制解析</code></pre><p>Integer还可以把整数格式化为指定进制的字符串：</p><pre><code>// Integer:public class Main {    public static void main(String[] args) {        System.out.println(Integer.toString(100)); // &quot;100&quot;,表示为10进制        System.out.println(Integer.toString(100, 36)); // &quot;2s&quot;,表示为36进制        System.out.println(Integer.toHexString(100)); // &quot;64&quot;,表示为16进制        System.out.println(Integer.toOctalString(100)); // &quot;144&quot;,表示为8进制        System.out.println(Integer.toBinaryString(100)); // &quot;1100100&quot;,表示为2进制    }}</code></pre><p>注意：上述方法的输出都是String，在计算机内存中，只用二进制表示，不存在十进制或十六进制的表示方法。int n = 100在内存中总是以4字节的二进制表示：</p><pre><code>┌────────┬────────┬────────┬────────┐│00000000│00000000│00000000│01100100│└────────┴────────┴────────┴────────┘</code></pre><p>我们经常使用的System.out.println(n);是依靠核心库自动把整数格式化为10进制输出并显示在屏幕上，使用Integer.toHexString(n)则通过核心库自动把整数格式化为16进制。</p><p>这里我们注意到程序设计的一个重要原则：数据的存储和显示要分离。</p><p>Java的包装类型还定义了一些有用的静态变量</p><pre><code>// boolean只有两个值true/false，其包装类型只需要引用Boolean提供的静态字段:Boolean t = Boolean.TRUE;Boolean f = Boolean.FALSE;// int可表示的最大/最小值:int max = Integer.MAX_VALUE; // 2147483647int min = Integer.MIN_VALUE; // -2147483648// long类型占用的bit和byte数量:int sizeOfLong = Long.SIZE; // 64 (bits)int bytesOfLong = Long.BYTES; // 8 (bytes)</code></pre><p>最后，所有的整数和浮点数的包装类型都继承自Number，因此，可以非常方便地直接通过包装类型获取各种基本类型：</p><pre><code>// 向上转型为Number:Number num = new Integer(999);// 获取byte, int, long, float, double:byte b = num.byteValue();int n = num.intValue();long ln = num.longValue();float f = num.floatValue();double d = num.doubleValue();</code></pre><h2 id="处理无符号整型"><a href="#处理无符号整型" class="headerlink" title="处理无符号整型"></a>处理无符号整型</h2><p>在Java中，并没有无符号整型（Unsigned）的基本数据类型。byte、short、int和long都是带符号整型，最高位是符号位。而C语言则提供了CPU支持的全部数据类型，包括无符号整型。无符号整型和有符号整型的转换在Java中就需要借助包装类型的静态方法完成。</p><p>例如，byte是有符号整型，范围是-128~+127，但如果把byte看作无符号整型，它的范围就是0~255。我们把一个负的byte按无符号整型转换为int：</p><pre><code>// Bytepublic class Main {    public static void main(String[] args) {        byte x = -1;        byte y = 127;        System.out.println(Byte.toUnsignedInt(x)); // 255        System.out.println(Byte.toUnsignedInt(y)); // 127    }}</code></pre><p>因为byte的-1的二进制表示是11111111，以无符号整型转换后的int就是255。</p><p>类似的，可以把一个short按unsigned转换为int，把一个int按unsigned转换为long。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Java核心库提供的包装类型可以把基本类型包装为class；</p><p>自动装箱和自动拆箱都是在编译期完成的（JDK&gt;=1.5）；</p><p>装箱和拆箱会影响执行效率，且拆箱时可能发生NullPointerException；</p><p>包装类型的比较必须使用equals()；</p><p>整数和浮点数的包装类型都继承自Number；</p><p>包装类型提供了大量实用方法。</p><h2 id="思考：Java中基本数据类型和包装类型有什么区别"><a href="#思考：Java中基本数据类型和包装类型有什么区别" class="headerlink" title="思考：Java中基本数据类型和包装类型有什么区别"></a>思考：Java中基本数据类型和包装类型有什么区别</h2><p>1、包装类是对象，拥有方法和字段，对象的调用都是通过引用对象的地址，基本类型不是</p><p>2、包装类型是引用的传递，基本类型是值的传递</p><p>3、声明方式不同，基本数据类型不需要new关键字，而包装类型需要new在堆内存中进行new来分配内存空间</p><p>4、存储位置不同，基本数据类型直接将值保存在值栈中，而包装类型是把对象放在堆中，然后通过对象的引用来调用他们</p><p>5、<strong><em>初始值不同，eg： int的初始值为 0 、 boolean的初始值为false 而包装类型的初始值为null</em></strong></p><p>6、使用方式不同，基本数据类型直接赋值使用就好 ，而包装类型是在集合如 collection Map时会使用</p><p>7.当需要往ArrayList，HashMap中放东西时，像int，double这种基本类型是放不进去的，因为容器都是装object的，这是就需要这些基本类型的外覆类了，比如</p><pre><code>List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="https://blog.csdn.net/shb_derek1/article/details/9624897" target="_blank" rel="noopener">https://blog.csdn.net/shb_derek1/article/details/9624897</a></p><p>【2】<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260473794166400" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1252599548343744/1260473794166400</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java基本数据类型和包装类的区别,不同类型为空的异常判断，集合操作&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
</feed>
