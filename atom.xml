<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-24T15:00:41.613Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>865. Smallest Subtree with all the Deepest Nodes具有所有最深结点的最小子树</title>
    <link href="http://yoursite.com/2018/08/24/865.%20Smallest%20Subtree%20with%20all%20the%20Deepest%20Nodes%E5%85%B7%E6%9C%89%E6%89%80%E6%9C%89%E6%9C%80%E6%B7%B1%E7%BB%93%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E6%A0%91/"/>
    <id>http://yoursite.com/2018/08/24/865. Smallest Subtree with all the Deepest Nodes具有所有最深结点的最小子树/</id>
    <published>2018-08-24T13:06:12.000Z</published>
    <updated>2018-08-24T15:00:41.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="865-Smallest-Subtree-with-all-the-Deepest-Nodes具有所有最深结点的最小子树"><a href="#865-Smallest-Subtree-with-all-the-Deepest-Nodes具有所有最深结点的最小子树" class="headerlink" title="865. Smallest Subtree with all the Deepest Nodes具有所有最深结点的最小子树"></a>865. Smallest Subtree with all the Deepest Nodes具有所有最深结点的最小子树</h1><p>给定一个根为 root 的二叉树，每个结点的深度是它到根的最短距离。</p><p>如果一个结点在整个树的任意结点之间具有最大的深度，则该结点是最深的。</p><p>一个结点的子树是该结点加上它的所有后代的集合。</p><p>返回能满足“以该结点为根的子树中包含所有最深的结点”这一条件的具有最大深度的结点。</p><a id="more"></a><p>示例：</p><p>输入：</p><pre><code>[3,5,1,6,2,0,8,null,null,7,4]</code></pre><p>输出：</p><pre><code>[2,7,4]</code></pre><p><img src="https://ws1.sinaimg.cn/large/0071ouepgy1ful3h7lug7j30k20h2t9l.jpg" alt="image"></p><p>解释：</p><p>我们返回值为 2 的结点，在图中用黄色标记。<br>在图中用蓝色标记的是树的最深的结点。<br>输入 “[3, 5, 1, 6, 2, 0, 8, null, null, 7, 4]” 是对给定的树的序列化表述。<br>输出 “[2, 7, 4]” 是对根结点的值为 2 的子树的序列化表述。<br>输入和输出都具有 TreeNode 类型。</p><p>提示：</p><p>树中结点的数量介于 1 和 500 之间。<br>每个结点的值都是独一无二的。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>写一个子函数 deep(TreeNode root)<br>返回一个 pair(int depth, TreeNode subtreeWithAllDeepest)</p><p>在子函数中：<br>若是结点为空，返回pair(0,null)<br>left=deep(root-&gt;left)<br>right=deep(root-&gt;right)</p><p>如果left depth== right depth<br>有最深的结点同时存在于左右子树中<br>返回pair(left.depth+1,root)</p><p>如果left depth &gt; right depth<br>只有左子树中存在最深结点<br>返回pair(left.depth+1,left subtree)</p><p>如果left depth &lt; right depth<br>只有右子树中存在最深结点<br>返回pair(right.depth+1, right subtree)</p><pre><code>TreeNode* subtreeWithAllDeepest(TreeNode* root) {    return deep(root).second;}pair&lt;int, TreeNode*&gt; deep(TreeNode* root) {    if (!root) return {0, NULL};    pair&lt;int, TreeNode*&gt; l = deep(root-&gt;left), r = deep(root-&gt;right);    int d1 = l.first, d2 = r.first;    return {max(d1, d2) + 1, d1 == d2 ? root : d1 &gt; d2 ? l.second : r.second};}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;865-Smallest-Subtree-with-all-the-Deepest-Nodes具有所有最深结点的最小子树&quot;&gt;&lt;a href=&quot;#865-Smallest-Subtree-with-all-the-Deepest-Nodes具有所有最深结点的最小子树&quot; class=&quot;headerlink&quot; title=&quot;865. Smallest Subtree with all the Deepest Nodes具有所有最深结点的最小子树&quot;&gt;&lt;/a&gt;865. Smallest Subtree with all the Deepest Nodes具有所有最深结点的最小子树&lt;/h1&gt;&lt;p&gt;给定一个根为 root 的二叉树，每个结点的深度是它到根的最短距离。&lt;/p&gt;
&lt;p&gt;如果一个结点在整个树的任意结点之间具有最大的深度，则该结点是最深的。&lt;/p&gt;
&lt;p&gt;一个结点的子树是该结点加上它的所有后代的集合。&lt;/p&gt;
&lt;p&gt;返回能满足“以该结点为根的子树中包含所有最深的结点”这一条件的具有最大深度的结点。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>697. Degree of an Array数组的度</title>
    <link href="http://yoursite.com/2018/08/24/697.%20Degree%20of%20an%20Array%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%A6/"/>
    <id>http://yoursite.com/2018/08/24/697. Degree of an Array数组的度/</id>
    <published>2018-08-24T05:36:12.000Z</published>
    <updated>2018-08-24T07:05:54.170Z</updated>
    
    <content type="html"><![CDATA[<h1 id="697-Degree-of-an-Array数组的度"><a href="#697-Degree-of-an-Array数组的度" class="headerlink" title="697. Degree of an Array数组的度"></a>697. Degree of an Array数组的度</h1><p>给定一个非空且只包含非负数的整数数组 nums, 数组的度的定义是指数组里任一元素出现频数的最大值。</p><p>你的任务是找到与 nums 拥有相同大小的度的最短连续子数组，返回其长度。</p><a id="more"></a><p>示例 1:</p><p>输入: </p><pre><code>[1, 2, 2, 3, 1]</code></pre><p>输出: 2<br>解释:<br>输入数组的度是2，因为元素1和2的出现频数最大，均为2.<br>连续子数组里面拥有相同度的有如下所示:</p><pre><code>[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]</code></pre><p>最短连续子数组[2, 2]的长度为2，所以返回2.<br>示例 2:</p><p>输入: </p><pre><code>[1,2,2,3,1,4,2]</code></pre><p>输出: 6<br>注意:</p><p>nums.length 在1到50,000区间范围内。<br>nums[i] 是一个在0到49,999范围内的整数。</p><!-- more --><h2 id="Brute-Force思路"><a href="#Brute-Force思路" class="headerlink" title="Brute Force思路"></a>Brute Force思路</h2><p>穷举所有的子数组然后将其度与原数组的度比较，相等则更新最小长度。但会超时。</p><pre><code>class Solution {public:    int findShortestSubArray(vector&lt;int&gt;&amp; nums) {        int minlen=nums.size();        int degree=getdegree(nums,0,nums.size()-1);        for(int i=0;i&lt;nums.size();i++){            for(int j=i+1;j&lt;nums.size();j++){                if(getdegree(nums,i,j)==degree) minlen=min(minlen,j-i+1);            }        }        return minlen;    }    int getdegree(vector&lt;int&gt;&amp; arr,int begin,int end){        int degree=0;        unordered_map&lt;int,int&gt; fre;        for(int i=begin;i&lt;=end;i++){            fre[arr[i]]++;        }        for(auto d:fre){            degree=max(degree,d.second);        }        return degree;    }};</code></pre><h2 id="O-n-解法"><a href="#O-n-解法" class="headerlink" title="O(n)解法"></a>O(n)解法</h2><p>使用两个哈希表，一个记录字符的开始位置，另一个记录字符的出现频率<br>一旦一个特定字符的频率大于其他的，我们更新这个变量的长度，当两个变量有同样的频率，只比较它们的长度选择较短的一个</p><pre><code>class Solution {public:    int findShortestSubArray(vector&lt;int&gt;&amp; nums) {        unordered_map&lt;int,int&gt; startindex,frequency;        int fre=0,len=nums.size();        for(int i=0;i&lt;nums.size();i++){            frequency[nums[i]]++;            if(startindex.count(nums[i])==0) startindex[nums[i]]=i;//first appear            if(frequency[nums[i]]==fre){//第i个字符的度与截止到当前的数组度相同                len=min(len,i-startindex[nums[i]]+1);            }            else if(frequency[nums[i]]&gt;fre){//需要更新度和长度                fre=frequency[nums[i]];                len=i-startindex[nums[i]]+1;            }        }        return len;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;697-Degree-of-an-Array数组的度&quot;&gt;&lt;a href=&quot;#697-Degree-of-an-Array数组的度&quot; class=&quot;headerlink&quot; title=&quot;697. Degree of an Array数组的度&quot;&gt;&lt;/a&gt;697. Degree of an Array数组的度&lt;/h1&gt;&lt;p&gt;给定一个非空且只包含非负数的整数数组 nums, 数组的度的定义是指数组里任一元素出现频数的最大值。&lt;/p&gt;
&lt;p&gt;你的任务是找到与 nums 拥有相同大小的度的最短连续子数组，返回其长度。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>538. Convert BST to Greater Tree把二叉搜索树转换为累加树</title>
    <link href="http://yoursite.com/2018/08/24/538.%20Convert%20BST%20to%20Greater%20Tree%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/"/>
    <id>http://yoursite.com/2018/08/24/538. Convert BST to Greater Tree把二叉搜索树转换为累加树/</id>
    <published>2018-08-24T05:36:12.000Z</published>
    <updated>2018-08-24T13:02:28.972Z</updated>
    
    <content type="html"><![CDATA[<h1 id="538-Convert-BST-to-Greater-Tree把二叉搜索树转换为累加树"><a href="#538-Convert-BST-to-Greater-Tree把二叉搜索树转换为累加树" class="headerlink" title="538. Convert BST to Greater Tree把二叉搜索树转换为累加树"></a>538. Convert BST to Greater Tree把二叉搜索树转换为累加树</h1><p>给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。</p><a id="more"></a><p>例如：</p><p>输入: 二叉搜索树:<br>              5<br>            /   \<br>           2     13</p><p>输出: 转换为累加树:<br>             18<br>            /   \<br>          20     13</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>二叉搜索树有一个重要的性质，就是中序遍历序列是非递减的<br>解法是一种中序遍历的镜像遍历方法，先用遍历右子树，再改变根节点的值,将其改为所有右子树结点之和，遍历左子树</p><pre><code>class Solution {private:    int cur_sum = 0;public:    void travel(TreeNode* root){        if (!root) return;        if (root-&gt;right) travel(root-&gt;right);        root-&gt;val = (cur_sum += root-&gt;val);        if (root-&gt;left) travel(root-&gt;left);    }    TreeNode* convertBST(TreeNode* root) {        travel(root);        return root;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;538-Convert-BST-to-Greater-Tree把二叉搜索树转换为累加树&quot;&gt;&lt;a href=&quot;#538-Convert-BST-to-Greater-Tree把二叉搜索树转换为累加树&quot; class=&quot;headerlink&quot; title=&quot;538. Convert BST to Greater Tree把二叉搜索树转换为累加树&quot;&gt;&lt;/a&gt;538. Convert BST to Greater Tree把二叉搜索树转换为累加树&lt;/h1&gt;&lt;p&gt;给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Binary Search Tree" scheme="http://yoursite.com/tags/Binary-Search-Tree/"/>
    
  </entry>
  
  <entry>
    <title>485. Max Consecutive Ones最大连续1的个数</title>
    <link href="http://yoursite.com/2018/08/24/485.%20Max%20Consecutive%20Ones/"/>
    <id>http://yoursite.com/2018/08/24/485. Max Consecutive Ones/</id>
    <published>2018-08-24T05:36:12.000Z</published>
    <updated>2018-08-24T07:05:48.492Z</updated>
    
    <content type="html"><![CDATA[<h1 id="485-Max-Consecutive-Ones最大连续1的个数"><a href="#485-Max-Consecutive-Ones最大连续1的个数" class="headerlink" title="485. Max Consecutive Ones最大连续1的个数"></a>485. Max Consecutive Ones最大连续1的个数</h1><p>给定一个二进制数组， 计算其中最大连续1的个数。</p><a id="more"></a><p>示例 1:</p><p>输入: </p><pre><code>[1,1,0,1,1,1]</code></pre><p>输出: 3<br>解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3.<br>注意：</p><p>输入的数组只包含 0 和1。<br>输入数组的长度是正整数，且不超过 10,000。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>定义局部最大和全局最大</p><pre><code>class Solution {public:    int findMaxConsecutiveOnes(vector&lt;int&gt;&amp; nums) {        int maxlen=0,locallen=0;        for(auto n:nums){            if((n&amp;1)==0) locallen=0;            else {                locallen++;                maxlen=max(maxlen,locallen);            }        }        return maxlen;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;485-Max-Consecutive-Ones最大连续1的个数&quot;&gt;&lt;a href=&quot;#485-Max-Consecutive-Ones最大连续1的个数&quot; class=&quot;headerlink&quot; title=&quot;485. Max Consecutive Ones最大连续1的个数&quot;&gt;&lt;/a&gt;485. Max Consecutive Ones最大连续1的个数&lt;/h1&gt;&lt;p&gt;给定一个二进制数组， 计算其中最大连续1的个数。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>885. Spiral Matrix III螺旋矩阵 III</title>
    <link href="http://yoursite.com/2018/08/24/885.%20Spiral%20Matrix%20III/"/>
    <id>http://yoursite.com/2018/08/24/885. Spiral Matrix III/</id>
    <published>2018-08-24T02:32:12.000Z</published>
    <updated>2018-08-24T12:53:30.507Z</updated>
    
    <content type="html"><![CDATA[<h1 id="885-Spiral-Matrix-III螺旋矩阵-III"><a href="#885-Spiral-Matrix-III螺旋矩阵-III" class="headerlink" title="885. Spiral Matrix III螺旋矩阵 III"></a>885. Spiral Matrix III螺旋矩阵 III</h1><p>在 R 行 C 列的矩阵上，我们从 (r0, c0) 面朝东面开始</p><p>这里，网格的西北角位于第一行第一列，网格的东南角位于最后一行最后一列。</p><p>现在，我们以顺时针按螺旋状行走，访问此网格中的每个位置。</p><p>每当我们移动到网格的边界之外时，我们会继续在网格之外行走（但稍后可能会返回到网格边界）。</p><p>最终，我们到过网格的所有 R * C 个空间。</p><p>按照访问顺序返回表示网格位置的坐标列表。</p><a id="more"></a><p>示例 1：</p><pre><code>输入：R = 1, C = 4, r0 = 0, c0 = 0输出：[[0,0],[0,1],[0,2],[0,3]]</code></pre><p><img src="https://ws1.sinaimg.cn/large/0071ouepgy1ful2oluezbj304u02rglf.jpg" alt="image"></p><p>示例 2：</p><pre><code>输入：R = 5, C = 6, r0 = 1, c0 = 4输出：[[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]</code></pre><p><img src="https://ws1.sinaimg.cn/large/0071ouepgy1ful2oluezbj304u02rglf.jpg" alt="image"></p><p>提示：</p><p>1 &lt;= R &lt;= 100<br>1 &lt;= C &lt;= 100<br>0 &lt;= r0 &lt; R<br>0 &lt;= c0 &lt; C</p><h2 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h2><p>分步走，如果位置在格子内则将它加入res</p><p>观察运动轨迹：<br>右移一步，向右转<br>下移一步，向右转</p><p>左移两步，向右转<br>上移两步，向右转</p><p>右移三步，向右转<br>下移三步，向右转</p><p>左移四步，向右转<br>上移四步，向右转</p><p>所以问题变为如何生成序列：1，1，2，2，3，3，4，4，5，5…<br>和如何向右转</p><p>生成序列：<br>a[index]=index/2+1</p><p>右转：<br>使用叉乘假设当前的方向在平面中是（x,y),在空间中则为(x,y,0)<br>那么右转后的方向是(x,y,0)X(0,0,1)=(y,-x,0)<br>变成代码：temp=x;x=y;y=-temp;</p><p>方向数组是：<br>(0,1),(1,0),(0,-1),(-1,0)，可以用两个变量来表示</p><p>时间复杂度：<br>O(max(M,N) ^ 2)</p><pre><code>vector&lt;vector&lt;int&gt;&gt; spiralMatrixIII(int R, int C, int r, int c) {    vector&lt;vector&lt;int&gt;&gt; res = {{r, c}};    int x = 0, y = 1, tmp;    for (int n = 0; res.size() &lt; R * C; n++) {//every position        for (int i = 0; i &lt; n / 2 + 1; i++) {//on one direction            r += x, c += y;            if (0 &lt;= r &amp;&amp; r &lt; R &amp;&amp; 0 &lt;= c &amp;&amp; c &lt; C)                res.push_back({r, c});        }        tmp = x, x = y, y = -tmp;    }    return res;}</code></pre><h2 id="思路2："><a href="#思路2：" class="headerlink" title="思路2："></a>思路2：</h2><pre><code>class Solution {public:    vector&lt;vector&lt;int&gt;&gt; spiralMatrixIII(int R, int C, int r0, int c0) {        int rpos=r0,cpos=c0,dir=0,go=1;//dir is the direction in the dr[4] and dc[4]        int distan=0,total=0;        int dr[4]={0,1,0,-1};        int dc[4]={1,0,-1,0};        vector&lt;vector&lt;int&gt;&gt; res;        res.push_back({rpos,cpos});//push back the start position        total++;        while(total&lt;R*C){//total is the total visit numbers            for(int i=1;i&lt;=go;i++){                rpos+=dr[dir];//start to go                cpos+=dc[dir];                if(rpos&gt;=0 &amp;&amp; rpos&lt;R &amp;&amp; cpos&gt;=0 &amp;&amp; cpos&lt;C){// push back the eanswer if it is in the grid                    res.push_back({rpos,cpos});                    total++;                }            }            if(distan &amp;1){//每隔两次访问步数加1，即恰好为奇数时访问步数加1                go++;            }            distan++;            dir++;            dir%=4;//change direction        }        return res;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;885-Spiral-Matrix-III螺旋矩阵-III&quot;&gt;&lt;a href=&quot;#885-Spiral-Matrix-III螺旋矩阵-III&quot; class=&quot;headerlink&quot; title=&quot;885. Spiral Matrix III螺旋矩阵 III&quot;&gt;&lt;/a&gt;885. Spiral Matrix III螺旋矩阵 III&lt;/h1&gt;&lt;p&gt;在 R 行 C 列的矩阵上，我们从 (r0, c0) 面朝东面开始&lt;/p&gt;
&lt;p&gt;这里，网格的西北角位于第一行第一列，网格的东南角位于最后一行最后一列。&lt;/p&gt;
&lt;p&gt;现在，我们以顺时针按螺旋状行走，访问此网格中的每个位置。&lt;/p&gt;
&lt;p&gt;每当我们移动到网格的边界之外时，我们会继续在网格之外行走（但稍后可能会返回到网格边界）。&lt;/p&gt;
&lt;p&gt;最终，我们到过网格的所有 R * C 个空间。&lt;/p&gt;
&lt;p&gt;按照访问顺序返回表示网格位置的坐标列表。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>20.PrintMatrix顺时针打印矩阵(CodingInterview)</title>
    <link href="http://yoursite.com/2018/08/24/%E5%89%91%E6%8C%87Offer20.%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"/>
    <id>http://yoursite.com/2018/08/24/剑指Offer20.顺时针打印矩阵/</id>
    <published>2018-08-24T01:35:00.000Z</published>
    <updated>2018-08-24T01:35:58.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="20-PrintMatrix顺时针打印矩阵-CodingInterview"><a href="#20-PrintMatrix顺时针打印矩阵-CodingInterview" class="headerlink" title="20.PrintMatrix顺时针打印矩阵(CodingInterview)"></a>20.PrintMatrix顺时针打印矩阵(CodingInterview)</h1><p>与其类似的一道题是LeetCode上的54. Spiral Matrix</p><p>题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><a id="more"></a><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>设矩阵的行数为row，列数为col，以一个5X5的矩阵为例，第一圈左上角坐标为（0，0），第二圈左上角坐标为（1，1），行列坐标相同，因此选取（start，start）作为起点。</p><p>最后一圈只有一个数字，对应坐标为（2，2）。注意到5&gt;2<em>2。对于6X6的矩阵6&gt;2</em>2仍然成立。因此可以得到让循环继续的条件是</p><pre><code>col&gt;start*2 &amp;&amp; row&gt;start*2</code></pre><p>可以解释为因为矩阵是对称的，所以为了能完整打印一圈startX和startY不会超出行列数的一半</p><p>考虑如何实现打印一圈的功能，可以分为向右-&gt;向下-&gt;向上-&gt;向左四步，值得注意的是最后一圈可能退化成只有一行，一列或一个数字，因此此时打印一圈就不需要四步，而缩减为三步、两步、一步。<br>所以要分析打印每一步的前提条件。</p><p>打印第一步时候不需要前提条件</p><p>打印第二步时至少需要有两行，endY&gt;startY</p><p>打印第三步时除了至少需要有两行还至少需要有两列 endY&gt;startY &amp;&amp; endX&gt;startX</p><p>打印第四步时至少需要三行两列 endY&gt;startY+1 &amp;&amp; endX&gt;startX</p><p>与此同时还要注意每一步的起始位置不要与上一步重合</p><pre><code>//==================================================================// 《剑指Offer——名企面试官精讲典型编程题》代码// 面试题29：顺时针打印矩阵// 题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。#include &lt;cstdio&gt;void PrintMatrixInCircle(int** numbers, int columns, int rows, int start);void printNumber(int number);void PrintMatrixClockwisely(int** numbers, int columns, int rows){    if (numbers == nullptr || columns &lt;= 0 || rows &lt;= 0)        return;    int start = 0;    while (columns &gt; start * 2 &amp;&amp; rows &gt; start * 2)    {        PrintMatrixInCircle(numbers, columns, rows, start);        ++start;    }}void PrintMatrixInCircle(int** numbers, int columns, int rows, int start){    int endX = columns - 1 - start;    int endY = rows - 1 - start;    // 从左到右打印一行    for (int i = start; i &lt;= endX; ++i)    {        int number = numbers[start][i];        printNumber(number);    }    // 从上到下打印一列    if (start &lt; endY)    {        for (int i = start + 1; i &lt;= endY; ++i)        {            int number = numbers[i][endX];            printNumber(number);        }    }    // 从右到左打印一行    if (start &lt; endX &amp;&amp; start &lt; endY)    {        for (int i = endX - 1; i &gt;= start; --i)        {            int number = numbers[endY][i];            printNumber(number);        }    }    // 从下到上打印一行    if (start &lt; endX &amp;&amp; start &lt; endY - 1)    {        for (int i = endY - 1; i &gt;= start + 1; --i)        {            int number = numbers[i][start];            printNumber(number);        }    }}void printNumber(int number){    printf(&quot;%d\t&quot;, number);}// ====================测试代码====================void Test(int columns, int rows){    printf(&quot;Test Begin: %d columns, %d rows.\n&quot;, columns, rows);    if (columns &lt; 1 || rows &lt; 1)        return;    int** numbers = new int*[rows];    for (int i = 0; i &lt; rows; ++i)    {        numbers[i] = new int[columns];        for (int j = 0; j &lt; columns; ++j)        {            numbers[i][j] = i * columns + j + 1;        }    }    PrintMatrixClockwisely(numbers, columns, rows);    printf(&quot;\n&quot;);    for (int i = 0; i &lt; rows; ++i)        delete[](int*)numbers[i];    delete[] numbers;}int main(int argc, char* argv[]){    /*    1    */    Test(1, 1);    /*    1    2    3    4    */    Test(2, 2);    /*    1    2    3    4    5    6    7    8    9    10   11   12    13   14   15   16    */    Test(4, 4);    /*    1    2    3    4    5    6    7    8    9    10    11   12   13   14   15    16   17   18   19   20    21   22   23   24   25    */    Test(5, 5);    /*    1    2    3    4    5    */    Test(1, 5);    /*    1    2    3    4    5    6    7    8    9    10    */    Test(2, 5);    /*    1    2    3    4    5    6    7    8    9    10   11   12    13   14   15    */    Test(3, 5);    /*    1    2    3    4    5    6    7    8    9    10   11   12    13   14   15   16    17   18   19   20    */    Test(4, 5);    /*    1    2    3    4    5    */    Test(5, 1);    /*    1    2    3    4    5    6    7    8    9    10    */    Test(5, 2);    /*    1    2    3    4    5    6    7    8    9    10    11   12   13   14    15    */    Test(5, 3);    /*    1    2    3    4    5    6    7    8    9    10    11   12   13   14   15    16   17   18   19   20    */    Test(5, 4);    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;20-PrintMatrix顺时针打印矩阵-CodingInterview&quot;&gt;&lt;a href=&quot;#20-PrintMatrix顺时针打印矩阵-CodingInterview&quot; class=&quot;headerlink&quot; title=&quot;20.PrintMatrix顺时针打印矩阵(CodingInterview)&quot;&gt;&lt;/a&gt;20.PrintMatrix顺时针打印矩阵(CodingInterview)&lt;/h1&gt;&lt;p&gt;与其类似的一道题是LeetCode上的54. Spiral Matrix&lt;/p&gt;
&lt;p&gt;题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Coding Interviews" scheme="http://yoursite.com/tags/Coding-Interviews/"/>
    
  </entry>
  
  <entry>
    <title>650. 2 Keys Keyboard只有两个键的键盘</title>
    <link href="http://yoursite.com/2018/08/24/650.%202%20Keys%20Keyboard%E5%8F%AA%E6%9C%89%E4%B8%A4%E4%B8%AA%E9%94%AE%E7%9A%84%E9%94%AE%E7%9B%98/"/>
    <id>http://yoursite.com/2018/08/24/650. 2 Keys Keyboard只有两个键的键盘/</id>
    <published>2018-08-24T01:30:12.000Z</published>
    <updated>2018-08-26T11:12:29.003Z</updated>
    
    <content type="html"><![CDATA[<h1 id="650-2-Keys-Keyboard只有两个键的键盘"><a href="#650-2-Keys-Keyboard只有两个键的键盘" class="headerlink" title="650. 2 Keys Keyboard只有两个键的键盘"></a>650. 2 Keys Keyboard只有两个键的键盘</h1><p>最初在一个记事本上只有一个字符 ‘A’。你每次可以对这个记事本进行两种操作：</p><p>Copy All (复制全部) : 你可以复制这个记事本中的所有字符(部分的复制是不允许的)。<br>Paste (粘贴) : 你可以粘贴你上一次复制的字符。<br>给定一个数字 n 。你需要使用最少的操作次数，在记事本中打印出恰好 n 个 ‘A’。输出能够打印出 n 个 ‘A’ 的最少操作次数。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: 3输出: 3解释:最初, 我们只有一个字符 &apos;A&apos;。第 1 步, 我们使用 Copy All 操作。第 2 步, 我们使用 Paste 操作来获得 &apos;AA&apos;。第 3 步, 我们使用 Paste 操作来获得 &apos;AAA&apos;。</code></pre><p>说明:</p><pre><code>n 的取值范围是 [1, 1000] 。</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>其实这道题就是将N分解为M个数字的乘积，且M个数字的和最小</p><p>我们寻找一个因子d使得我们能够做d次拷贝（n/d）来得到n</p><p>做d次拷贝需要采取d步（第一步全部复制，d-1次粘贴）</p><p>我们需要通过循环来找到这个d</p><p>时间复杂度评估：<br>最好的情况下O（log(n)) ，例如n=1024时需要十次迭代<br>最差情况下当n为一些大的质数的乘积</p><pre><code>public int minSteps(int n) {       int s = 0;       for (int d = 2; d &lt;= n; d++) {           while (n % d == 0) {               s += d;               n /= d;           }       }       return s;   }</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;650-2-Keys-Keyboard只有两个键的键盘&quot;&gt;&lt;a href=&quot;#650-2-Keys-Keyboard只有两个键的键盘&quot; class=&quot;headerlink&quot; title=&quot;650. 2 Keys Keyboard只有两个键的键盘&quot;&gt;&lt;/a&gt;650. 2 Keys Keyboard只有两个键的键盘&lt;/h1&gt;&lt;p&gt;最初在一个记事本上只有一个字符 ‘A’。你每次可以对这个记事本进行两种操作：&lt;/p&gt;
&lt;p&gt;Copy All (复制全部) : 你可以复制这个记事本中的所有字符(部分的复制是不允许的)。&lt;br&gt;Paste (粘贴) : 你可以粘贴你上一次复制的字符。&lt;br&gt;给定一个数字 n 。你需要使用最少的操作次数，在记事本中打印出恰好 n 个 ‘A’。输出能够打印出 n 个 ‘A’ 的最少操作次数。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>59. Spiral Matrix II螺旋矩阵 II</title>
    <link href="http://yoursite.com/2018/08/24/59.%20Spiral%20Matrix%20II%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%20II/"/>
    <id>http://yoursite.com/2018/08/24/59. Spiral Matrix II螺旋矩阵 II/</id>
    <published>2018-08-24T01:30:12.000Z</published>
    <updated>2018-08-24T07:09:48.754Z</updated>
    
    <content type="html"><![CDATA[<h1 id="59-Spiral-Matrix-II螺旋矩阵-II"><a href="#59-Spiral-Matrix-II螺旋矩阵-II" class="headerlink" title="59. Spiral Matrix II螺旋矩阵 II"></a>59. Spiral Matrix II螺旋矩阵 II</h1><p>给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p><a id="more"></a><p>示例:</p><p>输入: 3<br>输出:</p><pre><code>[ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ]]</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>此题可以参见剑指Offer20.PrintMatrix顺时针打印矩阵(CodingInterview)和54. Spiral Matrix螺旋矩阵</p><p>所不同的是可以先生成一个n*n规模的矩阵然后螺旋将数字填入，时间复杂度是O(n^2)。</p><pre><code>class Solution {public:    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) {        vector&lt;vector&lt;int&gt;&gt; res(n,vector&lt;int&gt;(n,0));        int start=0;        int num=1;        while(start*2&lt;n){            generate(res,start,num,n);            start++;        }        return res;    }    void generate(vector&lt;vector&lt;int&gt;&gt; &amp;res,int start,int &amp;num,int n){        int endy=n-start-1;        int endx=n-start-1;        for(int j=start;j&lt;=endy;j++){            res[start][j]=num;            num++;        }        for(int i=start+1;i&lt;=endx;i++){            res[i][endy]=num;            num++;        }        for(int j=endy-1;j&gt;=start;j--){            res[endx][j]=num;            num++;        }        for(int i=endx-1;i&gt;start;i--){            res[i][start]=num;            num++;        }    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;59-Spiral-Matrix-II螺旋矩阵-II&quot;&gt;&lt;a href=&quot;#59-Spiral-Matrix-II螺旋矩阵-II&quot; class=&quot;headerlink&quot; title=&quot;59. Spiral Matrix II螺旋矩阵 II&quot;&gt;&lt;/a&gt;59. Spiral Matrix II螺旋矩阵 II&lt;/h1&gt;&lt;p&gt;给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>在浏览器地址栏输入URL，按下回车后发生了什么</title>
    <link href="http://yoursite.com/2018/08/23/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5URL%EF%BC%8C%E6%8C%89%E4%B8%8B%E5%9B%9E%E8%BD%A6%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>http://yoursite.com/2018/08/23/在浏览器地址栏输入URL，按下回车后发生了什么/</id>
    <published>2018-08-23T01:06:12.000Z</published>
    <updated>2018-08-23T01:30:21.787Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在浏览器地址栏输入URL，按下回车后发生了什么"><a href="#在浏览器地址栏输入URL，按下回车后发生了什么" class="headerlink" title="在浏览器地址栏输入URL，按下回车后发生了什么"></a>在浏览器地址栏输入URL，按下回车后发生了什么</h1><p>这道题目没有所谓的完全的正确答案，这个题目可以让你在任意的一个点深入下去， 只要你对这个点是熟悉的。以下是一个大概流程：</p><a id="more"></a><h2 id="解答1："><a href="#解答1：" class="headerlink" title="解答1："></a>解答1：</h2><h3 id="1-浏览器向DNS服务器查找输入URL对应的IP地址。"><a href="#1-浏览器向DNS服务器查找输入URL对应的IP地址。" class="headerlink" title="1.浏览器向DNS服务器查找输入URL对应的IP地址。"></a>1.浏览器向DNS服务器查找输入URL对应的IP地址。</h3><h3 id="2-DNS服务器返回网站的IP地址。"><a href="#2-DNS服务器返回网站的IP地址。" class="headerlink" title="2.DNS服务器返回网站的IP地址。"></a>2.DNS服务器返回网站的IP地址。</h3><h3 id="3-浏览器根据IP地址与目标web服务器在80端口上建立TCP连接"><a href="#3-浏览器根据IP地址与目标web服务器在80端口上建立TCP连接" class="headerlink" title="3.浏览器根据IP地址与目标web服务器在80端口上建立TCP连接"></a>3.浏览器根据IP地址与目标web服务器在80端口上建立TCP连接</h3><h3 id="4-浏览器获取请求页面的html代码。"><a href="#4-浏览器获取请求页面的html代码。" class="headerlink" title="4.浏览器获取请求页面的html代码。"></a>4.浏览器获取请求页面的html代码。</h3><h3 id="5-浏览器在显示窗口内渲染HTML。"><a href="#5-浏览器在显示窗口内渲染HTML。" class="headerlink" title="5.浏览器在显示窗口内渲染HTML。"></a>5.浏览器在显示窗口内渲染HTML。</h3><h3 id="6-窗口关闭时，浏览器终止与服务器的连接。"><a href="#6-窗口关闭时，浏览器终止与服务器的连接。" class="headerlink" title="6.窗口关闭时，浏览器终止与服务器的连接。"></a>6.窗口关闭时，浏览器终止与服务器的连接。</h3><p>这其中最有趣的是第1步和第2步(域名解析)。我们输入的网址(域名)是IP地址的一个别名， 在一个DNS内，一个域名对应一个IP地址。域名系统(DNS) 的工作就是将域名与它的IP地址对应起来。DNS是分布式的，同时也是具有层级关系的。</p><h2 id="解答2："><a href="#解答2：" class="headerlink" title="解答2："></a>解答2：</h2><p>当我们用浏览器访问一个网页时，浏览器先尝试从Host文件中获取 <a href="http://www.baidu.com/对应的IP地址，如何不能取到就是用DNS协议来获取IP。在DNS协议中PC会向你的本地DNS服务器求助（一般是路由器），希望从本地DNS服务器那里得到百度的IP，如果得不到本地DNS服务器会向更高层次的DNS服务器求助.......,最终总能得到百度的IP。" target="_blank" rel="noopener">http://www.baidu.com/对应的IP地址，如何不能取到就是用DNS协议来获取IP。在DNS协议中PC会向你的本地DNS服务器求助（一般是路由器），希望从本地DNS服务器那里得到百度的IP，如果得不到本地DNS服务器会向更高层次的DNS服务器求助.......,最终总能得到百度的IP。</a></p><p>得到百度的IP，下一步使用TCP协议，建立TCP连接。在TCP协议中建立TCP需要与百度服务器握手三次，你先告诉服务器你要给服务器发东西（SYN），服务器应答你并告诉你它也要给你发东西（SYN，ACK），然后你向应答服务器（SYN，ACK）做出应答，总共来回了三次，成为3次握手。不过，建立TCP连接有个前提，你必须能够成功地把消息发到服务器上。</p><p>为了将消息从你的PC上传到服务器上，需要用到IP协议、ARP协议和OSPF协议。我们都知道，你的PC和百度服务器之间一般会有许多路由器之类的东西，IP协议指定了出发地和目的地；你的数据会经过一个又一个路由器，OSPF决定了会经过哪些路由器（用一种路由算法，找出最佳路径）从一个路由器怎么传给下一个路由器，这是ARP协议的工作，ARP负责求下一个节点的地址。IP协议使用的是IP地址，整个发送过程中只涉及出发地和目的地2个IP地址，而ARP协议使用的是MAC地址，整个发送过程中涉及到每一个节点的MAC地址。</p><p>现在，我们能和服务器通信，还建立TCP连接，下一步就是用HTTP协议请求网页内容了。你发个http请求报文给服务器，如果服务器禁止你访问就给你回个“forbidden”，如果他暂时挂掉了就给你回个“内部服务错误”，如果它正常才给你回个“OK”，并将你要的数据传给你；如果你有其他需要的东西再去给他要。你收到了服务器的回复，是一坨html的文本，浏览器必须能够理解文本的内容，并快速的渲染到屏幕上。渲染出来后，就可以看到网页了。</p><h2 id="解答3"><a href="#解答3" class="headerlink" title="解答3"></a>解答3</h2><h3 id="基本流程："><a href="#基本流程：" class="headerlink" title="基本流程："></a>基本流程：</h3><p>①查询ip地址</p><p>②建立tcp连接，接入服务器</p><p>③浏览器发起http请求</p><p>④服务器后台操作并做出http响应</p><p>⑤网页的解析与渲染</p><h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><p>查询ip地址<br>①浏览器解析出url中的域名。</p><p>②查询浏览器的DNS缓存。</p><p>③浏览器中没有DNS缓存，则查找本地客户端hosts文件有无对应的ip地址。</p><p>④hosts中无，则查找本地DNS服务器（运营商提供的DNS服务器）有无对应的DNS缓存。</p><p>⑤若本地DNS没有DNS缓存，则向根服务器查询，进行递归查找。</p><p>⑥递归查找从顶级域名开始（如.com）,一步步缩小范围，最终客户端取得ip地址。</p><p>tcp连接与http连接<br>①http协议建立在tcp协议之上，http请求前，需先进行tcp连接，形成客户端到服务器的稳定的通道。俗称TCP的三次握手。</p><p>②tcp连接完成后，http请求开始，请求有多种方式，常见的有get，post等。</p><p>③http请求包含请求头，也可能包含请求体两部分，请求头中包含我们希望对请求文件的操作的信息，请求体中包含传递给后台的参数。</p><p>④服务器收到http请求后，后台开始工作，如负载平衡，跨域等，这里就是后端的工作了。</p><p>⑤文件处理完毕，生成响应数据包，响应也包含两部分，响应头和相应体，响应体就是我们所请求的文件。</p><p>⑥经过网络传输，文件被下载到本地客户端，客户端开始加载。</p><p>html渲染<br>①客户端浏览器加载了html文件后，由上到下解析html为DOM树（DOM Tree）。</p><p>②遇到css文件，css中的url发起http请求。</p><p>③这是第二次http请求，由于http1.1协议增加了Connection: keep-alive声明，故tcp连接不会关闭，可以复用。</p><p>④http连接是无状态连接，客户端与服务器端需要重新发起请求–响应。</p><p>在请求css的过程中，解析器继续解析html，然后到了script标签。</p><p>⑤由于script可能会改变DOM结构，故解析器停止生成DOM树，解析器被js阻塞，等待js文件发起http请求，然后加载。这是第三次http请求。js执行完成后解析器继续解析。</p><p>⑥由于css文件可能会影响js文件的执行结果，因此需等css文件加载完成后再执行。</p><p>⑦浏览器收到css文件后，开始解析css文件为CSSOM树（CSS Rule Tree）。</p><p>⑧CSSOM树生成后，DOM Tree与CSS Rule Tree结合生成渲染树（Render Tree）。</p><p>⑨Render Tree会被css文件阻塞，渲染树生成后，先布局，绘制渲染树中节点的属性(位置，宽度，大小等)，然后渲染，页面就会呈现信息。</p><p>⑩继续边解析边渲染，遇到了另一个js文件，js文件执行后改变了DOM树，渲染树从被改变的dom开始再次渲染。</p><p>⑪继续向下渲染，碰到一个img标签，浏览器发起http请求，不会等待img加载完成，继续向下渲染，之后再重新渲染此部分。</p><p>⑫DOM树遇到html结束标签，停止解析，进而渲染结束。</p><h3 id="扩展思考"><a href="#扩展思考" class="headerlink" title="扩展思考"></a>扩展思考</h3><p>有那些网站优化的方法？<br>①减少DNS查询:将服务器域名的ip信息加入本地host文件。</p><p>②减少http请求数量，对于图片使用雪碧图,对于html文件和css文件，js文件分别进行合并操作。</p><p>③减少下载时间：压缩图片，使用压缩应用压缩文档中的空格，删除文件多余的语句和注释，创造自己的js精简库和精简框架,使用本地浏览器缓存。</p><p>④提前渲染开始时间：将css链接放在html头部。</p><p>⑤减轻解析器的阻塞：将js链接放在body尾部</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;在浏览器地址栏输入URL，按下回车后发生了什么&quot;&gt;&lt;a href=&quot;#在浏览器地址栏输入URL，按下回车后发生了什么&quot; class=&quot;headerlink&quot; title=&quot;在浏览器地址栏输入URL，按下回车后发生了什么&quot;&gt;&lt;/a&gt;在浏览器地址栏输入URL，按下回车后发生了什么&lt;/h1&gt;&lt;p&gt;这道题目没有所谓的完全的正确答案，这个题目可以让你在任意的一个点深入下去， 只要你对这个点是熟悉的。以下是一个大概流程：&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="TCPIP" scheme="http://yoursite.com/tags/TCPIP/"/>
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>59.SymmetricalBinaryTree对称的二叉树(CodingInterview)</title>
    <link href="http://yoursite.com/2018/08/23/%E5%89%91%E6%8C%87Offer59.%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2018/08/23/剑指Offer59.对称的二叉树/</id>
    <published>2018-08-23T00:45:12.000Z</published>
    <updated>2018-08-24T02:04:28.134Z</updated>
    
    <content type="html"><![CDATA[<h1 id="59-SymmetricalBinaryTree对称的二叉树-CodingInterview"><a href="#59-SymmetricalBinaryTree对称的二叉树-CodingInterview" class="headerlink" title="59.SymmetricalBinaryTree对称的二叉树(CodingInterview)"></a>59.SymmetricalBinaryTree对称的二叉树(CodingInterview)</h1><p>与其类似的一道题是LeetCode上的101. Symmetric Tree</p><p>请实现一个函数，用来判断一颗二叉树是不是对称的。<br>注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p><a id="more"></a><h2 id="Recursive递归解法："><a href="#Recursive递归解法：" class="headerlink" title="Recursive递归解法："></a>Recursive递归解法：</h2><p>定义一种对称的前序遍历算法，即先遍历父节点，再遍历它的右子节点，最后遍历它的左子节点。</p><p>可以通过对比二叉树的前序遍历序列和对称前序遍历序列来判断二叉树是不是对称的。如果两个序列是一样的那么二叉树是对称的。</p><pre><code>bool isSymmetrical(BinaryTreeNode* pRoot1, BinaryTreeNode* pRoot2);bool isSymmetrical(BinaryTreeNode* pRoot){    return isSymmetrical(pRoot, pRoot);}bool isSymmetrical(BinaryTreeNode* pRoot1, BinaryTreeNode* pRoot2){    if (pRoot1 == NULL &amp;&amp; pRoot2 == NULL) return true;    else if (pRoot1 == NULL || pRoot2 == NULL) return false;    else if (pRoot1-&gt;m_nValue != pRoot2-&gt;m_nValue) return false;    return isSymmetrical(pRoot1-&gt;m_pLeft, pRoot2-&gt;m_pRight) &amp;&amp; isSymmetrical(pRoot2-&gt;m_pRight, pRoot1-&gt;m_pLeft);}</code></pre><h2 id="Non-Recursive-use-queue-非递归解法"><a href="#Non-Recursive-use-queue-非递归解法" class="headerlink" title="Non-Recursive(use queue)非递归解法:"></a>Non-Recursive(use queue)非递归解法:</h2><p>使用队列进行层次遍历，当队列非空的时候对队列中的结点进行判断，再每次将下一层的所有节点按照对称的顺序入队</p><pre><code>#include&lt;iostream&gt;#include &lt;cstdio&gt;#include &quot;BinaryTree.h&quot;using namespace std;bool isSymmetrical(BinaryTreeNode* pRoot){    if (pRoot == NULL) return true;    queue&lt;BinaryTreeNode*&gt; queue;    queue.push(pRoot-&gt;m_pLeft);    queue.push(pRoot-&gt;m_pRight);    while (!queue.empty())    {        BinaryTreeNode *left = queue.front(); queue.pop();        BinaryTreeNode *right = queue.front(); queue.pop();        if (!left &amp;&amp; !right) continue;        else if (!left || !right) return false;        else if (left-&gt;m_nValue != right-&gt;m_nValue) return false;        queue.push(left-&gt;m_pLeft);        queue.push(right-&gt;m_pRight);        queue.push(left-&gt;m_pRight);        queue.push(right-&gt;m_pLeft);    }    return true;}// ====================测试代码====================void Test(char* testName, BinaryTreeNode* pRoot, bool expected){    if (testName != nullptr)        printf(&quot;%s begins: &quot;, testName);    if (isSymmetrical(pRoot) == expected)        printf(&quot;Passed.\n&quot;);    else        printf(&quot;FAILED.\n&quot;);}//            8//        6      6//       5 7    7 5void Test1(){    BinaryTreeNode* pNode8 = CreateBinaryTreeNode(8);    BinaryTreeNode* pNode61 = CreateBinaryTreeNode(6);    BinaryTreeNode* pNode62 = CreateBinaryTreeNode(6);    BinaryTreeNode* pNode51 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode71 = CreateBinaryTreeNode(7);    BinaryTreeNode* pNode72 = CreateBinaryTreeNode(7);    BinaryTreeNode* pNode52 = CreateBinaryTreeNode(5);    ConnectTreeNodes(pNode8, pNode61, pNode62);    ConnectTreeNodes(pNode61, pNode51, pNode71);    ConnectTreeNodes(pNode62, pNode72, pNode52);    Test(&quot;Test1&quot;, pNode8, true);    DestroyTree(pNode8);}//            8//        6      9//       5 7    7 5void Test2(){    BinaryTreeNode* pNode8 = CreateBinaryTreeNode(8);    BinaryTreeNode* pNode61 = CreateBinaryTreeNode(6);    BinaryTreeNode* pNode9 = CreateBinaryTreeNode(9);    BinaryTreeNode* pNode51 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode71 = CreateBinaryTreeNode(7);    BinaryTreeNode* pNode72 = CreateBinaryTreeNode(7);    BinaryTreeNode* pNode52 = CreateBinaryTreeNode(5);    ConnectTreeNodes(pNode8, pNode61, pNode9);    ConnectTreeNodes(pNode61, pNode51, pNode71);    ConnectTreeNodes(pNode9, pNode72, pNode52);    Test(&quot;Test2&quot;, pNode8, false);    DestroyTree(pNode8);}//            8//        6      6//       5 7    7void Test3(){    BinaryTreeNode* pNode8 = CreateBinaryTreeNode(8);    BinaryTreeNode* pNode61 = CreateBinaryTreeNode(6);    BinaryTreeNode* pNode62 = CreateBinaryTreeNode(6);    BinaryTreeNode* pNode51 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode71 = CreateBinaryTreeNode(7);    BinaryTreeNode* pNode72 = CreateBinaryTreeNode(7);    ConnectTreeNodes(pNode8, pNode61, pNode62);    ConnectTreeNodes(pNode61, pNode51, pNode71);    ConnectTreeNodes(pNode62, pNode72, nullptr);    Test(&quot;Test3&quot;, pNode8, false);    DestroyTree(pNode8);}//               5//              / \//             3   3//            /     \//           4       4//          /         \//         2           2//        /             \//       1               1void Test4(){    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode31 = CreateBinaryTreeNode(3);    BinaryTreeNode* pNode32 = CreateBinaryTreeNode(3);    BinaryTreeNode* pNode41 = CreateBinaryTreeNode(4);    BinaryTreeNode* pNode42 = CreateBinaryTreeNode(4);    BinaryTreeNode* pNode21 = CreateBinaryTreeNode(2);    BinaryTreeNode* pNode22 = CreateBinaryTreeNode(2);    BinaryTreeNode* pNode11 = CreateBinaryTreeNode(1);    BinaryTreeNode* pNode12 = CreateBinaryTreeNode(1);    ConnectTreeNodes(pNode5, pNode31, pNode32);    ConnectTreeNodes(pNode31, pNode41, nullptr);    ConnectTreeNodes(pNode32, nullptr, pNode42);    ConnectTreeNodes(pNode41, pNode21, nullptr);    ConnectTreeNodes(pNode42, nullptr, pNode22);    ConnectTreeNodes(pNode21, pNode11, nullptr);    ConnectTreeNodes(pNode22, nullptr, pNode12);    Test(&quot;Test4&quot;, pNode5, true);    DestroyTree(pNode5);}//               5//              / \//             3   3//            /     \//           4       4//          /         \//         6           2//        /             \//       1               1void Test5(){    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode31 = CreateBinaryTreeNode(3);    BinaryTreeNode* pNode32 = CreateBinaryTreeNode(3);    BinaryTreeNode* pNode41 = CreateBinaryTreeNode(4);    BinaryTreeNode* pNode42 = CreateBinaryTreeNode(4);    BinaryTreeNode* pNode6 = CreateBinaryTreeNode(6);    BinaryTreeNode* pNode22 = CreateBinaryTreeNode(2);    BinaryTreeNode* pNode11 = CreateBinaryTreeNode(1);    BinaryTreeNode* pNode12 = CreateBinaryTreeNode(1);    ConnectTreeNodes(pNode5, pNode31, pNode32);    ConnectTreeNodes(pNode31, pNode41, nullptr);    ConnectTreeNodes(pNode32, nullptr, pNode42);    ConnectTreeNodes(pNode41, pNode6, nullptr);    ConnectTreeNodes(pNode42, nullptr, pNode22);    ConnectTreeNodes(pNode6, pNode11, nullptr);    ConnectTreeNodes(pNode22, nullptr, pNode12);    Test(&quot;Test5&quot;, pNode5, false);    DestroyTree(pNode5);}//               5//              / \//             3   3//            /     \//           4       4//          /         \//         2           2//                      \//                       1void Test6(){    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode31 = CreateBinaryTreeNode(3);    BinaryTreeNode* pNode32 = CreateBinaryTreeNode(3);    BinaryTreeNode* pNode41 = CreateBinaryTreeNode(4);    BinaryTreeNode* pNode42 = CreateBinaryTreeNode(4);    BinaryTreeNode* pNode21 = CreateBinaryTreeNode(2);    BinaryTreeNode* pNode22 = CreateBinaryTreeNode(2);    BinaryTreeNode* pNode12 = CreateBinaryTreeNode(1);    ConnectTreeNodes(pNode5, pNode31, pNode32);    ConnectTreeNodes(pNode31, pNode41, nullptr);    ConnectTreeNodes(pNode32, nullptr, pNode42);    ConnectTreeNodes(pNode41, pNode21, nullptr);    ConnectTreeNodes(pNode42, nullptr, pNode22);    ConnectTreeNodes(pNode21, nullptr, nullptr);    ConnectTreeNodes(pNode22, nullptr, pNode12);    Test(&quot;Test6&quot;, pNode5, false);    DestroyTree(pNode5);}// 只有一个结点void Test7(){    BinaryTreeNode* pNode1 = CreateBinaryTreeNode(1);    Test(&quot;Test7&quot;, pNode1, true);    DestroyTree(pNode1);}// 没有结点void Test8(){    Test(&quot;Test8&quot;, nullptr, true);}// 所有结点都有相同的值，树对称//               5//              / \//             5   5//            /     \//           5       5//          /         \//         5           5void Test9(){    BinaryTreeNode* pNode1 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode21 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode22 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode31 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode32 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode41 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode42 = CreateBinaryTreeNode(5);    ConnectTreeNodes(pNode1, pNode21, pNode22);    ConnectTreeNodes(pNode21, pNode31, nullptr);    ConnectTreeNodes(pNode22, nullptr, pNode32);    ConnectTreeNodes(pNode31, pNode41, nullptr);    ConnectTreeNodes(pNode32, nullptr, pNode42);    ConnectTreeNodes(pNode41, nullptr, nullptr);    ConnectTreeNodes(pNode42, nullptr, nullptr);    Test(&quot;Test9&quot;, pNode1, true);    DestroyTree(pNode1);}// 所有结点都有相同的值，树不对称//               5//              / \//             5   5//            /     \//           5       5//          /       ///         5       5void Test10(){    BinaryTreeNode* pNode1 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode21 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode22 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode31 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode32 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode41 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode42 = CreateBinaryTreeNode(5);    ConnectTreeNodes(pNode1, pNode21, pNode22);    ConnectTreeNodes(pNode21, pNode31, nullptr);    ConnectTreeNodes(pNode22, nullptr, pNode32);    ConnectTreeNodes(pNode31, pNode41, nullptr);    ConnectTreeNodes(pNode32, pNode42, nullptr);    ConnectTreeNodes(pNode41, nullptr, nullptr);    ConnectTreeNodes(pNode42, nullptr, nullptr);    Test(&quot;Test10&quot;, pNode1, false);    DestroyTree(pNode1);}void main(int argc, char* argv[]){    Test1();    Test2();    Test3();    Test4();    Test5();    Test6();    Test7();    Test8();    Test9();    Test10();}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;59-SymmetricalBinaryTree对称的二叉树-CodingInterview&quot;&gt;&lt;a href=&quot;#59-SymmetricalBinaryTree对称的二叉树-CodingInterview&quot; class=&quot;headerlink&quot; title=&quot;59.SymmetricalBinaryTree对称的二叉树(CodingInterview)&quot;&gt;&lt;/a&gt;59.SymmetricalBinaryTree对称的二叉树(CodingInterview)&lt;/h1&gt;&lt;p&gt;与其类似的一道题是LeetCode上的101. Symmetric Tree&lt;/p&gt;
&lt;p&gt;请实现一个函数，用来判断一颗二叉树是不是对称的。&lt;br&gt;注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Coding Interviews" scheme="http://yoursite.com/tags/Coding-Interviews/"/>
    
      <category term="BinaryTree" scheme="http://yoursite.com/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer思路总结</title>
    <link href="http://yoursite.com/2018/08/23/%E5%89%91%E6%8C%87offer%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/08/23/剑指offer思路总结/</id>
    <published>2018-08-23T00:45:12.000Z</published>
    <updated>2018-08-23T03:26:40.658Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指offer思路总结"><a href="#剑指offer思路总结" class="headerlink" title="剑指offer思路总结"></a>剑指offer思路总结</h1><p>剑指offer已经刷过两遍，总结一下思路方便回忆</p><a id="more"></a><h2 id="13-在O-1-时间删除链表结点"><a href="#13-在O-1-时间删除链表结点" class="headerlink" title="13.在O(1)时间删除链表结点"></a>13.在O(1)时间删除链表结点</h2><pre><code>分情况讨论：先在链表中顺序搜索要删除的节点i不是尾结点：{    先将i的下一个结点j的内容复制到i    然后把i的指针指向结点j的下一个结点；    此时再删除结点j}链表只有一个结点{    则删除该结点    然后将其置为NULL    将头结点置为空}链表有多个结点而且要删除的结点是尾结点{    从头结点顺序遍历，只要找到该结点i的前序结点就可以，然后执行删除操作}</code></pre><h2 id="14-调整数组顺序使奇数位于偶数前面"><a href="#14-调整数组顺序使奇数位于偶数前面" class="headerlink" title="14.调整数组顺序使奇数位于偶数前面"></a>14.调整数组顺序使奇数位于偶数前面</h2><h3 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute Force"></a>Brute Force</h3><p>顺序扫描碰到偶数就将其放到末尾</p><h3 id="初级解法"><a href="#初级解法" class="headerlink" title="初级解法"></a>初级解法</h3><p>双指针指向头尾部分，头偶尾奇则交换两个数字</p><h3 id="可扩展解法"><a href="#可扩展解法" class="headerlink" title="可扩展解法"></a>可扩展解法</h3><p>仍使用头尾指针，但用函数指针的方法将判断奇偶的函数解耦出来，整体逻辑框架不需要改动</p><h2 id="15-链表中倒数第K个节点"><a href="#15-链表中倒数第K个节点" class="headerlink" title="15.链表中倒数第K个节点"></a>15.链表中倒数第K个节点</h2><p>快慢指针，快指针比慢指针领先k-1步出发，快指针到尾节点时慢指针指向的是所求</p><h3 id="举一反三"><a href="#举一反三" class="headerlink" title="举一反三"></a>举一反三</h3><h4 id="1-求链表中间结点"><a href="#1-求链表中间结点" class="headerlink" title="1.求链表中间结点"></a>1.求链表中间结点</h4><p>快慢指针，快指针每次走两步，慢指针每次走一步，快指针到末尾时慢指针指向中间结点</p><h4 id="2-判断单向链表是否成环"><a href="#2-判断单向链表是否成环" class="headerlink" title="2.判断单向链表是否成环"></a>2.判断单向链表是否成环</h4><p>同前面，若快指针追上慢指针则成环</p><h2 id="16-反转链表"><a href="#16-反转链表" class="headerlink" title="16.反转链表"></a>16.反转链表</h2><p>需要定义三个指针，指向当前遍历的结点，前一个结点和后一个结点,先要找到反转链表后的头结点即原始链表的尾节点，需要满足的条件是后结点为空</p><pre><code>////Non-RecursiveListNode* ReverseList(ListNode* pHead){    ListNode* pReversedHead = nullptr;    ListNode* pNode = pHead;    ListNode* pPrev = nullptr;    while (pNode != nullptr)    {        ListNode *pNext = pNode-&gt;m_pNext;        if (pNext == NULL) {//find the last node            pReversedHead = pNode;        }        pNode-&gt;m_pNext = pPrev;//Revserse        pPrev = pNode;// forward        pNode = pNext;    }    return pReversedHead;}ListNode* ReverseList(ListNode* pHead){    if (pHead == NULL || pHead-&gt;m_pNext == nullptr) return pHead;    ListNode *PReverseHead = pHead;    pHead=ReverseList(pHead-&gt;m_pNext);    PReverseHead-&gt;m_pNext-&gt;m_pNext = PReverseHead;//进入尾节点    PReverseHead-&gt;m_pNext = NULL;    return pHead;}</code></pre><h2 id="28-字符串的排列"><a href="#28-字符串的排列" class="headerlink" title="28.字符串的排列"></a>28.字符串的排列</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;剑指offer思路总结&quot;&gt;&lt;a href=&quot;#剑指offer思路总结&quot; class=&quot;headerlink&quot; title=&quot;剑指offer思路总结&quot;&gt;&lt;/a&gt;剑指offer思路总结&lt;/h1&gt;&lt;p&gt;剑指offer已经刷过两遍，总结一下思路方便回忆&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Coding Interviews" scheme="http://yoursite.com/tags/Coding-Interviews/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>300. Longest Increasing Subsequence最长上升子序列</title>
    <link href="http://yoursite.com/2018/08/22/300.%20Longest%20Increasing%20Subsequence%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2018/08/22/300. Longest Increasing Subsequence最长上升子序列/</id>
    <published>2018-08-22T12:30:12.000Z</published>
    <updated>2018-08-24T07:08:41.770Z</updated>
    
    <content type="html"><![CDATA[<h1 id="300-Longest-Increasing-Subsequence最长上升子序列"><a href="#300-Longest-Increasing-Subsequence最长上升子序列" class="headerlink" title="300. Longest Increasing Subsequence最长上升子序列"></a>300. Longest Increasing Subsequence最长上升子序列</h1><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><a id="more"></a><p>示例:</p><p>输入:<br>    [10,9,2,5,3,7,101,18]</p><p>输出: 4 </p><p>解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</p><p>说明:</p><p>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。<br>你算法的时间复杂度应该为 O(n2) 。</p><p>进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?</p><h2 id="动态规划解法："><a href="#动态规划解法：" class="headerlink" title="动态规划解法："></a>动态规划解法：</h2><p>首先来看一种动态规划Dynamic Programming的解法，这种解法的时间复杂度为O(n^2)，类似brute force的解法，我们维护一个一维dp数组，其中dp[i]表示以nums[i]为结尾的最长递增子串的长度，对于每一个nums[i]，我们从第一个数再搜索到i，如果发现某个数小于nums[i]，我们更新dp[i]，更新方法为dp[i] = max(dp[i], dp[j] + 1)，即比较当前dp[i]的值和那个小于num[i]的数的dp值加1的大小，我们就这样不断的更新dp数组，到最后dp数组中最大的值就是我们要返回的LIS的长度，参见代码如下：</p><pre><code>class Solution {public:    int lengthOfLIS(vector&lt;int&gt;&amp; nums) {        vector&lt;int&gt; dp(nums.size(),1);        int res=0;        for(int i=0;i&lt;nums.size();i++){            for(int j=0;j&lt;i;j++){                if(nums[i]&gt;nums[j]){                    dp[i]=max(dp[i],dp[j]+1);                }            }            res=max(res,dp[i]);        }        return res;    }};</code></pre><h2 id="进阶：二分查找法"><a href="#进阶：二分查找法" class="headerlink" title="进阶：二分查找法"></a>进阶：二分查找法</h2><p>我们来看一种思路更清晰的二分查找法，跟上面那种方法很类似，思路是先建立一个空的dp数组，然后开始遍历原数组，对于每一个遍历到的数字，我们用二分查找法在dp数组找第一个不小于它的数字，如果这个数字不存在，那么直接在dp数组后面加上遍历到的数字，如果存在，则将这个数字更新为当前遍历到的数字，最后返回dp数字的长度即可.</p><p>特别注意的是dp数组的值可能不是一个真实的LIS。{4， 2， 4， 5， 3， 7}，那么算完后的ends数组为{2， 3， 5， 7}，可以发现它不是一个原数组的LIS，只是长度相等而已参见代码如下：</p><pre><code>class Solution {public:    int lengthOfLIS(vector&lt;int&gt;&amp; nums) {        vector&lt;int&gt; dp;        for(int i=0;i&lt;nums.size();i++){            int left=0,right=dp.size();            while(left&lt;right){                int mid=left+(right-left)/2;                if(dp[mid]&lt;nums[i]) left=mid+1;                else right=mid;            }            if(right&gt;=dp.size()) dp.push_back(nums[i]);            else dp[right]=nums[i];        }        return dp.size();    }};</code></pre><h2 id="进阶：利用lowerbound函数的二分查找法"><a href="#进阶：利用lowerbound函数的二分查找法" class="headerlink" title="进阶：利用lowerbound函数的二分查找法"></a>进阶：利用lowerbound函数的二分查找法</h2><p>还有一种比较tricky的二分查找法，利用到了C++中STL的lower_bound函数，lower_bound返回数组中第一个不小于指定值的元素，跟上面的算法类似，我们还需要一个一维数组v，然后对于遍历到的nums中每一个元素，找其lower_bound，如果没有lower_bound，说明新元素比一维数组的尾元素还要大，直接添加到数组v中，跟之前解法的思路相同了。如果有lower_bound，说明新元素不是最大的，将其lower_bound替换为新元素，这个过程跟之前解法的二分查找法的部分实现相同功能，最后也是返回数组v的长度，注意数组v也不一定是真实的LIS，参见代码如下：</p><pre><code>class Solution {public:    int lengthOfLIS(vector&lt;int&gt;&amp; nums) {        vector&lt;int&gt; dp;        for(auto n:nums){            auto it=lower_bound(dp.begin(),dp.end(),n);            if(it == dp.end()) dp.push_back(n);            else *it=n;        }        return dp.size();    }};</code></pre><h2 id="进阶：利用upperbound函数的二分查找法"><a href="#进阶：利用upperbound函数的二分查找法" class="headerlink" title="进阶：利用upperbound函数的二分查找法"></a>进阶：利用upperbound函数的二分查找法</h2><p>upper_bound是返回数组中第一个大于指定值的元素，和lower_bound的区别时，它不能返回和指定值相等的元素，那么当新进来的数和数组中尾元素一样大时，upper_bound无法返回这个元素，那么按之前算法的处理方法是加到数组中，这样就不是严格的递增子串了，所以我们要做个处理，在处理每个新进来的元素时，先判断数组v中有无此元素，有的话直接跳过，这样就避免了相同数字的情况，参见代码如下：</p><pre><code>class Solution {public:    int lengthOfLIS(vector&lt;int&gt;&amp; nums) {        vector&lt;int&gt; dp;        for(auto n:nums){            if(find(dp.begin(),dp.end(),n)!=dp.end()) continue;            auto it=upper_bound(dp.begin(),dp.end(),n);            if(it==dp.end()) dp.push_back(n);            else *it=n;        }        return dp.size();    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;300-Longest-Increasing-Subsequence最长上升子序列&quot;&gt;&lt;a href=&quot;#300-Longest-Increasing-Subsequence最长上升子序列&quot; class=&quot;headerlink&quot; title=&quot;300. Longest Increasing Subsequence最长上升子序列&quot;&gt;&lt;/a&gt;300. Longest Increasing Subsequence最长上升子序列&lt;/h1&gt;&lt;p&gt;给定一个无序的整数数组，找到其中最长上升子序列的长度。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>64.StreamMedian数据流中的中位数(Coding Interviews )</title>
    <link href="http://yoursite.com/2018/08/22/%E5%89%91%E6%8C%87Offer64.%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://yoursite.com/2018/08/22/剑指Offer64.数据流中的中位数/</id>
    <published>2018-08-22T01:58:44.000Z</published>
    <updated>2018-08-24T07:08:32.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="64-StreamMedian数据流中的中位数-Coding-Interviews"><a href="#64-StreamMedian数据流中的中位数-Coding-Interviews" class="headerlink" title="64.StreamMedian数据流中的中位数(Coding Interviews )"></a>64.StreamMedian数据流中的中位数(Coding Interviews )</h1><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><a id="more"></a><p>将数据在容器中排序，将整个数据容器分隔成两部分。位于容器左边部分的数据比右边的数据小。中位数可以由两个指针指向的数据得到。如果容器中数据的数目是奇数，那么两个指针指向同一个数据。指针P1指向左边部分最大的数，指针P2指向右边部分最小的数。</p><p>如果能保证数据容器左边的数据都小于右边的数据，即使左右两边内部的数据没有排序，也可以根据左边最大的数及右边最小的数得到中位数。</p><p>使用一个最大堆来实现左边的数据容器，使用最小堆实现右边的数据容器。往堆中插入一个数据的时间效率是O(logn).由于只需要O(1）时间就可以得到位于堆顶的数据，因此得到中位数的时间效率是O(1)。</p><p>为了保证数据平均分配到两个堆中，可以在数据的总数目是偶数时把新数据插入到最小堆中，否则插入到最大堆中。</p><p>还要保证最大堆中里的所有数据都要小于最小堆中的数据。当数据的总数目是偶数时，按照前面的分配规则会把新的数据插入到最小堆中。如果此时这个新的数据比最大堆中的一些数据要小，那么</p><p>首先可以把这个新的数据插入到最大堆中，</p><p>接着把最大堆中的最大的数字拿出来插入到最小堆中。</p><p>由于最终插入到最小堆的数字是原最大堆中最大的数字，这样就保证了最小堆中所有数字都大于最大堆中的数字。</p><h3 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h3><pre><code>#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;functional&gt;using namespace std;template&lt;typename T&gt; class DynamicArray{public:    void Insert(T num)    {        if (((min.size() + max.size()) &amp; 1) == 0) {// even length             if (max.size() &gt; 0 &amp;&amp; num &lt; max[0]) {//new num is lower than  some numbers in the maxheap                max.push_back(num);                push_heap(max.begin(), max.end(), less&lt;T&gt;());// make the max heap                num = max[0];                pop_heap(max.begin(), max.end(), less&lt;T&gt;());                max.pop_heap();            }            min.push_heap(num);            push_heap(min.begin(), min.end(), greater&lt;T&gt;());//make the min heap        }        else {//odd length            if (min.size() &gt; 0 &amp;&amp; min[0] &lt; num) {                min.push_back(num);                push_heap(min, begin(), min.end(), greater&lt;T&gt;());                num = min[0];                pop_heap(min.begin(), min.end(), greater&lt;T&gt;());                min.pop_heap();            }            max.push_back(num);            push_heap(max.begin(), max.end(), less&lt;T&gt;());        }    }    T GetMedian()    {         int size = min.size() + max.size();        if (size == 0) throw exception(&quot;No numbers are available&quot;);        T median = 0;        if ((size &amp; 1) == 1) meidan = min[0];// only has one number        else median = (min[0] + max[0]) / 2;        return median;    }private:    vector&lt;T&gt; min;//min heap    vector&lt;T&gt; max;//max heap};// ==================== Test Code ====================void Test(char* testName, DynamicArray&lt;double&gt;&amp; numbers, double expected){    if(testName != NULL)        printf(&quot;%s begins: &quot;, testName);    if(abs(numbers.GetMedian() - expected) &lt; 0.0000001)        printf(&quot;Passed.\n&quot;);    else        printf(&quot;FAILED.\n&quot;);}int main(int argc, char* argv[]){    DynamicArray&lt;double&gt; numbers;    printf(&quot;Test1 begins: &quot;);    try    {        numbers.GetMedian();        printf(&quot;FAILED.\n&quot;);    }    catch(exception e)    {        printf(&quot;Passed.\n&quot;);    }    numbers.Insert(5);    Test(&quot;Test2&quot;, numbers, 5);    numbers.Insert(2);    Test(&quot;Test3&quot;, numbers, 3.5);    numbers.Insert(3);    Test(&quot;Test4&quot;, numbers, 3);    numbers.Insert(4);    Test(&quot;Test6&quot;, numbers, 3.5);    numbers.Insert(1);    Test(&quot;Test5&quot;, numbers, 3);    numbers.Insert(6);    Test(&quot;Test7&quot;, numbers, 3.5);    numbers.Insert(7);    Test(&quot;Test8&quot;, numbers, 4);    numbers.Insert(0);    Test(&quot;Test9&quot;, numbers, 3.5);    numbers.Insert(8);    Test(&quot;Test10&quot;, numbers, 4);    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;64-StreamMedian数据流中的中位数-Coding-Interviews&quot;&gt;&lt;a href=&quot;#64-StreamMedian数据流中的中位数-Coding-Interviews&quot; class=&quot;headerlink&quot; title=&quot;64.StreamMedian数据流中的中位数(Coding Interviews )&quot;&gt;&lt;/a&gt;64.StreamMedian数据流中的中位数(Coding Interviews )&lt;/h1&gt;&lt;p&gt;如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Coding Interviews" scheme="http://yoursite.com/tags/Coding-Interviews/"/>
    
      <category term="Max Heap" scheme="http://yoursite.com/tags/Max-Heap/"/>
    
      <category term="Template" scheme="http://yoursite.com/tags/Template/"/>
    
  </entry>
  
  <entry>
    <title>354. Russian Doll Envelopes俄罗斯套娃</title>
    <link href="http://yoursite.com/2018/08/22/354.%20Russian%20Doll%20Envelopes%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81/"/>
    <id>http://yoursite.com/2018/08/22/354. Russian Doll Envelopes俄罗斯套娃信封/</id>
    <published>2018-08-22T01:58:44.000Z</published>
    <updated>2018-08-22T13:15:14.247Z</updated>
    
    <content type="html"><![CDATA[<h1 id="354-Russian-Doll-Envelopes俄罗斯套娃"><a href="#354-Russian-Doll-Envelopes俄罗斯套娃" class="headerlink" title="354. Russian Doll Envelopes俄罗斯套娃"></a>354. Russian Doll Envelopes俄罗斯套娃</h1><p>给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 (w, h) 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。</p><p>请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p><a id="more"></a><p>说明:<br>不允许旋转信封。</p><p>示例:</p><p>输入: envelopes = [[5,4],[6,4],[6,7],[2,3]]<br>输出: 3<br>解释: 最多信封的个数为 3, 组合为: [2,3] =&gt; [5,4] =&gt; [6,7]。</p><h2 id="动态规划解法"><a href="#动态规划解法" class="headerlink" title="动态规划解法"></a>动态规划解法</h2><p>这道题给了我们一堆大小不一的信封，让我们像套俄罗斯娃娃那样把这些信封都给套起来，这道题实际上是之前那道Longest Increasing Subsequence的具体应用，而且难度增加了，从一维变成了两维，但是万变不离其宗，解法还是一样的，首先来看DP的解法，这是一种brute force的解法，首先要给所有的信封按从小到大排序，首先根据宽度从小到大排，如果宽度相同，那么高度小的再前面，这是STL里面sort的默认排法，所以我们不用写其他的comparator，直接排就可以了，然后我们开始遍历，对于每一个信封，我们都遍历其前面所有的信封，如果当前信封的长和宽都比前面那个信封的大，那么我们更新dp数组，通过dp[i] = max(dp[i], dp[j] + 1)。然后我们每遍历完一个信封，都更新一下结果res，参见代码如下；</p><pre><code>class Solution {public:    int maxEnvelopes(vector&lt;pair&lt;int, int&gt;&gt;&amp; envelopes) {        int res=0,n=envelopes.size();        vector&lt;int&gt; dp(n,1);        sort(envelopes.begin(),envelopes.end());        for(int i=0;i&lt;n;i++){            for(int j=0;j&lt;i;j++){                if(envelopes[i].first&gt;envelopes[j].first &amp;&amp; envelopes[i].second&gt; envelopes[j].second){                    dp[i]=max(dp[i],dp[j]+1);                }            }            res=max(res,dp[i]);        }        return res;    }};</code></pre><h2 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h2><p>可以使用二分查找法来优化速度，我们首先要做的还是给信封排序，但是这次排序和上面有些不同，信封的宽度还是从小到大排，但是宽度相等时，我们让高度大的在前面。那么现在问题就简化了成了找高度数字中的LIS，完全就和之前那道Longest Increasing Subsequence一样了，所以我们还是使用之前那题解法来做，参见代码如下：</p><pre><code>class Solution {public:    int maxEnvelopes(vector&lt;pair&lt;int, int&gt;&gt;&amp; envelopes) {              vector&lt;int&gt; dp;        sort(envelopes.begin(),envelopes.end(),[](const pair&lt;int,int&gt; &amp;a,const pair&lt;int,int&gt; &amp;b){            if(a.first==b.first) return a.second&gt; b.second;            return a.first &lt;b.first;        });        for(int i=0;i&lt;envelopes.size();i++){            int left=0,right=dp.size(),t=envelopes[i].second;            while(left&lt;right){                int mid=left+(right-left)/2;                if(dp[mid]&lt; t) left=mid+1;                else right=mid;            }            if(right&gt;=dp.size()) dp.push_back(t);            else dp[right]=t;        }        return dp.size();    }};</code></pre><h2 id="使用STL函数lower-bound的二分查找法"><a href="#使用STL函数lower-bound的二分查找法" class="headerlink" title="使用STL函数lower_bound的二分查找法"></a>使用STL函数lower_bound的二分查找法</h2><pre><code>class Solution {public:    int maxEnvelopes(vector&lt;pair&lt;int, int&gt;&gt;&amp; envelopes) {        vector&lt;int&gt; dp;        sort(envelopes.begin(),envelopes.end(),[](const pair&lt;int,int&gt; &amp;a,cosnt pair&lt;int,int&gt; &amp;b){           if(a.first==b.first) return a.second&gt;b.second;            return a.first&lt;b.first;        });        for(int i=0;i&lt;envelopes.size();i++){            auto it=lower_bound(dp.begin(),dp.end(),enveloeps[i].second);            if(it==dp.end()) dp.push_back(envelopes[i].second);            else *it=envelopes[i].second;        }        return dp.size();    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;354-Russian-Doll-Envelopes俄罗斯套娃&quot;&gt;&lt;a href=&quot;#354-Russian-Doll-Envelopes俄罗斯套娃&quot; class=&quot;headerlink&quot; title=&quot;354. Russian Doll Envelopes俄罗斯套娃&quot;&gt;&lt;/a&gt;354. Russian Doll Envelopes俄罗斯套娃&lt;/h1&gt;&lt;p&gt;给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 (w, h) 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。&lt;/p&gt;
&lt;p&gt;请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>C++基础概念I</title>
    <link href="http://yoursite.com/2018/08/21/C++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5I/"/>
    <id>http://yoursite.com/2018/08/21/C++基础概念I/</id>
    <published>2018-08-21T01:58:44.000Z</published>
    <updated>2018-08-22T10:13:35.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-基础概念I"><a href="#C-基础概念I" class="headerlink" title="C++基础概念I"></a>C++基础概念I</h1><p>总结C++基础概念</p><h2 id="1-C-面向对象的三大特征"><a href="#1-C-面向对象的三大特征" class="headerlink" title="1.C++面向对象的三大特征"></a>1.C++面向对象的三大特征</h2><a id="more"></a><h3 id="1-封装"><a href="#1-封装" class="headerlink" title="(1)封装:"></a>(1)封装:</h3><p>将客观事物封装成抽象的类,并且设计者可以对类的成员进行访问控制权限控制. 这样一方面可以做到数据的隐藏,保护数据安全;另一方面,封装可以修改类的内部实现而不用修改调用了该类的用户的代码.同时封装还有利于代码的 方便复用；</p><h3 id="2-继承"><a href="#2-继承" class="headerlink" title="(2)继承:"></a>(2)继承:</h3><h4 id="a"><a href="#a" class="headerlink" title="a."></a>a.</h4><p>继承具有这样一种功能,它可以使用现有类的所有功能；并且可以在不重新编写原有类的情况下对类的功能进行扩展.继承的过程是一般到特殊的过程,即是它们是is-a的关系;基类或父类是一般,而子类或派生类是基类的特殊表现;要实现继承可以通过继承和组合来实现;</p><h4 id="b"><a href="#b" class="headerlink" title="b."></a>b.</h4><p>广义上的继承分成三大类:实现继承:使用基类的属性和方法而无需额外编码的能力;接口继承:接口继承是指仅使用基类的属性和方法的名称,而具体的实现子类必须自己完成的能力;可视继承:子窗体(类)使用父窗体(类)的外观和实现代码的能力;</p><h3 id="3-多态"><a href="#3-多态" class="headerlink" title="(3)多态:"></a>(3)多态:</h3><h4 id="a-1"><a href="#a-1" class="headerlink" title="a."></a>a.</h4><p>多态的实现分成两种,一种是编译时的多态,主要是通过函数重载和运算符重</p><p>另外一种是运行时多态,主要是通过函数覆盖来实现的,它需要满足3个条件:基类函数必须是虚函数,并且基类的指针或引用指向子类的时候,当子类中对原有的虚函数进行重新定义之后形成一个更加严格的重载版本的时候,就会形成多态;它是通过动态联编实现的;</p><h4 id="b-1"><a href="#b-1" class="headerlink" title="b."></a>b.</h4><p>运行时的多态可以让基类的指针或引用指向不同的对象的时候表现出来不同的特性;</p><h2 id="2-简述C-C-程序编译时的内存分配情况"><a href="#2-简述C-C-程序编译时的内存分配情况" class="headerlink" title="2.简述C/C++程序编译时的内存分配情况"></a>2.简述C/C++程序编译时的内存分配情况</h2><h3 id="1-一般一个c-c-程序编译的时候内存布局如下-地址从低到高的顺序"><a href="#1-一般一个c-c-程序编译的时候内存布局如下-地址从低到高的顺序" class="headerlink" title="(1)一般一个c/c++程序编译的时候内存布局如下(地址从低到高的顺序)"></a>(1)一般一个c/c++程序编译的时候内存布局如下(地址从低到高的顺序)</h3><h4 id="a-代码区"><a href="#a-代码区" class="headerlink" title="a.代码区:"></a>a.代码区:</h4><p>存放程序的二进制代码.</p><h4 id="b-常量区"><a href="#b-常量区" class="headerlink" title="b.常量区:"></a>b.常量区:</h4><p>这个区和代码区的距离很近,主要存放一些非局部常量值和字符串字面值,一般不允许修改,程序结束由系统释放;具有常属性并且初始化的全局和静态变量也放在这个区.</p><h4 id="c-数据区"><a href="#c-数据区" class="headerlink" title="c.数据区:"></a>c.数据区:</h4><p>赋过初值的且不具有常属性的静态和全局变量在数据区.它和BSS段统称为静态区;程序结束后由系统释放;</p><h4 id="d-BSS段"><a href="#d-BSS段" class="headerlink" title="d.BSS段:"></a>d.BSS段:</h4><p>没有初始化的静态和全局变量;进程一旦被加载这个区所有的数据都被清0;</p><h4 id="e-堆区"><a href="#e-堆区" class="headerlink" title="e.堆区:"></a>e.堆区:</h4><p>   动态分配的内存;由程序员分配和释放,程序结束的时候如果没有释放,则由OS回收;</p><h4 id="f-栈区"><a href="#f-栈区" class="headerlink" title="f.栈区:"></a>f.栈区:</h4><p>   由编译器自动分配和释放,不使用的时候会自动的释放.主要用来存放非静态的局部变量,函数的参数和返回值, 临时变量等.</p><h4 id="g-命令行参数和环境变量区"><a href="#g-命令行参数和环境变量区" class="headerlink" title="g.命令行参数和环境变量区;"></a>g.命令行参数和环境变量区;</h4><p>下面是对应一段经典的代码:</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;  //unix下的头文件const int const_global = 10; //常全局变量int init_global = 10;        //初始化的全局变量int uninit_global;           //未初始化的全局白能量int main(int argc,char * argv[]){    const static int const_static = 10;//常属性的静态变量，不可以被赋值，初始化    static int init_static = 10;    //初始化静态变量    static int uninit_static;       //未初始化静态变量    const int const_local = 10;    // 常属性的局部变量    int  prev_local = 1;//前局部变量    int  next_local = 5;//后局部变量    int* prev_heap = malloc(sizeof(int));//前面分配的堆变量    int* next_heap = malloc(sizeof(int));//后面分配的堆变量    const char* literal = &quot;literal&quot;;      //字符串字面值，字面值常量    extern char** environ;               // 环境变量    printf(&quot;----地址最高断命令行参数和环境变量-------\n&quot;);    printf(&quot;        环境变量:%p\n&quot;,environ);    printf(&quot;      命令行参数:%p\n&quot;,argv);    printf(&quot;---------------栈区-----------------------\n&quot;);    printf(&quot;      常局部变量:%p\n&quot;,&amp;const_local);    printf(&quot;      前局部变量:%p\n&quot;,&amp;prev_local);    printf(&quot;      后局部变量:%p\n&quot;,&amp;next_local);    printf(&quot;--------------------堆--------------------\n&quot;);    printf(&quot;        前堆变量:%p\n&quot;,prev_heap);    printf(&quot;        后堆变量:%p\n&quot;,next_heap);    printf(&quot;--------------------BSS--------------------\n&quot;);    printf(&quot;未初始化全局变量:%p\n&quot;,&amp;uninit_global);    printf(&quot;未初始化静态变量:%p\n&quot;,&amp;uninit_static);    printf(&quot;----------------数据------------------------\n&quot;);    printf(&quot;  初始化全局变量:%p\n&quot;,&amp;init_static);    printf(&quot;  初始化全局变量:%p\n&quot;,&amp;init_global);    printf(&quot;----------------代码区----------------------\n&quot;);    printf(&quot;     常静态变量:%p\n&quot;,&amp;const_static);    printf(&quot;     字面值常量:%p\n&quot;,&amp;literal);    printf(&quot;     常全局变量:%p\n&quot;,&amp;const_global);    printf(&quot;           函数:%p\n&quot;,main);    return 0;}</code></pre><h3 id="2-从上面可以看出c-c-的内存分配方式主要有三种"><a href="#2-从上面可以看出c-c-的内存分配方式主要有三种" class="headerlink" title="(2)从上面可以看出c/c++的内存分配方式主要有三种"></a>(2)从上面可以看出c/c++的内存分配方式主要有三种</h3><h4 id="a-从静态存储区域分配"><a href="#a-从静态存储区域分配" class="headerlink" title="a.从静态存储区域分配:"></a>a.从静态存储区域分配:</h4><p>   内存在程序编译时已经分配好,这块内存在程序的整个运行期间都存在.速度快,不容易出错.因为由系统会善后.</p><h4 id="b-在栈上分配内存"><a href="#b-在栈上分配内存" class="headerlink" title="b.在栈上分配内存:"></a>b.在栈上分配内存:</h4><p>   在执行函数的时候,函数内非静态局部变量的存储单元都是在栈上创建,函数执行结束的时候这些存储单元自动被释放.栈内存分配内置于处理器的指令集中,效率很高但是分配的内容有限.</p><h4 id="c-从堆中分配内存"><a href="#c-从堆中分配内存" class="headerlink" title="c.从堆中分配内存:"></a>c.从堆中分配内存:</h4><p>即是动态分配内存.程序在运行的时候使用malloc/new申请任意大小的内存,程序员自己负责在何时用free/delete释放内存.动态内存的生存期由程序员决定,使用非常的灵活.如果在堆上分配了内存,就有责任去回收它,否则运行程序会出现内存泄漏,另外频繁的分配和释放不同大小的堆空间将会产生堆内碎片.不易管理;</p><h3 id="3-堆和栈之间的主要的区别是什么"><a href="#3-堆和栈之间的主要的区别是什么" class="headerlink" title="(3)堆和栈之间的主要的区别是什么?"></a>(3)堆和栈之间的主要的区别是什么?</h3><h4 id="a-管理方式不同"><a href="#a-管理方式不同" class="headerlink" title="a.管理方式不同:"></a>a.管理方式不同:</h4><p>栈是由编译器自动分配和释放,使用方便;而对于堆来说,分配和释放都必须由程序员来手动完成,不易管理,容易造成内存泄漏和内存碎片.</p><h4 id="b-可用内存空间不同"><a href="#b-可用内存空间不同" class="headerlink" title="b.可用内存空间不同:"></a>b.可用内存空间不同:</h4><p>对于栈来说,它可用的内存空间比较小;而对于堆来说它可以使用的空间比栈要大的多.</p><h4 id="c-能否产生碎片不同"><a href="#c-能否产生碎片不同" class="headerlink" title="c.能否产生碎片不同:"></a>c.能否产生碎片不同:</h4><p>由于栈采用的是后进先出的机制,所以栈空间没有内存碎片的产生;而对于堆来说,由于频繁的使用new/delete势必会造成内存空间分配的不连续,从而造成大量的碎片,使程序的效率降低.</p><h4 id="d-生长方向不同"><a href="#d-生长方向不同" class="headerlink" title="d.生长方向不同:"></a>d.生长方向不同:</h4><p>对于堆来说,它一般是向上的;即是向着地址增加的方向增长;对于栈来说,它一般是向下的,即向着地址减小的方向增长.</p><h4 id="e-分配的方式不同"><a href="#e-分配的方式不同" class="headerlink" title="e.分配的方式不同:"></a>e.分配的方式不同:</h4><p>对于堆来说,它只能是动态分配的;而对于栈来说,它分为静态分配和动态分配;静态分配由编译器来进行管理,而动态分配的栈和堆也是不一样的,动态分配的栈由编译器进行释放,无需我们程序员来释放.</p><h4 id="f-分配的效率不同"><a href="#f-分配的效率不同" class="headerlink" title="f.分配的效率不同:"></a>f.分配的效率不同:</h4><p>栈是机器系统提供的数据结构,计算机会在底层对栈提供支持:为栈分配专门的寄存器.压栈和出栈都由专门的指令进行.因此它的效率会很高;而堆则是由c/c++库函数实现的,机制是非常的负责的;例如要分配一块内存的时候,库函数会利用特定的算法在堆内存中搜索可用大小的内存空间;如果没有足够大的内存空间,就会调用系统功能去增加数据段的内存空间.这样才能得到足够大的可用的内存空间,因此堆内存的分配的效率比栈要低得多. </p><h3 id="4-new-malloc以及free-delete之间的区别"><a href="#4-new-malloc以及free-delete之间的区别" class="headerlink" title="(4)new/malloc以及free/delete之间的区别"></a>(4)new/malloc以及free/delete之间的区别</h3><h4 id="a-2"><a href="#a-2" class="headerlink" title="a."></a>a.</h4><p>new/delete是运算符,只能在C++中使用,它可以重载;mallloc/free是C的标准库函数,在C/C++中都可以使用.</p><h4 id="b-2"><a href="#b-2" class="headerlink" title="b."></a>b.</h4><p>对于非内部的数据类型的对象而言,光用malloc/free是无法满足动态对象的要求的.对象在创建的时候需要执行构造函数,对象在消亡之前需要执行析构函数.而molloc/free是库函数而不是运算符,不在编译器的控制范围之内,编译器不能将执行构造函数和析构函数的任务强加给malloc/free.因此C++需要一个能够完成动态分配内存和初始化的new,以及一个能够完成清理和释放内存的运算符delete.</p><h4 id="c"><a href="#c" class="headerlink" title="c."></a>c.</h4><p>new的返回值是指定类型的指针,可以自动的计算所需要分配的内存大小.而malloc的返回值是一个void类型的指针,我们在使用的时候要进行强制类型转换,并且分配的大小也要程序员手动的计算.</p><h4 id="d"><a href="#d" class="headerlink" title="d."></a>d.</h4><p>new/delete完全覆盖了malloc/free的功能,只所以还要保留malloc/free,是因为我们的C++程序有时要调用用C编写的而C中又没有new/delete,只能使用malloc/free.</p><h2 id="3-指针和引用之间的区别和联系"><a href="#3-指针和引用之间的区别和联系" class="headerlink" title="3.指针和引用之间的区别和联系"></a>3.指针和引用之间的区别和联系</h2><h3 id="联系"><a href="#联系" class="headerlink" title="联系:"></a>联系:</h3><h4 id="a-3"><a href="#a-3" class="headerlink" title="a."></a>a.</h4><p>指针和引用本质上都是地址的概念,引用在内部其实是用const指针来实现的.</p><h4 id="b-3"><a href="#b-3" class="headerlink" title="b."></a>b.</h4><p>给函数传递参数的时候,一级指针和引用作为函数参数的时候可以达到相同的效果.</p><h4 id="c-1"><a href="#c-1" class="headerlink" title="c."></a>c.</h4><p>指针的大部分效果都可以通过引用来实现。</p><h4 id="d-1"><a href="#d-1" class="headerlink" title="d."></a>d.</h4><p>二级指针作为参数的时候就是希望在函数的内部修改指针的指向.这个时候利用指针的引用可以达到同样的效果.</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别:"></a>区别:</h3><h4 id="a-4"><a href="#a-4" class="headerlink" title="a."></a>a.</h4><p>定义引用的时候必须初始化,定义指针的时候可以不初始化.</p><h4 id="b-4"><a href="#b-4" class="headerlink" title="b."></a>b.</h4><p>引用不能引用空,但是指针可以指向空.</p><h4 id="c-2"><a href="#c-2" class="headerlink" title="c."></a>c.</h4><p>引用的关系一旦确定,就无法改变;引用永远指向的是用来对它初始化的对象;而非常属性的指针是可以改变指向的.</p><h4 id="d-2"><a href="#d-2" class="headerlink" title="d."></a>d.</h4><p>指针是一个实体变量,在32位操作系统上面都是4个字节.而引用只是一个别名,其大小和其应用的对象的类型有关系.</p><h4 id="e"><a href="#e" class="headerlink" title="e."></a>e.</h4><p>有指向指针的指针,但是没有引用引用的引用;因为引用一旦建立,它就表示初始化它的对象.</p><h4 id="f"><a href="#f" class="headerlink" title="f."></a>f.</h4><p>有引用指针的引用,但是没有指向引用的指针；</p><h4 id="g"><a href="#g" class="headerlink" title="g."></a>g.</h4><p>有指针数组,但是没有引用数组,但是有数组的引用.<br>下面是一段代码非常的全面:</p><pre><code>#include &lt;iostream&gt;using namespace std;void foo(int a[3])/*这个地方传递的是数组的首地址*/{     cout &lt;&lt; sizeof(a)/sizeof(a[0]) &lt;&lt; endl;}void bar(int (&amp;a)[3])/*这里传参的时候就是数组的整体*/{     cout &lt;&lt; sizeof(a)/sizeof(a[0]) &lt;&lt; endl;}int main(void){     int a;     int* p = &amp;a;     int** pp = &amp;p;/*存在指向指针的指针*/     int&amp; r  = a;     int&amp;&amp; rr = r;/*error没有引用引用的引用*/     int*&amp;  rp = p; /*有引用指针的引用(指针引用)*/     int&amp;* pr = &amp;r; /*没有指向引用的指针(引用指针)*/     int x, y, z;     int* pa[] = {&amp;x,&amp;y,&amp;z};/*指针数组*/     int&amp; ra[] = {x,y,z};/*引用数组是不存在的因为引用不是一个实体*/     int arr[3] = {0};     int (&amp;ar)[3] = arr;/*数组引用(先近后远,先右后左)*/     foo(arr);/*这里传递的是数组的第一个元素的首地址*/     cout &lt;&lt; sizeof(arr)/sizeof(arr[0]) &lt;&lt; endl;     /*这里的数组名代表的是真个数组*/     int (*parr)[3] = &amp;arr;/*对数组名取地址得到的是一个数组指针                             这个时候arr代表的是数组的整体;*/     bar(arr);/*这里传递的就是数组的整体*/     return 0;}</code></pre><h2 id="4-类和结构体的区别"><a href="#4-类和结构体的区别" class="headerlink" title="4.类和结构体的区别"></a>4.类和结构体的区别</h2><p>结构体在默认情况下的成员都是public的,而类在默认情况下的成员是private的。</p><p>结构体和类都必须使用new创建，struct保证成员按照声明顺序在内存在存储，而类不保证。</p><p>C++结构体的继承默认是public，而c++类的继承默认是private。</p><h2 id="5-C-和C定义结构体区别"><a href="#5-C-和C定义结构体区别" class="headerlink" title="5.C++和C定义结构体区别"></a>5.C++和C定义结构体区别</h2><p>C++中的结构和类其实具备几乎一样的功能，结构体内也是可以声明函数，C++的结构体和类默认具有不一样的访问属性</p><h2 id="6-const常量与define宏定义的区别"><a href="#6-const常量与define宏定义的区别" class="headerlink" title="6.const常量与define宏定义的区别"></a>6.const常量与define宏定义的区别</h2><h3 id="1-编译器处理方式不同。"><a href="#1-编译器处理方式不同。" class="headerlink" title="(1) 编译器处理方式不同。"></a>(1) 编译器处理方式不同。</h3><p>define宏是在预处理阶段展开，生命周期止于编译期。只是一个常数、一个命令中的参数，没有实际的存在。#define常量存在于程序的代码段。const常量是编译运行阶段使用，const常量存在于程序的数据段.</p><h3 id="2-类型和安全检查不同。"><a href="#2-类型和安全检查不同。" class="headerlink" title="(2)类型和安全检查不同。"></a>(2)类型和安全检查不同。</h3><p>define宏没有类型，不做任何类型检查，仅仅是展开。const常量有具体的类型，在编译阶段会执行类型检查。</p><h3 id="3-存储方式不同。"><a href="#3-存储方式不同。" class="headerlink" title="(3)存储方式不同。"></a>(3)存储方式不同。</h3><p>define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。const常量会在内存中分配(可以是堆中也可以是栈中)</p><h2 id="7-memset-memcpy-和strcpy-的根本区别"><a href="#7-memset-memcpy-和strcpy-的根本区别" class="headerlink" title="7.memset ,memcpy 和strcpy 的根本区别"></a>7.memset ,memcpy 和strcpy 的根本区别</h2><p>memset用来对一段内存空间全部设置为某个字符，一般用在对定义的字符串进行初始化为’ ‘或’’；</p><p>它对较大的结构体或数组进行清零操作的一种最快方法。</p><pre><code>char temp[30];     memset(temp,&apos;\0&apos;,sizeof(temp));</code></pre><p>char temp[30]只是分配了一定的内存空间给该字符数组，但并未初始化该内存空间，即数组。所以，需要使用memset()来进行初始化。</p><p>memcpy用来做内存拷贝，你可以拿它拷贝任何数据类型的对象，可以指定拷贝的数据长度；</p><p>strcpy就只能拷贝字符串了，它遇到’\0’就结束拷贝；例如：<br>    char a[100],b[50];strcpy(a,b);</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;C-基础概念I&quot;&gt;&lt;a href=&quot;#C-基础概念I&quot; class=&quot;headerlink&quot; title=&quot;C++基础概念I&quot;&gt;&lt;/a&gt;C++基础概念I&lt;/h1&gt;&lt;p&gt;总结C++基础概念&lt;/p&gt;
&lt;h2 id=&quot;1-C-面向对象的三大特征&quot;&gt;&lt;a href=&quot;#1-C-面向对象的三大特征&quot; class=&quot;headerlink&quot; title=&quot;1.C++面向对象的三大特征&quot;&gt;&lt;/a&gt;1.C++面向对象的三大特征&lt;/h2&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>股票交易问题通解小结</title>
    <link href="http://yoursite.com/2018/08/21/%E8%82%A1%E7%A5%A8%E4%BA%A4%E6%98%93%E9%97%AE%E9%A2%98%E9%80%9A%E8%A7%A3%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2018/08/21/股票交易问题通解小结/</id>
    <published>2018-08-21T01:58:44.000Z</published>
    <updated>2018-08-22T10:14:24.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="股票交易问题通解小结"><a href="#股票交易问题通解小结" class="headerlink" title="股票交易问题通解小结"></a>股票交易问题通解小结</h1><p>本文的主要部分来自于leetcode讨论区,后面加上了一点个人的理解和扩展延伸，Leetcode中的股票交易问题共有下列几道：</p><a id="more"></a><pre><code>121.Best Time to Buy and Sell Stock122.Best Time to Buy and Sell Stock II123.Best Time to Buy and Sell Stock III188.Best Time to Buy and Sell Stock IV309.Best Time to Buy and Sell Stock with Cooldown714.Best Time to Buy and Sell Stock with Transaction Fee</code></pre><h2 id="I-–常见情况"><a href="#I-–常见情况" class="headerlink" title="I –常见情况"></a>I –常见情况</h2><p>本文的想法来自于下列的问题：给定一个代表每天股票价格的数组，是什么决定了我们能得到的最大利润？</p><p>大多数人会很快产生类似“那取决于我们处在第几天和我们被允许最多完成多少次交易”。</p><p>当然，这些是重要的因素因为它们在问题描述中就被显示出来。然而，在判断最大利润中有一个隐含因素不是那么明显但却至关重要，它将在下文中被阐述出来。</p><p>首先让我们确定符号来简化我们的分析，令prices作为长度为n的股票价格数组，i标记为第i天（i会从0到n-1)，k标记为被允许完成的最大交易次数,T[i][k]是在第i天的结尾经过最多k次交易所能获得的最大利润。很明显我们有基准情况：T[-1][k]=T[i][0]=0, 那就是没有股票或者没有交易导致没有利润（标记第1天为i=0因此i=0意味着没有股票）。</p><p>现在如果我们能够把T[i][k]和它的子问题T[i-1][k],T[i][k-1],T[i-1][k-1],…，我们会有一个可行的递推关系式<br>使得问题能够递归解决，所以我们怎样实现它呢？<br>最常见的直接方式是看第i天的行动，我们有多少种选择方式？答案是三种：买，卖，休息。我们应该采取哪种呢？</p><p>答案是：我们并不真的知道，但是可以去找哪一种最简单。假设没有其它的约束，我们可以尝试每种选择然后选择使得我们利润最大的一种。</p><p>可是我们确实有一个额外的约束，就是不能在同一时间进行重复交易，意味着如果我们决定在第i天购买，那么我们手中就应该不持有股票；如果我们决定在第i天出售，我们手中应该恰好有一只股票。我们手中<br>的股票数量是上文中提到的会影响我们第i天行为的因素同时也会影响最大利润。</p><p>因此我们对T[i][k]的定义应该被分割成两部分:T[i][k][0]和T[i][k][1],前者标记在最多k次交易和行动后我们手中没有股票的情况下第i天结尾时的最大利润，后者标记在最多k次交易和行动后我们手中只有一只股票的情况下第i天结尾时的最大利润，现在基准情况和递推关系可以被写作：</p><h3 id="1-基准情况："><a href="#1-基准情况：" class="headerlink" title="1.基准情况："></a>1.基准情况：</h3><pre><code>T[-1][k][0]=0, T[-1][k][1]=-InfinityT[i][0][0]=0, T[i][0][1]=-Infinity</code></pre><h3 id="2-递推关系："><a href="#2-递推关系：" class="headerlink" title="2.递推关系："></a>2.递推关系：</h3><pre><code>T[i][k][0]=max(T[i-1][k][0],T[i-1][k][1]+prices[i])T[i][k][1]=max(T[i-1][k][1],T[i-1][k-1][0]-prices[i])</code></pre><p>对于基准情况，T[-1][k][0] = T[i][0][0] = 0有同样的含义正如之前当T[-1][k][1] = T[i][0][1] = -Infinity强调了事实对于我们来说如果没有可获得的股票或不被允许交易那么就不可能手中有一只股票。</p><p>对于递推式中的T[i][k][0]，在第i天能采取的行动只有休息和卖，因为我们在一天结束时手中没有股票。T[i-1][k][0]是当采取行动休息时的最大利润，<br>而T[i-1][k][1] + prices[i]则是当行动卖被采取时的最大利润。</p><p>如果最大被允许的交易次数保持不变，由于一次交易包含两种成对的行为-买和卖。只有行为买会改变被允许的最大交易次数。（此处还有一种替代的解释）<br>对于递推式中的T[i][k][1]，在第i天能采取的行动只有休息和买，因为我们在一天结束时手中只有一只股票。T[i-1][k][1]是当采取行动休息时的最大利润，而T[i-1][k-1][0] - prices[i]是当采取购买行为时的最大利润。要注意被允许的最大交易次数会减一，因为在第i天的购买行为会使用掉一次交易次数。</p><p>为了找到最后一天结束时的最大利润，我们能够简化循环通过数组prices并且通过上面的递推关系式更新T[i][k][0]和T[i][k][1]。最终的答案是T[i][k][0]（我们总是有更大的利润如果我们以手中0只股票结束）</p><h2 id="II-–-对特殊情况的应用"><a href="#II-–-对特殊情况的应用" class="headerlink" title="II – 对特殊情况的应用"></a>II – 对特殊情况的应用</h2><p>前面提及的六种股票问题能够被k的值分类，k是被允许的最大交易次数（最后两个也有额外的要求例如冷却期或者交易费）。我会一个接一个的把通用解应用到这些问题上。</p><h3 id="情况I：k-1"><a href="#情况I：k-1" class="headerlink" title="情况I：k=1"></a>情况I：k=1</h3><p>对于这个情况，我们在每天都真的有两个未知变量：T[i][1][0]和T[i][1][1]，递推关系式表示：</p><pre><code>T[i][1][0] = max(T[i-1][1][0], T[i-1][1][1] + prices[i])T[i][1][1] = max(T[i-1][1][1], T[i-1][0][0] - prices[i]) = max(T[i-1][1][1], -prices[i])</code></pre><p>在第二个方程中我们充分利用了基准情况T[i][0][0]=0。<br>很容易直接写出O(n)时间复杂度和O(n)空间复杂度的解，基于上面的两个方程。可是，如果你注意到在第i天的最大利润事实上只依赖于那些在第i-1天的利润，<br>那么空间复杂度降为O(1)。这是空间最优的解法：</p><pre><code>public int maxProfit(int[] prices){    int T_i10=0,T_i11=Integer.MIN_VALUE;    for(int price:prices){        T_i10=Math.max(T_i10,T_i11 + price);        T_i11=Math.max(T_i11,-price);    }    return T_i10;}</code></pre><h3 id="情况-II-k-Infinity"><a href="#情况-II-k-Infinity" class="headerlink" title="情况 II: k=+Infinity"></a>情况 II: k=+Infinity</h3><p>如果k是正无穷的，那么在k和k-1之间没有任何真正区别，暗示了T[i-1][k-1][0] = T[i-1][k][0]和T[i-1][k-1][1] = T[i-1][k][1]，因此我们仍然在每天有两个未知变量：T[i][k][0]和T[i][k][1]，k=+Infinity,递推关系式如下：</p><pre><code>T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])T[i][k][1] = max(T[i-1][k][1], T[i-1][k-1][0] - prices[i]) = max(T[i-1][k][1], T[i-1][k][0] - prices[i])</code></pre><p>在第二个方程中我们会充分利用T[i-1][k-1][0] = T[i-1][k][0]，O(n)时间复杂度和O(1)空间复杂度的解法如下：</p><pre><code>public int maxProfit(int[] prices) {    int T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;    for (int price : prices) {        int T_ik0_old = T_ik0;        T_ik0 = Math.max(T_ik0, T_ik1 + price);        T_ik1 = Math.max(T_ik1, T_ik0_old - price);    }    return T_ik0;}</code></pre><p>(注意: 旧值缓存的T_ik0,是变量T_ik0_old,是不可能的，特别感谢0x0101和elvina澄清这一点）</p><p>这个解法提出了一种贪心的策略来获取最大利润：只要可能，在每个最小值出买股票然后在下一个局部最大值时迅速卖出。这等同于在prices中找到递增子序列，在每个子序列中的开头买入，在每个子序列的结尾卖出。这很容易展示这等同于只要有利可图时就积累利润，如<a href="https://discuss.leetcode.com/topic/726/is-this-question-a-joke中提到的。" target="_blank" rel="noopener">https://discuss.leetcode.com/topic/726/is-this-question-a-joke中提到的。</a></p><h3 id="情况-III-k-2"><a href="#情况-III-k-2" class="headerlink" title="情况 III: k=2"></a>情况 III: k=2</h3><p>与k=1的情况类似，除了现在我们每天有四个而不是两个变量：T[i][1][0], T[i][1][1], T[i][2][0], T[i][2][1]，递推关系式如下：</p><pre><code>T[i][2][0] = max(T[i-1][2][0], T[i-1][2][1] + prices[i])T[i][2][1] = max(T[i-1][2][1], T[i-1][1][0] - prices[i])T[i][1][0] = max(T[i-1][1][0], T[i-1][1][1] + prices[i])T[i][1][1] = max(T[i-1][1][1], -prices[i])</code></pre><p>在最后一个方程中我们充分利用了基准情况T[i][0][0]=0，下列解有O(n)的空间复杂度和O(1)</p><pre><code>public int maxProfit(int[] prices) {    int T_i10 = 0, T_i11 = Integer.MIN_VALUE, T_i20 = 0, T_i21 = Integer.MIN_VALUE;    for (int price : prices) {        T_i20 = Math.max(T_i20, T_i21 + price);        T_i21 = Math.max(T_i21, T_i10 - price);        T_i10 = Math.max(T_i10, T_i11 + price);        T_i11 = Math.max(T_i11, -price);    }    return T_i20;}</code></pre><h3 id="情况-IV：-k是任意的"><a href="#情况-IV：-k是任意的" class="headerlink" title="情况 IV： k是任意的"></a>情况 IV： k是任意的</h3><p>这是最通用的情况所以在每天我们都需要更新所有的有不同k值的最大利润对应在每天结尾时我们手中有0或1只股票。</p><p>可是，有一个微小的优化我们能够做的是如果k超出了一些临界值，超出了最大的利润不再依赖于允许交易的次数而是被可获得的股票数量限制（prices数组的长度），让我们计算出临界值会是什么。</p><p>一个获利交易花费至少两天（一天买另一天卖，买入价格不少于卖出价格)，如果prices数组的长度是n，最大的获利交易数量是n/2，在这之后没有可能的获益交易，<br>这暗示着最大的利润会保持不变。</p><p>因此，临界k值是n/2，如果给定的k值不小于这个值的时候，换句话说，k&gt;=n/2，我们能够把k拓展到正无穷，问题等价于情况II。</p><p>下列是时间复杂度为O(kn)，空间复杂度O(k)的解，没有优化，代码能够满足大K值时的时间约束。</p><pre><code>public int maxProfit(int k, int[] prices) {    if (k &gt;= prices.length &gt;&gt;&gt; 1) {    int T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;    for (int price : prices) {    int T_ik0_old = T_ik0;    T_ik0 = Math.max(T_ik0, T_ik1 + price);    T_ik1 = Math.max(T_ik1, T_ik0_old - price);    }    return T_ik0;}    int[] T_ik0 = new int[k + 1];    int[] T_ik1 = new int[k + 1];    Arrays.fill(T_ik1, Integer.MIN_VALUE);    for (int price : prices) {        for (int j = k; j &gt; 0; j--) {            T_ik0[j] = Math.max(T_ik0[j], T_ik1[j] + price);            T_ik1[j] = Math.max(T_ik1[j], T_ik0[j - 1] - price);        }    }    return T_ik0[k];}</code></pre><p>解法类似于<a href="https://discuss.leetcode.com/topic/8984/a-concise-dp-solution-in-java帖子中的解法，这里我使用了T数组的反向循环来避免使用临时变量。它也被证明不使用临时变量做前向循环也是可能的。" target="_blank" rel="noopener">https://discuss.leetcode.com/topic/8984/a-concise-dp-solution-in-java帖子中的解法，这里我使用了T数组的反向循环来避免使用临时变量。它也被证明不使用临时变量做前向循环也是可能的。</a></p><h3 id="情况-V：k-Infinity-有冷却期"><a href="#情况-V：k-Infinity-有冷却期" class="headerlink" title="情况 V：k=+Infinity 有冷却期"></a>情况 V：k=+Infinity 有冷却期</h3><p>这个例子相似于情况II更多是由于他们有同样的k值，除了递推式需要简单的修改来满足冷却期的要求。情况II中给出的原始递推式是：</p><pre><code>T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])T[i][k][1] = max(T[i-1][k][1], T[i-1][k][0] - prices[i])</code></pre><p>  但是由于冷却期，我们不能在第i天买入股票如果在第i-1天股票被卖出，因此，在上面的第二个方程中，我们事实上应该用T[i-2][k][0]而不是T[i-1][k][0]<br>如果我们打算在第i天买。其他所有都保持不变并且新的递推式是：</p><pre><code>T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])T[i][k][1] = max(T[i-1][k][1], T[i-2][k][0] - prices[i])</code></pre><p>下面是O（n）时间复杂度和O（1）空间复杂度的解法：</p><pre><code>public int maxProfit(int[] prices) {    int T_ik0_pre = 0, T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;    for (int price : prices) {        int T_ik0_old = T_ik0;        T_ik0 = Math.max(T_ik0, T_ik1 + price);        T_ik1 = Math.max(T_ik1, T_ik0_pre - price);        T_ik0_pre = T_ik0_old;    }    return T_ik0;}</code></pre><p>dietpepsi分享了一种非常好的解法，被证明和上述方法相同<a href="https://discuss.leetcode.com/topic/30421/share-my-thinking-process" target="_blank" rel="noopener">https://discuss.leetcode.com/topic/30421/share-my-thinking-process</a></p><h3 id="情况-VI-k-Infinity-但有交易费用"><a href="#情况-VI-k-Infinity-但有交易费用" class="headerlink" title="情况 VI:k=+Infinity 但有交易费用"></a>情况 VI:k=+Infinity 但有交易费用</h3><p>再一次的这个例子等同于情况ＩＩ因为它们有同样的ｋ值，除了现在的递推关系式需要轻微修改来满足交易费的要求。情况ＩＩ给出的原始递推关系式如下：</p><pre><code>T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])T[i][k][1] = max(T[i-1][k][1], T[i-1][k][0] - prices[i])</code></pre><p>因为现在我们需要为每次的交易行为付费，在第ｉ天的购买和出售股票获利中应该减去这个值，因此新的递推关系式应该为下面的任意一种：</p><pre><code>T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])T[i][k][1] = max(T[i-1][k][1], T[i-1][k][0] - prices[i] - fee)</code></pre><p>或</p><pre><code>T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i] - fee)T[i][k][1] = max(T[i-1][k][1], T[i-1][k][0] - prices[i])</code></pre><p>注意当我们减去费用时我们有两个选项，这是因为每次交易都会表征为两个成对出现的行为－－买和卖<br>费用能够被支付当我们买股票（第一组方程）或当我们卖股票（第二组方程），下列是Ｏ(n)时间复杂度和Ｏ(1)空间复杂度的解法对应于这两项选择，第二个解法我们需要注意可能的溢出。</p><h4 id="解法I－－当买入股票时支付交易费"><a href="#解法I－－当买入股票时支付交易费" class="headerlink" title="解法I－－当买入股票时支付交易费"></a>解法I－－当买入股票时支付交易费</h4><pre><code>public int maxProfit(int[] prices, int fee) {    int T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;    for (int price : prices) {        int T_ik0_old = T_ik0;        T_ik0 = Math.max(T_ik0, T_ik1 + price);        T_ik1 = Math.max(T_ik1, T_ik0_old - price - fee);    }    return T_ik0;}</code></pre><h4 id="解法II－－当售出股票时支付交易费"><a href="#解法II－－当售出股票时支付交易费" class="headerlink" title="解法II－－当售出股票时支付交易费"></a>解法II－－当售出股票时支付交易费</h4><pre><code>public int maxProfit(int[] prices, int fee) {    long T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;    for (int price : prices) {        long T_ik0_old = T_ik0;        T_ik0 = Math.max(T_ik0, T_ik1 + price - fee);        T_ik1 = Math.max(T_ik1, T_ik0_old - price);    }    return (int)T_ik0;}</code></pre><h1 id="III延伸拓展"><a href="#III延伸拓展" class="headerlink" title="III延伸拓展"></a>III延伸拓展</h1><p>在121. Best Time to Buy and Sell Stock中也可以将其转换成求最大子列和的问题，对于原数组，如果我们将arr[i]-arr[i-1]，也就是股票某日与前一日价格差，依次排列成一个数组，那么所求问题的答案就变成了求这个新数组的最大子列和。</p><p>在求解最大子列和问题时，使用Kadane算法。算法复杂度O（N）,kadane算法利用了数学归纳法的思想。简而言之，给定一个现成的数组，比如说−2, 1, −3, 4, −1, 2, 1, −5, 4，求其中的最大子列和，并不是容易的事情。但如果我们能从第一个数开始，随着数组的扩充，始终对其最大子列和保持跟踪，就可以求出任意一个数组的最大子列和。</p><p>详细的分析一下，往一个长度为i的数组后面插入第i+1个数，这时，数组的最大子列只有两种情况，要么包括第i+1个数，要么不包括第i+1个数。</p><p>即：<br>maxsubarraum = max(以第i+1个数结尾的子列和， 不以第i+1个数结尾的子列和)。</p><p>先计算前者，以第i+1个数结尾的子列和怎么算呢？很简单，要么它是以第i个数结尾的子列作为前缀，要么它不以之作为前缀。假设第i+1个数为x，那么：<br>以第i+1个数结尾的子列和 = max（x，以第i个数结尾的子列和+x)。</p><p>对于kadane算法的扩展还可以见于<code>hihocoder#1800 : 玩具设计师</code>一题中求二维数组的最大矩形和</p><h1 id="IV－－总结"><a href="#IV－－总结" class="headerlink" title="IV－－总结"></a>IV－－总结</h1><p> 总之，最通用的股票问题解法能够被表征为三个因素，ｉ天的序号，最大允许的交易次数ｋ和每天结束后我们手中持有的股票数。</p><p>上文已经展示了最大利润和他们终止情况的递推式，Ｏ(nk)时间复杂度和Ｏ(k)空间复杂度。结果被依次应用于六个例子，后两个由于额外的要求做了轻微的修改。<a href="https://discuss.leetcode.com/user/peterleetcode也介绍了一个很好的解法对于任意k值通用。如果有兴趣可以继续看一下。" target="_blank" rel="noopener">https://discuss.leetcode.com/user/peterleetcode也介绍了一个很好的解法对于任意k值通用。如果有兴趣可以继续看一下。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;股票交易问题通解小结&quot;&gt;&lt;a href=&quot;#股票交易问题通解小结&quot; class=&quot;headerlink&quot; title=&quot;股票交易问题通解小结&quot;&gt;&lt;/a&gt;股票交易问题通解小结&lt;/h1&gt;&lt;p&gt;本文的主要部分来自于leetcode讨论区,后面加上了一点个人的理解和扩展延伸，Leetcode中的股票交易问题共有下列几道：&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+github搭建个人博客问题总结</title>
    <link href="http://yoursite.com/2018/08/21/Hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/08/21/Hexo+github搭建个人博客问题总结/</id>
    <published>2018-08-21T01:58:44.000Z</published>
    <updated>2018-08-22T10:14:19.065Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Hexo-github搭建个人博客问题总结"><a href="#Hexo-github搭建个人博客问题总结" class="headerlink" title="Hexo+github搭建个人博客问题总结"></a>Hexo+github搭建个人博客问题总结</h4><p>总结Hexo+github搭建个人博客过程中两个费时较长的问题及其解决方法</p><a id="more"></a><h2 id="问题1：本地同时配置多个github账号导致博客部署失败"><a href="#问题1：本地同时配置多个github账号导致博客部署失败" class="headerlink" title="问题1：本地同时配置多个github账号导致博客部署失败"></a>问题1：本地同时配置多个github账号导致博客部署失败</h2><p>因为本地同时配置有两个github账号，在Hexo+github搭建个人博客部署到账号A成功后用相同方式部署到账号B时执行hexo d时出现问题</p><pre><code>remote: Permission to B/B.github.io.git denied to A.fatal: unable to access &apos;https://github.com/B/B.github.io.git/&apos;: The requested URL returned error: 403FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: remote: Permission to B/B.github.io.git denied to A.fatal: unable to access &apos;https://github.com/B/B.github.io.git/&apos;: The requested URL returned error: 403</code></pre><p>原因是在缺省设置下，github page只有该page对应的账号A才能push，为了解决该问题，在hexo的 _config.yml部署的repo地址改用ssh而不是用https，同时对ssh地址做Host别名替换，原有repo地址为repository: <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:Name/Name.github.io.git，替换为repository: git@B:Name/Name.github.io.git。<br>在原有的~.ssh\config中配置内容如下：</p><pre><code># 该配置用于账户AHost A # Host 服务器别名HostName github.com  # HostName 服务器ip地址或机器名User A # User连接服务器的用户名IdentityFile C:\Users\yiye\.ssh\id_rsa # IdentityFile 密匙文件的具体路径# 该配置用于账户BHost B # Host 服务器别名HostName github.com # HostName 服务器ip地址或机器名User B # User连接服务器的用户名IdentityFile C:\Users\yiye\.ssh\id_rsa_new # IdentityFile 密匙文件的具体路径</code></pre><p>这样ssh解析的时候就会自动把B转换为 github.com，push的时候系统就会根据不同的仓库地址使用不同的账号提交</p><h2 id="问题2：历史删除文件仍存在于repository中"><a href="#问题2：历史删除文件仍存在于repository中" class="headerlink" title="问题2：历史删除文件仍存在于repository中"></a>问题2：历史删除文件仍存在于repository中</h2><p>原本删除的文件仍存在于生成的blog\public中，这是因为没有执行hexo clean命令</p><h2 id="问题3：Hexo-deploy-发布不成功"><a href="#问题3：Hexo-deploy-发布不成功" class="headerlink" title="问题3：Hexo deploy 发布不成功"></a>问题3：Hexo deploy 发布不成功</h2><p>始终停留在</p><pre><code>nothing to commit (working directory clean)</code></pre><p>Hexo的issue中有提到这个问题哦，原因就是第一次设置错了，然后即使正确设置 Repository 再次 Deploy 的时候它也会报错：nothing to commit, working directory clean；error: src refspec master does not match any。所以，当重新设置 Repo 的时候要把 .deploy_git/ 文件夹删掉，让 Hexo 再次初始化，否则 Hexo 只是执行 push 操作，所以会一直报错。解决方法是删除.deploy_git</p><pre><code>rm -rf .deploy_githexo generaterhexo deploy</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Hexo-github搭建个人博客问题总结&quot;&gt;&lt;a href=&quot;#Hexo-github搭建个人博客问题总结&quot; class=&quot;headerlink&quot; title=&quot;Hexo+github搭建个人博客问题总结&quot;&gt;&lt;/a&gt;Hexo+github搭建个人博客问题总结&lt;/h4&gt;&lt;p&gt;总结Hexo+github搭建个人博客过程中两个费时较长的问题及其解决方法&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="Github" scheme="http://yoursite.com/tags/Github/"/>
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>C++基础概念II</title>
    <link href="http://yoursite.com/2018/08/21/C++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5II/"/>
    <id>http://yoursite.com/2018/08/21/C++基础概念II/</id>
    <published>2018-08-21T01:58:44.000Z</published>
    <updated>2018-08-22T10:14:14.908Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-基础概念II"><a href="#C-基础概念II" class="headerlink" title="C++基础概念II"></a>C++基础概念II</h1><p>总结C++基础概念</p><h2 id="1-C-的四种强制类型转换关键字，及它们的特点和使用的场合"><a href="#1-C-的四种强制类型转换关键字，及它们的特点和使用的场合" class="headerlink" title="1.C++的四种强制类型转换关键字，及它们的特点和使用的场合"></a>1.C++的四种强制类型转换关键字，及它们的特点和使用的场合</h2><a id="more"></a><p>C语言中的强制类型转换可以随意的转换我们想要的类型了,格式如下</p><pre><code>(类型) 变量名;</code></pre><p>为什么c++还要引入新的4种类型转换呢?</p><p>  这是因为新的类型转换控制符可以很好的控制类型转换的过程,允许控制各种类型不同的转换.</p><p>  还有一点好处是C++的类型转换控制符能告诉程序员或读者我们这个转换的目的是什么,我们<br> 只要看一下代码的类型转换控制符,就能明白我们想要达到什么样的目的.</p><h3 id="1-static-cast-lt-T-gt-content-静态转换-在编译期间处理"><a href="#1-static-cast-lt-T-gt-content-静态转换-在编译期间处理" class="headerlink" title="1)static_cast &lt;T*&gt; (content)  静态转换.在编译期间处理"></a>1)static_cast &lt;T*&gt; (content)  静态转换.在编译期间处理</h3><p>   它主要用于C++中内置的基本数据类型之间的转换.但是没有运行时类型的检测来保证转换的安全性.</p><p>   为什么需要static_cast类型的转换?</p><h4 id="a-用于基类和子类之间的指针或引用的转换。"><a href="#a-用于基类和子类之间的指针或引用的转换。" class="headerlink" title="a.用于基类和子类之间的指针或引用的转换。"></a>a.用于基类和子类之间的指针或引用的转换。</h4><p>这种转换把子类的指针或引用转换为基类表示是安全的;进行下行转换,把基类的指针或引用转换为子类表示时,由于没有进行动态类型检测,所以是不安全的;</p><h4 id="b-把void类型的指针转换成目标类型的指针-不安全"><a href="#b-把void类型的指针转换成目标类型的指针-不安全" class="headerlink" title="b.把void类型的指针转换成目标类型的指针(不安全)."></a>b.把void类型的指针转换成目标类型的指针(不安全).</h4><h4 id="c-用于内置的基本的数据类型之间的转换"><a href="#c-用于内置的基本的数据类型之间的转换" class="headerlink" title="c.用于内置的基本的数据类型之间的转换."></a>c.用于内置的基本的数据类型之间的转换.</h4><h4 id="d-把任何类型的表达式转换成void类型的"><a href="#d-把任何类型的表达式转换成void类型的" class="headerlink" title="d.把任何类型的表达式转换成void类型的."></a>d.把任何类型的表达式转换成void类型的.</h4><p>   注意:static_cast不会转换掉content的const,volatile,__unaligned属性</p><h3 id="2-static-const-lt-T-gt-content-去常转换-编译时执行"><a href="#2-static-const-lt-T-gt-content-去常转换-编译时执行" class="headerlink" title="2)static_const&lt;T*&gt;(content):去常转换;编译时执行;"></a>2)static_const&lt;T*&gt;(content):去常转换;编译时执行;</h3><p>  它主要作用同一个类型之间的去常和添加常属性之间的转换.不能用做不同的类型之间的转换.</p><p>  它可以把一个不是常属性的转换成常属性的,同时它也可以对一个本是常属性的类型进行去常.</p><h3 id="3-dynamic-cast-lt-T-gt-content-动态类型转换-也是向下安全转型-是在运行的时候执行"><a href="#3-dynamic-cast-lt-T-gt-content-动态类型转换-也是向下安全转型-是在运行的时候执行" class="headerlink" title="3)dynamic_cast&lt;T*&gt;(content) 动态类型转换;也是向下安全转型;是在运行的时候执行;"></a>3)dynamic_cast&lt;T*&gt;(content) 动态类型转换;也是向下安全转型;是在运行的时候执行;</h3><p>   通常用于基类和派生类之间的转换.转换时会进行类型安全检查。</p><h4 id="a"><a href="#a" class="headerlink" title="a."></a>a.</h4><p>不能用于内置的基本数据类型之间的转换.</p><h4 id="b"><a href="#b" class="headerlink" title="b."></a>b.</h4><p>dynamic_cast转换成功的话返回的是类的指针或引用,失败返回null;</p><h4 id="c"><a href="#c" class="headerlink" title="c."></a>c.</h4><p>dynamic_cast进行的转换的时候基类中一定要有虚函数,因为只有类中有了虚函数, 才说明它希望让基类指针或引用指向其派生类对象的情况,这样才有意义.这是由于运行时类型检查需要运行时类型的信息,而这些信息存储在虚函数表中.</p><h4 id="d"><a href="#d" class="headerlink" title="d."></a>d.</h4><p>在类的转换时,在类层次间进行转换的时候,dynamic_cast和static_cast进行上行转换的时候效果是一样的；但是在进行下行转换的时候,dynamic_cast会进行类型检查所以它更安全.它可以让指向基类的指针转换为指向其子类的指针或是其兄弟类的指针;</p><h3 id="4-reinterpret-cast-lt-T-gt-content-重解释类型转换"><a href="#4-reinterpret-cast-lt-T-gt-content-重解释类型转换" class="headerlink" title="4)reinterpret_cast&lt;T*&gt;(content)重解释类型转换;"></a>4)reinterpret_cast&lt;T*&gt;(content)重解释类型转换;</h3><p>   它有着和C风格强制类型转换同样的功能;它可以转化任何的内置数据类型为其他的类型, 同时它也可以把任何类型的指针转化为其他的类型;它的机理是对二进制数据进行重新的的解释,不会改变原来的格式,而static_cast会改变原来的格式;</p><h2 id="2-请说出static和const关键字尽可能多的作用"><a href="#2-请说出static和const关键字尽可能多的作用" class="headerlink" title="2.请说出static和const关键字尽可能多的作用"></a>2.请说出static和const关键字尽可能多的作用</h2><h3 id="static关键字至少有下列n个作用："><a href="#static关键字至少有下列n个作用：" class="headerlink" title="static关键字至少有下列n个作用："></a>static关键字至少有下列n个作用：</h3><h4 id="（1）"><a href="#（1）" class="headerlink" title="（1）"></a>（1）</h4><p>函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；</p><h4 id="（2）"><a href="#（2）" class="headerlink" title="（2）"></a>（2）</h4><p>在模块内的static全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；</p><h4 id="（3）"><a href="#（3）" class="headerlink" title="（3）"></a>（3）</h4><p>在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；</p><h4 id="（4）"><a href="#（4）" class="headerlink" title="（4）"></a>（4）</h4><p>在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；</p><h4 id="（5）"><a href="#（5）" class="headerlink" title="（5）"></a>（5）</h4><p>在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。</p><h3 id="const关键字至少有下列n个作用："><a href="#const关键字至少有下列n个作用：" class="headerlink" title="const关键字至少有下列n个作用："></a>const关键字至少有下列n个作用：</h3><h4 id="（1）-1"><a href="#（1）-1" class="headerlink" title="（1）"></a>（1）</h4><p>欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；</p><h4 id="（2）-1"><a href="#（2）-1" class="headerlink" title="（2）"></a>（2）</h4><p>对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；</p><h4 id="（3）-1"><a href="#（3）-1" class="headerlink" title="（3）"></a>（3）</h4><p>在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；</p><h4 id="（4）-1"><a href="#（4）-1" class="headerlink" title="（4）"></a>（4）</h4><p>对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量；</p><h4 id="（5）-1"><a href="#（5）-1" class="headerlink" title="（5）"></a>（5）</h4><p>对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。例如：<br>const classA operator<em>(const classA&amp; a1,const classA&amp; a2);<br>　　operator</em>的返回结果必须是一个const对象。如果不是，这样的变态代码也不会编译出错：</p><p>classA a, b, c;<br>(a <em> b) = c; // 对a</em>b的结果赋值<br>　　操作(a * b) = c显然不符合编程者的初衷，也没有任何意义。</p><p>剖析：<br>　　惊讶吗？小小的static和const居然有这么多功能，我们能回答几个？如果只能回答1~2个，那还真得闭关再好好修炼修炼。</p><p>　　这个题可以考查面试者对程序设计知识的掌握程度是初级、中级还是比较深入，没有一定的知识广度和深度，不可能对这个问题给出全面的解答。大多数人只能回答出static和const关键字的部分功能。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;C-基础概念II&quot;&gt;&lt;a href=&quot;#C-基础概念II&quot; class=&quot;headerlink&quot; title=&quot;C++基础概念II&quot;&gt;&lt;/a&gt;C++基础概念II&lt;/h1&gt;&lt;p&gt;总结C++基础概念&lt;/p&gt;
&lt;h2 id=&quot;1-C-的四种强制类型转换关键字，及它们的特点和使用的场合&quot;&gt;&lt;a href=&quot;#1-C-的四种强制类型转换关键字，及它们的特点和使用的场合&quot; class=&quot;headerlink&quot; title=&quot;1.C++的四种强制类型转换关键字，及它们的特点和使用的场合&quot;&gt;&lt;/a&gt;1.C++的四种强制类型转换关键字，及它们的特点和使用的场合&lt;/h2&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>前言</title>
    <link href="http://yoursite.com/2017/11/16/%E5%89%8D%E8%A8%80/"/>
    <id>http://yoursite.com/2017/11/16/前言/</id>
    <published>2017-11-16T13:14:20.000Z</published>
    <updated>2018-08-22T10:48:55.651Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>附上最近感触很深的一段话作为博客的序章</p><p>　　生命过程中能否成就事业，关键要看意志力的性质和力量，这一点比其他任何因素都来得重要．整天呼喊着＂给我机会，给我机会＂的人本质上是脆弱的，甚至是不堪一击的，因为在能够主宰一切的意志力面前，机会多得数不胜数．平庸和默默无闻很大程度上都是自己造成的，要抱怨只能抱怨自己．</p><a id="more"></a><p>　　格莱斯顿对＂平凡的人＂抱着极高的期望，他真诚的写道：＂从某种意义上说，世界上的每个人与生俱来就具备成就非凡业绩的素质，每个人都是如此．不只是那些天资聪颖，才华横溢的人，也不只是那些敏捷伶俐，遇事沉着的人，能够成就事业；那些木讷寡言，不善圆通的人，甚至那些资质鲁钝，反应迟缓的人，也能成就事业．＂<br>　　每一位受过教育的正常人都在心里深深地明白，在人生的旅途中只要采取适当的行为，就容易使自己成为了不起的人－－至少可以赢得某种程度的成功．但是，＂放松和惰性＂是事物的自然法则，他往往逐渐地屈服于这条法则的支配，慢慢地消磨了自己的棱角和锋芒，变得胸无大志，得过且过．他变得慵懒闲散，再也不能因为心中的高尚目标而受到激励，去发奋实现自己的梦想．然而，正是在这个时候，意志力应该一刻不停地发挥作用．</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;附上最近感触很深的一段话作为博客的序章&lt;/p&gt;
&lt;p&gt;　　生命过程中能否成就事业，关键要看意志力的性质和力量，这一点比其他任何因素都来得重要．整天呼喊着＂给我机会，给我机会＂的人本质上是脆弱的，甚至是不堪一击的，因为在能够主宰一切的意志力面前，机会多得数不胜数．平庸和默默无闻很大程度上都是自己造成的，要抱怨只能抱怨自己．&lt;/p&gt;
    
    </summary>
    
      <category term="2017年11月" scheme="http://yoursite.com/categories/2017%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="blog" scheme="http://yoursite.com/tags/blog/"/>
    
  </entry>
  
</feed>
