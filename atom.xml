<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-28T15:59:54.966Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>139. 单词拆分</title>
    <link href="http://yoursite.com/2020/05/28/139.%20%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/"/>
    <id>http://yoursite.com/2020/05/28/139. 单词拆分/</id>
    <published>2020-05-28T15:39:12.000Z</published>
    <updated>2020-05-28T15:59:54.966Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词</p><a id="more"></a><h1 id="📖题目描述："><a href="#📖题目描述：" class="headerlink" title="📖题目描述："></a>📖题目描述：</h1><p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p><p>说明：</p><p>拆分时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。<br>示例 1：</p><pre><code>输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]输出: true解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</code></pre><p>示例 2：</p><pre><code>输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]输出: true解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。     注意你可以重复使用字典中的单词。</code></pre><p>示例 3：</p><pre><code>输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]输出: false</code></pre><h1 id="📖方法一：暴力求解"><a href="#📖方法一：暴力求解" class="headerlink" title="📖方法一：暴力求解"></a>📖方法一：暴力求解</h1><p><strong>算法</strong></p><p>最简单的实现方法是用递归和回溯。为了找到解，我们可以检查字典单词中每一个单词的可能前缀，如果在字典中出现过，那么去掉这个前缀后剩余部分回归调用。同时，如果某次函数调用中发现整个字符串都已经被拆分且在字典中出现过了，函数就返回 <code>true</code> 。</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> word_Break(s, <span class="keyword">new</span> HashSet(wordDict), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">word_Break</span><span class="params">(String s, Set&lt;String&gt; wordDict, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == s.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> end = start + <span class="number">1</span>; end &lt;= s.length(); end++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (wordDict.contains(s.substring(start, end)) &amp;&amp; word_Break(s, wordDict, end)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(n^n)</em> 。考虑最坏情况 <em>s</em> = aaaaaaa 。每一个前缀都在字典中，此时回溯树的复杂度会达到 <em>n^n</em> 。</li><li>空间复杂度：<em>O(n)</em> 。回溯树的深度最深达到 <em>n</em> 。</li></ul><h1 id="📖方法二：记忆化回溯"><a href="#📖方法二：记忆化回溯" class="headerlink" title="📖方法二：记忆化回溯"></a>📖方法二：记忆化回溯</h1><p><strong>算法</strong></p><p>在先前的方法中，我们看到许多函数调用都是冗余的，也就是我们会对相同的字符串调用多次回溯函数。为了避免这种情况，我们可以使用记忆化的方法，其中一个 <em>memo</em> 数组会被用来保存子问题的结果。每当访问到已经访问过的后缀串，直接用 <em>memo</em> 数组中的值返回而不需要继续调用函数。</p><p>通过记忆化，许多冗余的子问题可以极大被优化，回溯树得到了剪枝，因此极大减小了时间复杂度。</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> word_Break(s, <span class="keyword">new</span> HashSet(wordDict), <span class="number">0</span>, <span class="keyword">new</span> Boolean[s.length()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">word_Break</span><span class="params">(String s, Set&lt;String&gt; wordDict, <span class="keyword">int</span> start, Boolean[] memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == s.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo[start] != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[start];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> end = start + <span class="number">1</span>; end &lt;= s.length(); end++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (wordDict.contains(s.substring(start, end)) &amp;&amp; word_Break(s, wordDict, end, memo)) &#123;</span><br><span class="line">                <span class="keyword">return</span> memo[start] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[start] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n^2)</em> 。回溯树的大小最多达到 <em>n^2</em> 。</p></li><li><p>空间复杂度：<em>O(n)</em> 。回溯树的深度可以达到 <em>n</em> 级别。</p></li></ul><h1 id="📖方法-3：使用宽度优先搜索"><a href="#📖方法-3：使用宽度优先搜索" class="headerlink" title="📖方法 3：使用宽度优先搜索"></a>📖方法 3：使用宽度优先搜索</h1><p><strong>算法</strong></p><p>另一个方法是使用宽度优先搜索。将字符串可视化成一棵树，每一个节点是用 <em>end</em> 为结尾的前缀字符串。当两个节点之间的所有节点都对应了字典中一个有效字符串时，两个节点可以被连接。</p><p>为了形成这样的一棵树，我们从给定字符串的第一个字符开始（比方说 <em>s</em> ），将它作为树的根部，开始找所有可行的以该字符为首字符的可行子串。进一步的，将每一个子字符串的结束字符的下标（比方说 <em>i</em>）放在队列的尾部供宽搜后续使用。</p><p>每次我们从队列最前面弹出一个元素，并考虑字符串 <em>s(i+1,end)</em> 作为原始字符串，并将当前节点作为树的根。这个过程会一直重复，直到队列中没有元素。如果字符串最后的元素可以作为树的一个节点，这意味着初始字符串可以被拆分成多个给定字典中的子字符串。</p><p>树的生成过程可以参考这个例子：</p><p>  <a href="https://pic.leetcode-cn.com/b874378afb2d9bc171a396e778cfeb25a6ee1368a374124de3d9990b820e80e6-image.png" target="_blank" rel="noopener">1</a>  <a href="https://pic.leetcode-cn.com/3bcb1c59ef2489c034310c76c86b2cfd707beed96f629d8be51e2ae96287d2c5-image.png" target="_blank" rel="noopener">2</a>  <a href="https://pic.leetcode-cn.com/cb9b4a35d26b71346da25f9f6cab1926dfb7cb9d3cb8171a750f8d012f081fff-image.png" target="_blank" rel="noopener">3</a>  <a href="https://pic.leetcode-cn.com/bd128522a7fc7b3426c1411cbc4c729018b53f814f74eb97fc25003bfe282eb4-image.png" target="_blank" rel="noopener">4</a>  <a href="https://pic.leetcode-cn.com/89989e53118ece2da9f0fd79c56b1beff07a6bdabd8ee9c1b0492f93d8eec000-image.png" target="_blank" rel="noopener">5</a>  <a href="https://pic.leetcode-cn.com/7e338635849ebb3ee872bcf8ddc14a56ece8bc2d4486cef984980fa8d53b7571-image.png" target="_blank" rel="noopener">6</a>  <a href="https://pic.leetcode-cn.com/13748edb1a2cab3f7636a0af409de256aa1048ff976dff44627c118b9f9b5fbb-image.png" target="_blank" rel="noopener">7</a> </p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; wordDictSet=<span class="keyword">new</span> HashSet(wordDict);</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line">        queue.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> start = queue.remove();</span><br><span class="line">            <span class="keyword">if</span> (visited[start] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> end = start + <span class="number">1</span>; end &lt;= s.length(); end++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (wordDictSet.contains(s.substring(start, end))) &#123;</span><br><span class="line">                        queue.add(end);</span><br><span class="line">                        <span class="keyword">if</span> (end == s.length()) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                visited[start] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n^2)</em> 。对于每个开始的位置，搜索会直到给定字符串的尾部结束。</p></li><li><p>空间复杂度：<em>O(n)</em> 。队列的大小最多 <em>n</em> 。</p></li></ul><h1 id="📖方法-4：使用动态规划"><a href="#📖方法-4：使用动态规划" class="headerlink" title="📖方法 4：使用动态规划"></a>📖方法 4：使用动态规划</h1><p><strong>算法</strong></p><p>这个方法的想法是对于给定的字符串（<em>s</em>）可以被拆分成子问题 <em>s1</em> 和 <em>s2</em> 。如果这些子问题都可以独立地被拆分成符合要求的子问题，那么整个问题 <em>s</em> 也可以满足。也就是，如果 “catsanddog” 可以拆分成两个子字符串 “catsand” 和 “dog” 。子问题 “catsand” 可以进一步拆分成 “cats” 和 “and” ，这两个独立的部分都是字典的一部分，所以 “catsand” 满足题意条件，再往前， “catsand” 和 “dog” 也分别满足条件，所以整个字符串 “catsanddog” 也满足条件。</p><p>现在，我们考虑 dp 数组求解的过程。我们使用 <em>n+1</em> 大小数组的dp ，其中 <em>n</em> 是给定字符串的长度。我们也使用 2 个下标指针 <em>i</em> 和 <em>j</em> ，其中 <em>i</em> 是当前字符串从头开始的子字符串（<em>s’*）的长度， *j</em> 是当前子字符串（<em>s’*）的拆分位置，拆分成 *s’(0,j)</em> 和 <em>s’(j+1,i)</em> 。</p><p>为了求出 dp 数组，我们初始化dp[0] 为 true  ，这是因为空字符串总是字典的一部分。 dp数组剩余的元素都初始化为false。</p><p>我们用下标 <em>i</em> 来考虑所有从当前字符串开始的可能的子字符串。对于每一个子字符串，我们通过下标 <em>j</em> 将它拆分成 <em>s1’</em> 和 <em>s2’</em> （注意 <em>i</em> 现在指向 <em>s2’</em> 的结尾）。为了将dp[i]数组求出来，我们依次检查每个dp[j]是否为 true ，也就是子字符串 <em>s1’</em> 是否满足题目要求。如果满足，我们接下来检查 <em>s2’</em> 是否在字典中。如果包含，我们接下来检查 <em>s2’</em> 是否在字典中，如果两个字符串都满足要求，我们让 true 为true，否则令其为false。</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; wordDictSet=<span class="keyword">new</span> HashSet(wordDict);</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &amp;&amp; wordDictSet.contains(s.substring(j, i))) &#123;</span><br><span class="line">                    dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n^2)</em> 。求出 dp 数组需要两重循环。</p></li><li><p>空间复杂度：<em>O(n)</em> 。 <em>dp</em> 数组的长度是 <em>n+1</em> 。</p></li></ul><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://leetcode-cn.com/problems/word-break/solution/dan-ci-chai-fen-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/word-break/solution/dan-ci-chai-fen-by-leetcode/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词&lt;/p&gt;
    
    </summary>
    
      <category term="2020年5月" scheme="http://yoursite.com/categories/2020%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>5. 最长回文子串</title>
    <link href="http://yoursite.com/2020/05/28/5.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/2020/05/28/5. 最长回文子串/</id>
    <published>2020-05-28T11:50:12.000Z</published>
    <updated>2020-05-28T15:18:56.865Z</updated>
    
    <content type="html"><![CDATA[<p>找到字符串中最长的回文子串，提供了「动态规划』问题的思考路径</p><a id="more"></a><h1 id="📖题目描述："><a href="#📖题目描述：" class="headerlink" title="📖题目描述："></a>📖题目描述：</h1><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><p>示例 1：</p><pre><code>输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。</code></pre><p>示例 2：</p><pre><code>输入: &quot;cbbd&quot;输出: &quot;bb&quot;</code></pre><p>这道题上次做还是2017年8月1日，今天重刷感觉还是没吃透，下面的方法和思路借鉴自牛人的题解，写的非常漂亮，比官方题解还好，这是他的博客推荐多学习一个：<a href="https://liweiwei1419.gitee.io/leetcode-algo/#indexCard" target="_blank" rel="noopener">https://liweiwei1419.gitee.io/leetcode-algo/#indexCard</a></p><h1 id="📖解题思路"><a href="#📖解题思路" class="headerlink" title="📖解题思路"></a>📖解题思路</h1><ul><li>以下解法中「暴力算法」是基础，「动态规划」必须掌握，「中心扩散」方法要会写；</li><li>「Manacher 算法」仅用于扩宽视野，绝大多数的算法面试中，面试官都不会要求写这个方法（除非面试者是竞赛选手）。</li></ul><h1 id="📖方法一：暴力匹配-（Brute-Force）"><a href="#📖方法一：暴力匹配-（Brute-Force）" class="headerlink" title="📖方法一：暴力匹配 （Brute Force）"></a>📖方法一：暴力匹配 （Brute Force）</h1><ul><li>根据回文子串的定义，枚举所有长度大于等于 <em>2</em> 的子串，依次判断它们是否是回文；</li><li>在具体实现时，可以只针对大于“当前得到的最长回文子串长度”的子串进行“回文验证”；</li><li>在记录最长回文子串的时候，可以只记录“当前子串的起始位置”和“子串长度”，不必做截取。这一步我们放在后面的方法中实现。</li></ul><p>说明：暴力解法时间复杂度高，但是思路清晰、编写简单。由于编写正确性的可能性很大，<strong>可以使用暴力匹配算法检验我们编写的其它算法是否正确</strong>。优化的解法在很多时候，是基于“暴力解法”，以空间换时间得到的，因此思考清楚暴力解法，分析其缺点，很多时候能为我们打开思路。</p><p><strong>参考代码 1</strong>：Java 代码正常运行，C++ 代码超出内存限制，Python 代码超时。</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// s.charAt(i) 每次都会检查数组下标越界，因此先转换成字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] charArray = s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举所有长度大于 1 的子串 charArray[i..j]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - i + <span class="number">1</span> &gt; maxLen &amp;&amp; validPalindromic(charArray, i, j)) &#123;</span><br><span class="line">                    maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                    begin = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(begin, begin + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证子串 s[left..right] 是否为回文串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validPalindromic</span><span class="params">(<span class="keyword">char</span>[] charArray, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (charArray[left] != charArray[right]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 暴力匹配（超时）</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="comment"># 特判</span></span><br><span class="line">        size = len(s)</span><br><span class="line">        <span class="keyword">if</span> size &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">        max_len = <span class="number">1</span></span><br><span class="line">        res = s[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 枚举所有长度大于等于 2 的子串</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(size - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, size):</span><br><span class="line">                <span class="keyword">if</span> j - i + <span class="number">1</span> &gt; max_len <span class="keyword">and</span> self.__valid(s, i, j):</span><br><span class="line">                    max_len = j - i + <span class="number">1</span></span><br><span class="line">                    res = s[i:j + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__valid</span><span class="params">(self, s, left, right)</span>:</span></span><br><span class="line">        <span class="comment"># 验证子串 s[left, right] 是否为回文串</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">if</span> s[left] != s[right]:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 超时测试用例</span></span><br><span class="line"><span class="comment"># "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 验证子串 s[left, right] 是否为回文串</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[left] != s[right]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特判</span></span><br><span class="line">        <span class="keyword">int</span> size = s.size();</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">string</span> res = s.substr(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举所有长度大于等于 2 的子串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; size; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - i + <span class="number">1</span> &gt; maxLen &amp;&amp; valid(s, i, j)) &#123;</span><br><span class="line">                    maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                    res = s.substr(i, maxLen);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 超出内存限制，测试用例</span></span><br><span class="line"><span class="comment">// "zudfweormatjycujjirzjpyrmaxurectxrtqedmmgergwdvjmjtstdhcihacqnothgttgqfywcpgnuvwglvfiuxteopoyizgehkwuvvkqxbnufkcbodlhdmbqyghkojrgokpwdhtdrwmvdegwycecrgjvuexlguayzcammupgeskrvpthrmwqaqsdcgycdupykppiyhwzwcplivjnnvwhqkkxildtyjltklcokcrgqnnwzzeuqioyahqpuskkpbxhvzvqyhlegmoviogzwuiqahiouhnecjwysmtarjjdjqdrkljawzasriouuiqkcwwqsxifbndjmyprdozhwaoibpqrthpcjphgsfbeqrqqoqiqqdicvybzxhklehzzapbvcyleljawowluqgxxwlrymzojshlwkmzwpixgfjljkmwdtjeabgyrpbqyyykmoaqdambpkyyvukalbrzoyoufjqeftniddsfqnilxlplselqatdgjziphvrbokofvuerpsvqmzakbyzxtxvyanvjpfyvyiivqusfrsufjanmfibgrkwtiuoykiavpbqeyfsuteuxxjiyxvlvgmehycdvxdorpepmsinvmyzeqeiikajopqedyopirmhymozernxzaueljjrhcsofwyddkpnvcvzixdjknikyhzmstvbducjcoyoeoaqruuewclzqqqxzpgykrkygxnmlsrjudoaejxkipkgmcoqtxhelvsizgdwdyjwuumazxfstoaxeqqxoqezakdqjwpkrbldpcbbxexquqrznavcrprnydufsidakvrpuzgfisdxreldbqfizngtrilnbqboxwmwienlkmmiuifrvytukcqcpeqdwwucymgvyrektsnfijdcdoawbcwkkjkqwzffnuqituihjaklvthulmcjrhqcyzvekzqlxgddjoir"</span></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<em>O(N^3)*，这里 *N</em> 是字符串的长度，枚举字符串的左边界、右边界，然后继续验证子串是否是回文子串，这三种操作都与 <em>N</em> 相关；</li><li>空间复杂度：<em>O(1)</em>，只使用到常数个临时变量，与字符串长度无关。</li></ul><h1 id="📖方法二：动态规划"><a href="#📖方法二：动态规划" class="headerlink" title="📖方法二：动态规划"></a>📖方法二：动态规划</h1><p>下面是「动态规划』问题的思考路径，供大家参考。</p><p><strong>特别说明</strong>：</p><ul><li>以下「动态规划」的解释只帮助大家了解「动态规划」问题的基本思想；</li><li>「动态规划」问题可以难到非常难，在学习的时候建议不要钻到特别难的问题中去；</li><li>掌握经典的动态规划问题的解法，理解状态的定义的由来、会列出状态转移方程；</li><li>然后再配合适当难度的问题的练习；</li><li>有时间和感兴趣的话可以做一些不太常见的类型的问题，拓宽视野；</li><li>「动态规划」讲得比较好的经典书籍是《算法导论》。</li></ul><p> <a href="https://pic.leetcode-cn.com/1f95da43d1bdeebdd1213bb804034ddc5f906dc61451cd63f2b5ab5d0eb33b33-%E3%80%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%8D%E9%97%AE%E9%A2%98%E6%80%9D%E8%80%83%E6%96%B9%E5%90%91.png" target="_blank" rel="noopener">「动态规划」问题思考方向.png</a></p><p>1、思考状态（重点）</p><ul><li>状态的定义，先尝试「题目问什么，就把什么设置为状态」；</li><li>然后思考「状态如何转移」，如果「状态转移方程」不容易得到，尝试修改定义，目的依然是为了方便得到「状态转移方程」。</li></ul><blockquote><p>「状态转移方程」是原始问题的不同规模的子问题的联系。即大问题的最优解如何由小问题的最优解得到。</p></blockquote><p>2、思考状态转移方程（核心、难点）</p><ul><li><p>状态转移方程是非常重要的，是动态规划的核心，也是难点；</p></li><li><p>常见的推导技巧是：分类讨论。即：对状态空间进行分类；</p></li><li><p>归纳「状态转移方程」是一个很灵活的事情，通常是具体问题具体分析；</p></li><li><p>除了掌握经典的动态规划问题以外，还需要多做题；</p></li><li><p>如果是针对面试，请自行把握难度。掌握常见问题的动态规划解法，理解动态规划解决问题，是从一个小规模问题出发，逐步得到大问题的解，并记录中间过程；</p></li><li><p>「动态规划」方法依然是「空间换时间」思想的体现，常见的解决问题的过程很像在「填表」。</p></li></ul><p>3、思考初始化</p><p>初始化是非常重要的，一步错，步步错。初始化状态一定要设置对，才可能得到正确的结果。</p><ul><li><p>角度 1：直接从状态的语义出发；</p></li><li><p>角度 2：如果状态的语义不好思考，就考虑「状态转移方程」的边界需要什么样初始化的条件；</p></li><li><p>角度 3：从「状态转移方程」方程的下标看是否需要多设置一行、一列表示「哨兵」（sentinel），这样可以避免一些特殊情况的讨论。</p></li></ul><p>4、思考输出</p><p>有些时候是最后一个状态，有些时候可能会综合之前所有计算过的状态。</p><p>5、思考优化空间（也可以叫做表格复用）</p><ul><li>「优化空间」会使得代码难于理解，且是的「状态」丢失原来的语义，初学的时候可以不一步到位。先把代码写正确是更重要；</li><li>「优化空间」在有一种情况下是很有必要的，那就是状态空间非常庞大的时候（处理海量数据），此时空间不够用，就必须「优化空间」；</li><li>非常经典的「优化空间」的典型问题是「0-1 背包」问题和「完全背包」问题。</li></ul><hr><p>（下面是这道问题「动态规划」方法的分析）</p><p>这道题比较烦人的是判断回文子串。因此需要一种能够快速判断原字符串的所有子串是否是回文子串的方法，于是想到了「动态规划」。</p><p>「动态规划」的一个关键的步骤是想清楚「状态如何转移」。事实上，「回文」天然具有「状态转移」性质。</p><ul><li>一个回文去掉两头以后，剩下的部分依然是回文（这里暂不讨论边界情况）；</li></ul><p>依然从回文串的定义展开讨论：</p><ul><li>如果一个字符串的头尾两个字符都不相等，那么这个字符串一定不是回文串；</li><li>如果一个字符串的头尾两个字符相等，才有必要继续判断下去。<ul><li>如果里面的子串是回文，整体就是回文串；</li><li>如果里面的子串不是回文串，整体就不是回文串。</li></ul></li></ul><p>即：<strong>在头尾字符相等的情况下，里面子串的回文性质据定了整个子串的回文性质</strong>，这就是状态转移。因此可以把「状态」定义为原字符串的一个子串是否为回文子串。</p><h4 id="第-1-步：定义状态"><a href="#第-1-步：定义状态" class="headerlink" title="第 1 步：定义状态"></a>第 1 步：定义状态</h4><p><code>dp[i][j]</code> 表示子串 <code>s[i..j]</code> 是否为回文子串，这里子串 <code>s[i..j]</code> 定义为左闭右闭区间，可以取到 <code>s[i]</code> 和 <code>s[j]</code>。</p><h4 id="第-2-步：思考状态转移方程"><a href="#第-2-步：思考状态转移方程" class="headerlink" title="第 2 步：思考状态转移方程"></a>第 2 步：思考状态转移方程</h4><p>在这一步分类讨论（根据头尾字符是否相等），根据上面的分析得到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><p>「动态规划」事实上是在填一张二维表格，由于构成子串，因此 <code>i</code> 和 <code>j</code> 的关系是 <code>i &lt;= j</code> ，因此，只需要填这张表格对角线以上的部分。</p></li><li><p>看到 <code>dp[i + 1][j - 1]</code> 就得考虑边界情况。</p></li></ul><p>边界条件是：表达式 <code>[i + 1, j - 1]</code> 不构成区间，即长度严格小于 <code>2</code>，即 <code>j - 1 - (i + 1) + 1 &lt; 2</code> ，整理得 <code>j - i &lt; 3</code>。</p><p>这个结论很显然：<code>j - i &lt; 3</code> 等价于 <code>j - i + 1 &lt; 4</code>，即当子串 <code>s[i..j]</code> 的长度等于 <code>2</code> 或者等于 <code>3</code> 的时候，其实只需要判断一下头尾两个字符是否相等就可以直接下结论了。</p><ul><li>如果子串 <code>s[i + 1..j - 1]</code> 只有 1 个字符，即去掉两头，剩下中间部分只有 <em>1</em> 个字符，显然是回文；</li><li>如果子串 <code>s[i + 1..j - 1]</code> 为空串，那么子串 <code>s[i, j]</code> 一定是回文子串。</li></ul><p>因此，在 <code>s[i] == s[j]</code> 成立和 <code>j - i &lt; 3</code> 的前提下，直接可以下结论，<code>dp[i][j] = true</code>，否则才执行状态转移。</p><h4 id="第-3-步：考虑初始化"><a href="#第-3-步：考虑初始化" class="headerlink" title="第 3 步：考虑初始化"></a>第 3 步：考虑初始化</h4><p>初始化的时候，单个字符一定是回文串，因此把对角线先初始化为 <code>true</code>，即 <code>dp[i][i] = true</code> 。</p><p>事实上，初始化的部分都可以省去。因为只有一个字符的时候一定是回文，<code>dp[i][i]</code> 根本不会被其它状态值所参考。</p><h4 id="第-4-步：考虑输出"><a href="#第-4-步：考虑输出" class="headerlink" title="第 4 步：考虑输出"></a>第 4 步：考虑输出</h4><p>只要一得到 <code>dp[i][j] = true</code>，就记录子串的长度和起始位置，没有必要截取，这是因为截取字符串也要消耗性能，记录此时的回文子串的「起始位置」和「回文长度」即可。</p><h4 id="第-5-步：考虑优化空间"><a href="#第-5-步：考虑优化空间" class="headerlink" title="第 5 步：考虑优化空间"></a>第 5 步：考虑优化空间</h4><p>因为在填表的过程中，只参考了左下方的数值。事实上可以优化，但是增加了代码编写和理解的难度，丢失可读和可解释性。在这里不优化空间。</p><p>注意事项：总是先得到小子串的回文判定，然后大子串才能参考小子串的判断结果，即填表顺序很重要。</p><p>大家能够可以自己动手，画一下表格，相信会对「动态规划」作为一种「表格法」有一个更好的理解。</p><p><strong>参考代码 2</strong>：</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特判</span></span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i][j] 表示 s[i, j] 是否是回文串</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">        <span class="keyword">char</span>[] charArray = s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意开始位置，只需要填这张表格对角线以上的部分，而且扫描的顺序要满足「无后效性」</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (charArray[i] != charArray[j]) &#123;</span><br><span class="line">                    dp[i][j] = <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 只要 dp[i][j] == true 成立，就表示子串 s[i..j] 是回文，此时记录回文长度和起始位置</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxLen) &#123;</span><br><span class="line">                    maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                    begin = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(begin, begin + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        size = len(s)</span><br><span class="line">        <span class="keyword">if</span> size &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">        dp = [[<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(size)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(size)]</span><br><span class="line"></span><br><span class="line">        max_len = <span class="number">1</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">            dp[i][i] = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, size):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, j):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                    <span class="keyword">if</span> j - i &lt; <span class="number">3</span>:</span><br><span class="line">                        dp[i][j] = <span class="keyword">True</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> dp[i][j]:</span><br><span class="line">                    cur_len = j - i + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> cur_len &gt; max_len:</span><br><span class="line">                        max_len = cur_len</span><br><span class="line">                        start = i</span><br><span class="line">        <span class="keyword">return</span> s[start:start + max_len]</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<em>O(N^{2})</em>。</li><li>空间复杂度：<em>O(N^{2})</em>，二维 dp 问题，一个状态得用二维有序数对表示，因此空间复杂度是 <em>O(N^{2})</em>。</li></ul><p>写完代码以后，可以纸上写下代码运行的流程，以字符串 <code>&#39;babad&#39;</code> 为例：</p><p> <a href="https://pic.leetcode-cn.com/b95575c883a4fc025e4e8816d4db1f35579d5bd945bfd9128154f882406bfce7-image.png" target="_blank" rel="noopener">‘babad’</a></p><p>可以发现：</p><p>1、<strong>当 <code>i</code> 和 <code>j</code> (图中是 <code>l</code> 和 <code>r</code>) 的差距等于小于 <code>3</code> 的时候，<code>dp</code> 值可以直接判断，不用参考以前的 <code>dp</code> 值；</strong></p><p>2、<strong>其它情况，每当计算新 <code>dp</code> 值的时候，都一定会参考「左下角」的 <code>dp</code> 值，即 <code>dp[i + 1][j - 1]</code>（<code>i + 1</code> 表示在下边，<code>j - 1</code> 表示在左边）。</strong></p><p>因此，从上到下写，或者从下到上写，都是可以的。</p><p>下面分别展示了错误的填表顺序和正确的填表顺序，以便大家理解动态规划要满足「无后效性」的意思。</p><p><strong>说明：表格中的数字表示「填表顺序」，从 1 开始</strong>。表格外的箭头和数字也表示「填表顺序」，与表格中的数字含义一致。</p><p> <a href="https://pic.leetcode-cn.com/4a24bbe4e55421f4f7d199b14e961eff792146092dd9a0c18cf06c824728407c-image.png" target="_blank" rel="noopener">错误的填表顺序</a></p><p> <a href="https://pic.leetcode-cn.com/7e9d1f1dbe2095b0609233faa03b224ab32adf832515de1ce15b496f2cbdf0ab-image.png" target="_blank" rel="noopener">正确的填表顺序</a></p><p><strong>参考代码 3</strong>：下面这段代码只有内层循环和「参考代码 2」不同，已经标注在注释中。</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] charArray = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="comment">// 只有下面这一行和「参考代码 2」不同，i 正着写、倒过来写都行，因为子串都有参考值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = j - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (charArray[i] == charArray[j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 只要 dp[i][j] == true 成立，就表示子串 s[i, j] 是回文，此时记录回文长度和起始位置</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> curLen = j - i + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (curLen &gt; maxLen) &#123;</span><br><span class="line">                        maxLen = curLen;</span><br><span class="line">                        start = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start, start + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        size = len(s)</span><br><span class="line">        <span class="keyword">if</span> size &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">        dp = [[<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(size)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(size)]</span><br><span class="line"></span><br><span class="line">        max_len = <span class="number">1</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">            dp[i][i] = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, size):</span><br><span class="line">            <span class="comment"># 只有下面这一行代码不一样</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(j - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                    <span class="keyword">if</span> j - i &lt; <span class="number">3</span>:</span><br><span class="line">                        dp[i][j] = <span class="keyword">True</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> dp[i][j]:</span><br><span class="line">                    cur_len = j - i + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> cur_len &gt; max_len:</span><br><span class="line">                        max_len = cur_len</span><br><span class="line">                        start = i</span><br><span class="line">        <span class="keyword">return</span> s[start:start + max_len]</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong>（同上）</p><p>「状态转移方程」其实可以写得更酷一点：借用 <code>or</code> 的短路功能，如果 <code>j - i &lt; 3</code> 成立，其实后面就不用计算了，状态转移方程可以写成如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = (s[i] == s[j]) and (j - i &lt; <span class="number">3</span> or dp[i + <span class="number">1</span>][j - <span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>以下代码虽然看起来短了一些，但是丢失了可读性，逻辑运算符混用，虽然加上了括号表示优先级，但如果没有前文铺垫，很难读懂是什么意思。不太推荐大家这么写。</p><p><strong>参考代码 4</strong>：</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] charArray = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j; i++) &#123;</span><br><span class="line"></span><br><span class="line">                dp[i][j] = charArray[i] == charArray[j] &amp;&amp; (j - i &lt; <span class="number">3</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 只要 dp[i][j] == true 成立，就表示子串 s[i, j] 是回文，此时记录回文长度和起始位置</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> curLen = j - i + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (curLen &gt; maxLen) &#123;</span><br><span class="line">                        maxLen = curLen;</span><br><span class="line">                        start = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start, start + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        size = len(s)</span><br><span class="line">        <span class="keyword">if</span> size &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">        dp = [[<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(size)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(size)]</span><br><span class="line"></span><br><span class="line">        max_len = <span class="number">1</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, size):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, j):</span><br><span class="line">                </span><br><span class="line">                dp[i][j] = (s[i] == s[j]) <span class="keyword">and</span> (j - i &lt; <span class="number">3</span> <span class="keyword">or</span> dp[i + <span class="number">1</span>][j - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> dp[i][j]:</span><br><span class="line">                    cur_len = j - i + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> cur_len &gt; max_len:</span><br><span class="line">                        max_len = cur_len</span><br><span class="line">                        start = i</span><br><span class="line">        <span class="keyword">return</span> s[start:start + max_len]</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong>（同上）</p><p>总结：</p><ul><li>我们看到，用「动态规划」方法解决问题，有的时候并不是直接面向问题的。</li><li>「动态规划」依然是「空间换时间」思想的体现，并且本身「动态规划」作为一种打表格法，就是在用「空间」换「时间」。</li></ul><p>关于「动态规划」方法执行时间慢的说明：</p><ul><li>动态规划本质上还是「暴力解法」，因为需要枚举左右边界，有 <em>O(N^2)</em> 这么多；</li><li>以下提供的「中心扩散法」枚举了所有可能的回文子串的中心，有 <em>O(2N)</em> 这么多，不在一个级别上。</li></ul><p>上面采用了时间复杂度估算的表示，<em>O(N^2)</em> 表示最高项是 <em>aN^2</em> 的多项式。</p><p>从这个问题我们也可以看出，虽然时间复杂度一样，但是实际执行时间有可能是有差距的，并且时间复杂度是一个估算，没有必要计算得很清楚，这是因为真正的运行时间还和很多因素有关：例如所运行机器的环境，测试用例等。</p><hr><h3 id="方法三：中心扩散法"><a href="#方法三：中心扩散法" class="headerlink" title="方法三：中心扩散法"></a>方法三：中心扩散法</h3><p>暴力法采用双指针两边夹，验证是否是回文子串。</p><p>除了枚举字符串的左右边界以外，比较容易想到的是<strong>枚举可能出现的回文子串的“中心位置”，从“中心位置”尝试尽可能扩散出去，得到一个回文串</strong>。</p><p>因此中心扩散法的思路是：遍历每一个索引，以这个索引为中心，利用“回文串”中心对称的特点，往两边扩散，看最多能扩散多远。</p><p>枚举“中心位置”时间复杂度为 <em>O(N)</em>，从“中心位置”扩散得到“回文子串”的时间复杂度为 <em>O(N)</em>，因此时间复杂度可以降到 <em>O(N^2)</em>。</p><p>在这里要注意一个细节：回文串在长度为奇数和偶数的时候，“回文中心”的形式是不一样的。</p><ul><li><p>奇数回文串的“中心”是一个具体的字符，例如：回文串 <code>&quot;aba&quot;</code> 的中心是字符 <code>&quot;b&quot;</code>；</p></li><li><p>偶数回文串的“中心”是位于中间的两个字符的“空隙”，例如：回文串串 <code>&quot;abba&quot;</code> 的中心是两个 <code>&quot;b&quot;</code> 中间的那个“空隙”。</p><p><a href="https://pic.leetcode-cn.com/572db4731d6a0e32ee9c14773ed476068bebb88883335bc7415cb0b43762303a.jpg" target="_blank" rel="noopener">图 1 ：奇数回文串与偶数回文串</a></p></li></ul><p>我们看一下一个字符串可能的回文子串的中心在哪里？</p><p> <a href="https://pic.leetcode-cn.com/3c4ca880f2dd7463e15ddf7bbd59e2f7d11434b7dbc69b55893660012726ee88.jpg" target="_blank" rel="noopener">图 2：枚举可能的所有回文中心</a></p><p>我们可以设计一个方法，兼容以上两种情况：</p><p>1、如果传入重合的索引编码，进行中心扩散，此时得到的回文子串的长度是奇数；</p><p>2、如果传入相邻的索引编码，进行中心扩散，此时得到的回文子串的长度是偶数。</p><p>具体编码细节在以下的代码的注释中体现。</p><p><strong>参考代码 5</strong>：</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        String res = s.substring(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 中心位置枚举到 len - 2 即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            String oddStr = centerSpread(s, i, i);</span><br><span class="line">            String evenStr = centerSpread(s, i, i + <span class="number">1</span>);</span><br><span class="line">            String maxLenStr = oddStr.length() &gt; evenStr.length() ? oddStr : evenStr;</span><br><span class="line">            <span class="keyword">if</span> (maxLenStr.length() &gt; maxLen) &#123;</span><br><span class="line">                maxLen = maxLenStr.length();</span><br><span class="line">                res = maxLenStr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">centerSpread</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// left = right 的时候，此时回文中心是一个字符，回文串的长度是奇数</span></span><br><span class="line">        <span class="comment">// right = left + 1 的时候，此时回文中心是一个空隙，回文串的长度是偶数</span></span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = right;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                i--;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里要小心，跳出 while 循环时，恰好满足 s.charAt(i) != s.charAt(j)，因此不能取 i，不能取 j</span></span><br><span class="line">        <span class="keyword">return</span> s.substring(i + <span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        size = len(s)</span><br><span class="line">        <span class="keyword">if</span> size &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 至少是 1</span></span><br><span class="line">        max_len = <span class="number">1</span></span><br><span class="line">        res = s[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">            palindrome_odd, odd_len = self.__center_spread(s, size, i, i)</span><br><span class="line">            palindrome_even, even_len = self.__center_spread(s, size, i, i + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 当前找到的最长回文子串</span></span><br><span class="line">            cur_max_sub = palindrome_odd <span class="keyword">if</span> odd_len &gt;= even_len <span class="keyword">else</span> palindrome_even</span><br><span class="line">            <span class="keyword">if</span> len(cur_max_sub) &gt; max_len:</span><br><span class="line">                max_len = len(cur_max_sub)</span><br><span class="line">                res = cur_max_sub</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__center_spread</span><span class="params">(self, s, size, left, right)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        left = right 的时候，此时回文中心是一个字符，回文串的长度是奇数</span></span><br><span class="line"><span class="string">        right = left + 1 的时候，此时回文中心是一个空隙，回文串的长度是偶数</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i = left</span><br><span class="line">        j = right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt; size <span class="keyword">and</span> s[i] == s[j]:</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[i + <span class="number">1</span>:j], j - i - <span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">centerSpread</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// left = right 的时候，此时回文中心是一个空隙，向两边扩散得到的回文子串的长度是奇数</span></span><br><span class="line">        <span class="comment">// right = left + 1 的时候，此时回文中心是一个字符，向两边扩散得到的回文子串的长度是偶数</span></span><br><span class="line">        <span class="keyword">int</span> size = s.size();</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = right;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                i--;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里要小心，跳出 while 循环时，恰好满足 s.charAt(i) != s.charAt(j)，因此不能取 i，不能取 j</span></span><br><span class="line">        <span class="keyword">return</span> s.substr(i + <span class="number">1</span>, j - i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特判</span></span><br><span class="line">        <span class="keyword">int</span> size = s.size();</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">string</span> res = s.substr(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 中心位置枚举到 len - 2 即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">string</span> oddStr = centerSpread(s, i, i);</span><br><span class="line">            <span class="built_in">string</span> evenStr = centerSpread(s, i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">string</span> maxLenStr = oddStr.size() &gt; evenStr.size() ? oddStr : evenStr;</span><br><span class="line">            <span class="keyword">if</span> (maxLenStr.length() &gt; maxLen) &#123;</span><br><span class="line">                maxLen = maxLenStr.size();</span><br><span class="line">                res = maxLenStr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<em>O(N^{2})</em>，理由已经叙述。</li><li>空间复杂度：<em>O(1)</em>，只使用到常数个临时变量，与字符串长度无关。</li></ul><p>事实上，还有时间复杂度更优的算法，是由计算机科学家 Manacher 发明的，下面介绍这种算法。</p><h3 id="方法四：Manacher-算法（不用掌握，面试的时候绝大多数情况下不会要求写这个算法，了解思想即可）"><a href="#方法四：Manacher-算法（不用掌握，面试的时候绝大多数情况下不会要求写这个算法，了解思想即可）" class="headerlink" title="方法四：Manacher 算法（不用掌握，面试的时候绝大多数情况下不会要求写这个算法，了解思想即可）"></a>方法四：Manacher 算法（不用掌握，面试的时候绝大多数情况下不会要求写这个算法，了解思想即可）</h3><blockquote><p>说明：以下题解中有一些细节我当时做的时候，没有仔细推敲，已经有朋友指出有错误，请大家根据自己的理解去思考科学家的做法和思想，我暂时没有时间修改这个部分的内容，大家也可以参考其他朋友的题解，给大家造成不便，我很抱歉。</p></blockquote><p>个人觉得知道 Manacher 算法是基于“中心扩散法”，采用和 kmp 算法类似的思想，依然是“以空间换时间”。</p><p>Manacher 算法，被中国程序员戏称为“马拉车”算法。它专门用于解决“最长回文子串”问题，时间复杂度为 <em>O(N)</em>。</p><p>维基百科中对于 Manacher 算法是这样描述的：</p><blockquote><p>[Manacher(1975)] 发现了一种线性时间算法，可以在列出给定字符串中从字符串头部开始的所有回文。并且，Apostolico, Breslauer &amp; Galil (1995) 发现，同样的算法也可以在任意位置查找全部最大回文子串，并且时间复杂度是线性的。因此，他们提供了一种时间复杂度为线性的最长回文子串解法。替代性的线性时间解决 Jeuring (1994), Gusfield (1997)提供的，基于后缀树(suffix trees)。也存在已知的高效并行算法。</p></blockquote><p>Manacher 算法本质上还是中心扩散法，只不过它使用了类似 KMP 算法的技巧，充分挖掘了已经进行回文判定的子串的特点，在遍历的过程中，记录了已经遍历过的子串的信息，也是典型的以空间换时间思想的体现。</p><p>下面介绍 Manacher 算法的具体流程。</p><h4 id="第-1-步：对原始字符串进行预处理（添加分隔符）"><a href="#第-1-步：对原始字符串进行预处理（添加分隔符）" class="headerlink" title="第 1 步：对原始字符串进行预处理（添加分隔符）"></a>第 1 步：对原始字符串进行预处理（添加分隔符）</h4><p>首先在字符串的首尾、相邻的字符中插入分隔符，例如 <code>&quot;babad&quot;</code> 添加分隔符 <code>&quot;#&quot;</code> 以后得到 <code>&quot;#b#a#b#a#d#&quot;</code>。</p><p>对这一点有如下说明：</p><p>1、分隔符是一个字符，种类也只有一个，并且这个字符一定不能是原始字符串中出现过的字符；</p><p>2、加入了分隔符以后，使得“间隙”有了具体的位置，方便后续的讨论，并且<strong>新字符串中的任意一个回文子串在原始字符串中的一定能找到唯一的一个回文子串与之对应</strong>，因此对新字符串的回文子串的研究就能得到原始字符串的回文子串；</p><p>3、新字符串的回文子串的长度一定是奇数；</p><p>4、新字符串的回文子串一定以分隔符作为两边的边界，因此分隔符起到“哨兵”的作用。</p><p> <a href="https://pic.leetcode-cn.com/d9546795e5c73d06b7c77645aef92413f794b3850a62492682a46eb00c9ee711.jpg" target="_blank" rel="noopener">图 3：原始字符串与新字符串的对应关系</a></p><h4 id="第-2-步：计算辅助数组-p"><a href="#第-2-步：计算辅助数组-p" class="headerlink" title="第 2 步：计算辅助数组 p"></a>第 2 步：计算辅助数组 p</h4><p>辅助数组 <code>p</code> 记录了新字符串中以每个字符为中心的回文子串的信息。</p><p>手动的计算方法仍然是“中心扩散法”，此时记录以当前字符为中心，向左右两边同时扩散，记录能够扩散的最大步数。</p><p>以字符串 <code>&quot;abbabb&quot;</code> 为例，说明如何手动计算得到辅助数组 <code>p</code> ，我们要填的就是下面这张表。</p><table><thead><tr><th><strong>char</strong></th><th><strong>#</strong></th><th><strong>a</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th><th><strong>a</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th></tr></thead><tbody><tr><td><strong>index</strong></td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td></tr><tr><td><strong>p</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>第 1 行数组 <code>char</code> ：原始字符串<strong>加上分隔符以后</strong>的每个字符。</p><p>第 2 行数组 <code>index</code> ：这个数组是新字符串的索引数组，它的值是从 <em>0</em> 开始的索引编号。</p><ul><li>我们首先填 <code>p[0]</code>。</li></ul><p>以 <code>char[0] = &#39;#&#39;</code> 为中心，同时向左边向右扩散，走 <em>1</em> 步就碰到边界了，因此能扩散的步数为 <em>0</em>，因此 <code>p[0] = 0</code>；</p><table><thead><tr><th><strong>char</strong></th><th><strong>#</strong></th><th><strong>a</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th><th><strong>a</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th></tr></thead><tbody><tr><td><strong>index</strong></td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td></tr><tr><td><strong>p</strong></td><td><strong>0</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><ul><li>下面填写 <code>p[1]</code> 。</li></ul><p>以 <code>char[1] = &#39;a&#39;</code> 为中心，同时向左边向右扩散，走 <em>1</em> 步，左右都是 <code>&quot;#&quot;</code>，构成回文子串，于是再继续同时向左边向右边扩散，左边就碰到边界了，最多能扩散的步数”为 <em>1</em>，因此 <code>p[1] = 1</code>；</p><table><thead><tr><th><strong>char</strong></th><th><strong>#</strong></th><th><strong>a</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th><th><strong>a</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th></tr></thead><tbody><tr><td><strong>index</strong></td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td></tr><tr><td><strong>p</strong></td><td>0</td><td><strong>1</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><ul><li>下面填写 <code>p[2]</code> 。</li></ul><p>以 <code>char[2] = &#39;#&#39;</code> 为中心，同时向左边向右扩散，走 <em>1</em> 步，左边是 <code>&quot;a&quot;</code>，右边是 <code>&quot;b&quot;</code>，不匹配，最多能扩散的步数为 <em>0</em>，因此 <code>p[2] = 0</code>；</p><table><thead><tr><th><strong>char</strong></th><th><strong>#</strong></th><th><strong>a</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th><th><strong>a</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th></tr></thead><tbody><tr><td><strong>index</strong></td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td></tr><tr><td><strong>p</strong></td><td>0</td><td>1</td><td><strong>0</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><ul><li>下面填写 <code>p[3]</code>。</li></ul><p>以 <code>char[3] = &#39;b&#39;</code> 为中心，同时向左边向右扩散，走 <em>1</em> 步，左右两边都是 <code>“#”</code>，构成回文子串，继续同时向左边向右扩散，左边是 <code>&quot;a&quot;</code>，右边是 <code>&quot;b&quot;</code>，不匹配，最多能扩散的步数为 <em>1</em> ，因此 <code>p[3] = 1</code>；</p><table><thead><tr><th><strong>char</strong></th><th><strong>#</strong></th><th><strong>a</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th><th><strong>a</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th></tr></thead><tbody><tr><td><strong>index</strong></td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td></tr><tr><td><strong>p</strong></td><td>0</td><td>1</td><td>0</td><td><strong>1</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><ul><li>下面填写 <code>p[4]</code>。</li></ul><p>以 <code>char[4] = &#39;#&#39;</code> 为中心，同时向左边向右扩散，最多可以走 <em>4</em> 步，左边到达左边界，因此 <code>p[4] = 4</code>。</p><table><thead><tr><th><strong>char</strong></th><th><strong>#</strong></th><th><strong>a</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th><th><strong>a</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th></tr></thead><tbody><tr><td><strong>index</strong></td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td></tr><tr><td><strong>p</strong></td><td>0</td><td>1</td><td>0</td><td>1</td><td><strong>4</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><ul><li>继续填完 p 数组剩下的部分。</li></ul><p>分析到这里，后面的数字不难填出，最后写成如下表格：</p><table><thead><tr><th><strong>char</strong></th><th><strong>#</strong></th><th><strong>a</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th><th><strong>a</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th></tr></thead><tbody><tr><td><strong>index</strong></td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td></tr><tr><td><strong>p</strong></td><td>0</td><td>1</td><td>0</td><td>1</td><td>4</td><td>1</td><td>0</td><td>5</td><td>0</td><td>1</td><td>2</td><td>1</td><td>0</td></tr></tbody></table><p><strong>说明</strong>：有些资料将辅助数组 <code>p</code> 定义为回文半径数组，即 <code>p[i]</code> 记录了以新字符串第 <code>i</code> 个字符为中心的回文字符串的半径（包括第 <code>i</code> 个字符），与我们这里定义的辅助数组 <code>p</code> 有一个字符的偏差，本质上是一样的。</p><p>下面是辅助数组 <code>p</code> 的结论：辅助数组 <code>p</code> 的最大值是 <em>5</em>，对应了原字符串 <code>&quot;abbabb&quot;</code> 的  “最长回文子串” ：<code>&quot;bbabb&quot;</code>。这个结论具有一般性，即：</p><blockquote><p>辅助数组 <code>p</code> 的最大值就是“最长回文子串”的长度。</p></blockquote><p>因此，我们可以在计算辅助数组 <code>p</code> 的过程中记录这个最大值，并且记录最长回文子串。</p><p>简单说明一下这是为什么：</p><ol><li><p>如果新回文子串的中心是一个字符，那么原始回文子串的中心也是一个字符，在新回文子串中，向两边扩散的特点是：“先分隔符，后字符”，同样扩散的步数因为有分隔符 <code>#</code> 的作用，在新字符串中每扩散两步，虽然实际上只扫到一个有效字符，但是相当于在原始字符串中相当于计算了两个字符。<strong>因为最后一定以分隔符结尾，还要计算一个，正好这个就可以把原始回文子串的中心算进去</strong>；</p><p><a href="https://pic.leetcode-cn.com/4ba4319f13bee429bb95ba119dcaefe71c9644bcf9e9be3ba2637d13fcccd3d6.jpg" target="_blank" rel="noopener">图 4：理解辅助数组的数值与原始字符串回文子串的等价性-1</a></p></li></ol><ol start="2"><li>如果新回文子串的中心是 <code>#</code>，那么原始回文子串的中心就是一个“空隙”。在新回文子串中，向两边扩散的特点是：“先字符，后分隔符”，扩散的步数因为有分隔符  <code>#</code> 的作用，在新字符串中每扩散两步，虽然实际上只扫到一个有效字符，但是相当于在原始字符串中相当于计算了两个字符。</li></ol><p>因此，“辅助数组 <code>p</code> 的最大值就是“最长回文子串”的长度”这个结论是成立的，可以看下面的图理解上面说的 <em>2</em> 点。</p><p> <a href="https://pic.leetcode-cn.com/05e76869add71c1cbf396bb89ee5ad7f560cc6c5e60926ceaef00a3bbc32c9e4.jpg" target="_blank" rel="noopener">图 4：理解辅助数组的数值与原始字符串回文子串的等价性-2</a></p><p>写到这里，其实已经能写出一版代码，把这一版代码提交到 LeetCode 是可以通过的，这同样也可以验证我们上面的结论是正确的。</p><p><strong>参考代码 6</strong>：</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        String str = addBoundaries(s, <span class="string">'#'</span>);</span><br><span class="line">        <span class="keyword">int</span> sLen = <span class="number">2</span> * len + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sLen; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> curLen = centerSpread(str, i);</span><br><span class="line">            <span class="keyword">if</span> (curLen &gt; maxLen) &#123;</span><br><span class="line">                maxLen = curLen;</span><br><span class="line">                start = (i - maxLen) / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start, start + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">centerSpread</span><span class="params">(String s, <span class="keyword">int</span> center)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> i = center - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = center + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; len &amp;&amp; s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">            i--;</span><br><span class="line">            j++;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建预处理字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s      原始字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> divide 分隔字符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 使用分隔字符处理以后得到的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">addBoundaries</span><span class="params">(String s, <span class="keyword">char</span> divide)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s.indexOf(divide) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误，您传递的分割字符，在输入字符串中存在！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            stringBuilder.append(divide);</span><br><span class="line">            stringBuilder.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        stringBuilder.append(divide);</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># Manacher 算法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="comment"># 特判</span></span><br><span class="line">        size = len(s)</span><br><span class="line">        <span class="keyword">if</span> size &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 得到预处理字符串</span></span><br><span class="line">        t = <span class="string">"#"</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">            t += s[i]</span><br><span class="line">            t += <span class="string">"#"</span></span><br><span class="line">        <span class="comment"># 新字符串的长度</span></span><br><span class="line">        t_len = <span class="number">2</span> * size + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 当前遍历的中心最大扩散步数，其值等于原始字符串的最长回文子串的长度</span></span><br><span class="line">        max_len = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 原始字符串的最长回文子串的起始位置，与 max_len 必须同时更新</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(t_len):</span><br><span class="line">            cur_len = self.__center_spread(t, i)</span><br><span class="line">            <span class="keyword">if</span> cur_len &gt; max_len:</span><br><span class="line">                max_len = cur_len</span><br><span class="line">                start = (i - max_len) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> s[start: start + max_len]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__center_spread</span><span class="params">(self, s, center)</span>:</span></span><br><span class="line">        size = len(s)</span><br><span class="line">        i = center - <span class="number">1</span></span><br><span class="line">        j = center + <span class="number">1</span></span><br><span class="line">        step = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt; size <span class="keyword">and</span> s[i] == s[j]:</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            step += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> step</span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">centerSpread</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> center)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.size();</span><br><span class="line">        <span class="keyword">int</span> i = center - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = center + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; len &amp;&amp; s[i] == s[j]) &#123;</span><br><span class="line">            i--;</span><br><span class="line">            j++;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特判</span></span><br><span class="line">        <span class="keyword">int</span> size = s.size();</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到预处理字符串</span></span><br><span class="line">        <span class="built_in">string</span> str = <span class="string">"#"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            str += s[i];</span><br><span class="line">            str += <span class="string">"#"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sSize = <span class="number">2</span> * size + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sSize; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> curLen = centerSpread(str, i);</span><br><span class="line">            <span class="keyword">if</span> (curLen &gt; maxLen) &#123;</span><br><span class="line">                maxLen = curLen;</span><br><span class="line">                start = (i - maxLen) / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<em>O(N^2)*，这里 *N</em> 是原始字符串的长度。新字符串的长度是 2<em>N+1 ，不计系数与常数项，因此时间复杂度仍为 *O(N^2)</em>。</li><li>空间复杂度：<em>O(N)</em>。</li></ul><blockquote><p><strong>科学家的工作：充分利用新字符串的回文性质，计算辅助数组 <code>p</code>。</strong></p></blockquote><p>上面的代码不太智能的地方是，对新字符串每一个位置进行中心扩散，会导致原始字符串的每一个字符被访问多次，一个比较极端的情况就是：<code>#a#a#a#a#a#a#a#a#</code>。事实上，计算机科学家 Manacher 就改进了这种算法，使得在填写新的辅助数组 <code>p</code> 的值的时候，能够参考已经填写过的辅助数组 <code>p</code> 的值，使得新字符串每个字符只访问了一次，整体时间复杂度由 <em>O(N^2)</em> 改进到 <em>O(N)</em>。</p><p>具体做法是：在遍历的过程中，除了循环变量 <code>i</code> 以外，我们还需要记录两个变量，它们是 <code>maxRight</code> 和 <code>center</code> ，它们分别的含义如下：</p><ul><li><code>maxRight</code>：记录当前向右扩展的最远边界，即从开始到现在使用“中心扩散法”能得到的回文子串，它能延伸到的最右端的位置 。对于 <code>maxRight</code> 我们说明 3 点：</li></ul><ol><li><p>“向右最远”是在计算辅助数组 <code>p</code> 的过程中，向右边扩散能走的索引最大的位置，注意：得到一个 <code>maxRight</code> 所对应的回文子串，并不一定是当前得到的“最长回文子串”，很可能的一种情况是，某个回文子串可能比较短，但是它正好在整个字符串比较靠后的位置；</p></li><li><p><code>maxRight</code> 的下一个位置可能是被程序看到的，停止的原因有 2 点：（1）左边界不能扩散，导致右边界受限制也不能扩散，<code>maxRight</code> 的下一个位置看不到；（2）正是因为看到了 <code>maxRight</code> 的下一个位置，导致 <code>maxRight</code> 不能继续扩散。</p></li><li><p>为什么 <code>maxRight</code> 很重要？因为扫描是从左向右进行的， <code>maxRight</code> 能够提供的信息最多，它是一个重要的分类讨论的标准，因此我们需要一个变量记录它。</p></li></ol><ul><li><code>center</code>：<code>center</code> 是与 <code>maxRight</code> 相关的一个变量，它是上述 <code>maxRight</code> 的回文中心的索引值。对于 <code>center</code> 的说明如下：</li></ul><ol><li><p><code>center</code> 的形式化定义：</p><pre><code>center=argmax{x+p[x]∣0≤x&lt;i}</code></pre><p>说明：<code>x + p[x]</code> 的最大值就是我们定义的 <code>maxRight</code>，<code>i</code> 是循环变量，<code>0&lt;= x&lt; i</code> 表示是在 <code>i</code> 之前的所有索引里得到的最大值  <code>maxRight</code>，它对应的回文中心索引就是上述式子。</p></li><li><p><code>maxRight</code> 与 <code>center</code> 是一一对应的关系，即一个  <code>center</code> 的值唯一对应了一个 <code>maxRight</code> 的值；因此 <strong><code>maxRight</code> 与 <code>center</code> 必须要同时更新</strong>。</p></li></ol><p>下面的讨论就根据循环变量 <code>i</code> 与 <code>maxRight</code> 的关系展开讨论：</p><p>情况 1：当 <code>i &gt;= maxRight</code> 的时候，这就是一开始，以及刚刚把一个回文子串扫描完的情况，此时只能够根据“中心扩散法”一个一个扫描，逐渐扩大 <code>maxRight</code>；</p><p>情况 2：当 <code>i &lt; maxRight</code> 的时候，根据新字符的回文子串的性质，循环变量关于 <code>center</code> 对称的那个索引（记为 <code>mirror</code>）的 <code>p</code> 值就很重要。</p><p>我们先看 <code>mirror</code> 的值是多少，因为 <code>center</code> 是中心，<code>i</code> 和 <code>mirror</code> 关于 <code>center</code> 中心对称，因此 <code>(mirror + i) / 2 = center</code> ，所以 <code>mirror = 2 * center - i</code>。</p><p>根据 <code>p[mirror]</code> 的数值从小到大，具体可以分为如下 3 种情况：</p><p>情况 2（1）：<code>p[mirror]</code> 的数值比较小，不超过 <code>maxRight - i</code>。</p><p>说明：<code>maxRight - i</code> 的值，就是从 <code>i</code> 关于 <code>center</code> 的镜像点开始向左走（不包括它自己），到 <code>maxRight</code> 关于 <code>center</code> 的镜像点的步数</p><p> <a href="https://pic.leetcode-cn.com/aadfb3cfee9715c7d0a8fb8e8938ede16203226710909e093a27e2e2791b9233-image.png" target="_blank" rel="noopener">图 5：Manacher 算法分类讨论情况 2（1）</a></p><p>从图上可以看出，由于“以 <code>center</code> 为中心的回文子串”的对称性，导致了“以 <code>i</code> 为中心的回文子串”与“以 <code>center</code> 为中心的回文子串”也具有对称性，“以 <code>i</code> 为中心的回文子串”与“以 <code>center</code> 为中心的回文子串”不能再扩散了，此时，直接把数值抄过来即可，即 <code>p[i] = p[mirror]</code>。</p><p>情况 2（2）：<code>p[mirror]</code> 的数值恰好等于 <code>maxRight - i</code>。</p><p> <a href="https://pic.leetcode-cn.com/2f25bb6f215a3caba05738cb0be4cdb0b0c380fa9fe0b7e80ee00a1f1840b088-image.png" target="_blank" rel="noopener">图 5：Manacher 算法分类讨论情况 2（2）</a></p><p>说明：仍然是依据“以 <code>center</code> 为中心的回文子串”的对称性，导致了“以 <code>i</code> 为中心的回文子串”与“以 <code>center</code> 为中心的回文子串”也具有对称性。</p><ol><li>因为靠左边的 <code>f</code> 与靠右边的 <code>g</code> 的原因，导致“以 <code>center</code> 为中心的回文子串”不能继续扩散；</li><li>但是“以 <code>i</code> 为中心的回文子串” 还可以继续扩散。</li></ol><p>因此，可以先把 <code>p[mirror]</code> 的值抄过来，然后继续“中心扩散法”，继续增加 <code>maxRight</code>。</p><p>情况 2（3）：<code>p[mirror]</code> 的数值大于 <code>maxRight - i</code>。</p><p> <a href="https://pic.leetcode-cn.com/dac4d98cd3c3963eb5b48a851dd4988c5f998158bf66a77feb134255522838d7-image.png" target="_blank" rel="noopener">图 5：Manacher 算法分类讨论情况 2（3）</a></p><p>说明：仍然是依据“以 <code>center</code> 为中心的回文子串”的对称性，导致了“以 <code>i</code> 为中心的回文子串”与“以 <code>center</code> 为中心的回文子串”也具有对称性。<br>下面证明，<code>p[i] = maxRight - i</code> ，证明的方法还是利用三个回文子串的对称性。</p><p> <a href="https://pic.leetcode-cn.com/d404aff63ecd764aaa70e6bb961a7e4286b8b2afdb6b4ce4bf696fb8eeb55086.jpg" target="_blank" rel="noopener">图 5：Manacher 算法分类讨论情况 2（3）的证明</a></p><p>① 由于“以 <code>center</code> 为中心的回文子串”的对称性， 黄色箭头对应的字符 <code>c</code> 和 <code>e</code> 一定不相等；</p><p>② 由于“以 <code>mirror</code> 为中心的回文子串”的对称性， 绿色箭头对应的字符 <code>c</code> 和 <code>c</code> 一定相等；</p><p>③ 又由于“以 <code>center</code> 为中心的回文子串”的对称性， 蓝色箭头对应的字符 <code>c</code> 和 <code>c</code> 一定相等；</p><p>推出“以 <code>i</code> 为中心的回文子串”的对称性，  红色箭头对应的字符 <code>c</code> 和 <code>e</code> 一定不相等。</p><p>因此，<code>p[i] = maxRight - i</code>，不可能再大。上面是因为我画的图，可能看的朋友会觉得理所当然。事实上，可以使用反证法证明：</p><p>如果“以 <code>i</code> 为中心的回文子串” 再向两边扩散的两个字符 <code>c</code> 和 <code>e</code> 相等，就能够推出黄色、绿色、蓝色、红色箭头所指向的 8 个变量的值都相等，此时“以 <code>center</code> 为中心的回文子串” 就可以再同时向左边和右边扩散 <em>1</em> 格，与 <code>maxRight</code> 的最大性矛盾。</p><p>综合以上 3 种情况，当 <code>i &lt; maxRight</code> 的时候，<code>p[i]</code> 可以参考 <code>p[mirror]</code> 的信息，以 <code>maxRight - i</code> 作为参考标准，<code>p[i]</code> 的值应该是保守的，即二者之中较小的那个值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p[i] = min(maxRight - i, p[mirror]);</span><br></pre></td></tr></table></figure><p><strong>参考代码 7</strong>：</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特判</span></span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到预处理字符串</span></span><br><span class="line">        String str = addBoundaries(s, <span class="string">'#'</span>);</span><br><span class="line">        <span class="comment">// 新字符串的长度</span></span><br><span class="line">        <span class="keyword">int</span> sLen = <span class="number">2</span> * len + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数组 p 记录了扫描过的回文子串的信息</span></span><br><span class="line">        <span class="keyword">int</span>[] p = <span class="keyword">new</span> <span class="keyword">int</span>[sLen];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 双指针，它们是一一对应的，须同时更新</span></span><br><span class="line">        <span class="keyword">int</span> maxRight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> center = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前遍历的中心最大扩散步数，其值等于原始字符串的最长回文子串的长度</span></span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 原始字符串的最长回文子串的起始位置，与 maxLen 必须同时更新        </span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sLen; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; maxRight) &#123;</span><br><span class="line">                <span class="keyword">int</span> mirror = <span class="number">2</span> * center - i;</span><br><span class="line">                <span class="comment">// 这一行代码是 Manacher 算法的关键所在，要结合图形来理解</span></span><br><span class="line">                p[i] = Math.min(maxRight - i, p[mirror]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下一次尝试扩散的左右起点，能扩散的步数直接加到 p[i] 中</span></span><br><span class="line">            <span class="keyword">int</span> left = i - (<span class="number">1</span> + p[i]);</span><br><span class="line">            <span class="keyword">int</span> right = i + (<span class="number">1</span> + p[i]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// left &gt;= 0 &amp;&amp; right &lt; sLen 保证不越界</span></span><br><span class="line">            <span class="comment">// str.charAt(left) == str.charAt(right) 表示可以扩散 1 次</span></span><br><span class="line">            <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; sLen &amp;&amp; str.charAt(left) == str.charAt(right)) &#123;</span><br><span class="line">                p[i]++;</span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 根据 maxRight 的定义，它是遍历过的 i 的 i + p[i] 的最大者</span></span><br><span class="line">            <span class="comment">// 如果 maxRight 的值越大，进入上面 i &lt; maxRight 的判断的可能性就越大，这样就可以重复利用之前判断过的回文信息了</span></span><br><span class="line">            <span class="keyword">if</span> (i + p[i] &gt; maxRight) &#123;</span><br><span class="line">                <span class="comment">// maxRight 和 center 需要同时更新</span></span><br><span class="line">                maxRight = i + p[i];</span><br><span class="line">                center = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p[i] &gt; maxLen) &#123;</span><br><span class="line">                <span class="comment">// 记录最长回文子串的长度和相应它在原始字符串中的起点</span></span><br><span class="line">                maxLen = p[i];</span><br><span class="line">                start = (i - maxLen) / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start, start + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建预处理字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s      原始字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> divide 分隔字符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 使用分隔字符处理以后得到的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">addBoundaries</span><span class="params">(String s, <span class="keyword">char</span> divide)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s.indexOf(divide) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误，您传递的分割字符，在输入字符串中存在！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            stringBuilder.append(divide);</span><br><span class="line">            stringBuilder.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        stringBuilder.append(divide);</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># Manacher 算法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="comment"># 特判</span></span><br><span class="line">        size = len(s)</span><br><span class="line">        <span class="keyword">if</span> size &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 得到预处理字符串</span></span><br><span class="line">        t = <span class="string">"#"</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">            t += s[i]</span><br><span class="line">            t += <span class="string">"#"</span></span><br><span class="line">        <span class="comment"># 新字符串的长度</span></span><br><span class="line">        t_len = <span class="number">2</span> * size + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 数组 p 记录了扫描过的回文子串的信息</span></span><br><span class="line">        p = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(t_len)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 双指针，它们是一一对应的，须同时更新</span></span><br><span class="line">        max_right = <span class="number">0</span></span><br><span class="line">        center = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当前遍历的中心最大扩散步数，其值等于原始字符串的最长回文子串的长度</span></span><br><span class="line">        max_len = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 原始字符串的最长回文子串的起始位置，与 max_len 必须同时更新</span></span><br><span class="line">        start = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(t_len):</span><br><span class="line">            <span class="keyword">if</span> i &lt; max_right:</span><br><span class="line">                mirror = <span class="number">2</span> * center - i</span><br><span class="line">                <span class="comment"># 这一行代码是 Manacher 算法的关键所在，要结合图形来理解</span></span><br><span class="line">                p[i] = min(max_right - i, p[mirror])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 下一次尝试扩散的左右起点，能扩散的步数直接加到 p[i] 中</span></span><br><span class="line">            left = i - (<span class="number">1</span> + p[i])</span><br><span class="line">            right = i + (<span class="number">1</span> + p[i])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># left &gt;= 0 and right &lt; t_len 保证不越界</span></span><br><span class="line">            <span class="comment"># t[left] == t[right] 表示可以扩散 1 次</span></span><br><span class="line">            <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; t_len <span class="keyword">and</span> t[left] == t[right]:</span><br><span class="line">                p[i] += <span class="number">1</span></span><br><span class="line">                left -= <span class="number">1</span></span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 根据 max_right 的定义，它是遍历过的 i 的 i + p[i] 的最大者</span></span><br><span class="line">            <span class="comment"># 如果 max_right 的值越大，进入上面 i &lt; max_right 的判断的可能性就越大，这样就可以重复利用之前判断过的回文信息了</span></span><br><span class="line">            <span class="keyword">if</span> i + p[i] &gt; max_right:</span><br><span class="line">                <span class="comment"># max_right 和 center 需要同时更新</span></span><br><span class="line">                max_right = i + p[i]</span><br><span class="line">                center = i</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> p[i] &gt; max_len:</span><br><span class="line">                <span class="comment"># 记录最长回文子串的长度和相应它在原始字符串中的起点</span></span><br><span class="line">                max_len = p[i]</span><br><span class="line">                start = (i - max_len) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> s[start: start + max_len]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特判</span></span><br><span class="line">        <span class="keyword">int</span> size = s.size();</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到预处理字符串</span></span><br><span class="line">        <span class="built_in">string</span> str = <span class="string">"#"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            str += s[i];</span><br><span class="line">            str += <span class="string">"#"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 新字符串的长度</span></span><br><span class="line">        <span class="keyword">int</span> strSize = <span class="number">2</span> * size + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 数组 p 记录了扫描过的回文子串的信息</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p(strSize, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 双指针，它们是一一对应的，须同时更新</span></span><br><span class="line">        <span class="keyword">int</span> maxRight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> center = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前遍历的中心最大扩散步数，其值等于原始字符串的最长回文子串的长度</span></span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 原始字符串的最长回文子串的起始位置，与 maxLen 必须同时更新</span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strSize; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; maxRight) &#123;</span><br><span class="line">                <span class="keyword">int</span> mirror = (<span class="number">2</span> * center) - i;</span><br><span class="line">                <span class="comment">// 这一行代码是 Manacher 算法的关键所在，要结合图形来理解</span></span><br><span class="line">                p[i] = min(maxRight - i, p[mirror]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下一次尝试扩散的左右起点，能扩散的步数直接加到 p[i] 中</span></span><br><span class="line">            <span class="keyword">int</span> left = i - (<span class="number">1</span> + p[i]);</span><br><span class="line">            <span class="keyword">int</span> right = i + (<span class="number">1</span> + p[i]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// left &gt;= 0 &amp;&amp; right &lt; sLen 保证不越界</span></span><br><span class="line">            <span class="comment">// str.charAt(left) == str.charAt(right) 表示可以扩散 1 次</span></span><br><span class="line">            <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; strSize &amp;&amp; str[left] == str[right]) &#123;</span><br><span class="line">                p[i]++;</span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据 maxRight 的定义，它是遍历过的 i 的 i + p[i] 的最大者</span></span><br><span class="line">            <span class="comment">// 如果 maxRight 的值越大，进入上面 i &lt; maxRight 的判断的可能性就越大，这样就可以重复利用之前判断过的回文信息了</span></span><br><span class="line">            <span class="keyword">if</span> (i + p[i] &gt; maxRight) &#123;</span><br><span class="line">                <span class="comment">// maxRight 和 center 需要同时更新</span></span><br><span class="line">                maxRight = i + p[i];</span><br><span class="line">                center = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p[i] &gt; maxLen) &#123;</span><br><span class="line">                <span class="comment">// 记录最长回文子串的长度和相应它在原始字符串中的起点</span></span><br><span class="line">                maxLen = p[i];</span><br><span class="line">                start = (i - maxLen) / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<em>O(N)</em>，Manacher 算法只有在遇到还未匹配的位置时才进行匹配，已经匹配过的位置不再匹配，因此对于字符串 <code>S</code> 的每一个位置，都只进行一次匹配，算法的复杂度为 <em>O(N)</em>。</li><li>空间复杂度：<em>O(N)</em>。</li></ul><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/</a></p><p>【2】<a href="https://liweiwei1419.gitee.io/leetcode-algo/#indexCard" target="_blank" rel="noopener">https://liweiwei1419.gitee.io/leetcode-algo/#indexCard</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;找到字符串中最长的回文子串，提供了「动态规划』问题的思考路径&lt;/p&gt;
    
    </summary>
    
      <category term="2020年5月" scheme="http://yoursite.com/categories/2020%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>131. 分割回文串</title>
    <link href="http://yoursite.com/2020/05/28/131.%20%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    <id>http://yoursite.com/2020/05/28/131. 分割回文串/</id>
    <published>2020-05-27T16:12:12.000Z</published>
    <updated>2020-05-28T11:46:20.618Z</updated>
    
    <content type="html"><![CDATA[<p>分割成一些子串，使每个子串都是回文串。返回 s 所有可能的分割方案</p><a id="more"></a><h1 id="📖题目描述："><a href="#📖题目描述：" class="headerlink" title="📖题目描述："></a>📖题目描述：</h1><p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。</p><p>返回 s 所有可能的分割方案。</p><p>示例:</p><pre><code>输入: &quot;aab&quot;输出:[  [&quot;aa&quot;,&quot;b&quot;],  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]]</code></pre><h1 id="📖解题思路"><a href="#📖解题思路" class="headerlink" title="📖解题思路"></a>📖解题思路</h1><p>搜索问题主要使用回溯法。</p><p>回溯法思考的步骤：</p><p>1、画递归树；</p><p>2、根据自己画的递归树编码。</p><p> <a href="https://pic.leetcode-cn.com/298a80282ac3505fec3710abdc1e656c591cf7acaa3ba976151480729244b649-image.png" target="_blank" rel="noopener">递归树</a></p><p>思考如何根据这棵递归树编码：</p><p>1、每一个结点表示剩余没有扫描到的字符串，产生分支是截取了剩余字符串的前缀；</p><p>2、产生前缀字符串的时候，判断前缀字符串是否是回文。</p><ul><li>如果前缀字符串是回文，则可以产生分支和结点；</li><li>如果前缀字符串不是回文，则不产生分支和结点，这一步是剪枝操作。</li></ul><p>3、在叶子结点是空字符串的时候结算，此时<strong>从根结点到叶子结点的路径，就是结果集里的一个结果，使用深度优先遍历，记录下所有可能的结果</strong>。</p><ul><li>采用一个路径变量 <code>path</code> 搜索，<code>path</code> 全局使用一个（注意结算的时候，需要生成一个拷贝），因此在递归执行方法结束以后需要回溯，即将递归之前添加进来的元素拿出去；</li><li><code>path</code> 的操作只在列表的末端，因此合适的数据结构是栈。</li></ul><h1 id="📖方法一：回溯"><a href="#📖方法一：回溯" class="headerlink" title="📖方法一：回溯"></a>📖方法一：回溯</h1><p><strong>参考代码 1</strong>：</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Stack 这个类 Java 的文档里推荐写成 Deque&lt;Integer&gt; stack = new ArrayDeque&lt;Integer&gt;();</span></span><br><span class="line">        <span class="comment">// 注意：只使用 stack 相关的接口</span></span><br><span class="line">        Deque&lt;String&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        backtracking(s, <span class="number">0</span>, len, stack, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 起始字符的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len   字符串 s 的长度，可以设置为全局变量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path  记录从根结点到叶子结点的路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> res   记录所有的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> len, Deque&lt;String&gt; path, List&lt;List&lt;String&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == len) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 因为截取字符串是消耗性能的，因此，采用传子串索引的方式判断一个子串是否是回文子串</span></span><br><span class="line">            <span class="comment">// 不是的话，剪枝</span></span><br><span class="line">            <span class="keyword">if</span> (!checkPalindrome(s, start, i)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            path.addLast(s.substring(start, i + <span class="number">1</span>));</span><br><span class="line">            backtracking(s, i + <span class="number">1</span>, len, path, res);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这一步的时间复杂度是 O(N)，因此，可以采用动态规划先把回文子串的结果记录在一个表格里</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left  子串的左边界，可以取到</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 子串的右边界，可以取到</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkPalindrome</span><span class="params">(String str, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 严格小于即可</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(left) != str.charAt(right)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="📖方法二：回溯的优化（加了动态规划）"><a href="#📖方法二：回溯的优化（加了动态规划）" class="headerlink" title="📖方法二：回溯的优化（加了动态规划）"></a>📖方法二：回溯的优化（加了动态规划）</h1><p>在上一步，验证回文串那里，每一次都得使用“两边夹”的方式验证子串是否是回文子串。于是“用空间换时间”，利用「力扣」第 5 题：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring" target="_blank" rel="noopener">最长回文子串</a> 的思路，利用动态规划把结果先算出来，这样就可以以 <em>O(1)</em> 的时间复杂度直接得到一个子串是否是回文。</p><p><strong>参考代码 2</strong>：</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 预处理</span></span><br><span class="line">        <span class="comment">// 状态：dp[i][j] 表示 s[i][j] 是否是回文</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">        <span class="comment">// 状态转移方程：在 s[i] == s[j] 的时候，dp[i][j] 参考 dp[i + 1][j - 1]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> right = <span class="number">0</span>; right &lt; len; right++) &#123;</span><br><span class="line">            <span class="comment">// 注意：left &lt;= right 取等号表示 1 个字符的时候也需要判断</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>; left &lt;= right; left++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(left) == s.charAt(right) &amp;&amp; (right - left &lt;= <span class="number">2</span> || dp[left + <span class="number">1</span>][right - <span class="number">1</span>])) &#123;</span><br><span class="line">                    dp[left][right] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Deque&lt;String&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        backtracking(s, <span class="number">0</span>, len, dp, stack, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(String s,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> start,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">boolean</span>[][] dp,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Deque&lt;String&gt; path,</span></span></span><br><span class="line"><span class="function"><span class="params">                              List&lt;List&lt;String&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == len) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 剪枝</span></span><br><span class="line">            <span class="keyword">if</span> (!dp[start][i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.addLast(s.substring(start, i + <span class="number">1</span>));</span><br><span class="line">            backtracking(s, i + <span class="number">1</span>, len, dp, path, res);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://leetcode-cn.com/problems/palindrome-partitioning/solution/hui-su-you-hua-jia-liao-dong-tai-gui-hua-by-liweiw/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/palindrome-partitioning/solution/hui-su-you-hua-jia-liao-dong-tai-gui-hua-by-liweiw/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分割成一些子串，使每个子串都是回文串。返回 s 所有可能的分割方案&lt;/p&gt;
    
    </summary>
    
      <category term="2020年5月" scheme="http://yoursite.com/categories/2020%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>887. 鸡蛋掉落</title>
    <link href="http://yoursite.com/2020/05/28/887.%20%E9%B8%A1%E8%9B%8B%E6%8E%89%E8%90%BD/"/>
    <id>http://yoursite.com/2020/05/28/887. 鸡蛋掉落/</id>
    <published>2020-05-27T16:12:12.000Z</published>
    <updated>2020-05-28T07:39:15.598Z</updated>
    
    <content type="html"><![CDATA[<p>确定不摔碎鸡蛋的临界楼层的最小移动次数</p><a id="more"></a><h1 id="📖题目描述："><a href="#📖题目描述：" class="headerlink" title="📖题目描述："></a>📖题目描述：</h1><p>你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。</p><p>每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。</p><p>你知道存在楼层 F ，满足 0 &lt;= F &lt;= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。</p><p>每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 &lt;= X &lt;= N）。</p><p>你的目标是确切地知道 F 的值是多少。</p><p>无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？</p><p>示例 1：</p><pre><code>输入：K = 1, N = 2输出：2解释：鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。如果它没碎，那么我们肯定知道 F = 2 。因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。</code></pre><p>示例 2：</p><pre><code>输入：K = 2, N = 6输出：3</code></pre><p>示例 3：</p><pre><code>输入：K = 3, N = 14输出：4</code></pre><p>提示：</p><pre><code>1 &lt;= K &lt;= 1001 &lt;= N &lt;= 10000</code></pre><h1 id="📖文字题解"><a href="#📖文字题解" class="headerlink" title="📖文字题解"></a>📖文字题解</h1><p>本题是谷歌的一道经典面试题。由于本题过于经典，谷歌公司已经不再将这题作为面试的候选题目了。</p><p>本题还没出现在Leetcode上时我曾经做过一遍，当时只想到用二分法来寻找临界楼层，但没有和动态规划结合，其实一般涉及到“最多”，“最少”之类的字眼多数都会和动态规划沾边。</p><p>本题难度较高，要想通过本题，需要一定的动态规划优化或数学功底。本题的标准解法为动态规划，由于篇幅有限，不会叙述 <strong>动态规划的边界条件</strong>、<strong>自底向上的动态规划和自顶向下的动态规划分别怎么实现</strong> 等较为基础的知识，而是把重点放在推导动态规划状态转移方程的过程，以及优化的思路、证明以及方法。</p><p>读者应当期望在阅读完本题解后，能够对方法一有一个大致的思路，并且可以在尝试中编写出代码。方法一已经是很优秀的解法，本题解也着重于此。而对于方法二和方法三，已经超过了面试难度，是竞赛中的考点，仅供读者挑战自我的极限。</p><h2 id="方法一：动态规划-二分搜索"><a href="#方法一：动态规划-二分搜索" class="headerlink" title="方法一：动态规划 + 二分搜索"></a>方法一：动态规划 + 二分搜索</h2><p><strong>思路和算法</strong></p><p>我们可以考虑使用动态规划来做这道题，状态可以表示成 <em>(K, N)*，其中 *K</em> 为鸡蛋数，<em>N</em> 为楼层数。当我们从第 <em>X</em> 楼扔鸡蛋的时候：</p><ul><li><p>如果鸡蛋不碎，那么状态变成 <em>(K, N-X)*，即我们鸡蛋的数目不变，但答案只可能在上方的 *N-X</em> 层楼了。也就是说，我们把原问题缩小成了一个规模为 <em>(K, N-X)</em> 的子问题；</p></li><li><p>如果鸡蛋碎了，那么状态变成 <em>(K-1, X-1)*，即我们少了一个鸡蛋，但我们知道答案只可能在第 *X</em> 楼下方的 <em>X-1</em> 层楼中了。也就是说，我们把原问题缩小成了一个规模为 <em>(K-1, X-1)</em> 的子问题。</p></li></ul><p>这样一来，我们定义 <em>dp(K, N)</em> 为在状态 <em>(K, N)</em> 下最少需要的步数。根据以上分析我们可以列出状态转移方程：</p><pre><code>dp(K,N)=1+ min(max(dp(K−1,X−1),dp(K,N−X)))  1≤X≤N</code></pre><p>这个状态转移方程是如何得来的呢？对于 <em>dp(K, N)</em> 而言，我们像上面分析的那样，枚举第一个鸡蛋扔在的楼层数 <em>X</em>。由于我们并不知道真正的 <em>F</em> 值，因此我们必须保证 <strong>鸡蛋碎了之后接下来需要的步数</strong> 和 <strong>鸡蛋没碎之后接下来需要的步数</strong> 二者的 <strong>最大值</strong> 最小，这样就保证了在 <strong>最坏情况下（也就是无论 <em>F</em> 的值如何）</strong> <em>dp(K, N)</em> 的值最小。如果能理解这一点，也就能理解上面的状态转移方程，即 </p><pre><code>最小化max(dp(K-1, X-1), dp(K, N-X))</code></pre><p>如果我们直接暴力转移求解每个状态的 <em>dp</em> 值，时间复杂度是为 <em>O(KN^2)*，即一共有 *O(KN)</em> 个状态，对于每个状态枚举扔鸡蛋的楼层 <em>X</em>，需要 <em>O(N)</em> 的时间。这无疑在当前数据范围下是会超出时间限制的，因此我们需要想办法优化枚举的时间复杂度。</p><p>我们观察到 <em>dp(K, N)</em> 是一个关于 <em>N</em> 的单调递增函数，也就是说在鸡蛋数 <em>K</em> 固定的情况下，楼层数 <em>N</em> 越多，需要的步数一定不会变少。在上述的状态转移方程中，第一项</p><pre><code>T1 (X)=dp(K−1,X−1)</code></pre><p>是一个随 <em>X</em> 的增加而单调递增的函数，第二项</p><pre><code>T2(X)=dp(K,N−X)</code></pre><p>是一个随着 <em>X</em> 的增加而单调递减的函数。</p><p>这如何帮助我们来优化这个问题呢？当 <em>X</em> 增加时，T1 (X) 单调递增而 T2(X) 单调递减，我们可以想象在一个直角坐标系中，横坐标为 <em>X</em>，纵坐标为T1(X) 和 T2(X)。当一个函数单调递增而另一个函数单调递减时，我们如何找到一个位置使得它们的最大值最小呢？</p><p> <a href="https://assets.leetcode-cn.com/solution-static/887_fig1.jpg" target="_blank" rel="noopener">fig1</a></p><p>如上图所示，如果这两个函数都是连续函数，那么我们只需要找出这两个函数的交点，在交点处就能保证这两个函数的最大值最小。但在本题中，T1​(X) 和 T2​ (X) 都是离散函数，也就是说，<em>X</em> 的值只能取 <em>1, 2, 3</em> 等等。在这种情况下，我们需要找到</p><pre><code>最大的满足 T1​(X)&lt;T2​(X)的X_0，以及最小的满足T1​ (X)≥T2​(X)的X_1，</code></pre><p>对应到上图中，就是离这两个函数（想象中的）交点左右两侧最近的整数。</p><p>我们只需要比较在 <em>X_0</em> 和 <em>X_1*处两个函数的最大值，取一个最小的作为 *X</em> 即可。在数学上，我们可以证明出 <em>X_0</em> 和 <em>X_1</em> 相差 <em>1</em>，这也是比较显然的，因为它们正好夹住了那个想象中的交点，并且相距尽可能地近。因此我们就可以使用二分查找的方法找出 <em>X_0</em>，再得到 <em>X_1</em>：</p><p>我们在所有满足条件的 <em>X</em> 上进行二分查找。对于状态 <em>(K, N)</em> 而言，<em>X</em> 即为 <em>[1, N]</em> 中的任一整数； 在二分查找的过程中，假设当前这一步我们查找到了Xmid ，如果</p><pre><code>T1​(Xmid​)&gt;T2​(Xmid​)，</code></pre><p>那么真正的 <em>X_0</em> 一定在 Xmid的左侧，否则真正的 <em>X_0</em> 在Xmid的右侧。</p><p>二分查找的写法因人而异，本质上我们就是需要找到最大的满足</p><pre><code>T1​(X)&lt;T2​(X)</code></pre><p>的 <em>X_0*，根据 Xmid 进行二分边界的调整。在得到了 *X_0</em> 后，我们可以知道 <em>X_1</em> 即为 <em>X_0 + 1*，此时我们只需要比较max(T1​(X0​),T2​(X0​))和 max(T1​(X1​),T2​(X1​)) ，取较小的那个对应的位置作为 *X</em> 即可。</p><p>这样一来，对于给定的状态 <em>(K, N)<em>，我们只需要 O(logN)的时间，通过二分查找就能得到最优的那个 *X</em>，因此时间复杂度从 *O(KN^2)</em> 降低至O(KN\logN) ，可以通过本题。</p><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dp(K, N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, Integer&gt; memo = <span class="keyword">new</span> HashMap();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!memo.containsKey(N * <span class="number">100</span> + K)) &#123;</span><br><span class="line">            <span class="keyword">int</span> ans;</span><br><span class="line">            <span class="keyword">if</span> (N == <span class="number">0</span>)</span><br><span class="line">                ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (K == <span class="number">1</span>)</span><br><span class="line">                ans = N;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> lo = <span class="number">1</span>, hi = N;</span><br><span class="line">                <span class="keyword">while</span> (lo + <span class="number">1</span> &lt; hi) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">int</span> t1 = dp(K-<span class="number">1</span>, x-<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">int</span> t2 = dp(K, N-x);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (t1 &lt; t2)</span><br><span class="line">                        lo = x;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (t1 &gt; t2)</span><br><span class="line">                        hi = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        lo = hi = x;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ans = <span class="number">1</span> + Math.min(Math.max(dp(K-<span class="number">1</span>, lo-<span class="number">1</span>), dp(K, N-lo)),</span><br><span class="line">                                   Math.max(dp(K-<span class="number">1</span>, hi-<span class="number">1</span>), dp(K, N-hi)));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            memo.put(N * <span class="number">100</span> + K, ans);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> memo.get(N * <span class="number">100</span> + K);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[solution1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">superEggDrop</span><span class="params">(self, K: int, N: int)</span> -&gt; int:</span></span><br><span class="line">        memo = &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(k, n)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> (k, n) <span class="keyword">not</span> <span class="keyword">in</span> memo:</span><br><span class="line">                <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">                    ans = <span class="number">0</span></span><br><span class="line">                <span class="keyword">elif</span> k == <span class="number">1</span>:</span><br><span class="line">                    ans = n</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    lo, hi = <span class="number">1</span>, n</span><br><span class="line">                    <span class="comment"># keep a gap of 2 X values to manually check later</span></span><br><span class="line">                    <span class="keyword">while</span> lo + <span class="number">1</span> &lt; hi:</span><br><span class="line">                        x = (lo + hi) // <span class="number">2</span></span><br><span class="line">                        t1 = dp(k<span class="number">-1</span>, x<span class="number">-1</span>)</span><br><span class="line">                        t2 = dp(k, n-x)</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> t1 &lt; t2:</span><br><span class="line">                            lo = x</span><br><span class="line">                        <span class="keyword">elif</span> t1 &gt; t2:</span><br><span class="line">                            hi = x</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            lo = hi = x</span><br><span class="line"></span><br><span class="line">                    ans = <span class="number">1</span> + min(max(dp(k<span class="number">-1</span>, x<span class="number">-1</span>), dp(k, n-x))</span><br><span class="line">                                  <span class="keyword">for</span> x <span class="keyword">in</span> (lo, hi))</span><br><span class="line"></span><br><span class="line">                memo[k, n] = ans</span><br><span class="line">            <span class="keyword">return</span> memo[k, n]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp(K, N)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>[solution1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; memo;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (memo.find(N * <span class="number">100</span> + K) == memo.end()) &#123;</span><br><span class="line">            <span class="keyword">int</span> ans;</span><br><span class="line">            <span class="keyword">if</span> (N == <span class="number">0</span>) ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (K == <span class="number">1</span>) ans = N;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> lo = <span class="number">1</span>, hi = N;</span><br><span class="line">                <span class="keyword">while</span> (lo + <span class="number">1</span> &lt; hi) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">int</span> t1 = dp(K<span class="number">-1</span>, x<span class="number">-1</span>);</span><br><span class="line">                    <span class="keyword">int</span> t2 = dp(K, N-x);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (t1 &lt; t2) lo = x;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (t1 &gt; t2) hi = x;</span><br><span class="line">                    <span class="keyword">else</span> lo = hi = x;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ans = <span class="number">1</span> + min(max(dp(K<span class="number">-1</span>, lo<span class="number">-1</span>), dp(K, N-lo)),</span><br><span class="line">                                   max(dp(K<span class="number">-1</span>, hi<span class="number">-1</span>), dp(K, N-hi)));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            memo[N * <span class="number">100</span> + K] = ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> memo[N * <span class="number">100</span> + K];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dp(K, N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(K * N\logN)  。我们需要计算 <em>O(K * N)</em> 个状态，每个状态计算时需要O(logN)的时间进行二分搜索。</p></li><li><p>空间复杂度：<em>O(K * N)*。我们需要 *O(K * N)</em> 的空间存储每个状态的解。</p></li></ul><h2 id="方法二：决策单调性"><a href="#方法二：决策单调性" class="headerlink" title="方法二：决策单调性"></a>方法二：决策单调性</h2><p><strong>说明</strong></p><p>方法二涉及决策单调性，是竞赛中的考点。这里我们不会叙述 <strong>何为决策单调性</strong> 以及 <strong>如何根据决策单调性写出优化的动态规划</strong>，而是仅指出决策单调性的存在性。</p><p><strong>思路</strong></p><p>我们重新写下方法一中的状态转移方程：</p><pre><code>dp(K,N)=1+min​(max(dp(K−1,X−1),dp(K,N−X))) 1≤X≤N</code></pre><p>并且假设Xopt​是使得 <em>dp(K, N)</em> 取到最优值的最小决策点 <em>X_0</em>。</p><pre><code>Xopt​=argmin​(max(dp(K−1,X−1),dp(K,N−X))) 1≤X≤N</code></pre><p>在方法一中，我们是通过二分查找的方法，找到 <em>X_0</em> 和 <em>X_1</em> 中最优的作为 Xopt​= 的，那么还有什么更好的方法吗？</p><p>我们固定 <em>K</em>，随着 <em>N</em> 的增加，对于状态转移方程中 <em>dp(K-1, X-1)</em> 这一项，它的值是不变的，因为它和 <em>N</em> 无关。而对于状态转移方程中 <em>dp(K, N-X)</em> 这一项，随着 <em>N</em> 的增加，它的值也会增加。在方法一中，我们知道 <em>dp(K-1, X-1)</em> 随着 <em>X</em> 单调递增，而 <em>dp(K, N-X)</em> 随着 <em>X</em> 单调递减，那么当 <em>N</em> 增加时，<em>dp(K, N-X)</em> 对应的函数折线图在每个整数点上都是增加的，因此在 <em>dp(K-1, X-1)</em> 不变的情况下， Xopt​ 是单调递增的。</p><p>我们可以想象一条斜率为负的直线和一条斜率为正的直线，当斜率为负的直线（类比 <em>dp(K, N-X)*）向上平移（类比 *N</em> 的增加）时，它和斜率为正的直线（类比 <em>dp(K-1, X-1)</em>）的交点会一直向右移动，这个交点就确定了 Xopt​ ，这与方法一也是一致的。</p><p>因此当我们固定 <em>K</em> 时，随着 <em>N</em> 的增加，<em>dp(K, N)</em> 对应的最优解的坐标Xopt​单调递增，这样一来每个 <em>dp(K, N)</em> 的均摊时间复杂度为 <em>O(1)</em>。</p><figure class="highlight java"><figcaption><span>[solution2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Right now, dp[i] represents dp(1, i)</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; ++i)</span><br><span class="line">            dp[i] = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= K; ++k) &#123;</span><br><span class="line">            <span class="comment">// Now, we will develop dp2[i] = dp(k, i)</span></span><br><span class="line">            <span class="keyword">int</span>[] dp2 = <span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">1</span>; n &lt;= N; ++n) &#123;</span><br><span class="line">                <span class="comment">// Let's find dp2[n] = dp(k, n)</span></span><br><span class="line">                <span class="comment">// Increase our optimal x while we can make our answer better.</span></span><br><span class="line">                <span class="comment">// Notice max(dp[x-1], dp2[n-x]) &gt; max(dp[x], dp2[n-x-1])</span></span><br><span class="line">                <span class="comment">// is simply max(T1(x-1), T2(x-1)) &gt; max(T1(x), T2(x)).</span></span><br><span class="line">                <span class="keyword">while</span> (x &lt; n &amp;&amp; Math.max(dp[x-<span class="number">1</span>], dp2[n-x]) &gt; Math.max(dp[x], dp2[n-x-<span class="number">1</span>]))</span><br><span class="line">                    x++;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// The final answer happens at this x.</span></span><br><span class="line">                dp2[n] = <span class="number">1</span> + Math.max(dp[x-<span class="number">1</span>], dp2[n-x]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dp = dp2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[N];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[solution2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">superEggDrop</span><span class="params">(self, K: int, N: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># Right now, dp[i] represents dp(1, i)</span></span><br><span class="line">        dp = list(range(N+<span class="number">1</span>))</span><br><span class="line">        dp2 = [<span class="number">0</span>] * (N+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">2</span>, K+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># Now, we will develop dp2[i] = dp(k, i)</span></span><br><span class="line">            x = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">1</span>, N+<span class="number">1</span>):</span><br><span class="line">                <span class="comment"># Let's find dp2[n] = dp(k, n)</span></span><br><span class="line">                <span class="comment"># Increase our optimal x while we can make our answer better.</span></span><br><span class="line">                <span class="comment"># Notice max(dp[x-1], dp2[n-x]) &gt; max(dp[x], dp2[n-x-1])</span></span><br><span class="line">                <span class="comment"># is simply max(T1(x-1), T2(x-1)) &gt; max(T1(x), T2(x)).</span></span><br><span class="line">                <span class="keyword">while</span> x &lt; n <span class="keyword">and</span> max(dp[x<span class="number">-1</span>], dp2[n-x]) &gt;= max(dp[x], dp2[n-x<span class="number">-1</span>]):</span><br><span class="line">                    x += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># The final answer happens at this x.</span></span><br><span class="line">                dp2[n] = <span class="number">1</span> + max(dp[x<span class="number">-1</span>], dp2[n-x])</span><br><span class="line"></span><br><span class="line">            dp = dp2[:]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>[solution2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[N + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; ++i) dp[i] = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= K; ++k) &#123;</span><br><span class="line">            <span class="keyword">int</span> dp2[N + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">1</span>; </span><br><span class="line">            dp2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">1</span>; n &lt;= N; ++n) &#123;</span><br><span class="line">                <span class="keyword">while</span> (x &lt; n &amp;&amp; max(dp[x<span class="number">-1</span>], dp2[n-x]) &gt;= max(dp[x], dp2[n-x<span class="number">-1</span>])) x++;</span><br><span class="line">                dp2[n] = <span class="number">1</span> + max(dp[x<span class="number">-1</span>], dp2[n-x]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">1</span>; n &lt;= N; ++n) dp[n] = dp2[n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[N];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(K * N)*。我们需要计算 *O(K * N)</em> 个状态，同时对于每个 <em>K</em>，最优解指针只会从 <em>0</em> 到 <em>N</em> 走一次，复杂度也是 <em>O(K * N)</em>。因此总体复杂度为 <em>O(K * N)</em>。</p></li><li><p>空间复杂度：<em>O(N)*。因为 *dp</em> 每一层的解只依赖于上一层的解，因此我们每次只保留一层的解，需要的空间复杂度为 <em>O(N)</em>。</p></li></ul><h2 id="方法三：数学法"><a href="#方法三：数学法" class="headerlink" title="方法三：数学法"></a>方法三：数学法</h2><p><strong>说明</strong></p><p>方法三涉及逆向思维，是一种没见过就不太可能想出来，读过题解也很容易忘记的方法。</p><p><strong>思路</strong></p><p>反过来想这个问题：如果我们可以做 <em>T</em> 次操作，而且有 <em>K</em> 个鸡蛋，那么我们能找到答案的最高的 <em>N</em> 是多少？我们设 <em>f(T, K)</em> 为在上述条件下的 <em>N</em>。如果我们求出了所有的 <em>f(T, K)</em>，那么只需要找出最小的满足  f(T,K)≥N  的 <em>T</em>。</p><p>那么我们如何求出 <em>f(T, K)</em> 呢？我们还是使用动态规划。因为我们需要找出最高的 <em>N</em>，因此我们不必思考到底在哪里扔这个鸡蛋，我们只需要扔出一个鸡蛋，看看到底发生了什么：</p><ul><li><p>如果鸡蛋没有碎，那么对应的是 <em>f(T - 1, K)*，也就是说在这一层的上方可以有 *f(T - 1, K)</em> 层；</p></li><li><p>如果鸡蛋碎了，那么对应的是 <em>f(T - 1, K - 1)*，也就是说在这一层的下方可以有 *f(T - 1， K - 1)</em> 层。</p></li></ul><p>因此我们就可以写出状态转移方程：</p><pre><code>f(T, K) = 1 + f(T-1, K-1) + f(T-1, K)</code></pre><p>边界条件为：当 T≥1 的时候 f(T, 1) = T，当K≥1 时，<em>f(1, K) = 1</em>。</p><p>那么问题来了：<strong><em>T</em> 最大可以达到多少</strong>？由于我们在进行动态规划时，<em>T</em> 在题目中并没有给出，那么我们需要进行到动态规划的哪一步呢？可以发现，操作次数是一定不会超过楼层数的，因此 T≤N，我们只要算出在 <em>f(N, K)</em> 内的所有 <em>f</em> 值即可。</p><figure class="highlight java"><figcaption><span>[solution3-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] f = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][K + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; ++i) &#123;</span><br><span class="line">            f[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= K; ++j) &#123;</span><br><span class="line">                f[i][j] = <span class="number">1</span> + f[i - <span class="number">1</span>][j - <span class="number">1</span>] + f[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (f[i][K] &gt;= N) &#123;</span><br><span class="line">                ans = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[solution3-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">superEggDrop</span><span class="params">(self, K: int, N: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        f = [[<span class="number">0</span>] * (K + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(N + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, K + <span class="number">1</span>):</span><br><span class="line">            f[<span class="number">1</span>][i] = <span class="number">1</span></span><br><span class="line">        ans = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, N + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, K + <span class="number">1</span>):</span><br><span class="line">                f[i][j] = <span class="number">1</span> + f[i - <span class="number">1</span>][j - <span class="number">1</span>] + f[i - <span class="number">1</span>][j]</span><br><span class="line">            <span class="keyword">if</span> f[i][K] &gt;= N:</span><br><span class="line">                ans = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>[solution3-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(K + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; ++i) &#123;</span><br><span class="line">            f[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= K; ++j) &#123;</span><br><span class="line">                f[i][j] = <span class="number">1</span> + f[i - <span class="number">1</span>][j - <span class="number">1</span>] + f[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (f[i][K] &gt;= N) &#123;</span><br><span class="line">                ans = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(K<em>N)</em>。事实上，更准确的时间复杂度应当为 <em>O(K * T)</em>，我们不加证明地给出 <em>N = O(T^K)</em>，因此有 ![O(K<em>T)=O(K</em>\sqrt[K]{N}) ](./p__O_K_</em><em>T__=<em>O</em>K</em>*<em>sqrt_K</em>{N}__.png) 。</p></li><li><p>空间复杂度：<em>O(K</em>N)*。</p></li></ul><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://leetcode-cn.com/problems/super-egg-drop/solution/ji-dan-diao-luo-by-leetcode-solution-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/super-egg-drop/solution/ji-dan-diao-luo-by-leetcode-solution-2/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;确定不摔碎鸡蛋的临界楼层的最小移动次数&lt;/p&gt;
    
    </summary>
    
      <category term="2020年5月" scheme="http://yoursite.com/categories/2020%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>21. 合并两个有序链表</title>
    <link href="http://yoursite.com/2020/05/27/21.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/05/27/21. 合并两个有序链表/</id>
    <published>2020-05-27T15:20:12.000Z</published>
    <updated>2020-05-27T16:01:03.665Z</updated>
    
    <content type="html"><![CDATA[<p>将两个升序链表合并为一个新的升序链表并返回</p><a id="more"></a><h1 id="📖题目描述："><a href="#📖题目描述：" class="headerlink" title="📖题目描述："></a>📖题目描述：</h1><p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例：</p><pre><code>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</code></pre><h1 id="📖方法一：递归"><a href="#📖方法一：递归" class="headerlink" title="📖方法一：递归"></a>📖方法一：递归</h1><p><strong>思路</strong></p><p>我们可以如下递归地定义两个链表里的 <code>merge</code> 操作（忽略边界情况，比如空链表等）：</p><pre><code>list1[0]+merge(list1[1:],list2)​    list1[0]&lt;list2[0]list2[0]+merge(list1,list2[1:])​    otherwise</code></pre><p>也就是说，两个链表头部值较小的一个节点与剩下元素的 <code>merge</code> 操作结果合并。</p><p><strong>算法</strong></p><p>我们直接将以上递归过程建模，同时需要考虑边界情况。</p><p>如果 <code>l1</code> 或者 <code>l2</code> 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 <code>l1</code> 和 <code>l2</code> 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束。</p><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[sol1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">elif</span> l2 <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        <span class="keyword">elif</span> l1.val &lt; l2.val:</span><br><span class="line">            l1.next = self.mergeTwoLists(l1.next, l2)</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l2.next = self.mergeTwoLists(l1, l2.next)</span><br><span class="line">            <span class="keyword">return</span> l2</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">        l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n + m)*，其中 *n</em> 和 <em>m</em> 分别为两个链表的长度。因为每次调用递归都会去掉 <code>l1</code> 或者 <code>l2</code> 的头节点（直到至少有一个链表为空），函数 <code>mergeTwoList</code> 至多只会递归调用每个节点一次。因此，时间复杂度取决于合并后的链表长度，即 <em>O(n+m)</em>。</p></li><li><p>空间复杂度：<em>O(n + m)*，其中 *n</em> 和 <em>m</em> 分别为两个链表的长度。递归调用 <code>mergeTwoLists</code> 函数时需要消耗栈空间，栈空间的大小取决于递归调用的深度。结束递归调用时 <code>mergeTwoLists</code> 函数最多调用 <em>n+m</em> 次，因此空间复杂度为 <em>O(n+m)</em>。</p></li></ul><h1 id="📖-方法二：迭代"><a href="#📖-方法二：迭代" class="headerlink" title="📖 方法二：迭代"></a>📖 方法二：迭代</h1><p><strong>思路</strong></p><p>我们可以用迭代的方法来实现上述算法。当 <code>l1</code> 和 <code>l2</code> 都不是空链表时，判断 <code>l1</code> 和 <code>l2</code> 哪一个链表的头节点的值更小，将较小值的节点添加到结果里，当一个节点被添加到结果里之后，将对应链表中的节点向后移一位。</p><p>这种暴力求解方法是首先想到的，但是在实现过程中忽略了使用伪节点，在while循环中判断的都是</p><pre><code>l1.next != null &amp;&amp; l2.next != null</code></pre><p>所以代码写的过于复杂都把自己绕晕了。</p><p><strong>算法</strong></p><p>首先，我们设定一个哨兵节点 <code>prehead</code> ，这可以在最后让我们比较容易地返回合并后的链表。我们维护一个 <code>prev</code> 指针，我们需要做的是调整它的 <code>next</code> 指针。然后，我们重复以下过程，直到 <code>l1</code> 或者 <code>l2</code> 指向了 <code>null</code> ：如果 <code>l1</code> 当前节点的值小于等于 <code>l2</code> ，我们就把 <code>l1</code> 当前的节点接在 <code>prev</code> 节点的后面同时将 <code>l1</code> 指针往后移一位。否则，我们对 <code>l2</code> 做同样的操作。不管我们将哪一个元素接在了后面，我们都需要把 <code>prev</code> 向后移一位。</p><p>在循环终止的时候， <code>l1</code> 和 <code>l2</code> 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表即可。</p><p> <code>1-&gt;4-&gt;5</code> 和 <code>1-&gt;2-&gt;3-&gt;6</code> 两个链表迭代合并的过程见参考资料【2】：</p><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode prehead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        ListNode prev = prehead;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">                prev.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span></span><br><span class="line">        prev.next = l1 == <span class="keyword">null</span> ? l2 : l1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prehead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[sol2-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        prehead = ListNode(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        prev = prehead</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">                prev.next = l1</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prev.next = l2</span><br><span class="line">                l2 = l2.next            </span><br><span class="line">            prev = prev.next</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span></span><br><span class="line">        prev.next = l1 <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">else</span> l2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prehead.next</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><figcaption><span>[sol2-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> prehead = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> prev = prehead;</span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">            prev.next = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev.next = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = prev.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span></span><br><span class="line">    prev.next = l1 === <span class="literal">null</span> ? l2 : l1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prehead.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* preHead = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        ListNode* prev = preHead;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                prev-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span></span><br><span class="line">        prev-&gt;next = l1 == <span class="literal">nullptr</span> ? l2 : l1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> preHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n + m)</em> ，其中 <em>n</em> 和 <em>m</em> 分别为两个链表的长度。因为每次循环迭代中，<code>l1</code> 和 <code>l2</code> 只有一个元素会被放进合并链表中， 因此 <code>while</code> 循环的次数不会超过两个链表的长度之和。所有其他操作的时间复杂度都是常数级别的，因此总的时间复杂度为 <em>O(n+m)</em>。</p></li><li><p>空间复杂度：<em>O(1)</em> 。我们只需要常数的空间存放若干变量。</p></li></ul><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-sorted-lists</a></p><p>【2】<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;将两个升序链表合并为一个新的升序链表并返回&lt;/p&gt;
    
    </summary>
    
      <category term="2020年5月" scheme="http://yoursite.com/categories/2020%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>685.冗余链接II</title>
    <link href="http://yoursite.com/2020/05/26/685.%E5%86%97%E4%BD%99%E9%93%BE%E6%8E%A5II/"/>
    <id>http://yoursite.com/2020/05/26/685.冗余链接II/</id>
    <published>2020-05-26T12:26:12.000Z</published>
    <updated>2020-05-27T16:00:57.870Z</updated>
    
    <content type="html"><![CDATA[<p>使用并查集找到一条可以删去的边。</p><a id="more"></a><h1 id="📖题目描述："><a href="#📖题目描述：" class="headerlink" title="📖题目描述："></a>📖题目描述：</h1><p>在本问题中，有根树指满足以下条件的有向图。该树只有一个根节点，所有其他节点都是该根节点的后继。每一个节点只有一个父节点，除了根节点没有父节点。</p><p>输入一个有向图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。</p><p>结果图是一个以边组成的二维数组。 每一个边 的元素是一对 [u, v]，用以表示有向图中连接顶点 u and v和顶点的边，其中父节点u是子节点v的一个父节点。</p><p>返回一条能删除的边，使得剩下的图是有N个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。</p><p>示例 1:</p><pre><code>输入: [[1,2], [1,3], [2,3]]输出: [2,3]解释: 给定的有向图如下:  1 / \v   v2--&gt;3</code></pre><p>示例 2:</p><pre><code>输入: [[1,2], [2,3], [3,4], [4,1], [1,5]]输出: [4,1]解释: 给定的有向图如下:5 &lt;- 1 -&gt; 2     ^    |     |    v     4 &lt;- 3</code></pre><p>注意:</p><pre><code>二维数组大小的在3到1000范围内。二维数组中的每个整数在1到N之间，其中 N 是二维数组的大小。</code></pre><h1 id="📖解题思路："><a href="#📖解题思路：" class="headerlink" title="📖解题思路："></a>📖解题思路：</h1><p>通过分情况讨论，把hard题分为3个medium题来做。</p><ol><li><p>情况1是多出的边指向某个非root的结点，该结点记为end，它的入度为2，出度不为0，此时答案只可能为指向end的两条边之一，注意这时候答案唯一，删错边可能导致图不联通，无法构成树:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2 -&gt; 1</span><br><span class="line">^  / ^</span><br><span class="line">| v  |</span><br><span class="line">4    3</span><br></pre></td></tr></table></figure></li><li><p>情况2与情况1类似，存在入度为2但出度为0的end结点，此时答案不唯一，删掉指向end的哪条边都能使得图变成树，按照题目要求返回最后环内最后出现的边即可:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5 &lt;- 1 -&gt; 2</span><br><span class="line">     |    |</span><br><span class="line">     v    v</span><br><span class="line">     4 &lt;- 3</span><br></pre></td></tr></table></figure></li><li><p>情况3是多出的边指向root，所有结点的入度都是1，此时答案不唯一，删除环内任意边都可以，按照题目要求返回最后环内最后出现的边即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5 &lt;- 1 -&gt; 2</span><br><span class="line">     ^    |</span><br><span class="line">     |    v</span><br><span class="line">     4 &lt;- 3</span><br></pre></td></tr></table></figure></li></ol><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>根据以上分析，代码可以通过分情况讨论，把这道hard题分为多个medium题来做。（这里假设你已经懂了并查集，若不懂，可以先做一下这题<a href="https://leetcode-cn.com/problems/redundant-connection/" target="_blank" rel="noopener">684.冗余链接I</a>，把并查集学一下）</p><ul><li>情况1和2可以合并处理，并查集合并所有边，对于指向end的边只合并第一条，若最后联通分量合并为1，则可以把指向end的第二条边删除，否则只能删除第一条边。</li><li>情况3时,这时候题目退化为<a href="https://leetcode-cn.com/problems/redundant-connection/" target="_blank" rel="noopener">684.冗余链接I</a>，解法相同，即用并查集不断合并结点，直到将要合并的顶点已经联通了，则当前边是多余的，可删掉。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test case:</span></span><br><span class="line"><span class="comment">// [[1,2],[1,3],[2,3]]</span></span><br><span class="line"><span class="comment">// [[1,2], [2,3], [3,4], [4,1], [1,5]]</span></span><br><span class="line"><span class="comment">// [[2,1],[3,1],[4,2],[1,4]]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parents;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">MyFind</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(a != parents[a])&#123;</span><br><span class="line">            parents[a] = parents[parents[a]];<span class="comment">// 稍微压缩一下路径</span></span><br><span class="line">            a = parents[a];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsConnect</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = MyFind(a);</span><br><span class="line">        <span class="keyword">int</span> p2 = MyFind(b);</span><br><span class="line">        <span class="keyword">return</span> p1 == p2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MyUnion</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = MyFind(a);</span><br><span class="line">        <span class="keyword">int</span> p2 = MyFind(b);</span><br><span class="line">        <span class="keyword">if</span>(p1 == p2) <span class="keyword">return</span>;</span><br><span class="line">        parents[p1] = p2;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findRedundantDirectedConnection(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges) &#123;</span><br><span class="line">        <span class="comment">// 统计大家出入度，并找到入度为2的终点（若有的话）</span></span><br><span class="line">        <span class="keyword">int</span> n = edges.size(); <span class="comment">// n个顶点，注意顶点从1开始</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inDegree(n); <span class="comment">// 入度</span></span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;e : edges)&#123;</span><br><span class="line">            inDegree[e[<span class="number">1</span>]<span class="number">-1</span>]++; <span class="comment">// 入度+1</span></span><br><span class="line">            <span class="keyword">if</span>(inDegree[e[<span class="number">1</span>]<span class="number">-1</span>] &gt; <span class="number">1</span>) end = e[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 并查集初始化</span></span><br><span class="line">        count = edges.size();</span><br><span class="line">        parents.resize(count);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;count; ++i)&#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若有end，则为情况1、2，答案为指向end的两条边之一</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span> != end)&#123;</span><br><span class="line">            <span class="keyword">bool</span> is_first = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge_first;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge_second;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;e : edges)&#123;</span><br><span class="line">                <span class="comment">// 对于指向end的两条边，只合并第一条，看最后是否能联通</span></span><br><span class="line">                <span class="keyword">if</span>(e[<span class="number">1</span>] == end)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(is_first)&#123;</span><br><span class="line">                        is_first = <span class="literal">false</span>;</span><br><span class="line">                        MyUnion(e[<span class="number">0</span>]<span class="number">-1</span>, e[<span class="number">1</span>]<span class="number">-1</span>);</span><br><span class="line">                        edge_first = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        edge_second = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    MyUnion(e[<span class="number">0</span>]<span class="number">-1</span>, e[<span class="number">1</span>]<span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 有可能删掉任意边都行，这时优先返回靠后的边，即second</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="number">1</span> == count) <span class="keyword">return</span> edge_second;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> edge_first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若无end，则删除环路中任意一条边都行，按照题意，删除环路中最后出现的那条边</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;e : edges)&#123;</span><br><span class="line">                <span class="comment">// 若将添加的边已经有连接了，则该边可删除</span></span><br><span class="line">                <span class="keyword">if</span>(IsConnect(e[<span class="number">0</span>]<span class="number">-1</span>, e[<span class="number">1</span>]<span class="number">-1</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">                MyUnion(e[<span class="number">0</span>]<span class="number">-1</span>, e[<span class="number">1</span>]<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不会运行到这里</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://leetcode-cn.com/problems/redundant-connection-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/redundant-connection-ii</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用并查集找到一条可以删去的边。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年5月" scheme="http://yoursite.com/categories/2020%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
      <category term="Union Find" scheme="http://yoursite.com/tags/Union-Find/"/>
    
      <category term="Graph" scheme="http://yoursite.com/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>1226. 哲学家进餐</title>
    <link href="http://yoursite.com/2020/05/26/1226.%20%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90/"/>
    <id>http://yoursite.com/2020/05/26/1226. 哲学家进餐/</id>
    <published>2020-05-25T16:05:12.000Z</published>
    <updated>2020-05-26T14:17:26.445Z</updated>
    
    <content type="html"><![CDATA[<p>哲学家就餐问题</p><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>5 个沉默寡言的哲学家围坐在圆桌前，每人面前一盘意面。叉子放在哲学家之间的桌面上。（5 个哲学家，5 根叉子）</p><p>所有的哲学家都只会在思考和进餐两种行为间交替。哲学家只有同时拿到左边和右边的叉子才能吃到面，而同一根叉子在同一时间只能被一个哲学家使用。每个哲学家吃完面后都需要把叉子放回桌面以供其他哲学家吃面。只要条件允许，哲学家可以拿起左边或者右边的叉子，但在没有同时拿到左右叉子时不能进食。</p><p>假设面的数量没有限制，哲学家也能随便吃，不需要考虑吃不吃得下。</p><p>设计一个进餐规则（并行算法）使得每个哲学家都不会挨饿；也就是说，在没有人知道别人什么时候想吃东西或思考的情况下，每个哲学家都可以在吃饭和思考之间一直交替下去。</p><p>哲学家从 0 到 4 按 顺时针 编号。请实现函数</p><pre><code>void wantsToEat(philosopher, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork)：philosopher 哲学家的编号。pickLeftFork 和 pickRightFork 表示拿起左边或右边的叉子。eat 表示吃面。putLeftFork 和 putRightFork 表示放下左边或右边的叉子。</code></pre><p>由于哲学家不是在吃面就是在想着啥时候吃面，所以思考这个方法没有对应的回调。<br>给你 5 个线程，每个都代表一个哲学家，请你使用类的同一个对象来模拟这个过程。在最后一次调用结束之前，可能会为同一个哲学家多次调用该函数。</p><p>示例：</p><pre><code>输入：n = 1输出：[[4,2,1],[4,1,1],[0,1,1],[2,2,1],[2,1,1],[2,0,3],[2,1,2],[2,2,2],[4,0,3],[4,1,2],[0,2,1],[4,2,2],[3,2,1],[3,1,1],[0,0,3],[0,1,2],[0,2,2],[1,2,1],[1,1,1],[3,0,3],[3,1,2],[3,2,2],[1,0,3],[1,1,2],[1,2,2]]</code></pre><p>解释:</p><pre><code>n 表示每个哲学家需要进餐的次数。输出数组描述了叉子的控制和进餐的调用，它的格式如下：output[i] = [a, b, c] (3个整数)- a 哲学家编号。- b 指定叉子：{1 : 左边, 2 : 右边}.- c 指定行为：{1 : 拿起, 2 : 放下, 3 : 吃面}。如 [4,2,1] 表示 4 号哲学家拿起了右边的叉子。</code></pre><p>提示：</p><pre><code>1 &lt;= n &lt;= 60</code></pre><h1 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h1><p>这道题本质上其实是想考察<strong>如何避免死锁</strong>。<br>易知：当 <em>5</em> 个哲学家都拿着其左边(或右边)的叉子时，会进入死锁。</p><p>PS：死锁的 <em>4</em> 个必要条件：</p><ol><li>互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</li><li>请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</li><li>不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。</li><li>循环等待条件: 若干进程间形成首尾相接循环等待资源的关系。</li></ol><p>故<strong>最多</strong>只允许 <em>4</em> 个哲学家去持有叉子，可保证至少有 <em>1</em> 个哲学家能吃上意大利面（即获得到 <em>2</em> 个叉子）。<br>因为最差情况下是：<em>4</em> 个哲学家都各自持有1个叉子，此时还 <strong>剩余 <em>1</em> 个叉子</strong> 可供使用，这 <em>4</em> 个哲学家中必然有1人能获取到这个 <strong>剩余的 <em>1</em> 个叉子</strong>，从而手持 <em>2</em> 个叉子，可以吃意大利面。<br>即：<em>4</em> 个人中，<em>1</em> 个人有 <em>2</em> 个叉子，<em>3</em> 个人各持 <em>1</em> 个叉子，共计 <em>5</em> 个叉子。</p><p>既然<strong>最多</strong>只允许4个哲学家去持有叉子，那么如果只允许3个哲学家去持有叉子是否可行呢？</p><p>当然可行，<em>3</em>个哲学家可以先都各自持有<em>1</em>把叉子，此时还剩余<em>2</em>把叉子；</p><p>当这<em>3</em>个哲学家刚好都相邻(比如：编号为图中的<code>0, 1, 2</code>)，可能会造成只有<em>1</em>个哲学家能吃到意面的情况，具体而言即<code>0</code>号哲学家拿到了其左侧的叉子(编号为<code>1</code>)，<code>1</code>号哲学家也拿到了其左侧的叉子(编号为<code>2</code>)，<code>2</code>号哲学家也拿到了其左侧的叉子(编号为<code>3</code>)，此时只有<code>0</code>号哲学家能拿到其右侧的叉子(编号为<code>0</code>)，因此只有<code>0</code>号哲学家能吃到意面。<br>而其余情况下，<code>3</code>个哲学家中都能有<code>2</code>人吃到意面。<br>即：<em>3</em> 个人中，<em>2</em> 个人各自持有 <em>2</em> 个叉子，<em>1</em> 个人持有 <em>1</em> 个叉子，共计 <em>5</em> 个叉子。</p><p>并且仔细想想，叉子的数目是<strong>固定</strong>的(个数为<code>5</code>)，直觉上来讲<code>3</code>个人去抢<code>5</code>个叉子 比 <code>4</code>个人去抢<code>5</code>个叉子效率高。</p><h1 id="方法一：信号量"><a href="#方法一：信号量" class="headerlink" title="方法一：信号量"></a>方法一：信号量</h1><p>用<code>Semaphore</code>去实现上述的限制：<code>Semaphore eatLimit = new Semaphore(4);</code><br>一共有5个叉子，视为5个<code>ReentrantLock</code>，并将它们全放入1个数组中。</p><p><code>ReentrantLock</code>的使用方法和介绍见我的博文《<strong>1115. 交替打印FooBar</strong>》</p><p>给叉子编号 <em>0, 1, 2, 3, 4</em>（对应数组下标）。<br>具体编号如下图这般设计的：</p><p> <a href="https://pic.leetcode-cn.com/30159b01ce754904bbc76bb81e52cfb5751b074f811ba88919bb3a0b861e02d8-%E5%93%B2%E5%AD%A6%E5%AE%B6%E9%97%AE%E9%A2%98%E5%9B%BE.png" target="_blank" rel="noopener">哲学家问题图.png</a></p><p>有了这些思路，代码实现就变得清晰起来。</p><p>代码具体实现：</p><figure class="highlight java"><figcaption><span>[-方法1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiningPhilosophers</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1个Fork视为1个ReentrantLock，5个叉子即5个ReentrantLock，将其都放入数组中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock[] lockList = &#123;<span class="keyword">new</span> ReentrantLock(),</span><br><span class="line">            <span class="keyword">new</span> ReentrantLock(),</span><br><span class="line">            <span class="keyword">new</span> ReentrantLock(),</span><br><span class="line">            <span class="keyword">new</span> ReentrantLock(),</span><br><span class="line">            <span class="keyword">new</span> ReentrantLock()&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//限制 最多只有4个哲学家去持有叉子</span></span><br><span class="line">    <span class="keyword">private</span> Semaphore eatLimit = <span class="keyword">new</span> Semaphore(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiningPhilosophers</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call the run() method of any runnable to execute its code</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wantsToEat</span><span class="params">(<span class="keyword">int</span> philosopher,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickRightFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable eat,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putRightFork)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftFork = (philosopher + <span class="number">1</span>) % <span class="number">5</span>;    <span class="comment">//左边的叉子 的编号</span></span><br><span class="line">        <span class="keyword">int</span> rightFork = philosopher;    <span class="comment">//右边的叉子 的编号</span></span><br><span class="line"></span><br><span class="line">        eatLimit.acquire();    <span class="comment">//限制的人数 -1</span></span><br><span class="line"></span><br><span class="line">        lockList[leftFork].lock();    <span class="comment">//拿起左边的叉子</span></span><br><span class="line">        lockList[rightFork].lock();    <span class="comment">//拿起右边的叉子</span></span><br><span class="line"></span><br><span class="line">        pickLeftFork.run();    <span class="comment">//拿起左边的叉子 的具体执行</span></span><br><span class="line">        pickRightFork.run();    <span class="comment">//拿起右边的叉子 的具体执行</span></span><br><span class="line"></span><br><span class="line">        eat.run();    <span class="comment">//吃意大利面 的具体执行</span></span><br><span class="line"></span><br><span class="line">        putLeftFork.run();    <span class="comment">//放下左边的叉子 的具体执行</span></span><br><span class="line">        putRightFork.run();    <span class="comment">//放下右边的叉子 的具体执行</span></span><br><span class="line"></span><br><span class="line">        lockList[leftFork].unlock();    <span class="comment">//放下左边的叉子</span></span><br><span class="line">        lockList[rightFork].unlock();    <span class="comment">//放下右边的叉子</span></span><br><span class="line"></span><br><span class="line">        eatLimit.release();<span class="comment">//限制的人数 +1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最多</strong>只允许4个哲学家去持有叉子时</p><pre><code>执行耗时:15 ms,击败了78.39% 的Java用户</code></pre><p>而改为<strong>最多</strong>只允许4，3，2，1个哲学家去持有叉子时</p><pre><code>执行耗时都是14 ms,击败了94.24% 的Java用户</code></pre><p>接下来的2个方法来自作者mike-meng，链接见参考资料【2】，他是用C++实现的，将其转为Java代码如下：</p><h1 id="方法-2："><a href="#方法-2：" class="headerlink" title="方法 2："></a><strong>方法 <em>2</em>：</strong></h1><p>设置 <em>1</em> 个临界区以实现 <em>1</em> 个哲学家 “<strong>同时</strong>”拿起左右  <strong><em>2</em> 把叉子</strong>的效果。<br>即进入临界区之后，保证<strong>成功获取</strong>到左右 <strong><em>2</em> 把叉子</strong> 并 执行相关代码后，才退出临界区。</p><p>评论区看到有题友说方法2就是“只让1个哲学家就餐”的思路，无需将叉子视为<code>ReentrantLock</code>。</p><p>下面也给出了“只允许1个哲学家就餐”的代码。</p><p>但是2者之间还是有<strong>细微</strong>的<strong>差别</strong>：<br>方法2是在成功<strong>拿起左右叉子之后</strong>就退出临界区，而“只让1个哲学家就餐”是在<strong>拿起左右叉子 + 吃意面 + 放下左右叉子</strong> 一套流程走完之后才退出临界区。</p><p>前者的情况可大概分为2种，举具体例子说明(可参照上面给出的图片)：</p><ol><li><code>1</code>号哲学家拿起左右叉子(<code>1</code>号叉子 + <code>2</code>号叉子)后就退出临界区，此时<code>4</code>号哲学家成功挤进临界区，他也成功拿起了左右叉子(<code>0</code>号叉子和<code>4</code>号叉子)，然后就退出临界区。</li><li><code>1</code>号哲学家拿起左右叉子(<code>1</code>号叉子 + <code>2</code>号叉子)后就退出临界区，此时<code>2</code>号哲学家成功挤进临界区，他需要拿起<code>2</code>号叉子和<code>3</code>号叉子，但<code>2</code>号叉子有一定的概率还被<code>1</code>号哲学家持有(<code>1</code>号哲学家意面还没吃完)，因此<code>2</code>号哲学家进入临界区后还需要等待<code>2</code>号叉子。至于<code>3</code>号叉子，根本没其他人跟<code>2</code>号哲学家争夺，因此可以将该种情况视为“<code>2</code>号哲学家只拿起了1只叉子，在等待另1只叉子”的情况。</li></ol><p>总之，第1种情况即<strong>先后进入临界区</strong>的<strong>2位哲学家</strong>的左右叉子不存在竞争情况，因此先后进入临界区的2位哲学家进入临界区后都不用等待叉子，直接就餐。此时可视为2个哲学家在同时就餐(当然前1个哲学家有可能已经吃完了，但姑且当作是2个人同时就餐)。</p><p>第2种情况即先后进入临界区的2位哲学家的左右叉子存在竞争情况(说明这2位哲学家的<strong>编号相邻</strong>)，因此<strong>后进入临界区</strong>的哲学家还需要等待1只叉子，才能就餐。此时可视为只有1个哲学家在就餐。</p><p>至于“只允许1个哲学家就餐”的代码，很好理解，每次严格地只让1个哲学家就餐，由于过于严格，以至于都不需要将叉子视为<code>ReentrantLock</code>。</p><p>方法<code>2</code>有一定的概率是“并行”，“只允许1个哲学家就餐”是严格的“串行”。</p><p>代码如下：</p><figure class="highlight java"><figcaption><span>[-方法2]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiningPhilosophers</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1个Fork视为1个ReentrantLock，5个叉子即5个ReentrantLock，将其都放入数组中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock[] lockList = &#123;<span class="keyword">new</span> ReentrantLock(),</span><br><span class="line">            <span class="keyword">new</span> ReentrantLock(),</span><br><span class="line">            <span class="keyword">new</span> ReentrantLock(),</span><br><span class="line">            <span class="keyword">new</span> ReentrantLock(),</span><br><span class="line">            <span class="keyword">new</span> ReentrantLock()&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//让 1个哲学家可以 “同时”拿起2个叉子(搞个临界区)</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock pickBothForks = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiningPhilosophers</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call the run() method of any runnable to execute its code</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wantsToEat</span><span class="params">(<span class="keyword">int</span> philosopher,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickRightFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable eat,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putRightFork)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftFork = (philosopher + <span class="number">1</span>) % <span class="number">5</span>;    <span class="comment">//左边的叉子 的编号</span></span><br><span class="line">        <span class="keyword">int</span> rightFork = philosopher;    <span class="comment">//右边的叉子 的编号</span></span><br><span class="line"></span><br><span class="line">        pickBothForks.lock();    <span class="comment">//进入临界区</span></span><br><span class="line"></span><br><span class="line">        lockList[leftFork].lock();    <span class="comment">//拿起左边的叉子</span></span><br><span class="line">        lockList[rightFork].lock();    <span class="comment">//拿起右边的叉子</span></span><br><span class="line"></span><br><span class="line">        pickLeftFork.run();    <span class="comment">//拿起左边的叉子 的具体执行</span></span><br><span class="line">        pickRightFork.run();    <span class="comment">//拿起右边的叉子 的具体执行</span></span><br><span class="line"></span><br><span class="line">        pickBothForks.unlock();    <span class="comment">//退出临界区</span></span><br><span class="line"></span><br><span class="line">        eat.run();    <span class="comment">//吃意大利面 的具体执行</span></span><br><span class="line"></span><br><span class="line">        putLeftFork.run();    <span class="comment">//放下左边的叉子 的具体执行</span></span><br><span class="line">        putRightFork.run();    <span class="comment">//放下右边的叉子 的具体执行</span></span><br><span class="line"></span><br><span class="line">        lockList[leftFork].unlock();    <span class="comment">//放下左边的叉子</span></span><br><span class="line">        lockList[rightFork].unlock();    <span class="comment">//放下右边的叉子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[-只允许1个哲学家就餐]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiningPhilosophers</span> </span>&#123;</span><br><span class="line">    <span class="comment">//只允许1个哲学家就餐</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock pickBothForks = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiningPhilosophers</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call the run() method of any runnable to execute its code</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wantsToEat</span><span class="params">(<span class="keyword">int</span> philosopher,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickRightFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable eat,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putRightFork)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftFork = (philosopher + <span class="number">1</span>) % <span class="number">5</span>;    <span class="comment">//左边的叉子 的编号</span></span><br><span class="line">        <span class="keyword">int</span> rightFork = philosopher;    <span class="comment">//右边的叉子 的编号</span></span><br><span class="line"></span><br><span class="line">        pickBothForks.lock();    <span class="comment">//进入临界区</span></span><br><span class="line"></span><br><span class="line">        pickLeftFork.run();    <span class="comment">//拿起左边的叉子 的具体执行</span></span><br><span class="line">        pickRightFork.run();    <span class="comment">//拿起右边的叉子 的具体执行</span></span><br><span class="line"></span><br><span class="line">        eat.run();    <span class="comment">//吃意大利面 的具体执行</span></span><br><span class="line"></span><br><span class="line">        putLeftFork.run();    <span class="comment">//放下左边的叉子 的具体执行</span></span><br><span class="line">        putRightFork.run();    <span class="comment">//放下右边的叉子 的具体执行</span></span><br><span class="line"></span><br><span class="line">        pickBothForks.unlock();    <span class="comment">//退出临界区</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h2><p>  临界资源是一次仅允许一个进程使用的共享资源。各进程采取互斥的方式，实现共享的资源称作临界资源。属于临界资源的硬件有，打印机，磁带机等；软件有消息队列，变量，数组，缓冲区等。诸进程间采取互斥方式，实现对这种资源的共享。</p><h2 id="临界区："><a href="#临界区：" class="headerlink" title="临界区："></a>临界区：</h2><p>  每个进程中访问临界资源的那段代码称为临界区（criticalsection），每次只允许一个进程进入临界区，进入后，不允许其他进程进入。不论是硬件临界资源还是软件临界资源，多个进程必须互斥的对它进行访问。多个进程涉及到同一个临界资源的的临界区称为相关临界区。使用临界区时，一般不允许其运行时间过长，只要运行在临界区的线程还没有离开，其他所有进入此临界区的线程都会被挂起而进入等待状态，并在一定程度上影响程序的运行性能。</p><h1 id="方法-3："><a href="#方法-3：" class="headerlink" title="方法 3："></a><strong>方法 <em>3</em>：</strong></h1><p>前面说过，该题的本质是考察 <strong>如何避免死锁</strong>。<br>而当5个哲学家都<strong>左手持有</strong>其<strong>左边的叉子</strong> 或 当5个哲学家都<strong>右手持有</strong>其<strong>右边的叉子</strong>时，会发生<strong>死锁</strong>。<br>故只需设计1个避免发生上述情况发生的策略即可。</p><p>即可以让<strong>一部分哲学家</strong>优先去获取其左边的叉子，再去获取其右边的叉子；再让<strong>剩余哲学家</strong>优先去获取其右边的叉子，再去获取其左边的叉子。</p><p>代码如下：</p><figure class="highlight java"><figcaption><span>[-方法3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiningPhilosophers</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1个Fork视为1个ReentrantLock，5个叉子即5个ReentrantLock，将其都放入数组中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock[] lockList = &#123;<span class="keyword">new</span> ReentrantLock(),</span><br><span class="line">            <span class="keyword">new</span> ReentrantLock(),</span><br><span class="line">            <span class="keyword">new</span> ReentrantLock(),</span><br><span class="line">            <span class="keyword">new</span> ReentrantLock(),</span><br><span class="line">            <span class="keyword">new</span> ReentrantLock()&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiningPhilosophers</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call the run() method of any runnable to execute its code</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wantsToEat</span><span class="params">(<span class="keyword">int</span> philosopher,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickRightFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable eat,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putRightFork)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftFork = (philosopher + <span class="number">1</span>) % <span class="number">5</span>;    <span class="comment">//左边的叉子 的编号</span></span><br><span class="line">        <span class="keyword">int</span> rightFork = philosopher;    <span class="comment">//右边的叉子 的编号</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//编号为偶数的哲学家，优先拿起左边的叉子，再拿起右边的叉子</span></span><br><span class="line">        <span class="keyword">if</span> (philosopher % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            lockList[leftFork].lock();    <span class="comment">//拿起左边的叉子</span></span><br><span class="line">            lockList[rightFork].lock();    <span class="comment">//拿起右边的叉子</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//编号为奇数的哲学家，优先拿起右边的叉子，再拿起左边的叉子</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            lockList[rightFork].lock();    <span class="comment">//拿起右边的叉子</span></span><br><span class="line">            lockList[leftFork].lock();    <span class="comment">//拿起左边的叉子</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pickLeftFork.run();    <span class="comment">//拿起左边的叉子 的具体执行</span></span><br><span class="line">        pickRightFork.run();    <span class="comment">//拿起右边的叉子 的具体执行</span></span><br><span class="line"></span><br><span class="line">        eat.run();    <span class="comment">//吃意大利面 的具体执行</span></span><br><span class="line"></span><br><span class="line">        putLeftFork.run();    <span class="comment">//放下左边的叉子 的具体执行</span></span><br><span class="line">        putRightFork.run();    <span class="comment">//放下右边的叉子 的具体执行</span></span><br><span class="line"></span><br><span class="line">        lockList[leftFork].unlock();    <span class="comment">//放下左边的叉子</span></span><br><span class="line">        lockList[rightFork].unlock();    <span class="comment">//放下右边的叉子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="改进"><a href="#改进" class="headerlink" title="改进:"></a>改进:</h1><p><strong>位运算</strong>就可以表示<code>5</code>个叉子的<strong>使用状态</strong>，只需用1个<code>volatile</code>修饰的<code>int</code>变量即可 + <code>CAS</code>操作即可。<br>而<code>volatile</code>修饰的<code>int</code>变量 + <code>CAS</code>操作 <code>-&gt;</code> <code>AtomicInteger</code>类</p><figure class="highlight java"><figcaption><span>[-改进的方法1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiningPhilosophers</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化为0, 二进制表示则为00000, 说明当前所有叉子都未被使用</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger fork = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//每个叉子的int值(即二进制的00001, 00010, 00100, 01000, 10000)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] forkMask = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>&#125;;</span><br><span class="line">    <span class="comment">//限制 最多只有4个哲学家去持有叉子</span></span><br><span class="line">    <span class="keyword">private</span> Semaphore eatLimit = <span class="keyword">new</span> Semaphore(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiningPhilosophers</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call the run() method of any runnable to execute its code</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wantsToEat</span><span class="params">(<span class="keyword">int</span> philosopher,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickRightFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable eat,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putRightFork)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftMask = forkMask[(philosopher + <span class="number">1</span>) % <span class="number">5</span>], rightMask = forkMask[philosopher];</span><br><span class="line">        eatLimit.acquire();    <span class="comment">//限制的人数 -1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!pickFork(leftMask)) Thread.sleep(<span class="number">1</span>);    <span class="comment">//拿起左边的叉子</span></span><br><span class="line">        <span class="keyword">while</span> (!pickFork(rightMask)) Thread.sleep(<span class="number">1</span>);   <span class="comment">//拿起右边的叉子</span></span><br><span class="line"></span><br><span class="line">        pickLeftFork.run();    <span class="comment">//拿起左边的叉子 的具体执行</span></span><br><span class="line">        pickRightFork.run();    <span class="comment">//拿起右边的叉子 的具体执行</span></span><br><span class="line"></span><br><span class="line">        eat.run();    <span class="comment">//吃意大利面 的具体执行</span></span><br><span class="line"></span><br><span class="line">        putLeftFork.run();    <span class="comment">//放下左边的叉子 的具体执行</span></span><br><span class="line">        putRightFork.run();    <span class="comment">//放下右边的叉子 的具体执行</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!putFork(leftMask)) Thread.sleep(<span class="number">1</span>);     <span class="comment">//放下左边的叉子</span></span><br><span class="line">        <span class="keyword">while</span> (!putFork(rightMask)) Thread.sleep(<span class="number">1</span>);    <span class="comment">//放下右边的叉子</span></span><br><span class="line"></span><br><span class="line">        eatLimit.release(); <span class="comment">//限制的人数 +1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">pickFork</span><span class="params">(<span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> expect = fork.get();</span><br><span class="line">        <span class="keyword">return</span> (expect &amp; mask) &gt; <span class="number">0</span> ? <span class="keyword">false</span> : fork.compareAndSet(expect, expect ^ mask);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">putFork</span><span class="params">(<span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> expect = fork.get();</span><br><span class="line">        <span class="keyword">return</span> fork.compareAndSet(expect, expect ^ mask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[-改进的方法2]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiningPhilosophers</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化为0, 二进制表示则为00000, 说明当前所有叉子都未被使用</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger fork = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>), both = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//每个叉子的int值(即二进制的00001, 00010, 00100, 01000, 10000)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] forkMask = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiningPhilosophers</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call the run() method of any runnable to execute its code</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wantsToEat</span><span class="params">(<span class="keyword">int</span> philosopher,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickRightFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable eat,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putRightFork)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftMask = forkMask[(philosopher + <span class="number">1</span>) % <span class="number">5</span>], rightMask = forkMask[philosopher];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!both.compareAndSet(<span class="number">0</span>, <span class="number">1</span>)) Thread.sleep(<span class="number">1</span>);     <span class="comment">//进入临界区</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!pickFork(leftMask)) Thread.sleep(<span class="number">1</span>);    <span class="comment">//拿起左边的叉子</span></span><br><span class="line">        <span class="keyword">while</span> (!pickFork(rightMask)) Thread.sleep(<span class="number">1</span>);   <span class="comment">//拿起右边的叉子</span></span><br><span class="line"></span><br><span class="line">        pickLeftFork.run();    <span class="comment">//拿起左边的叉子 的具体执行</span></span><br><span class="line">        pickRightFork.run();    <span class="comment">//拿起右边的叉子 的具体执行</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!both.compareAndSet(<span class="number">1</span>, <span class="number">0</span>)) Thread.sleep(<span class="number">1</span>);    <span class="comment">//退出临界区</span></span><br><span class="line"></span><br><span class="line">        eat.run();    <span class="comment">//吃意大利面 的具体执行</span></span><br><span class="line"></span><br><span class="line">        putLeftFork.run();    <span class="comment">//放下左边的叉子 的具体执行</span></span><br><span class="line">        putRightFork.run();    <span class="comment">//放下右边的叉子 的具体执行</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!putFork(rightMask)) Thread.sleep(<span class="number">1</span>);   <span class="comment">//放下右边的叉子</span></span><br><span class="line">        <span class="keyword">while</span> (!putFork(leftMask)) Thread.sleep(<span class="number">1</span>);    <span class="comment">//放下左边的叉子</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">pickFork</span><span class="params">(<span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> expect = fork.get();</span><br><span class="line">        <span class="keyword">return</span> (expect &amp; mask) &gt; <span class="number">0</span> ? <span class="keyword">false</span> : fork.compareAndSet(expect, expect ^ mask);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">putFork</span><span class="params">(<span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> expect = fork.get();</span><br><span class="line">        <span class="keyword">return</span> fork.compareAndSet(expect, expect ^ mask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[-改进的方法3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiningPhilosophers</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化为0, 二进制表示则为00000, 说明当前所有叉子都未被使用</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger fork = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//每个叉子的int值(即二进制的00001, 00010, 00100, 01000, 10000)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] forkMask = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiningPhilosophers</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call the run() method of any runnable to execute its code</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wantsToEat</span><span class="params">(<span class="keyword">int</span> philosopher,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickRightFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable eat,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putRightFork)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftMask = forkMask[(philosopher + <span class="number">1</span>) % <span class="number">5</span>], rightMask = forkMask[philosopher];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//编号为偶数的哲学家，优先拿起左边的叉子，再拿起右边的叉子</span></span><br><span class="line">        <span class="keyword">if</span> (philosopher % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!pickFork(leftMask)) Thread.sleep(<span class="number">1</span>);     <span class="comment">//拿起左边的叉子</span></span><br><span class="line">            <span class="keyword">while</span> (!pickFork(rightMask)) Thread.sleep(<span class="number">1</span>);    <span class="comment">//拿起右边的叉子</span></span><br><span class="line">        &#125;<span class="comment">//编号为奇数的哲学家，优先拿起右边的叉子，再拿起左边的叉子</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!pickFork(rightMask)) Thread.sleep(<span class="number">1</span>);    <span class="comment">//拿起右边的叉子</span></span><br><span class="line">            <span class="keyword">while</span> (!pickFork(leftMask)) Thread.sleep(<span class="number">1</span>);     <span class="comment">//拿起左边的叉子</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pickLeftFork.run();    <span class="comment">//拿起左边的叉子 的具体执行</span></span><br><span class="line">        pickRightFork.run();    <span class="comment">//拿起右边的叉子 的具体执行</span></span><br><span class="line"></span><br><span class="line">        eat.run();    <span class="comment">//吃意大利面 的具体执行</span></span><br><span class="line"></span><br><span class="line">        putLeftFork.run();    <span class="comment">//放下左边的叉子 的具体执行</span></span><br><span class="line">        putRightFork.run();    <span class="comment">//放下右边的叉子 的具体执行</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!putFork(rightMask)) Thread.sleep(<span class="number">1</span>);    <span class="comment">//放下右边的叉子</span></span><br><span class="line">        <span class="keyword">while</span> (!putFork(leftMask)) Thread.sleep(<span class="number">1</span>);     <span class="comment">//放下左边的叉子</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">pickFork</span><span class="params">(<span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> expect = fork.get();</span><br><span class="line">        <span class="keyword">return</span> (expect &amp; mask) &gt; <span class="number">0</span> ? <span class="keyword">false</span> : fork.compareAndSet(expect, expect ^ mask);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">putFork</span><span class="params">(<span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> expect = fork.get();</span><br><span class="line">        <span class="keyword">return</span> fork.compareAndSet(expect, expect ^ mask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://leetcode-cn.com/problems/the-dining-philosophers" target="_blank" rel="noopener">https://leetcode-cn.com/problems/the-dining-philosophers</a></p><p>【2】<a href="https://leetcode-cn.com/problems/the-dining-philosophers/solution/zhe-xue-jia-jiu-can-wen-ti-by-mike-meng" target="_blank" rel="noopener">https://leetcode-cn.com/problems/the-dining-philosophers/solution/zhe-xue-jia-jiu-can-wen-ti-by-mike-meng</a></p><p>【3】<a href="https://blog.csdn.net/u013272948/java/article/details/53929572" target="_blank" rel="noopener">https://blog.csdn.net/u013272948/java/article/details/53929572</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;哲学家就餐问题&lt;/p&gt;
    
    </summary>
    
      <category term="2020年5月" scheme="http://yoursite.com/categories/2020%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Concurrency" scheme="http://yoursite.com/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>1195. 交替打印字符串</title>
    <link href="http://yoursite.com/2020/05/24/1195.%20%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://yoursite.com/2020/05/24/1195. 交替打印字符串/</id>
    <published>2020-05-24T15:23:12.000Z</published>
    <updated>2020-05-25T15:49:04.282Z</updated>
    
    <content type="html"><![CDATA[<p>编写一个可以从 1 到 n 输出代表这个数字的字符串的程序</p><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>编写一个可以从 1 到 n 输出代表这个数字的字符串的程序，但是：</p><pre><code>如果这个数字可以被 3 整除，输出 &quot;fizz&quot;。如果这个数字可以被 5 整除，输出 &quot;buzz&quot;。如果这个数字可以同时被 3 和 5 整除，输出 &quot;fizzbuzz&quot;。</code></pre><p>例如，当 n = 15，输出：</p><pre><code>1, 2, fizz, 4, buzz, fizz, 7, 8, fizz, buzz, 11, fizz, 13, 14, fizzbuzz。</code></pre><p>假设有这么一个类：</p><pre><code>class FizzBuzz {  public FizzBuzz(int n) { ... }               // constructor  public void fizz(printFizz) { ... }          // only output &quot;fizz&quot;  public void buzz(printBuzz) { ... }          // only output &quot;buzz&quot;  public void fizzbuzz(printFizzBuzz) { ... }  // only output &quot;fizzbuzz&quot;  public void number(printNumber) { ... }      // only output the numbers}</code></pre><p>请你实现一个有四个线程的多线程版  FizzBuzz， 同一个 FizzBuzz 实例会被如下四个线程使用：</p><pre><code>线程A将调用 fizz() 来判断是否能被 3 整除，如果可以，则输出 fizz。线程B将调用 buzz() 来判断是否能被 5 整除，如果可以，则输出 buzz。线程C将调用 fizzbuzz() 来判断是否同时能被 3 和 5 整除，如果可以，则输出 fizzbuzz。线程D将调用 number() 来实现输出既不能被 3 整除也不能被 5 整除的数字。</code></pre><h1 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h1><ol><li>凡是可以用semaphore解决的问题，大多都可以使用管程（也就是lock）来解决，但使用lock需要增加一个变量来标记起始条件</li><li>凡是可以使用多个condition可以解决的问题，都可以使用一个condition和一个volatile变量来解决</li></ol><h1 id="方法一：信号量Semaphore"><a href="#方法一：信号量Semaphore" class="headerlink" title="方法一：信号量Semaphore"></a>方法一：信号量Semaphore</h1><p>很容易可以想到使用信号量的方法来解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintFizzBuzz</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrintFizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Semaphore fSema = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> Semaphore bSema = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> Semaphore fbSema = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> Semaphore nSema = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * use semaphore</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> printFizz</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// printFizz.run() outputs "fizz".</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizz</span><span class="params">(Runnable printFizz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i = i + <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">5</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                fSema.acquire();</span><br><span class="line">                printFizz.run();</span><br><span class="line">                nSema.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printBuzz.run() outputs "buzz".</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buzz</span><span class="params">(Runnable printBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &lt;= n; i = i + <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">3</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                bSema.acquire();</span><br><span class="line">                printBuzz.run();</span><br><span class="line">                nSema.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printFizzBuzz.run() outputs "fizzbuzz".</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizzbuzz</span><span class="params">(Runnable printFizzBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">15</span>; i &lt;= n; i = i + <span class="number">15</span>) &#123;</span><br><span class="line">            fbSema.acquire();</span><br><span class="line">            printFizzBuzz.run();</span><br><span class="line">            nSema.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printNumber.accept(x) outputs "x", where x is an integer.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">number</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            nSema.acquire();</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; i % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                fbSema.release();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                fSema.release();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                bSema.release();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                printNumber.accept(i);</span><br><span class="line">                nSema.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的一点是<strong>如果不在fizz和buzz方法中加入对15的余数判断就会使得线程执行混乱</strong>，本地运行结果：Time Limit Exceeded</p><p>只需将n改到30即可打印看到执行情况，即使在else if中已经做了情况区分仍然会出错。这其中的原因可以本地调试来深究。</p><h1 id="方案二：Lock"><a href="#方案二：Lock" class="headerlink" title="方案二：Lock"></a>方案二：Lock</h1><p>lock的方案使用了多个condition，这其实也是可以使用一个condition外加一个volatile变量来实现的</p><h2 id="Condition的用法"><a href="#Condition的用法" class="headerlink" title="Condition的用法"></a>Condition的用法</h2><p>Condition是在java 1.5中才出现的，它用来替代传统的Object的wait()、notify()实现线程间的协作，相比使用Object的wait()、notify()，使用Condition的await()、signal()这种方式实现线程间协作更加安全和高效。因此通常来说比较推荐使用Condition，阻塞队列实际上是使用了Condition来模拟线程间协作。</p><p>Condition是个接口，基本的方法就是await()和signal()方法；</p><p>Condition依赖于Lock接口，生成一个Condition的基本代码是lock.newCondition() </p><p> 调用Condition的await()和signal()方法，都必须在lock保护之内，就是说必须在lock.lock()和lock.unlock之间才可以使用</p><pre><code>Conditon中的await()对应Object的wait()；Condition中的signal()对应Object的notify()；Condition中的signalAll()对应Object的notifyAll()。</code></pre><p> condition可以通俗的理解为条件队列。当一个线程在调用了await方法以后，直到线程等待的某个条件为真的时候才会被唤醒。这种方式为线程提供了更加简单的等待/通知模式。Condition必须要配合锁一起使用，因为对共享状态变量的访问发生在多线程环境下。一个Condition的实例必须与一个Lock绑定，因此Condition一般都是作为Lock的内部实现。</p><pre><code>await() ：造成当前线程在接到信号或被中断之前一直处于等待状态。await(long time, TimeUnit unit) ：造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态awaitNanos(long nanosTimeout) ：造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。返回值表示剩余时间，如果在nanosTimesout之前唤醒，那么返回值 = nanosTimeout - 消耗时间，如果返回值 &lt;= 0 ,则可以认定它已经超时了。awaitUninterruptibly() ：造成当前线程在接到信号之前一直处于等待状态。【注意：该方法对中断不敏感】。awaitUntil(Date deadline) ：造成当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态。如果没有到指定时间就被通知，则返回true，否则表示到了指定时间，返回返回false。signal() ：唤醒一个等待线程。该线程从等待方法返回前必须获得与Condition相关的锁。signal()All ：唤醒所有等待线程。能够从等待方法返回的线程必须获得与Condition相关的锁。</code></pre><p>更多源码分析详见<a href="https://blog.csdn.net/bohu83/java/article/details/51098106" target="_blank" rel="noopener">java condition使用及分析</a></p><p>使用Lock和Condition来解决本题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintFizzBuzz</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrintFizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition fCond = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition bCond = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition fbCond = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition nCond = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Boolean state = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * use lock</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> printFizz</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// printFizz.run() outputs "fizz".</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizz</span><span class="params">(Runnable printFizz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i = i + <span class="number">3</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">5</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (!state) &#123;</span><br><span class="line">                        fCond.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    printFizz.run();</span><br><span class="line">                    state = <span class="keyword">false</span>;</span><br><span class="line">                    nCond.signal();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printBuzz.run() outputs "buzz".</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buzz</span><span class="params">(Runnable printBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &lt;= n; i = i + <span class="number">5</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">3</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (!state) &#123;</span><br><span class="line">                        bCond.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    printBuzz.run();</span><br><span class="line">                    state = <span class="keyword">false</span>;</span><br><span class="line">                    nCond.signal();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printFizzBuzz.run() outputs "fizzbuzz".</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizzbuzz</span><span class="params">(Runnable printFizzBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">15</span>; i &lt;= n; i = i + <span class="number">15</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!state) &#123;</span><br><span class="line">                    fbCond.await();</span><br><span class="line">                &#125;</span><br><span class="line">                printFizzBuzz.run();</span><br><span class="line">                state = <span class="keyword">false</span>;</span><br><span class="line">                nCond.signal();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printNumber.accept(x) outputs "x", where x is an integer.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">number</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (state) &#123;</span><br><span class="line">                    nCond.await();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; i % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    fbCond.signal();</span><br><span class="line">                    state = <span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    fCond.signal();</span><br><span class="line">                    state = <span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    bCond.signal();</span><br><span class="line">                    state = <span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    printNumber.accept(i);</span><br><span class="line">                    nCond.signal();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrintFizzBuzz pfb = <span class="keyword">new</span> PrintFizzBuzz(<span class="number">15</span>);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pfb.fizz(() -&gt; System.out.print(<span class="string">"fizz"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pfb.buzz(() -&gt; System.out.print(<span class="string">"buzz"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pfb.fizzbuzz(() -&gt; System.out.print(<span class="string">"fizzbuzz"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t4 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pfb.number(value -&gt; System.out.print(value));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方案三：AtomicInteger"><a href="#方案三：AtomicInteger" class="headerlink" title="方案三：AtomicInteger"></a>方案三：AtomicInteger</h1><p>使用AtomicInteger时，使用了while及LockSupport来完成线程等待。</p><h2 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h2><p>LockSupport是一个线程阻塞工具类，所有的方法都是静态方法，可以让线程在任意位置阻塞。</p><pre><code>public static void park(Object blocker); // 暂停当前线程public static void parkNanos(Object blocker, long nanos); // 暂停当前线程，不过有超时时间的限制public static void parkUntil(Object blocker, long deadline); // 暂停当前线程，直到某个时间public static void park(); // 无期限暂停当前线程public static void parkNanos(long nanos); // 暂停当前线程，不过有超时时间的限制public static void parkUntil(long deadline); // 暂停当前线程，直到某个时间public static void unpark(Thread thread); // 恢复当前线程public static Object getBlocker(Thread t);</code></pre><p>park和unpark可以实现类似wait和notify的功能，但是并不和wait和notify交叉，也就是说unpark不会对wait起作用，notify也不会对park起作用。</p><p>park和unpark的使用不会出现死锁的情况</p><p>更多用法参见<a href="https://www.jianshu.com/p/f1f2cd289205" target="_blank" rel="noopener">LockSupport的用法及原理</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FizzBuzz</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Initialize the flag.</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger state = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// The current number.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> curNum = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printFizz.run() outputs "fizz".</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizz</span><span class="params">(Runnable printFizz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">            <span class="comment">// Update the current state using CAS in orde to run the logic exclusively.</span></span><br><span class="line">            <span class="keyword">while</span> (!<span class="keyword">this</span>.state.compareAndSet(<span class="number">1</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="comment">// Alleviate the busy spin.</span></span><br><span class="line">                LockSupport.parkNanos(<span class="number">1L</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.curNum &gt; n) &#123;</span><br><span class="line">                <span class="comment">// Reset the state before return, then other waiting threads can terminate.</span></span><br><span class="line">                <span class="keyword">this</span>.state.set(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">this</span>.curNum % <span class="number">3</span> == <span class="number">0</span>) &amp;&amp; (<span class="keyword">this</span>.curNum % <span class="number">5</span> != <span class="number">0</span>)) &#123;</span><br><span class="line">                printFizz.run();    </span><br><span class="line">                <span class="keyword">this</span>.curNum++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">this</span>.state.set(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printBuzz.run() outputs "buzz".</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buzz</span><span class="params">(Runnable printBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;            </span><br><span class="line">            <span class="keyword">while</span> (!<span class="keyword">this</span>.state.compareAndSet(<span class="number">1</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">                LockSupport.parkNanos(<span class="number">1L</span>);</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.curNum &gt; n) &#123;    </span><br><span class="line">                <span class="keyword">this</span>.state.set(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">this</span>.curNum % <span class="number">3</span> != <span class="number">0</span>) &amp;&amp; (<span class="keyword">this</span>.curNum % <span class="number">5</span> == <span class="number">0</span>)) &#123;</span><br><span class="line">                printBuzz.run();</span><br><span class="line">                <span class="keyword">this</span>.curNum++;    </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">this</span>.state.set(<span class="number">1</span>);   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printFizzBuzz.run() outputs "fizzbuzz".</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizzbuzz</span><span class="params">(Runnable printFizzBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!<span class="keyword">this</span>.state.compareAndSet(<span class="number">1</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">                LockSupport.parkNanos(<span class="number">1L</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.curNum &gt; n) &#123;</span><br><span class="line">                <span class="keyword">this</span>.state.set(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">this</span>.curNum % <span class="number">3</span> == <span class="number">0</span>) &amp;&amp; (<span class="keyword">this</span>.curNum % <span class="number">5</span> == <span class="number">0</span>)) &#123;    </span><br><span class="line">                printFizzBuzz.run();    </span><br><span class="line">                <span class="keyword">this</span>.curNum++;    </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">this</span>.state.set(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printNumber.accept(x) outputs "x", where x is an integer.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">number</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!<span class="keyword">this</span>.state.compareAndSet(<span class="number">1</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">                LockSupport.parkNanos(<span class="number">1L</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.curNum &gt; n) &#123;    </span><br><span class="line">                <span class="keyword">this</span>.state.set(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                    </span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">this</span>.curNum % <span class="number">3</span> != <span class="number">0</span>) &amp;&amp; (<span class="keyword">this</span>.curNum % <span class="number">5</span> != <span class="number">0</span>)) &#123;    </span><br><span class="line">                printNumber.accept(<span class="keyword">this</span>.curNum);  </span><br><span class="line">                <span class="keyword">this</span>.curNum++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">this</span>.state.set(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://leetcode-cn.com/problems/fizz-buzz-multithreaded" target="_blank" rel="noopener">https://leetcode-cn.com/problems/fizz-buzz-multithreaded</a></p><p>【2】<a href="https://blog.csdn.net/bohu83/java/article/details/51098106" target="_blank" rel="noopener">https://blog.csdn.net/bohu83/java/article/details/51098106</a></p><p>【3】<a href="https://www.jianshu.com/p/f1f2cd289205" target="_blank" rel="noopener">https://www.jianshu.com/p/f1f2cd289205</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写一个可以从 1 到 n 输出代表这个数字的字符串的程序&lt;/p&gt;
    
    </summary>
    
      <category term="2020年5月" scheme="http://yoursite.com/categories/2020%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Concurrency" scheme="http://yoursite.com/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>1117. H2O 生成</title>
    <link href="http://yoursite.com/2020/05/24/1117.%20H2O%20%E7%94%9F%E6%88%90/"/>
    <id>http://yoursite.com/2020/05/24/1117. H2O 生成/</id>
    <published>2020-05-24T14:16:12.000Z</published>
    <updated>2020-05-24T15:07:36.341Z</updated>
    
    <content type="html"><![CDATA[<p>使线程三三成组突破屏障并能立即组合产生一个水分子</p><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>现在有两种线程，氢 oxygen 和氧 hydrogen，你的目标是组织这两种线程来产生水分子。</p><p>存在一个屏障（barrier）使得每个线程必须等候直到一个完整水分子能够被产生出来。</p><p>氢和氧线程会被分别给予 releaseHydrogen 和 releaseOxygen 方法来允许它们突破屏障。</p><p>这些线程应该三三成组突破屏障并能立即组合产生一个水分子。</p><p>你必须保证产生一个水分子所需线程的结合必须发生在下一个水分子产生之前。</p><p>换句话说:</p><p>如果一个氧线程到达屏障时没有氢线程到达，它必须等候直到两个氢线程到达。<br>如果一个氢线程到达屏障时没有其它线程到达，它必须等候直到一个氧线程和另一个氢线程到达。<br>书写满足这些限制条件的氢、氧线程同步代码。</p><p>示例 1:</p><pre><code>输入: &quot;HOH&quot;输出: &quot;HHO&quot;解释: &quot;HOH&quot; 和 &quot;OHH&quot; 依然都是有效解。</code></pre><p>示例 2:</p><pre><code>输入: &quot;OOHHHH&quot;输出: &quot;HHOHHO&quot;解释: &quot;HOHHHO&quot;, &quot;OHHHHO&quot;, &quot;HHOHOH&quot;, &quot;HOHHOH&quot;, &quot;OHHHOH&quot;, &quot;HHOOHH&quot;, &quot;HOHOHH&quot; 和 &quot;OHHOHH&quot; 依然都是有效解。</code></pre><p>限制条件:</p><pre><code>输入字符串的总长将会是 3n, 1 ≤ n ≤ 50；输入字符串中的 “H” 总数将会是 2n；输入字符串中的 “O” 总数将会是 n。</code></pre><h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><p>h每获取一次释放一个o许可，o每次获取两个许可（即2次h后执行一次o）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">H2O</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Semaphore h = <span class="keyword">new</span> Semaphore(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">private</span> Semaphore o = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">H2O</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hydrogen</span><span class="params">(Runnable releaseHydrogen)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">h.acquire();</span><br><span class="line">        <span class="comment">// releaseHydrogen.run() outputs "H". Do not change or remove this line.</span></span><br><span class="line">        releaseHydrogen.run();</span><br><span class="line">        o.release();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oxygen</span><span class="params">(Runnable releaseOxygen)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        o.acquire(<span class="number">2</span>); <span class="comment">//2次h后执行一次o</span></span><br><span class="line">        <span class="comment">// releaseOxygen.run() outputs "O". Do not change or remove this line.</span></span><br><span class="line">releaseOxygen.run();</span><br><span class="line">h.release(<span class="number">2</span>);<span class="comment">//一次o后执行2次h</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ReentrantLock-Condition"><a href="#ReentrantLock-Condition" class="headerlink" title="ReentrantLock+Condition"></a>ReentrantLock+Condition</h1><p>Condition用法参见<a href="https://www.jianshu.com/p/be2dc7c878dc" target="_blank" rel="noopener">java并发编程之Condition</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">H2O</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition hCondition = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition oCondition = lock.newCondition();</span><br><span class="line">    <span class="comment">//前2位代表氢元素的个数,第3位代表氧元素的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> h2o = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">H2O</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hydrogen</span><span class="params">(Runnable releaseHydrogen)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="comment">//00(0个H元素) 01(1个H元素) 11(2个H元素)</span></span><br><span class="line">        <span class="comment">//((h2o &amp; 3) == 3)表示H元素已经到了2个</span></span><br><span class="line">        <span class="keyword">while</span>((h2o &amp; <span class="number">3</span>) == <span class="number">3</span>) &#123;</span><br><span class="line">            hCondition.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// releaseHydrogen.run() outputs "H". Do not change or remove this line.</span></span><br><span class="line">        releaseHydrogen.run();</span><br><span class="line">        <span class="comment">//==0代表没有1个氢元素,否则一定会有1个氢元素</span></span><br><span class="line">        h2o += ((h2o &amp; <span class="number">3</span>) == <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//水分子已经生成</span></span><br><span class="line">        <span class="keyword">if</span>(h2o == <span class="number">7</span>)&#123;</span><br><span class="line">            h2o = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//唤醒一个氧线程</span></span><br><span class="line">        oCondition.signal();</span><br><span class="line">        <span class="comment">//如果((h2o &amp; 3) == 3)表示氢线程不需要再唤醒了</span></span><br><span class="line">        <span class="keyword">if</span>((h2o &amp; <span class="number">3</span>) != <span class="number">3</span>)&#123;</span><br><span class="line">            hCondition.signal();</span><br><span class="line">        &#125;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oxygen</span><span class="params">(Runnable releaseOxygen)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="comment">//((h2o &amp; 4) == 4)表示O元素已经到了1个</span></span><br><span class="line">        <span class="keyword">while</span>((h2o &amp; <span class="number">4</span>)==<span class="number">4</span>)&#123;</span><br><span class="line">            oCondition.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// releaseOxygen.run() outputs "O". Do not change or remove this line.</span></span><br><span class="line">releaseOxygen.run();</span><br><span class="line">        h2o += <span class="number">4</span>;</span><br><span class="line">        <span class="comment">//水分子已经生成</span></span><br><span class="line">        <span class="keyword">if</span>(h2o == <span class="number">7</span>)&#123;</span><br><span class="line">            h2o = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为只需要1个氧元素,所以这里只需要唤醒氢线程就可以了</span></span><br><span class="line">        hCondition.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Semaphore-CyclicBarrier"><a href="#Semaphore-CyclicBarrier" class="headerlink" title="Semaphore+CyclicBarrier"></a>Semaphore+CyclicBarrier</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">H2O</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore hSem = <span class="keyword">new</span> Semaphore(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore oSem = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">H2O</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hydrogen</span><span class="params">(Runnable releaseHydrogen)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        hSem.acquire();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            barrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// releaseHydrogen.run() outputs "H". Do not change or remove this line.</span></span><br><span class="line">        releaseHydrogen.run();</span><br><span class="line">        hSem.release();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oxygen</span><span class="params">(Runnable releaseOxygen)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        oSem.acquire();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            barrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// releaseOxygen.run() outputs "H". Do not change or remove this line.</span></span><br><span class="line">        releaseOxygen.run();</span><br><span class="line">        oSem.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://leetcode-cn.com/problems/building-h2o" target="_blank" rel="noopener">https://leetcode-cn.com/problems/building-h2o</a></p><p>【2】<a href="https://www.jianshu.com/p/be2dc7c878dc" target="_blank" rel="noopener">https://www.jianshu.com/p/be2dc7c878dc</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使线程三三成组突破屏障并能立即组合产生一个水分子&lt;/p&gt;
    
    </summary>
    
      <category term="2020年5月" scheme="http://yoursite.com/categories/2020%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Concurrency" scheme="http://yoursite.com/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>1116. 打印零与奇偶数</title>
    <link href="http://yoursite.com/2020/05/24/1116.%20%E6%89%93%E5%8D%B0%E9%9B%B6%E4%B8%8E%E5%A5%87%E5%81%B6%E6%95%B0/"/>
    <id>http://yoursite.com/2020/05/24/1116. 打印零与奇偶数/</id>
    <published>2020-05-24T14:01:12.000Z</published>
    <updated>2020-05-24T14:31:09.699Z</updated>
    
    <content type="html"><![CDATA[<p>按顺序交替调用三个线程</p><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>假设有这么一个类：</p><pre><code>class ZeroEvenOdd {  public ZeroEvenOdd(int n) { ... }      // 构造函数  public void zero(printNumber) { ... }  // 仅打印出 0  public void even(printNumber) { ... }  // 仅打印出 偶数  public void odd(printNumber) { ... }   // 仅打印出 奇数}</code></pre><p>相同的一个 ZeroEvenOdd 类实例将会传递给三个不同的线程：</p><pre><code>线程 A 将调用 zero()，它只输出 0 。线程 B 将调用 even()，它只输出偶数。线程 C 将调用 odd()，它只输出奇数。</code></pre><p>每个线程都有一个 printNumber 方法来输出一个整数。请修改给出的代码以输出整数序列 010203040506… ，其中序列的长度必须为 2n。</p><p>示例 1：</p><pre><code>输入：n = 2输出：&quot;0102&quot;说明：三条线程异步执行，其中一个调用 zero()，另一个线程调用 even()，最后一个线程调用odd()。正确的输出为 &quot;0102&quot;。</code></pre><p>示例 2：</p><pre><code>输入：n = 5输出：&quot;0102030405&quot;</code></pre><h1 id="方法一：信号量"><a href="#方法一：信号量" class="headerlink" title="方法一：信号量"></a>方法一：信号量</h1><p>由1115. 交替打印FooBar中的方法很容易想到<br>通过三个信号量来控制。</p><p>zero方法中的for表示要输出的0个次数，同时用来控制要唤醒偶数还是奇数方法</p><p>even方法用来输出偶数同时唤醒zero方法。</p><p>odd方法用来输出奇数同时唤醒zero方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.function.IntConsumer;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZeroEvenOdd</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    Semaphore zero = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">    Semaphore even = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    Semaphore odd = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZeroEvenOdd</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printNumber.accept(x) outputs "x", where x is an integer.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zero</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            zero.acquire();</span><br><span class="line">            printNumber.accept(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                odd.release();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                even.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">even</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i=i+<span class="number">2</span>) &#123;</span><br><span class="line">            even.acquire();</span><br><span class="line">            printNumber.accept(i);</span><br><span class="line">            zero.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">odd</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n ; i=i+<span class="number">2</span>) &#123;</span><br><span class="line">            odd.acquire();</span><br><span class="line">            printNumber.accept(i);</span><br><span class="line">            zero.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ZeroEvenOdd zeroEvenOdd = <span class="keyword">new</span> ZeroEvenOdd(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zeroEvenOdd.zero(System.out::print);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zeroEvenOdd.even(System.out::print);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zeroEvenOdd.odd(System.out::print);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法二：Lock"><a href="#方法二：Lock" class="headerlink" title="方法二：Lock"></a>方法二：Lock</h1><p>“凡是可以用信号量解决的问题，都可以用管程模型来解决”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZeroEvenOdd</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZeroEvenOdd</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Condition z = lock.newCondition();</span><br><span class="line">    Condition num = lock.newCondition();</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> zTurn = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> zIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zero</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;zIndex&lt;n;) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(!zTurn) &#123;</span><br><span class="line">        z.await();</span><br><span class="line">        &#125;</span><br><span class="line">        printNumber.accept(<span class="number">0</span>);</span><br><span class="line">        zTurn = <span class="keyword">false</span>;</span><br><span class="line">        num.signalAll();</span><br><span class="line">                zIndex++;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">even</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i+=<span class="number">2</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(zTurn || (zIndex&amp;<span class="number">1</span>)==<span class="number">1</span>) &#123;</span><br><span class="line">        num.await();</span><br><span class="line">        &#125;</span><br><span class="line">        printNumber.accept(i);</span><br><span class="line">        zTurn = <span class="keyword">true</span>;</span><br><span class="line">        z.signal();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">odd</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i+=<span class="number">2</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(zTurn || (zIndex&amp;<span class="number">1</span>)==<span class="number">0</span>) &#123;</span><br><span class="line">        num.await();</span><br><span class="line">        &#125;</span><br><span class="line">        printNumber.accept(i);</span><br><span class="line">        zTurn = <span class="keyword">true</span>;</span><br><span class="line">        z.signal();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法三：无锁"><a href="#方法三：无锁" class="headerlink" title="方法三：无锁"></a>方法三：无锁</h1><p>凡是用了锁的，都来试试可否变成无锁的（本机测试是可行的，但测评平台报超时）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZeroEvenOdd</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZeroEvenOdd</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> stage = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zero</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(stage&gt;<span class="number">0</span>);</span><br><span class="line">    printNumber.accept(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>((i&amp;<span class="number">1</span>)==<span class="number">0</span>) &#123;</span><br><span class="line">    stage = <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    stage = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">even</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i+=<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(stage!=<span class="number">2</span>);</span><br><span class="line">    printNumber.accept(i);</span><br><span class="line">    stage = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">odd</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i+=<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(stage!=<span class="number">1</span>);</span><br><span class="line">    printNumber.accept(i);</span><br><span class="line">    stage = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://leetcode-cn.com/problems/print-zero-even-odd/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/print-zero-even-odd/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;按顺序交替调用三个线程&lt;/p&gt;
    
    </summary>
    
      <category term="2020年5月" scheme="http://yoursite.com/categories/2020%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Concurrency" scheme="http://yoursite.com/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>1115. 交替打印FooBar</title>
    <link href="http://yoursite.com/2020/05/22/1115.%20%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0FooBar/"/>
    <id>http://yoursite.com/2020/05/22/1115. 交替打印FooBar/</id>
    <published>2020-05-22T14:32:12.000Z</published>
    <updated>2020-05-23T04:30:31.185Z</updated>
    
    <content type="html"><![CDATA[<p>两个不同的线程将会共用一个 FooBar 实例。其中一个线程将会调用 foo() 方法，另一个线程将会调用 bar() 方法.设计修改程序交替调用这两个方法。</p><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>我们提供一个类：</p><pre><code>class FooBar {  public void foo() {    for (int i = 0; i &lt; n; i++) {      print(&quot;foo&quot;);    }  }  public void bar() {    for (int i = 0; i &lt; n; i++) {      print(&quot;bar&quot;);    }  }}</code></pre><p>两个不同的线程将会共用一个 FooBar 实例。其中一个线程将会调用 foo() 方法，另一个线程将会调用 bar() 方法。</p><p>请设计修改程序，以确保 “foobar” 被输出 n 次。</p><p>示例 1:</p><pre><code>输入: n = 1输出: &quot;foobar&quot;解释: 这里有两个线程被异步启动。其中一个调用 foo() 方法, 另一个调用 bar() 方法，&quot;foobar&quot; 将被输出一次。</code></pre><p>示例 2:</p><pre><code>输入: n = 2输出: &quot;foobarfoobar&quot;解释: &quot;foobar&quot; 将被输出两次。</code></pre><h1 id="方案一：Semaphore"><a href="#方案一：Semaphore" class="headerlink" title="方案一：Semaphore"></a>方案一：Semaphore</h1><p>很容易想到这种类似红绿灯交替变换的情境，一开始尝试用两个AtomicBoolean值来控制两个方法轮流调用，但发现难以在循环情况下运行，因此考虑使用信号量：</p><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>为了防止出现因多个程序同时访问一个共享资源而引发的一系列问题，我们需要一种方法，它可以通过生成并使用令牌来授权，在任一时刻只能有一个执行线程访问代码的临界区域。临界区域是指执行数据更新的代码需要独占式地执行。而信号量就可以提供这样的一种访问机制，让一个临界区同一时间只有一个线程在访问它，也就是说信号量是用来调协进程对共享资源的访问的。</p><p>信号量是一个特殊的变量，程序对其访问都是原子操作，且只允许对它进行等待（即P(信号变量))和发送（即V(信号变量))信息操作。</p><p>最简单的信号量是只能取0和1的变量，这也是信号量最常见的一种形式，叫做二进制信号量。而可以取多个正整数的信号量被称为通用信号量。这里主要讨论二进制信号量。</p><h2 id="信号量的工作原理"><a href="#信号量的工作原理" class="headerlink" title="信号量的工作原理"></a>信号量的工作原理</h2><p>由于信号量只能进行两种操作等待和发送信号，即P(sv)和V(sv),他们的行为是这样的：</p><p>P(sv)：如果sv的值大于零，就给它减1；如果它的值为零，就挂起该进程的执行</p><p>V(sv)：如果有其他进程因等待sv而被挂起，就让它恢复运行，如果没有进程因等待sv而挂起，就给它加1.</p><p>举个例子，就是两个进程共享信号量sv，一旦其中一个进程执行了P(sv)操作，它将得到信号量，并可以进入临界区，使sv减1。</p><p>而第二个进程将被阻止进入临界区，因为当它试图执行P(sv)时，sv为0，它会被挂起以等待第一个进程离开临界区域并执行V(sv)释放信号量，这时第二个进程就可以恢复执行。</p><h2 id="Semaphore使用初探："><a href="#Semaphore使用初探：" class="headerlink" title="Semaphore使用初探："></a>Semaphore使用初探：</h2><p>Semaphore是用来保护一个或者多个共享资源的访问，Semaphore内部维护了一个计数器，其值为可以访问的共享资源的个数。一个线程要访问共享资源，先获得信号量，如果信号量的计数器值大于1，意味着有共享资源可以访问，则使其计数器值减去1，再访问共享资源。</p><p>如果计数器值为0,线程进入休眠。当某个线程使用完共享资源后，释放信号量，并将信号量内部的计数器加1，之前进入休眠的线程将被唤醒并再次试图获得信号量。</p><p>就好比一个图书馆管理员，站在门口，只有图书馆有空位，就开门允许与空位数量等量的人进入图书馆。多个人进入图书馆后，相当于N个人来分配使用N个空位。为避免多个人来同时竞争同一个空位，在内部仍然使用锁来控制资源的同步访问。</p><h3 id="Semaphore的使用："><a href="#Semaphore的使用：" class="headerlink" title="Semaphore的使用："></a>Semaphore的使用：</h3><p>Semaphore使用时需要先构建一个参数来指定共享资源的数量，Semaphore构造完成后即是获取Semaphore、共享资源使用完毕后释放Semaphore。</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooBar</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Semaphore foo = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);<span class="comment">//foo方法可以访问的共享资源为1</span></span><br><span class="line">    Semaphore bar = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);<span class="comment">//bar方法可以访问的共享资源为0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            foo.acquire();<span class="comment">//foo方法获得信号量，并将信号量内部的计数器减1，计数器值为0后,线程进入休眠。</span></span><br><span class="line">            printFoo.run();</span><br><span class="line">            bar.release();<span class="comment">//bar方法释放信号量，并将信号量内部的计数器加1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            bar.acquire();<span class="comment">//bar方法获得信号量，并将信号量内部的计数器减1，计数器值为0后,线程进入休眠。</span></span><br><span class="line">            printBar.run();</span><br><span class="line">            foo.release();<span class="comment">//foo方法释放信号量，并将信号量内部的计数器加1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方案二：Lock（公平锁）"><a href="#方案二：Lock（公平锁）" class="headerlink" title="方案二：Lock（公平锁）"></a>方案二：Lock（公平锁）</h1><h2 id="公平锁："><a href="#公平锁：" class="headerlink" title="公平锁："></a>公平锁：</h2><p>每个线程抢占锁的顺序为先后调用lock方法的顺序依次获取锁，类似于排队吃饭。</p><h2 id="非公平锁："><a href="#非公平锁：" class="headerlink" title="非公平锁："></a>非公平锁：</h2><p>每个线程抢占锁的顺序不定，谁运气好，谁就获取到锁，和调用lock方法的先后顺序无关</p><h2 id="ReentrantLock（可重入锁）及其优点"><a href="#ReentrantLock（可重入锁）及其优点" class="headerlink" title="ReentrantLock（可重入锁）及其优点"></a>ReentrantLock（可重入锁）及其优点</h2><p>java中已经有了内置锁：synchronized,synchronized的特点是使用简单，一切交给JVM去处理,不需要显示释放。</p><p>从用法上可以看出，与synchronized相比， ReentrantLock就稍微复杂一点。因为必须在finally中进行解锁操作，<br>如果不在 finally解锁，有可能代码出现异常锁没被释放，那么为什么要引入ReentrantLock呢？</p><p>在jdk1.5里面，ReentrantLock的性能是明显优于synchronized的，但是在jdk1.6里面，synchronized做了优化，他们之间的性能差别已经不明显了。</p><p>ReentrantLock并不是一种替代内置加锁的方法，而是作为一种可选择的高级功能。<br>相比于synchronized，ReentrantLock在功能上更加丰富，它具有可重入、可中断、可限时、公平锁等特点。</p><h3 id="可重入（其实synchronized-也是可重入的）"><a href="#可重入（其实synchronized-也是可重入的）" class="headerlink" title="可重入（其实synchronized 也是可重入的）"></a>可重入（其实synchronized 也是可重入的）</h3><pre><code>lock.lock();lock.lock();try{    i++;}           finally{    lock.unlock();    lock.unlock();}</code></pre><p>由于ReentrantLock是重入锁，所以可以反复得到相同的一把锁，它有一个与锁相关的获取计数器，如果拥有锁的某个线程再次得到锁，那么获取计数器就加1，然后锁需要被释放两次才能获得真正释放(重入锁)。</p><h3 id="可中断"><a href="#可中断" class="headerlink" title="可中断"></a>可中断</h3><p>与synchronized不同的是，ReentrantLock对中断是有响应的.synchronized一旦尝试获取锁就会一直等待直到获取到锁。<br>构造一个死锁的例子，然后用中断来处理死锁</p><p>此处示例见<a href="https://www.jianshu.com/p/155260c8af6c" target="_blank" rel="noopener">ReentrantLock的使用</a></p><h3 id="可限时"><a href="#可限时" class="headerlink" title="可限时"></a>可限时</h3><p>超时不能获得锁，就返回false，不会永久等待构成死锁</p><p>使用lock.tryLock(long timeout, TimeUnit unit)来实现可限时锁，参数为时间和单位。</p><h3 id="公平锁的使用方法"><a href="#公平锁的使用方法" class="headerlink" title="公平锁的使用方法"></a>公平锁的使用方法</h3><p>一般意义上的锁是不公平的，不一定先来的线程能先得到锁，后来的线程就后得到锁。不公平的锁可能会产生饥饿现象。</p><p>公平锁的意思就是，这个锁能保证线程是先来的先得到锁。虽然公平锁不会产生饥饿现象，但是公平锁的性能会比非公平锁差很多。</p><pre><code>public ReentrantLock(boolean fair) public static ReentrantLock fairLock = new ReentrantLock(true);</code></pre><h2 id="Volatile关键字"><a href="#Volatile关键字" class="headerlink" title="Volatile关键字"></a>Volatile关键字</h2><p>Java的volatile关键字用于标记一个变量“应当存储在主存”。更确切地说，每次读取volatile变量，都应该从主存读取，而不是从CPU缓存读取。每次写入一个volatile变量，应该写到主存中，而不是仅仅写到CPU缓存。</p><p>Java的volatile关键字能保证变量修改后，对各个线程是可见的。更多详细内容参见<a href="http://ifeve.com/java-volatile%e5%85%b3%e9%94%ae%e5%ad%97/" target="_blank" rel="noopener">Java Volatile关键字</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooBar</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> permitFoo = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(permitFoo) &#123;</span><br><span class="line">                printFoo.run();</span><br><span class="line">                    i++;</span><br><span class="line">                    permitFoo = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(!permitFoo) &#123;</span><br><span class="line">                printBar.run();</span><br><span class="line">                i++;</span><br><span class="line">                permitFoo = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此种方法可以跑通但是超时了。</p><h1 id="方案三：无锁"><a href="#方案三：无锁" class="headerlink" title="方案三：无锁"></a>方案三：无锁</h1><p>以上的公平锁方案完全可以改造成无锁方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooBar</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> permitFoo = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;     </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(permitFoo) &#123;</span><br><span class="line">        printFoo.run();</span><br><span class="line">            i++;</span><br><span class="line">            permitFoo = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;       </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!permitFoo) &#123;</span><br><span class="line">        printBar.run();</span><br><span class="line">        i++;</span><br><span class="line">        permitFoo = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此种方法可以跑通但是也超时了。</p><h1 id="方案四：CyclicBarrier"><a href="#方案四：CyclicBarrier" class="headerlink" title="方案四：CyclicBarrier"></a>方案四：CyclicBarrier</h1><p>字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用。我们暂且把这个状态就叫做barrier，当调用await()方法之后，线程就处于barrier了。</p><p>CyclicBarrier更适合用在循环场景中，那么我们来试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    CyclicBarrier cyclicBarrier= <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> fin = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooBar</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!fin);</span><br><span class="line">            <span class="comment">// printFoo.run() outputs "foo". Do not change or remove this line.</span></span><br><span class="line">            printFoo.run();</span><br><span class="line">            fin = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (BrokenBarrierException e)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (BrokenBarrierException e)&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// printBar.run() outputs "bar". Do not change or remove this line.</span></span><br><span class="line">                printBar.run();</span><br><span class="line">                fin = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法可以提交成功。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://leetcode-cn.com/problems/print-foobar-alternately/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/print-foobar-alternately/</a></p><p>【2】<a href="https://zhuanlan.zhihu.com/p/81626432" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/81626432</a></p><p>【3】<a href="https://blog.csdn.net/ljianhui/java/article/details/10243617" target="_blank" rel="noopener">https://blog.csdn.net/ljianhui/java/article/details/10243617</a></p><p>【4】<a href="https://blog.csdn.net/zbc1090549839/java/article/details/53389602" target="_blank" rel="noopener">https://blog.csdn.net/zbc1090549839/java/article/details/53389602</a></p><p>【5】<a href="https://www.jianshu.com/p/155260c8af6c" target="_blank" rel="noopener">https://www.jianshu.com/p/155260c8af6c</a></p><p>【6】<a href="http://ifeve.com/java-volatile%e5%85%b3%e9%94%ae%e5%ad%97/" target="_blank" rel="noopener">http://ifeve.com/java-volatile%e5%85%b3%e9%94%ae%e5%ad%97/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;两个不同的线程将会共用一个 FooBar 实例。其中一个线程将会调用 foo() 方法，另一个线程将会调用 bar() 方法.设计修改程序交替调用这两个方法。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年5月" scheme="http://yoursite.com/categories/2020%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Concurrency" scheme="http://yoursite.com/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程</title>
    <link href="http://yoursite.com/2020/05/21/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/05/21/Java并发编程/</id>
    <published>2020-05-21T14:20:12.000Z</published>
    <updated>2020-05-23T04:30:25.861Z</updated>
    
    <content type="html"><![CDATA[<p>介绍Java并发编程中的常用方法，如AtomicInteger，信号量Semaphore，这些方法的实现原理和源码值得深究。</p><a id="more"></a><h1 id="Java原子操作AtomicInteger"><a href="#Java原子操作AtomicInteger" class="headerlink" title="Java原子操作AtomicInteger"></a>Java原子操作AtomicInteger</h1><p>JDK1.5之后的java.util.concurrent.atomic包里，多了一批原子处理类。AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference。主要用于在高并发环境下的高效程序处理,来帮助我们简化同步处理.</p><p>AtomicInteger，一个提供原子操作的Integer的类。在Java语言中，++i和i++操作并不是线程安全的，在使用的时候，不可避免的会用到synchronized关键字。而AtomicInteger则通过一种线程安全的加减操作接口。</p><p>我们先来看看AtomicInteger给我们提供了什么接口:</p><pre><code>    public final int get() //获取当前的值public final int getAndSet(int newValue)//获取当前的值，并设置新的值public final int getAndIncrement()//获取当前的值，并自增public final int getAndDecrement() //获取当前的值，并自减public final int getAndAdd(int delta) //获取当前的值，并加上预期的值</code></pre><p>下面通过两个简单的例子来看一下 AtomicInteger 的优势在哪:</p><p>普通线程同步:</p><pre><code>class Test2 {        private volatile int count = 0;        public synchronized void increment() {                  count++; //若要线程安全执行执行count++，需要加锁        }        public int getCount() {                  return count;        }}</code></pre><p>使用AtomicInteger:</p><pre><code>class Test2 {        private AtomicInteger count = new AtomicInteger();        public void increment() {                  count.incrementAndGet();        }   //使用AtomicInteger之后，不需要加锁，也可以实现线程安全。       public int getCount() {                return count.get();        }}</code></pre><p>使用AtomicInteger是非常的安全的.而且因为AtomicInteger由硬件提供原子操作指令实现的。在非激烈竞争的情况下，开销更小，速度更快。</p><p>我们来看看AtomicInteger是如何使用非阻塞算法来实现并发控制的:<br>AtomicInteger的关键域只有一下3个：</p><pre><code>// setup to use Unsafe.compareAndSwapInt for updatesprivate static final Unsafe unsafe = Unsafe.getUnsafe();private static final long valueOffset;static {             try {                        valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField(&quot;value&quot;));           } catch (Exception ex) {                throw new Error(ex);         }    }private volatile int value;</code></pre><p>这里， unsafe是java提供的获得对对象内存地址访问的类，注释已经清楚的写出了，它的作用就是在更新操作时提供“比较并替换”的作用。实际上就是AtomicInteger中的一个工具。<br>valueOffset是用来记录value本身在内存的便宜地址的，这个记录，也主要是为了在更新操作在内存中找到value的位置，方便比较。<br>注意：value是用来存储整数的时间变量，这里被声明为volatile，就是为了保证在更新操作时，当前线程可以拿到value最新的值（并发环境下，value可能已经被其他线程更新了）。<br>这里，我们以自增的代码为例，可以看到这个并发控制的核心算法：</p><pre><code>/***Atomicallyincrementsbyonethecurrentvalue.**@returntheupdatedvalue*/publicfinalintincrementAndGet(){for(;;){    //这里可以拿到value的最新值    intcurrent=get();    intnext=current+1;if(compareAndSet(current,next))    returnnext;    }}publicfinalbooleancompareAndSet(intexpect,intupdate){//使用unsafe的native方法，实现高效的硬件级别CAS        returnunsafe.compareAndSwapInt(this,valueOffset,expect,update);}</code></pre><p>优点总结:<br>最大的好处就是可以避免多线程的优先级倒置和死锁情况的发生，提升在高并发处理下的性能。</p><h1 id="信号量Semaphore"><a href="#信号量Semaphore" class="headerlink" title="信号量Semaphore"></a>信号量Semaphore</h1><p>Semaphore也叫信号量，在JDK1.5被引入，可以用来控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用资源。</p><p>Semaphore内部维护了一组虚拟的许可，许可的数量可以通过构造函数的参数指定。</p><p>访问特定资源前，必须使用acquire方法获得许可，如果许可数量为0，该线程则一直阻塞，直到有可用许可。</p><p>访问资源后，使用release释放许可。</p><p>Semaphore和ReentrantLock类似，获取许可有公平策略和非公平许可策略，默认情况下使用非公平策略。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>Semaphore可以用来做流量分流，特别是对公共资源有限的场景，比如数据库连接。</p><p>假设有这个的需求，读取几万个文件的数据到数据库中，由于文件读取是IO密集型任务，可以启动几十个线程并发读取，但是数据库连接数只有10个，这时就必须控制最多只有10个线程能够拿到数据库连接进行操作。这个时候，就可以使用Semaphore做流量控制。</p><pre><code>public class SemaphoreTest {    private static final int COUNT = 40;    private static Executor executor = Executors.newFixedThreadPool(COUNT);    private static Semaphore semaphore = new Semaphore(10);    public static void main(String[] args) {        for (int i=0; i&lt; COUNT; i++) {            executor.execute(new ThreadTest.Task());        }    }    static class Task implements Runnable {        @Override        public void run() {            try {                //读取文件操作                semaphore.acquire();                // 存数据过程                semaphore.release();            } catch (InterruptedException e) {                e.printStackTrace();            } finally {            }        }    }}</code></pre><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>代码源于JDK1.8<br>Semaphore实现主要基于java同步器AQS，不熟悉的可以移步 <a href="https://www.jianshu.com/p/d8eeb31bee5c" target="_blank" rel="noopener">深入浅出java同步器</a>。</p><p>内部使用state表示许可数量。</p><h3 id="非公平策略"><a href="#非公平策略" class="headerlink" title="非公平策略"></a>非公平策略</h3><p>acquire实现，核心代码如下：</p><pre><code>final int nonfairTryAcquireShared(int acquires) {    for (;;) {        int available = getState();        int remaining = available - acquires;        if (remaining &lt; 0 ||            compareAndSetState(available, remaining))            return remaining;    }}</code></pre><p>acquires值默认为1，表示尝试获取1个许可，remaining代表剩余的许可数。</p><p>如果remaining &lt; 0，表示目前没有剩余的许可。</p><p>当前线程进入AQS中的doAcquireSharedInterruptibly方法等待可用许可并挂起，直到被唤醒。</p><p>release实现，核心代码如下：</p><pre><code>protected final boolean tryReleaseShared(int releases) {    for (;;) {        int current = getState();        int next = current + releases;        if (next &lt; current) // overflow            throw new Error(&quot;Maximum permit count exceeded&quot;);        if (compareAndSetState(current, next))            return true;    }}</code></pre><p>releases值默认为1，表示尝试释放1个许可，next代表如果许可释放成功，可用许可的数量。</p><p>通过unsafe.compareAndSwapInt修改state的值，确保同一时刻只有一个线程可以释放成功。</p><p>许可释放成功，当前线程进入到AQS的doReleaseShared方法，唤醒队列中等待许可的线程。</p><p>也许有人会有疑问，非公平性体现在哪里？</p><p>当一个线程A执行acquire方法时，会直接尝试获取许可，而不管同一时刻阻塞队列中是否有线程也在等待许可，如果恰好有线程C执行release释放许可，并唤醒阻塞队列中第一个等待的线程B，这个时候，线程A和线程B是共同竞争可用许可，不公平性就是这么体现出来的，线程A一点时间都没等待就和线程B同等对待。</p><h3 id="公平策略"><a href="#公平策略" class="headerlink" title="公平策略"></a>公平策略</h3><p>acquire实现，核心代码如下：</p><pre><code>protected int tryAcquireShared(int acquires) {    for (;;) {        if (hasQueuedPredecessors())            return -1;        int available = getState();        int remaining = available - acquires;        if (remaining &lt; 0 ||            compareAndSetState(available, remaining))            return remaining;    }}</code></pre><p>acquires值默认为1，表示尝试获取1个许可，remaining代表剩余的许可数。<br>可以看到和非公平策略相比，就多了一个对阻塞队列的检查。</p><p>如果阻塞队列没有等待的线程，则参与许可的竞争。<br>否则直接插入到阻塞队列尾节点并挂起，等待被唤醒。</p><p>release实现，和非公平策略一样。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="https://www.jianshu.com/p/509aca840f6d" target="_blank" rel="noopener">https://www.jianshu.com/p/509aca840f6d</a></p><p>【2】<a href="https://www.ibm.com/developerworks/cn/java/j-jtp11234/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-jtp11234/</a></p><p>【3】<a href="https://www.jianshu.com/p/0090341c6b80" target="_blank" rel="noopener">https://www.jianshu.com/p/0090341c6b80</a></p><p>【4】<a href="https://www.jianshu.com/p/d8eeb31bee5c" target="_blank" rel="noopener">https://www.jianshu.com/p/d8eeb31bee5c</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍Java并发编程中的常用方法，如AtomicInteger，信号量Semaphore，这些方法的实现原理和源码值得深究。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年5月" scheme="http://yoursite.com/categories/2020%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="Concurrency" scheme="http://yoursite.com/tags/Concurrency/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>1114.按序打印</title>
    <link href="http://yoursite.com/2020/05/21/1114.%E6%8C%89%E5%BA%8F%E6%89%93%E5%8D%B0/"/>
    <id>http://yoursite.com/2020/05/21/1114.按序打印/</id>
    <published>2020-05-21T12:56:12.000Z</published>
    <updated>2020-05-23T04:30:38.629Z</updated>
    
    <content type="html"><![CDATA[<p>请设计修改程序，以确保三个线程中的 two() 方法在 one() 方法之后被执行，three() 方法在 two() 方法之后被执行。</p><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>我们提供了一个类：</p><pre><code>public class Foo {  public void one() { print(&quot;one&quot;); }  public void two() { print(&quot;two&quot;); }  public void three() { print(&quot;three&quot;); }}</code></pre><p>三个不同的线程将会共用一个 Foo 实例。</p><pre><code>线程 A 将会调用 one() 方法线程 B 将会调用 two() 方法线程 C 将会调用 three() 方法</code></pre><p>请设计修改程序，以确保 two() 方法在 one() 方法之后被执行，three() 方法在 two() 方法之后被执行。</p><p>示例 1:</p><pre><code>输入: [1,2,3]输出: &quot;onetwothree&quot;</code></pre><p>解释: </p><p>有三个线程会被异步启动。<br>输入 [1,2,3] 表示线程 A 将会调用 one() 方法，线程 B 将会调用 two() 方法，线程 C 将会调用 three() 方法。<br>正确的输出是 “onetwothree”。<br>示例 2:</p><pre><code>输入: [1,3,2]输出: &quot;onetwothree&quot;</code></pre><p>解释: </p><p>输入 [1,3,2] 表示线程 A 将会调用 one() 方法，线程 B 将会调用 three() 方法，线程 C 将会调用 two() 方法。<br>正确的输出是 “onetwothree”。</p><p>注意:</p><p>尽管输入中的数字似乎暗示了顺序，但是我们并不保证线程在操作系统中的调度顺序。</p><p>你看到的输入格式主要是为了确保测试的全面性。</p><h1 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h1><p>来自<a href="https://baike.baidu.com/item/%E5%B9%B6%E5%8F%91%E8%AE%A1%E7%AE%97/9939802?fr=aladdin" target="_blank" rel="noopener">并发计算</a>的场景，该场景下，程序在多线程（或多进程）中 <em>同时</em> 执行。</p><p>同时进行并不是完全指进程或线程在不同的物理 CPU 上独立运行，更多情况下，是在一个物理 CPU 上交替执行多个线程或进程。<em>并发既可在线程中，也可在进程中。</em></p><p>并发主要为多任务情况设计。但如果应用不当，可能会引发一些漏洞。按照情况不同，可以分为三种：</p><ul><li><p><strong>竞态条件</strong>：由于多进程之间的竞争执行，导致程序未按照期望的顺序输出。</p></li><li><p><strong>死锁</strong>：并发程序等待一些必要资源，导致没有程序可以执行。</p></li><li><p><strong>资源不足</strong>：进程被永久剥夺了运行所需的资源。</p></li></ul><p>此题中存在竞态条件。下面展示一个竞态条件的例子。</p><p>假设有一个方法 <code>withdraw(amount)</code>，如果请求量小于当前余额，则从当前余额中减去请求量，然后返回余额。方法定义如下：</p><figure class="highlight python"><figcaption><span>[snippet1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">balance = <span class="number">500</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">withdraw</span><span class="params">(amount)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> (amount &lt; balance):</span><br><span class="line">        balance -= amount</span><br><span class="line">    <span class="keyword">return</span> balance</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[snippet1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> balance = <span class="number">500</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (amount &lt; balance) &#123;</span><br><span class="line">    balance -= amount;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> balance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们 <em>期望</em> 该方法执行后余额永远不会为负。</p><p>但是有可能出现竞态条件，使得余额变为负数。假设两个线程同时使用不同的参数执行该方法。例如：线程 1 执行 <code>withdraw(amount=400)</code>，线程 2 执行 <code>withdraw(amount=200)</code>。这两个线程的执行顺序如下图所示。在每个时刻只执行一条语句。</p><p><img src="https://pic.leetcode-cn.com/Figures/1114/1114_race_condition.png" alt="image"></p><p>上述流程执行结束后，余额变成负数，这并不是期望的输出。</p><h1 id="无竞争并发"><a href="#无竞争并发" class="headerlink" title="无竞争并发"></a>无竞争并发</h1><p>并发问题有一个共同特征：多个线程/进程之间共享一些资源（例如：余额）。由于无法消除资源共享的约束，防止并发问题就变成了 <strong>资源共享的协调</strong> 问题。</p><p>根据这个思路，如果可以确保程序中 <strong>关键部分代码的独占性</strong>（例如：检查和减少余额），就可以防止程序进入不一致的状态。</p><blockquote><p>竞争条件的解决方案为：需要某些关键部分代码具有排他性，即在给定的时间内，只有一个线程可以进入关键部分代码。</p></blockquote><p>可以将这种机制看做限制关键部分代码访问的锁。在前面示例的关键部分代码加锁，即检查余额和减少余额的语句。然后重新运行两个线程，会有下图的执行顺序：</p><p><img src="https://pic.leetcode-cn.com/Figures/1114/1114_lock.png" alt="image"></p><p>在该机制下，一旦一个线程进入关键部分，它就可以阻止其他线程进入该关键部分。例如，在时间点 3，<code>线程 2</code> 进入关键部分，那么在时间点 4，如果没有锁保护，<code>线程 1</code> 就可能进入关键部分。最后两个线程同时运行，保证系统的一致性，并确保余额正确。</p><p>如果该线程未被授权进入关键代码，可以认为该线程被阻塞或进入睡眠状态。例如，<code>线程 1</code> 在时间点 4 被阻塞，之后关键部分被释放，可以通知其他等待线程。<code>线程 2</code> 在时间点 5 释放了关键部分，就可以通知 <code>线程 1</code> 进入。</p><blockquote><p>这种机制还具有唤醒其他等待线程的功能。</p></blockquote><p>总之，为了防止出现并发竞争状态，需要一种具有两种功能的机制：1）关键部分的访问控制；2）通知阻塞线程。</p><h1 id="方法一：使用-synchronization"><a href="#方法一：使用-synchronization" class="headerlink" title="方法一：使用 synchronization"></a>方法一：使用 synchronization</h1><p><strong>思路</strong></p><p>题目要求按顺序依次执行三个方法，且每个方法都在单独的线程中运行。为了保证线程的执行顺序，可以在方法之间创建一些依赖关系，即第二个方法必须在第一个方法之后执行，第三个方法必须在第二个方法之后执行。</p><blockquote><p>方法对之间的依赖关系形成了所有方法的特定的执行顺序。例如 <code>A &lt; B</code>, <code>B &lt; C</code>，则所有方法的执行顺序为 <code>A &lt; B &lt; C</code>。</p></blockquote><p><img src="https://pic.leetcode-cn.com/Figures/1114/1114_partial_order.png" alt="image"></p><p>依赖关系可以通过并发机制实现。使用一个共享变量 <code>firstJobDone</code> 协调第一个方法与第二个方法的执行顺序，使用另一个共享变量 <code>secondJobDone</code> 协调第二个方法与第三个方法的执行顺序。</p><p><strong>算法</strong></p><ul><li><p>首先初始化共享变量 <code>firstJobDone</code> 和 <code>secondJobDone</code>，初始值表示所有方法未执行。</p></li><li><p>方法 <code>first()</code> 没有依赖关系，可以直接执行。在方法最后更新变量 <code>firstJobDone</code> 表示该方法执行完成。</p></li><li><p>方法 <code>second()</code> 中，检查 <code>firstJobDone</code> 的状态。如果未更新则进入等待状态，否则执行方法 <code>second()</code>。在方法末尾，更新变量 <code>secondJobDone</code> 表示方法 <code>second()</code> 执行完成。</p></li><li><p>方法 <code>third()</code> 中，检查 <code>secondJobDone</code> 的状态。与方法 <code>second()</code> 类似，执行 <code>third()</code> 之前，需要先等待 <code>secondJobDone</code> 的状态。</p></li></ul><p><img src="https://pic.leetcode-cn.com/Figures/1114/1114_flow.png" alt="image"></p><p><strong>实现</strong></p><p>上述算法的实现在很大程度上取决于选择的编程语言。尽管在 Java，C++ 和 Python 中都存在<a href="https://baike.baidu.com/item/%E4%BA%92%E6%96%A5%E4%BA%8B%E4%BB%B6/9980508?fr=aladdin" target="_blank" rel="noopener">互斥</a>与<a href="https://baike.baidu.com/item/%E4%BF%A1%E5%8F%B7%E9%87%8F/9807501?fr=aladdin" target="_blank" rel="noopener">信号量</a>，但不同语言对并发机制有不同实现。</p><figure class="highlight python"><figcaption><span>[solution1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.firstJobDone = Lock()</span><br><span class="line">        self.secondJobDone = Lock()</span><br><span class="line">        self.firstJobDone.acquire()</span><br><span class="line">        self.secondJobDone.acquire()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">first</span><span class="params">(self, printFirst: <span class="string">'Callable[[], None]'</span>)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="comment"># printFirst() outputs "first".</span></span><br><span class="line">        printFirst()</span><br><span class="line">        <span class="comment"># Notify the thread that is waiting for the first job to be done.</span></span><br><span class="line">        self.firstJobDone.release()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">second</span><span class="params">(self, printSecond: <span class="string">'Callable[[], None]'</span>)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="comment"># Wait for the first job to be done</span></span><br><span class="line">        <span class="keyword">with</span> self.firstJobDone:</span><br><span class="line">            <span class="comment"># printSecond() outputs "second".</span></span><br><span class="line">            printSecond()</span><br><span class="line">            <span class="comment"># Notify the thread that is waiting for the second job to be done.</span></span><br><span class="line">            self.secondJobDone.release()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">third</span><span class="params">(self, printThird: <span class="string">'Callable[[], None]'</span>)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Wait for the second job to be done.</span></span><br><span class="line">        <span class="keyword">with</span> self.secondJobDone:</span><br><span class="line">            <span class="comment"># printThird() outputs "third".</span></span><br><span class="line">            printThird()</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption><span>[solution1-Cpp]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">sem_t</span> firstJobDone;</span><br><span class="line">    <span class="keyword">sem_t</span> secondJobDone;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    Foo() &#123;</span><br><span class="line">        sem_init(&amp;firstJobDone, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        sem_init(&amp;secondJobDone, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void first(function&lt;void()&gt; printFirst) &#123;</span><br><span class="line">        <span class="comment">// printFirst() outputs "first".</span></span><br><span class="line">        printFirst();</span><br><span class="line">        sem_post(&amp;firstJobDone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void second(function&lt;void()&gt; printSecond) &#123;</span><br><span class="line">        sem_wait(&amp;firstJobDone);</span><br><span class="line">        <span class="comment">// printSecond() outputs "second".</span></span><br><span class="line">        printSecond();</span><br><span class="line">        sem_post(&amp;secondJobDone);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void third(function&lt;void()&gt; printThird) &#123;</span><br><span class="line">        sem_wait(&amp;secondJobDone);</span><br><span class="line">        <span class="comment">// printThird() outputs "third".</span></span><br><span class="line">        printThird();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> AtomicInteger firstJobDone = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">private</span> AtomicInteger secondJobDone = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">(Runnable printFirst)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// printFirst.run() outputs "first".</span></span><br><span class="line">    printFirst.run();</span><br><span class="line">    <span class="comment">// mark the first job as done, by increasing its count.</span></span><br><span class="line">    firstJobDone.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(Runnable printSecond)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (firstJobDone.get() != <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// waiting for the first job to be done.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printSecond.run() outputs "second".</span></span><br><span class="line">    printSecond.run();</span><br><span class="line">    <span class="comment">// mark the second as done, by increasing its count.</span></span><br><span class="line">    secondJobDone.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">third</span><span class="params">(Runnable printThird)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (secondJobDone.get() != <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// waiting for the second job to be done.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printThird.run() outputs "third".</span></span><br><span class="line">    printThird.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="扩展思考"><a href="#扩展思考" class="headerlink" title="扩展思考"></a>扩展思考</h1><p>按序打印中只使用一个AtomicInteger做共享变量会增加耗时，可以深入探究其中的原因。</p><h1 id="方法二：通过synchronized构造屏障"><a href="#方法二：通过synchronized构造屏障" class="headerlink" title="方法二：通过synchronized构造屏障"></a>方法二：通过synchronized构造屏障</h1><p>这是一个典型的执行屏障的问题，可以通过构造屏障来实现。</p><p>如下图，我们需要构造 <em>2</em> 道屏障，<code>second</code> 线程等待 <code>first</code> 屏障，<code>third</code> 线程等待 <code>second</code> 屏障。：</p><p><img src="https://pic.leetcode-cn.com/879c5abd22c2dbc2618a1433dfbeb02a34b9586a10425986fafdc90eef978cc1-image.png" alt="image"></p><p><code>first</code> 线程会释放 <code>first</code> 屏障，而 <code>second</code> 线程会释放 <code>second</code> 屏障。</p><p>Java 中，我们使用线程等待的方式实现执行屏障，使用释放线程等待的方式实现屏障消除。具体代码如下：</p><figure class="highlight java"><figcaption><span>[-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> firstFinished;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> secondFinished;</span><br><span class="line">    <span class="keyword">private</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">(Runnable printFirst)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// printFirst.run() outputs "first". Do not change or remove this line.</span></span><br><span class="line">            printFirst.run();</span><br><span class="line">            firstFinished = <span class="keyword">true</span>;</span><br><span class="line">            lock.notifyAll(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(Runnable printSecond)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!firstFinished) &#123;</span><br><span class="line">                lock.wait();</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// printSecond.run() outputs "second". Do not change or remove this line.</span></span><br><span class="line">            printSecond.run();</span><br><span class="line">            secondFinished = <span class="keyword">true</span>;</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">third</span><span class="params">(Runnable printThird)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">           <span class="keyword">while</span> (!secondFinished) &#123;</span><br><span class="line">                lock.wait();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printThird.run() outputs "third". Do not change or remove this line.</span></span><br><span class="line">            printThird.run();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="https://leetcode-cn.com/problems/print-in-order/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/print-in-order/</a></p><p>【2】<a href="https://baike.baidu.com/item/%E5%B9%B6%E5%8F%91%E8%AE%A1%E7%AE%97/9939802?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/%E5%B9%B6%E5%8F%91%E8%AE%A1%E7%AE%97/9939802?fr=aladdin</a></p><p>【3】<a href="https://leetcode-cn.com/problems/print-in-order/solution/an-xu-da-yin-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/print-in-order/solution/an-xu-da-yin-by-leetcode/</a></p><p>【4】<a href="https://www.jianshu.com/p/509aca840f6d" target="_blank" rel="noopener">https://www.jianshu.com/p/509aca840f6d</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;请设计修改程序，以确保三个线程中的 two() 方法在 one() 方法之后被执行，three() 方法在 two() 方法之后被执行。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年5月" scheme="http://yoursite.com/categories/2020%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Concurrency" scheme="http://yoursite.com/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>684.冗余链接</title>
    <link href="http://yoursite.com/2020/05/19/684.%E5%86%97%E4%BD%99%E9%93%BE%E6%8E%A5/"/>
    <id>http://yoursite.com/2020/05/19/684.冗余链接/</id>
    <published>2020-05-19T02:26:12.000Z</published>
    <updated>2020-05-19T15:51:25.460Z</updated>
    
    <content type="html"><![CDATA[<p>使用并查集找到一条可以删去的边。</p><a id="more"></a><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>在计算机科学中，并查集是一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题。有一个联合-查找算法（Union-find Algorithm）定义了两个用于此数据结构的操作：</p><p>Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。<br>Union：将两个子集合并成同一个集合。</p><p>由于支持这两种操作，一个不相交集也常被称为联合-查找数据结构（Union-find Data Structure）或合并-查找集合（Merge-find Set）。<br>为了更加精确的定义这些方法，需要定义如何表示集合。一种常用的策略是为每个集合选定一个固定的元素，称为代表，以表示整个集合。接着，Find(x) 返回 x 所属集合的代表，而 Union 使用两个集合的代表作为参数。</p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>本问题中, 树指的是一个连通且无环的无向图。</p><p>输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。</p><p>结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u &lt; v，表示连接顶点u 和v的无向图的边。</p><p>返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u &lt; v。</p><p>示例 1：</p><p>输入: [[1,2], [1,3], [2,3]]<br>输出: [2,3]<br>解释: 给定的无向图为:<br>  1<br> / <br>2 - 3<br>示例 2：</p><p>输入: [[1,2], [2,3], [3,4], [1,4], [1,5]]<br>输出: [1,4]<br>解释: 给定的无向图为:<br>5 - 1 - 2<br>    |   |<br>    4 - 3</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="方法一：DFS"><a href="#方法一：DFS" class="headerlink" title="方法一：DFS"></a>方法一：DFS</h2><p><strong>算法：</strong><br>对于每个边 <code>(u, v)</code>，用深度优先搜索遍历图，以查看是否可以将 <code>u</code> 连接到 <code>v</code>。如果可以，则它是重复边。</p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(N^2)*。其中 *N</em> 是图中的结点数（以及边数）。在最坏的情况下，对于我们包含的每一条边，我们必须搜索图中出现的每一条边。</li><li>空间复杂度：<em>O(N)*，图的当前构造最多有 *N</em> 个结点。</li></ul><h2 id="方法二：并查集"><a href="#方法二：并查集" class="headerlink" title="方法二：并查集"></a>方法二：并查集</h2><p><strong>算法：</strong><br>如果我们熟悉并查集（DSU）数据结构，我们可以直接使用它来解决这个问题：我们只需找到已经连接的图中出现的第一条边。本解释的其余部分将重点介绍实现 DSU 的细节。</p><p>一个 DSU 数据结构可以用来维护图形连接组件的数据，并快速查询它们。有两种操作：</p><ul><li><code>dsu.find(node x)</code>，找到元素 <code>x</code> 所在的集合的代表，该操作也可以用于判断两个元素是否位于同一个集合。</li><li><code>dsu.union(node x, node y)</code>，把元素 <code>x</code> 和元素 <code>y</code> 所在的集合合并，要求 <code>x</code>和 <code>y</code> 所在的集合不相交，如果相交则不合并。</li></ul><p>为了实现这一点，我们跟踪父结点，它会记录同一连接节点中较小结点的所在的集合。如果结点是它自己的父结点，我们将其称为连接结点的领导者。</p><p>DSU 结构的简单实现如下所示：<br>伪代码 ：<br>我们使用两种技术来提高运行时的复杂性：路径压缩和按秩合并。</p><ul><li>路径压缩涉及将 <code>find</code> 函数中的 <code>x=parent[x]</code> 更改为<code>parent[x]=find(parent[x])</code>。</li><li>按秩合并涉及到将发现的工作量平均分配给领导者。每当 <code>dsu.union(x, y)</code> 时，我们都有两个领导者 <code>xr，yr</code>，并且我们要选择是要 <code>parent[x]=yr</code> 还是 <code>parent[y]=xr</code>。我们选择有更多子节点的领导者作为领导者。</li><li>具体地说，<code>rank</code> 的含义是 <code>x</code> 的跟随者少于 <code>2 ^ rank[x]</code>，这个策略可以作为 <code>dsu.find</code> 中的递归循环可中的界限。</li></ul><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<img src="./p__O_Nalpha_N___approx_O_N__.png" alt="O(N\alpha(N))\approxO(N) "> 。其中， <em>N</em> 是图中顶点的数目（以及边的数目），<img src="./p__alpha_.png" alt="\alpha ">  是 <code>Inverse-Ackermann</code> 函数。我们对 <code>dsu.union</code> 进行了多达 <em>N</em> 次查询，这需要花费 <img src="./p__O_alpha_N___.png" alt="O(\alpha(N)) ">  时间。可以去查阅资料为什么 <code>dsu.union</code> 具有 <img src="./p__O_alpha_N___.png" alt="O(\alpha(N)) ">  复杂性、<code>Inverse-Ackermann</code> 函数是什么以及为什么 <img src="./p__O_alpha_N___.png" alt="O(\alpha(N)) ">  大约是 <em>O(1)</em> 的原因。</li><li>空间复杂度：<em>O(N)*，图的当前构造（嵌入在我们的 DSU 结构中）最多有 *N</em> 个结点。</li></ul><h1 id="并查集的实现"><a href="#并查集的实现" class="headerlink" title="并查集的实现"></a>并查集的实现</h1><h2 id="集合树："><a href="#集合树：" class="headerlink" title="集合树："></a>集合树：</h2><p>所有节点以代表节点为父节点构成的多叉树</p><h2 id="节点的代表节点："><a href="#节点的代表节点：" class="headerlink" title="节点的代表节点："></a>节点的代表节点：</h2><p>可以理解为节点的父节点，从当前节点出发，可以向上找到的第一个节点</p><h2 id="集合的代表节点："><a href="#集合的代表节点：" class="headerlink" title="集合的代表节点："></a>集合的代表节点：</h2><p>可以理解为根节点，意味着该集合内所有节点向上走，最终都能到达的节点</p><p>体到这个题上：<br>我们以这个边集合为例子[[1,2], [3,4], [3,2], [1,4], [1,5]]</p><p>一、首先，对于边集合edges的每个元素，我们将其看作两个节点集合</p><p>比如边[2, 3],我们将其看作节点集合2，和节点集合3</p><p>二、在没有添加边的时候，各个节点集合独立，我们需要初始化各个节点集合的代表节点为其自身</p><p>所以，我们先初始化一个容器vector，使得vector[i]=i。</p><p>这里两个i意思不同，作为索引的i是指当前节点，作为值的i是指当前节点所在集合的代表节点。</p><p>比如vector[2] = 2，意味着2这个节点所在集合的代表节点就是2，没有添加边的情况下，所有节点单独成集合，自身就是代表节点</p><p>三、然后我们开始遍历边集合，将边转化为集合的关系</p><p>这里有一点很重要：边[a,b]意味着a所在集合可以和b所在集合合并。</p><p>合并方法很多，这里我们简单地将a集合的代表节点戳到b集合的代表节点上。<br>这意味着，将b集合代表节点作为合并后大集合的代表节点。</p><p>对于一个集合的代表节点s，一定有s-&gt;s，意思是s如果是代表节点，那么它本身不存在代表节点</p><p>假设我们的读取顺序为[[1,2], [3,4], [3,2], [1,4], [1,5]]</p><p>初始化vector[0, 1, 2, 3, 4, 5]</p><p>对应的index [0, 1, 2, 3, 4, 5]</p><p>##########################################################################</p><p>1.读取[1,2]：</p><p>读取顺序为[[1,2], [3,4], [3,2], [1,4], [1,5]]</p><p>当前vector[0, 1, 2, 3, 4, 5]</p><p>当前index [0, 1, 2, 3, 4, 5]</p><p>原本1-&gt;1，2-&gt;2，</p><p>由1节点出发，vector[1]=1, 找到1所在集合的代表节点1</p><p>由2节点出发，vector[2]=2, 找到2所在集合的代表节点2</p><p>于是，将1的代表置为2，vector[1]=2, vector[2]=2</p><p>对应的vector[0, 2, 2, 3, 4, 5]</p><p>对应的index [0, 1, 2, 3, 4, 5]</p><p>##########################################################################</p><p>2.读取[3, 4]</p><p>读取顺序为[[1,2], [3,4], [3,2], [1,4], [1,5]]</p><p>当前vector[0, 2, 2, 3, 4, 5]</p><p>当前index [0, 1, 2, 3, 4, 5]</p><p>同理，将3所在集合的的代表节点3的代表节点置为4</p><p>对应的vector[0, 2, 2, 4, 4, 5]</p><p>对应的index [0, 1, 2, 3, 4, 5]</p><p>##########################################################################<br>3.读取[3, 2]</p><p>读取顺序为[[1,2], [3,4], [3,2], [1,4], [1,5]]</p><p>当前vector[0, 1, 2, 4, 4, 5]</p><p>当前index [0, 1, 2, 3, 4, 5]</p><p>从节点3出发，vector[3]=4, vector[4]=4,于是找到节点3所在集合的代表节点为4</p><p>从节点2出发，vector[2]=2, 找到节点2所在集合的代表节点为2</p><p>于是，将4的代表置为2，vector[4]=2, vector[2]=2</p><p>对应的vector[0, 2, 2, 4, 2, 5]</p><p>对应的index [0, 1, 2, 3, 4, 5]</p><p>##########################################################################<br>4.读取[1, 4]</p><p>读取顺序为[[1,2], [3,4], [3,2], [1,4], [1,5]]</p><p>当前vector[0, 2, 2, 4, 2, 5]</p><p>当前index [0, 1, 2, 3, 4, 5]</p><p>从节点1出发，vector[1]=2, vector[2]=2, 找到节点1所在集合代表节点为2</p><p>从节点4出发，vector[4]=2, vector[2]=2, 找到节点4所在集合代表节点为2</p><p>由于1和4的代表节点相同，说明这两个节点本身就在同一个集合中</p><p>由于原图是无向图，路径是双向可达的，1能够到达2,而且2能够到达4，再加上1能够到达4</p><p>说明1能通过两条路径到达4，,这也意味着这条边出现的时候，原图中一定出现了环</p><p>至于题中要求的，返回最后一条边，其实这就是返回添加过后会构成环的那一条边<br>直白解释就是，在这条边出现之前，图中没有环</p><p>这条边出现，图中也出现环。包括这条边在内，构成环的边都是满足破圈条件的边<br>然而谁是最后一条出现在边集合里的？当然，就是这条构成环的最后一条边<br>##########################################################################</p><pre><code>class Solution {public:    vector&lt;int&gt; findRedundantConnection(vector&lt;vector&lt;int&gt;&gt;&amp; edges) {        vector&lt;int&gt; rp(1001);        int sz = edges.size();        // 初始化各元素为单独的集合，代表节点就是其本身        for(int i=0;i&lt;sz;i++)            rp[i] = i;        for(int j=0;j&lt;sz;j++){            // 找到边上两个节点所在集合的代表节点            int set1 = find(edges[j][0], rp);            int set2 = find(edges[j][1], rp);            if(set1 == set2)  // 两个集合代表节点相同，说明出现环，返回答案                return edges[j];            else    // 两个集合独立，合并集合。将前一个集合代表节点戳到后一个集合代表节点上                rp[set1] = set2;        }        return {0, 0};    }    // 查找路径并返回代表节点，实际上就是给定当前节点，返回该节点所在集合的代表节点    // 之前这里写的压缩路径，引起歧义，因为结果没更新到vector里，所以这里改成路径查找比较合适    int find(int n, vector&lt;int&gt; &amp;rp){        int num = n;        while(rp[num] != num)            num = rp[num];        return num;    }};</code></pre><h1 id="Java实现并查集"><a href="#Java实现并查集" class="headerlink" title="Java实现并查集"></a>Java实现并查集</h1><p>对于同一棵树的所有节点来说，都拥有共同的祖先节点。</p><p>因此，判断冗余连接的条件即为，判断新加入的边，两个节点是否有共同的祖先。</p><p>（1）如果有共同的祖先，则说明这条边是冗余的边；</p><p>（2）如果没有共同的祖先，则说明这两条边并未加入树中，因此进行合并操作。<br>循环边的记录，获取最后出现的冗余边，就是答案。</p><pre><code>public static class UnionFind {    int[] parent;    int[] rank;    public UnionFind(int total) {        parent = new int[total];        rank = new int[total];        for (int i = 0; i &lt; total; i++) {            parent[i] = i;            rank[i] = 1;        }    }    public int find(int x) {        while (x != parent[x]) {            parent[x] = parent[parent[x]];            x = parent[x];        }        return x;    }    public void unionElements(int p, int q) {        int pRoot = find(p);        int qRoot = find(q);        if (pRoot == qRoot) {            return;        }        if (rank[pRoot] &lt; rank[qRoot]) {            parent[pRoot] = qRoot;        } else if (rank[pRoot] &gt; rank[qRoot]) {            parent[qRoot] = pRoot;        } else {            parent[pRoot] = qRoot;            rank[qRoot] += 1;        }    }}public int[] findRedundantConnection(int[][] edges) {    int[] res = new int[2];    UnionFind unionFind = new UnionFind(edges.length);    // 第一条边肯定未记录至树中，可直接合并节点    unionFind.unionElements(edges[0][0] - 1, edges[0][1] - 1);    for (int i = 1; i &lt; edges.length; i++) {        if (unionFind.find(edges[i][0] - 1) == unionFind.find(edges[i][1] - 1)) {            res[0] = edges[i][0];            res[1] = edges[i][1];        } else {            unionFind.unionElements(edges[i][0] - 1, edges[i][1] - 1);        }    }    return res;}</code></pre><h1 id="Map实现并查集（Java）"><a href="#Map实现并查集（Java）" class="headerlink" title="Map实现并查集（Java）"></a>Map实现并查集（Java）</h1><p>逻辑很简单，对每一条边：<br>1、如果两个顶点在不同的树上，则合并两个树<br>2、如果两个顶点在相同的树上，那么他们一定构成了闭环</p><p>为了提升效率，getRoot(并查集中的find)方法中对树进行了压缩</p><pre><code>class Solution {public int[] findRedundantConnection(int[][] edges) {    Map&lt;Integer, Integer&gt; cMap = new HashMap&lt;&gt;();    for (int i = 0; i &lt; edges.length; i++) {        int pi0 = getRoot(cMap, edges[i][0]);        int pi1 = getRoot(cMap, edges[i][1]);        if(pi0 != pi1){            cMap.put(pi0,pi1);        } else {            return edges[i];        }    }    return null;}private int getRoot(Map&lt;Integer, Integer&gt; parents, int i){    if(parents.get(i) == null){        parents.put(i, i);        return i;    }    if(parents.get(i) == i){        return i;    }    return getRoot(parents,parents.get(i));}}</code></pre><h1 id="证明-：给定一条新的边，两头节点在同一个集合，就意味着出现了环"><a href="#证明-：给定一条新的边，两头节点在同一个集合，就意味着出现了环" class="headerlink" title="证明    ：给定一条新的边，两头节点在同一个集合，就意味着出现了环"></a>证明    ：给定一条新的边，两头节点在同一个集合，就意味着出现了环</h1><p>#####################################################################<br>下面是增加的一部分证明，</p><p>证明一下为什么给定一条新的边，两头节点在同一个集合，就意味着出现了环</p><p>这里有个大前提，因为是无向图，集合里不会同时出现[1,2]和[2,1]这种重合边</p><p>上面的代码遇到集合里有重合边的情况是会出现误判的</p><p>就拿这个[1,2]和[2,1]来举例</p><p>给定[1,2]后，再读取[2,1]，两个节点在同一个集合，然而并没有出现环。</p><p>所以，这里代码工作的前提是不出现重合边<br>#####################################################################</p><p>下面回到最初的问题，为什么给定新边的两个节点在同一集合就意味着出现了环</p><p>假设给定新边的两个节点分别为5,6，新边为[5,6]</p><p>对于一条新出现的边，总共有两种情况，两个节点之一单独成集合，两个节点均不单独成集合</p><p>第一种情况，两个节点之一单独成集合</p><p>假设5单独成集合。这种情况下，两个节点不可能在一个集合里</p><p>因为有一个独立集合（只有节点5），6所在的集合和这个集合必然没有交集</p><p>之后这两个集合进行合并操作</p><p>直观点理解就是，5单独成集合，意味着5第一次出现在图里</p><p>这里只有新边和5相关，所以当前只给定一条和5相关的边，对5而言，就像只举起了一只手</p><p>要形成环，环上每个节点都必须是举起两只手的</p><p>所以这种情况下是不可能出现环的，程序中也是这样判定的</p><p>第二种情况，两个节点均不单独成集合</p><p>这里也可以细分为5和6是否作为该集合的代表节点</p><p>假设5所在集合代表节点为a</p><p>6所在集合代表节点也为a</p><p>2.1第一个分支，如果a不为5和6本身，那么就有5-&gt;…-&gt;a，6-&gt;…-&gt;a，路径双向可达</p><p>可以得到5-&gt;…-&gt;a-&gt;…-&gt;6,对于给定边[5,6]可得5-&gt;6</p><p>所以5到达6有两条路径，出现了环。</p><p>2.2第二个分支，a为5和6之一</p><p>假设，a为5</p><p>2.2.1 首先考虑，6直接指向5这种情况</p><p>出现这种情况，只能是在已经存在集合x-&gt;…-&gt;6时，出现[…,5]这样的边</p><p>其中，…为x-&gt;…-&gt;6路径上除6以外任意节点</p><p>此时…的代表节点为6，5的代表节点为5，合并，6戳到5上，于是出现了6直接指向5</p><p>这种情况下，已经存在6-&gt;…-&gt;5一条路径，再读取到[5,6]，环出现了</p><p>2.2.2 再考虑6不直接指向5的情况，就简单很多了，6-&gt;x-&gt;5</p><p>再读取到[5,6]，6可以通过两条路径到达5，出现环</p><p>综上，在边集合没有重合边的情况下，如果给定新边的两个节点在同一集合中，说明图中出现了环</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://leetcode-cn.com/problems/redundant-connection/solution/tong-su-jiang-jie-bing-cha-ji-bang-zhu-xiao-bai-ku/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/redundant-connection/solution/tong-su-jiang-jie-bing-cha-ji-bang-zhu-xiao-bai-ku/</a></p><p>【2】<a href="https://leetcode-cn.com/problems/redundant-connection/solution/bing-cha-ji-jie-jue-rong-yu-lian-jie-i-by-jxd134/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/redundant-connection/solution/bing-cha-ji-jie-jue-rong-yu-lian-jie-i-by-jxd134/</a></p><p>【3】<a href="https://leetcode-cn.com/problems/redundant-connection/solution/bing-cha-ji-mapshi-xian-de-ling-lei-bing-cha-ji-by/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/redundant-connection/solution/bing-cha-ji-mapshi-xian-de-ling-lei-bing-cha-ji-by/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用并查集找到一条可以删去的边。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年5月" scheme="http://yoursite.com/categories/2020%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Union Find" scheme="http://yoursite.com/tags/Union-Find/"/>
    
      <category term="Graph" scheme="http://yoursite.com/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>Lombok的基本注解使用</title>
    <link href="http://yoursite.com/2020/05/18/Lombok%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/05/18/Lombok的基本注解使用/</id>
    <published>2020-05-18T14:05:12.000Z</published>
    <updated>2020-05-18T16:13:03.842Z</updated>
    
    <content type="html"><![CDATA[<p>学习使用Lombok的基本注解：@Data，@AllArgsConstructor，@NoArgsConstructor，@Builder</p><a id="more"></a><p>Lombok 是一种 Java™ 实用工具，可用来帮助开发人员消除 Java 的冗长，尤其是对于简单的 Java 对象（POJO）。它通过注解实现这一目的。</p><h1 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h1><p>在 pom.xml 文件中添加相关依赖：</p><pre><code>&lt;lombok.version&gt;1.16.20&lt;/lombok.version&gt;&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;version&gt;${lombok.version}&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;</code></pre><h1 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h1><p>由于 Lombok 采取的注解形式的，在编译后，自动生成相应的方法，需要下载插件来支持它。<br>以 IDEA 为例：查找插件 lombok plugin 安装即可。</p><p>以 User 实体类为例（set,get,toString 方法），</p><p>拿lombok官网的一个例子来说:</p><pre><code>public class Mountain{    private String name;    private double longitude;    private String country;}</code></pre><p>要使用这个对象,必须还要写一些getter和setter方法,可能还要写一个构造器、equals方法、或者hash方法.这些方法很冗长而且没有技术含量,我们叫它样板式代码.<br>lombok的主要作用是通过一些注解，消除样板式代码，像这样：</p><pre><code>@Datapublic class Mountain{    private String name;    private double longitude;    private String country;}</code></pre><p>然后这个类自动生成了这些方法.</p><h1 id="Data-生成getter-setter等函数"><a href="#Data-生成getter-setter等函数" class="headerlink" title="@Data 生成getter,setter等函数"></a>@Data 生成getter,setter等函数</h1><p>使用这个注解，就不用再去手写Getter,Setter,equals,canEqual,hasCode,toString等方法了，注解后在编译时会自动加进去。@Data 包含了 @ToString、@EqualsAndHashCode、@Getter / @Setter和@RequiredArgsConstructor的功能.</p><h1 id="AllArgsConstructor-生成全参数构造函数"><a href="#AllArgsConstructor-生成全参数构造函数" class="headerlink" title="@AllArgsConstructor 生成全参数构造函数"></a>@AllArgsConstructor 生成全参数构造函数</h1><p>使用后添加一个构造函数，该构造函数含有所有已声明字段属性参数</p><h1 id="NoArgsConstructor-生成全参数构造函数"><a href="#NoArgsConstructor-生成全参数构造函数" class="headerlink" title="@NoArgsConstructor 生成全参数构造函数"></a>@NoArgsConstructor 生成全参数构造函数</h1><p>使用后创建一个无参构造函数,即没有参数的构造函数。</p><h1 id="Builder"><a href="#Builder" class="headerlink" title="@Builder"></a>@Builder</h1><p>关于Builder较为复杂一些，Builder的作用之一是为了解决在某个类有很多构造函数的情况，也省去写很多构造函数的麻烦，在设计模式中的思想是：用一个内部类去实例化一个对象，避免一个类出现过多构造函数，</p><p>举一个例子：</p><pre><code>import lombok.*;@Data //生成getter,setter等函数@AllArgsConstructor //生成全参数构造函数@NoArgsConstructor//生成无参构造函数@Builderpublic class User {    private String name;    private String age;    private String sex;}</code></pre><p>我们来为User类赋值并打印一下结果：</p><pre><code>public static void main(String[] args) {      User userAllArgs = new User(&quot;27&quot;, &quot;yiye&quot;, &quot;male&quot;);//有全参数构造函数可如此赋值      User userNoArgs = new User();//有无参构造函数时可以如此使用      userNoArgs = User.builder().age(&quot;26&quot;).name(&quot;yezi&quot;).sex(&quot;male&quot;).build();//有      System.out.println(&quot;userAllArgs:&quot; + userAllArgs);      System.out.println(&quot;userNoArgs:&quot; + userNoArgs);  }</code></pre><p>打印结果是：</p><pre><code>userAllArgs:User(name=27, age=yiye, sex=male)userNoArgs:User(name=yezi, age=26, sex=male)</code></pre><h1 id="无参构造函数失效的情况"><a href="#无参构造函数失效的情况" class="headerlink" title="无参构造函数失效的情况"></a>无参构造函数失效的情况</h1><p><strong><em>注意的是，同时使用@Data 和 @AllArgsConstructor 后 ，默认的无参构造函数失效，如果需要它，要重新设置 @NoArgsConstructor</em></strong><br>这里我们要回顾一下Java中无参构造函数的相关知识：</p><ol><li><p>如果一个类没有定义任何构造函数，那么该类会自动生成1个默认的构造函数。默认构造函数没有参数。</p></li><li><p>如果一个类定义了构造函数，但这些构造函数都有参数，那么不会生成默认构造函数，也就是说此时类没有无参的构造函数。</p></li></ol><p>这种错误会出现在一些场合，例如我们定义一个DTO</p><pre><code>@Data@AllArgsConstructorpublic class TemplateInfoResponseDTO {    private String code;    private String msg;    private Boolean success;    private String data;}</code></pre><p>然后通过向某个已提供的接口发送post请求，然后将接收到的结果解析为TemplateInfoResponseDTO，</p><pre><code>String response = httpRequestHelper.sendPostWithLongWaitTime(BaseUrl + GETTEMPLATEINFO_URL, JSON.toJSONString(templateInfo));        TemplateInfoResponseDTO templateInfoResponseDTO = JSON.parseObject(response, TemplateInfoResponseDTO.class);</code></pre><p>但是返回的了错误信息是</p><pre><code>set property error, TemplateInfoResultVO#data，</code></pre><p>查看该接口平台的日志可以看到，</p><pre><code>com.alibaba.fastjson.JSONException:default constructor not found. class ...... TemplateInfoResponseDTO</code></pre><p>说明TemplateInfoResponseDTO 没有默认的无参构造函数，所以string 转 object 失败了，因为同时使用@Data 和 @AllArgsConstructor 后 ，默认的无参构造函数失效，要么再加上@NoArgsConstructor注解，要么删除@AllArgsConstructor。</p><h1 id="Builder支持默认值"><a href="#Builder支持默认值" class="headerlink" title="@Builder支持默认值"></a>@Builder支持默认值</h1><p>Lombok 使用 Builder 的时候，需要在默认值的部分加上 @Default 注解，否则默认值是无效的<br>例如我们给User的属性赋予默认值</p><pre><code>@Data //生成getter,setter等函数@AllArgsConstructor //生成全参数构造函数@NoArgsConstructor//生成无参构造函数@Builderpublic class User {    private String name = &quot;yiye&quot;;    private String age = &quot;18&quot;;    private String sex = &quot;male&quot;;}</code></pre><p>然后打印出来：</p><pre><code>public static void main(String[] args) {      User userAllArgs = User.builder().build();      System.out.println(&quot;userAllArgs:&quot; + userAllArgs);      User userNoArgs = new User();      System.out.println(&quot;userNoArgs:&quot; + userNoArgs);  }</code></pre><p>打印结果：</p><pre><code>userAllArgs:User(name=null, age=null, sex=null)userNoArgs:User(name=yiye, age=18, sex=male)</code></pre><p>可见@Builder默认是不支持默认值设置，或者说，自动忽略了User里面设置的默认值。<br>在有默认值的属性上使用这个注解：@Builder.Default</p><pre><code>@Data //生成getter,setter等函数@AllArgsConstructor //生成全参数构造函数@NoArgsConstructor//生成无参构造函数@Builderpublic class User {    @Builder.Default    private String name = &quot;yiye&quot;;    @Builder.Default    private String age = &quot;18&quot;;    @Builder.Default    private String sex = &quot;male&quot;;}</code></pre><p>再看打印的结果：</p><pre><code>userAllArgs:User(name=yiye, age=18, sex=male)userNoArgs:User(name=null, age=null, sex=null)</code></pre><p>发现此时@Builder支持了默认值的设置，但是直接用无参构造的方法new User()出来的对象没有了默认值，这是需要注意的一点。</p><p>Lombok更多的注解使用方法参见参考资料【1】，另外可以在IDEA的target/classes文件夹中查看编译后的class文件，看加了注解后的实体编译后自动生成了哪些方法。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://www.jianshu.com/p/365ea41b3573" target="_blank" rel="noopener">https://www.jianshu.com/p/365ea41b3573</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习使用Lombok的基本注解：@Data，@AllArgsConstructor，@NoArgsConstructor，@Builder&lt;/p&gt;
    
    </summary>
    
      <category term="2020年5月" scheme="http://yoursite.com/categories/2020%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>后端开发常用调试技巧集锦</title>
    <link href="http://yoursite.com/2020/05/18/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7%E9%9B%86%E9%94%A6/"/>
    <id>http://yoursite.com/2020/05/18/后端开发常用调试技巧集锦/</id>
    <published>2020-05-18T09:24:12.000Z</published>
    <updated>2020-05-23T04:30:19.348Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下容易被忽略的后端开发中常用的调试技巧，主要包括IDEA中的常用快捷键和调试方法，<br>使用Charles，Postman，浏览器，命令行调试的常见技巧。</p><a id="more"></a><h1 id="IntelliJ-IDEA的常用调试技巧："><a href="#IntelliJ-IDEA的常用调试技巧：" class="headerlink" title="IntelliJ IDEA的常用调试技巧："></a>IntelliJ IDEA的常用调试技巧：</h1><h2 id="Mac中的常用快捷键"><a href="#Mac中的常用快捷键" class="headerlink" title="Mac中的常用快捷键"></a>Mac中的常用快捷键</h2><pre><code>Ctrl+A：到行首（达到Home键的效果）Ctrl+E：到行尾（达到End键的效果）Ctrl+N：到下一行Ctrl+P：到上一行Ctrl+K：从光标处开始删除，直到行尾</code></pre><p>更多的参见<a href="https://www.jianshu.com/p/87581b2c570c" target="_blank" rel="noopener">Mac终端快捷键</a></p><h2 id="IDEA中的常用快捷键"><a href="#IDEA中的常用快捷键" class="headerlink" title="IDEA中的常用快捷键"></a>IDEA中的常用快捷键</h2><p>这里仅记录一些易被忽略的常用快捷键，更多的快捷键参见<a href="https://www.jianshu.com/p/b8c13ca3154a" target="_blank" rel="noopener">IDEA Mac 快捷键</a>：<br>Mac键盘符号和修饰键说明</p><pre><code>⌘ Command⇧ Shift⌥ Option⌃ Control↩︎ Return/Enter⌫ Delete⌦ 向前删除键（Fn+Delete）↑ 上箭头↓ 下箭头← 左箭头→ 右箭头⇞ Page Up（Fn+↑）⇟ Page Down（Fn+↓）Home Fn + ←</code></pre><h3 id="Editing（编辑"><a href="#Editing（编辑" class="headerlink" title="Editing（编辑)"></a>Editing（编辑)</h3><pre><code>⌘N, ⌃↩, ⌃N 生成代码（getter、setter、构造函数、hashCode/equals,toString）⌘⌥T 包围代码（使用if..else, try..catch, for, synchronized等包围选中的代码）⌘⌥L 格式化代码⌃⌥O 优化import⌃⇧J 智能的将代码拼接成一行⌘↩ 智能的拆分拼接的行⇧↩ 开始新的一行⌘⇧+ 展开所以代码块⌘⇧- 折叠所有代码块⌘ + Y/X    删除行⌘ + D    复制行</code></pre><h3 id="Navigation（导航）"><a href="#Navigation（导航）" class="headerlink" title="Navigation（导航）"></a>Navigation（导航）</h3><pre><code>双击shift或⌘O  查找类文件⌘⌥← / ⌘⌥→ 退回 / 前进到上一个操作的地方⌘⇧⌫ 跳转到最后一个编辑的地方</code></pre><h2 id="函数重构抽取函数"><a href="#函数重构抽取函数" class="headerlink" title="函数重构抽取函数"></a>函数重构抽取函数</h2><pre><code>右键-》refactor-》Extract-》Method</code></pre><h2 id="抛异常快捷键"><a href="#抛异常快捷键" class="headerlink" title="抛异常快捷键"></a>抛异常快捷键</h2><pre><code>Code-&gt;Surround With</code></pre><h2 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h2><pre><code>fori    生成循环sout    System.out.println();⌘ + J    可以查看所有代码模板⌘ + ⌥ + J    用动态模板环绕⌘ + ⇧ + Enter    自动补全末尾的字符（括号，分号），例如敲完if/for时也可以自动补上{}花括号。⌥ + Enter    导入包，快速修复</code></pre><p>在项目中写好的接口下输入psvm按Tab即可自动展示出</p><pre><code>public static void main(String[] args) {}</code></pre><p>可以实时在项目中插入一个能运行的入口。psvm 也就是public static void main的首字母</p><p>System.out.println() (sout 按tab)，for循环（fori按tab）main(psvm按tab)，更多的提示可以CTRL + j 可以查看，mac系统下是command＋j，</p><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><pre><code>⌘ + ⇧ +T 创建单元测试用例</code></pre><p>要多学会使用在项目中编写单元测试的方法进行测试，不要总是重新运行整个项目<br>在maven项目的pom.xml文件中添加依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;junit&lt;/groupId&gt;    &lt;artifactId&gt;junit&lt;/artifactId&gt;    &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>选择一个类 比如xxxServiceImpl， xxDaoImpl<br>然后右键，选择goto – test</p><h1 id="Charles调试技巧"><a href="#Charles调试技巧" class="headerlink" title="Charles调试技巧"></a>Charles调试技巧</h1><p>charles也叫青花瓷，一个很文艺的名字，是在 Mac 下常用的网络封包截取工具，我主要使用charles的场景：<br>一是做移动开发时将其设置成系统的网络访问代理服务器，二是调试一些纯接口的项目时可以使用charles做网页代理将浏览器里的请求代理发送到本地实时调试。</p><h2 id="使用Map-Remote功能"><a href="#使用Map-Remote功能" class="headerlink" title="使用Map Remote功能"></a>使用Map Remote功能</h2><p>对于纯接口系统可以使用charles做网页代理将浏览器里的请求代理发送到本地实时调试，比之前简便了太多。<br><strong><em>Charles 的Map 功能分Map Remote 和Map Local 两种，Map Remote 是将指定的网络请求重定向到另一个网址，Map Local 是将指定的网络请求重定向到本地文件。</em></strong><br>Map Remote 使用场景，app或者PC&amp;M站某个需求刚提测阶段，新接口A在测试环境有，<br>还有一种极端情况，接口只在开发本地机器提供（无线底层很多接口不维护测试环境），线上环境A接口还未上线，此时可以使用charles的map remote功能。<br>选择</p><pre><code>charles-&gt;Tools-&gt;Map Remote-&gt;Enable Map Remote</code></pre><p>将Map From填写为测试环境的网址和端口，<br>Map to填写为本机的端口，注意填写Path<br>协议选择http</p><p><strong><em>Map From：</em></strong></p><pre><code>Protocol：httpHost：test.cn（前端的测试网址）PORT：80（http默认端口80，https默认端口是403）Path：/api/milp2p/module/currentModuleDataQuery：currentModuleStep=COMPLIANCE&amp;_=*</code></pre><p><strong><em>Map to：</em></strong></p><pre><code>Protocol：httpHost：192.168.0.1（指定主机的ip地址，可以使用ifconfig查询指定主机的ip地址，在eth0一项，本机可以用localhost）PORT：8900（本地项目使用的端口）Path：/module/currentModuleDataQuery：currentModuleStep=COMPLIANCE&amp;_=*</code></pre><p>对于submitCurrentModuleStep的代理更为简单：<br><strong><em>Map From：</em></strong></p><pre><code>Protocol：httpHost：test.cn（前端的测试网址）PORT：80（http默认端口80，https默认端口是403）Path：/api/milp2p/module/submitCurrentModuleStepQuery：=*</code></pre><p><strong><em>Map to：</em></strong></p><pre><code>Protocol：httpHost：192.168.0.1（指定主机的ip地址，可以使用ifconfig查询指定主机的ip地址，在eth0一项，本机可以用localhost）PORT：8900（本地项目使用的端口）Path：/module/submitCurrentModuleStepQuery：_=*</code></pre><p>关于Map Local和Rewrite功能的使用参见文章《Charles使用Map Local和Rewrite提高开发效率》</p><p>另外要选择菜单中的 “Proxy” –&gt; “Mac OS X Proxy”，才能将 Charles 设置成系统代理</p><h1 id="PostMan调试技巧"><a href="#PostMan调试技巧" class="headerlink" title="PostMan调试技巧"></a>PostMan调试技巧</h1><p>PostMan软件可用于调试HTTP接口，具体使用方法不再赘述<br>只说需要注意的几点：</p><h2 id="RequestParam注解"><a href="#RequestParam注解" class="headerlink" title="@RequestParam注解"></a>@RequestParam注解</h2><p>当controller中当方法参数为@RequestParam形式时</p><pre><code>//4。从外部能够查询商户(根据ID查询商户)//http://localhost:8080//Shop/ShopQuery Postman中Get内容，其余内容可以在Params中的KEY和VALUE填写@GetMapping(&quot;/ShopQuery&quot;)public ShopResponseDTO ShopQuery(@RequestParam(&quot;shopName&quot;) String shopName,                                    @RequestParam(&quot;contactName&quot;) String contactName,                                    @RequestParam(&quot;contactPhone&quot;)  String contactPhone,                                    @RequestParam(&quot;platformKey&quot;) String platformKey,                                    @RequestParam(&quot;shortName&quot;) String shortName){    ShopResponseDTO shopResponseDTO=new ShopResponseDTO();    shopResponseDTO=userService.MybatisSpringQuery(40L);    return shopResponseDTO;}</code></pre><p>Postman中选择POST格式发送，<a href="http://localhost:8080/Shop/ShopQuery" target="_blank" rel="noopener">http://localhost:8080/Shop/ShopQuery</a><br>然后在Params中填入KEY和VALUE，即可发送对应当POST请求。</p><h2 id="RequestBody注解"><a href="#RequestBody注解" class="headerlink" title="@RequestBody注解"></a>@RequestBody注解</h2><p>如果controller中的方法参数为@RequestBody形式时:</p><pre><code>/**商户接口* 4。从外部能够查询商户(根据ID查询商户)* http://localhost:8080//Shop/ShopQuery Postman中Get内容，其余内容可以在Params中的KEY和VALUE填写* @param ShopRequestDTO* @return*/@GetMapping(&quot;/ShopQuery&quot;)public ShopResponseDTO ShopQuery(@RequestBody SelectByIDShopRequestDTO selectByIDShopRequestDTO){  TblShopEntity tblShopEntity=new TblShopEntity();  tblShopEntity.setId(selectByIDShopRequestDTO.getId());  ShopResponseDTO shopResponseDTO;  shopResponseDTO=userService.MybatisSpringQuery(tblShopEntity);  return shopResponseDTO;}</code></pre><p>则选择Body-》raw形式，然后在右侧的栏中选择JSON(application/json)<br>以JSON格式填写POST中的Body：</p><pre><code>{    &quot;ID&quot;: &quot;47943&quot;}</code></pre><h2 id="使用postman发送请求可以使用Chrome插件"><a href="#使用postman发送请求可以使用Chrome插件" class="headerlink" title="使用postman发送请求可以使用Chrome插件"></a>使用postman发送请求可以使用Chrome插件</h2><p>postman interceptor<br>来抓取真实的请求，然后保存起来，根据情况替换请求地址</p><h1 id="浏览器测试技巧"><a href="#浏览器测试技巧" class="headerlink" title="浏览器测试技巧"></a>浏览器测试技巧</h1><p>除了用Postman进行测试外，也可以直接在浏览器中输入GET请求进行测试，在网址栏输入<a href="http://localhost:8080//Shop/ShopQuery发送即可" target="_blank" rel="noopener">http://localhost:8080//Shop/ShopQuery发送即可</a></p><h2 id="浏览器清空cookies缓存"><a href="#浏览器清空cookies缓存" class="headerlink" title="浏览器清空cookies缓存"></a>浏览器清空cookies缓存</h2><p>chrome右键打开检查页面，在和NETWORK平级的APPLICATION里可以找到cookies，右键clear</p><h1 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h1><h2 id="在日志中搜索匹配文本"><a href="#在日志中搜索匹配文本" class="headerlink" title="在日志中搜索匹配文本"></a>在日志中搜索匹配文本</h2><p>在vim中打开然后搜索，输入/，<br>然后输入要搜索的文本“target search text”<br>按enter后可定位到，如果要匹配下一个按小写n键。<br>跳转到上一个匹配呢？按下N（大写N）</p><p>也可以使用grep命令来过滤</p><pre><code>grep &quot;target search text&quot; debug.log --color</code></pre><h2 id="使用curl命令测试"><a href="#使用curl命令测试" class="headerlink" title="使用curl命令测试"></a>使用curl命令测试</h2><p>curl 是常用的命令行工具，用来请求 Web 服务器。它的名字就是客户端（client）的 URL 工具的意思。</p><p>它的功能非常强大，命令行参数多达几十种。如果熟练的话，完全可以取代 Postman 这一类的图形界面工具。</p><p>不带有任何参数时，curl 就是发出 GET 请求。</p><pre><code>$ curl https://www.google.com</code></pre><h3 id="d"><a href="#d" class="headerlink" title="-d"></a>-d</h3><p>-d参数用于发送 POST 请求的数据体。</p><pre><code>$ curl -d&apos;login=emma＆password=123&apos;-X POST https://google.com/login</code></pre><p>或者</p><pre><code>$ curl -d &apos;login=emma&apos; -d &apos;password=123&apos; -X POST  https://google.com/login</code></pre><p>使用-d参数以后，HTTP 请求会自动加上标头Content-Type : application/x-www-form-urlencoded。并且会自动将请求转为 POST 方法，因此可以省略-X POST。</p><p>-d参数可以读取本地文本文件的数据，向服务器发送。</p><pre><code>$ curl -d &apos;@data.txt&apos; https://google.com/login</code></pre><p>上面命令读取data.txt文件的内容，作为数据体向服务器发送。</p><h3 id="发送json格式请求"><a href="#发送json格式请求" class="headerlink" title="发送json格式请求"></a>发送json格式请求</h3><pre><code>curl -d &apos;{&quot;applyId&quot;:&quot;123&quot;}&apos;  -H &quot;Content-Type:application/json&quot; -X POST &quot;http://text.idc/TestController/getInfo&quot;curl --location --request POST &apos;http://text.idc/TestController/getInfo&apos;  --header &apos;Content-Type: application/json&apos; --data-raw &apos;{&quot;applyId&quot;:&quot;123&quot;}&apos;</code></pre><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://www.jianshu.com/p/6f81e86c8a61" target="_blank" rel="noopener">https://www.jianshu.com/p/6f81e86c8a61</a></p><p>【2】<a href="https://www.jianshu.com/p/dffca69070fc" target="_blank" rel="noopener">https://www.jianshu.com/p/dffca69070fc</a></p><p>【3】<a href="https://www.cnblogs.com/nzg-noway/articles/6524952.html" target="_blank" rel="noopener">https://www.cnblogs.com/nzg-noway/articles/6524952.html</a></p><p>【4】<a href="http://www.ruanyifeng.com/blog/2019/09/curl-reference.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/09/curl-reference.html</a></p><p>【5】<a href="https://www.jianshu.com/p/b8c13ca3154a" target="_blank" rel="noopener">https://www.jianshu.com/p/b8c13ca3154a</a></p><p>【6】<a href="https://www.jianshu.com/p/87581b2c570c" target="_blank" rel="noopener">https://www.jianshu.com/p/87581b2c570c</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下容易被忽略的后端开发中常用的调试技巧，主要包括IDEA中的常用快捷键和调试方法，&lt;br&gt;使用Charles，Postman，浏览器，命令行调试的常见技巧。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年5月" scheme="http://yoursite.com/categories/2020%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>405. 数字转化为十六进制数</title>
    <link href="http://yoursite.com/2020/04/29/405.%20%E6%95%B0%E5%AD%97%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0/"/>
    <id>http://yoursite.com/2020/04/29/405. 数字转化为十六进制数/</id>
    <published>2020-04-29T08:12:12.000Z</published>
    <updated>2020-04-29T09:38:47.665Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。</p><a id="more"></a><p>这道题看似简单但想符合所有情况还是很伤脑筋。<br>用了无符号右移和位运算后简化了很多。<br>首先要知道16进制数在计算机中是怎么表示的，<br>由于对于16进制一个有16个数（0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f）<br>所以我们只需要使用4位 2^4=16刚好可以表示16个数，<br>所以计算机在内部是用4位来表示16进制的0000表示0,0001表示1…..1111表示f.<br>所有题目给我们一个int型的数字num,一个int= 4字节 = 32位，<br>所以，这个32位数字可以被分隔成8个4位数，<br>所以我们只需要从头到尾每4位每4的的遍历，每遍历一个4位就将其转化为16进制的数即可<br>，有人可能会问为什么这样可以，其实这样我们是做了两个步骤，<br>先转化为2进制（由于计算机中所有东西本身就是2进制存储的，所以我们可以直接得到该数字的2进制），<br>再转化为16进制，比如对于26 -&gt;二进制为‭00011010‬（前面省略了24个0）<br>所以每4位遍历就变成了0001,1010对于0001 对应16进制中的1,1010对应16进制中的a所以结果就是为1a.<br>所以对于此题我们只需要从尾部开始用位运算取出每一个4位，<br>再转化为16进制即可只需要注意前面为0的16进制应该删除即可。<br>我们首先需要设一个数字calc = 0xf也就是右边4位为1其余均为0<br>，此时我们把数字num与之进行与运算就可以取出，num右边4位的值，<br>然后再把calc向左边移动4位就变成了11110000(前面省略24个0)此时在与之相与就可以得到num中右边8位的值，<br>此时还需要把这个值向右移动4位，因为这样是的到了第2个4位值，然后再次重复此步骤即可。</p><h1 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h1><p>java里面有 Integer.toHexString() 但是题目要求自己写 位运算，以4位为粒度进行取数,转化为16进制字符串</p><pre><code> /** * 如：35 == 0010 0011 = 23 * * 注意：java中 *      hex to int Integer.valueOf(&quot;12ff&quot;,16) *      int to hex Integer.toHexString(35) */```    public String toHex(int num) {        char[] hex = &quot;0123456789abcdef&quot;.toCharArray();        String s = new String();        while(num != 0){            int end = num&amp;15;            s = hex[end] + s;            //无符号右移            num &gt;&gt;&gt;=4;        }        if(s.length() == 0){            s = &quot;0&quot;;        }        return s;    }</code></pre><h1 id="无符号右移运算符-gt-gt-gt"><a href="#无符号右移运算符-gt-gt-gt" class="headerlink" title="无符号右移运算符&gt;&gt;&gt;"></a>无符号右移运算符&gt;&gt;&gt;</h1><p>它的通用格式如下所示：</p><p>　　value &gt;&gt;&gt; num</p><p>num 指定要移位值value 移动的位数。</p><p>无符号右移的规则只记住一点：忽略了符号位扩展，0补最高位</p><p>无符号右移规则和右移运算是一样的，只是填充时不管左边的数字是正是负都用0来填充，无符号右移运算只针对负数计算，因为对于正数来说这种运算没有意义<br>无符号右移运算符&gt;&gt;&gt; 只是对32位和64位的值有意义</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年4月" scheme="http://yoursite.com/categories/2020%E5%B9%B44%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot学习笔记VIII-MybatisPlus教程</title>
    <link href="http://yoursite.com/2020/04/17/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0VIII-MybatisPlus%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/04/17/SpringBoot学习笔记VIII-MybatisPlus教程/</id>
    <published>2020-04-17T02:12:12.000Z</published>
    <updated>2020-04-17T03:11:43.354Z</updated>
    
    <content type="html"><![CDATA[<p>MybatisPlus教程</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>官网地址：<a href="https://mybatis.plus/" target="_blank" rel="noopener">https://mybatis.plus/</a></p><p>官网简介：MyBatis-Plus 是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p><p>下面介绍如何快速上手 mybatis-plus，给出了 mapper 和 service CRUD 的基本示例。</p><p>建议在后续开发中，时时翻看官方文档（<a href="https://mybatis.plus/guide）。" target="_blank" rel="noopener">https://mybatis.plus/guide）。</a></p><h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><pre><code>&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><h2 id="MapperScan-配置"><a href="#MapperScan-配置" class="headerlink" title="MapperScan 配置"></a>MapperScan 配置</h2><pre><code>@SpringBootApplication@MapperScan(&quot;com.xx.xx.xx.mapper&quot;)public class Application {    public static void main(String[] args) {        SpringApplication.run(Application.class, args);    }}</code></pre><h1 id="Mapper-基本使用"><a href="#Mapper-基本使用" class="headerlink" title="Mapper 基本使用"></a>Mapper 基本使用</h1><h2 id="Entity-定义"><a href="#Entity-定义" class="headerlink" title="Entity 定义"></a>Entity 定义</h2><pre><code>@Data@Accessors(chain = true)@TableName(&quot;t_user&quot;) // 表名，默认是类名转下划线public class User {    // 指定主键，IdType.AUTO 表示自增主键    @TableId(type= IdType.AUTO)    private Long id;    private String name;    private Integer age;    private String email;    private Integer address;    // 不在数据库里的字段    @TableField(exist = false)    private Integer count;}</code></pre><h2 id="Mapper-定义：继承-BaseMapper"><a href="#Mapper-定义：继承-BaseMapper" class="headerlink" title="Mapper 定义：继承 BaseMapper"></a>Mapper 定义：继承 BaseMapper</h2><pre><code>public interface UserMapper extends BaseMapper&lt;User&gt; {}</code></pre><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><pre><code>@RunWith(SpringRunner.class)@SpringBootTestpublic class MapperTest {    @Autowired    private UserMapper mapper;    @Test    public void insertTest() {        // 1. insert        User user = new User();        user.setName(&quot;小羊&quot;);        user.setAge(3);        user.setEmail(&quot;abc@mp.com&quot;);        assertThat(mapper.insert(user)).isGreaterThan(0);        // 成功直接拿 ID        assertThat(user.getId()).isNotNull();    }    @Test    public void deleteTest() {        // 1. deleteById        assertThat(mapper.deleteById(3L)).isGreaterThan(0);        // 2. delete with queryWrapper        assertThat(mapper.delete(new QueryWrapper&lt;User&gt;()            .lambda().eq(User::getName, &quot;Sandy&quot;))).isGreaterThan(0);    }    @Test    public void updateTest() {        // 1. updateById        assertThat(mapper.updateById(new User().setId(1L).setEmail(&quot;ab@c.c&quot;))).isGreaterThan(0);        // 2. update with entity and updateWrapper        assertThat(            mapper.update(                new User().setName(&quot;mp&quot;),                Wrappers.&lt;User&gt;lambdaUpdate()                    .set(User::getAge, 3)                    .eq(User::getId, 2)            )        ).isGreaterThan(0);        User user = mapper.selectById(2);        assertThat(user.getAge()).isEqualTo(3);        assertThat(user.getName()).isEqualTo(&quot;mp&quot;);        // 3. update with entity and queryWrapper        mapper.update(            new User().setEmail(&quot;miemie@baomidou.com&quot;),            new QueryWrapper&lt;User&gt;()                .lambda().eq(User::getId, 2)        );        user = mapper.selectById(2);        assertThat(user.getEmail()).isEqualTo(&quot;miemie@baomidou.com&quot;);        // 4. update with UpdateWrapper        mapper.update(null, new UpdateWrapper&lt;User&gt;()            .lambda().eq(User::getId, 2).set(User::getAge, 1));        // mapper.update(null, new UpdateWrapper&lt;User&gt;()        //   .eq(&quot;id&quot;, 2).set(&quot;age&quot;, 1));        user = mapper.selectById(2);        assertThat(user.getAge()).isEqualTo(1);    }    @Test    public void selectTest() {        // 1. selectById        assertThat(mapper.selectById(1L)).isNotNull();        // 2. selectOne with QueryWrapper        User user = mapper.selectOne(new QueryWrapper&lt;User&gt;().lambda().eq(User::getId, 1L));        assertThat(user.getAge()).isEqualTo(3);        // 3. selectList with lambdaQuery        mapper.selectList(Wrappers.&lt;User&gt;lambdaQuery().select(User::getId))            .forEach(x -&gt; {                assertThat(x.getId()).isNotNull();            });        // 4. selectList with QueryWrapper        mapper.selectList(new QueryWrapper&lt;User&gt;().select(&quot;id&quot;, &quot;name&quot;))            .forEach(x -&gt; {                assertThat(x.getId()).isNotNull();            });        // 5. selectMaps        List&lt;Map&lt;String, Object&gt;&gt; mapList = mapper.selectMaps(Wrappers.&lt;User&gt;query().orderByAsc(&quot;age&quot;));        assertThat(mapList).isNotEmpty();        assertThat(mapList.get(0)).isNotEmpty();        System.out.println(mapList.get(0));        // 6. selectPage        IPage&lt;User&gt; page = mapper.selectPage(new Page&lt;&gt;(1, 5),            Wrappers.&lt;User&gt;query().orderByAsc(&quot;age&quot;));        assertThat(page).isNotNull();        assertThat(page.getRecords()).isNotEmpty();        System.out.println(page.getRecords().get(0));        // 7. selectMaxId        QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();        wrapper.select(&quot;max(id) as id&quot;);        User userMaxId = mapper.selectOne(wrapper);        System.out.println(&quot;maxId=&quot; + userMaxId.getId());        List&lt;User&gt; users = mapper.selectList(Wrappers.&lt;User&gt;lambdaQuery().orderByDesc(User::getId));        Assert.assertEquals(userMaxId.getId().longValue(), users.get(0).getId().longValue());    }    @Test    public void orderByTest() {        List&lt;User&gt; users = mapper.selectList(Wrappers.&lt;User&gt;query().orderByAsc(&quot;age&quot;));        assertThat(users).isNotEmpty();        List&lt;User&gt; usersLambda = mapper.selectList(Wrappers.&lt;User&gt;lambdaQuery().orderByAsc(User::getAge));        assertThat(usersLambda).isNotEmpty();    }    @Test    public void groupTest() {        QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();        wrapper.select(&quot;age, count(*)&quot;)            .groupBy(&quot;age&quot;);        List&lt;Map&lt;String, Object&gt;&gt; maplist = mapper.selectMaps(wrapper);        for (Map&lt;String, Object&gt; mp : maplist) {            System.out.println(mp);        }        mapper.selectList( new QueryWrapper&lt;User&gt;().lambda()            .select(User::getAge)            .groupBy(User::getAge)            .orderByAsc(User::getAge))            .forEach(System.out::println);    }    // Mybatis-Plus 没有为 join 操作提供增强接口    // 在 userMapper 中定义函数，与 Mybatis 的使用一致    // @Select(&quot;select a.id as addressId, t.id as userId, t.name as userName, a.address as address &quot;    //  + &quot;from t_user t\n&quot;    //  + &quot;join address a on t.address = a.id\n&quot;    //  + &quot;where t.id = #{userId}&quot;)    // UserAddress selectUserAddress(Long userId);    @Test    public void joinTest() {        UserAddress userAddress = mapper.selectUserAddress(7L);        System.out.println(userAddress);    }    // UserAddress 定义    // @Data    // public class UserAddress {    //   Integer addressId;    //   Integer userId;    //   String address;    //   String userName;    // }}</code></pre><h1 id="Service-基本使用"><a href="#Service-基本使用" class="headerlink" title="Service 基本使用"></a>Service 基本使用</h1><h2 id="Service-定义"><a href="#Service-定义" class="headerlink" title="Service 定义"></a>Service 定义</h2><pre><code>public interface UserService extends IService&lt;User&gt; {}@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService {}</code></pre><h2 id="测试用例-1"><a href="#测试用例-1" class="headerlink" title="测试用例"></a>测试用例</h2><pre><code>@RunWith(SpringRunner.class)@SpringBootTestpublic class ServiceTest {    @Autowired    private UserService userService;    @Test    public void saveTest() {        User user = new User();        user.setId(10L);        user.setName(&quot;小羊&quot;);        user.setAge(3);        user.setEmail(&quot;abc@mp.com&quot;);        // 1. save: 相当于 mapper.insert        assertThat(userService.save(user)).isTrue();        // 2. saveOrUpdate: 先根据 id 进行 select，如果存在则 update，否则 insert        assertThat(userService.saveOrUpdate(user)).isTrue();        System.out.println(user);    }    @Test    public void removeTest() {        User user = new User();        user.setName(&quot;miemie&quot;);        // 1. removeById        userService.save(user);        assertTrue(userService.removeById(user.getId()));        // 2. remove with QueryWrapper        userService.save(user);        assertTrue(userService.remove(new QueryWrapper&lt;User&gt;().lambda().eq(User::getId, user.getId())));        // 3. removeByMap        userService.save(user);        Map&lt;String, Object&gt; columnMap = new HashMap&lt;&gt;();        columnMap.put(&quot;id&quot;, user.getId().toString());        assertTrue(userService.removeByMap(columnMap));        // 4. lambdaUpdate        userService.save(user);        assertTrue(userService.lambdaUpdate().eq(User::getId, user.getId()).remove());    }    @Test    public void updateTest(){        // 1. updateById        User user = new User();        user.setId(1L);        user.setName(&quot;mm&quot;);        assertTrue(userService.updateById(user));        // 2. update with updateWrapper        UpdateWrapper&lt;User&gt; updateWrapper = new UpdateWrapper&lt;User&gt;().eq(&quot;id&quot;, 1L).set(&quot;name&quot;, &quot;mm&quot;);        System.out.println(updateWrapper.getCustomSqlSegment());        assertTrue(userService.update(updateWrapper));        // 3. lambdaUpdate        boolean update = userService.lambdaUpdate().eq(User::getAge, 18).set(User::getAge, 31).update();        System.out.println(update);    }    @Test    public void getTest(){        Long userId = 1L;        // 1. getById        User u1 = userService.getById(userId);        assertThat(u1).isNotNull();        // 2. getOne        User u2 = userService.getOne(new QueryWrapper&lt;User&gt;().lambda().eq(User::getId, userId));        assertThat(u2).isNotNull();        assertSame(u1.getId(), u2.getId());        // 3. getList        List&lt;User&gt; list1 = userService.list(new QueryWrapper&lt;User&gt;().lambda().eq(User::getId, userId));        assertThat(list1.isEmpty()).isFalse();        // 4. lambdaQuery        List&lt;User&gt; list = userService.lambdaQuery().eq(User::getId, userId).list();        list.forEach(System.out::println);    }}</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MybatisPlus教程&lt;/p&gt;
    
    </summary>
    
      <category term="2020年4月" scheme="http://yoursite.com/categories/2020%E5%B9%B44%E6%9C%88/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>设计模式学习笔记V-策略模式</title>
    <link href="http://yoursite.com/2020/04/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0V-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/04/13/设计模式学习笔记V-策略模式/</id>
    <published>2020-04-13T09:30:12.000Z</published>
    <updated>2020-04-23T02:04:37.538Z</updated>
    
    <content type="html"><![CDATA[<p>策略模式（Strategy Pattern）</p><a id="more"></a><h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。</p><p>在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。</p><p>主要解决：在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。</p><p>何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。</p><p>如何解决：将这些算法封装成一个一个的类，任意地替换。</p><p>关键代码：实现同一个接口。</p><p>应用实例： 1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 3、JAVA AWT 中的 LayoutManager。</p><p>优点： 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。</p><p>缺点： 1、策略类会增多。 2、所有策略类都需要对外暴露。</p><p>使用场景： 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</p><p>注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>我们将创建一个定义活动的 Strategy 接口和实现了 Strategy 接口的实体策略类。Context 是一个使用了某种策略的类。</p><p>StrategyPatternDemo，我们的演示类使用 Context 和策略对象来演示 Context 在它所配置或使用的策略改变时的行为变化。</p><h2 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h2><p>创建一个接口。</p><pre><code>Strategy.javapublic interface Strategy {   public int doOperation(int num1, int num2);}</code></pre><h2 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h2><p>创建实现接口的实体类。</p><pre><code>OperationAdd.javapublic class OperationAdd implements Strategy{   @Override   public int doOperation(int num1, int num2) {      return num1 + num2;   }}OperationSubstract.javapublic class OperationSubstract implements Strategy{   @Override   public int doOperation(int num1, int num2) {      return num1 - num2;   }}OperationMultiply.javapublic class OperationMultiply implements Strategy{   @Override   public int doOperation(int num1, int num2) {      return num1 * num2;   }}</code></pre><h2 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a>步骤 3</h2><p>创建 Context 类。</p><pre><code>Context.javapublic class Context {   private Strategy strategy;   public Context(Strategy strategy){      this.strategy = strategy;   }   public int executeStrategy(int num1, int num2){      return strategy.doOperation(num1, num2);   }}</code></pre><h2 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤 4"></a>步骤 4</h2><p>使用 Context 来查看当它改变策略 Strategy 时的行为变化。</p><pre><code>StrategyPatternDemo.javapublic class StrategyPatternDemo {   public static void main(String[] args) {      Context context = new Context(new OperationAdd());          System.out.println(&quot;10 + 5 = &quot; + context.executeStrategy(10, 5));      context = new Context(new OperationSubstract());            System.out.println(&quot;10 - 5 = &quot; + context.executeStrategy(10, 5));      context = new Context(new OperationMultiply());          System.out.println(&quot;10 * 5 = &quot; + context.executeStrategy(10, 5));   }}</code></pre><h2 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤 5"></a>步骤 5</h2><p>执行程序，输出结果：</p><pre><code>10 + 5 = 1510 - 5 = 510 * 5 = 50</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="https://www.runoob.com/design-pattern/strategy-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/strategy-pattern.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;策略模式（Strategy Pattern）&lt;/p&gt;
    
    </summary>
    
      <category term="2020年4月" scheme="http://yoursite.com/categories/2020%E5%B9%B44%E6%9C%88/"/>
    
    
      <category term="Design Pattern，Java" scheme="http://yoursite.com/tags/Design-Pattern%EF%BC%8CJava/"/>
    
  </entry>
  
  <entry>
    <title>1046. 最后一块石头的重量</title>
    <link href="http://yoursite.com/2020/02/16/1046.%20%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F/"/>
    <id>http://yoursite.com/2020/02/16/1046. 最后一块石头的重量/</id>
    <published>2020-02-16T09:51:12.000Z</published>
    <updated>2020-02-16T09:55:55.982Z</updated>
    
    <content type="html"><![CDATA[<p>过完年后在家办公已经两周，好久没更新博客了，最近做的大多是easy难度的题聊以消遣，这道easy主要练习了下队列和比较函数，也可以用堆来解决。</p><a id="more"></a><p>有一堆石头，每块石头的重量都是正整数。</p><p>每一回合，从中选出两块最重的石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下：</p><p>如果 x == y，那么两块石头都会被完全粉碎；<br>如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。<br>最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。</p><p>提示：</p><p>1 &lt;= stones.length &lt;= 30<br>1 &lt;= stones[i] &lt;= 1000</p><pre><code>class Solution {    public int lastStoneWeight(int[] stones) {        /* 使用优先对列保证每次能拿到最大的数 */        Queue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(new Comparator&lt;Integer&gt;() {            @Override            public int compare(Integer o1, Integer o2) {                return (o2 - o1);            }        });        for (int i = 0; i &lt; stones.length; i++) {            queue.offer(stones[i]);        }        while(queue.size() &gt; 1) {            int x = queue.poll();            int y = queue.poll();            int diff = Math.abs(x - y);            if (diff != 0) {                queue.offer(diff);            }        }        if (queue.isEmpty()) return 0;        return queue.peek();    }}</code></pre><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】：<a href="https://leetcode-cn.com/problems/last-stone-weight/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/last-stone-weight/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;过完年后在家办公已经两周，好久没更新博客了，最近做的大多是easy难度的题聊以消遣，这道easy主要练习了下队列和比较函数，也可以用堆来解决。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年2月" scheme="http://yoursite.com/categories/2020%E5%B9%B42%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="heap" scheme="http://yoursite.com/tags/heap/"/>
    
  </entry>
  
</feed>
