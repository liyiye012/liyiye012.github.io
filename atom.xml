<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-17T03:11:43.354Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot学习笔记VIII-MybatisPlus教程</title>
    <link href="http://yoursite.com/2020/04/17/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0VIII-MybatisPlus%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/04/17/SpringBoot学习笔记VIII-MybatisPlus教程/</id>
    <published>2020-04-17T02:12:12.000Z</published>
    <updated>2020-04-17T03:11:43.354Z</updated>
    
    <content type="html"><![CDATA[<p>MybatisPlus教程</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>官网地址：<a href="https://mybatis.plus/" target="_blank" rel="noopener">https://mybatis.plus/</a></p><p>官网简介：MyBatis-Plus 是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p><p>下面介绍如何快速上手 mybatis-plus，给出了 mapper 和 service CRUD 的基本示例。</p><p>建议在后续开发中，时时翻看官方文档（<a href="https://mybatis.plus/guide）。" target="_blank" rel="noopener">https://mybatis.plus/guide）。</a></p><h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><pre><code>&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><h2 id="MapperScan-配置"><a href="#MapperScan-配置" class="headerlink" title="MapperScan 配置"></a>MapperScan 配置</h2><pre><code>@SpringBootApplication@MapperScan(&quot;com.xx.xx.xx.mapper&quot;)public class Application {    public static void main(String[] args) {        SpringApplication.run(Application.class, args);    }}</code></pre><h1 id="Mapper-基本使用"><a href="#Mapper-基本使用" class="headerlink" title="Mapper 基本使用"></a>Mapper 基本使用</h1><h2 id="Entity-定义"><a href="#Entity-定义" class="headerlink" title="Entity 定义"></a>Entity 定义</h2><pre><code>@Data@Accessors(chain = true)@TableName(&quot;t_user&quot;) // 表名，默认是类名转下划线public class User {    // 指定主键，IdType.AUTO 表示自增主键    @TableId(type= IdType.AUTO)    private Long id;    private String name;    private Integer age;    private String email;    private Integer address;    // 不在数据库里的字段    @TableField(exist = false)    private Integer count;}</code></pre><h2 id="Mapper-定义：继承-BaseMapper"><a href="#Mapper-定义：继承-BaseMapper" class="headerlink" title="Mapper 定义：继承 BaseMapper"></a>Mapper 定义：继承 BaseMapper</h2><pre><code>public interface UserMapper extends BaseMapper&lt;User&gt; {}</code></pre><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><pre><code>@RunWith(SpringRunner.class)@SpringBootTestpublic class MapperTest {    @Autowired    private UserMapper mapper;    @Test    public void insertTest() {        // 1. insert        User user = new User();        user.setName(&quot;小羊&quot;);        user.setAge(3);        user.setEmail(&quot;abc@mp.com&quot;);        assertThat(mapper.insert(user)).isGreaterThan(0);        // 成功直接拿 ID        assertThat(user.getId()).isNotNull();    }    @Test    public void deleteTest() {        // 1. deleteById        assertThat(mapper.deleteById(3L)).isGreaterThan(0);        // 2. delete with queryWrapper        assertThat(mapper.delete(new QueryWrapper&lt;User&gt;()            .lambda().eq(User::getName, &quot;Sandy&quot;))).isGreaterThan(0);    }    @Test    public void updateTest() {        // 1. updateById        assertThat(mapper.updateById(new User().setId(1L).setEmail(&quot;ab@c.c&quot;))).isGreaterThan(0);        // 2. update with entity and updateWrapper        assertThat(            mapper.update(                new User().setName(&quot;mp&quot;),                Wrappers.&lt;User&gt;lambdaUpdate()                    .set(User::getAge, 3)                    .eq(User::getId, 2)            )        ).isGreaterThan(0);        User user = mapper.selectById(2);        assertThat(user.getAge()).isEqualTo(3);        assertThat(user.getName()).isEqualTo(&quot;mp&quot;);        // 3. update with entity and queryWrapper        mapper.update(            new User().setEmail(&quot;miemie@baomidou.com&quot;),            new QueryWrapper&lt;User&gt;()                .lambda().eq(User::getId, 2)        );        user = mapper.selectById(2);        assertThat(user.getEmail()).isEqualTo(&quot;miemie@baomidou.com&quot;);        // 4. update with UpdateWrapper        mapper.update(null, new UpdateWrapper&lt;User&gt;()            .lambda().eq(User::getId, 2).set(User::getAge, 1));        // mapper.update(null, new UpdateWrapper&lt;User&gt;()        //   .eq(&quot;id&quot;, 2).set(&quot;age&quot;, 1));        user = mapper.selectById(2);        assertThat(user.getAge()).isEqualTo(1);    }    @Test    public void selectTest() {        // 1. selectById        assertThat(mapper.selectById(1L)).isNotNull();        // 2. selectOne with QueryWrapper        User user = mapper.selectOne(new QueryWrapper&lt;User&gt;().lambda().eq(User::getId, 1L));        assertThat(user.getAge()).isEqualTo(3);        // 3. selectList with lambdaQuery        mapper.selectList(Wrappers.&lt;User&gt;lambdaQuery().select(User::getId))            .forEach(x -&gt; {                assertThat(x.getId()).isNotNull();            });        // 4. selectList with QueryWrapper        mapper.selectList(new QueryWrapper&lt;User&gt;().select(&quot;id&quot;, &quot;name&quot;))            .forEach(x -&gt; {                assertThat(x.getId()).isNotNull();            });        // 5. selectMaps        List&lt;Map&lt;String, Object&gt;&gt; mapList = mapper.selectMaps(Wrappers.&lt;User&gt;query().orderByAsc(&quot;age&quot;));        assertThat(mapList).isNotEmpty();        assertThat(mapList.get(0)).isNotEmpty();        System.out.println(mapList.get(0));        // 6. selectPage        IPage&lt;User&gt; page = mapper.selectPage(new Page&lt;&gt;(1, 5),            Wrappers.&lt;User&gt;query().orderByAsc(&quot;age&quot;));        assertThat(page).isNotNull();        assertThat(page.getRecords()).isNotEmpty();        System.out.println(page.getRecords().get(0));        // 7. selectMaxId        QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();        wrapper.select(&quot;max(id) as id&quot;);        User userMaxId = mapper.selectOne(wrapper);        System.out.println(&quot;maxId=&quot; + userMaxId.getId());        List&lt;User&gt; users = mapper.selectList(Wrappers.&lt;User&gt;lambdaQuery().orderByDesc(User::getId));        Assert.assertEquals(userMaxId.getId().longValue(), users.get(0).getId().longValue());    }    @Test    public void orderByTest() {        List&lt;User&gt; users = mapper.selectList(Wrappers.&lt;User&gt;query().orderByAsc(&quot;age&quot;));        assertThat(users).isNotEmpty();        List&lt;User&gt; usersLambda = mapper.selectList(Wrappers.&lt;User&gt;lambdaQuery().orderByAsc(User::getAge));        assertThat(usersLambda).isNotEmpty();    }    @Test    public void groupTest() {        QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();        wrapper.select(&quot;age, count(*)&quot;)            .groupBy(&quot;age&quot;);        List&lt;Map&lt;String, Object&gt;&gt; maplist = mapper.selectMaps(wrapper);        for (Map&lt;String, Object&gt; mp : maplist) {            System.out.println(mp);        }        mapper.selectList( new QueryWrapper&lt;User&gt;().lambda()            .select(User::getAge)            .groupBy(User::getAge)            .orderByAsc(User::getAge))            .forEach(System.out::println);    }    // Mybatis-Plus 没有为 join 操作提供增强接口    // 在 userMapper 中定义函数，与 Mybatis 的使用一致    // @Select(&quot;select a.id as addressId, t.id as userId, t.name as userName, a.address as address &quot;    //  + &quot;from t_user t\n&quot;    //  + &quot;join address a on t.address = a.id\n&quot;    //  + &quot;where t.id = #{userId}&quot;)    // UserAddress selectUserAddress(Long userId);    @Test    public void joinTest() {        UserAddress userAddress = mapper.selectUserAddress(7L);        System.out.println(userAddress);    }    // UserAddress 定义    // @Data    // public class UserAddress {    //   Integer addressId;    //   Integer userId;    //   String address;    //   String userName;    // }}</code></pre><h1 id="Service-基本使用"><a href="#Service-基本使用" class="headerlink" title="Service 基本使用"></a>Service 基本使用</h1><h2 id="Service-定义"><a href="#Service-定义" class="headerlink" title="Service 定义"></a>Service 定义</h2><pre><code>public interface UserService extends IService&lt;User&gt; {}@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService {}</code></pre><h2 id="测试用例-1"><a href="#测试用例-1" class="headerlink" title="测试用例"></a>测试用例</h2><pre><code>@RunWith(SpringRunner.class)@SpringBootTestpublic class ServiceTest {    @Autowired    private UserService userService;    @Test    public void saveTest() {        User user = new User();        user.setId(10L);        user.setName(&quot;小羊&quot;);        user.setAge(3);        user.setEmail(&quot;abc@mp.com&quot;);        // 1. save: 相当于 mapper.insert        assertThat(userService.save(user)).isTrue();        // 2. saveOrUpdate: 先根据 id 进行 select，如果存在则 update，否则 insert        assertThat(userService.saveOrUpdate(user)).isTrue();        System.out.println(user);    }    @Test    public void removeTest() {        User user = new User();        user.setName(&quot;miemie&quot;);        // 1. removeById        userService.save(user);        assertTrue(userService.removeById(user.getId()));        // 2. remove with QueryWrapper        userService.save(user);        assertTrue(userService.remove(new QueryWrapper&lt;User&gt;().lambda().eq(User::getId, user.getId())));        // 3. removeByMap        userService.save(user);        Map&lt;String, Object&gt; columnMap = new HashMap&lt;&gt;();        columnMap.put(&quot;id&quot;, user.getId().toString());        assertTrue(userService.removeByMap(columnMap));        // 4. lambdaUpdate        userService.save(user);        assertTrue(userService.lambdaUpdate().eq(User::getId, user.getId()).remove());    }    @Test    public void updateTest(){        // 1. updateById        User user = new User();        user.setId(1L);        user.setName(&quot;mm&quot;);        assertTrue(userService.updateById(user));        // 2. update with updateWrapper        UpdateWrapper&lt;User&gt; updateWrapper = new UpdateWrapper&lt;User&gt;().eq(&quot;id&quot;, 1L).set(&quot;name&quot;, &quot;mm&quot;);        System.out.println(updateWrapper.getCustomSqlSegment());        assertTrue(userService.update(updateWrapper));        // 3. lambdaUpdate        boolean update = userService.lambdaUpdate().eq(User::getAge, 18).set(User::getAge, 31).update();        System.out.println(update);    }    @Test    public void getTest(){        Long userId = 1L;        // 1. getById        User u1 = userService.getById(userId);        assertThat(u1).isNotNull();        // 2. getOne        User u2 = userService.getOne(new QueryWrapper&lt;User&gt;().lambda().eq(User::getId, userId));        assertThat(u2).isNotNull();        assertSame(u1.getId(), u2.getId());        // 3. getList        List&lt;User&gt; list1 = userService.list(new QueryWrapper&lt;User&gt;().lambda().eq(User::getId, userId));        assertThat(list1.isEmpty()).isFalse();        // 4. lambdaQuery        List&lt;User&gt; list = userService.lambdaQuery().eq(User::getId, userId).list();        list.forEach(System.out::println);    }}</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MybatisPlus教程&lt;/p&gt;
    
    </summary>
    
      <category term="2020年4月" scheme="http://yoursite.com/categories/2020%E5%B9%B44%E6%9C%88/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>设计模式学习笔记V-策略模式</title>
    <link href="http://yoursite.com/2020/04/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0V-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/04/13/设计模式学习笔记V-策略模式/</id>
    <published>2020-04-13T09:30:12.000Z</published>
    <updated>2020-04-23T02:04:37.538Z</updated>
    
    <content type="html"><![CDATA[<p>策略模式（Strategy Pattern）</p><a id="more"></a><h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。</p><p>在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。</p><p>主要解决：在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。</p><p>何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。</p><p>如何解决：将这些算法封装成一个一个的类，任意地替换。</p><p>关键代码：实现同一个接口。</p><p>应用实例： 1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 3、JAVA AWT 中的 LayoutManager。</p><p>优点： 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。</p><p>缺点： 1、策略类会增多。 2、所有策略类都需要对外暴露。</p><p>使用场景： 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</p><p>注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>我们将创建一个定义活动的 Strategy 接口和实现了 Strategy 接口的实体策略类。Context 是一个使用了某种策略的类。</p><p>StrategyPatternDemo，我们的演示类使用 Context 和策略对象来演示 Context 在它所配置或使用的策略改变时的行为变化。</p><h2 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h2><p>创建一个接口。</p><pre><code>Strategy.javapublic interface Strategy {   public int doOperation(int num1, int num2);}</code></pre><h2 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h2><p>创建实现接口的实体类。</p><pre><code>OperationAdd.javapublic class OperationAdd implements Strategy{   @Override   public int doOperation(int num1, int num2) {      return num1 + num2;   }}OperationSubstract.javapublic class OperationSubstract implements Strategy{   @Override   public int doOperation(int num1, int num2) {      return num1 - num2;   }}OperationMultiply.javapublic class OperationMultiply implements Strategy{   @Override   public int doOperation(int num1, int num2) {      return num1 * num2;   }}</code></pre><h2 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a>步骤 3</h2><p>创建 Context 类。</p><pre><code>Context.javapublic class Context {   private Strategy strategy;   public Context(Strategy strategy){      this.strategy = strategy;   }   public int executeStrategy(int num1, int num2){      return strategy.doOperation(num1, num2);   }}</code></pre><h2 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤 4"></a>步骤 4</h2><p>使用 Context 来查看当它改变策略 Strategy 时的行为变化。</p><pre><code>StrategyPatternDemo.javapublic class StrategyPatternDemo {   public static void main(String[] args) {      Context context = new Context(new OperationAdd());          System.out.println(&quot;10 + 5 = &quot; + context.executeStrategy(10, 5));      context = new Context(new OperationSubstract());            System.out.println(&quot;10 - 5 = &quot; + context.executeStrategy(10, 5));      context = new Context(new OperationMultiply());          System.out.println(&quot;10 * 5 = &quot; + context.executeStrategy(10, 5));   }}</code></pre><h2 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤 5"></a>步骤 5</h2><p>执行程序，输出结果：</p><pre><code>10 + 5 = 1510 - 5 = 510 * 5 = 50</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="https://www.runoob.com/design-pattern/strategy-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/strategy-pattern.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;策略模式（Strategy Pattern）&lt;/p&gt;
    
    </summary>
    
      <category term="2020年4月" scheme="http://yoursite.com/categories/2020%E5%B9%B44%E6%9C%88/"/>
    
    
      <category term="Design Pattern，Java" scheme="http://yoursite.com/tags/Design-Pattern%EF%BC%8CJava/"/>
    
  </entry>
  
  <entry>
    <title>1046. 最后一块石头的重量</title>
    <link href="http://yoursite.com/2020/02/16/1046.%20%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F/"/>
    <id>http://yoursite.com/2020/02/16/1046. 最后一块石头的重量/</id>
    <published>2020-02-16T09:51:12.000Z</published>
    <updated>2020-02-16T09:55:55.982Z</updated>
    
    <content type="html"><![CDATA[<p>过完年后在家办公已经两周，好久没更新博客了，最近做的大多是easy难度的题聊以消遣，这道easy主要练习了下队列和比较函数，也可以用堆来解决。</p><a id="more"></a><p>有一堆石头，每块石头的重量都是正整数。</p><p>每一回合，从中选出两块最重的石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下：</p><p>如果 x == y，那么两块石头都会被完全粉碎；<br>如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。<br>最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。</p><p>提示：</p><p>1 &lt;= stones.length &lt;= 30<br>1 &lt;= stones[i] &lt;= 1000</p><pre><code>class Solution {    public int lastStoneWeight(int[] stones) {        /* 使用优先对列保证每次能拿到最大的数 */        Queue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(new Comparator&lt;Integer&gt;() {            @Override            public int compare(Integer o1, Integer o2) {                return (o2 - o1);            }        });        for (int i = 0; i &lt; stones.length; i++) {            queue.offer(stones[i]);        }        while(queue.size() &gt; 1) {            int x = queue.poll();            int y = queue.poll();            int diff = Math.abs(x - y);            if (diff != 0) {                queue.offer(diff);            }        }        if (queue.isEmpty()) return 0;        return queue.peek();    }}</code></pre><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】：<a href="https://leetcode-cn.com/problems/last-stone-weight/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/last-stone-weight/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;过完年后在家办公已经两周，好久没更新博客了，最近做的大多是easy难度的题聊以消遣，这道easy主要练习了下队列和比较函数，也可以用堆来解决。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年2月" scheme="http://yoursite.com/categories/2020%E5%B9%B42%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="heap" scheme="http://yoursite.com/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记XIV</title>
    <link href="http://yoursite.com/2020/01/24/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0XIV/"/>
    <id>http://yoursite.com/2020/01/24/Java学习笔记XIV/</id>
    <published>2020-01-24T09:34:12.000Z</published>
    <updated>2020-01-24T11:37:52.768Z</updated>
    
    <content type="html"><![CDATA[<p>Java的值传递和引用传递</p><a id="more"></a><p>java中数据类型分为基本数据类型和引用数据类型。</p><p>基本数据类型</p><pre><code>整型：byte，short，int，long浮点型：float，double字符型：char布尔型：boolean</code></pre><p>引用数据类型</p><pre><code>数组类接口</code></pre><p>方法的参数分为实际参数，和形式参数。</p><pre><code>形式参数：定义方法时写的参数。实际参数：调用方法时写的具体数值。</code></pre><p>一般情况下，在数据做为参数传递的时候，<strong><em>基本数据类型是值传递，引用数据类型是引用传递（地址传递）。</em></strong></p><h1 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h1><pre><code>public static void main(String[] args) {    int num1 = 10;    int num2 = 20;    swap(num1, num2);    System.out.println(&quot;num1 = &quot; + num1);    System.out.println(&quot;num2 = &quot; + num2);}public static void swap(int a, int b) {    int temp = a;    a = b;    b = temp;    System.out.println(&quot;a = &quot; + a);    System.out.println(&quot;b = &quot; + b);}</code></pre><p>运行结果：</p><pre><code>a = 20b = 10num1 = 10num2 = 20</code></pre><h2 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h2><p>主函数进栈，num1、num2初始化。<br>调用swap方法，swap( )进栈，将num1和num2的值，复制一份给a和b。<br>swap方法中对a、b的值进行交换。<br>swap方法运行完毕，a、b的值已经交换。<br>swap方法弹栈。<br>主函数弹栈。</p><h2 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h2><p>在swap方法中，a、b的值进行交换，并不会影响到num1、num2。因为，a、b中的值，只是从num1、num2的复制过来的。<br>也就是说，a、b相当于num1、num2的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p><h1 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h1><pre><code>public static void main(String[] args) {    int[] arr = {1,2,3,4,5};    change(arr);    System.out.println(arr[0]);}//将数组的第一个元素变为0public static void change(int[] array) {    int len = array.length;    array[0] = 0;}</code></pre><p>运行结果是：<br>    0</p><h1 id="流程：-1"><a href="#流程：-1" class="headerlink" title="流程："></a>流程：</h1><p>主函数进栈，int[] arr初始化。<br>调用change方法，change( )进栈，将arr的地址值，复制一份给array。<br>change方法中，根据地址值，找到堆中的数组，并将第一个元素的值改为0。<br>change方法运行完毕，数组中第一个元素的值已经改变。<br>change方法弹栈。<br>主函数弹栈。</p><h1 id="解析：-1"><a href="#解析：-1" class="headerlink" title="解析："></a>解析：</h1><p>调用change()的时候，形参array接收的是arr地址值的副本。并在change方法中，通过地址值，对数组进行操作。change方法弹栈以后，数组中的值已经改变。main方法中，打印出来的arr[0]也就从原来的1变成了0.</p><p>无论是主函数，还是change方法，操作的都是同一个地址值对应的数组。<br>就像你把自己家的钥匙给了另一个人，这个人拿着钥匙在你家一顿瞎折腾，然后走了。等你拿着钥匙回到家以后，家里已经变成了被折腾过后，惨不忍睹的样子。。<br>这里的钥匙就相当于地址值，家就相当于数组本身。</p><h1 id="String类型传递"><a href="#String类型传递" class="headerlink" title="String类型传递"></a>String类型传递</h1><pre><code>public static void main(String[] args) {    String str = &quot;AAA&quot;;    change(str);    System.out.println(str);}   public static void change(String s) {    s = &quot;abc&quot;;}</code></pre><p>运行的结果是：</p><pre><code>AAA</code></pre><p>String是一个类，类是引用数据类型，做为参数传递的时候，应该是引用传递。但是从结果看起来却是值传递。</p><h2 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h2><p>String的API中有这么一句话：“their values cannot be changed after they are created”，<br>意思是：String的值在创建之后不能被更改。<br>API中还有一段：<br>String str = “abc”;<br>等效于：</p><pre><code>char data[] = {&apos;a&apos;, &apos;b&apos;, &apos;c&apos;};String str = new String(data);</code></pre><p>也就是说：对String对象str的任何修改 等同于 重新创建一个对象，并将新的地址值赋值给str。</p><p>这样的话，上面的代码就可以写成：</p><pre><code>public static void main(String[] args) {    String str1 = &quot;AAA&quot;;    change(str1);    System.out.println(str1);}   public static void change(String s) {    char data[] = {&apos;a&apos;, &apos;b&apos;, &apos;c&apos;}    String str = new String(data);    s = str;}</code></pre><h2 id="流程：-2"><a href="#流程：-2" class="headerlink" title="流程："></a>流程：</h2><p>主函数进栈，str1初始化。<br>调用change方法，change( )进栈，将str1的地址值，复制一份给s。<br>change方法中，重现创建了一个String对象”abc”，并将s指向了新的地址值。<br>change方法运行完毕，s所指向的地址值已经改变。<br>change方法弹栈。<br>主函数弹栈。</p><h2 id="解析：-2"><a href="#解析：-2" class="headerlink" title="解析："></a>解析：</h2><p>String对象做为参数传递时，走的依然是引用传递，只不过String这个类比较特殊。<br>String对象一旦创建，内容不可更改。每一次内容的更改都是重现创建出来的新对象。<br>当change方法执行完毕时，s所指向的地址值已经改变。而s本来的地址值就是copy过来的副本，所以并不能改变str1的值。</p><h1 id="String类型类似情况："><a href="#String类型类似情况：" class="headerlink" title="String类型类似情况："></a>String类型类似情况：</h1><pre><code>class Person {    String name;    public Person(String name) {        this.name = name;    }}public class Test {    public static void main(String[] args) {        Person p = new Person(&quot;张三&quot;);        change(p);        System.out.println(p.name);    }    public static void change(Person p) {        Person person = new Person(&quot;李四&quot;);        p = person;    }}</code></pre><p>运行的结果是：</p><pre><code>张三</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>值传递的时候，将实参的值，copy一份给形参。<br>引用传递的时候，将实参的地址值，copy一份给形参。<br>也就是说，不管是值传递还是引用传递，形参拿到的仅仅是实参的副本，而不是实参本身。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://blog.csdn.net/zhzhao999/article/details/53449504" target="_blank" rel="noopener">https://blog.csdn.net/zhzhao999/article/details/53449504</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java的值传递和引用传递&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>24.两两交换链表中的节点</title>
    <link href="http://yoursite.com/2020/01/24/257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2020/01/24/257.二叉树的所有路径/</id>
    <published>2020-01-24T09:31:12.000Z</published>
    <updated>2020-01-26T06:34:21.518Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p><a id="more"></a><p>此题主要有递归和迭代两种方式进行深度优先遍历，主要让我感兴趣的是在Java中可以使用List&lt;&gt;进行引用传递，参见笔记《Java学习笔记XIV》或参考资料【2】</p><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>比较容易想到的是递归遍历的解法：<br>在递归遍历二叉树时，需要考虑当前的节点和它的孩子节点。如果当前的节点不是叶子节点，则在当前的路径末尾添加该节点，并递归遍历该节点的每一个孩子节点。如果当前的节点是叶子节点，则在当前的路径末尾添加该节点后，就得到了一条从根节点到叶子节点的路径，可以把该路径加入到答案中。</p><p>最开始写出的答案：</p><pre><code>class Solution {    public List&lt;String&gt; binaryTreePaths(TreeNode root) {        List&lt;String&gt; res=new LinkedList&lt;&gt;();        deepSearch(root,&quot;&quot;,res);        return res;    }    public void deepSearch(TreeNode root,String path,List&lt;String&gt; res) {        if(root.left==null &amp;&amp; root.right==null) {            path=path+Integer.toString(root.val);            res.add(path);            return;        }        if(root.left!=null){            path=path+Integer.toString(root.val)+&quot;-&gt;&quot;;            deepSearch(root.left,path,res);        }        if(root.right!=null){            path=path+Integer.toString(root.val)+&quot;-&gt;&quot;;            deepSearch(root.right,path,res);        }    }}</code></pre><p>但遍历了树[“1-&gt;2-&gt;5”, “1-&gt;3”]发现结果是[“1-&gt;2-&gt;5”, “1-&gt;1-&gt;3”]<br>原因是遍历了左子树后回到根节点发现右子树进入时就已经有上次遗留的path=”1-&gt;”了，因此改为：</p><pre><code>class Solution {    public List&lt;String&gt; binaryTreePaths(TreeNode root) {        List&lt;String&gt; res=new LinkedList&lt;&gt;();        deepSearch(root,&quot;&quot;,res);        return res;    }    public void deepSearch(TreeNode root,String path,List&lt;String&gt; res) {        if(root.left==null &amp;&amp; root.right==null) {            path=path+Integer.toString(root.val);            res.add(path);            return;        }        path=path+Integer.toString(root.val)+&quot;-&gt;&quot;;        if(root.left!=null){            deepSearch(root.left,path,res);        }        if(root.right!=null){            deepSearch(root.right,path,res);        }    }}</code></pre><p>又发现出现了典型的空指针问题，因此加入对空指针的判断就可以通过了，官方题解如下：</p><pre><code>class Solution {    public void construct_paths(TreeNode root, String path, LinkedList&lt;String&gt; paths) {        if (root != null) {            path += Integer.toString(root.val);            if ((root.left == null) &amp;&amp; (root.right == null))  // 当前节点是叶子节点                paths.add(path);  // 把路径加入到答案中            else {                path += &quot;-&gt;&quot;;  // 当前节点不是叶子节点，继续递归遍历                construct_paths(root.left, path, paths);                construct_paths(root.right, path, paths);            }        }    }    public List&lt;String&gt; binaryTreePaths(TreeNode root) {        LinkedList&lt;String&gt; paths = new LinkedList();        construct_paths(root, &quot;&quot;, paths);        return paths;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：每个节点只会被访问一次，因此时间复杂度为 O(N)，其中 N 表示节点数目。<br>空间复杂度：O(N)。这里不考虑存储答案 paths 使用的空间，仅考虑额外的空间复杂度。额外的空间复杂度为递归时使用的栈空间，在最坏情况下，当二叉树中每个节点只有一个孩子节点时，递归的层数为 N，此时空间复杂度为 O(N)。在最好情况下，当二叉树为平衡二叉树时，它的高度为 log(N)，此时空间复杂度为O(log(N))。</p><h1 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h1><p>上面的算法也可以使用迭代（宽度优先搜索）的方法实现。我们维护一个队列，存储节点以及根到该节点的路径。一开始这个队列里只有根节点。在每一步迭代中，我们取出队列中的首节点，如果它是一个叶子节点，则将它对应的路径加入到答案中。如果它不是一个叶子节点，则将它的所有孩子节点加入到队列的末尾。当队列为空时，迭代结束。</p><pre><code>class Solution {    public List&lt;String&gt; binaryTreePaths(TreeNode root) {        LinkedList&lt;String&gt; paths = new LinkedList();        if (root == null)            return paths;        LinkedList&lt;TreeNode&gt; node_stack = new LinkedList();        LinkedList&lt;String&gt; path_stack = new LinkedList();        node_stack.add(root);        path_stack.add(Integer.toString(root.val));        TreeNode node;        String path;        while (!node_stack.isEmpty()) {            node = node_stack.pollLast();            path = path_stack.pollLast();            if ((node.left == null) &amp;&amp; (node.right == null))                paths.add(path);            if (node.left != null) {                node_stack.add(node.left);                path_stack.add(path + &quot;-&gt;&quot; + Integer.toString(node.left.val));            }            if (node.right != null) {                node_stack.add(node.right);                path_stack.add(path + &quot;-&gt;&quot; + Integer.toString(node.right.val));            }        }        return paths;    }}</code></pre><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(N)，每个节点只会被访问一次。<br>空间复杂度：O(N)，在最坏情况下，队列中有 N 个节点。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://leetcode-cn.com/problems/binary-tree-paths/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-paths/</a><br>【2】<a href="https://blog.csdn.net/zhzhao999/article/details/53449504" target="_blank" rel="noopener">https://blog.csdn.net/zhzhao999/article/details/53449504</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个二叉树，返回所有从根节点到叶子节点的路径。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="BinaryTree" scheme="http://yoursite.com/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>24.两两交换链表中的节点</title>
    <link href="http://yoursite.com/2020/01/22/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>http://yoursite.com/2020/01/22/24.两两交换链表中的节点/</id>
    <published>2020-01-22T06:32:12.000Z</published>
    <updated>2020-01-22T06:38:13.500Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表</p><a id="more"></a><p>此题有递归和迭代两种方法，我在做的时候首先想到的是用迭代的方法。但是在返回哪个结点时出了问题。调试了很久。看官方题解<br><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/liang-liang-jiao-huan-lian-biao-zhong-de-jie-di-19/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/liang-liang-jiao-huan-lian-biao-zhong-de-jie-di-19/</a><br>也没有弄清楚dummy结点下个结点为什么会准确的指向交换后的链表头而不是跟着交换移动。<br>看了<br><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/bi-jiao-zhi-jie-gao-xiao-de-zuo-fa-han-tu-jie-by-w/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/bi-jiao-zhi-jie-gao-xiao-de-zuo-fa-han-tu-jie-by-w/</a><br>这个题解中的图解才算搞清楚了，建议再做的时候还是在不看题解的情况下写一次。</p><p>顺便推荐IDEA中的leetcode-editor插件，这个插件现在已经可以在中文版leetcode上无缝对接使用了。适合在一些场景下做leetcode。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个链表，两两交换其中相邻的节点，并返回交换后的链表&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="LinkList" scheme="http://yoursite.com/tags/LinkList/"/>
    
  </entry>
  
  <entry>
    <title>微信公众平台开发学习笔记I</title>
    <link href="http://yoursite.com/2020/01/20/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0I/"/>
    <id>http://yoursite.com/2020/01/20/微信公众平台开发学习笔记I/</id>
    <published>2020-01-20T07:18:12.000Z</published>
    <updated>2020-01-20T07:26:49.762Z</updated>
    
    <content type="html"><![CDATA[<p>在测试号中配置接口URL和Token遇到的问题及解决方法</p><a id="more"></a><h1 id="在测试号中配置接口URL和Token"><a href="#在测试号中配置接口URL和Token" class="headerlink" title="在测试号中配置接口URL和Token"></a>在测试号中配置接口URL和Token</h1><p>使用ngrok穿透工具为本地生成对外的网址：<br><a href="https://dashboard.ngrok.com/get-started" target="_blank" rel="noopener">https://dashboard.ngrok.com/get-started</a><br>注册后得到与本账户绑定的authtoken</p><pre><code>./ngrok authtoken 1WNVahHoiVcDG9Hr6c4E86yQpbA_eX526mPNsmsXBkMnLLs6</code></pre><p>启动HTTP隧道</p><pre><code>./ngrok http 80</code></pre><p>这条命令的意思是将本地80端口对应的服务暴露到外网中。<br>显示界面：</p><pre><code>Session Status   online                                       Account          Yiye Li (Plan: Free)                                 Version          2.3.35                             Region            United States(us)                                   Web Interface     http://127.0.0.1:4040                                             Forwarding   http://e5d20d55.ngrok.io -&gt; http://localhost:80                 Forwarding   https://e5d20d55.ngrok.io -&gt; http://localhost:80    Connections  ttl   opn   rt1   rt5   p50   p90                                      0       0       0.00    0.00    0.00    0.00  </code></pre><p>第一个是http协议对应的外网地址，第二个是https协议对应的外网地址。这样，凡是访问<a href="http://e5d20d55.ngrok.io的请求都将发送到localhost:80。不付费的话每次启动ngrok都会分配一个新的外网域名，所以需要每次更换配置或者更换访问地址。" target="_blank" rel="noopener">http://e5d20d55.ngrok.io的请求都将发送到localhost:80。不付费的话每次启动ngrok都会分配一个新的外网域名，所以需要每次更换配置或者更换访问地址。</a></p><p>然后在<a href="https://mp.weixin.qq.com/debug/cgi-bin/sandboxinfo?action=showinfo&amp;t=sandbox/index中输入https://e5d20d55.ngrok.io和token，token从本地项目的applicaiton.yml中获取。" target="_blank" rel="noopener">https://mp.weixin.qq.com/debug/cgi-bin/sandboxinfo?action=showinfo&amp;t=sandbox/index中输入https://e5d20d55.ngrok.io和token，token从本地项目的applicaiton.yml中获取。</a><br>但这时提交会发现配置失败，而且查看本地运行日志没有记录，原因是本地项目的端口号为9006，而URL是本地80端口对应的服务暴露到外网中，因此重新运行</p><pre><code>./ngrok http 9006</code></pre><p>然后提交改正后的本地映射地址,结果发现又失败了，原来是本地响应微信发送的token验证接口有url后缀，所以重新生成时要加上对应接口的后缀,例如新生成的是<a href="http://c6e2a3bf.ngrok.io，则填http://c6e2a3bf.ngrok.io/wechat,另外本地同时要启动项目才能校验。至此就可以成功提交。" target="_blank" rel="noopener">http://c6e2a3bf.ngrok.io，则填http://c6e2a3bf.ngrok.io/wechat,另外本地同时要启动项目才能校验。至此就可以成功提交。</a></p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login" target="_blank" rel="noopener">https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login</a><br>【2】<a href="https://mp.weixin.qq.com/debug/" target="_blank" rel="noopener">https://mp.weixin.qq.com/debug/</a><br>【3】<a href="https://developers.weixin.qq.com/doc/offiaccount/Getting_Started/Overview.html" target="_blank" rel="noopener">https://developers.weixin.qq.com/doc/offiaccount/Getting_Started/Overview.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在测试号中配置接口URL和Token遇到的问题及解决方法&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Wechat" scheme="http://yoursite.com/tags/Wechat/"/>
    
  </entry>
  
  <entry>
    <title>601.Human Traffic of Stadium体育馆的人流量</title>
    <link href="http://yoursite.com/2020/01/20/601.Human%20Traffic%20of%20Stadium%E4%BD%93%E8%82%B2%E9%A6%86%E7%9A%84%E4%BA%BA%E6%B5%81%E9%87%8F/"/>
    <id>http://yoursite.com/2020/01/20/601.Human Traffic of Stadium体育馆的人流量/</id>
    <published>2020-01-20T06:10:12.000Z</published>
    <updated>2020-01-20T06:44:43.836Z</updated>
    
    <content type="html"><![CDATA[<p>查询连续递增的序列</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h1><p>在表 stadium 中查询人流量超过 100 的记录，将查询结果与其自身的临时表连接，再使用 WHERE 子句获得满足条件的记录。</p><p>第一步：查询人流量超过 100 的记录，然后将结果与其自身的临时表连接。<br>MySQL</p><pre><code>select distinct t1.*from stadium t1, stadium t2, stadium t3where t1.people &gt;= 100 and t2.people &gt;= 100 and t3.people &gt;= 100;</code></pre><p>共有 6 天人流量超过 100 人，笛卡尔积 后有 216（666） 条记录。</p><p>前 3 列来自表 t1，中间 3 列来自表 t2，最后 3 列来自表 t3。</p><p>表 t1，t2 和 t3 相同，需要考虑添加哪些条件能够得到想要的结果。以 t1 为例，它有可能是高峰期的第 1 天，第 2 天，或第 3 天。</p><p>t1 是高峰期第 1 天：</p><pre><code>(t1.id - t2.id = -1 and t1.id - t3.id = -2 and t2.id - t3.id =-1) -- t1, t2, t3</code></pre><p>t1 是高峰期第 2 天：</p><pre><code>(t2.id - t1.id = -1 and t2.id - t3.id = -2 and t1.id - t3.id =-1) -- t2, t1, t3</code></pre><p>t1 是高峰期第 3 天：</p><pre><code>(t3.id - t2.id = -1 and t2.id - t1.id =-1 and t3.id - t1.id = -2) -- t3, t2, t1</code></pre><p>因此：</p><pre><code>select t1.*from stadium t1, stadium t2, stadium t3where t1.people &gt;= 100 and t2.people &gt;= 100 and t3.people &gt;= 100and(  (t1.id - t2.id = -1 and t1.id - t3.id = -2 and t2.id - t3.id =-1)  -- t1, t2, t3  or  (t2.id - t1.id = -1 and t2.id - t3.id = -2 and t1.id - t3.id =-1) -- t2, t1, t3  or  (t3.id - t2.id = -1 and t2.id - t1.id =-1 and t3.id - t1.id = -2) -- t3, t2, t1);| id | date       | people ||----|------------|--------|| 7  | 2017-01-07 | 199    || 6  | 2017-01-06 | 1455   || 8  | 2017-01-08 | 188    || 7  | 2017-01-07 | 199    || 5  | 2017-01-05 | 145    || 6  | 2017-01-06 | 1455   |</code></pre><p>可以看到查询结果中存在重复的记录，再使用 DISTINCT 去重。</p><pre><code>select distinct t1.*from stadium t1, stadium t2, stadium t3where t1.people &gt;= 100 and t2.people &gt;= 100 and t3.people &gt;= 100and(      (t1.id - t2.id = -1 and t1.id - t3.id = -2 and t2.id - t3.id =-1)  -- t1, t2, t3    or    (t2.id - t1.id = -1 and t2.id - t3.id = -2 and t1.id - t3.id =-1) -- t2, t1, t3    or    (t3.id - t2.id = -1 and t2.id - t1.id =-1 and t3.id - t1.id = -2) -- t3, t2, t1)order by t1.id;</code></pre><p>此题官方题解貌似把t1,t2,t3的id前后顺序搞反了，不过也不影响执行结果。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://leetcode.com/problems/human-traffic-of-stadium/" target="_blank" rel="noopener">https://leetcode.com/problems/human-traffic-of-stadium/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;查询连续递增的序列&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Database" scheme="http://yoursite.com/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>185.Department Top Three Salaries</title>
    <link href="http://yoursite.com/2020/01/20/185.Department%20Top%20Three%20Salaries/"/>
    <id>http://yoursite.com/2020/01/20/185.Department Top Three Salaries/</id>
    <published>2020-01-20T03:00:12.000Z</published>
    <updated>2020-01-20T06:11:12.950Z</updated>
    
    <content type="html"><![CDATA[<p>查询部门的薪酬前三高员工</p><a id="more"></a><h1 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h1><p>同184，只是本次查询的是薪酬前三高的员工，允许并列</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>首先参考之前的思路，先来查询中公司中占前三高的薪酬是多少,前三高意味着不超过三个比它的薪酬高：</p><pre><code>select e1.Name as &apos;Employee&apos;, e1.Salaryfrom Employee e1where 3 &gt;(    select count(distinct e2.Salary)    from Employee e2    where e2.Salary &gt; e1.Salary);</code></pre><p>查询结果：</p><pre><code>| Employee | Salary ||----------|--------|| Henry    | 80000  || Max      | 90000  || Randy    | 85000  |</code></pre><p>现在我们需要把员工和部门两张表连接起来：</p><p>MySQL：</p><pre><code>SELECT    d.Name AS &apos;Department&apos;, e1.Name AS &apos;Employee&apos;, e1.SalaryFROM    Employee e1        JOIN    Department d ON e1.DepartmentId = d.IdWHERE    3 &gt; (SELECT            COUNT(DISTINCT e2.Salary)        FROM            Employee e2        WHERE            e2.Salary &gt; e1.Salary                AND e1.DepartmentId = e2.DepartmentId        );</code></pre><p>即可查询到部门的薪酬前三高员工</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://leetcode.com/problems/department-top-three-salaries/" target="_blank" rel="noopener">https://leetcode.com/problems/department-top-three-salaries/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;查询部门的薪酬前三高员工&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Database" scheme="http://yoursite.com/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>数据库学习笔记IX</title>
    <link href="http://yoursite.com/2020/01/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0IX/"/>
    <id>http://yoursite.com/2020/01/19/数据库学习笔记IX/</id>
    <published>2020-01-19T09:51:12.000Z</published>
    <updated>2020-01-20T02:48:34.345Z</updated>
    
    <content type="html"><![CDATA[<p>rank，row_number，dense_rank，ntile函数的用法  </p><a id="more"></a><h1 id="rank函数"><a href="#rank函数" class="headerlink" title="rank函数"></a>rank函数</h1><p>　　rank函数用于返回结果集的分区内每行的排名， 行的排名是相关行之前的排名数加一。简单来说rank函数就是对查询出来的记录进行排名，与row_number函数不同的是，rank函数考虑到了over子句中排序字段值相同的情况，如果使用rank函数来生成序号，over子句中排序字段值相同的序号是一样的，后面字段值不相同的序号将跳过相同的排名号排下一个，也就是相关行之前的排名数加一，可以理解为根据当前的记录数生成序号，后面的记录依此类推。</p><pre><code>select * ,RANK() OVER(order by column_name) as rankfrom table_name</code></pre><p>练习题目：<a href="https://leetcode.com/problems/rank-scores/" target="_blank" rel="noopener">https://leetcode.com/problems/rank-scores/</a></p><h2 id="rank函数进行分组"><a href="#rank函数进行分组" class="headerlink" title="rank函数进行分组"></a>rank函数进行分组</h2><pre><code>a           b           c----------- ----------- ----1           3           E2           4           A3           2           D3           5           B4           2           C2           4           B</code></pre><p>以a,b进行分组，在每个组内以b进行排名。分了5个组，第2行跟第3行是一个组，其他的每行是一个组。在第2行与第3行的组内以b排名，并列为1</p><pre><code>SELECT * ,rank () OVER (PARTITION BY a,b ORDER BY b) rank FROM table_namea           b           c    rank----------- ----------- ---- --------------------1           3           E    12           4           A    12           4           B    13           2           D    13           5           B    14           2           C    1</code></pre><p>以a,b进行分组，在每个组内以c进行排名。分了5个组，第2行跟第3行是一个组，其他的每行是一个组。在第2行与第3行的组内以c排名，由于c列一个是A，一个是B，所以Rank分别为1、2。</p><pre><code>SELECT * ,rank () OVER (PARTITION BY a,b ORDER BY c) rank FROM table_namea           b           c    rank----------- ----------- ---- --------------------1           3           E    12           4           A    12           4           B    23           2           D    13           5           B    14           2           C    1</code></pre><p>总结：<br>1、partition  by用于给结果集分组，如果没有指定那么它把整个结果集作为一个分组。</p><p>2、Rank 是在每个分组内部进行排名的。</p><h2 id="在MySQL中实现Rank函数"><a href="#在MySQL中实现Rank函数" class="headerlink" title="在MySQL中实现Rank函数"></a>在MySQL中实现Rank函数</h2><p>在MySQL中没有rank函数，所以我们要自己用普通的查询语句来实现排序功能。这部分可以参见参考资料【2】：《在MySQL中实现Rank高级排名函数》</p><h1 id="row-number函数"><a href="#row-number函数" class="headerlink" title="row_number函数"></a>row_number函数</h1><p>　　row_number的用途的非常广泛，一般可以用来实现web程序的分页，为查询出来的每一行记录生成一个序号，依次排序且不会重复，注意使用row_number函数时必须要用over子句选择对某一列进行排序才能生成序号。row_number用法实例:</p><pre><code>select ROW_NUMBER()OVER(order by column_name desc) as row_num,* from table_name</code></pre><h1 id="dense-rank函数"><a href="#dense-rank函数" class="headerlink" title="dense_rank函数"></a>dense_rank函数</h1><p>　　dense_rank函数的功能与rank函数类似，dense_rank函数在生成序号时是连续的，而rank函数生成的序号有可能不连续。dense_rank函数出现相同排名时，将不跳过相同排名号，rank值紧接上一次的rank值。在各个分组内，rank()是跳跃排序，有两个第一名时接下来就是第四名，dense_rank()是连续排序，有两个第一名时仍然跟着第二名。将上面的Sql语句改由dense_rank函数来实现。</p><pre><code>select * ,DENSE_RANK() OVER(order by column_name) as den_rankfrom table_name</code></pre><h1 id="ntile函数"><a href="#ntile函数" class="headerlink" title="ntile函数"></a>ntile函数</h1><p>　　ntile函数可以对序号进行分组处理，将有序分区中的行分发到指定数目的组中。 各个组有编号，编号从一开始。 对于每一个行，ntile 将返回此行所属的组的编号。这就相当于将查询出来的记录集放到指定长度的数组中，每一个数组元素存放一定数量的记录。ntile函数为每条记录生成的序号就是这条记录所有的数组元素的索引（从1开始）。也可以将每一个分配记录的数组元素称为“桶”。ntile函数有一个参数，用来指定桶数。下面的SQL语句使用ntile函数对Order表进行了装桶处理：</p><pre><code>select * ,NTILE(4) OVER(order by column_name) as ntilefrom table_name</code></pre><p>　　如果表的总记录数是6条，而上面的Sql语句ntile函数指定的组数是4，那么Sql Server2005是怎么来决定每一组应该分多少条记录呢？这里我们就需要了解ntile函数的分组依据（约定）。</p><p>　　ntile函数的分组依据（约定）：</p><p>　　1、每组的记录数不能大于它上一组的记录数，即编号小的桶放的记录数不能小于编号大的桶。也就是说，第1组中的记录数只能大于等于第2组及以后各组中的记录数。</p><p>　　2、所有组中的记录数要么都相同，要么从某一个记录较少的组（命名为X）开始后面所有组的记录数都与该组（X组）的记录数相同。也就是说，如果有个组，前三组的记录数都是9，而第四组的记录数是8，那么第五组和第六组的记录数也必须是8。</p><p>　　这里对约定2进行详细说明一下，以便于更好的理解。</p><p>　　首先系统会去检查能不能对所有满足条件的记录进行平均分组，若能则直接平均分配就完成分组了；若不能，则会先分出一个组，这个组分多少条记录呢？就是 （总记录数/总组数）+1 条，之所以分配 （总记录数/总组数）+1 条是因为当不能进行平均分组时，总记录数%总组数肯定是有余的，又因为分组约定1，所以先分出去的组需要+1条。</p><p>　　分完之后系统会继续去比较余下的记录数和未分配的组数能不能进行平均分配，若能，则平均分配余下的记录；若不能，则再分出去一组，这个组的记录数也是（总记录数/总组数）+1条。</p><p>　　然后系统继续去比较余下的记录数和未分配的组数能不能进行平均分配，若能，则平均分配余下的记录；若还是不能，则再分配出去一组，继续比较余下的……这样一直进行下去，直至分组完成。</p><p>　　举个例子，将51条记录分配成5组，51%5==1不能平均分配，则先分出去一组（51/5）+1=11条记录，然后比较余下的 51-11=40 条记录能否平均分配给未分配的4组，能平均分配，则剩下的4组，每组各40/4=10 条记录，分配完成，分配结果为：11，10，10，10，10</p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>   在使用排名函数的时候需要注意以下三点：</p><p>　　1、排名函数必须有 OVER 子句。</p><p>　　2、排名函数必须有包含 ORDER BY 的 OVER 子句。</p><p>　　3、分组内从1开始排序。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】 <a href="https://www.cnblogs.com/52XF/p/4209211.html" target="_blank" rel="noopener">https://www.cnblogs.com/52XF/p/4209211.html</a><br>【2】 <a href="https://www.jianshu.com/p/bb1b72a1623e" target="_blank" rel="noopener">https://www.jianshu.com/p/bb1b72a1623e</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;rank，row_number，dense_rank，ntile函数的用法  &lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Database，MySQL" scheme="http://yoursite.com/tags/Database%EF%BC%8CMySQL/"/>
    
  </entry>
  
  <entry>
    <title>184.Department Highest Salary</title>
    <link href="http://yoursite.com/2020/01/19/184.Department%20Highest%20Salary/"/>
    <id>http://yoursite.com/2020/01/19/184.Department Highest Salary/</id>
    <published>2020-01-19T07:52:12.000Z</published>
    <updated>2020-01-20T03:02:49.176Z</updated>
    
    <content type="html"><![CDATA[<p>查询部门的最高薪水，MAX，IN和GROUP BY语句的使用</p><a id="more"></a><h1 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h1><p>The Employee table holds all employees. Every employee has an Id, a salary, and there is also a column for the department Id.</p><pre><code>+----+-------+--------+--------------+| Id | Name  | Salary | DepartmentId |+----+-------+--------+--------------+| 1  | Joe   | 70000  | 1            || 2  | Jim   | 90000  | 1            || 3  | Henry | 80000  | 2            || 4  | Sam   | 60000  | 2            || 5  | Max   | 90000  | 1            |+----+-------+--------+--------------+</code></pre><p>The Department table holds all departments of the company.</p><pre><code>+----+----------+| Id | Name     |+----+----------+| 1  | IT       || 2  | Sales    |+----+----------+</code></pre><p>Write a SQL query to find employees who have the highest salary in each of the departments. For the above tables, your SQL query should return the following rows (order of rows does not matter).</p><pre><code>+------------+----------+--------+| Department | Employee | Salary |+------------+----------+--------+| IT         | Max      | 90000  || IT         | Jim      | 90000  || Sales      | Henry    | 80000  |+------------+----------+--------+</code></pre><p>Explanation:</p><p>Max and Jim both have the highest salary in the IT department and Henry has the highest salary in the Sales department.</p><h1 id="最开始想到的解法（错误）："><a href="#最开始想到的解法（错误）：" class="headerlink" title="最开始想到的解法（错误）："></a>最开始想到的解法（错误）：</h1><pre><code>select Department.Name as Department,Employee.Name as Employee ,MAX(Employee.Salary) as Salaryfrom Employeejoin Departmenton Employee.DepartmentId=Department.idgroup by Employee.DepartmentId</code></pre><p>换成</p><pre><code>select *from Employeejoin Departmenton Employee.DepartmentId=Department.idgroup by Employee.DepartmentId</code></pre><p>看了一下实际查询到的结果如下。</p><pre><code>{&quot;headers&quot;:[&quot;Id&quot;, &quot;Name&quot;, &quot;Salary&quot;, &quot;DepartmentId&quot;, &quot;Id&quot;, &quot;Name&quot;],&quot;values&quot;:[[1, &quot;Joe&quot;, 70000, 1, 1, &quot;IT&quot;],[3, &quot;Henry&quot;, 80000, 2, 2, &quot;Sales&quot;]]}</code></pre><p>发现是group by语句用错了，group by是用来根据一个或多个列对结果集进行分组</p><h1 id="正确解法："><a href="#正确解法：" class="headerlink" title="正确解法："></a>正确解法：</h1><p>可以换个思路，我们先来查询每个部门的最高薪水：</p><pre><code>SELECT    DepartmentId, MAX(Salary)FROM    EmployeeGROUP BY DepartmentId;</code></pre><p>查到的结果：</p><pre><code>| DepartmentId | MAX(Salary) ||--------------|-------------|| 1            | 90000       || 2            | 80000       |</code></pre><p>现在连接两张表，然后使用in语句把所有满足上面情况的雇员信息筛选出来：</p><pre><code>SELECT    Department.name AS &apos;Department&apos;,    Employee.name AS &apos;Employee&apos;,    SalaryFROM    Employee        JOIN    Department ON Employee.DepartmentId = Department.IdWHERE    (Employee.DepartmentId , Salary) IN    (   SELECT            DepartmentId, MAX(Salary)        FROM            Employee        GROUP BY DepartmentId    );</code></pre><p>查询结果：</p><pre><code>| Department | Employee | Salary ||------------|----------|--------|| Sales      | Henry    | 80000  || IT         | Max      | 90000  |   </code></pre><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://leetcode.com/problems/department-highest-salary/" target="_blank" rel="noopener">https://leetcode.com/problems/department-highest-salary/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;查询部门的最高薪水，MAX，IN和GROUP BY语句的使用&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Database" scheme="http://yoursite.com/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>数据库学习笔记VIII</title>
    <link href="http://yoursite.com/2020/01/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0VIII/"/>
    <id>http://yoursite.com/2020/01/17/数据库学习笔记VIII/</id>
    <published>2020-01-17T09:51:12.000Z</published>
    <updated>2020-01-19T09:04:25.389Z</updated>
    
    <content type="html"><![CDATA[<p>MS SQL Server和MySQL区别  </p><a id="more"></a><h1 id="MS-SQL-Server和MySQL区别"><a href="#MS-SQL-Server和MySQL区别" class="headerlink" title="MS SQL Server和MySQL区别"></a>MS SQL Server和MySQL区别</h1><p>MySQL支持enum,和set类型，SQL Server不支持</p><p>MySQL不支持nchar,nvarchar,ntext类型</p><p>MySQL的递增语句是AUTO_INCREMENT，而MS SQL是identity(1,1)</p><p>MS SQL不支持replace into 语句，但是在最新的sql20008里面，也支持merge语法</p><p>MySQL支持insert into table1 set t1 = “”, t2 = “”,但是MSSQL不支持这样写</p><p>MySQL支持insert into tabl1 values (1,1), (1,1), (1,1),(1,1),(1,1), (1,1), (1,1)</p><p>MS SQL不支持limit语句，是非常遗憾的，只能用top 取代limt0,N，row_number()over()函数取代limit N,M</p><p>MySQL在创建表时要为每个表指定一个存储引擎类型，而MS SQL只支持一种存储引擎</p><p>PHP连接MySQL和MS SQL的方式都差不多，只需要将函数的MySQL替换成MS SQL即可。</p><p>MySQL的管理工具有几个比较好的，MySQL_front,和官方那个套件，不过都没有SSMS的使用方便，这是MySQL很大的一个缺点。</p><p>MySQL需要为表指定存储类型</p><p>MS SQL识别符是,[type]表示他区别于关键字，但是MySQL却是 `，也就是按键1左边的那个符号</p><p>MSSQL支持getdate()方法获取当前时间日期，但是MySQL里面可以分日期类型和时间类型，获取当前日期是cur_date()，当前完整时间是now()函数</p><p>MySQL不支持默认值为当前时间的datetime类型（MSSQL很容易做到），在MySQL里面是用timestamp类型</p><p>MS SQL里面检查是否有这个表再删除，需要这样：<br>    　　if exists (select * from dbo.systs<br>    where id = t_id(N”uc_newpm”)andTPROPERTY(id,N”IsUserTable”)=1)<br>　　但是在MySQL里面只需要 DROP TABLE IF EXISTS cdb_forums;</p><p>MySQL text字段类型不允许有默认值</p><p>MySQL的一个表的总共字段长度不超过65XXX。</p><p>MS SQL默认到处表创建语句的默认值表示是((0)),而在MySQL里面是不允许带两括号的</p><p>同样的负载压力，MySQL要消耗更少的CPU和内存，MS SQL的确是很耗资源。</p><p>MySQL支持无符号型的整数，那么比不支持无符号型的MS SQL就能多出一倍的最大数存储</p><p>MySQL不支持在MSSQL里面使用非常方便的varchar(max)类型，这个类型在MSSQL里面既可做一般数据存储，也可以做blob数据存储</p><p>MySQL创建非聚集索引只需要在创建表的时候指定为key就行，比如：KEYdisplayorder(fid,displayorder) 在MS SQL里面必须要：</p><p>  　　create unique nonclustered index<br>  　　index_uc_protectedmrs_username_appid on dbo.uc_protectedmrs<br>  　　(username asc,appid asc)<br>一个很表面的区别就是MySQL的安装特别简单，而且文件大小才110M（非安装版）</p><p>MySQL的存储过程只是出现在最新的版本中，稳定性和性能可能不如MS SQL。</p><p>MySQL支持date,time,year类型，MS SQL到2008才支持date和time。</p><p>#参考资料<br>【1】 <a href="https://blog.csdn.net/xc_zhou/article/details/89002519" target="_blank" rel="noopener">https://blog.csdn.net/xc_zhou/article/details/89002519</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MS SQL Server和MySQL区别  &lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Database，MySQL" scheme="http://yoursite.com/tags/Database%EF%BC%8CMySQL/"/>
    
  </entry>
  
  <entry>
    <title>1179. Reformat Department Table</title>
    <link href="http://yoursite.com/2020/01/17/1179.%20Reformat%20Department%20Table/"/>
    <id>http://yoursite.com/2020/01/17/1179. Reformat Department Table/</id>
    <published>2020-01-17T08:03:12.000Z</published>
    <updated>2020-01-17T09:36:07.059Z</updated>
    
    <content type="html"><![CDATA[<p>行转列(PIVOT)与列转行(UNPIVOT)的应用</p><a id="more"></a><p>以下是每个部门在每个月份的收入：</p><pre><code>Department table:+------+---------+-------+| id   | revenue | month |+------+---------+-------+| 1    | 8000    | Jan   || 2    | 9000    | Jan   || 3    | 10000   | Feb   || 1    | 7000    | Feb   || 1    | 6000    | Mar   |+------+---------+-------+</code></pre><p>但我们现在想要重组表的格式，变为：</p><pre><code>Result table:+------+-------------+-------------+-------------+-----+-------------+| id   | Jan_Revenue | Feb_Revenue | Mar_Revenue | ... | Dec_Revenue |+------+-------------+-------------+-------------+-----+-------------+| 1    | 8000        | 7000        | 6000        | ... | null        || 2    | 9000        | null        | null        | ... | null        || 3    | null        | 10000       | null        | ... | null        |+------+-------------+-------------+-------------+-----+-------------+</code></pre><p>比较直接的方法是：</p><pre><code>SELECT    id,    MAX(CASE WHEN month = &apos;Jan&apos; THEN revenue ELSE null END) AS Jan_Revenue,    MAX(CASE WHEN month = &apos;Feb&apos; THEN revenue ELSE null END) AS Feb_Revenue,    MAX(CASE WHEN month = &apos;Mar&apos; THEN revenue ELSE null END) AS Mar_Revenue,    MAX(CASE WHEN month = &apos;Apr&apos; THEN revenue ELSE null END) AS Apr_Revenue,    MAX(CASE WHEN month = &apos;May&apos; THEN revenue ELSE null END) AS May_Revenue,    MAX(CASE WHEN month = &apos;Jun&apos; THEN revenue ELSE null END) AS Jun_Revenue,    MAX(CASE WHEN month = &apos;Jul&apos; THEN revenue ELSE null END) AS Jul_Revenue,    MAX(CASE WHEN month = &apos;Aug&apos; THEN revenue ELSE null END) AS Aug_Revenue,    MAX(CASE WHEN month = &apos;Sep&apos; THEN revenue ELSE null END) AS Sep_Revenue,    MAX(CASE WHEN month = &apos;Oct&apos; THEN revenue ELSE null END) AS Oct_Revenue,    MAX(CASE WHEN month = &apos;Nov&apos; THEN revenue ELSE null END) AS Nov_Revenue,    MAX(CASE WHEN month = &apos;Dec&apos; THEN revenue ELSE null END) AS Dec_RevenueFROM DepartmentGROUP BY id</code></pre><p>使用行转列(PIVOT)：</p><pre><code>SELECT    id,    Jan AS Jan_Revenue,    Feb AS Feb_Revenue,    Mar AS Mar_Revenue,    Apr AS Apr_Revenue,    May AS May_Revenue,    Jun AS Jun_Revenue,    Jul AS Jul_Revenue,    Aug AS Aug_Revenue,    Sep AS Sep_Revenue,    Oct AS Oct_Revenue,    Nov AS Nov_Revenue,    Dec AS Dec_RevenueFROM DepartmentPIVOT(    MAX(revenue)    FOR month IN (Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec)        ) AS MonthsRevenue</code></pre><p>也就是说，行转列后，原来的某个列的值变做了列名，在这里就是原来month列的值“Jan”,”Feb”…”Dec”边做了列名，而我们需要做的另一个工作就是计算这些列的值（这里的“计算”其实就是PIVOT里面的聚合函数(sum,avg等)）<br>注意上面的解法要选择MS SQL Server而不是MySQL</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://leetcode.com/problems/reformat-department-table/discuss/382960/MSSQL-Multiple-joins-GroupBy-and-Pivot-table-solutions" target="_blank" rel="noopener">https://leetcode.com/problems/reformat-department-table/discuss/382960/MSSQL-Multiple-joins-GroupBy-and-Pivot-table-solutions</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;行转列(PIVOT)与列转行(UNPIVOT)的应用&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Database" scheme="http://yoursite.com/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Effective-Java阅读笔记XVII</title>
    <link href="http://yoursite.com/2020/01/17/Effective-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0XVII/"/>
    <id>http://yoursite.com/2020/01/17/Effective-Java阅读笔记XVII/</id>
    <published>2020-01-16T18:33:12.000Z</published>
    <updated>2020-01-17T10:32:00.125Z</updated>
    
    <content type="html"><![CDATA[<p>第五章阅读： 泛型<br>33.优先考虑类型安全的异构容器</p><a id="more"></a><p>　　泛型的常见用法包括集合，如 Set<e> 和 Map&lt;K，V&gt; 和单个元素容器，如 ThreadLocal<t> 和 AtomicReference<t>。 在所有这些用途中，它都是参数化的容器。 这限制了每个容器只能有固定数量的类型参数。 通常这正是你想要的。 一个 Set 有单一的类型参数，表示它的元素类型; 一个 Map 有两个，代表它的键和值的类型；等等。</t></t></e></p><p>　　然而有时候，你需要更多的灵活性。 例如，数据库一行记录可以具有任意多列，并且能够以类型安全的方式访问它们是很好的。 幸运的是，有一个简单的方法可以达到这个效果。 这个想法是参数化键（key）而不是容器。 然后将参数化的键提交给容器以插入或检索值。 泛型类型系统用于保证值的类型与其键一致。</p><p>　　作为这种方法的一个简单示例，请考虑一个 Favorites 类，它允许其客户端保存和检索任意多种类型的 favorite 实例。 该类型的 Class 对象将扮演参数化键的一部分。其原因是这 Class 类是泛型的。 类的类型从字面上来说不是简单的 Class，而是 Class<t>。 例如，String.class 的类型为 Class<string>，Integer.class 的类型为 Class<integer>。 当在方法中传递字面类传递编译时和运行时类型信息时，它被称为类型令牌（type token）[Bracha04]。</integer></string></t></p><p>　　Favorites 类的 API 很简单。 它看起来就像一个简单 Map 类，除了该键是参数化的以外。 客户端在设置和获取 favorites 实例时呈现一个 Class 对象。 如下是 API：</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="http://sjsdfg.gitee.io/effective-java-3rd-chinese/#/notes/33.%20%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%BC%82%E6%9E%84%E5%AE%B9%E5%99%A8" target="_blank" rel="noopener">http://sjsdfg.gitee.io/effective-java-3rd-chinese/#/notes/33.%20%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%BC%82%E6%9E%84%E5%AE%B9%E5%99%A8</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第五章阅读： 泛型&lt;br&gt;33.优先考虑类型安全的异构容器&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Effective-Java阅读笔记XVI</title>
    <link href="http://yoursite.com/2020/01/17/Effective-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0XVI/"/>
    <id>http://yoursite.com/2020/01/17/Effective-Java阅读笔记XVI/</id>
    <published>2020-01-16T17:33:12.000Z</published>
    <updated>2020-01-17T01:52:24.696Z</updated>
    
    <content type="html"><![CDATA[<p>第五章阅读： 泛型</p><p>31.使用限定通配符来增加 API 的灵活性<br>记住基本规则： producer-extends, consumer-super（PECS）。 还要记住，所有 Comparable 和 Comparator 都是消费者。如果一个参数化类型代表一个 T 生产者，使用 &lt;? extends T&gt;；如果它代表 T 消费者，则使用 &lt;? super T&gt;。<br>32.合理地结合泛型和可变参数<br>可变参数和泛型不能很好地交互，因为可变参数机制是在数组上面构建的脆弱的抽象，并且数组具有与泛型不同的类型规则。 虽然泛型可变参数不是类型安全的，但它们是合法的。 如果选择使用泛型（或参数化）可变参数编写方法，请首先确保该方法是类型安全的，然后使用 @SafeVarargs 注解对其进行标注</p><a id="more"></a><h1 id="使用限定通配符来增加-API-的灵活性"><a href="#使用限定通配符来增加-API-的灵活性" class="headerlink" title="使用限定通配符来增加 API 的灵活性"></a>使用限定通配符来增加 API 的灵活性</h1><p>　　如条目 28 所述，参数化类型是不变的。换句话说，对于任何两个不同类型的 Type1 和 Type，List<type1> 既不是 List<type2> 子类型也不是其父类型。尽管 List<string> 不是 List<object> 的子类型是违反直觉的，但它确实是有道理的。 可以将任何对象放入 List<object> 中，但是只能将字符串放入 List<string> 中。 由于 List<string> 不能做 List<object> 所能做的所有事情，所以它不是一个子类型（条目 10 中的里氏替代原则）。</object></string></string></object></object></string></type2></type1></p><p>　　相对于提供的不可变的类型，有时你需要比此更多的灵活性。 考虑条目 29 中的 Stack 类。下面是它的公共 API：</p><pre><code>public class Stack&lt;E&gt; {    public Stack();    public void push(E e);    public E pop();    public boolean isEmpty();}</code></pre><p>　　假设我们想要添加一个方法来获取一系列元素，并将它们全部推送到栈上。 以下是第一种尝试：</p><pre><code>// pushAll method without wildcard type - deficient!public void pushAll(Iterable&lt;E&gt; src) {    for (E e : src)        push(e);}</code></pre><p>　　这种方法可以干净地编译，但不完全令人满意。 如果可遍历的 src 元素类型与栈的元素类型完全匹配，那么它工作正常。 但是，假设有一个 Stack<number>，并调用 push(intVal)，其中 intVal 的类型是 Integer。 这是因为 Integer 是 Number 的子类型。 从逻辑上看，这似乎也应该起作用：</number></p><pre><code>Stack&lt;Number&gt; numberStack = new Stack&lt;&gt;();Iterable&lt;Integer&gt; integers = ... ;numberStack.pushAll(integers);</code></pre><p>　　但是，如果你尝试了，会得到这个错误消息，因为参数化类型是不变的：</p><pre><code>StackTest.java:7: error: incompatible types: Iterable&lt;Integer&gt;cannot be converted to Iterable&lt;Number&gt;        numberStack.pushAll(integers);                            ^</code></pre><p>　　幸运的是，有对应的解决方法。 该语言提供了一种特殊的参数化类型来调用一个限定通配符类型来处理这种情况。 pushAll 的输入参数的类型不应该是「E 的 Iterable 接口」，而应该是「E 的某个子类型的 Iterable 接口」，并且有一个通配符类型，这意味着：Iterable&lt;? extends E&gt;。 （关键字 extends 的使用有点误导：回忆条目 29 中，子类型被定义为每个类型都是它自己的子类型，即使它本身没有继承。）让我们修改 pushAll 来使用这个类型：</p><pre><code>// Wildcard type for a parameter that serves as an E producerpublic void pushAll(Iterable&lt;? extends E&gt; src) {    for (E e : src)        push(e);}</code></pre><p>　　有了这个改变，Stack 类不仅可以干净地编译，而且客户端代码也不会用原始的 pushAll 声明编译。 因为 Stack 和它的客户端干净地编译，你知道一切都是类型安全的。</p><p>　　现在假设你想写一个 popAll 方法，与 pushAll 方法相对应。 popAll 方法从栈中弹出每个元素并将元素添加到给定的集合中。 以下是第一次尝试编写 popAll 方法的过程：</p><pre><code>// popAll method without wildcard type - deficient!public void popAll(Collection&lt;E&gt; dst) {    while (!isEmpty())        dst.add(pop());}</code></pre><p>　　同样，如果目标集合的元素类型与栈的元素类型完全匹配，则干净编译并且工作正常。 但是，这又不完全令人满意。 假设你有一个 Stac<number> 和 Object 类型的变量。 如果从栈中弹出一个元素并将其存储在该变量中，它将编译并运行而不会出错。 所以你也不能这样做吗？</number></p><pre><code>Stack&lt;Number&gt; numberStack = new Stack&lt;Number&gt;();Collection&lt;Object&gt; objects = ... ;numberStack.popAll(objects);</code></pre><p>　　如果尝试将此客户端代码与之前显示的 popAll 版本进行编译，则会得到与我们的第一版 pushAll 非常类似的错误：Collection<object> 不是 Collection<number> 的子类型。 通配符类型再一次提供了一条出路。 popAll 的输入参数的类型不应该是「E 的集合」，而应该是「E 的某个父类型的集合」（其中父类型被定义为 E 是它自己的父类型[JLS，4.10]）。 再次，有一个通配符类型，正是这个意思：Collection&lt;? super E&gt;。 让我们修改 popAll 来使用它：</number></object></p><pre><code>// Wildcard type for parameter that serves as an E consumerpublic void popAll(Collection&lt;? super E&gt; dst) {    while (!isEmpty())        dst.add(pop());}</code></pre><p>　　通过这个改动，Stack 类和客户端代码都可以干净地编译。<br>　　这个结论很清楚。<strong><em>为了获得最大的灵活性，对代表生产者或消费者的输入参数使用通配符类型。</em></strong> 如果一个输入参数既是一个生产者又是一个消费者，那么通配符类型对你没有好处：你需要一个精确的类型匹配，这就是没有任何通配符的情况。</p><p>　　这里有一个助记符来帮助你记住使用哪种通配符类型： PECS 代表： producer-extends，consumer-super。</p><p>　　换句话说，如果一个参数化类型代表一个 T 生产者，使用 &lt;? extends T&gt;；如果它代表 T 消费者，则使用 &lt;? super T&gt;。 在我们的 Stack 示例中，pushAll 方法的 src 参数生成栈使用的 E 实例，因此 src 的合适类型为 Iterable&lt;? extends E&gt;；popAll 方法的 dst 参数消费 Stack 中的 E 实例，因此 dst 的合适类型是 Collection &lt;? super E&gt;。 PECS 助记符抓住了使用通配符类型的基本原则。 Naftalin 和 Wadler 称之为获取和放置原则（Get and Put Principle）[Naftalin07,2.4]。</p><p>　　记住这个助记符之后，让我们来看看本章中以前项目的一些方法和构造方法声明。 条目 28 中的 Chooser 类构造方法有这样的声明：</p><pre><code>public Chooser(Collection&lt;T&gt; choices)</code></pre><p>　　这个构造方法只使用集合选择来生产类型 T 的值（并将它们存储起来以备后用），所以它的声明应该使用一个 extends T 的通配符类型。下面是得到的构造方法声明：</p><pre><code>// Wildcard type for parameter that serves as an T producerpublic Chooser(Collection&lt;? extends T&gt; choices)</code></pre><p>　　这种改变在实践中会有什么不同吗？ 是的，会有不同。 假你有一个 List<integer>，并且想把它传递给 Chooser<number> 的构造方法。 这不会与原始声明一起编译，但是它只会将限定通配符类型添加到声明中。</number></integer></p><p>　　现在看看条目 30 中的 union 方法。下是声明：</p><pre><code>public static &lt;E&gt; Set&lt;E&gt; union(Set&lt;E&gt; s1, Set&lt;E&gt; s2)</code></pre><p>　　两个参数 s1 和 s2 都是 E 的生产者，所以 PECS 助记符告诉我们该声明应该如下：</p><pre><code>public static &lt;E&gt; Set&lt;E&gt; union(Set&lt;? extends E&gt; s1,  Set&lt;? extends E&gt; s2)</code></pre><p>　　请注意，返回类型仍然是 Set<e>。 不要使用限定通配符类型作为返回类型。除了会为用户提供额外的灵活性，还强制他们在客户端代码中使用通配符类型。 通过修改后的声明，此代码将清晰地编译：</e></p><pre><code>Set&lt;Integer&gt;  integers =  Set.of(1, 3, 5);Set&lt;Double&gt;   doubles  =  Set.of(2.0, 4.0, 6.0);Set&lt;Number&gt;   numbers  =  union(integers, doubles);</code></pre><p>　　如果使用得当，类的用户几乎不会看到通配符类型。 他们使方法接受他们应该接受的参数，拒绝他们应该拒绝的参数。 如果一个类的用户必须考虑通配符类型，那么它的 API 可能有问题。<br>　　在 Java 8 之前，类型推断规则不够聪明，无法处理先前的代码片段，这要求编译器使用上下文指定的返回类型（或目标类型）来推断 E 的类型。union 方法调用的目标类型如前所示是 Set<number>。 如果尝试在早期版本的 Java 中编译片段（以及适合的 Set.of 工厂替代版本），将会看到如此长的错综复杂的错误消息：</number></p><pre><code>Union.java:14: error: incompatible types        Set&lt;Number&gt; numbers = union(integers, doubles);                                   ^  required: Set&lt;Number&gt;  found:    Set&lt;INT#1&gt;  where INT#1,INT#2 are intersection types:    INT#1 extends Number,Comparable&lt;? extends INT#2&gt;    INT#2 extends Number,Comparable&lt;?&gt;</code></pre><p>　　幸运的是有办法来处理这种错误。 如果编译器不能推断出正确的类型，你可以随时告诉它使用什么类型的显式类型参数[JLS，15.12]。 甚至在 Java 8 中引入目标类型之前，这不是你必须经常做的事情，这很好，因为显式类型参数不是很漂亮。 通过添加显式类型参数，如下所示，代码片段在 Java 8 之前的版本中进行了干净编译：</p><pre><code>// Explicit type parameter - required prior to Java 8Set&lt;Number&gt; numbers = Union.&lt;Number&gt;union(integers, doubles);</code></pre><p>　　接下来让我们把注意力转向条目 30 中的 max 方法。这里是原始声明：</p><pre><code>public static &lt;T extends Comparable&lt;T&gt;&gt; T max(List&lt;T&gt; list)</code></pre><p>　为了从原来到修改后的声明，我们两次应用了 PECS。首先直接的应用是参数列表。 它生成 T 实例，所以将类型从 List<t> 更改为 List&lt;? extends T&gt;。 棘手的应用是类型参数 T。这是我们第一次看到通配符应用于类型参数。 最初，T 被指定为继承 Comparable<t>，但 Comparable 的 T 消费 T 实例（并生成指示顺序关系的整数）。 因此，参数化类型 Comparable<t> 被替换为限定通配符类型 Comparable&lt;? super T&gt;。 Comparable 实例总是消费者，所以通常应该使用 Comparable&lt;? super T&gt; 优于 Comparable<t>。 Comparator 也是如此。因此，通常应该使用 Comparator&lt;? super T&gt; 优于 Comparator<t>。<br>　　修改后的 max 声明可能是本书中最复杂的方法声明。 增加的复杂性是否真的起作用了吗？ 同样，它的确如此。 这是一个列表的简单例子，它被原始声明排除，但在被修改后的版本里是允许的：</t></t></t></t></t></p><pre><code>List&lt;ScheduledFuture&lt;?&gt;&gt; scheduledFutures = ... ;</code></pre><p>　　无法将原始方法声明应用于此列表的原因是 ScheduledFuture 不实现 Comparable<scheduledfuture>。 相反，它是 Delayed 的子接口，它继承了 Comparable<delayed>。 换句话说，一个 ScheduledFuture 实例不仅仅和其他的 ScheduledFuture 实例相比较： 它可以与任何 Delayed 实例比较，并且足以导致原始的声明拒绝它。 更普遍地说，通配符要求来支持没有直接实现 Comparable（或 Comparator）的类型，但继承了一个类型。</delayed></scheduledfuture></p><p>　　还有一个关于通配符相关的话题。 类型参数和通配符之间具有双重性，许多方法可以用一个或另一个声明。 例如，下面是两个可能的声明，用于交换列表中两个索引项目的静态方法。 第一个使用无限制类型参数（条目 30），第二个使用无限制通配符：</p><pre><code>// Two possible declarations for the swap methodpublic static &lt;E&gt; void swap(List&lt;E&gt; list, int i, int j);public static void swap(List&lt;?&gt; list, int i, int j);</code></pre><p>　　这两个声明中的哪一个更可取，为什么？ 在公共 API 中，第二个更好，因为它更简单。 你传入一个列表（任何列表），该方法交换索引的元素。 没有类型参数需要担心。 通常， <strong><em>如果类型参数在方法声明中只出现一次，请将其替换为通配符。</em></strong> 如果它是一个无限制的类型参数，请将其替换为无限制的通配符; 如果它是一个限定类型参数，则用限定通配符替换它。</p><p>　　第二个 swap 方法声明有一个问题。 这个简单的实现不会编译：</p><pre><code>public static void swap(List&lt;?&gt; list, int i, int j) {    list.set(i, list.set(j, list.get(i)));}</code></pre><p>　　试图编译它会产生这个不太有用的错误信息：</p><pre><code>Swap.java:5: error: incompatible types: Object cannot beconverted to CAP#1        list.set(i, list.set(j, list.get(i)));                                        ^  where CAP#1 is a fresh type-variable:    CAP#1 extends Object from capture of ?</code></pre><p>　　看起来我们不能把一个元素放回到我们刚刚拿出来的列表中。 问题是列表的类型是 List<?>，并且不能将除 null 外的任何值放入 List<?> 中。 幸运的是，有一种方法可以在不使用不安全的转换或原始类型的情况下实现此方法。 这个想法是写一个私有辅助方法来捕捉通配符类型。 辅助方法必须是泛型方法才能捕获类型。 以下是它的定义：</p><pre><code>public static void swap(List&lt;?&gt; list, int i, int j) {    swapHelper(list, i, j);}// Private helper method for wildcard captureprivate static &lt;E&gt; void swapHelper(List&lt;E&gt; list, int i, int j) {    list.set(i, list.set(j, list.get(i)));}</code></pre><p>　　swapHelper 方法知道该列表是一个 List<e>。 因此，它知道从这个列表中获得的任何值都是 E 类型，并且可以安全地将任何类型的 E 值放入列表中。 这个稍微复杂的 swap 的实现可以干净地编译。 它允许我们导出基于通配符的漂亮声明，同时利用内部更复杂的泛型方法。 swap 方法的客户端不需要面对更复杂的 swapHelper 声明，但他们从中受益。 辅助方法具有我们认为对公共方法来说过于复杂的签名。</e></p><p>　　总之，在你的 API 中使用通配符类型，虽然棘手，但使得 API 更加灵活。 如果编写一个将被广泛使用的类库，正确使用通配符类型应该被认为是强制性的。 记住基本规则： producer-extends, consumer-super（PECS）。 还要记住，所有 Comparable 和 Comparator 都是消费者。</p><h1 id="合理地结合泛型和可变参数"><a href="#合理地结合泛型和可变参数" class="headerlink" title="合理地结合泛型和可变参数"></a>合理地结合泛型和可变参数</h1><p>　　在 Java 5 中，可变参数方法（详见第 53 条）和泛型都被添加到平台中，所以你可能希望它们能够正常交互; 可悲的是，他们并没有。 可变参数的目的是允许客户端将一个可变数量的参数传递给一个方法，但这是一个脆弱的抽象（leaky abstraction）：当你调用一个可变参数方法时，会创建一个数组来保存可变参数；那个应该是实现细节的数组是可见的。 因此，当可变参数具有泛型或参数化类型时，会导致编译器警告混淆。</p><p>　　回顾条目 28，非具体化（non-reifiable）的类型是其运行时表示比其编译时表示具有更少信息的类型，并且几乎所有泛型和参数化类型都是不可具体化的。 如果某个方法声明其可变参数为非具体化的类型，则编译器将在该声明上生成警告。 如果在推断类型不可确定的可变参数参数上调用该方法，那么编译器也会在调用中生成警告。 警告看起来像这样：</p><pre><code>warning: [unchecked] Possible heap pollution from    parameterized vararg type List&lt;String&gt;</code></pre><p>　　当参数化类型的变量引用不属于该类型的对象时会发生堆污染（Heap pollution）[JLS，4.12.2]。 它会导致编译器的自动生成的强制转换失败，违反了泛型类型系统的基本保证。</p><p>　　例如，请考虑以下方法，该方法是第 127 页上的代码片段的一个不太明显的变体：</p><pre><code>// Mixing generics and varargs can violate type safety!static void dangerous(List&lt;String&gt;... stringLists) {    List&lt;Integer&gt; intList = List.of(42);    Object[] objects = stringLists;    objects[0] = intList;             // Heap pollution    String s = stringLists[0].get(0); // ClassCastException}</code></pre><p>　　此方法没有可见的强制转换，但在调用一个或多个参数时抛出 ClassCastException 异常。 它的最后一行有一个由编译器生成的隐形转换。 这种转换失败，表明类型安全性已经被破坏，并且将值保存在泛型可变参数数组参数中是不安全的。</p><p>　　这个例子引发了一个有趣的问题：为什么声明一个带有泛型可变参数的方法是合法的，当明确创建一个泛型数组是非法的时候呢？ 换句话说，为什么前面显示的方法只生成一个警告，而 127 页上的代码片段会生成一个错误？ 答案是，具有泛型或参数化类型的可变参数参数的方法在实践中可能非常有用，因此语言设计人员选择忍受这种不一致。 事实上，Java 类库导出了几个这样的方法，包括 Arrays.asList(T… a)，Collections.addAll(Collection&lt;? super T&gt; c, T… elements)，EnumSet.of(E first, E… rest)。 与前面显示的危险方法不同，这些类库方法是类型安全的。</p><p>　　在 Java 7 中，@SafeVarargs 注解已添加到平台，以允许具有泛型可变参数的方法的作者自动禁止客户端警告。 实质上，@SafeVarargs 注解构成了作者对类型安全的方法的承诺。 为了交换这个承诺，编译器同意不要警告用户调用可能不安全的方法。</p><p>　　除非它实际上是安全的，否则注意不要使用 @SafeVarargs 注解标注一个方法。 那么需要做些什么来确保这一点呢？ 回想一下，调用方法时会创建一个泛型数组，以容纳可变参数。 如果方法没有在数组中存储任何东西（它会覆盖参数）并且不允许对数组的引用进行转义（这会使不受信任的代码访问数组），那么它是安全的。 换句话说，如果可变参数数组仅用于从调用者向方法传递可变数量的参数——毕竟这是可变参数的目的——那么该方法是安全的。</p><p>　　值得注意的是，你可以违反类型安全性，即使不会在可变参数数组中存储任何内容。 考虑下面的泛型可变参数方法，它返回一个包含参数的数组。 乍一看，它可能看起来像一个方便的小工具：</p><pre><code>// UNSAFE - Exposes a reference to its generic parameter array!static &lt;T&gt; T[] toArray(T... args) {    return args;}</code></pre><p>　　这个方法只是返回它的可变参数数组。 该方法可能看起来并不危险，但它是该数组的类型由传递给方法的参数的编译时类型决定，编译器可能没有足够的信息来做出正确的判断。 由于此方法返回其可变参数数组，它可以将堆污染传播到调用栈上。<br>　　为了具体说明，请考虑下面的泛型方法，它接受三个类型 T 的参数，并返回一个包含两个参数的数组，随机选择：</p><pre><code>static &lt;T&gt; T[] pickTwo(T a, T b, T c) {    switch(ThreadLocalRandom.current().nextInt(3)) {      case 0: return toArray(a, b);      case 1: return toArray(a, c);      case 2: return toArray(b, c);    }    throw new AssertionError(); // Can&apos;t get here}</code></pre><p>　　这个方法本身不是危险的，除了调用具有泛型可变参数的 toArray 方法之外，不会产生警告。</p><p>　　编译此方法时，编译器会生成代码以创建一个将两个 T 实例传递给 toArray 的可变参数数组。 这段代码分配了一个 Object[] 类型的数组，它是保证保存这些实例的最具体的类型，而不管在调用位置传递给 pickTwo 的对象是什么类型。 toArray 方法只是简单地将这个数组返回给 pickTwo，然后 pickTwo 将它返回给调用者，所以 pickTwo 总是返回一个 Object[] 类型的数组。</p><pre><code>public static void main(String[] args) {    String[] attributes = pickTwo(&quot;Good&quot;, &quot;Fast&quot;, &quot;Cheap&quot;);}</code></pre><p>　　这种方法没有任何问题，因此它编译时不会产生任何警告。 但是当运行它时，抛出一个 ClassCastException 异常，尽管不包含可见的转换。 你没有看到的是，编译器已经生成了一个隐藏的强制转换为由 pickTwo 返回的值的 String[] 类型，以便它可以存储在属性中。 转换失败，因为 Object[] 不是 String[] 的子类型。 这种故障相当令人不安，因为它从实际导致堆污染（toArray）的方法中移除了两个级别，并且在实际参数存储在其中之后，可变参数数组未被修改。</p><p>　　这个例子是为了让人们认识到给另一个方法访问一个泛型的可变参数数组是不安全的，除了两个例外：将数组传递给另一个可变参数方法是安全的，这个方法是用 @SafeVarargs 正确标注的， 将数组传递给一个非可变参数的方法是安全的，该方法仅计算数组内容的一些方法。</p><p>　　这里是安全使用泛型可变参数的典型示例。 此方法将任意数量的列表作为参数，并按顺序返回包含所有输入列表元素的单个列表。 由于该方法使用 @SafeVarargs 进行标注，因此在声明或其调用站位置上不会生成任何警告：</p><pre><code>// Safe method with a generic varargs parameter@SafeVarargsstatic &lt;T&gt; List&lt;T&gt; flatten(List&lt;? extends T&gt;... lists) {    List&lt;T&gt; result = new ArrayList&lt;&gt;();    for (List&lt;? extends T&gt; list : lists)        result.addAll(list);    return result;}</code></pre><p>　　决定何时使用 @SafeVarargs 注解的规则很简单：在每种方法上使用 @SafeVarargs，并使用泛型或参数化类型的可变参数，这样用户就不会因不必要的和令人困惑的编译器警告而担忧。 这意味着你不应该写危险或者 toArray 等不安全的可变参数方法。 每次编译器警告你可能会受到来自你控制的方法中泛型可变参数的堆污染时，请检查该方法是否安全。 提醒一下，在下列情况下，泛型可变参数方法是安全的：</p><h2 id="它不会在可变参数数组中存储任何东西"><a href="#它不会在可变参数数组中存储任何东西" class="headerlink" title="它不会在可变参数数组中存储任何东西"></a>它不会在可变参数数组中存储任何东西</h2><h2 id="它不会使数组（或克隆）对不可信代码可见。"><a href="#它不会使数组（或克隆）对不可信代码可见。" class="headerlink" title="它不会使数组（或克隆）对不可信代码可见。"></a>它不会使数组（或克隆）对不可信代码可见。</h2><p>如果违反这些禁令中的任何一项，请修复。<br>　　请注意，SafeVarargs 注解只对不能被重写的方法是合法的，因为不可能保证每个可能的重写方法都是安全的。 在 Java 8 中，注解仅在静态方法和 final 实例方法上合法; 在 Java 9 中，它在私有实例方法中也变为合法。</p><p>　　使用 SafeVarargs 注解的替代方法是采用条目 28 的建议，并用 List 参数替换可变参数（这是一个变相的数组）。 下面是应用于我们的 flatten 方法时，这种方法的样子。 请注意，只有参数声明被更改了：</p><pre><code>// List as a typesafe alternative to a generic varargs parameterstatic &lt;T&gt; List&lt;T&gt; flatten(List&lt;List&lt;? extends T&gt;&gt; lists) {    List&lt;T&gt; result = new ArrayList&lt;&gt;();    for (List&lt;? extends T&gt; list : lists)        result.addAll(list);    return result;}</code></pre><p>　　然后可以将此方法与静态工厂方法 List.of 结合使用，以允许可变数量的参数。 请注意，这种方法依赖于 List.of 声明使用 @SafeVarargs 注解：</p><pre><code>audience = flatten(List.of(friends, romans, countrymen));</code></pre><p>　　这种方法的优点是编译器可以证明这种方法是类型安全的。 不必使用 @SafeVarargs 注解来证明其安全性，也不用担心在确定安全性时可能会犯错。 主要缺点是客户端代码有点冗长，运行可能会慢一些。</p><p>　　这个技巧也可以用在不可能写一个安全的可变参数方法的情况下，就像第 147 页的 toArray 方法那样。它的列表模拟是 List.of 方法，所以我们甚至不必编写它；Java 类库作者已经为我们完成了这项工作。 pickTwo 方法然后变成这样：</p><p>　　main 方变成这样：</p><pre><code>public static void main(String[] args) {    List&lt;String&gt; attributes = pickTwo(&quot;Good&quot;, &quot;Fast&quot;, &quot;Cheap&quot;);}</code></pre><p>　　生成的代码是类型安全的，因为它只使用泛型，不是数组。</p><p>　　总而言之，可变参数和泛型不能很好地交互，因为可变参数机制是在数组上面构建的脆弱的抽象，并且数组具有与泛型不同的类型规则。 虽然泛型可变参数不是类型安全的，但它们是合法的。 如果选择使用泛型（或参数化）可变参数编写方法，请首先确保该方法是类型安全的，然后使用 @SafeVarargs 注解对其进行标注，以免造成使用不愉快。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="http://sjsdfg.gitee.io/effective-java-3rd-chinese/#/notes/31.%20%E4%BD%BF%E7%94%A8%E9%99%90%E5%AE%9A%E9%80%9A%E9%85%8D%E7%AC%A6%E6%9D%A5%E5%A2%9E%E5%8A%A0API%E7%9A%84%E7%81%B5%E6%B4%BB%E6%80%A7" target="_blank" rel="noopener">http://sjsdfg.gitee.io/effective-java-3rd-chinese/#/notes/31.%20%E4%BD%BF%E7%94%A8%E9%99%90%E5%AE%9A%E9%80%9A%E9%85%8D%E7%AC%A6%E6%9D%A5%E5%A2%9E%E5%8A%A0API%E7%9A%84%E7%81%B5%E6%B4%BB%E6%80%A7</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第五章阅读： 泛型&lt;/p&gt;
&lt;p&gt;31.使用限定通配符来增加 API 的灵活性&lt;br&gt;记住基本规则： producer-extends, consumer-super（PECS）。 还要记住，所有 Comparable 和 Comparator 都是消费者。如果一个参数化类型代表一个 T 生产者，使用 &amp;lt;? extends T&amp;gt;；如果它代表 T 消费者，则使用 &amp;lt;? super T&amp;gt;。&lt;br&gt;32.合理地结合泛型和可变参数&lt;br&gt;可变参数和泛型不能很好地交互，因为可变参数机制是在数组上面构建的脆弱的抽象，并且数组具有与泛型不同的类型规则。 虽然泛型可变参数不是类型安全的，但它们是合法的。 如果选择使用泛型（或参数化）可变参数编写方法，请首先确保该方法是类型安全的，然后使用 @SafeVarargs 注解对其进行标注&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Effective-Java阅读笔记XV</title>
    <link href="http://yoursite.com/2020/01/17/Effective-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0XV/"/>
    <id>http://yoursite.com/2020/01/17/Effective-Java阅读笔记XV/</id>
    <published>2020-01-16T16:33:12.000Z</published>
    <updated>2020-01-17T01:50:19.117Z</updated>
    
    <content type="html"><![CDATA[<p>第五章阅读： 泛型</p><p>29.优先考虑泛型<br>泛型类型比需要在客户端代码中强制转换的类型更安全，更易于使用。<br>30.优先使用泛型方法<br>像泛型类型一样，泛型方法比需要客户端对输入参数和返回值进行显式强制转换的方法更安全，更易于使用。</p><a id="more"></a><h1 id="优先考虑泛型"><a href="#优先考虑泛型" class="headerlink" title="优先考虑泛型"></a>优先考虑泛型</h1><p>　　参数化声明并使用 JDK 提供的泛型类型和方法通常不会太困难。 但编写自己的泛型类型有点困难，但值得努力学习。</p><p>　　考虑条目 7 中的简单堆栈实现：</p><pre><code>// Object-based collection - a prime candidate for genericspublic class Stack {    private Object[] elements;    private int size = 0;    private static final int DEFAULT_INITIAL_CAPACITY = 16;    public Stack() {        elements = new Object[DEFAULT_INITIAL_CAPACITY];    }    public void push(Object e) {        ensureCapacity();        elements[size++] = e;    }    public Object pop() {        if (size == 0)            throw new EmptyStackException();        Object result = elements[--size];        elements[size] = null; // Eliminate obsolete reference        return result;    }    public boolean isEmpty() {        return size == 0;    }    private void ensureCapacity() {        if (elements.length == size)            elements = Arrays.copyOf(elements, 2 * size + 1);    }}</code></pre><p>　　这个类应该已经被参数化了，但是由于事实并非如此，我们可以对它进行泛型化。 换句话说，我们可以参数化它，而不会损害原始非参数化版本的客户端。 就目前而言，客户端必须强制转换从堆栈中弹出的对象，而这些强制转换可能会在运行时失败。 泛型化类的第一步是在其声明中添加一个或多个类型参数。 在这种情况下，有一个类型参数，表示堆栈的元素类型，这个类型参数的常规名称是 E（详见第 68 条）。</p><p>　　下一步是用相应的类型参数替换所有使用的 Object 类型，然后尝试编译生成的程序：</p><pre><code>// Initial attempt to generify Stack - won&apos;t compile!public class Stack&lt;E&gt; {    private E[] elements;    private int size = 0;    private static final int DEFAULT_INITIAL_CAPACITY = 16;    public Stack() {        elements = new E[DEFAULT_INITIAL_CAPACITY];    }    public void push(E e) {        ensureCapacity();        elements[size++] = e;    }    public E pop() {        if (size == 0)            throw new EmptyStackException();        E result = elements[--size];        elements[size] = null; // Eliminate obsolete reference        return result;    }    ... // no changes in isEmpty or ensureCapacity}</code></pre><p>　　你通常会得到至少一个错误或警告，这个类也不例外。 幸运的是，这个类只产生一个错误：</p><pre><code>Stack.java:8: generic array creation        elements = new E[DEFAULT_INITIAL_CAPACITY];                   ^</code></pre><p>　　如条目 28 所述，你不能创建一个不可具体化类型的数组，例如类型 E。每当编写一个由数组支持的泛型时，就会出现此问题。 有两种合理的方法来解决它。 第一种解决方案直接规避了对泛型数组创建的禁用：创建一个 Object 数组并将其转换为泛型数组类型。 现在没有了错误，编译器会发出警告。 这种用法是合法的，但不是（一般）类型安全的：</p><pre><code>Stack.java:8: warning: [unchecked] unchecked castfound: Object[], required: E[]        elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY];                       ^</code></pre><p>　　编译器可能无法证明你的程序是类型安全的，但你可以。 你必须说服自己，不加限制的类型强制转换不会损害程序的类型安全。 有问题的数组（元素）保存在一个私有属性中，永远不会返回给客户端或传递给任何其他方法。 保存在数组中的唯一元素是那些传递给 push 方法的元素，它们是 E 类型的，所以未经检查的强制转换不会造成任何伤害。</p><p>　　一旦证明未经检查的强制转换是安全的，请尽可能缩小范围（条目 27）。 在这种情况下，构造方法只包含未经检查的数组创建，所以在整个构造方法中抑制警告是合适的。 通过添加一个注解来执行此操作，Stack 可以干净地编译，并且可以在没有显式强制转换或担心 ClassCastException 异常的情况下使用它：</p><pre><code>// The elements array will contain only E instances from push(E).// This is sufficient to ensure type safety, but the runtime// type of the array won&apos;t be E[]; it will always be Object[]!@SuppressWarnings(&quot;unchecked&quot;)public Stack() {    elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY];}</code></pre><p>　消除 Stack 中的泛型数组创建错误的第二种方法是将属性元素的类型从 E[] 更改为 Object[]。 如果这样做，会得到一个不同的错误：</p><pre><code>Stack.java:19: incompatible typesfound: Object, required: E        E result = elements[--size];                           ^</code></pre><p>　　可以通过将从数组中检索到的元素转换为 E 来将此错误更改为警告：</p><pre><code>Stack.java:19: warning: [unchecked] unchecked castfound: Object, required: E        E result = (E) elements[--size];                               ^</code></pre><p>　　因为 E 是不可具体化的类型，编译器无法在运行时检查强制转换。 再一次，你可以很容易地向自己证明，不加限制的转换是安全的，所以可以适当地抑制警告。 根据条目 27 的建议，我们只在包含未经检查的强制转换的分配上抑制警告，而不是在整个 pop 方法上：</p><pre><code>// Appropriate suppression of unchecked warningpublic E pop() {    if (size == 0)        throw new EmptyStackException();    // push requires elements to be of type E, so cast is correct    @SuppressWarnings(&quot;unchecked&quot;) E result =        (E) elements[--size];    elements[size] = null; // Eliminate obsolete reference    return result;}</code></pre><p>　　两种消除泛型数组创建的技术都有其追随者。 第一个更可读：数组被声明为 E[] 类型，清楚地表明它只包含 E 实例。 它也更简洁：在一个典型的泛型类中，你从代码中的许多点读取数组; 第一种技术只需要一次转换（创建数组的地方），而第二种技术每次读取数组元素都需要单独转换。 因此，第一种技术是优选的并且在实践中更常用。 但是，它确实会造成堆污染（heap pollution）（详见第 32 条）：数组的运行时类型与编译时类型不匹配（除非 E 碰巧是 Object）。 这使得一些程序员非常不安，他们选择了第二种技术，尽管在这种情况下堆的污染是无害的。<br>　　下面的程序演示了泛型 Stack 类的使用。 该程序以相反的顺序打印其命令行参数，并将其转换为大写。 对从堆栈弹出的元素调用 String 的 toUpperCase 方法不需要显式强制转换，而自动生成的强制转换将保证成功：</p><pre><code>// Little program to exercise our generic Stackpublic static void main(String[] args) {    Stack&lt;String&gt; stack = new Stack&lt;&gt;();    for (String arg : args)        stack.push(arg);    while (!stack.isEmpty())        System.out.println(stack.pop().toUpperCase());}</code></pre><p>　　上面的例子似乎与条目 28 相矛盾，条目 28 中鼓励使用列表优先于数组。 在泛型类型中使用列表并不总是可行或可取的。 Java 本身生来并不支持列表，所以一些泛型类型（如 ArrayList）必须在数组上实现。 其他的泛型类型，比如 HashMap，是为了提高性能而实现的。</p><p>　　绝大多数泛型类型就像我们的 Stack 示例一样，它们的类型参数没有限制：可以创建一个 Stack<object>，Stack&lt;int[]&gt;，Stack&lt;List<string>&gt; 或者其他任何对象的 Stack 引用类型。 请注意，不能创建基本类型的堆栈：尝试创建 Stack<int> 或 Stack<double> 将导致编译时错误。 这是 Java 泛型类型系统的一个基本限制。 可以使用基本类型的包装类（详见第 61 条）来解决这个限制。</double></int></string></object></p><p>　　有一些泛型类型限制了它们类型参数的允许值。 例如，考虑 java.util.concurrent.DelayQueue，它的声明如下所示：</p><pre><code>class DelayQueue&lt;E extends Delayed&gt; implements BlockingQueue&lt;E&gt;</code></pre><p>　　类型参数列表（<e extends delayed>）要求实际的类型参数 E 是 java.util.concurrent.Delayed 的子类型。 这使得 DelayQueue 实现及其客户端可以利用 DelayQueue 元素上的 Delayed 方法，而不需要显式的转换或 ClassCastException 异常的风险。 类型参数 E 被称为限定类型参数。 请注意，子类型关系被定义为每个类型都是自己的子类型，因此创建 DelayQueue<delayed> 是合法的。</delayed></e></p><p>　　总之，泛型类型比需要在客户端代码中强制转换的类型更安全，更易于使用。 当你设计新的类型时，确保它们可以在没有这种强制转换的情况下使用。 这通常意味着使类型泛型化。 如果你有任何现有的类型，应该是泛型的但实际上却不是，那么把它们泛型化。 这使这些类型的新用户的使用更容易，而不会破坏现有的客户端（条目 26）。</p><h1 id="优先使用泛型方法"><a href="#优先使用泛型方法" class="headerlink" title="优先使用泛型方法"></a>优先使用泛型方法</h1><p>　　正如类可以是泛型的，方法也可以是泛型的。 对参数化类型进行操作的静态工具方法通常都是泛型的。 集合中的所有“算法”方法（如 binarySearch 和 sort）都是泛型的。<br>　　编写泛型方法类似于编写泛型类型。 考虑这个方法，它返回两个集合的并集：</p><pre><code>// Uses raw types - unacceptable! [Item 26]public static Set union(Set s1, Set s2) {    Set result = new HashSet(s1);    result.addAll(s2);    return result;}</code></pre><p>　　此方法可以编译但有两个警告：</p><pre><code>Union.java:5: warning: [unchecked] unchecked call toHashSet(Collection&lt;? extends E&gt;) as a member of raw type HashSet        Set result = new HashSet(s1);                     ^Union.java:6: warning: [unchecked] unchecked call toaddAll(Collection&lt;? extends E&gt;) as a member of raw type Set        result.addAll(s2);                     ^</code></pre><p>　　要修复这些警告并使方法类型安全，请修改其声明以声明表示三个集合（两个参数和返回值）的元素类型的类型参数，并在整个方法中使用此类型参数。 声明类型参数的类型参数列表位于方法的修饰符和返回类型之间。 在这个例子中，类型参数列表是 <e>，返回类型是 Set<e>。 类型参数的命名约定对于泛型方法和泛型类型是相同的（详见第 29 和 68 条）：</e></e></p><pre><code>// Generic methodpublic static &lt;E&gt; Set&lt;E&gt; union(Set&lt;E&gt; s1, Set&lt;E&gt; s2) {    Set&lt;E&gt; result = new HashSet&lt;&gt;(s1);    result.addAll(s2);    return result;}</code></pre><p>　　至少对于简单的泛型方法来说，就是这样。 此方法编译时不会生成任何警告，并提供类型安全性和易用性。 这是一个简单的程序来运行该方法。 这个程序不包含强制转换和编译时没有错误或警告：至少对于简单的泛型方法来说，就是这样。 此方法编译时不会生成任何警告，并提供类型安全性和易用性。 这是一个简单的程序来运行该方法。 这个程序不包含强制转换和编译时没有错误或警告：</p><pre><code>// Simple program to exercise generic methodpublic static void main(String[] args) {    Set&lt;String&gt; guys = Set.of(&quot;Tom&quot;, &quot;Dick&quot;, &quot;Harry&quot;);    Set&lt;String&gt; stooges = Set.of(&quot;Larry&quot;, &quot;Moe&quot;, &quot;Curly&quot;);    Set&lt;String&gt; aflCio = union(guys, stooges);    System.out.println(aflCio);}</code></pre><p>　　当运行这个程序时，它会打印[Moe, Tom, Harry, Larry, Curly, Dick]（输出中元素的顺序依赖于具体实现。）</p><p>　　union 方法的一个限制是所有三个集合（输入参数和返回值）的类型必须完全相同。 通过使用限定通配符类型（ bounded wildcard types）（详见第 31 条），可以使该方法更加灵活。</p><p>　　有时，需要创建一个不可改变但适用于许多不同类型的对象。 因为泛型是通过擦除来实现的（详见第 28 条），所以可以使用单个对象进行所有必需的类型参数化，但是需要编写一个静态工厂方法来重复地为每个请求的类型参数化分配对象。 这种称为泛型单例工厂（generic singleton factory）的模式用于方法对象（function objects）（详见第 42 条），比如 Collections.reverseOrder 方法，偶尔也用于 Collections.emptySet 之类的集合。</p><p>　　假设你想写一个恒等方法分配器（ identity function dispenser）。 类库提供了 Function.identity 方法，所以没有理由编写你自己的实现（详见第 59 条），但它是有启发性的。 如果每次要求的时候都去创建一个新的恒等方法对象是浪费的，因为它是无状态的。 如果 Java 的泛型被具体化，那么每个类型都需要一个恒等方法，但是由于它们被擦除以后，所以泛型的单例就足够了。 以下是它的实例：</p><pre><code>// Generic singleton factory patternprivate static UnaryOperator&lt;Object&gt; IDENTITY_FN = (t) -&gt; t;@SuppressWarnings(&quot;unchecked&quot;)public static &lt;T&gt; UnaryOperator&lt;T&gt; identityFunction() {    return (UnaryOperator&lt;T&gt;) IDENTITY_FN;}</code></pre><p>　　将 IDENTITY_FN 转换为 (UnaryFunction<t>) 会生成一个未经检查的强制转换警告，因为 UnaryOperator<object> 对于每个 T 都不是一个 UnaryOperator<t>。但是恒等方法是特殊的：它返回未修改的参数，所以我们知道，使用它作为一个 UnaryFunction<t> 是类型安全的，无论 T 的值是多少。因此，我们可以放心地抑制由这个强制生成的未经检查的强制转换警告。 一旦我们完成了这些，代码编译没有错误或警告。<br>　　下面是一个示例程序，它使用我们的泛型单例作为 UnaryOperator<string> 和 UnaryOperator<number>。 像往常一样，它不包含强制转化，编译时也没有错误和警告：</number></string></t></t></object></t></p><pre><code>// Sample program to exercise generic singletonpublic static void main(String[] args) {    String[] strings = { &quot;jute&quot;, &quot;hemp&quot;, &quot;nylon&quot; };    UnaryOperator&lt;String&gt; sameString = identityFunction();    for (String s : strings)        System.out.println(sameString.apply(s));    Number[] numbers = { 1, 2.0, 3L };    UnaryOperator&lt;Number&gt; sameNumber = identityFunction();    for (Number n : numbers)        System.out.println(sameNumber.apply(n));}</code></pre><p>　　虽然相对较少，类型参数受涉及该类型参数本身的某种表达式限制是允许的。 这就是所谓的 <strong><em>递归类型限制（recursive type bound）</em></strong> 。 递归类型限制的常见用法与 Comparable 接口有关，它定义了一个类型的自然顺序（详见第 14 条）。 这个接口如下所示：</p><pre><code>public interface Comparable&lt;T&gt; {    int compareTo(T o);}</code></pre><p>　　类型参数 T 定义了实现 Comparable<t> 的类型的元素可以比较的类型。 在实际中，几乎所有类型都只能与自己类型的元素进行比较。 所以，例如，String 类实现了 Comparable<string>，Integer 类实现了 Comparable<integer> 等等。<br>　　许多方法采用实现 Comparable 的元素的集合来对其进行排序，在其中进行搜索，计算其最小值或最大值等。 要做到这一点，要求集合中的每一个元素都可以与其中的每一个元素相比，换言之，这个元素是可以相互比较的。 以下是如何表达这一约束：</integer></string></t></p><pre><code>// Using a recursive type bound to express mutual comparabilitypublic static &lt;E extends Comparable&lt;E&gt;&gt; E max(Collection&lt;E&gt; c);</code></pre><p>　　限定的类型 &lt;E extends Comparable <e>&gt; 可以理解为「任何可以与自己比较的类型 E」，这或多或少精确地对应于相互可比性的概念。<br>　　这里有一个与前面的声明相匹配的方法。它根据其元素的自然顺序来计算集合中的最大值，并编译没有错误或警告：</e></p><pre><code>// Returns max value in a collection - uses recursive type boundpublic static &lt;E extends Comparable&lt;E&gt;&gt; E max(Collection&lt;E&gt; c) {  if (c.isEmpty())    throw new IllegalArgumentException(&quot;Empty collection&quot;);  E result = null;  for (E e : c)    if (result == null || e.compareTo(result) &gt; 0)      result = Objects.requireNonNull(e);  return result;}</code></pre><p>　　请注意，如果列表为空，则此方法将引发 IllegalArgumentException 异常。 更好的选择是返回一个 Optional<e>（详见第 55 条）。</e></p><p>　　递归类型限制可能变得复杂得多，但幸运的是他们很少这样做。 如果你理解了这个习惯用法，它的通配符变体（详见第 31 条）和模拟的自我类型用法（详见第 2 条），你将能够处理在实践中遇到的大多数递归类型限制。</p><p>　　总之，像泛型类型一样，泛型方法比需要客户端对输入参数和返回值进行显式强制转换的方法更安全，更易于使用。 像类型一样，你应该确保你的方法可以不用强制转换，这通常意味着它们是泛型的。 应该泛型化现有的方法，其使用需要强制转换。 这使得新用户的使用更容易，而不会破坏现有的客户端（详见第 26 条）。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="http://sjsdfg.gitee.io/effective-java-3rd-chinese/#/notes/29.%20%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E6%B3%9B%E5%9E%8B" target="_blank" rel="noopener">http://sjsdfg.gitee.io/effective-java-3rd-chinese/#/notes/29.%20%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E6%B3%9B%E5%9E%8B</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第五章阅读： 泛型&lt;/p&gt;
&lt;p&gt;29.优先考虑泛型&lt;br&gt;泛型类型比需要在客户端代码中强制转换的类型更安全，更易于使用。&lt;br&gt;30.优先使用泛型方法&lt;br&gt;像泛型类型一样，泛型方法比需要客户端对输入参数和返回值进行显式强制转换的方法更安全，更易于使用。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Effective-Java阅读笔记XIV</title>
    <link href="http://yoursite.com/2020/01/16/Effective-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0XIV/"/>
    <id>http://yoursite.com/2020/01/16/Effective-Java阅读笔记XIV/</id>
    <published>2020-01-16T15:57:12.000Z</published>
    <updated>2020-01-17T01:50:19.117Z</updated>
    
    <content type="html"><![CDATA[<p>第五章阅读： 泛型</p><p>27.消除非检查警告<br>未经检查的警告是重要的。 不要忽视他们。 每个未经检查的警告代表在运行时出现 ClassCastException 异常的可能性。 尽可能消除这些警告。 如果无法消除未经检查的警告，并且可以证明引发该警告的代码是安全类型的，则可以在尽可能小的范围内使用 @SuppressWarnings(“unchecked”) 注解来禁止警告。 记录决定在注释中抑制此警告的理由。<br>28.列表优于数组<br>数组和泛型具有非常不同的类型规则。 数组是协变的（covariant），被具体化了（reified），数组是协变和具体化的; 泛型是不变的，类型擦除的。 因此，数组提供运行时类型的安全性，但不提供编译时类型的安全性，反之亦然。 一般来说，数组和泛型不能很好地混合工作。 如果发现把它们混合在一起，得到编译时错误或者警告，应该首先用列表来替换数组。</p><a id="more"></a><h1 id="消除非检查警告"><a href="#消除非检查警告" class="headerlink" title="消除非检查警告"></a>消除非检查警告</h1><p>　　使用泛型编程时，会看到许多编译器警告：未经检查的强制转换警告，未经检查的方法调用警告，未经检查的参数化可变长度类型警告以及未经检查的转换警告。 你使用泛型获得的经验越多，获得的警告越少，但不要期望新编写的代码能够干净地编译。</p><p>　　许多未经检查的警告很容易消除。 例如，假设你不小心写了以下声明：</p><pre><code>Set&lt;Lark&gt; exaltation = new HashSet();</code></pre><p>　　编译器会提醒你你做错了什么：</p><pre><code>Venery.java:4: warning: [unchecked] unchecked conversion        Set&lt;Lark&gt; exaltation = new HashSet();                               ^  required: Set&lt;Lark&gt;  found:    HashSet。</code></pre><p>　然后可以进行指示修正，让警告消失。 请注意，实际上并不需要指定类型参数，只是为了表明它与 Java 7 中引入的钻石运算符（「&lt;&gt;」）一同出现。然后编译器会推断出正确的实际类型参数（在本例中为 Lark）：</p><pre><code>Set&lt;Lark&gt; exaltation = new HashSet&lt;&gt;();</code></pre><p>　　但一些警告更难以消除。 本章充满了这种警告的例子。 当你收到需要进一步思考的警告时，坚持不懈！ 尽可能地消除每一个未经检查的警告。 如果你消除所有的警告，你可以放心，你的代码是类型安全的，这是一件非常好的事情。 这意味着在运行时你将不会得到一个 ClassCastException 异常，并且增加了你的程序将按照你的意图行事的信心。</p><p>　　如果你不能消除警告，但你可以证明引发警告的代码是类型安全的，那么（并且只能这样）用 @SuppressWarnings(“unchecked”) 注解来抑制警告。 如果你在没有首先证明代码是类型安全的情况下压制警告，那么你给自己一个错误的安全感。 代码可能会在不发出任何警告的情况下进行编译，但是它仍然可以在运行时抛出 ClassCastException 异常。 但是，如果你忽略了你认为是安全的未经检查的警告（而不是抑制它们），那么当一个新的警告出现时，你将不会注意到这是一个真正的问题。 新出现的警告就会淹没在所有的错误警告当中。</p><p>　　SuppressWarnings 注解可用于任何声明，从单个局部变量声明到整个类。 始终在尽可能最小的范围内使用 SuppressWarnings 注解。 通常这是一个变量声明或一个非常短的方法或构造方法。 切勿在整个类上使用 SuppressWarnings 注解。 这样做可能会掩盖重要的警告。</p><p>　　如果你发现自己在长度超过一行的方法或构造方法上使用 SuppressWarnings 注解，则可以将其移到局部变量声明上。 你可能需要声明一个新的局部变量，但这是值得的。 例如，考虑这个来自 ArrayList 的 toArray 方法：</p><pre><code>public &lt;T&gt; T[] toArray(T[] a) {    if (a.length &lt; size)       return (T[]) Arrays.copyOf(elements, size, a.getClass());    System.arraycopy(elements, 0, a, 0, size);    if (a.length &gt; size)       a[size] = null;    return a;}如果编译 ArrayList 类，则该方法会生成此警告：ArrayList.java:305: warning: [unchecked] unchecked cast       return (T[]) Arrays.copyOf(elements, size, a.getClass());                                 ^  required: T[]  found:    Object[]</code></pre><p>　　在返回语句中设置 SuppressWarnings 注解是非法的，因为它不是一个声明[JLS，9.7]。 你可能会试图把注释放在整个方法上，但是不要这要做。 相反，声明一个局部变量来保存返回值并标注它的声明，如下所示：</p><pre><code>// Adding local variable to reduce scope of @SuppressWarningspublic &lt;T&gt; T[] toArray(T[] a) {    if (a.length &lt; size) {        // This cast is correct because the array we&apos;re creating        // is of the same type as the one passed in, which is T[].        @SuppressWarnings(&quot;unchecked&quot;) T[] result =            (T[]) Arrays.copyOf(elements, size, a.getClass());        return result;    }    System.arraycopy(elements, 0, a, 0, size);    if (a.length &gt; size)        a[size] = null;    return a;}</code></pre><p>　　所产生的方法干净地编译，并最小化未经检查的警告被抑制的范围。<br>　　<strong><em>每当使用 @SuppressWarnings(“unchecked”) 注解时，请添加注释，说明为什么是安全的。</em></strong> 这将有助于他人理解代码，更重要的是，这将减少有人修改代码的可能性，从而使计算不安全。 如果你觉得很难写这样的注释，请继续思考。 毕竟，你最终可能会发现未经检查的操作是不安全的。</p><p>　　总之，未经检查的警告是重要的。 不要忽视他们。 每个未经检查的警告代表在运行时出现 ClassCastException 异常的可能性。 尽你所能消除这些警告。 如果无法消除未经检查的警告，并且可以证明引发该警告的代码是安全类型的，则可以在尽可能小的范围内使用 @SuppressWarnings(“unchecked”) 注解来禁止警告。 记录你决定在注释中抑制此警告的理由。</p><h1 id="列表优于数组"><a href="#列表优于数组" class="headerlink" title="列表优于数组"></a>列表优于数组</h1><p>　　数组在两个重要方面与泛型不同。 首先，数组是协变的（covariant）。 这个吓人的单词意味着如果 Sub 是 Super 的子类型，则数组类型 Sub[] 是数组类型 Super[] 的子类型。 相比之下，泛型是不变的（invariant）：对于任何两种不同的类型 Type1 和 Type2，List<type1> 既不是 List<type2> 的子类型也不是父类型。[JLS，4.10; Naftalin07, 2.5]。 你可能认为这意味着泛型是不足的，但可以说是数组缺陷。 这段代码是合法的：</type2></type1></p><pre><code>// Fails at runtime!Object[] objectArray = new Long[1];objectArray[0] = &quot;I don&apos;t fit in&quot;; // Throws ArrayStoreException</code></pre><p>　　但这个不是：</p><pre><code>// Won&apos;t compile!List&lt;Object&gt; ol = new ArrayList&lt;Long&gt;(); // Incompatible typesol.add(&quot;I don&apos;t fit in&quot;);</code></pre><p>　　无论哪种方式，你不能把一个 String 类型放到一个 Long 类型容器中，但是用一个数组，你会发现在运行时产生了一个错误；对于列表，可以在编译时就能发现错误。 当然，你宁愿在编译时找出错误。</p><p>　　数组和泛型之间的第二个主要区别是数组被具体化了（reified）[JLS，4.7]。 这意味着数组在运行时知道并强制执行它们的元素类型。 如前所述，如果尝试将一个 String 放入 Long 数组中，得到一个 ArrayStoreException 异常。 相反，泛型通过擦除（erasure）来实现[JLS，4.6]。 这意味着它们只在编译时执行类型约束，并在运行时丢弃（或擦除）它们的元素类型信息。 擦除是允许泛型类型与不使用泛型的遗留代码自由互操作（详见第 26 条），从而确保在 Java 5 中平滑过渡到泛型。</p><p>　　由于这些基本差异，数组和泛型不能很好地在一起混合使用。 例如，创建泛型类型的数组，参数化类型的数组，以及类型参数的数组都是非法的。 因此，这些数组创建表达式都不合法：new List<e>[]，new List<string>[]，new E[]。 所有将在编译时导致泛型数组创建错误。</string></e></p><p>　　为什么创建一个泛型数组是非法的？ 因为它不是类型安全的。 如果这是合法的，编译器生成的强制转换程序在运行时可能会因为 ClassCastException 异常而失败。 这将违反泛型类型系统提供的基本保证。</p><p>　　为了具体说明，请考虑下面的代码片段：</p><pre><code>// Why generic array creation is illegal - won&apos;t compile!List&lt;String&gt;[] stringLists = new List&lt;String&gt;[1];  // (1)List&lt;Integer&gt; intList = List.of(42);               // (2)Object[] objects = stringLists;                    // (3)objects[0] = intList;                              // (4)String s = stringLists[0].get(0);                  // (5)</code></pre><p>　　让我们假设第 1 行创建一个泛型数组是合法的。第 2 行创建并初始化包含单个元素的 List<integer>。第 3 行将 List<string> 数组存储到 Object 数组变量中，这是合法的，因为数组是协变的。第 4 行将 List<integer> 存储在 Object 数组的唯一元素中，这是因为泛型是通过擦除来实现的：List<integer> 实例的运行时类型仅仅是 List，而 List<string>[] 实例是 List[]，所以这个赋值不会产生 ArrayStoreException 异常。现在我们遇到了麻烦。将一个 List<integer> 实例存储到一个声明为仅保存 List<string> 实例的数组中。在第 5 行中，我们从这个数组的唯一列表中检索唯一的元素。编译器自动将检索到的元素转换为 String，但它是一个 Integer，所以我们在运行时得到一个 ClassCastException 异常。为了防止发生这种情况，第 1 行（创建一个泛型数组）必须产生一个编译时错误。</string></integer></string></integer></integer></string></integer></p><p>　　类型 E，List<e> 和 List<string> 等在技术上被称为不可具体化的类型（nonreifiable types）[JLS，4.7]。 直观地说，不可具体化的类型是其运行时表示包含的信息少于其编译时表示的类型。 由于擦除，可唯一确定的参数化类型是无限定通配符类型，如 List<?> 和 Map<?, ?>（详见第 26 条）。 尽管很少有用，创建无限定通配符类型的数组是合法的。</string></e></p><p>　　禁止泛型数组的创建可能会很恼人的。 这意味着，例如，泛型集合通常不可能返回其元素类型的数组（但是参见条目 33 中的部分解决方案）。 这也意味着，当使用可变参数方法（详见第 53 条）和泛型时，会产生令人困惑的警告。 这是因为每次调用可变参数方法时，都会创建一个数组来保存可变参数。 如果此数组的元素类型不可确定，则会收到警告。 SafeVarargs 注解可以用来解决这个问题（详见第 32 条）。</p><p>　　当你在强制转换为数组类型时，得到泛型数组创建错误，或是未经检查的强制转换警告时，最佳解决方案通常是使用集合类型 List<e> 而不是数组类型 E[]。 这样可能会牺牲一些简洁性或性能，但作为交换，你会获得更好的类型安全性和互操作性。</e></p><p>　　例如，假设你想用带有集合的构造方法来编写一个 Chooser 类，并且有个方法返回随机选择的集合的一个元素。 根据传递给构造方法的集合，可以使用选择器作为游戏模具，魔术 8 球或数据源进行蒙特卡罗模拟。 这是一个没有泛型的简单实现：</p><pre><code>// Chooser - a class badly in need of generics!public class Chooser {    private final Object[] choiceArray;    public Chooser(Collection choices) {        choiceArray = choices.toArray();    }    public Object choose() {        Random rnd = ThreadLocalRandom.current();        return choiceArray[rnd.nextInt(choiceArray.length)];    }}</code></pre><p>　　要使用这个类，每次调用方法时，都必须将 Object 的 choose 方法的返回值转换为所需的类型，如果类型错误，则转换在运行时失败。 我们先根据条目 29 的建议，试图修改 Chooser 类，使其成为泛型的。</p><pre><code>// A first cut at making Chooser generic - won&apos;t compilepublic class Chooser&lt;T&gt; {    private final T[] choiceArray;    public Chooser(Collection&lt;T&gt; choices) {        choiceArray = choices.toArray();    }    // choose method unchanged}</code></pre><p>　　如果你尝试编译这个类，会得到这个错误信息：</p><pre><code>Chooser.java:9: error: incompatible types: Object[] cannot beconverted to T[]        choiceArray = choices.toArray();                                     ^  where T is a type-variable:    T extends Object declared in class Chooser</code></pre><p>　　没什么大不了的，将 Object 数组转换为 T 数组：</p><pre><code>choiceArray = (T[]) choices.toArray();</code></pre><p>　　这没有了错误，而是得到一个警告：</p><pre><code>Chooser.java:9: warning: [unchecked] unchecked cast        choiceArray = (T[]) choices.toArray();                                           ^  required: T[], found: Object[]  where T is a type-variable:T extends Object declared in class Chooser</code></pre><p>　　编译器告诉你在运行时不能保证强制转换的安全性，因为程序不会知道 T 代表什么类型——记住，元素类型信息在运行时会被泛型删除。 该程序可以正常工作吗？ 是的，但编译器不能证明这一点。 你可以证明这一点，在注释中提出证据，并用注解来抑制警告，但最好是消除警告的原因（详见第 27 条）。</p><p>　　要消除未经检查的强制转换警告，请使用列表而不是数组。 下面是另一个版本的 Chooser 类，编译时没有错误或警告：</p><pre><code>// List-based Chooser - typesafepublic class Chooser&lt;T&gt; {    private final List&lt;T&gt; choiceList;    public Chooser(Collection&lt;T&gt; choices) {        choiceList = new ArrayList&lt;&gt;(choices);    }    public T choose() {        Random rnd = ThreadLocalRandom.current();        return choiceList.get(rnd.nextInt(choiceList.size()));    }}</code></pre><p>　　这个版本有些冗长，也许运行比较慢，但是值得一提的是，在运行时不会得到 ClassCastException 异常。</p><p>　　总之，数组和泛型具有非常不同的类型规则。 数组是协变和具体化的; 泛型是不变的，类型擦除的。 因此，数组提供运行时类型的安全性，但不提供编译时类型的安全性，反之亦然。 一般来说，数组和泛型不能很好地混合工作。 如果你发现把它们混合在一起，得到编译时错误或者警告，你的第一个冲动应该是用列表来替换数组。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="http://sjsdfg.gitee.io/effective-java-3rd-chinese/#/notes/27.%20%E6%B6%88%E9%99%A4%E9%9D%9E%E6%A3%80%E6%9F%A5%E8%AD%A6%E5%91%8A" target="_blank" rel="noopener">http://sjsdfg.gitee.io/effective-java-3rd-chinese/#/notes/27.%20%E6%B6%88%E9%99%A4%E9%9D%9E%E6%A3%80%E6%9F%A5%E8%AD%A6%E5%91%8A</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第五章阅读： 泛型&lt;/p&gt;
&lt;p&gt;27.消除非检查警告&lt;br&gt;未经检查的警告是重要的。 不要忽视他们。 每个未经检查的警告代表在运行时出现 ClassCastException 异常的可能性。 尽可能消除这些警告。 如果无法消除未经检查的警告，并且可以证明引发该警告的代码是安全类型的，则可以在尽可能小的范围内使用 @SuppressWarnings(“unchecked”) 注解来禁止警告。 记录决定在注释中抑制此警告的理由。&lt;br&gt;28.列表优于数组&lt;br&gt;数组和泛型具有非常不同的类型规则。 数组是协变的（covariant），被具体化了（reified），数组是协变和具体化的; 泛型是不变的，类型擦除的。 因此，数组提供运行时类型的安全性，但不提供编译时类型的安全性，反之亦然。 一般来说，数组和泛型不能很好地混合工作。 如果发现把它们混合在一起，得到编译时错误或者警告，应该首先用列表来替换数组。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Effective-Java阅读笔记XIII</title>
    <link href="http://yoursite.com/2020/01/16/Effective-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0XIII/"/>
    <id>http://yoursite.com/2020/01/16/Effective-Java阅读笔记XIII/</id>
    <published>2020-01-16T15:14:12.000Z</published>
    <updated>2020-01-17T01:50:19.117Z</updated>
    
    <content type="html"><![CDATA[<p>第四章阅读：类和接口</p><p>25.将源文件限制为单个顶级类<br>永远不要将多个顶级类或接口放在一个源文件中。 遵循这个规则保证在编译时不能有多个定义。 这又保证了编译生成的类文件以及生成的程序的行为与源文件传递给编译器的顺序无关。</p><p>第五章阅读： 泛型<br>泛型实现了参数化类型，这样编写的组件（通常是集合）可以适用于多种类型。“泛型”这个术语的含义是“适用于很多类型”。编程语言中泛型出现的初衷是通过解耦类或方法与所使用的类型之间的约束，使得类或方法具备最宽泛的表达力。</p><p>26.不要使用原始类型<br>使用原始类型可能导致运行时异常，所以不要使用它们。 原始类型只是为了与引入泛型机制之前的遗留代码进行兼容和互用而提供的。Set<object> 是一个参数化类型，表示一个可以包含任何类型对象的集合，Set&lt;?&gt; 是一个通配符类型，表示一个只能包含某些未知类型对象的集合，Set 是一个原始类型，它不在泛型类型系统之列。 前两个类型是安全的，最后一个不是。</object></p><a id="more"></a><h1 id="将源文件限制为单个顶级类"><a href="#将源文件限制为单个顶级类" class="headerlink" title="将源文件限制为单个顶级类"></a>将源文件限制为单个顶级类</h1><p>　　虽然 Java 编译器允许在单个源文件中定义多个顶级类，但这样做没有任何好处，并且存在重大风险。 风险源于在源文件中定义多个顶级类使得为类提供多个定义成为可能。 使用哪个定义会受到源文件传递给编译器的顺序的影响。<br>　　为了具体说明，请考虑下面源文件，其中只包含一个引用其他两个顶级类（Utensil 和 Dessert 类）的成员的 Main 类：</p><pre><code>public class Main {    public static void main(String[] args) {        System.out.println(Utensil.NAME + [Dessert.NAME](http://Dessert.NAME));    }}</code></pre><p>　　现在假设在 Utensil.java 的源文件中同时定义了 Utensil 和 Dessert：</p><pre><code>// Two classes defined in one file. Don&apos;t ever do this!class Utensil {    static final String NAME = &quot;pan&quot;;}class Dessert {    static final String NAME = &quot;cake&quot;;}当然，main 方法会打印 pancake。</code></pre><p>　　现在假设你不小心创建了另一个名为 Dessert.java 的源文件，它定义了相同的两个类：</p><pre><code>// Two classes defined in one file. Don&apos;t ever do this!class Utensil {    static final String NAME = &quot;pot&quot;;}class Dessert {    static final String NAME = &quot;pie&quot;;}</code></pre><p>　　如果你足够幸运，使用命令 javac Main.java Dessert.java 编译程序，编译将失败，编译器会告诉你，你已经多次定义了类 Utensil 和 Dessert。 这是因为编译器首先编译 Main.java，当它看到对 Utensil 的引用（它在 Dessert 的引用之前）时，它将在 Utensil.java 中查找这个类并找到 Utensil 和 Dessert。 当编译器在命令行上遇到 Dessert.java 时，它也将拉入该文件，导致它遇到 Utensil 和 Dessert 的定义。</p><p>　　如果使用命令 javac Main.java 或 javac Main.java Utensil.java 编译程序，它的行为与在编写 Dessert.java 文件（即打印 pancake）之前的行为相同。 但是，如果使用命令 javac Dessert.java Main.java 编译程序，它将打印 potpie。 程序的行为因此受到源文件传递给编译器的顺序的影响，这显然是不可接受的。</p><p>　　解决这个问题很简单，将顶层类（如我们的例子中的 Utensil 和 Dessert）分割成单独的源文件。 如果试图将多个顶级类放入单个源文件中，请考虑使用静态成员类（详见第 24 条）作为将类拆分为单独的源文件的替代方法。 如果这些类从属于另一个类，那么将它们变成静态成员类通常是更好的选择，因为它提高了可读性，并且可以通过声明它们为私有（详见第 15 条）来减少类的可访问性。下面是我们的例子看起来如何使用静态成员类：</p><pre><code>// Static member classes instead of multiple top-level classespublic class Test {    public static void main(String[] args) {        System.out.println(Utensil.NAME + [Dessert.NAME](http://Dessert.NAME));    }    private static class Utensil {        static final String NAME = &quot;pan&quot;;    }    private static class Dessert {        static final String NAME = &quot;cake&quot;;    }}</code></pre><p>　　这个教训很清楚：永远不要将多个顶级类或接口放在一个源文件中。 遵循这个规则保证在编译时不能有多个定义。 这又保证了编译生成的类文件以及生成的程序的行为与源文件传递给编译器的顺序无关。</p><h1 id="不要使用原始类型"><a href="#不要使用原始类型" class="headerlink" title="不要使用原始类型"></a>不要使用原始类型</h1><p>　　首先，有几个术语。一个类或接口，它的声明有一个或多个类型参数（type parameters ），被称之为泛型类或泛型接口。 例如，List 接口具有单个类型参数 E，表示其元素类型。 接口的全名是 List<e>（读作「E」的列表），但是人们经常称它为 List。 泛型类和接口统称为泛型类型（generic types）。</e></p><p>　　每个泛型定义了一组参数化类型（parameterized types），它们由类或接口名称组成，后跟一个与泛型类型的形式类型参数[JLS，4.4,4.5] 相对应的实际类型参数的尖括号「&lt;&gt;」列表。 例如，List<string>（读作「字符串列表」）是一个参数化类型，表示其元素类型为 String 的列表。 （String 是与形式类型参数 E 相对应的实际类型参数）。</string></p><p>　　最后，每个泛型定义了一个原始类型（raw type），它是没有任何类型参数的泛型类型的名称[JLS，4.8]。 例如，对应于 List<e> 的原始类型是 List。 原始类型的行为就像所有的泛型类型信息都从类型声明中被清除一样。 它们的存在主要是为了与没有泛型之前的代码相兼容。</e></p><p>　　在泛型被添加到 Java 之前，这是一个典型的集合声明。 从 Java 9 开始，它仍然是合法的，但并不是典型的声明方式了：</p><pre><code>// Raw collection type - don&apos;t do this!// My stamp collection. Contains only Stamp instances.private final Collection stamps = ... ;</code></pre><p>　　如果你今天使用这个声明，然后不小心把 coin 实例放入你的 stamp 集合中，错误的插入编译和运行没有错误（尽管编译器发出一个模糊的警告）：</p><pre><code>// Erroneous insertion of coin into stamp collectionstamps.add(new Coin( ... )); // Emits &quot;unchecked call&quot; warning</code></pre><p>　　直到您尝试从 stamp 集合中检索 coin 实例时才会发生错误：</p><pre><code>// Raw iterator type - don&apos;t do this!for (Iterator i = stamps.iterator(); i.hasNext(); )    Stamp stamp = (Stamp) i.next(); // Throws ClassCastException        stamp.cancel();</code></pre><p>　　正如本书所提到的，在编译完成之后尽快发现错误是值得的，理想情况是在编译时。 在这种情况下，直到运行时才发现错误，在错误发生后的很长一段时间，以及可能远离包含错误的代码的代码中。 一旦看到 ClassCastException，就必须搜索代码类库，查找将 coin 实例放入 stamp 集合的方法调用。 编译器不能帮助你，因为它不能理解那个说「仅包含 stamp 实例」的注释。<br>　　对于泛型，类型声明包含的信息，而不是注释：</p><pre><code>// Parameterized collection type - typesafeprivate final Collection&lt;Stamp&gt; stamps = ... ;</code></pre><p>　　从这个声明中，编译器知道 stamps 集合应该只包含 Stamp 实例，并保证它是 true，假设你的整个代码类库编译时不发出（或者抑制；参见条目 27）任何警告。 当使用参数化类型声明声明 stamps 时，错误的插入会生成一个编译时错误消息，告诉你到底发生了什么错误：</p><pre><code>Test.java:9: error: incompatible types: Coin cannot be convertedto Stamp    c.add(new Coin());              ^</code></pre><p>　　当从集合中检索元素时，编译器会为你插入不可见的强制转换，并保证它们不会失败（再假设你的所有代码都不会生成或禁止任何编译器警告）。 虽然意外地将 coin 实例插入 stamp 集合的预期可能看起来很牵强，但这个问题是真实的。 例如，很容易想象将 BigInteger 放入一个只包含 BigDecimal 实例的集合中。</p><p>　　如前所述，使用原始类型（没有类型参数的泛型）是合法的，但是你不应该这样做。<br><strong><em>如果你使用原始类型，则会丧失泛型的所有安全性和表达上的优势。</em></strong> 鉴于你不应该使用它们，为什么语言设计者首先允许原始类型呢？ 答案是为了兼容性。 泛型被添加时，Java 即将进入第二个十年，并且有大量的代码没有使用泛型。 所有这些代码都是合法的，并且与使用泛型的新代码进行交互操作被认为是至关重要的。 将参数化类型的实例传递给为原始类型设计的方法必须是合法的，反之亦然。 这个需求，被称为迁移兼容性，驱使决策支持原始类型，并使用擦除来实现泛型（详见第 28 条）。</p><p>　　虽然不应使用诸如 List 之类的原始类型，但可以使用参数化类型来允许插入任意对象（如 List<object>）。 原始类型 List 和参数化类型 List<object> 之间有什么区别？ 松散地说，前者已经选择了泛型类型系统，而后者明确地告诉编译器，它能够保存任何类型的对象。 虽然可以将 List<string> 传递给 List 类型的参数，但不能将其传递给 List<object> 类型的参数。 泛型有子类型的规则，List<string> 是原始类型 List 的子类型，但不是参数化类型 List<object> 的子类型（条目 28）。 因此，如果使用诸如 List 之类的原始类型，则会丢失类型安全性，但是如果使用参数化类型（例如 List<object>）则不会。</object></object></string></object></string></object></object></p><p>　　为了具体说明，请考虑以下程序：</p><pre><code>// Fails at runtime - unsafeAdd method uses a raw type (List)!public static void main(String[] args) {    List&lt;String&gt; strings = new ArrayList&lt;&gt;();    unsafeAdd(strings, Integer.valueOf(42));    String s = strings.get(0); // Has compiler-generated cast}private static void unsafeAdd(List list, Object o) {    list.add(o);}</code></pre><p>　　此程序可以编译，它使用原始类型列表，但会收到警告：</p><pre><code>Test.java:10: warning: [unchecked] unchecked call to add(E) as amember of the raw type List    list.add(o);            ^</code></pre><p>　　实际上，如果运行该程序，则当程序尝试调用 strings.get(0) 的结果（一个 Integer）转换为一个 String 时，会得到 ClassCastException 异常。 这是一个编译器生成的强制转换，因此通常会保证成功，但在这种情况下，我们忽略了编译器警告并付出了代价。</p><p>　　如果用 unsafeAdd 声明中的参数化类型 List<object> 替换原始类型 List，并尝试重新编译该程序，则会发现它不再编译，而是发出错误消息：</object></p><pre><code>Test.java:5: error: incompatible types: List&lt;String&gt; cannot beconverted to List&lt;Object&gt;    unsafeAdd(strings, Integer.valueOf(42));</code></pre><p>　　你可能会试图使用原始类型来处理元素类型未知且无关紧要的集合。 例如，假设你想编写一个方法，它需要两个集合并返回它们共同拥有的元素的数量。 如果是泛型新手，那么您可以这样写：</p><pre><code>// Use of raw type for unknown element type - don&apos;t do this!static int numElementsInCommon(Set s1, Set s2) {    int result = 0;    for (Object o1 : s1)        if (s2.contains(o1))            result++;    return result;}</code></pre><p>　　这种方法可以工作，但它使用原始类型，这是危险的。 安全替代方式是使用无限制通配符类型（unbounded wildcard types）。 如果要使用泛型类型，但不知道或关心实际类型参数是什么，则可以使用问号来代替。 例如，泛型类型 Set<e> 的无限制通配符类型是 Set&lt;?&gt;（读取「某种类型的集合」）。 它是最通用的参数化的 Set 类型，能够保持任何集合。 下面是 numElementsInCommon 方法使用无限制通配符类型声明的情况：</e></p><pre><code>// Uses unbounded wildcard type - typesafe and flexiblestatic int numElementsInCommon(Set&lt;?&gt; s1, Set&lt;?&gt; s2) { ... }</code></pre><p>　　无限制通配符 Set<?> 与原始类型 Set 之间有什么区别？ 问号真的给你放任何东西吗？ 这不是要点，但通配符类型是安全的，原始类型不是。 你可以将任何元素放入具有原始类型的集合中，轻易破坏集合的类型不变性（如第 119 页上的 unsafeAdd 方法所示）; 你不能把任何元素（除 null 之外）放入一个 Collection<?> 中。 试图这样做会产生一个像这样的编译时错误消息：</p><pre><code>WildCard.java:13: error: incompatible types: String cannot beconverted to CAP#1    c.add(&quot;verboten&quot;);          ^  where CAP#1 is a fresh type-variable:    CAP#1 extends Object from capture of ?</code></pre><p>　　不可否认的是，这个错误信息留下了一些需要的东西，但是编译器已经完成了它的工作，不管它的元素类型是什么，都不会破坏集合的类型不变性。 你不仅不能将任何元素（除 null 以外）放入一个 Collection&lt;?&gt; 中，并且根本无法猜测你会得到那种类型的对象。 如果这些限制是不可接受的，可以使用泛型方法（详见第 30 条）或有限制的通配符类型（详见第 31 条）。</p><p>　　对于不应该使用原始类型的规则，有一些小例外。 <strong><em>你必须在类字面值（class literals）中使用原始类型。</em></strong>  规范中不允许使用参数化类型（尽管它允许数组类型和基本类型）[JLS，15.8.2]。 换句话说，List.class，String[].class 和 int.class 都是合法的，但 List<string>.class 和 List&lt;?&gt;.class 都是不合法的。</string></p><p>　　规则的第二个例外与 instanceof 操作符有关。 因为泛型类型信息在运行时被擦除，所以在无限制通配符类型以外的参数化类型上使用 instanceof 运算符是非法的。 使用无限制通配符类型代替原始类型，不会对 instanceof 运算符的行为产生任何影响。 在这种情况下，尖括号（&lt;&gt;）和问号（?）就显得多余。 <strong><em>以下是使用泛型类型的 instanceof 运算符的首选方法</em></strong>：</p><pre><code>// Legitimate use of raw type - instanceof operatorif (o instanceof Set) {       // Raw type    Set&lt;?&gt; s = (Set&lt;?&gt;) o;    // Wildcard type    ...}</code></pre><p>　　请注意，一旦确定 o 对象是一个 Set，则必须将其转换为通配符 Set&lt;?&gt;，而不是原始类型 Set。 这是一个受检查的（checked）转换，所以不会导致编译器警告。</p><p>　　总之，使用原始类型可能导致运行时异常，所以不要使用它们。 原始类型只是为了与引入泛型机制之前的遗留代码进行兼容和互用而提供的。 作为一个快速回顾，Set<object> 是一个参数化类型，表示一个可以包含任何类型对象的集合，Set&lt;?&gt; 是一个通配符类型，表示一个只能包含某些未知类型对象的集合，Set 是一个原始类型，它不在泛型类型系统之列。 前两个类型是安全的，最后一个不是。</object></p><p>　　为了快速参考，下表中总结了本条目（以及本章稍后介绍的一些）中介绍的术语：</p><pre><code>术语           中文含义       举例                 所在条目Parameterized type    参数化类型    List&lt;String&gt;    条目 26Actual type parameter    实际类型参数    String    条目 26Generic type    泛型类型    List&lt;E&gt;    条目 26 和 条目 29Formal type parameter    形式类型参数    E    条目 26Unbounded wildcard type    无限制通配符类型    List&lt;?&gt;    条目 26Raw type    原始类型    List    条目 26Bounded type parameter    限制类型参数    &lt;E extends Number&gt;    条目 29Recursive type bound    递归类型限制    &lt;T extends Comparable&lt;T&gt;&gt;    条目 30Bounded wildcard type    限制通配符类型    List&lt;? extends Number&gt;    条目 31Generic method    泛型方法    static &lt;E&gt; List&lt;E&gt; asList(E[] a)    条目 30Type token    类型令牌    String.class    条目 33</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="http://sjsdfg.gitee.io/effective-java-3rd-chinese/#/notes/25.%20%E5%B0%86%E6%BA%90%E6%96%87%E4%BB%B6%E9%99%90%E5%88%B6%E4%B8%BA%E5%8D%95%E4%B8%AA%E9%A1%B6%E7%BA%A7%E7%B1%BB?id=_25-%e5%b0%86%e6%ba%90%e6%96%87%e4%bb%b6%e9%99%90%e5%88%b6%e4%b8%ba%e5%8d%95%e4%b8%aa%e9%a1%b6%e7%ba%a7%e7%b1%bb" target="_blank" rel="noopener">http://sjsdfg.gitee.io/effective-java-3rd-chinese/#/notes/25.%20%E5%B0%86%E6%BA%90%E6%96%87%E4%BB%B6%E9%99%90%E5%88%B6%E4%B8%BA%E5%8D%95%E4%B8%AA%E9%A1%B6%E7%BA%A7%E7%B1%BB?id=_25-%e5%b0%86%e6%ba%90%e6%96%87%e4%bb%b6%e9%99%90%e5%88%b6%e4%b8%ba%e5%8d%95%e4%b8%aa%e9%a1%b6%e7%ba%a7%e7%b1%bb</a><br>【2】<a href="https://lingcoder.github.io/OnJava8/#/book/20-Generics?id=%e7%ae%80%e5%8d%95%e6%b3%9b%e5%9e%8b" target="_blank" rel="noopener">https://lingcoder.github.io/OnJava8/#/book/20-Generics?id=%e7%ae%80%e5%8d%95%e6%b3%9b%e5%9e%8b</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第四章阅读：类和接口&lt;/p&gt;
&lt;p&gt;25.将源文件限制为单个顶级类&lt;br&gt;永远不要将多个顶级类或接口放在一个源文件中。 遵循这个规则保证在编译时不能有多个定义。 这又保证了编译生成的类文件以及生成的程序的行为与源文件传递给编译器的顺序无关。&lt;/p&gt;
&lt;p&gt;第五章阅读： 泛型&lt;br&gt;泛型实现了参数化类型，这样编写的组件（通常是集合）可以适用于多种类型。“泛型”这个术语的含义是“适用于很多类型”。编程语言中泛型出现的初衷是通过解耦类或方法与所使用的类型之间的约束，使得类或方法具备最宽泛的表达力。&lt;/p&gt;
&lt;p&gt;26.不要使用原始类型&lt;br&gt;使用原始类型可能导致运行时异常，所以不要使用它们。 原始类型只是为了与引入泛型机制之前的遗留代码进行兼容和互用而提供的。Set&lt;object&gt; 是一个参数化类型，表示一个可以包含任何类型对象的集合，Set&amp;lt;?&amp;gt; 是一个通配符类型，表示一个只能包含某些未知类型对象的集合，Set 是一个原始类型，它不在泛型类型系统之列。 前两个类型是安全的，最后一个不是。&lt;/object&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Effective-Java阅读笔记XII</title>
    <link href="http://yoursite.com/2020/01/16/Effective-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0XII/"/>
    <id>http://yoursite.com/2020/01/16/Effective-Java阅读笔记XII/</id>
    <published>2020-01-16T09:17:12.000Z</published>
    <updated>2020-01-17T01:50:19.117Z</updated>
    
    <content type="html"><![CDATA[<p>第四章阅读：类和接口</p><p>23.类层次结构优于标签类<br>当遇到一个带有标签字段的现有类时，可以考虑将其重构为一个类层次结构。<br>24.支持使用静态成员类而不是非静态类<br>有四种不同的嵌套类：静态成员类，非静态成员类，匿名类和局部类。每个都有它的用途。 如果一个嵌套的类需要在一个方法之外可见，或者太长而不能很好地适应一个方法，使用一个成员类。 如果一个成员类的每个实例都需要一个对其宿主实例的引用，使其成为非静态的; 否则，使其静态。 假设这个类属于一个方法内部，如果你只需要从一个地方创建实例，并且存在一个预置类型来说明这个类的特征，那么把它作为一个匿名类；否则，把它变成局部类</p><a id="more"></a><h1 id="类层次结构优于标签类"><a href="#类层次结构优于标签类" class="headerlink" title="类层次结构优于标签类"></a>类层次结构优于标签类</h1><p>　　有时你可能会碰到一个类，它的实例有两个或更多的风格，并且包含一个标签字段（tag field），表示实例的风格。 例如，考虑这个类，它可以表示一个圆形或矩形：</p><pre><code>// Tagged class - vastly inferior to a class hierarchy!class Figure {    enum Shape { RECTANGLE, CIRCLE };    // Tag field - the shape of this figure    final Shape shape;    // These fields are used only if shape is RECTANGLE    double length;    double width;    // This field is used only if shape is CIRCLE    double radius;    // Constructor for circle    Figure(double radius) {        shape = Shape.CIRCLE;        this.radius = radius;    }    // Constructor for rectangle    Figure(double length, double width) {        shape = Shape.RECTANGLE;        this.length = length;        this.width = width;    }    double area() {        switch(shape) {          case RECTANGLE:            return length * width;          case CIRCLE:            return Math.PI * (radius * radius);          default:            throw new AssertionError(shape);        }    }}</code></pre><p>　　这样的标签类具有许多缺点。 它们充斥着杂乱无章的样板代码，包括枚举声明，标签字段和 switch 语句。 可读性更差，因为多个实现在一个类中混杂在一起。 内存使用增加，因为实例负担属于其他风格不相关的领域。 字段不能成为 final，除非构造方法初始化不相关的字段，导致更多的样板代码。 构造方法在编译器的帮助下，必须设置标签字段并初始化正确的数据字段：如果初始化错误的字段，程序将在运行时失败。 除非可以修改其源文件，否则不能将其添加到标记的类中。 如果你添加一个风格，你必须记得给每个 switch 语句添加一个 case，否则这个类将在运行时失败。 最后，一个实例的数据类型没有提供任何关于风格的线索。 总之，<strong><em>标签类是冗长的，容易出错的，而且效率低下。</em></strong><br>　　幸运的是，像 Java 这样的面向对象的语言为定义一个能够表示多种风格对象的单一数据类型提供了更好的选择：子类型化（subtyping）。标签类仅仅是一个类层次的简单的模仿。</p><p>　　要将标签类转换为类层次，首先定义一个包含抽象方法的抽象类，该标签类的行为取决于标签值。 在 Figure 类中，只有一个这样的方法，就是 area 方法。 这个抽象类是类层次的根。 如果有任何方法的行为不依赖于标签的值，把它们放在这个类中。 同样，如果有所有的方法使用的数据字段，把它们放在这个类。Figure 类中不存在这种与类型无关的方法或字段。</p><p>　　接下来，为原始标签类的每种类型定义一个根类的具体子类。 在我们的例子中，有两个类型：圆形和矩形。 在每个子类中包含特定于改类型的数据字段。 在我们的例子中，半径字段是属于圆的，长度和宽度字段都是矩形的。 还要在每个子类中包含根类中每个抽象方法的适当实现。 这里是对应于 Figure 类的类层次：</p><pre><code>// Class hierarchy replacement for a tagged classabstract class Figure {    abstract double area();}class Circle extends Figure {    final double radius;    Circle(double radius) { this.radius = radius; }    @Override double area() { return Math.PI * (radius * radius); }}class Rectangle extends Figure {    final double length;    final double width;    Rectangle(double length, double width) {        this.length = length;        this.width  = width;    }    @Override double area() { return length * width; }}</code></pre><p>　　这个类层次纠正了之前提到的标签类的每个缺点。 代码简单明了，不包含原文中的样板文件。 每种类型的实现都是由自己的类来分配的，而这些类都没有被无关的数据字段所占用。 所有的字段是 final 的。 编译器确保每个类的构造方法初始化其数据字段，并且每个类都有一个针对在根类中声明的每个抽象方法的实现。 这消除了由于缺少 switch-case 语句而导致的运行时失败的可能性。 多个程序员可以独立地继承类层次，并且可以相互操作，而无需访问根类的源代码。 每种类型都有一个独立的数据类型与之相关联，允许程序员指出变量的类型，并将变量和输入参数限制为特定的类型。</p><p>　　类层次的另一个优点是可以使它们反映类型之间的自然层次关系，从而提高了灵活性，并提高了编译时类型检查的效率。 假设原始示例中的标签类也允许使用正方形。 类层次可以用来反映一个正方形是一种特殊的矩形（假设它们是不可变的）：</p><pre><code>class Square extends Rectangle {    Square(double side) {        super(side, side);    }}</code></pre><p>　　请注意，上述层次结构中的字段是直接访问的，而不是通过访问器方法访问的。 这里是为了简洁起见，如果类层次是公开的（详见第 16 条），这将是一个糟糕的设计。</p><p>　　总之，标签类很少有适用的情况。 如果你想写一个带有显式标签字段的类，请考虑标签字段是否可以被删除，并是否能被类层次结构替换。 当遇到一个带有标签字段的现有类时，可以考虑将其重构为一个类层次结构。</p><h1 id="支持使用静态成员类而不是非静态类"><a href="#支持使用静态成员类而不是非静态类" class="headerlink" title="支持使用静态成员类而不是非静态类"></a>支持使用静态成员类而不是非静态类</h1><p>　　嵌套类（nested class）是在另一个类中定义的类。 嵌套类应该只存在于其宿主类（enclosing class）中。 如果一个嵌套类在其他一些情况下是有用的，那么它应该是一个顶级类。 有四种嵌套类：静态成员类，非静态成员类，匿名类和局部类。 除了第一种以外，剩下的三种都被称为 <strong><em>内部类（inner class）</em></strong>。 这个条目告诉你什么时候使用哪种类型的嵌套类以及为什么使用。</p><p>　　静态成员类是最简单的嵌套类。 最好把它看作是一个普通的类，恰好在另一个类中声明，并且可以访问所有宿主类的成员，甚至是那些被声明为私有类的成员。 静态成员类是其宿主类的静态成员，并遵循与其他静态成员相同的可访问性规则。 如果它被声明为 private，则只能在宿主类中访问，等等。</p><p>　　静态成员类的一个常见用途是作为公共帮助类，仅在与其外部类一起使用时才有用。 例如，考虑一个描述计算器支持的操作的枚举类型（详见第 34 条）。 Operation 枚举应该是 Calculator 类的公共静态成员类。 Calculator 客户端可以使用 Calculator.Operation.PLUS 和 Calculator.Operation.MINUS 等名称来引用操作。</p><p>　　在语法上，静态成员类和非静态成员类之间的唯一区别是静态成员类在其声明中具有 static 修饰符。 尽管句法相似，但这两种嵌套类是非常不同的。 非静态成员类的每个实例都隐含地与其包含的类的宿主实例相关联。 在非静态成员类的实例方法中，可以调用宿主实例上的方法，或者使用限定的构造[JLS，15.8.4] 获得对宿主实例的引用。 如果嵌套类的实例可以与其宿主类的实例隔离存在，那么嵌套类必须是静态成员类：不可能在没有宿主实例的情况下创建非静态成员类的实例。</p><p>　　非静态成员类实例和其宿主实例之间的关联是在创建成员类实例时建立的，并且之后不能被修改。 通常情况下，通过在宿主类的实例方法中调用非静态成员类构造方法来自动建立关联。 尽管很少有可能使用表达式 enclosingInstance.new MemberClass(args) 手动建立关联。 正如你所预料的那样，该关联在非静态成员类实例中占用了空间，并为其构建添加了时间开销。</p><p>　　非静态成员类的一个常见用法是定义一个 Adapter [Gamma95]，它允许将外部类的实例视为某个不相关类的实例。 例如，Map 接口的实现通常使用非静态成员类来实现它们的集合视图，这些视图由 Map 的 keySet，entrySet 和 values 方法返回。 同样，集合接口（如 Set 和 List）的实现通常使用非静态成员类来实现它们的迭代器：</p><pre><code>// Typical use of a nonstatic member classpublic class MySet&lt;E&gt; extends AbstractSet&lt;E&gt; {    ... // Bulk of the class omitted    @Override    public Iterator&lt;E&gt; iterator() {        return new MyIterator();    }    private class MyIterator implements Iterator&lt;E&gt; {        ...    }}</code></pre><p>　　<strong><em>如果你声明了一个不需要访问宿主实例的成员类，总是把 static 修饰符放在它的声明中，使它成为一个静态成员类，而不是非静态的成员类。</em></strong> 如果你忽略了这个修饰符，每个实例都会有一个隐藏的外部引用给它的宿主实例。 如前所述，存储这个引用需要占用时间和空间。 更严重的是，并且会导致即使宿主类在满足垃圾回收的条件时却仍然驻留在内存中（详见第 7 条）。 由此产生的内存泄漏可能是灾难性的。 由于引用是不可见的，所以通常难以检测到。</p><p>　　私有静态成员类的常见用法是表示由它们的宿主类表示的对象的组件。 例如，考虑将键与值相关联的 Map 实例。 许多 Map 实现对于映射中的每个键值对都有一个内部的 Entry 对象。 当每个 entry 都与 Map 关联时，entry 上的方法 (getKey，getValue 和 setValue) 不需要访问 Map。 因此，使用非静态成员类来表示 entry 将是浪费的：私有静态成员类是最好的。 如果意外地忽略了 entry 声明中的 static 修饰符，Map 仍然可以工作，但是每个 entry 都会包含对 Map 的引用，浪费空间和时间。</p><p>　　如果所讨论的类是导出类的公共或受保护成员，则在静态和非静态成员类之间正确选择是非常重要的。 在这种情况下，成员类是导出的 API 元素，如果不违反向后兼容性，就不能在后续版本中从非静态变为静态成员类。</p><p>　　正如你所期望的，一个匿名类没有名字。 它不是其宿主类的成员。 它不是与其他成员一起声明，而是在使用时同时声明和实例化。 在表达式合法的代码中，匿名类是允许的。 当且仅当它们出现在非静态上下文中时，匿名类才会封装实例。 但是，即使它们出现在静态上下文中，它们也不能有除常量型变量之外的任何静态成员，这些常量型变量包括 final 的基本类型，或者初始化常量表达式的字符串属性[JLS，4.12.4]。</p><p>　　匿名类的适用性有很多限制。 除了在声明的时候之外，不能实例化它们。 你不能执行 instanceof 方法测试或者做任何其他需要你命名的类。 不能声明一个匿名类来实现多个接口，或者继承一个类并同时实现一个接口。 匿名类的客户端不能调用除父类型继承的成员以外的任何成员。 因为匿名类在表达式中出现，所以它们必须保持简短 —— 约十行或更少 —— 否则可读性将受到影响。</p><p>　　在将 lambda 表达式添加到 Java（第 6 章）之前，匿名类是创建小函数对象和处理对象的首选方法，但 lambda 表达式现在是首选（详见第 42 条）。 匿名类的另一个常见用途是实现静态工厂方法（请参阅条目 20 中的 intArrayAsList）。</p><p>　　局部类是四种嵌套类中使用最少的。 一个局部类可以在任何可以声明局部变量的地方声明，并遵守相同的作用域规则。 局部类与其他类型的嵌套类具有共同的属性。 像成员类一样，他们有名字，可以重复使用。 就像匿名类一样，只有在非静态上下文中定义它们时，它们才会包含实例，并且它们不能包含静态成员。 像匿名类一样，应该保持简短，以免损害可读性。</p><p>　　回顾一下，有四种不同的嵌套类，每个都有它的用途。 如果一个嵌套的类需要在一个方法之外可见，或者太长而不能很好地适应一个方法，使用一个成员类。 如果一个成员类的每个实例都需要一个对其宿主实例的引用，使其成为非静态的; 否则，使其静态。 假设这个类属于一个方法内部，如果你只需要从一个地方创建实例，并且存在一个预置类型来说明这个类的特征，那么把它作为一个匿名类；否则，把它变成局部类。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="http://sjsdfg.gitee.io/effective-java-3rd-chinese/#/notes/23.%20%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E4%BC%98%E4%BA%8E%E6%A0%87%E7%AD%BE%E7%B1%BB" target="_blank" rel="noopener">http://sjsdfg.gitee.io/effective-java-3rd-chinese/#/notes/23.%20%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E4%BC%98%E4%BA%8E%E6%A0%87%E7%AD%BE%E7%B1%BB</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第四章阅读：类和接口&lt;/p&gt;
&lt;p&gt;23.类层次结构优于标签类&lt;br&gt;当遇到一个带有标签字段的现有类时，可以考虑将其重构为一个类层次结构。&lt;br&gt;24.支持使用静态成员类而不是非静态类&lt;br&gt;有四种不同的嵌套类：静态成员类，非静态成员类，匿名类和局部类。每个都有它的用途。 如果一个嵌套的类需要在一个方法之外可见，或者太长而不能很好地适应一个方法，使用一个成员类。 如果一个成员类的每个实例都需要一个对其宿主实例的引用，使其成为非静态的; 否则，使其静态。 假设这个类属于一个方法内部，如果你只需要从一个地方创建实例，并且存在一个预置类型来说明这个类的特征，那么把它作为一个匿名类；否则，把它变成局部类&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Effective-Java阅读笔记XI</title>
    <link href="http://yoursite.com/2020/01/16/Effective-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0XI/"/>
    <id>http://yoursite.com/2020/01/16/Effective-Java阅读笔记XI/</id>
    <published>2020-01-16T08:23:12.000Z</published>
    <updated>2020-01-17T01:50:19.118Z</updated>
    
    <content type="html"><![CDATA[<p>第四章阅读：类和接口</p><p>21.为后代设计接口<br>应该避免使用默认方法向现有的接口添加新的方法，除非这个需要是关键的。在默认方法的情况下，接口的现有实现类可以在没有错误或警告的情况下编译，但在运行时会失败。<br>22.接口仅用来定义类型<br>接口只能用于定义类型。 它们不应该只是被用于导出常量。</p><a id="more"></a><h1 id="为后代设计接口"><a href="#为后代设计接口" class="headerlink" title="为后代设计接口"></a>为后代设计接口</h1><p>　　在 Java 8 之前，不可能在不破坏现有实现的情况下为接口添加方法。 如果向接口添加了一个新方法，现有的实现通常会缺少该方法，从而导致编译时错误。 在 Java 8 中，添加了默认方法（default method）构造[JLS 9.4]，目的是允许将方法添加到现有的接口。 但是增加新的方法到现有的接口是充满风险的。</p><p>　　默认方法的声明包含一个默认实现，该方法允许实现接口的类直接使用，而不必实现默认方法。 虽然在 Java 中添加默认方法可以将方法添加到现有接口，但不能保证这些方法可以在所有已有的实现中使用。 默认的方法被「注入（injected）」到现有的实现中，没有经过实现类的知道或同意。 在 Java 8 之前，这些实现是用默认的接口编写的，它们的接口永远不会获得任何新的方法。</p><p>　　许多新的默认方法被添加到 Java 8 的核心集合接口中，主要是为了方便使用 lambda 表达式（第 6 章）。 Java 类库的默认方法是高质量的通用实现，在大多数情况下，它们工作正常。 但是，编写一个默认方法并不总是可能的，它保留了每个可能的实现的所有不变量。</p><p>　　例如，考虑在 Java 8 中添加到 Collection 接口的 removeIf 方法。此方法删除给定布尔方法（或 Predicate 函数式接口）返回 true 的所有元素。默认实现被指定为使用迭代器遍历集合，调用每个元素的谓词，并使用迭代器的 remove 方法删除谓词返回 true 的元素。 据推测，这个声明看起来像这样：默认实现被指定为使用迭代器遍历集合，调用每个元素的 Predicate 函数式接口，并使用迭代器的 remove 方法删除 Predicate 函数式接口返回 true 的元素。 根据推测，这个声明看起来像这样：</p><pre><code>// Default method added to the Collection interface in Java 8default boolean removeIf(Predicate&lt;? super E&gt; filter) {    Objects.requireNonNull(filter);    boolean result = false;    for (Iterator&lt;E&gt; it = iterator(); it.hasNext(); ) {        if (filter.test(it.next())) {            it.remove();            result = true;        }    }    return result;}</code></pre><p>　　这是可能为 removeIf 方法编写的最好的通用实现，但遗憾的是，它在一些实际的 Collection 实现中失败了。 例如，考虑 org.apache.commons.collections4.collection.SynchronizedCollection 方法。 这个类出自 Apache Commons 类库中，与 java.util 包中的静态工厂 Collections.synchronizedCollection 方法返回的类相似。 Apache 版本还提供了使用客户端提供的对象进行锁定的能力，以代替集合。 换句话说，它是一个包装类（条目 18），它们的所有方法在委托给包装集合类之前在一个锁定对象上进行同步。</p><p>　　Apache 的 SynchronizedCollection 类仍然在积极维护，但在撰写本文时，并未重写 removeIf 方法。 如果这个类与 Java 8 一起使用，它将继承 removeIf 的默认实现，但实际上不能保持类的基本承诺：自动同步每个方法调用。 默认实现对同步一无所知，并且不能访问包含锁定对象的属性。 如果客户端在另一个线程同时修改集合的情况下调用 SynchronizedCollection 实例上的 removeIf 方法，则可能会导致 ConcurrentModificationException 异常或其他未指定的行为。</p><p>　　为了防止在类似的 Java 平台类库实现中发生这种情况，比如 Collections.synchronizedCollection 返回的包级私有的类，JDK 维护者必须重写默认的 removeIf 实现和其他类似的方法来在调用默认实现之前执行必要的同步。 原来不属于 Java 平台的集合实现没有机会与接口更改进行类似的改变，有些还没有这样做。</p><p>　　<strong><em>在默认方法的情况下，接口的现有实现类可以在没有错误或警告的情况下编译，但在运行时会失败。</em></strong> 虽然不是非常普遍，但这个问题也不是一个孤立的事件。 在 Java 8 中添加到集合接口的一些方法已知是易受影响的，并且已知一些现有的实现会受到影响。</p><p>　　应该避免使用默认方法向现有的接口添加新的方法，除非这个需要是关键的，在这种情况下，你应该仔细考虑，以确定现有的接口实现是否会被默认的方法实现所破坏。然而，默认方法对于在创建接口时提供标准的方法实现非常有用，以减轻实现接口的任务（详见第 20 条）。</p><p>　　还值得注意的是，默认方法不是被用来设计，来支持从接口中移除方法或者改变现有方法的签名的目的。在不破坏现有客户端的情况下，这些接口都不可能发生更改。</p><p>　　准则是清楚的。 尽管默认方法现在是 Java 平台的一部分，<strong><em>但是非常悉心地设计接口仍然是非常重要的</em></strong>。 虽然默认方法可以将方法添加到现有的接口，但这样做有很大的风险。 如果一个接口包含一个小缺陷，可能会永远惹怒用户。 如果一个接口严重缺陷，可能会破坏包含它的 API。</p><p>　　因此，在发布之前测试每个新接口是非常重要的。 多个程序员应该以不同的方式实现每个接口。 至少，你应该准备三种不同的实现。 编写多个使用每个新接口的实例来执行各种任务的客户端程序同样重要。 这将大大确保每个接口都能满足其所有的预期用途。 这些步骤将允许你在发布之前发现接口中的缺陷，但仍然可以轻松地修正它们。 虽然在接口被发布后可能会修正一些存在的缺陷，但不要太指望这一点。</p><h1 id="接口仅用来定义类型"><a href="#接口仅用来定义类型" class="headerlink" title="接口仅用来定义类型"></a>接口仅用来定义类型</h1><p>　　当类实现接口时，该接口作为一种类型（type），可以用来引用类的实例。因此，一个类实现了一个接口，因此表明客户端可以如何处理类的实例。为其他目的定义接口是不合适的。</p><p>　　一种失败的接口就是所谓的常量接口（constant interface）。 这样的接口不包含任何方法; 它只包含静态 final 属性，每个输出一个常量。 使用这些常量的类实现接口，以避免需要用类名限定常量名。 这里是一个例子：</p><pre><code>// Constant interface antipattern - do not use!public interface PhysicalConstants {    // Avogadro&apos;s number (1/mol)    static final double AVOGADROS_NUMBER   = 6.022_140_857e23;    // Boltzmann constant (J/K)    static final double BOLTZMANN_CONSTANT = 1.380_648_52e-23;    // Mass of the electron (kg)    static final double ELECTRON_MASS      = 9.109_383_56e-31;}</code></pre><p>　　常量接口模式是对接口的糟糕使用。 类在内部使用一些常量，完全属于实现细节。实现一个常量接口会导致这个实现细节泄漏到类的导出 API 中。对类的用户来说，类实现一个常量接口是没有意义的。事实上，它甚至可能使他们感到困惑。更糟糕的是，它代表了一个承诺：如果在将来的版本中修改了类，不再需要使用常量，那么它仍然必须实现接口，以确保二进制兼容性。如果一个非 final 类实现了常量接口，那么它的所有子类的命名空间都会被接口中的常量所污染。</p><p>　　Java 平台类库中有多个常量接口，如 java.io.ObjectStreamConstants。 这些接口应该被视为不规范的，不应该被效仿。</p><p>　　如果你想导出常量，有几个合理的选择方案。 如果常量与现有的类或接口紧密相关，则应将其添加到该类或接口中。 例如，所有数字基本类型的包装类，如 Integer 和 Double，都会导出 MIN_VALUE 和 MAX_VALUE 常量。 如果常量最好被看作枚举类型的成员，则应该使用枚举类型（详见第 34 条）导出它们。 否则，你应该用一个不可实例化的工具类来导出常量（详见第 4 条）。 下是前面所示的 PhysicalConstants 示例的工具类的版本：</p><pre><code>// Constant utility classpackage com.effectivejava.science;public class PhysicalConstants {  private PhysicalConstants() { }  // Prevents instantiation  public static final double AVOGADROS_NUMBER = 6.022_140_857e23;  public static final double BOLTZMANN_CONST  = 1.380_648_52e-23;  public static final double ELECTRON_MASS    = 9.109_383_56e-31;}</code></pre><p>　　顺便提一下，请注意在数字文字中使用下划线字符_ 。 从 Java 7 开始，合法的下划线对数字字面量的值没有影响，但是如果使用得当的话可以使它们更容易阅读。 无论是固定的浮点数，如果他们包含五个或更多的连续数字，考虑将下划线添加到数字字面量中。 对于底数为 10 的数字，无论是整型还是浮点型的，都应该用下划线将数字分成三个数字组，表示一千的正负幂。</p><p>　　通常，实用工具类要求客户端使用类名来限定常量名，例如 PhysicalConstants.AVOGADROS_NUMBER。 如果大量使用实用工具类导出的常量，则通过使用静态导入来限定具有类名的常量：</p><pre><code>// Use of static import to avoid qualifying constantsimport static com.effectivejava.science.PhysicalConstants.*;public class Test {    double  atoms(double mols) {        return AVOGADROS_NUMBER * mols;    }    ...    // Many more uses of PhysicalConstants justify static import}</code></pre><p>　　总之，接口只能用于定义类型。 它们不应该只是被用于导出常量。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="http://sjsdfg.gitee.io/effective-java-3rd-chinese/#/notes/21.%20%E4%B8%BA%E5%90%8E%E4%BB%A3%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3" target="_blank" rel="noopener">http://sjsdfg.gitee.io/effective-java-3rd-chinese/#/notes/21.%20%E4%B8%BA%E5%90%8E%E4%BB%A3%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第四章阅读：类和接口&lt;/p&gt;
&lt;p&gt;21.为后代设计接口&lt;br&gt;应该避免使用默认方法向现有的接口添加新的方法，除非这个需要是关键的。在默认方法的情况下，接口的现有实现类可以在没有错误或警告的情况下编译，但在运行时会失败。&lt;br&gt;22.接口仅用来定义类型&lt;br&gt;接口只能用于定义类型。 它们不应该只是被用于导出常量。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
</feed>
