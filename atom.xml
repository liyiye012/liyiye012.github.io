<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-28T02:42:36.855Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>操作系统基础概念I</title>
    <link href="http://yoursite.com/2018/08/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5I/"/>
    <id>http://yoursite.com/2018/08/28/操作系统基础概念I/</id>
    <published>2018-08-28T02:42:12.000Z</published>
    <updated>2018-08-28T02:42:36.855Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统基础概念I"><a href="#操作系统基础概念I" class="headerlink" title="操作系统基础概念I"></a>操作系统基础概念I</h1><p>总结操作系统基础概念</p><a id="more"></a><h2 id="（一）请分别简单说一说进程和线程以及它们的区别。"><a href="#（一）请分别简单说一说进程和线程以及它们的区别。" class="headerlink" title="（一）请分别简单说一说进程和线程以及它们的区别。"></a>（一）请分别简单说一说进程和线程以及它们的区别。</h2><p>进程是具有一定功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源调度和分配的一个独立单位。<br>线程是进程的实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。<br>一个进程可以有多个线程，多个线程也可以并发执行</p><p>如果你对进程或者线程不太熟悉，建议阅读：<a href="https://link.zhihu.com/?target=http%3A//www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="noopener">进程与线程的一个简单解释</a></p><h2 id="（二）线程同步的方式有哪些？"><a href="#（二）线程同步的方式有哪些？" class="headerlink" title="（二）线程同步的方式有哪些？"></a>（二）线程同步的方式有哪些？</h2><p>互斥量：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。<br>信号量：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。<br>事件（信号）：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</p><p>如果你对线程同步的方式不太熟悉，建议阅读：<a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/lebronjames/archive/2010/08/11/1797702.html" target="_blank" rel="noopener">线程同步的几种方式</a></p><h2 id="（三）进程的通信方式有哪些？"><a href="#（三）进程的通信方式有哪些？" class="headerlink" title="（三）进程的通信方式有哪些？"></a>（三）进程的通信方式有哪些？</h2><p>主要分为：管道、系统IPC（包括消息队列、信号量、共享存储）、SOCKET</p><p>管道主要分为：普通管道PIPE 、流管道（s_pipe）、命名管道（name_pipe）</p><p>管道是一种半双工的通信方式，数据只能单项流动，并且只能在具有亲缘关系的进程间流动，进程的亲缘关系通常是父子进程<br>命名管道也是半双工的通信方式，它允许无亲缘关系的进程间进行通信<br>信号量是一个计数器，用来控制多个进程对资源的访问，它通常作为一种锁机制。<br>消息队列是消息的链表，存放在内核中并由消息队列标识符标识。<br>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。<br>共享内存就是映射一段能被其它进程访问的内存，这段共享内存由一个进程创建，但是多个进程可以访问。<br>如果你对进程的通信方式不太熟悉，建议阅读： <a href="https://blog.csdn.net/yufaw/article/details/7409596" target="_blank" rel="noopener">进程间的几种通信方式</a></p><p>##（四）什么是缓冲区溢出？有什么危害？其原因是什么？</p><p>缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。</p><p>危害有以下两点：</p><p>程序崩溃，导致拒绝额服务<br>跳转并且执行一段恶意代码<br>造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入。 </p><p>如果你想深入了解缓冲区溢出，推荐阅读：<a href="http://www.cnblogs.com/fanzhidongyzby/archive/2013/08/10/3250405.html" target="_blank" rel="noopener">缓冲区溢出攻击</a></p><p>##（五）什么是死锁？死锁产生的条件？</p><p>在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲就是两个或多个进程无限期的阻塞、相互等待的一种状态。</p><p>死锁产生的四个条件（有一个条件不成立，则不会产生死锁）</p><p>互斥条件：一个资源一次只能被一个进程使用<br>请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放<br>不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺<br>循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系<br>如果对死锁还不是太熟悉，建议阅读：<a href="http://www.cnblogs.com/Jessy/p/3540724.html" target="_blank" rel="noopener">死锁产生的原因和解锁的方法</a></p><p>##（六）进程有哪几种状态？</p><p>就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源<br>运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数<br>阻塞状态： 进程等待某种条件，在条件满足之前无法执行<br>如果你对进程的几种状态以及中间的装换不太了解，建议阅读：<a href="http://www.cnblogs.com/Jessy/p/3540724.html" target="_blank" rel="noopener">进程的三种状态及转换</a></p><p>##（七）分页和分段有什么区别？</p><p>段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 ；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的。<br>段的大小不固定，有它所完成的功能决定；页大大小固定，由系统决定<br>段向用户提供二维地址空间；页向用户提供的是一维地址空间<br>段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。<br>如果你对分页和分段还不太了解，建议阅读：<a href="https://blog.csdn.net/wangrunmin/article/details/7967293" target="_blank" rel="noopener">分段和分页</a></p><p>##（八） 操作系统中进程调度策略有哪几种？</p><p>FCFS(先来先服务)，优先级，时间片轮转，多级反馈</p><p>如果你想深入的了解这几种调度策略，推荐阅读：<a href="https://blog.csdn.net/luyafei_89430/article/details/12971171" target="_blank" rel="noopener">几个常用的操作系统进程调度算法</a> </p><p>##（九）说一说进程同步有哪几种机制。</p><p>原子操作、信号量机制、自旋锁管程、会合、分布式系统</p><p>如果你想深入的了解这几种机制，推荐阅读： <a href="http://www.cnblogs.com/sonic4x/archive/2011/07/05/2098036.html" target="_blank" rel="noopener">进程同步的几种机制</a></p><p>##（十）说一说死锁的处理基本策略和常用方法。</p><p>解决死锁的基本方法如下： </p><p>预防死锁、避免死锁、检测死锁、解除死锁 </p><p>解决四多的常用策略如下： </p><p>鸵鸟策略、预防策略、避免策略、检测与解除死锁<br>如果你对死锁的处理策略不是太熟悉，推荐阅读：<a href="https://blog.csdn.net/bxyill/article/details/8237339" target="_blank" rel="noopener">产生死锁的原因和必要条件+解决死锁的基本方法</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统基础概念I&quot;&gt;&lt;a href=&quot;#操作系统基础概念I&quot; class=&quot;headerlink&quot; title=&quot;操作系统基础概念I&quot;&gt;&lt;/a&gt;操作系统基础概念I&lt;/h1&gt;&lt;p&gt;总结操作系统基础概念&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Operating System" scheme="http://yoursite.com/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>688. Knight Probability in Chessboard“马”在棋盘上的概率</title>
    <link href="http://yoursite.com/2018/08/27/688.%20Knight%20Probability%20in%20Chessboard%E2%80%9C%E9%A9%AC%E2%80%9D%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87/"/>
    <id>http://yoursite.com/2018/08/27/688. Knight Probability in Chessboard“马”在棋盘上的概率/</id>
    <published>2018-08-27T10:48:10.000Z</published>
    <updated>2018-08-27T13:03:04.729Z</updated>
    
    <content type="html"><![CDATA[<h1 id="688-Knight-Probability-in-Chessboard“马”在棋盘上的概率"><a href="#688-Knight-Probability-in-Chessboard“马”在棋盘上的概率" class="headerlink" title="688. Knight Probability in Chessboard“马”在棋盘上的概率"></a>688. Knight Probability in Chessboard“马”在棋盘上的概率</h1><p> 已知一个 NxN 的国际象棋棋盘，棋盘的行号和列号都是从0开始。即最左上角的格子记为 (0, 0), 最右下角的记为 (N-1, N-1)。 </p><p>现有一个“马”（也译作“骑士”）位于 (r, c) ，并打算进行 K 次移动。 </p><a id="more"></a><p>如下图所示，国际象棋的“马”每一步先沿水平或垂直方向移动2个格子，然后向与之相垂直的方向再移动1个格子，共有8个可选的位置。</p><p><img src="http://ww1.sinaimg.cn/large/0071ouepgy1fuogeyhztfj30ba0baq32.jpg" alt="image"></p><p>现在“马”每一步都从可选的位置（包括棋盘外部的）中独立随机地选择一个进行移动，直到移动了 K 次或跳到了棋盘外面。</p><p>求移动结束后，“马”仍留在棋盘上的概率。</p><p>例:</p><p>输入: </p><pre><code>3, 2, 0, 0</code></pre><p>输出: 0.0625<br>解释:<br>输入的数据依次为 N, K, r, c<br>第1步时，有且只有2种走法令“马”可以留在棋盘上(跳到(1,2)或(2,1))。对于以上的两种情况，各自在第2步均有且只有2种走法令“马”仍然留在棋盘上。<br>所以“马”在结束后仍在棋盘上的概率为0.0625。<br>注意:</p><p>N 的取值范围为 [1, 25]<br>K 的取值范围为 [0, 100]<br>开始时，“马”总是位于棋盘上</p><h2 id="解法：动态规划"><a href="#解法：动态规划" class="headerlink" title="解法：动态规划"></a>解法：动态规划</h2><p>令f[r][c][steps]成为在第steps步后落在区域(r,c)的概率，递推式如下：</p><pre><code>\$\$ f[r][c][steps]=∑_​{dr,dc​​} f[r+dr][c+dc][steps−1]/8.0 \$\$  </code></pre><p>(dr,dc)包括八个可能（2,1), (2, -1),(2,−1), (-2, 1),(−2,1), (-2, -1),(−2,−1), (1, 2),(1,2), (1, -2),(1,−2), (-1, 2),(−1,2), (-1, -2)(−1,−2)</p><p>为了不使用三维数组f，我们会使用两个二维dp,dp2，存储最近使用的两层，其中dp2会代表f[][][steps],dp会代表f[][][steps-1]</p><p>时间复杂度：<br>O(KN^​2)<br>空间复杂度：<br>O(N^​2)</p><pre><code>class Solution {    public double knightProbability(int N, int K, int sr, int sc) {        double[][] dp = new double[N][N];        int[] dr = new int[]{2, 2, 1, 1, -1, -1, -2, -2};        int[] dc = new int[]{1, -1, 2, -2, 2, -2, 1, -1};        dp[sr][sc] = 1;        for (; K &gt; 0; K--) {            double[][] dp2 = new double[N][N];            for (int r = 0; r &lt; N; r++) {                for (int c = 0; c &lt; N; c++) {                    for (int k = 0; k &lt; 8; k++) {                        int cr = r + dr[k];                        int cc = c + dc[k];                        if (0 &lt;= cr &amp;&amp; cr &lt; N &amp;&amp; 0 &lt;= cc &amp;&amp; cc &lt; N) {                            dp2[cr][cc] += dp[r][c] / 8.0;                        }                    }                }            }            dp = dp2;        }        double ans = 0.0;        for (double[] row: dp) {            for (double x: row) ans += x;        }        return ans;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;688-Knight-Probability-in-Chessboard“马”在棋盘上的概率&quot;&gt;&lt;a href=&quot;#688-Knight-Probability-in-Chessboard“马”在棋盘上的概率&quot; class=&quot;headerlink&quot; title=&quot;688. Knight Probability in Chessboard“马”在棋盘上的概率&quot;&gt;&lt;/a&gt;688. Knight Probability in Chessboard“马”在棋盘上的概率&lt;/h1&gt;&lt;p&gt; 已知一个 NxN 的国际象棋棋盘，棋盘的行号和列号都是从0开始。即最左上角的格子记为 (0, 0), 最右下角的记为 (N-1, N-1)。 &lt;/p&gt;
&lt;p&gt;现有一个“马”（也译作“骑士”）位于 (r, c) ，并打算进行 K 次移动。 &lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>139. Word Break单词拆分</title>
    <link href="http://yoursite.com/2018/08/26/139.%20Word%20Break%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/"/>
    <id>http://yoursite.com/2018/08/26/139. Word Break单词拆分/</id>
    <published>2018-08-26T12:33:12.000Z</published>
    <updated>2018-08-27T14:08:19.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="139-Word-Break单词拆分"><a href="#139-Word-Break单词拆分" class="headerlink" title="139. Word Break单词拆分"></a>139. Word Break单词拆分</h1><p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p><a id="more"></a><p>说明：</p><p>拆分时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。<br>示例 1：</p><pre><code>输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]输出: true解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</code></pre><p>示例 2：</p><pre><code>输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]输出: true解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。     注意你可以重复使用字典中的单词。</code></pre><p>示例 3：</p><pre><code>输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]输出: false</code></pre><h2 id="思路：动态规划"><a href="#思路：动态规划" class="headerlink" title="思路：动态规划"></a>思路：动态规划</h2><p>使用一个bool型的数组dp,dp[i]被设置为真如果一个有效词在这里终结。优化方法是从当前位置i逆向搜索只要找到dp[j]==true的位置就截取之后的子字符串搜索是否在字典中</p><pre><code>class Solution {public:    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) {        if(s.size()&lt;=0) return false;        vector&lt;bool&gt; dp(s.size()+1,false);        dp[0]=true;        for(int i=1;i&lt;=s.size();i++){            for(int j=i-1;j&gt;=0;j--){                if(dp[j]){                    string word=s.substr(j,i-j);                    if(findword(wordDict,word)){                        dp[i]=true;                        break;//next i                    }                }            }        }        return dp[s.size()];    }    bool findword(vector&lt;string&gt;&amp; wordDict,string word){        for(int i=0;i&lt;wordDict.size();i++){            if(wordDict[i]==word) return true;        }        return false;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;139-Word-Break单词拆分&quot;&gt;&lt;a href=&quot;#139-Word-Break单词拆分&quot; class=&quot;headerlink&quot; title=&quot;139. Word Break单词拆分&quot;&gt;&lt;/a&gt;139. Word Break单词拆分&lt;/h1&gt;&lt;p&gt;给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>626. Exchange Seats换座位</title>
    <link href="http://yoursite.com/2018/08/26/626.%20Exchange%20Seats%E6%8D%A2%E5%BA%A7%E4%BD%8D/"/>
    <id>http://yoursite.com/2018/08/26/626. Exchange Seats换座位/</id>
    <published>2018-08-26T12:33:12.000Z</published>
    <updated>2018-08-26T13:27:54.554Z</updated>
    
    <content type="html"><![CDATA[<h1 id="626-Exchange-Seats换座位"><a href="#626-Exchange-Seats换座位" class="headerlink" title="626. Exchange Seats换座位"></a>626. Exchange Seats换座位</h1><p>小美是一所中学的信息科技老师，她有一张 seat 座位表，平时用来储存学生名字和与他们相对应的座位 id。</p><p>其中纵列的 id 是连续递增的</p><p>小美想改变相邻俩学生的座位。</p><p>你能不能帮她写一个 SQL query 来输出小美想要的结果呢？</p><a id="more"></a><p>示例：</p><pre><code>+---------+---------+|    id   | student |+---------+---------+|    1    | Abbot   ||    2    | Doris   ||    3    | Emerson ||    4    | Green   ||    5    | Jeames  |+---------+---------+</code></pre><p>假如数据输入的是上表，则输出结果如下：</p><pre><code>+---------+---------+|    id   | student |+---------+---------+|    1    | Doris   ||    2    | Abbot   ||    3    | Green   ||    4    | Emerson ||    5    | Jeames  |+---------+---------+</code></pre><p>注意：</p><p>如果学生人数是奇数，则不需要改变最后一个同学的座位。</p><h2 id="思路I：使用流控制语句CASE"><a href="#思路I：使用流控制语句CASE" class="headerlink" title="思路I：使用流控制语句CASE"></a>思路I：使用流控制语句CASE</h2><h3 id="算法："><a href="#算法：" class="headerlink" title="算法："></a>算法：</h3><p>对于奇数ID的学生，交换后新的ID是（ID+1），最后一个座位的学生除外。</p><p>对于偶数ID的学生，新的ID是（ID-1），为了查询ID数量，可以使用查询：</p><pre><code>SELECT    COUNT(*) AS countsFROM    seat</code></pre><p>然后我们可以使用CASE语句和MOD()函数来为每个学生交换座位</p><h3 id="MYSQL"><a href="#MYSQL" class="headerlink" title="MYSQL"></a>MYSQL</h3><pre><code>SELECT    (CASE        WHEN MOD(id,2) != 0 AND counts !=id THEN id+1        WHEN MOD(id,2) !=0 AND counts =id THEN id        ELSE id-1    END) AS id,    studentFROM    seat,    (SELECT COUNT(*) AS counts    FROM        seat) AS seat_countsORDER BY id ASC;</code></pre><h2 id="思路II：使用位运算和COALESCE"><a href="#思路II：使用位运算和COALESCE" class="headerlink" title="思路II：使用位运算和COALESCE()"></a>思路II：使用位运算和COALESCE()</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>位运算表达式(id+1)^1-1能够计算交换后的新的id</p><pre><code>SELECT id,(id+1)^1-1, student FROM seat;| id | (id+1)^1-1 | student ||----|------------|---------|| 1  | 2          | Abbot   || 2  | 1          | Doris   || 3  | 4          | Emerson || 4  | 3          | Green   || 5  | 6          | Jeames  |</code></pre><p>然后我们能够用一个临时的表将座位填入</p><pre><code>SELECT    *FROM    seat s1        LEFT JOIN    seat s2 ON (s1.id+1)^1-1 = s2.idORDER BY s1.id;| id | student | id | student ||----|---------|----|---------|| 1  | Abbot   | 2  | Doris   || 2  | Doris   | 1  | Abbot   || 3  | Emerson | 4  | Green   || 4  | Green   | 3  | Emerson || 5  | Jeames  |    |         |</code></pre><p>前两列来自s1后两列来自s2</p><p>最后我们可以输出s1.id 和 s2.student。可是s2.student时空的当id为末尾时，因此我们可以使用函数COALESCE()来生成最后一个记录的正确输出</p><h3 id="MYSQL-1"><a href="#MYSQL-1" class="headerlink" title="MYSQL"></a>MYSQL</h3><pre><code>SELECT    s1.id, COALESCE(s2.student,s1.student) AS studentFROM    seat s1        LEFT JOIN    seat s2 ON ((S1.id+1)^1)-1= s2.idORDER BY s1.id;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;626-Exchange-Seats换座位&quot;&gt;&lt;a href=&quot;#626-Exchange-Seats换座位&quot; class=&quot;headerlink&quot; title=&quot;626. Exchange Seats换座位&quot;&gt;&lt;/a&gt;626. Exchange Seats换座位&lt;/h1&gt;&lt;p&gt;小美是一所中学的信息科技老师，她有一张 seat 座位表，平时用来储存学生名字和与他们相对应的座位 id。&lt;/p&gt;
&lt;p&gt;其中纵列的 id 是连续递增的&lt;/p&gt;
&lt;p&gt;小美想改变相邻俩学生的座位。&lt;/p&gt;
&lt;p&gt;你能不能帮她写一个 SQL query 来输出小美想要的结果呢？&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="SQL" scheme="http://yoursite.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Kickstart-Round-E-2018-ProblemA.Yogurt</title>
    <link href="http://yoursite.com/2018/08/26/Kickstart-Round-E-2018-ProblemA.Yogurt/"/>
    <id>http://yoursite.com/2018/08/26/Kickstart-Round-E-2018-ProblemA.Yogurt/</id>
    <published>2018-08-26T07:07:00.000Z</published>
    <updated>2018-08-26T12:07:12.750Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kickstart-Round-E-2018-ProblemA-Yogurt"><a href="#Kickstart-Round-E-2018-ProblemA-Yogurt" class="headerlink" title="Kickstart-Round-E-2018-ProblemA.Yogurt"></a>Kickstart-Round-E-2018-ProblemA.Yogurt</h1><p>酸奶可以作为开胃菜、主菜或甜点的营养成分，但它必须在过期前食用，而且可能很快过期!此外，不同的酸奶会在不同的日子过期。露西很喜欢酸奶，她刚买了N杯酸奶，但她担心自己可能无法在酸奶过期前全部喝完。从今天开始，第i杯酸奶会过期，在过期当天或之后的任何一天都不能喝。虽然露西很喜欢酸奶，但她每天最多只能喝K杯酸奶。从今天开始，她最多能喝多少杯酸奶?</p><a id="more"></a><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>Problem<br>Yogurt can be a nutritious part of an appetizer, main course, or dessert, but it must be consumed before it expires, and it might expire quickly! Moreover, different cups of yogurt might expire on different days.</p><p>Lucy loves yogurt, and she has just bought N cups of yogurt, but she is worried that she might not be able to consume all of them before they expire. The i-th cup of yogurt will expire Ai days from today, and a cup of yogurt cannot be consumed on the day it expires, or on any day after that.</p><p>As much as Lucy loves yogurt, she can still only consume at most K cups of yogurt each day. What is the largest number of cups of yogurt that she can consume, starting from today?</p><p>Input<br>The first line of the input gives the number of test cases, T. T test cases follow. Each test case starts with one line containing two integers N and K, as described above. Then, there is one more line with N integers Ai, as described above.</p><p>Output<br>For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the maximum number of cups of yogurt that Lucy can consume, as described above.</p><p>Limits<br>1 ≤ T ≤ 100.<br>1 ≤ K ≤ N.<br>1 ≤ Ai ≤ 109, for all i.<br>Small dataset<br>1 ≤ N ≤ 1000.<br>K = 1.<br>Large dataset<br>1 ≤ N ≤ 5000.<br>Sample</p><p>Input </p><p>Output </p><pre><code>42 11 15 13 2 3 2 32 21 16 21 1 1 7 7 7Case #1: 1Case #2: 3Case #3: 2Case #4: 5</code></pre><p>Note that the last two sample cases would not appear in the Small dataset.</p><p>In Sample Case #1, each of the two cups of yogurt will expire in one day. Today, Lucy can consume one of them, but she can only consume at most one cup each day, so she cannot consume both. Tomorrow, Lucy cannot consume the remaining cup of yogurt, because it will have expired.</p><p>In Sample Case #3, Lucy can consume up to two cups each day, so she can consume all of the yogurt.</p><h2 id="思路1（Brute-force"><a href="#思路1（Brute-force" class="headerlink" title="思路1（Brute force)"></a>思路1（Brute force)</h2><p>模拟每天发生的过程，先将输入的保质期数组A排序，将最大的保质期天数定义为maxday，然后从今天到maxday进行循环，每天更新最多能喝的杯数和当前的保质期数组。<br>这里在比赛过程中犯了两个错误，见代码注释</p><pre><code>#include &lt;iostream&gt;#include&lt;unordered_map&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#include&lt;set&gt;using namespace std;void solve() {// brute force TLE    int N = 0, K = 0;    cin &gt;&gt; N &gt;&gt; K;    vector&lt;int&gt; a;     for (int i = 0; i &lt; N; i++) {    int temp;    cin &gt;&gt; temp;     a.push_back(temp);    }    sort(a.begin(), a.end());      /*  cout &lt;&lt; &quot;a[N-1]=&quot; &lt;&lt; a[N - 1] &lt;&lt; &quot;  &quot;;     cout &lt;&lt; &quot;After sort:   &quot;; output(a);*/    int num = 0;    int maxday = a[N - 1];    for (int i = 0; i &lt; maxday; i++) {//error i &lt; a[N - 1] 因为a[N-1]会动态变化       // cout &lt;&lt; &quot;i=&quot; &lt;&lt; i &lt;&lt; &quot;  &quot;;    int k = 0;    for (int j = 0; j &lt; N ; j++) {    //cout &lt;&lt; &quot;j=&quot; &lt;&lt; j &lt;&lt; endl;    if ((a[j] &gt; 0)&amp;&amp;(k&lt;K)) {//error (k&lt;K)条件要放到这个if里而不能放到for循环中    a[j] = 0;    k++;    num++;        }    }   // cout &lt;&lt; &quot;  num=&quot; &lt;&lt; num&lt;&lt;&quot;  &quot;; output(a);    for (int mm = 0; mm &lt; N; mm++) { a[mm] -= 1; }    }    cout &lt;&lt; num &lt;&lt; endl;}int main() {    freopen(&quot;C:\\Users\\yiye\\Downloads\\A-small-attempt0.in&quot;, &quot;r&quot;, stdin);    //freopen(&quot;C:\\Users\\yiye\\Downloads\\out.txt&quot;, &quot;w&quot;, stdout);    int T;    scanf(&quot;%d&quot;, &amp;T);    for (int i = 1; i &lt;= T; i++) {         printf(&quot;Case #%d: &quot;, i);         solve();    }        //===========================        //fclose(stdin);//关闭文件         //fclose(stdout);//关闭文件         return 0;}</code></pre><h2 id="思路2（Brute-force-改进版本"><a href="#思路2（Brute-force-改进版本" class="headerlink" title="思路2（Brute force)改进版本"></a>思路2（Brute force)改进版本</h2><p>在每天的模拟过程中用lower_bound找到第一个非零的位置，然后将改天中连续K个杯子状态置为已喝，这样可以将时间复杂度从O(n*n)变为O(nlog(n))</p><pre><code>#include &lt;iostream&gt;#include&lt;unordered_map&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;stack&gt; #include &lt;functional&gt; #include&lt;set&gt;using namespace std;void solve() {// brute force TLE    int N = 0, K = 0;    cin &gt;&gt; N &gt;&gt; K;    vector&lt;int&gt; a;    for (int i = 0; i &lt; N; i++) {        int temp;        cin &gt;&gt; temp;        a.push_back(temp);    }    sort(a.begin(), a.end());    int num = 0;        int maxday = a[N - 1];        for (int i = 0; i &lt; maxday; i++) {//error i &lt; a[N - 1] 因为a[N-1]会动态变化            //cout &lt;&lt; &quot;i=&quot; &lt;&lt; i &lt;&lt; &quot;  &quot;;                int k = 0;            vector&lt;int&gt;::iterator nonezeroindex = lower_bound(a.begin(), a.end(), 1);            for (int j = nonezeroindex-a.begin(); j &lt;nonezeroindex - a.begin()+ K &amp;&amp; j&lt;N ; j++) {                a[j] = 0;                num++;                        }            //cout &lt;&lt; &quot;  nonezeroindex=&quot;&lt;&lt;(nonezeroindex-a.begin())&lt;&lt;&quot;  num=&quot; &lt;&lt; num&lt;&lt;&quot;  &quot;; output(a);            for (int mm = nonezeroindex - a.begin(); mm &lt; N; mm++) { a[mm] -= 1; }        }    cout &lt;&lt; num &lt;&lt; endl;}int main() {    //freopen(&quot;C:\\Users\\yiye\\Downloads\\A-small-attempt0.in&quot;, &quot;r&quot;, stdin);    //freopen(&quot;C:\\Users\\yiye\\Downloads\\out.txt&quot;, &quot;w&quot;, stdout);    freopen(&quot;out.txt&quot;, &quot;r&quot;, stdin);    int T;    scanf(&quot;%d&quot;, &amp;T);    for (int i = 1; i &lt;= T; i++) {        printf(&quot;Case #%d: &quot;, i);        solve();    }        //===========================        //fclose(stdin);//关闭文件         //fclose(stdout);//关闭文件         return 0;    } </code></pre><h2 id="思路3："><a href="#思路3：" class="headerlink" title="思路3："></a>思路3：</h2><p>这是E轮中第一名选手ijn的解法，核心代码用五行实现了我十行的功能，浓缩的都是精华啊</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int t,n,m,a[5005],i,j,k,ans;int main(){    freopen(&quot;a.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;a.out&quot;,&quot;w&quot;,stdout);    scanf(&quot;%d&quot;,&amp;t);    for(int xxx=1;xxx&lt;=t;xxx++)    {        printf(&quot;Case #%d: &quot;,xxx);        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);//m为K        for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,a+i);        sort(a+1,a+n+1);        for(i=k=1,ans=0;i&lt;=n;k++)        {            j=min(i+m,n+1);            ans+=j-i;            i=j;            for(;i&lt;=n&amp;&amp;a[i]&lt;=k;i++);        }        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre><p>将其    改写成易于理解的形式    </p><pre><code>void solve() {    int N, K;    cin &gt;&gt; N &gt;&gt; K;    vector&lt;int&gt; a(N+1,0);    for (int i = 1; i &lt;= N; i++) cin &gt;&gt; a[i];    sort(a.begin(), a.end());//实现排序功能    int  num=0;    for (int k = 1, i = 1; i &lt;= N; k++) {//对数组进行遍历，ans为最多能喝的杯数，k为已经过去的天数        int j = min(i + K, N + 1);//寻找可以喝的酸奶序列的终点        num += j - i;//更新        i = j;        for (; i &lt;= N &amp;&amp; a[i] &lt;= k; i++);//跳过过期的杯子    }    cout &lt;&lt; num &lt;&lt; endl;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Kickstart-Round-E-2018-ProblemA-Yogurt&quot;&gt;&lt;a href=&quot;#Kickstart-Round-E-2018-ProblemA-Yogurt&quot; class=&quot;headerlink&quot; title=&quot;Kickstart-Round-E-2018-ProblemA.Yogurt&quot;&gt;&lt;/a&gt;Kickstart-Round-E-2018-ProblemA.Yogurt&lt;/h1&gt;&lt;p&gt;酸奶可以作为开胃菜、主菜或甜点的营养成分，但它必须在过期前食用，而且可能很快过期!此外，不同的酸奶会在不同的日子过期。露西很喜欢酸奶，她刚买了N杯酸奶，但她担心自己可能无法在酸奶过期前全部喝完。从今天开始，第i杯酸奶会过期，在过期当天或之后的任何一天都不能喝。虽然露西很喜欢酸奶，但她每天最多只能喝K杯酸奶。从今天开始，她最多能喝多少杯酸奶?&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Kickstart" scheme="http://yoursite.com/tags/Kickstart/"/>
    
      <category term="Google" scheme="http://yoursite.com/tags/Google/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>865. Smallest Subtree with all the Deepest Nodes具有所有最深结点的最小子树</title>
    <link href="http://yoursite.com/2018/08/24/865.%20Smallest%20Subtree%20with%20all%20the%20Deepest%20Nodes%E5%85%B7%E6%9C%89%E6%89%80%E6%9C%89%E6%9C%80%E6%B7%B1%E7%BB%93%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E6%A0%91/"/>
    <id>http://yoursite.com/2018/08/24/865. Smallest Subtree with all the Deepest Nodes具有所有最深结点的最小子树/</id>
    <published>2018-08-24T13:06:12.000Z</published>
    <updated>2018-08-24T15:00:41.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="865-Smallest-Subtree-with-all-the-Deepest-Nodes具有所有最深结点的最小子树"><a href="#865-Smallest-Subtree-with-all-the-Deepest-Nodes具有所有最深结点的最小子树" class="headerlink" title="865. Smallest Subtree with all the Deepest Nodes具有所有最深结点的最小子树"></a>865. Smallest Subtree with all the Deepest Nodes具有所有最深结点的最小子树</h1><p>给定一个根为 root 的二叉树，每个结点的深度是它到根的最短距离。</p><p>如果一个结点在整个树的任意结点之间具有最大的深度，则该结点是最深的。</p><p>一个结点的子树是该结点加上它的所有后代的集合。</p><p>返回能满足“以该结点为根的子树中包含所有最深的结点”这一条件的具有最大深度的结点。</p><a id="more"></a><p>示例：</p><p>输入：</p><pre><code>[3,5,1,6,2,0,8,null,null,7,4]</code></pre><p>输出：</p><pre><code>[2,7,4]</code></pre><p><img src="https://ws1.sinaimg.cn/large/0071ouepgy1ful3h7lug7j30k20h2t9l.jpg" alt="image"></p><p>解释：</p><p>我们返回值为 2 的结点，在图中用黄色标记。<br>在图中用蓝色标记的是树的最深的结点。<br>输入 “[3, 5, 1, 6, 2, 0, 8, null, null, 7, 4]” 是对给定的树的序列化表述。<br>输出 “[2, 7, 4]” 是对根结点的值为 2 的子树的序列化表述。<br>输入和输出都具有 TreeNode 类型。</p><p>提示：</p><p>树中结点的数量介于 1 和 500 之间。<br>每个结点的值都是独一无二的。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>写一个子函数 deep(TreeNode root)<br>返回一个 pair(int depth, TreeNode subtreeWithAllDeepest)</p><p>在子函数中：<br>若是结点为空，返回pair(0,null)<br>left=deep(root-&gt;left)<br>right=deep(root-&gt;right)</p><p>如果left depth== right depth<br>有最深的结点同时存在于左右子树中<br>返回pair(left.depth+1,root)</p><p>如果left depth &gt; right depth<br>只有左子树中存在最深结点<br>返回pair(left.depth+1,left subtree)</p><p>如果left depth &lt; right depth<br>只有右子树中存在最深结点<br>返回pair(right.depth+1, right subtree)</p><pre><code>TreeNode* subtreeWithAllDeepest(TreeNode* root) {    return deep(root).second;}pair&lt;int, TreeNode*&gt; deep(TreeNode* root) {    if (!root) return {0, NULL};    pair&lt;int, TreeNode*&gt; l = deep(root-&gt;left), r = deep(root-&gt;right);    int d1 = l.first, d2 = r.first;    return {max(d1, d2) + 1, d1 == d2 ? root : d1 &gt; d2 ? l.second : r.second};}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;865-Smallest-Subtree-with-all-the-Deepest-Nodes具有所有最深结点的最小子树&quot;&gt;&lt;a href=&quot;#865-Smallest-Subtree-with-all-the-Deepest-Nodes具有所有最深结点的最小子树&quot; class=&quot;headerlink&quot; title=&quot;865. Smallest Subtree with all the Deepest Nodes具有所有最深结点的最小子树&quot;&gt;&lt;/a&gt;865. Smallest Subtree with all the Deepest Nodes具有所有最深结点的最小子树&lt;/h1&gt;&lt;p&gt;给定一个根为 root 的二叉树，每个结点的深度是它到根的最短距离。&lt;/p&gt;
&lt;p&gt;如果一个结点在整个树的任意结点之间具有最大的深度，则该结点是最深的。&lt;/p&gt;
&lt;p&gt;一个结点的子树是该结点加上它的所有后代的集合。&lt;/p&gt;
&lt;p&gt;返回能满足“以该结点为根的子树中包含所有最深的结点”这一条件的具有最大深度的结点。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>538. Convert BST to Greater Tree把二叉搜索树转换为累加树</title>
    <link href="http://yoursite.com/2018/08/24/538.%20Convert%20BST%20to%20Greater%20Tree%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/"/>
    <id>http://yoursite.com/2018/08/24/538. Convert BST to Greater Tree把二叉搜索树转换为累加树/</id>
    <published>2018-08-24T05:36:12.000Z</published>
    <updated>2018-08-24T13:02:28.972Z</updated>
    
    <content type="html"><![CDATA[<h1 id="538-Convert-BST-to-Greater-Tree把二叉搜索树转换为累加树"><a href="#538-Convert-BST-to-Greater-Tree把二叉搜索树转换为累加树" class="headerlink" title="538. Convert BST to Greater Tree把二叉搜索树转换为累加树"></a>538. Convert BST to Greater Tree把二叉搜索树转换为累加树</h1><p>给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。</p><a id="more"></a><p>例如：</p><p>输入: 二叉搜索树:<br>              5<br>            /   \<br>           2     13</p><p>输出: 转换为累加树:<br>             18<br>            /   \<br>          20     13</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>二叉搜索树有一个重要的性质，就是中序遍历序列是非递减的<br>解法是一种中序遍历的镜像遍历方法，先用遍历右子树，再改变根节点的值,将其改为所有右子树结点之和，遍历左子树</p><pre><code>class Solution {private:    int cur_sum = 0;public:    void travel(TreeNode* root){        if (!root) return;        if (root-&gt;right) travel(root-&gt;right);        root-&gt;val = (cur_sum += root-&gt;val);        if (root-&gt;left) travel(root-&gt;left);    }    TreeNode* convertBST(TreeNode* root) {        travel(root);        return root;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;538-Convert-BST-to-Greater-Tree把二叉搜索树转换为累加树&quot;&gt;&lt;a href=&quot;#538-Convert-BST-to-Greater-Tree把二叉搜索树转换为累加树&quot; class=&quot;headerlink&quot; title=&quot;538. Convert BST to Greater Tree把二叉搜索树转换为累加树&quot;&gt;&lt;/a&gt;538. Convert BST to Greater Tree把二叉搜索树转换为累加树&lt;/h1&gt;&lt;p&gt;给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Binary Search Tree" scheme="http://yoursite.com/tags/Binary-Search-Tree/"/>
    
  </entry>
  
  <entry>
    <title>697. Degree of an Array数组的度</title>
    <link href="http://yoursite.com/2018/08/24/697.%20Degree%20of%20an%20Array%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%A6/"/>
    <id>http://yoursite.com/2018/08/24/697. Degree of an Array数组的度/</id>
    <published>2018-08-24T05:36:12.000Z</published>
    <updated>2018-08-24T07:05:54.170Z</updated>
    
    <content type="html"><![CDATA[<h1 id="697-Degree-of-an-Array数组的度"><a href="#697-Degree-of-an-Array数组的度" class="headerlink" title="697. Degree of an Array数组的度"></a>697. Degree of an Array数组的度</h1><p>给定一个非空且只包含非负数的整数数组 nums, 数组的度的定义是指数组里任一元素出现频数的最大值。</p><p>你的任务是找到与 nums 拥有相同大小的度的最短连续子数组，返回其长度。</p><a id="more"></a><p>示例 1:</p><p>输入: </p><pre><code>[1, 2, 2, 3, 1]</code></pre><p>输出: 2<br>解释:<br>输入数组的度是2，因为元素1和2的出现频数最大，均为2.<br>连续子数组里面拥有相同度的有如下所示:</p><pre><code>[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]</code></pre><p>最短连续子数组[2, 2]的长度为2，所以返回2.<br>示例 2:</p><p>输入: </p><pre><code>[1,2,2,3,1,4,2]</code></pre><p>输出: 6<br>注意:</p><p>nums.length 在1到50,000区间范围内。<br>nums[i] 是一个在0到49,999范围内的整数。</p><!-- more --><h2 id="Brute-Force思路"><a href="#Brute-Force思路" class="headerlink" title="Brute Force思路"></a>Brute Force思路</h2><p>穷举所有的子数组然后将其度与原数组的度比较，相等则更新最小长度。但会超时。</p><pre><code>class Solution {public:    int findShortestSubArray(vector&lt;int&gt;&amp; nums) {        int minlen=nums.size();        int degree=getdegree(nums,0,nums.size()-1);        for(int i=0;i&lt;nums.size();i++){            for(int j=i+1;j&lt;nums.size();j++){                if(getdegree(nums,i,j)==degree) minlen=min(minlen,j-i+1);            }        }        return minlen;    }    int getdegree(vector&lt;int&gt;&amp; arr,int begin,int end){        int degree=0;        unordered_map&lt;int,int&gt; fre;        for(int i=begin;i&lt;=end;i++){            fre[arr[i]]++;        }        for(auto d:fre){            degree=max(degree,d.second);        }        return degree;    }};</code></pre><h2 id="O-n-解法"><a href="#O-n-解法" class="headerlink" title="O(n)解法"></a>O(n)解法</h2><p>使用两个哈希表，一个记录字符的开始位置，另一个记录字符的出现频率<br>一旦一个特定字符的频率大于其他的，我们更新这个变量的长度，当两个变量有同样的频率，只比较它们的长度选择较短的一个</p><pre><code>class Solution {public:    int findShortestSubArray(vector&lt;int&gt;&amp; nums) {        unordered_map&lt;int,int&gt; startindex,frequency;        int fre=0,len=nums.size();        for(int i=0;i&lt;nums.size();i++){            frequency[nums[i]]++;            if(startindex.count(nums[i])==0) startindex[nums[i]]=i;//first appear            if(frequency[nums[i]]==fre){//第i个字符的度与截止到当前的数组度相同                len=min(len,i-startindex[nums[i]]+1);            }            else if(frequency[nums[i]]&gt;fre){//需要更新度和长度                fre=frequency[nums[i]];                len=i-startindex[nums[i]]+1;            }        }        return len;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;697-Degree-of-an-Array数组的度&quot;&gt;&lt;a href=&quot;#697-Degree-of-an-Array数组的度&quot; class=&quot;headerlink&quot; title=&quot;697. Degree of an Array数组的度&quot;&gt;&lt;/a&gt;697. Degree of an Array数组的度&lt;/h1&gt;&lt;p&gt;给定一个非空且只包含非负数的整数数组 nums, 数组的度的定义是指数组里任一元素出现频数的最大值。&lt;/p&gt;
&lt;p&gt;你的任务是找到与 nums 拥有相同大小的度的最短连续子数组，返回其长度。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>485. Max Consecutive Ones最大连续1的个数</title>
    <link href="http://yoursite.com/2018/08/24/485.%20Max%20Consecutive%20Ones/"/>
    <id>http://yoursite.com/2018/08/24/485. Max Consecutive Ones/</id>
    <published>2018-08-24T05:36:12.000Z</published>
    <updated>2018-08-24T07:05:48.492Z</updated>
    
    <content type="html"><![CDATA[<h1 id="485-Max-Consecutive-Ones最大连续1的个数"><a href="#485-Max-Consecutive-Ones最大连续1的个数" class="headerlink" title="485. Max Consecutive Ones最大连续1的个数"></a>485. Max Consecutive Ones最大连续1的个数</h1><p>给定一个二进制数组， 计算其中最大连续1的个数。</p><a id="more"></a><p>示例 1:</p><p>输入: </p><pre><code>[1,1,0,1,1,1]</code></pre><p>输出: 3<br>解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3.<br>注意：</p><p>输入的数组只包含 0 和1。<br>输入数组的长度是正整数，且不超过 10,000。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>定义局部最大和全局最大</p><pre><code>class Solution {public:    int findMaxConsecutiveOnes(vector&lt;int&gt;&amp; nums) {        int maxlen=0,locallen=0;        for(auto n:nums){            if((n&amp;1)==0) locallen=0;            else {                locallen++;                maxlen=max(maxlen,locallen);            }        }        return maxlen;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;485-Max-Consecutive-Ones最大连续1的个数&quot;&gt;&lt;a href=&quot;#485-Max-Consecutive-Ones最大连续1的个数&quot; class=&quot;headerlink&quot; title=&quot;485. Max Consecutive Ones最大连续1的个数&quot;&gt;&lt;/a&gt;485. Max Consecutive Ones最大连续1的个数&lt;/h1&gt;&lt;p&gt;给定一个二进制数组， 计算其中最大连续1的个数。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>885. Spiral Matrix III螺旋矩阵 III</title>
    <link href="http://yoursite.com/2018/08/24/885.%20Spiral%20Matrix%20III/"/>
    <id>http://yoursite.com/2018/08/24/885. Spiral Matrix III/</id>
    <published>2018-08-24T02:32:12.000Z</published>
    <updated>2018-08-24T12:53:30.507Z</updated>
    
    <content type="html"><![CDATA[<h1 id="885-Spiral-Matrix-III螺旋矩阵-III"><a href="#885-Spiral-Matrix-III螺旋矩阵-III" class="headerlink" title="885. Spiral Matrix III螺旋矩阵 III"></a>885. Spiral Matrix III螺旋矩阵 III</h1><p>在 R 行 C 列的矩阵上，我们从 (r0, c0) 面朝东面开始</p><p>这里，网格的西北角位于第一行第一列，网格的东南角位于最后一行最后一列。</p><p>现在，我们以顺时针按螺旋状行走，访问此网格中的每个位置。</p><p>每当我们移动到网格的边界之外时，我们会继续在网格之外行走（但稍后可能会返回到网格边界）。</p><p>最终，我们到过网格的所有 R * C 个空间。</p><p>按照访问顺序返回表示网格位置的坐标列表。</p><a id="more"></a><p>示例 1：</p><pre><code>输入：R = 1, C = 4, r0 = 0, c0 = 0输出：[[0,0],[0,1],[0,2],[0,3]]</code></pre><p><img src="https://ws1.sinaimg.cn/large/0071ouepgy1ful2oluezbj304u02rglf.jpg" alt="image"></p><p>示例 2：</p><pre><code>输入：R = 5, C = 6, r0 = 1, c0 = 4输出：[[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]</code></pre><p><img src="https://ws1.sinaimg.cn/large/0071ouepgy1ful2oluezbj304u02rglf.jpg" alt="image"></p><p>提示：</p><p>1 &lt;= R &lt;= 100<br>1 &lt;= C &lt;= 100<br>0 &lt;= r0 &lt; R<br>0 &lt;= c0 &lt; C</p><h2 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h2><p>分步走，如果位置在格子内则将它加入res</p><p>观察运动轨迹：<br>右移一步，向右转<br>下移一步，向右转</p><p>左移两步，向右转<br>上移两步，向右转</p><p>右移三步，向右转<br>下移三步，向右转</p><p>左移四步，向右转<br>上移四步，向右转</p><p>所以问题变为如何生成序列：1，1，2，2，3，3，4，4，5，5…<br>和如何向右转</p><p>生成序列：<br>a[index]=index/2+1</p><p>右转：<br>使用叉乘假设当前的方向在平面中是（x,y),在空间中则为(x,y,0)<br>那么右转后的方向是(x,y,0)X(0,0,1)=(y,-x,0)<br>变成代码：temp=x;x=y;y=-temp;</p><p>方向数组是：<br>(0,1),(1,0),(0,-1),(-1,0)，可以用两个变量来表示</p><p>时间复杂度：<br>O(max(M,N) ^ 2)</p><pre><code>vector&lt;vector&lt;int&gt;&gt; spiralMatrixIII(int R, int C, int r, int c) {    vector&lt;vector&lt;int&gt;&gt; res = {{r, c}};    int x = 0, y = 1, tmp;    for (int n = 0; res.size() &lt; R * C; n++) {//every position        for (int i = 0; i &lt; n / 2 + 1; i++) {//on one direction            r += x, c += y;            if (0 &lt;= r &amp;&amp; r &lt; R &amp;&amp; 0 &lt;= c &amp;&amp; c &lt; C)                res.push_back({r, c});        }        tmp = x, x = y, y = -tmp;    }    return res;}</code></pre><h2 id="思路2："><a href="#思路2：" class="headerlink" title="思路2："></a>思路2：</h2><pre><code>class Solution {public:    vector&lt;vector&lt;int&gt;&gt; spiralMatrixIII(int R, int C, int r0, int c0) {        int rpos=r0,cpos=c0,dir=0,go=1;//dir is the direction in the dr[4] and dc[4]        int distan=0,total=0;        int dr[4]={0,1,0,-1};        int dc[4]={1,0,-1,0};        vector&lt;vector&lt;int&gt;&gt; res;        res.push_back({rpos,cpos});//push back the start position        total++;        while(total&lt;R*C){//total is the total visit numbers            for(int i=1;i&lt;=go;i++){                rpos+=dr[dir];//start to go                cpos+=dc[dir];                if(rpos&gt;=0 &amp;&amp; rpos&lt;R &amp;&amp; cpos&gt;=0 &amp;&amp; cpos&lt;C){// push back the eanswer if it is in the grid                    res.push_back({rpos,cpos});                    total++;                }            }            if(distan &amp;1){//每隔两次访问步数加1，即恰好为奇数时访问步数加1                go++;            }            distan++;            dir++;            dir%=4;//change direction        }        return res;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;885-Spiral-Matrix-III螺旋矩阵-III&quot;&gt;&lt;a href=&quot;#885-Spiral-Matrix-III螺旋矩阵-III&quot; class=&quot;headerlink&quot; title=&quot;885. Spiral Matrix III螺旋矩阵 III&quot;&gt;&lt;/a&gt;885. Spiral Matrix III螺旋矩阵 III&lt;/h1&gt;&lt;p&gt;在 R 行 C 列的矩阵上，我们从 (r0, c0) 面朝东面开始&lt;/p&gt;
&lt;p&gt;这里，网格的西北角位于第一行第一列，网格的东南角位于最后一行最后一列。&lt;/p&gt;
&lt;p&gt;现在，我们以顺时针按螺旋状行走，访问此网格中的每个位置。&lt;/p&gt;
&lt;p&gt;每当我们移动到网格的边界之外时，我们会继续在网格之外行走（但稍后可能会返回到网格边界）。&lt;/p&gt;
&lt;p&gt;最终，我们到过网格的所有 R * C 个空间。&lt;/p&gt;
&lt;p&gt;按照访问顺序返回表示网格位置的坐标列表。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>20.PrintMatrix顺时针打印矩阵(CodingInterview)</title>
    <link href="http://yoursite.com/2018/08/24/%E5%89%91%E6%8C%87Offer20.%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"/>
    <id>http://yoursite.com/2018/08/24/剑指Offer20.顺时针打印矩阵/</id>
    <published>2018-08-24T01:35:00.000Z</published>
    <updated>2018-08-24T01:35:58.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="20-PrintMatrix顺时针打印矩阵-CodingInterview"><a href="#20-PrintMatrix顺时针打印矩阵-CodingInterview" class="headerlink" title="20.PrintMatrix顺时针打印矩阵(CodingInterview)"></a>20.PrintMatrix顺时针打印矩阵(CodingInterview)</h1><p>与其类似的一道题是LeetCode上的54. Spiral Matrix</p><p>题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><a id="more"></a><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>设矩阵的行数为row，列数为col，以一个5X5的矩阵为例，第一圈左上角坐标为（0，0），第二圈左上角坐标为（1，1），行列坐标相同，因此选取（start，start）作为起点。</p><p>最后一圈只有一个数字，对应坐标为（2，2）。注意到5&gt;2<em>2。对于6X6的矩阵6&gt;2</em>2仍然成立。因此可以得到让循环继续的条件是</p><pre><code>col&gt;start*2 &amp;&amp; row&gt;start*2</code></pre><p>可以解释为因为矩阵是对称的，所以为了能完整打印一圈startX和startY不会超出行列数的一半</p><p>考虑如何实现打印一圈的功能，可以分为向右-&gt;向下-&gt;向上-&gt;向左四步，值得注意的是最后一圈可能退化成只有一行，一列或一个数字，因此此时打印一圈就不需要四步，而缩减为三步、两步、一步。<br>所以要分析打印每一步的前提条件。</p><p>打印第一步时候不需要前提条件</p><p>打印第二步时至少需要有两行，endY&gt;startY</p><p>打印第三步时除了至少需要有两行还至少需要有两列 endY&gt;startY &amp;&amp; endX&gt;startX</p><p>打印第四步时至少需要三行两列 endY&gt;startY+1 &amp;&amp; endX&gt;startX</p><p>与此同时还要注意每一步的起始位置不要与上一步重合</p><pre><code>//==================================================================// 《剑指Offer——名企面试官精讲典型编程题》代码// 面试题29：顺时针打印矩阵// 题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。#include &lt;cstdio&gt;void PrintMatrixInCircle(int** numbers, int columns, int rows, int start);void printNumber(int number);void PrintMatrixClockwisely(int** numbers, int columns, int rows){    if (numbers == nullptr || columns &lt;= 0 || rows &lt;= 0)        return;    int start = 0;    while (columns &gt; start * 2 &amp;&amp; rows &gt; start * 2)    {        PrintMatrixInCircle(numbers, columns, rows, start);        ++start;    }}void PrintMatrixInCircle(int** numbers, int columns, int rows, int start){    int endX = columns - 1 - start;    int endY = rows - 1 - start;    // 从左到右打印一行    for (int i = start; i &lt;= endX; ++i)    {        int number = numbers[start][i];        printNumber(number);    }    // 从上到下打印一列    if (start &lt; endY)    {        for (int i = start + 1; i &lt;= endY; ++i)        {            int number = numbers[i][endX];            printNumber(number);        }    }    // 从右到左打印一行    if (start &lt; endX &amp;&amp; start &lt; endY)    {        for (int i = endX - 1; i &gt;= start; --i)        {            int number = numbers[endY][i];            printNumber(number);        }    }    // 从下到上打印一行    if (start &lt; endX &amp;&amp; start &lt; endY - 1)    {        for (int i = endY - 1; i &gt;= start + 1; --i)        {            int number = numbers[i][start];            printNumber(number);        }    }}void printNumber(int number){    printf(&quot;%d\t&quot;, number);}// ====================测试代码====================void Test(int columns, int rows){    printf(&quot;Test Begin: %d columns, %d rows.\n&quot;, columns, rows);    if (columns &lt; 1 || rows &lt; 1)        return;    int** numbers = new int*[rows];    for (int i = 0; i &lt; rows; ++i)    {        numbers[i] = new int[columns];        for (int j = 0; j &lt; columns; ++j)        {            numbers[i][j] = i * columns + j + 1;        }    }    PrintMatrixClockwisely(numbers, columns, rows);    printf(&quot;\n&quot;);    for (int i = 0; i &lt; rows; ++i)        delete[](int*)numbers[i];    delete[] numbers;}int main(int argc, char* argv[]){    /*    1    */    Test(1, 1);    /*    1    2    3    4    */    Test(2, 2);    /*    1    2    3    4    5    6    7    8    9    10   11   12    13   14   15   16    */    Test(4, 4);    /*    1    2    3    4    5    6    7    8    9    10    11   12   13   14   15    16   17   18   19   20    21   22   23   24   25    */    Test(5, 5);    /*    1    2    3    4    5    */    Test(1, 5);    /*    1    2    3    4    5    6    7    8    9    10    */    Test(2, 5);    /*    1    2    3    4    5    6    7    8    9    10   11   12    13   14   15    */    Test(3, 5);    /*    1    2    3    4    5    6    7    8    9    10   11   12    13   14   15   16    17   18   19   20    */    Test(4, 5);    /*    1    2    3    4    5    */    Test(5, 1);    /*    1    2    3    4    5    6    7    8    9    10    */    Test(5, 2);    /*    1    2    3    4    5    6    7    8    9    10    11   12   13   14    15    */    Test(5, 3);    /*    1    2    3    4    5    6    7    8    9    10    11   12   13   14   15    16   17   18   19   20    */    Test(5, 4);    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;20-PrintMatrix顺时针打印矩阵-CodingInterview&quot;&gt;&lt;a href=&quot;#20-PrintMatrix顺时针打印矩阵-CodingInterview&quot; class=&quot;headerlink&quot; title=&quot;20.PrintMatrix顺时针打印矩阵(CodingInterview)&quot;&gt;&lt;/a&gt;20.PrintMatrix顺时针打印矩阵(CodingInterview)&lt;/h1&gt;&lt;p&gt;与其类似的一道题是LeetCode上的54. Spiral Matrix&lt;/p&gt;
&lt;p&gt;题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Coding Interviews" scheme="http://yoursite.com/tags/Coding-Interviews/"/>
    
  </entry>
  
  <entry>
    <title>650. 2 Keys Keyboard只有两个键的键盘</title>
    <link href="http://yoursite.com/2018/08/24/650.%202%20Keys%20Keyboard%E5%8F%AA%E6%9C%89%E4%B8%A4%E4%B8%AA%E9%94%AE%E7%9A%84%E9%94%AE%E7%9B%98/"/>
    <id>http://yoursite.com/2018/08/24/650. 2 Keys Keyboard只有两个键的键盘/</id>
    <published>2018-08-24T01:30:12.000Z</published>
    <updated>2018-08-26T11:12:29.003Z</updated>
    
    <content type="html"><![CDATA[<h1 id="650-2-Keys-Keyboard只有两个键的键盘"><a href="#650-2-Keys-Keyboard只有两个键的键盘" class="headerlink" title="650. 2 Keys Keyboard只有两个键的键盘"></a>650. 2 Keys Keyboard只有两个键的键盘</h1><p>最初在一个记事本上只有一个字符 ‘A’。你每次可以对这个记事本进行两种操作：</p><p>Copy All (复制全部) : 你可以复制这个记事本中的所有字符(部分的复制是不允许的)。<br>Paste (粘贴) : 你可以粘贴你上一次复制的字符。<br>给定一个数字 n 。你需要使用最少的操作次数，在记事本中打印出恰好 n 个 ‘A’。输出能够打印出 n 个 ‘A’ 的最少操作次数。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: 3输出: 3解释:最初, 我们只有一个字符 &apos;A&apos;。第 1 步, 我们使用 Copy All 操作。第 2 步, 我们使用 Paste 操作来获得 &apos;AA&apos;。第 3 步, 我们使用 Paste 操作来获得 &apos;AAA&apos;。</code></pre><p>说明:</p><pre><code>n 的取值范围是 [1, 1000] 。</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>其实这道题就是将N分解为M个数字的乘积，且M个数字的和最小</p><p>我们寻找一个因子d使得我们能够做d次拷贝（n/d）来得到n</p><p>做d次拷贝需要采取d步（第一步全部复制，d-1次粘贴）</p><p>我们需要通过循环来找到这个d</p><p>时间复杂度评估：<br>最好的情况下O（log(n)) ，例如n=1024时需要十次迭代<br>最差情况下当n为一些大的质数的乘积</p><pre><code>public int minSteps(int n) {       int s = 0;       for (int d = 2; d &lt;= n; d++) {           while (n % d == 0) {               s += d;               n /= d;           }       }       return s;   }</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;650-2-Keys-Keyboard只有两个键的键盘&quot;&gt;&lt;a href=&quot;#650-2-Keys-Keyboard只有两个键的键盘&quot; class=&quot;headerlink&quot; title=&quot;650. 2 Keys Keyboard只有两个键的键盘&quot;&gt;&lt;/a&gt;650. 2 Keys Keyboard只有两个键的键盘&lt;/h1&gt;&lt;p&gt;最初在一个记事本上只有一个字符 ‘A’。你每次可以对这个记事本进行两种操作：&lt;/p&gt;
&lt;p&gt;Copy All (复制全部) : 你可以复制这个记事本中的所有字符(部分的复制是不允许的)。&lt;br&gt;Paste (粘贴) : 你可以粘贴你上一次复制的字符。&lt;br&gt;给定一个数字 n 。你需要使用最少的操作次数，在记事本中打印出恰好 n 个 ‘A’。输出能够打印出 n 个 ‘A’ 的最少操作次数。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>59. Spiral Matrix II螺旋矩阵 II</title>
    <link href="http://yoursite.com/2018/08/24/59.%20Spiral%20Matrix%20II%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%20II/"/>
    <id>http://yoursite.com/2018/08/24/59. Spiral Matrix II螺旋矩阵 II/</id>
    <published>2018-08-24T01:30:12.000Z</published>
    <updated>2018-08-24T07:09:48.754Z</updated>
    
    <content type="html"><![CDATA[<h1 id="59-Spiral-Matrix-II螺旋矩阵-II"><a href="#59-Spiral-Matrix-II螺旋矩阵-II" class="headerlink" title="59. Spiral Matrix II螺旋矩阵 II"></a>59. Spiral Matrix II螺旋矩阵 II</h1><p>给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p><a id="more"></a><p>示例:</p><p>输入: 3<br>输出:</p><pre><code>[ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ]]</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>此题可以参见剑指Offer20.PrintMatrix顺时针打印矩阵(CodingInterview)和54. Spiral Matrix螺旋矩阵</p><p>所不同的是可以先生成一个n*n规模的矩阵然后螺旋将数字填入，时间复杂度是O(n^2)。</p><pre><code>class Solution {public:    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) {        vector&lt;vector&lt;int&gt;&gt; res(n,vector&lt;int&gt;(n,0));        int start=0;        int num=1;        while(start*2&lt;n){            generate(res,start,num,n);            start++;        }        return res;    }    void generate(vector&lt;vector&lt;int&gt;&gt; &amp;res,int start,int &amp;num,int n){        int endy=n-start-1;        int endx=n-start-1;        for(int j=start;j&lt;=endy;j++){            res[start][j]=num;            num++;        }        for(int i=start+1;i&lt;=endx;i++){            res[i][endy]=num;            num++;        }        for(int j=endy-1;j&gt;=start;j--){            res[endx][j]=num;            num++;        }        for(int i=endx-1;i&gt;start;i--){            res[i][start]=num;            num++;        }    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;59-Spiral-Matrix-II螺旋矩阵-II&quot;&gt;&lt;a href=&quot;#59-Spiral-Matrix-II螺旋矩阵-II&quot; class=&quot;headerlink&quot; title=&quot;59. Spiral Matrix II螺旋矩阵 II&quot;&gt;&lt;/a&gt;59. Spiral Matrix II螺旋矩阵 II&lt;/h1&gt;&lt;p&gt;给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>在浏览器地址栏输入URL，按下回车后发生了什么</title>
    <link href="http://yoursite.com/2018/08/23/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5URL%EF%BC%8C%E6%8C%89%E4%B8%8B%E5%9B%9E%E8%BD%A6%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>http://yoursite.com/2018/08/23/在浏览器地址栏输入URL，按下回车后发生了什么/</id>
    <published>2018-08-23T01:06:12.000Z</published>
    <updated>2018-08-23T01:30:21.787Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在浏览器地址栏输入URL，按下回车后发生了什么"><a href="#在浏览器地址栏输入URL，按下回车后发生了什么" class="headerlink" title="在浏览器地址栏输入URL，按下回车后发生了什么"></a>在浏览器地址栏输入URL，按下回车后发生了什么</h1><p>这道题目没有所谓的完全的正确答案，这个题目可以让你在任意的一个点深入下去， 只要你对这个点是熟悉的。以下是一个大概流程：</p><a id="more"></a><h2 id="解答1："><a href="#解答1：" class="headerlink" title="解答1："></a>解答1：</h2><h3 id="1-浏览器向DNS服务器查找输入URL对应的IP地址。"><a href="#1-浏览器向DNS服务器查找输入URL对应的IP地址。" class="headerlink" title="1.浏览器向DNS服务器查找输入URL对应的IP地址。"></a>1.浏览器向DNS服务器查找输入URL对应的IP地址。</h3><h3 id="2-DNS服务器返回网站的IP地址。"><a href="#2-DNS服务器返回网站的IP地址。" class="headerlink" title="2.DNS服务器返回网站的IP地址。"></a>2.DNS服务器返回网站的IP地址。</h3><h3 id="3-浏览器根据IP地址与目标web服务器在80端口上建立TCP连接"><a href="#3-浏览器根据IP地址与目标web服务器在80端口上建立TCP连接" class="headerlink" title="3.浏览器根据IP地址与目标web服务器在80端口上建立TCP连接"></a>3.浏览器根据IP地址与目标web服务器在80端口上建立TCP连接</h3><h3 id="4-浏览器获取请求页面的html代码。"><a href="#4-浏览器获取请求页面的html代码。" class="headerlink" title="4.浏览器获取请求页面的html代码。"></a>4.浏览器获取请求页面的html代码。</h3><h3 id="5-浏览器在显示窗口内渲染HTML。"><a href="#5-浏览器在显示窗口内渲染HTML。" class="headerlink" title="5.浏览器在显示窗口内渲染HTML。"></a>5.浏览器在显示窗口内渲染HTML。</h3><h3 id="6-窗口关闭时，浏览器终止与服务器的连接。"><a href="#6-窗口关闭时，浏览器终止与服务器的连接。" class="headerlink" title="6.窗口关闭时，浏览器终止与服务器的连接。"></a>6.窗口关闭时，浏览器终止与服务器的连接。</h3><p>这其中最有趣的是第1步和第2步(域名解析)。我们输入的网址(域名)是IP地址的一个别名， 在一个DNS内，一个域名对应一个IP地址。域名系统(DNS) 的工作就是将域名与它的IP地址对应起来。DNS是分布式的，同时也是具有层级关系的。</p><h2 id="解答2："><a href="#解答2：" class="headerlink" title="解答2："></a>解答2：</h2><p>当我们用浏览器访问一个网页时，浏览器先尝试从Host文件中获取 <a href="http://www.baidu.com/对应的IP地址，如何不能取到就是用DNS协议来获取IP。在DNS协议中PC会向你的本地DNS服务器求助（一般是路由器），希望从本地DNS服务器那里得到百度的IP，如果得不到本地DNS服务器会向更高层次的DNS服务器求助.......,最终总能得到百度的IP。" target="_blank" rel="noopener">http://www.baidu.com/对应的IP地址，如何不能取到就是用DNS协议来获取IP。在DNS协议中PC会向你的本地DNS服务器求助（一般是路由器），希望从本地DNS服务器那里得到百度的IP，如果得不到本地DNS服务器会向更高层次的DNS服务器求助.......,最终总能得到百度的IP。</a></p><p>得到百度的IP，下一步使用TCP协议，建立TCP连接。在TCP协议中建立TCP需要与百度服务器握手三次，你先告诉服务器你要给服务器发东西（SYN），服务器应答你并告诉你它也要给你发东西（SYN，ACK），然后你向应答服务器（SYN，ACK）做出应答，总共来回了三次，成为3次握手。不过，建立TCP连接有个前提，你必须能够成功地把消息发到服务器上。</p><p>为了将消息从你的PC上传到服务器上，需要用到IP协议、ARP协议和OSPF协议。我们都知道，你的PC和百度服务器之间一般会有许多路由器之类的东西，IP协议指定了出发地和目的地；你的数据会经过一个又一个路由器，OSPF决定了会经过哪些路由器（用一种路由算法，找出最佳路径）从一个路由器怎么传给下一个路由器，这是ARP协议的工作，ARP负责求下一个节点的地址。IP协议使用的是IP地址，整个发送过程中只涉及出发地和目的地2个IP地址，而ARP协议使用的是MAC地址，整个发送过程中涉及到每一个节点的MAC地址。</p><p>现在，我们能和服务器通信，还建立TCP连接，下一步就是用HTTP协议请求网页内容了。你发个http请求报文给服务器，如果服务器禁止你访问就给你回个“forbidden”，如果他暂时挂掉了就给你回个“内部服务错误”，如果它正常才给你回个“OK”，并将你要的数据传给你；如果你有其他需要的东西再去给他要。你收到了服务器的回复，是一坨html的文本，浏览器必须能够理解文本的内容，并快速的渲染到屏幕上。渲染出来后，就可以看到网页了。</p><h2 id="解答3"><a href="#解答3" class="headerlink" title="解答3"></a>解答3</h2><h3 id="基本流程："><a href="#基本流程：" class="headerlink" title="基本流程："></a>基本流程：</h3><p>①查询ip地址</p><p>②建立tcp连接，接入服务器</p><p>③浏览器发起http请求</p><p>④服务器后台操作并做出http响应</p><p>⑤网页的解析与渲染</p><h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><p>查询ip地址<br>①浏览器解析出url中的域名。</p><p>②查询浏览器的DNS缓存。</p><p>③浏览器中没有DNS缓存，则查找本地客户端hosts文件有无对应的ip地址。</p><p>④hosts中无，则查找本地DNS服务器（运营商提供的DNS服务器）有无对应的DNS缓存。</p><p>⑤若本地DNS没有DNS缓存，则向根服务器查询，进行递归查找。</p><p>⑥递归查找从顶级域名开始（如.com）,一步步缩小范围，最终客户端取得ip地址。</p><p>tcp连接与http连接<br>①http协议建立在tcp协议之上，http请求前，需先进行tcp连接，形成客户端到服务器的稳定的通道。俗称TCP的三次握手。</p><p>②tcp连接完成后，http请求开始，请求有多种方式，常见的有get，post等。</p><p>③http请求包含请求头，也可能包含请求体两部分，请求头中包含我们希望对请求文件的操作的信息，请求体中包含传递给后台的参数。</p><p>④服务器收到http请求后，后台开始工作，如负载平衡，跨域等，这里就是后端的工作了。</p><p>⑤文件处理完毕，生成响应数据包，响应也包含两部分，响应头和相应体，响应体就是我们所请求的文件。</p><p>⑥经过网络传输，文件被下载到本地客户端，客户端开始加载。</p><p>html渲染<br>①客户端浏览器加载了html文件后，由上到下解析html为DOM树（DOM Tree）。</p><p>②遇到css文件，css中的url发起http请求。</p><p>③这是第二次http请求，由于http1.1协议增加了Connection: keep-alive声明，故tcp连接不会关闭，可以复用。</p><p>④http连接是无状态连接，客户端与服务器端需要重新发起请求–响应。</p><p>在请求css的过程中，解析器继续解析html，然后到了script标签。</p><p>⑤由于script可能会改变DOM结构，故解析器停止生成DOM树，解析器被js阻塞，等待js文件发起http请求，然后加载。这是第三次http请求。js执行完成后解析器继续解析。</p><p>⑥由于css文件可能会影响js文件的执行结果，因此需等css文件加载完成后再执行。</p><p>⑦浏览器收到css文件后，开始解析css文件为CSSOM树（CSS Rule Tree）。</p><p>⑧CSSOM树生成后，DOM Tree与CSS Rule Tree结合生成渲染树（Render Tree）。</p><p>⑨Render Tree会被css文件阻塞，渲染树生成后，先布局，绘制渲染树中节点的属性(位置，宽度，大小等)，然后渲染，页面就会呈现信息。</p><p>⑩继续边解析边渲染，遇到了另一个js文件，js文件执行后改变了DOM树，渲染树从被改变的dom开始再次渲染。</p><p>⑪继续向下渲染，碰到一个img标签，浏览器发起http请求，不会等待img加载完成，继续向下渲染，之后再重新渲染此部分。</p><p>⑫DOM树遇到html结束标签，停止解析，进而渲染结束。</p><h3 id="扩展思考"><a href="#扩展思考" class="headerlink" title="扩展思考"></a>扩展思考</h3><p>有那些网站优化的方法？<br>①减少DNS查询:将服务器域名的ip信息加入本地host文件。</p><p>②减少http请求数量，对于图片使用雪碧图,对于html文件和css文件，js文件分别进行合并操作。</p><p>③减少下载时间：压缩图片，使用压缩应用压缩文档中的空格，删除文件多余的语句和注释，创造自己的js精简库和精简框架,使用本地浏览器缓存。</p><p>④提前渲染开始时间：将css链接放在html头部。</p><p>⑤减轻解析器的阻塞：将js链接放在body尾部</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;在浏览器地址栏输入URL，按下回车后发生了什么&quot;&gt;&lt;a href=&quot;#在浏览器地址栏输入URL，按下回车后发生了什么&quot; class=&quot;headerlink&quot; title=&quot;在浏览器地址栏输入URL，按下回车后发生了什么&quot;&gt;&lt;/a&gt;在浏览器地址栏输入URL，按下回车后发生了什么&lt;/h1&gt;&lt;p&gt;这道题目没有所谓的完全的正确答案，这个题目可以让你在任意的一个点深入下去， 只要你对这个点是熟悉的。以下是一个大概流程：&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="TCPIP" scheme="http://yoursite.com/tags/TCPIP/"/>
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>59.SymmetricalBinaryTree对称的二叉树(CodingInterview)</title>
    <link href="http://yoursite.com/2018/08/23/%E5%89%91%E6%8C%87Offer59.%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2018/08/23/剑指Offer59.对称的二叉树/</id>
    <published>2018-08-23T00:45:12.000Z</published>
    <updated>2018-08-24T02:04:28.134Z</updated>
    
    <content type="html"><![CDATA[<h1 id="59-SymmetricalBinaryTree对称的二叉树-CodingInterview"><a href="#59-SymmetricalBinaryTree对称的二叉树-CodingInterview" class="headerlink" title="59.SymmetricalBinaryTree对称的二叉树(CodingInterview)"></a>59.SymmetricalBinaryTree对称的二叉树(CodingInterview)</h1><p>与其类似的一道题是LeetCode上的101. Symmetric Tree</p><p>请实现一个函数，用来判断一颗二叉树是不是对称的。<br>注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p><a id="more"></a><h2 id="Recursive递归解法："><a href="#Recursive递归解法：" class="headerlink" title="Recursive递归解法："></a>Recursive递归解法：</h2><p>定义一种对称的前序遍历算法，即先遍历父节点，再遍历它的右子节点，最后遍历它的左子节点。</p><p>可以通过对比二叉树的前序遍历序列和对称前序遍历序列来判断二叉树是不是对称的。如果两个序列是一样的那么二叉树是对称的。</p><pre><code>bool isSymmetrical(BinaryTreeNode* pRoot1, BinaryTreeNode* pRoot2);bool isSymmetrical(BinaryTreeNode* pRoot){    return isSymmetrical(pRoot, pRoot);}bool isSymmetrical(BinaryTreeNode* pRoot1, BinaryTreeNode* pRoot2){    if (pRoot1 == NULL &amp;&amp; pRoot2 == NULL) return true;    else if (pRoot1 == NULL || pRoot2 == NULL) return false;    else if (pRoot1-&gt;m_nValue != pRoot2-&gt;m_nValue) return false;    return isSymmetrical(pRoot1-&gt;m_pLeft, pRoot2-&gt;m_pRight) &amp;&amp; isSymmetrical(pRoot2-&gt;m_pRight, pRoot1-&gt;m_pLeft);}</code></pre><h2 id="Non-Recursive-use-queue-非递归解法"><a href="#Non-Recursive-use-queue-非递归解法" class="headerlink" title="Non-Recursive(use queue)非递归解法:"></a>Non-Recursive(use queue)非递归解法:</h2><p>使用队列进行层次遍历，当队列非空的时候对队列中的结点进行判断，再每次将下一层的所有节点按照对称的顺序入队</p><pre><code>#include&lt;iostream&gt;#include &lt;cstdio&gt;#include &quot;BinaryTree.h&quot;using namespace std;bool isSymmetrical(BinaryTreeNode* pRoot){    if (pRoot == NULL) return true;    queue&lt;BinaryTreeNode*&gt; queue;    queue.push(pRoot-&gt;m_pLeft);    queue.push(pRoot-&gt;m_pRight);    while (!queue.empty())    {        BinaryTreeNode *left = queue.front(); queue.pop();        BinaryTreeNode *right = queue.front(); queue.pop();        if (!left &amp;&amp; !right) continue;        else if (!left || !right) return false;        else if (left-&gt;m_nValue != right-&gt;m_nValue) return false;        queue.push(left-&gt;m_pLeft);        queue.push(right-&gt;m_pRight);        queue.push(left-&gt;m_pRight);        queue.push(right-&gt;m_pLeft);    }    return true;}// ====================测试代码====================void Test(char* testName, BinaryTreeNode* pRoot, bool expected){    if (testName != nullptr)        printf(&quot;%s begins: &quot;, testName);    if (isSymmetrical(pRoot) == expected)        printf(&quot;Passed.\n&quot;);    else        printf(&quot;FAILED.\n&quot;);}//            8//        6      6//       5 7    7 5void Test1(){    BinaryTreeNode* pNode8 = CreateBinaryTreeNode(8);    BinaryTreeNode* pNode61 = CreateBinaryTreeNode(6);    BinaryTreeNode* pNode62 = CreateBinaryTreeNode(6);    BinaryTreeNode* pNode51 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode71 = CreateBinaryTreeNode(7);    BinaryTreeNode* pNode72 = CreateBinaryTreeNode(7);    BinaryTreeNode* pNode52 = CreateBinaryTreeNode(5);    ConnectTreeNodes(pNode8, pNode61, pNode62);    ConnectTreeNodes(pNode61, pNode51, pNode71);    ConnectTreeNodes(pNode62, pNode72, pNode52);    Test(&quot;Test1&quot;, pNode8, true);    DestroyTree(pNode8);}//            8//        6      9//       5 7    7 5void Test2(){    BinaryTreeNode* pNode8 = CreateBinaryTreeNode(8);    BinaryTreeNode* pNode61 = CreateBinaryTreeNode(6);    BinaryTreeNode* pNode9 = CreateBinaryTreeNode(9);    BinaryTreeNode* pNode51 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode71 = CreateBinaryTreeNode(7);    BinaryTreeNode* pNode72 = CreateBinaryTreeNode(7);    BinaryTreeNode* pNode52 = CreateBinaryTreeNode(5);    ConnectTreeNodes(pNode8, pNode61, pNode9);    ConnectTreeNodes(pNode61, pNode51, pNode71);    ConnectTreeNodes(pNode9, pNode72, pNode52);    Test(&quot;Test2&quot;, pNode8, false);    DestroyTree(pNode8);}//            8//        6      6//       5 7    7void Test3(){    BinaryTreeNode* pNode8 = CreateBinaryTreeNode(8);    BinaryTreeNode* pNode61 = CreateBinaryTreeNode(6);    BinaryTreeNode* pNode62 = CreateBinaryTreeNode(6);    BinaryTreeNode* pNode51 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode71 = CreateBinaryTreeNode(7);    BinaryTreeNode* pNode72 = CreateBinaryTreeNode(7);    ConnectTreeNodes(pNode8, pNode61, pNode62);    ConnectTreeNodes(pNode61, pNode51, pNode71);    ConnectTreeNodes(pNode62, pNode72, nullptr);    Test(&quot;Test3&quot;, pNode8, false);    DestroyTree(pNode8);}//               5//              / \//             3   3//            /     \//           4       4//          /         \//         2           2//        /             \//       1               1void Test4(){    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode31 = CreateBinaryTreeNode(3);    BinaryTreeNode* pNode32 = CreateBinaryTreeNode(3);    BinaryTreeNode* pNode41 = CreateBinaryTreeNode(4);    BinaryTreeNode* pNode42 = CreateBinaryTreeNode(4);    BinaryTreeNode* pNode21 = CreateBinaryTreeNode(2);    BinaryTreeNode* pNode22 = CreateBinaryTreeNode(2);    BinaryTreeNode* pNode11 = CreateBinaryTreeNode(1);    BinaryTreeNode* pNode12 = CreateBinaryTreeNode(1);    ConnectTreeNodes(pNode5, pNode31, pNode32);    ConnectTreeNodes(pNode31, pNode41, nullptr);    ConnectTreeNodes(pNode32, nullptr, pNode42);    ConnectTreeNodes(pNode41, pNode21, nullptr);    ConnectTreeNodes(pNode42, nullptr, pNode22);    ConnectTreeNodes(pNode21, pNode11, nullptr);    ConnectTreeNodes(pNode22, nullptr, pNode12);    Test(&quot;Test4&quot;, pNode5, true);    DestroyTree(pNode5);}//               5//              / \//             3   3//            /     \//           4       4//          /         \//         6           2//        /             \//       1               1void Test5(){    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode31 = CreateBinaryTreeNode(3);    BinaryTreeNode* pNode32 = CreateBinaryTreeNode(3);    BinaryTreeNode* pNode41 = CreateBinaryTreeNode(4);    BinaryTreeNode* pNode42 = CreateBinaryTreeNode(4);    BinaryTreeNode* pNode6 = CreateBinaryTreeNode(6);    BinaryTreeNode* pNode22 = CreateBinaryTreeNode(2);    BinaryTreeNode* pNode11 = CreateBinaryTreeNode(1);    BinaryTreeNode* pNode12 = CreateBinaryTreeNode(1);    ConnectTreeNodes(pNode5, pNode31, pNode32);    ConnectTreeNodes(pNode31, pNode41, nullptr);    ConnectTreeNodes(pNode32, nullptr, pNode42);    ConnectTreeNodes(pNode41, pNode6, nullptr);    ConnectTreeNodes(pNode42, nullptr, pNode22);    ConnectTreeNodes(pNode6, pNode11, nullptr);    ConnectTreeNodes(pNode22, nullptr, pNode12);    Test(&quot;Test5&quot;, pNode5, false);    DestroyTree(pNode5);}//               5//              / \//             3   3//            /     \//           4       4//          /         \//         2           2//                      \//                       1void Test6(){    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode31 = CreateBinaryTreeNode(3);    BinaryTreeNode* pNode32 = CreateBinaryTreeNode(3);    BinaryTreeNode* pNode41 = CreateBinaryTreeNode(4);    BinaryTreeNode* pNode42 = CreateBinaryTreeNode(4);    BinaryTreeNode* pNode21 = CreateBinaryTreeNode(2);    BinaryTreeNode* pNode22 = CreateBinaryTreeNode(2);    BinaryTreeNode* pNode12 = CreateBinaryTreeNode(1);    ConnectTreeNodes(pNode5, pNode31, pNode32);    ConnectTreeNodes(pNode31, pNode41, nullptr);    ConnectTreeNodes(pNode32, nullptr, pNode42);    ConnectTreeNodes(pNode41, pNode21, nullptr);    ConnectTreeNodes(pNode42, nullptr, pNode22);    ConnectTreeNodes(pNode21, nullptr, nullptr);    ConnectTreeNodes(pNode22, nullptr, pNode12);    Test(&quot;Test6&quot;, pNode5, false);    DestroyTree(pNode5);}// 只有一个结点void Test7(){    BinaryTreeNode* pNode1 = CreateBinaryTreeNode(1);    Test(&quot;Test7&quot;, pNode1, true);    DestroyTree(pNode1);}// 没有结点void Test8(){    Test(&quot;Test8&quot;, nullptr, true);}// 所有结点都有相同的值，树对称//               5//              / \//             5   5//            /     \//           5       5//          /         \//         5           5void Test9(){    BinaryTreeNode* pNode1 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode21 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode22 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode31 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode32 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode41 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode42 = CreateBinaryTreeNode(5);    ConnectTreeNodes(pNode1, pNode21, pNode22);    ConnectTreeNodes(pNode21, pNode31, nullptr);    ConnectTreeNodes(pNode22, nullptr, pNode32);    ConnectTreeNodes(pNode31, pNode41, nullptr);    ConnectTreeNodes(pNode32, nullptr, pNode42);    ConnectTreeNodes(pNode41, nullptr, nullptr);    ConnectTreeNodes(pNode42, nullptr, nullptr);    Test(&quot;Test9&quot;, pNode1, true);    DestroyTree(pNode1);}// 所有结点都有相同的值，树不对称//               5//              / \//             5   5//            /     \//           5       5//          /       ///         5       5void Test10(){    BinaryTreeNode* pNode1 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode21 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode22 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode31 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode32 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode41 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode42 = CreateBinaryTreeNode(5);    ConnectTreeNodes(pNode1, pNode21, pNode22);    ConnectTreeNodes(pNode21, pNode31, nullptr);    ConnectTreeNodes(pNode22, nullptr, pNode32);    ConnectTreeNodes(pNode31, pNode41, nullptr);    ConnectTreeNodes(pNode32, pNode42, nullptr);    ConnectTreeNodes(pNode41, nullptr, nullptr);    ConnectTreeNodes(pNode42, nullptr, nullptr);    Test(&quot;Test10&quot;, pNode1, false);    DestroyTree(pNode1);}void main(int argc, char* argv[]){    Test1();    Test2();    Test3();    Test4();    Test5();    Test6();    Test7();    Test8();    Test9();    Test10();}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;59-SymmetricalBinaryTree对称的二叉树-CodingInterview&quot;&gt;&lt;a href=&quot;#59-SymmetricalBinaryTree对称的二叉树-CodingInterview&quot; class=&quot;headerlink&quot; title=&quot;59.SymmetricalBinaryTree对称的二叉树(CodingInterview)&quot;&gt;&lt;/a&gt;59.SymmetricalBinaryTree对称的二叉树(CodingInterview)&lt;/h1&gt;&lt;p&gt;与其类似的一道题是LeetCode上的101. Symmetric Tree&lt;/p&gt;
&lt;p&gt;请实现一个函数，用来判断一颗二叉树是不是对称的。&lt;br&gt;注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Coding Interviews" scheme="http://yoursite.com/tags/Coding-Interviews/"/>
    
      <category term="BinaryTree" scheme="http://yoursite.com/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer思路总结</title>
    <link href="http://yoursite.com/2018/08/23/%E5%89%91%E6%8C%87offer%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/08/23/剑指offer思路总结/</id>
    <published>2018-08-23T00:45:12.000Z</published>
    <updated>2018-08-23T03:26:40.658Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指offer思路总结"><a href="#剑指offer思路总结" class="headerlink" title="剑指offer思路总结"></a>剑指offer思路总结</h1><p>剑指offer已经刷过两遍，总结一下思路方便回忆</p><a id="more"></a><h2 id="13-在O-1-时间删除链表结点"><a href="#13-在O-1-时间删除链表结点" class="headerlink" title="13.在O(1)时间删除链表结点"></a>13.在O(1)时间删除链表结点</h2><pre><code>分情况讨论：先在链表中顺序搜索要删除的节点i不是尾结点：{    先将i的下一个结点j的内容复制到i    然后把i的指针指向结点j的下一个结点；    此时再删除结点j}链表只有一个结点{    则删除该结点    然后将其置为NULL    将头结点置为空}链表有多个结点而且要删除的结点是尾结点{    从头结点顺序遍历，只要找到该结点i的前序结点就可以，然后执行删除操作}</code></pre><h2 id="14-调整数组顺序使奇数位于偶数前面"><a href="#14-调整数组顺序使奇数位于偶数前面" class="headerlink" title="14.调整数组顺序使奇数位于偶数前面"></a>14.调整数组顺序使奇数位于偶数前面</h2><h3 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute Force"></a>Brute Force</h3><p>顺序扫描碰到偶数就将其放到末尾</p><h3 id="初级解法"><a href="#初级解法" class="headerlink" title="初级解法"></a>初级解法</h3><p>双指针指向头尾部分，头偶尾奇则交换两个数字</p><h3 id="可扩展解法"><a href="#可扩展解法" class="headerlink" title="可扩展解法"></a>可扩展解法</h3><p>仍使用头尾指针，但用函数指针的方法将判断奇偶的函数解耦出来，整体逻辑框架不需要改动</p><h2 id="15-链表中倒数第K个节点"><a href="#15-链表中倒数第K个节点" class="headerlink" title="15.链表中倒数第K个节点"></a>15.链表中倒数第K个节点</h2><p>快慢指针，快指针比慢指针领先k-1步出发，快指针到尾节点时慢指针指向的是所求</p><h3 id="举一反三"><a href="#举一反三" class="headerlink" title="举一反三"></a>举一反三</h3><h4 id="1-求链表中间结点"><a href="#1-求链表中间结点" class="headerlink" title="1.求链表中间结点"></a>1.求链表中间结点</h4><p>快慢指针，快指针每次走两步，慢指针每次走一步，快指针到末尾时慢指针指向中间结点</p><h4 id="2-判断单向链表是否成环"><a href="#2-判断单向链表是否成环" class="headerlink" title="2.判断单向链表是否成环"></a>2.判断单向链表是否成环</h4><p>同前面，若快指针追上慢指针则成环</p><h2 id="16-反转链表"><a href="#16-反转链表" class="headerlink" title="16.反转链表"></a>16.反转链表</h2><p>需要定义三个指针，指向当前遍历的结点，前一个结点和后一个结点,先要找到反转链表后的头结点即原始链表的尾节点，需要满足的条件是后结点为空</p><pre><code>////Non-RecursiveListNode* ReverseList(ListNode* pHead){    ListNode* pReversedHead = nullptr;    ListNode* pNode = pHead;    ListNode* pPrev = nullptr;    while (pNode != nullptr)    {        ListNode *pNext = pNode-&gt;m_pNext;        if (pNext == NULL) {//find the last node            pReversedHead = pNode;        }        pNode-&gt;m_pNext = pPrev;//Revserse        pPrev = pNode;// forward        pNode = pNext;    }    return pReversedHead;}ListNode* ReverseList(ListNode* pHead){    if (pHead == NULL || pHead-&gt;m_pNext == nullptr) return pHead;    ListNode *PReverseHead = pHead;    pHead=ReverseList(pHead-&gt;m_pNext);    PReverseHead-&gt;m_pNext-&gt;m_pNext = PReverseHead;//进入尾节点    PReverseHead-&gt;m_pNext = NULL;    return pHead;}</code></pre><h2 id="28-字符串的排列"><a href="#28-字符串的排列" class="headerlink" title="28.字符串的排列"></a>28.字符串的排列</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;剑指offer思路总结&quot;&gt;&lt;a href=&quot;#剑指offer思路总结&quot; class=&quot;headerlink&quot; title=&quot;剑指offer思路总结&quot;&gt;&lt;/a&gt;剑指offer思路总结&lt;/h1&gt;&lt;p&gt;剑指offer已经刷过两遍，总结一下思路方便回忆&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="Coding Interviews" scheme="http://yoursite.com/tags/Coding-Interviews/"/>
    
  </entry>
  
  <entry>
    <title>300. Longest Increasing Subsequence最长上升子序列</title>
    <link href="http://yoursite.com/2018/08/22/300.%20Longest%20Increasing%20Subsequence%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2018/08/22/300. Longest Increasing Subsequence最长上升子序列/</id>
    <published>2018-08-22T12:30:12.000Z</published>
    <updated>2018-08-24T07:08:41.770Z</updated>
    
    <content type="html"><![CDATA[<h1 id="300-Longest-Increasing-Subsequence最长上升子序列"><a href="#300-Longest-Increasing-Subsequence最长上升子序列" class="headerlink" title="300. Longest Increasing Subsequence最长上升子序列"></a>300. Longest Increasing Subsequence最长上升子序列</h1><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><a id="more"></a><p>示例:</p><p>输入:<br>    [10,9,2,5,3,7,101,18]</p><p>输出: 4 </p><p>解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</p><p>说明:</p><p>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。<br>你算法的时间复杂度应该为 O(n2) 。</p><p>进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?</p><h2 id="动态规划解法："><a href="#动态规划解法：" class="headerlink" title="动态规划解法："></a>动态规划解法：</h2><p>首先来看一种动态规划Dynamic Programming的解法，这种解法的时间复杂度为O(n^2)，类似brute force的解法，我们维护一个一维dp数组，其中dp[i]表示以nums[i]为结尾的最长递增子串的长度，对于每一个nums[i]，我们从第一个数再搜索到i，如果发现某个数小于nums[i]，我们更新dp[i]，更新方法为dp[i] = max(dp[i], dp[j] + 1)，即比较当前dp[i]的值和那个小于num[i]的数的dp值加1的大小，我们就这样不断的更新dp数组，到最后dp数组中最大的值就是我们要返回的LIS的长度，参见代码如下：</p><pre><code>class Solution {public:    int lengthOfLIS(vector&lt;int&gt;&amp; nums) {        vector&lt;int&gt; dp(nums.size(),1);        int res=0;        for(int i=0;i&lt;nums.size();i++){            for(int j=0;j&lt;i;j++){                if(nums[i]&gt;nums[j]){                    dp[i]=max(dp[i],dp[j]+1);                }            }            res=max(res,dp[i]);        }        return res;    }};</code></pre><h2 id="进阶：二分查找法"><a href="#进阶：二分查找法" class="headerlink" title="进阶：二分查找法"></a>进阶：二分查找法</h2><p>我们来看一种思路更清晰的二分查找法，跟上面那种方法很类似，思路是先建立一个空的dp数组，然后开始遍历原数组，对于每一个遍历到的数字，我们用二分查找法在dp数组找第一个不小于它的数字，如果这个数字不存在，那么直接在dp数组后面加上遍历到的数字，如果存在，则将这个数字更新为当前遍历到的数字，最后返回dp数字的长度即可.</p><p>特别注意的是dp数组的值可能不是一个真实的LIS。{4， 2， 4， 5， 3， 7}，那么算完后的ends数组为{2， 3， 5， 7}，可以发现它不是一个原数组的LIS，只是长度相等而已参见代码如下：</p><pre><code>class Solution {public:    int lengthOfLIS(vector&lt;int&gt;&amp; nums) {        vector&lt;int&gt; dp;        for(int i=0;i&lt;nums.size();i++){            int left=0,right=dp.size();            while(left&lt;right){                int mid=left+(right-left)/2;                if(dp[mid]&lt;nums[i]) left=mid+1;                else right=mid;            }            if(right&gt;=dp.size()) dp.push_back(nums[i]);            else dp[right]=nums[i];        }        return dp.size();    }};</code></pre><h2 id="进阶：利用lowerbound函数的二分查找法"><a href="#进阶：利用lowerbound函数的二分查找法" class="headerlink" title="进阶：利用lowerbound函数的二分查找法"></a>进阶：利用lowerbound函数的二分查找法</h2><p>还有一种比较tricky的二分查找法，利用到了C++中STL的lower_bound函数，lower_bound返回数组中第一个不小于指定值的元素，跟上面的算法类似，我们还需要一个一维数组v，然后对于遍历到的nums中每一个元素，找其lower_bound，如果没有lower_bound，说明新元素比一维数组的尾元素还要大，直接添加到数组v中，跟之前解法的思路相同了。如果有lower_bound，说明新元素不是最大的，将其lower_bound替换为新元素，这个过程跟之前解法的二分查找法的部分实现相同功能，最后也是返回数组v的长度，注意数组v也不一定是真实的LIS，参见代码如下：</p><pre><code>class Solution {public:    int lengthOfLIS(vector&lt;int&gt;&amp; nums) {        vector&lt;int&gt; dp;        for(auto n:nums){            auto it=lower_bound(dp.begin(),dp.end(),n);            if(it == dp.end()) dp.push_back(n);            else *it=n;        }        return dp.size();    }};</code></pre><h2 id="进阶：利用upperbound函数的二分查找法"><a href="#进阶：利用upperbound函数的二分查找法" class="headerlink" title="进阶：利用upperbound函数的二分查找法"></a>进阶：利用upperbound函数的二分查找法</h2><p>upper_bound是返回数组中第一个大于指定值的元素，和lower_bound的区别时，它不能返回和指定值相等的元素，那么当新进来的数和数组中尾元素一样大时，upper_bound无法返回这个元素，那么按之前算法的处理方法是加到数组中，这样就不是严格的递增子串了，所以我们要做个处理，在处理每个新进来的元素时，先判断数组v中有无此元素，有的话直接跳过，这样就避免了相同数字的情况，参见代码如下：</p><pre><code>class Solution {public:    int lengthOfLIS(vector&lt;int&gt;&amp; nums) {        vector&lt;int&gt; dp;        for(auto n:nums){            if(find(dp.begin(),dp.end(),n)!=dp.end()) continue;            auto it=upper_bound(dp.begin(),dp.end(),n);            if(it==dp.end()) dp.push_back(n);            else *it=n;        }        return dp.size();    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;300-Longest-Increasing-Subsequence最长上升子序列&quot;&gt;&lt;a href=&quot;#300-Longest-Increasing-Subsequence最长上升子序列&quot; class=&quot;headerlink&quot; title=&quot;300. Longest Increasing Subsequence最长上升子序列&quot;&gt;&lt;/a&gt;300. Longest Increasing Subsequence最长上升子序列&lt;/h1&gt;&lt;p&gt;给定一个无序的整数数组，找到其中最长上升子序列的长度。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>354. Russian Doll Envelopes俄罗斯套娃</title>
    <link href="http://yoursite.com/2018/08/22/354.%20Russian%20Doll%20Envelopes%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81/"/>
    <id>http://yoursite.com/2018/08/22/354. Russian Doll Envelopes俄罗斯套娃信封/</id>
    <published>2018-08-22T01:58:44.000Z</published>
    <updated>2018-08-22T13:15:14.247Z</updated>
    
    <content type="html"><![CDATA[<h1 id="354-Russian-Doll-Envelopes俄罗斯套娃"><a href="#354-Russian-Doll-Envelopes俄罗斯套娃" class="headerlink" title="354. Russian Doll Envelopes俄罗斯套娃"></a>354. Russian Doll Envelopes俄罗斯套娃</h1><p>给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 (w, h) 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。</p><p>请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p><a id="more"></a><p>说明:<br>不允许旋转信封。</p><p>示例:</p><p>输入: envelopes = [[5,4],[6,4],[6,7],[2,3]]<br>输出: 3<br>解释: 最多信封的个数为 3, 组合为: [2,3] =&gt; [5,4] =&gt; [6,7]。</p><h2 id="动态规划解法"><a href="#动态规划解法" class="headerlink" title="动态规划解法"></a>动态规划解法</h2><p>这道题给了我们一堆大小不一的信封，让我们像套俄罗斯娃娃那样把这些信封都给套起来，这道题实际上是之前那道Longest Increasing Subsequence的具体应用，而且难度增加了，从一维变成了两维，但是万变不离其宗，解法还是一样的，首先来看DP的解法，这是一种brute force的解法，首先要给所有的信封按从小到大排序，首先根据宽度从小到大排，如果宽度相同，那么高度小的再前面，这是STL里面sort的默认排法，所以我们不用写其他的comparator，直接排就可以了，然后我们开始遍历，对于每一个信封，我们都遍历其前面所有的信封，如果当前信封的长和宽都比前面那个信封的大，那么我们更新dp数组，通过dp[i] = max(dp[i], dp[j] + 1)。然后我们每遍历完一个信封，都更新一下结果res，参见代码如下；</p><pre><code>class Solution {public:    int maxEnvelopes(vector&lt;pair&lt;int, int&gt;&gt;&amp; envelopes) {        int res=0,n=envelopes.size();        vector&lt;int&gt; dp(n,1);        sort(envelopes.begin(),envelopes.end());        for(int i=0;i&lt;n;i++){            for(int j=0;j&lt;i;j++){                if(envelopes[i].first&gt;envelopes[j].first &amp;&amp; envelopes[i].second&gt; envelopes[j].second){                    dp[i]=max(dp[i],dp[j]+1);                }            }            res=max(res,dp[i]);        }        return res;    }};</code></pre><h2 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h2><p>可以使用二分查找法来优化速度，我们首先要做的还是给信封排序，但是这次排序和上面有些不同，信封的宽度还是从小到大排，但是宽度相等时，我们让高度大的在前面。那么现在问题就简化了成了找高度数字中的LIS，完全就和之前那道Longest Increasing Subsequence一样了，所以我们还是使用之前那题解法来做，参见代码如下：</p><pre><code>class Solution {public:    int maxEnvelopes(vector&lt;pair&lt;int, int&gt;&gt;&amp; envelopes) {              vector&lt;int&gt; dp;        sort(envelopes.begin(),envelopes.end(),[](const pair&lt;int,int&gt; &amp;a,const pair&lt;int,int&gt; &amp;b){            if(a.first==b.first) return a.second&gt; b.second;            return a.first &lt;b.first;        });        for(int i=0;i&lt;envelopes.size();i++){            int left=0,right=dp.size(),t=envelopes[i].second;            while(left&lt;right){                int mid=left+(right-left)/2;                if(dp[mid]&lt; t) left=mid+1;                else right=mid;            }            if(right&gt;=dp.size()) dp.push_back(t);            else dp[right]=t;        }        return dp.size();    }};</code></pre><h2 id="使用STL函数lower-bound的二分查找法"><a href="#使用STL函数lower-bound的二分查找法" class="headerlink" title="使用STL函数lower_bound的二分查找法"></a>使用STL函数lower_bound的二分查找法</h2><pre><code>class Solution {public:    int maxEnvelopes(vector&lt;pair&lt;int, int&gt;&gt;&amp; envelopes) {        vector&lt;int&gt; dp;        sort(envelopes.begin(),envelopes.end(),[](const pair&lt;int,int&gt; &amp;a,cosnt pair&lt;int,int&gt; &amp;b){           if(a.first==b.first) return a.second&gt;b.second;            return a.first&lt;b.first;        });        for(int i=0;i&lt;envelopes.size();i++){            auto it=lower_bound(dp.begin(),dp.end(),enveloeps[i].second);            if(it==dp.end()) dp.push_back(envelopes[i].second);            else *it=envelopes[i].second;        }        return dp.size();    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;354-Russian-Doll-Envelopes俄罗斯套娃&quot;&gt;&lt;a href=&quot;#354-Russian-Doll-Envelopes俄罗斯套娃&quot; class=&quot;headerlink&quot; title=&quot;354. Russian Doll Envelopes俄罗斯套娃&quot;&gt;&lt;/a&gt;354. Russian Doll Envelopes俄罗斯套娃&lt;/h1&gt;&lt;p&gt;给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 (w, h) 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。&lt;/p&gt;
&lt;p&gt;请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>64.StreamMedian数据流中的中位数(Coding Interviews )</title>
    <link href="http://yoursite.com/2018/08/22/%E5%89%91%E6%8C%87Offer64.%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://yoursite.com/2018/08/22/剑指Offer64.数据流中的中位数/</id>
    <published>2018-08-22T01:58:44.000Z</published>
    <updated>2018-08-24T07:08:32.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="64-StreamMedian数据流中的中位数-Coding-Interviews"><a href="#64-StreamMedian数据流中的中位数-Coding-Interviews" class="headerlink" title="64.StreamMedian数据流中的中位数(Coding Interviews )"></a>64.StreamMedian数据流中的中位数(Coding Interviews )</h1><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><a id="more"></a><p>将数据在容器中排序，将整个数据容器分隔成两部分。位于容器左边部分的数据比右边的数据小。中位数可以由两个指针指向的数据得到。如果容器中数据的数目是奇数，那么两个指针指向同一个数据。指针P1指向左边部分最大的数，指针P2指向右边部分最小的数。</p><p>如果能保证数据容器左边的数据都小于右边的数据，即使左右两边内部的数据没有排序，也可以根据左边最大的数及右边最小的数得到中位数。</p><p>使用一个最大堆来实现左边的数据容器，使用最小堆实现右边的数据容器。往堆中插入一个数据的时间效率是O(logn).由于只需要O(1）时间就可以得到位于堆顶的数据，因此得到中位数的时间效率是O(1)。</p><p>为了保证数据平均分配到两个堆中，可以在数据的总数目是偶数时把新数据插入到最小堆中，否则插入到最大堆中。</p><p>还要保证最大堆中里的所有数据都要小于最小堆中的数据。当数据的总数目是偶数时，按照前面的分配规则会把新的数据插入到最小堆中。如果此时这个新的数据比最大堆中的一些数据要小，那么</p><p>首先可以把这个新的数据插入到最大堆中，</p><p>接着把最大堆中的最大的数字拿出来插入到最小堆中。</p><p>由于最终插入到最小堆的数字是原最大堆中最大的数字，这样就保证了最小堆中所有数字都大于最大堆中的数字。</p><h3 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h3><pre><code>#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;functional&gt;using namespace std;template&lt;typename T&gt; class DynamicArray{public:    void Insert(T num)    {        if (((min.size() + max.size()) &amp; 1) == 0) {// even length             if (max.size() &gt; 0 &amp;&amp; num &lt; max[0]) {//new num is lower than  some numbers in the maxheap                max.push_back(num);                push_heap(max.begin(), max.end(), less&lt;T&gt;());// make the max heap                num = max[0];                pop_heap(max.begin(), max.end(), less&lt;T&gt;());                max.pop_heap();            }            min.push_heap(num);            push_heap(min.begin(), min.end(), greater&lt;T&gt;());//make the min heap        }        else {//odd length            if (min.size() &gt; 0 &amp;&amp; min[0] &lt; num) {                min.push_back(num);                push_heap(min, begin(), min.end(), greater&lt;T&gt;());                num = min[0];                pop_heap(min.begin(), min.end(), greater&lt;T&gt;());                min.pop_heap();            }            max.push_back(num);            push_heap(max.begin(), max.end(), less&lt;T&gt;());        }    }    T GetMedian()    {         int size = min.size() + max.size();        if (size == 0) throw exception(&quot;No numbers are available&quot;);        T median = 0;        if ((size &amp; 1) == 1) meidan = min[0];// only has one number        else median = (min[0] + max[0]) / 2;        return median;    }private:    vector&lt;T&gt; min;//min heap    vector&lt;T&gt; max;//max heap};// ==================== Test Code ====================void Test(char* testName, DynamicArray&lt;double&gt;&amp; numbers, double expected){    if(testName != NULL)        printf(&quot;%s begins: &quot;, testName);    if(abs(numbers.GetMedian() - expected) &lt; 0.0000001)        printf(&quot;Passed.\n&quot;);    else        printf(&quot;FAILED.\n&quot;);}int main(int argc, char* argv[]){    DynamicArray&lt;double&gt; numbers;    printf(&quot;Test1 begins: &quot;);    try    {        numbers.GetMedian();        printf(&quot;FAILED.\n&quot;);    }    catch(exception e)    {        printf(&quot;Passed.\n&quot;);    }    numbers.Insert(5);    Test(&quot;Test2&quot;, numbers, 5);    numbers.Insert(2);    Test(&quot;Test3&quot;, numbers, 3.5);    numbers.Insert(3);    Test(&quot;Test4&quot;, numbers, 3);    numbers.Insert(4);    Test(&quot;Test6&quot;, numbers, 3.5);    numbers.Insert(1);    Test(&quot;Test5&quot;, numbers, 3);    numbers.Insert(6);    Test(&quot;Test7&quot;, numbers, 3.5);    numbers.Insert(7);    Test(&quot;Test8&quot;, numbers, 4);    numbers.Insert(0);    Test(&quot;Test9&quot;, numbers, 3.5);    numbers.Insert(8);    Test(&quot;Test10&quot;, numbers, 4);    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;64-StreamMedian数据流中的中位数-Coding-Interviews&quot;&gt;&lt;a href=&quot;#64-StreamMedian数据流中的中位数-Coding-Interviews&quot; class=&quot;headerlink&quot; title=&quot;64.StreamMedian数据流中的中位数(Coding Interviews )&quot;&gt;&lt;/a&gt;64.StreamMedian数据流中的中位数(Coding Interviews )&lt;/h1&gt;&lt;p&gt;如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Coding Interviews" scheme="http://yoursite.com/tags/Coding-Interviews/"/>
    
      <category term="Max Heap" scheme="http://yoursite.com/tags/Max-Heap/"/>
    
      <category term="Template" scheme="http://yoursite.com/tags/Template/"/>
    
  </entry>
  
  <entry>
    <title>股票交易问题通解小结</title>
    <link href="http://yoursite.com/2018/08/21/%E8%82%A1%E7%A5%A8%E4%BA%A4%E6%98%93%E9%97%AE%E9%A2%98%E9%80%9A%E8%A7%A3%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2018/08/21/股票交易问题通解小结/</id>
    <published>2018-08-21T01:58:44.000Z</published>
    <updated>2018-08-22T10:14:24.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="股票交易问题通解小结"><a href="#股票交易问题通解小结" class="headerlink" title="股票交易问题通解小结"></a>股票交易问题通解小结</h1><p>本文的主要部分来自于leetcode讨论区,后面加上了一点个人的理解和扩展延伸，Leetcode中的股票交易问题共有下列几道：</p><a id="more"></a><pre><code>121.Best Time to Buy and Sell Stock122.Best Time to Buy and Sell Stock II123.Best Time to Buy and Sell Stock III188.Best Time to Buy and Sell Stock IV309.Best Time to Buy and Sell Stock with Cooldown714.Best Time to Buy and Sell Stock with Transaction Fee</code></pre><h2 id="I-–常见情况"><a href="#I-–常见情况" class="headerlink" title="I –常见情况"></a>I –常见情况</h2><p>本文的想法来自于下列的问题：给定一个代表每天股票价格的数组，是什么决定了我们能得到的最大利润？</p><p>大多数人会很快产生类似“那取决于我们处在第几天和我们被允许最多完成多少次交易”。</p><p>当然，这些是重要的因素因为它们在问题描述中就被显示出来。然而，在判断最大利润中有一个隐含因素不是那么明显但却至关重要，它将在下文中被阐述出来。</p><p>首先让我们确定符号来简化我们的分析，令prices作为长度为n的股票价格数组，i标记为第i天（i会从0到n-1)，k标记为被允许完成的最大交易次数,T[i][k]是在第i天的结尾经过最多k次交易所能获得的最大利润。很明显我们有基准情况：T[-1][k]=T[i][0]=0, 那就是没有股票或者没有交易导致没有利润（标记第1天为i=0因此i=0意味着没有股票）。</p><p>现在如果我们能够把T[i][k]和它的子问题T[i-1][k],T[i][k-1],T[i-1][k-1],…，我们会有一个可行的递推关系式<br>使得问题能够递归解决，所以我们怎样实现它呢？<br>最常见的直接方式是看第i天的行动，我们有多少种选择方式？答案是三种：买，卖，休息。我们应该采取哪种呢？</p><p>答案是：我们并不真的知道，但是可以去找哪一种最简单。假设没有其它的约束，我们可以尝试每种选择然后选择使得我们利润最大的一种。</p><p>可是我们确实有一个额外的约束，就是不能在同一时间进行重复交易，意味着如果我们决定在第i天购买，那么我们手中就应该不持有股票；如果我们决定在第i天出售，我们手中应该恰好有一只股票。我们手中<br>的股票数量是上文中提到的会影响我们第i天行为的因素同时也会影响最大利润。</p><p>因此我们对T[i][k]的定义应该被分割成两部分:T[i][k][0]和T[i][k][1],前者标记在最多k次交易和行动后我们手中没有股票的情况下第i天结尾时的最大利润，后者标记在最多k次交易和行动后我们手中只有一只股票的情况下第i天结尾时的最大利润，现在基准情况和递推关系可以被写作：</p><h3 id="1-基准情况："><a href="#1-基准情况：" class="headerlink" title="1.基准情况："></a>1.基准情况：</h3><pre><code>T[-1][k][0]=0, T[-1][k][1]=-InfinityT[i][0][0]=0, T[i][0][1]=-Infinity</code></pre><h3 id="2-递推关系："><a href="#2-递推关系：" class="headerlink" title="2.递推关系："></a>2.递推关系：</h3><pre><code>T[i][k][0]=max(T[i-1][k][0],T[i-1][k][1]+prices[i])T[i][k][1]=max(T[i-1][k][1],T[i-1][k-1][0]-prices[i])</code></pre><p>对于基准情况，T[-1][k][0] = T[i][0][0] = 0有同样的含义正如之前当T[-1][k][1] = T[i][0][1] = -Infinity强调了事实对于我们来说如果没有可获得的股票或不被允许交易那么就不可能手中有一只股票。</p><p>对于递推式中的T[i][k][0]，在第i天能采取的行动只有休息和卖，因为我们在一天结束时手中没有股票。T[i-1][k][0]是当采取行动休息时的最大利润，<br>而T[i-1][k][1] + prices[i]则是当行动卖被采取时的最大利润。</p><p>如果最大被允许的交易次数保持不变，由于一次交易包含两种成对的行为-买和卖。只有行为买会改变被允许的最大交易次数。（此处还有一种替代的解释）<br>对于递推式中的T[i][k][1]，在第i天能采取的行动只有休息和买，因为我们在一天结束时手中只有一只股票。T[i-1][k][1]是当采取行动休息时的最大利润，而T[i-1][k-1][0] - prices[i]是当采取购买行为时的最大利润。要注意被允许的最大交易次数会减一，因为在第i天的购买行为会使用掉一次交易次数。</p><p>为了找到最后一天结束时的最大利润，我们能够简化循环通过数组prices并且通过上面的递推关系式更新T[i][k][0]和T[i][k][1]。最终的答案是T[i][k][0]（我们总是有更大的利润如果我们以手中0只股票结束）</p><h2 id="II-–-对特殊情况的应用"><a href="#II-–-对特殊情况的应用" class="headerlink" title="II – 对特殊情况的应用"></a>II – 对特殊情况的应用</h2><p>前面提及的六种股票问题能够被k的值分类，k是被允许的最大交易次数（最后两个也有额外的要求例如冷却期或者交易费）。我会一个接一个的把通用解应用到这些问题上。</p><h3 id="情况I：k-1"><a href="#情况I：k-1" class="headerlink" title="情况I：k=1"></a>情况I：k=1</h3><p>对于这个情况，我们在每天都真的有两个未知变量：T[i][1][0]和T[i][1][1]，递推关系式表示：</p><pre><code>T[i][1][0] = max(T[i-1][1][0], T[i-1][1][1] + prices[i])T[i][1][1] = max(T[i-1][1][1], T[i-1][0][0] - prices[i]) = max(T[i-1][1][1], -prices[i])</code></pre><p>在第二个方程中我们充分利用了基准情况T[i][0][0]=0。<br>很容易直接写出O(n)时间复杂度和O(n)空间复杂度的解，基于上面的两个方程。可是，如果你注意到在第i天的最大利润事实上只依赖于那些在第i-1天的利润，<br>那么空间复杂度降为O(1)。这是空间最优的解法：</p><pre><code>public int maxProfit(int[] prices){    int T_i10=0,T_i11=Integer.MIN_VALUE;    for(int price:prices){        T_i10=Math.max(T_i10,T_i11 + price);        T_i11=Math.max(T_i11,-price);    }    return T_i10;}</code></pre><h3 id="情况-II-k-Infinity"><a href="#情况-II-k-Infinity" class="headerlink" title="情况 II: k=+Infinity"></a>情况 II: k=+Infinity</h3><p>如果k是正无穷的，那么在k和k-1之间没有任何真正区别，暗示了T[i-1][k-1][0] = T[i-1][k][0]和T[i-1][k-1][1] = T[i-1][k][1]，因此我们仍然在每天有两个未知变量：T[i][k][0]和T[i][k][1]，k=+Infinity,递推关系式如下：</p><pre><code>T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])T[i][k][1] = max(T[i-1][k][1], T[i-1][k-1][0] - prices[i]) = max(T[i-1][k][1], T[i-1][k][0] - prices[i])</code></pre><p>在第二个方程中我们会充分利用T[i-1][k-1][0] = T[i-1][k][0]，O(n)时间复杂度和O(1)空间复杂度的解法如下：</p><pre><code>public int maxProfit(int[] prices) {    int T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;    for (int price : prices) {        int T_ik0_old = T_ik0;        T_ik0 = Math.max(T_ik0, T_ik1 + price);        T_ik1 = Math.max(T_ik1, T_ik0_old - price);    }    return T_ik0;}</code></pre><p>(注意: 旧值缓存的T_ik0,是变量T_ik0_old,是不可能的，特别感谢0x0101和elvina澄清这一点）</p><p>这个解法提出了一种贪心的策略来获取最大利润：只要可能，在每个最小值出买股票然后在下一个局部最大值时迅速卖出。这等同于在prices中找到递增子序列，在每个子序列中的开头买入，在每个子序列的结尾卖出。这很容易展示这等同于只要有利可图时就积累利润，如<a href="https://discuss.leetcode.com/topic/726/is-this-question-a-joke中提到的。" target="_blank" rel="noopener">https://discuss.leetcode.com/topic/726/is-this-question-a-joke中提到的。</a></p><h3 id="情况-III-k-2"><a href="#情况-III-k-2" class="headerlink" title="情况 III: k=2"></a>情况 III: k=2</h3><p>与k=1的情况类似，除了现在我们每天有四个而不是两个变量：T[i][1][0], T[i][1][1], T[i][2][0], T[i][2][1]，递推关系式如下：</p><pre><code>T[i][2][0] = max(T[i-1][2][0], T[i-1][2][1] + prices[i])T[i][2][1] = max(T[i-1][2][1], T[i-1][1][0] - prices[i])T[i][1][0] = max(T[i-1][1][0], T[i-1][1][1] + prices[i])T[i][1][1] = max(T[i-1][1][1], -prices[i])</code></pre><p>在最后一个方程中我们充分利用了基准情况T[i][0][0]=0，下列解有O(n)的空间复杂度和O(1)</p><pre><code>public int maxProfit(int[] prices) {    int T_i10 = 0, T_i11 = Integer.MIN_VALUE, T_i20 = 0, T_i21 = Integer.MIN_VALUE;    for (int price : prices) {        T_i20 = Math.max(T_i20, T_i21 + price);        T_i21 = Math.max(T_i21, T_i10 - price);        T_i10 = Math.max(T_i10, T_i11 + price);        T_i11 = Math.max(T_i11, -price);    }    return T_i20;}</code></pre><h3 id="情况-IV：-k是任意的"><a href="#情况-IV：-k是任意的" class="headerlink" title="情况 IV： k是任意的"></a>情况 IV： k是任意的</h3><p>这是最通用的情况所以在每天我们都需要更新所有的有不同k值的最大利润对应在每天结尾时我们手中有0或1只股票。</p><p>可是，有一个微小的优化我们能够做的是如果k超出了一些临界值，超出了最大的利润不再依赖于允许交易的次数而是被可获得的股票数量限制（prices数组的长度），让我们计算出临界值会是什么。</p><p>一个获利交易花费至少两天（一天买另一天卖，买入价格不少于卖出价格)，如果prices数组的长度是n，最大的获利交易数量是n/2，在这之后没有可能的获益交易，<br>这暗示着最大的利润会保持不变。</p><p>因此，临界k值是n/2，如果给定的k值不小于这个值的时候，换句话说，k&gt;=n/2，我们能够把k拓展到正无穷，问题等价于情况II。</p><p>下列是时间复杂度为O(kn)，空间复杂度O(k)的解，没有优化，代码能够满足大K值时的时间约束。</p><pre><code>public int maxProfit(int k, int[] prices) {    if (k &gt;= prices.length &gt;&gt;&gt; 1) {    int T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;    for (int price : prices) {    int T_ik0_old = T_ik0;    T_ik0 = Math.max(T_ik0, T_ik1 + price);    T_ik1 = Math.max(T_ik1, T_ik0_old - price);    }    return T_ik0;}    int[] T_ik0 = new int[k + 1];    int[] T_ik1 = new int[k + 1];    Arrays.fill(T_ik1, Integer.MIN_VALUE);    for (int price : prices) {        for (int j = k; j &gt; 0; j--) {            T_ik0[j] = Math.max(T_ik0[j], T_ik1[j] + price);            T_ik1[j] = Math.max(T_ik1[j], T_ik0[j - 1] - price);        }    }    return T_ik0[k];}</code></pre><p>解法类似于<a href="https://discuss.leetcode.com/topic/8984/a-concise-dp-solution-in-java帖子中的解法，这里我使用了T数组的反向循环来避免使用临时变量。它也被证明不使用临时变量做前向循环也是可能的。" target="_blank" rel="noopener">https://discuss.leetcode.com/topic/8984/a-concise-dp-solution-in-java帖子中的解法，这里我使用了T数组的反向循环来避免使用临时变量。它也被证明不使用临时变量做前向循环也是可能的。</a></p><h3 id="情况-V：k-Infinity-有冷却期"><a href="#情况-V：k-Infinity-有冷却期" class="headerlink" title="情况 V：k=+Infinity 有冷却期"></a>情况 V：k=+Infinity 有冷却期</h3><p>这个例子相似于情况II更多是由于他们有同样的k值，除了递推式需要简单的修改来满足冷却期的要求。情况II中给出的原始递推式是：</p><pre><code>T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])T[i][k][1] = max(T[i-1][k][1], T[i-1][k][0] - prices[i])</code></pre><p>  但是由于冷却期，我们不能在第i天买入股票如果在第i-1天股票被卖出，因此，在上面的第二个方程中，我们事实上应该用T[i-2][k][0]而不是T[i-1][k][0]<br>如果我们打算在第i天买。其他所有都保持不变并且新的递推式是：</p><pre><code>T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])T[i][k][1] = max(T[i-1][k][1], T[i-2][k][0] - prices[i])</code></pre><p>下面是O（n）时间复杂度和O（1）空间复杂度的解法：</p><pre><code>public int maxProfit(int[] prices) {    int T_ik0_pre = 0, T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;    for (int price : prices) {        int T_ik0_old = T_ik0;        T_ik0 = Math.max(T_ik0, T_ik1 + price);        T_ik1 = Math.max(T_ik1, T_ik0_pre - price);        T_ik0_pre = T_ik0_old;    }    return T_ik0;}</code></pre><p>dietpepsi分享了一种非常好的解法，被证明和上述方法相同<a href="https://discuss.leetcode.com/topic/30421/share-my-thinking-process" target="_blank" rel="noopener">https://discuss.leetcode.com/topic/30421/share-my-thinking-process</a></p><h3 id="情况-VI-k-Infinity-但有交易费用"><a href="#情况-VI-k-Infinity-但有交易费用" class="headerlink" title="情况 VI:k=+Infinity 但有交易费用"></a>情况 VI:k=+Infinity 但有交易费用</h3><p>再一次的这个例子等同于情况ＩＩ因为它们有同样的ｋ值，除了现在的递推关系式需要轻微修改来满足交易费的要求。情况ＩＩ给出的原始递推关系式如下：</p><pre><code>T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])T[i][k][1] = max(T[i-1][k][1], T[i-1][k][0] - prices[i])</code></pre><p>因为现在我们需要为每次的交易行为付费，在第ｉ天的购买和出售股票获利中应该减去这个值，因此新的递推关系式应该为下面的任意一种：</p><pre><code>T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])T[i][k][1] = max(T[i-1][k][1], T[i-1][k][0] - prices[i] - fee)</code></pre><p>或</p><pre><code>T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i] - fee)T[i][k][1] = max(T[i-1][k][1], T[i-1][k][0] - prices[i])</code></pre><p>注意当我们减去费用时我们有两个选项，这是因为每次交易都会表征为两个成对出现的行为－－买和卖<br>费用能够被支付当我们买股票（第一组方程）或当我们卖股票（第二组方程），下列是Ｏ(n)时间复杂度和Ｏ(1)空间复杂度的解法对应于这两项选择，第二个解法我们需要注意可能的溢出。</p><h4 id="解法I－－当买入股票时支付交易费"><a href="#解法I－－当买入股票时支付交易费" class="headerlink" title="解法I－－当买入股票时支付交易费"></a>解法I－－当买入股票时支付交易费</h4><pre><code>public int maxProfit(int[] prices, int fee) {    int T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;    for (int price : prices) {        int T_ik0_old = T_ik0;        T_ik0 = Math.max(T_ik0, T_ik1 + price);        T_ik1 = Math.max(T_ik1, T_ik0_old - price - fee);    }    return T_ik0;}</code></pre><h4 id="解法II－－当售出股票时支付交易费"><a href="#解法II－－当售出股票时支付交易费" class="headerlink" title="解法II－－当售出股票时支付交易费"></a>解法II－－当售出股票时支付交易费</h4><pre><code>public int maxProfit(int[] prices, int fee) {    long T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;    for (int price : prices) {        long T_ik0_old = T_ik0;        T_ik0 = Math.max(T_ik0, T_ik1 + price - fee);        T_ik1 = Math.max(T_ik1, T_ik0_old - price);    }    return (int)T_ik0;}</code></pre><h1 id="III延伸拓展"><a href="#III延伸拓展" class="headerlink" title="III延伸拓展"></a>III延伸拓展</h1><p>在121. Best Time to Buy and Sell Stock中也可以将其转换成求最大子列和的问题，对于原数组，如果我们将arr[i]-arr[i-1]，也就是股票某日与前一日价格差，依次排列成一个数组，那么所求问题的答案就变成了求这个新数组的最大子列和。</p><p>在求解最大子列和问题时，使用Kadane算法。算法复杂度O（N）,kadane算法利用了数学归纳法的思想。简而言之，给定一个现成的数组，比如说−2, 1, −3, 4, −1, 2, 1, −5, 4，求其中的最大子列和，并不是容易的事情。但如果我们能从第一个数开始，随着数组的扩充，始终对其最大子列和保持跟踪，就可以求出任意一个数组的最大子列和。</p><p>详细的分析一下，往一个长度为i的数组后面插入第i+1个数，这时，数组的最大子列只有两种情况，要么包括第i+1个数，要么不包括第i+1个数。</p><p>即：<br>maxsubarraum = max(以第i+1个数结尾的子列和， 不以第i+1个数结尾的子列和)。</p><p>先计算前者，以第i+1个数结尾的子列和怎么算呢？很简单，要么它是以第i个数结尾的子列作为前缀，要么它不以之作为前缀。假设第i+1个数为x，那么：<br>以第i+1个数结尾的子列和 = max（x，以第i个数结尾的子列和+x)。</p><p>对于kadane算法的扩展还可以见于<code>hihocoder#1800 : 玩具设计师</code>一题中求二维数组的最大矩形和</p><h1 id="IV－－总结"><a href="#IV－－总结" class="headerlink" title="IV－－总结"></a>IV－－总结</h1><p> 总之，最通用的股票问题解法能够被表征为三个因素，ｉ天的序号，最大允许的交易次数ｋ和每天结束后我们手中持有的股票数。</p><p>上文已经展示了最大利润和他们终止情况的递推式，Ｏ(nk)时间复杂度和Ｏ(k)空间复杂度。结果被依次应用于六个例子，后两个由于额外的要求做了轻微的修改。<a href="https://discuss.leetcode.com/user/peterleetcode也介绍了一个很好的解法对于任意k值通用。如果有兴趣可以继续看一下。" target="_blank" rel="noopener">https://discuss.leetcode.com/user/peterleetcode也介绍了一个很好的解法对于任意k值通用。如果有兴趣可以继续看一下。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;股票交易问题通解小结&quot;&gt;&lt;a href=&quot;#股票交易问题通解小结&quot; class=&quot;headerlink&quot; title=&quot;股票交易问题通解小结&quot;&gt;&lt;/a&gt;股票交易问题通解小结&lt;/h1&gt;&lt;p&gt;本文的主要部分来自于leetcode讨论区,后面加上了一点个人的理解和扩展延伸，Leetcode中的股票交易问题共有下列几道：&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
  </entry>
  
</feed>
