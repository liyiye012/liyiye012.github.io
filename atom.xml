<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-17T06:20:30.433Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Shell学习笔记I</title>
    <link href="http://yoursite.com/2019/09/16/Shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0I/"/>
    <id>http://yoursite.com/2019/09/16/Shell学习笔记I/</id>
    <published>2019-09-16T10:51:12.000Z</published>
    <updated>2019-09-17T06:20:30.433Z</updated>
    
    <content type="html"><![CDATA[<p>Shell脚本编程，懒虫的最爱。</p><a id="more"></a><p>世界的进步是由一群聪明的懒人推动的，可惜自己不但不聪明，还很懒。每次写完博客总打着熟悉git操作的旗号手动部署，终于洗心革面决定写个脚本来自动部署。</p><pre><code>#!/bin/bashcd /Users/liyiye/yiye-project/liyiye012.github.iogit add .git commit -m &quot;github.io 自动部署&quot;git pushhexo cleanhexo ghexo d</code></pre><p>这里写下Shell脚本学习的过程。</p><h1 id="What-is-Shell-and-Shell-Script"><a href="#What-is-Shell-and-Shell-Script" class="headerlink" title="What is Shell and Shell Script"></a>What is Shell and Shell Script</h1><p>shell是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。Ken Thompson的sh是第一种Unix Shell，Windows Explorer是一个典型的图形界面Shell。</p><p>Shell脚本(Shell script)是一种电脑程序与文本文件，内容由一连串的shell命令组成，经由Unix Shell直译其内容后运作。</p><p>被当成是一种脚本语言来设计，其运作方式与直译语言相当，由Unix shell扮演命令行解释器的角色，在读取shell script之后，依序运行其中的shell命令，之后输出结果。利用Shell script可以进行系统管理，文件操作等。</p><p>业界所说的shell通常都是指shell脚本，但读者朋友要知道，shell和shell script是两个不同的概念。由于习惯的原因，简洁起见，本文出现的“shell编程”都是指shell脚本编程，不是指开发shell自身（如Windows Explorer扩展开发）</p><p>打开文本编辑器，新建一个文本文件，并命名为 test.sh。</p><p>扩展名sh代表 shell，扩展名并不影响脚本执行，见名知意就好，如果用 php 写 shell 脚本，扩展名也可以用php。</p><h2 id="第一个shell脚本-Hello-World"><a href="#第一个shell脚本-Hello-World" class="headerlink" title="第一个shell脚本 Hello World"></a>第一个shell脚本 Hello World</h2><p>在 test.sh 中输入代码：</p><pre><code>#!/bin/bashecho &quot;Hello World !&quot;  #这是一条语句</code></pre><p>第 1 行的#!是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell；后面的/bin/bash就是指明了解释器的具体位置。</p><p>第 2 行的 echo 命令用于向标准输出文件（Standard Output，stdout，一般就是指显示器）输出文本。在.sh文件中使用命令与在终端直接输入命令的效果是一样的。</p><p>第 2 行的#及其后面的内容是注释。Shell 脚本中所有以#开头的都是注释（当然以#!开头的除外）</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>运行Shell脚本有两种方法：</p><h3 id="作为可执行程序"><a href="#作为可执行程序" class="headerlink" title="作为可执行程序"></a>作为可执行程序</h3><pre><code>chmod +x test.sh./test.sh</code></pre><p>注意，一定要写成./test.sh，而不是test.sh，运行其它二进制的程序也一样，直接写test.sh，linux系统会去PATH里寻找有没有叫test.sh的，而只有/bin, /sbin, /usr/bin，/usr/sbin等在PATH里，你的当前目录通常不在PATH里，所以写成test.sh是会找不到命令的，要用./test.sh告诉系统说，就在当前目录找。</p><p>通过这种方式运行bash脚本，第一行一定要写对，好让系统查找到正确的解释器。</p><p>这里的”系统”，其实就是shell这个应用程序（想象一下Windows Explorer），但我故意写成系统，是方便理解，既然这个系统就是指shell，那么一个使用/bin/sh作为解释器的脚本是不是可以省去第一行呢？是的。</p><h3 id="作为解释器参数"><a href="#作为解释器参数" class="headerlink" title="作为解释器参数"></a>作为解释器参数</h3><p>这种运行方式是，直接运行解释器，其参数就是shell脚本的文件名，如：</p><pre><code>/bin/sh test.sh/bin/php test.php</code></pre><p>这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。</p><h2 id="stdin"><a href="#stdin" class="headerlink" title="stdin"></a>stdin</h2><pre><code>#!/bin/bashecho &quot;What is your name?&quot;read PERSONecho &quot;Hello, $PERSON&quot;</code></pre><p>第 3 行中表示从终端读取用户输入的数据，并赋值给 PERSON 变量。read 命令用来从标准输入文件（Standard Input，stdin，一般就是指键盘）读取用户输入的数据。</p><p>第 4 行表示输出变量 PERSON 的内容。注意在变量名前边要加上$，否则变量名会作为字符串的一部分处理。</p><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><pre><code>#!/bin/shcd ~mkdir shell_tutcd shell_tutfor ((i=0; i&lt;10; i++)); do    touch test_$i.txtdone</code></pre><p>示例解释</p><pre><code>第1行：指定脚本解释器，这里是用/bin/sh做解释器的第2行：切换到当前用户的home目录第3行：创建一个目录shell_tut第4行：切换到shell_tut目录第5行：循环条件，一共循环10次第6行：创建一个test_0…9.txt文件第7行：循环体结束</code></pre><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><p>定义变量时，变量名不加美元符号（$），如：</p><pre><code>your_name=&quot;qinjx&quot;</code></pre><p>注意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。</p><p>除了显式地直接赋值，还可以用语句给变量赋值，如：</p><pre><code>for file in `ls /etc`</code></pre><h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><p>使用一个定义过的变量，只要在变量名前面加美元符号即可，如：</p><pre><code>your_name=&quot;qinjx&quot;echo $your_nameecho ${your_name}</code></pre><p>变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：</p><pre><code>for skill in Ada Coffe Action Java; do    echo &quot;I am good at ${skill}Script&quot;done</code></pre><p>如果不给skill变量加花括号，写成echo “I am good at $skillScript”，解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。</p><p>推荐给所有变量加上花括号，这是个好的编程习惯。IntelliJ IDEA编写shell script时，IDE就会提示加花括号。</p><h2 id="重定义变量"><a href="#重定义变量" class="headerlink" title="重定义变量"></a>重定义变量</h2><p>已定义的变量，可以被重新定义，如：</p><pre><code>your_name=&quot;qinjx&quot;echo $your_nameyour_name=&quot;alibaba&quot;echo $your_name</code></pre><p>这样写是合法的，但注意，第二次赋值的时候不能写$your_name=”alibaba”，使用变量的时候才加美元符。</p><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>以“#”开头的行就是注释，会被解释器忽略。</p><p>##多行注释<br>sh里没有多行注释，只能每一行加一个#号。</p><p>如果在开发过程中，遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？每一行加个#符号太费力了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。</p><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>字符串是shell编程中最常用最有用的数据类型，字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟PHP类似。</p><h2 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h2><pre><code>str=&apos;this is a string&apos;</code></pre><h3 id="单引号字符串的限制："><a href="#单引号字符串的限制：" class="headerlink" title="单引号字符串的限制："></a>单引号字符串的限制：</h3><p>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的</p><p>单引号字串中不能出现单引号（对单引号使用转义符后也不行）</p><h2 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h2><pre><code>your_name=&apos;qinjx&apos;str=&quot;Hello, I know your are \&quot;$your_name\&quot;! \n&quot;</code></pre><p>双引号里可以有变量</p><p>双引号里可以出现转义字符</p><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h3><pre><code>your_name=&quot;qinjx&quot;greeting=&quot;hello, &quot;$your_name&quot; !&quot;greeting_1=&quot;hello, ${your_name} !&quot;echo $greeting $greeting_1</code></pre><h3 id="获取字符串长度："><a href="#获取字符串长度：" class="headerlink" title="获取字符串长度："></a>获取字符串长度：</h3><pre><code>string=&quot;abcd&quot;echo ${#string} #输出：4</code></pre><h3 id="提取子字符串"><a href="#提取子字符串" class="headerlink" title="提取子字符串"></a>提取子字符串</h3><pre><code>string=&quot;alibaba is a great company&quot;echo ${string:1:4} #输出：liba</code></pre><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><h1 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h1><h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><p>和Java、PHP等语言不一样，sh的流程控制不可为空，如：</p><pre><code>&lt;?phpif (isset($_GET[&quot;q&quot;])) {    search(q);}else {    //do nothing}</code></pre><p>在sh/bash里可不能这么写，如果else分支没有语句执行，就不要写这个else。</p><p>还要注意，sh里的if [ $foo -eq 0 ]，这个方括号跟Java/PHP里if后面的圆括号大不相同，它是一个可执行程序（和ls, grep一样），想不到吧？在CentOS上，它在/usr/bin目录下：</p><pre><code>ll /usr/bin/[-rwxr-xr-x. 1 root root 33408 6月  22 2012 /usr/bin/[</code></pre><p>正因为方括号在这里是一个可执行程序，方括号后面必须加空格，不能写成if [$foo -eq 0]</p><h2 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><pre><code>if conditionthen    command1    command2    ...    commandNfi</code></pre><p>写成一行（适用于终端命令提示符）：</p><pre><code>if `ps -ef | grep ssh`;  then echo hello; fi</code></pre><p>末尾的fi就是if倒过来拼写，后面还会遇到类似的</p><h3 id="if-else-1"><a href="#if-else-1" class="headerlink" title="if else"></a>if else</h3><pre><code>if conditionthen    command1    command2    ...    commandNelse    commandfi</code></pre><h3 id="if-else-if-else"><a href="#if-else-if-else" class="headerlink" title="if else-if else"></a>if else-if else</h3><pre><code>if condition1then    command1elif condition2    command2else    commandNfi</code></pre><h2 id="for-while"><a href="#for-while" class="headerlink" title="for while"></a>for while</h2><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>在开篇的示例里演示过了：</p><pre><code>for var in item1 item2 ... itemNdo    command1    command2    ...    commandNdone</code></pre><p>写成一行：</p><pre><code>for var in item1 item2 ... itemN; do command1; command2… done;</code></pre><h3 id="C风格的for"><a href="#C风格的for" class="headerlink" title="C风格的for"></a>C风格的for</h3><pre><code>for (( EXP1; EXP2; EXP3 ))do    command1    command2    command3done</code></pre><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><pre><code>while conditiondo    commanddone</code></pre><h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h3><pre><code>while :do    commanddone</code></pre><p>或者</p><pre><code>while truedo    commanddone</code></pre><p>或者</p><pre><code>for (( ; ; ))</code></pre><h3 id="until"><a href="#until" class="headerlink" title="until"></a>until</h3><pre><code>until conditiondo    commanddone</code></pre><h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><pre><code>case &quot;${opt}&quot; in    &quot;Install-Puppet-Server&quot; )        install_master $1        exit    ;;    &quot;Install-Puppet-Client&quot; )        install_client $1        exit    ;;    &quot;Config-Puppet-Server&quot; )        config_puppet_master        exit    ;;    &quot;Config-Puppet-Client&quot; )        config_puppet_client        exit    ;;    &quot;Exit&quot; )        exit    ;;    * ) echo &quot;Bad option, please choose again&quot;esac</code></pre><p>case的语法和C family语言差别很大，它需要一个esac（就是case反过来）作为结束标记，每个case分支用右圆括号，用两个分号表示break</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><p>可以使用source和.关键字，如：</p><pre><code>source ./function.sh. ./function.sh</code></pre><p>在bash里，source和.是等效的，他们都是读入function.sh的内容并执行其内容（类似PHP里的include），为了更好的可移植性，推荐使用第二种写法。</p><p>包含一个文件和执行一个文件一样，也要写这个文件的路径，不能光写文件名，比如上述例子中:</p><p>  . ./function.sh<br>不可以写作：</p><p>  . function.sh<br>如果function.sh是用户传入的参数，如何获得它的绝对路径呢？方法是：</p><pre><code>real_path=`readlink -f $1`#$1是用户输入的参数，如function.sh. $real_path</code></pre><h1 id="用户输入"><a href="#用户输入" class="headerlink" title="用户输入"></a>用户输入</h1><h2 id="执行脚本时传入"><a href="#执行脚本时传入" class="headerlink" title="执行脚本时传入"></a>执行脚本时传入</h2><h2 id="脚本运行中输入"><a href="#脚本运行中输入" class="headerlink" title="脚本运行中输入"></a>脚本运行中输入</h2><h2 id="select菜单"><a href="#select菜单" class="headerlink" title="select菜单"></a>select菜单</h2><h2 id="stdin和stdout"><a href="#stdin和stdout" class="headerlink" title="stdin和stdout"></a>stdin和stdout</h2><h1 id="常用的命令"><a href="#常用的命令" class="headerlink" title="常用的命令"></a>常用的命令</h1><p>sh脚本结合系统命令便有了强大的威力，在字符处理领域，有grep、awk、sed三剑客，grep负责找出特定的行，awk能将行拆分成多个字段，sed则可以实现更新插入删除等写操作。</p><h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p>查看进程列表</p><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>排除grep自身<br>查找与target相邻的结果</p><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><h2 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h2><h1 id="脚本解释器"><a href="#脚本解释器" class="headerlink" title="脚本解释器"></a>脚本解释器</h1><h2 id="sh"><a href="#sh" class="headerlink" title="sh"></a>sh</h2><p>即Bourne shell，POSIX（Portable Operating System Interface）标准的shell解释器，它的二进制文件路径通常是/bin/sh，由Bell Labs开发。</p><p>下面讲的是sh，如果使用其它语言用作shell编程，请参考相应语言的文档。</p><h2 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h2><p>Bash是Bourne shell的替代品，属GNU Project，二进制文件路径通常是/bin/bash。业界通常混用bash、sh、和shell，比如你会经常在招聘运维工程师的文案中见到：熟悉Linux Bash编程，精通Shell编程。</p><p>在CentOS里，/bin/sh是一个指向/bin/bash的符号链接:</p><pre><code>[root@centosraw ~]# ls -l /bin/*sh-rwxr-xr-x. 1 root root 903272 Feb 22 05:09 /bin/bash-rwxr-xr-x. 1 root root 106216 Oct 17  2012 /bin/dashlrwxrwxrwx. 1 root root      4 Mar 22 10:22 /bin/sh -&gt; bash</code></pre><p>但在Mac OS上不是，/bin/sh和/bin/bash是两个不同的文件，尽管它们的大小只相差100字节左右:</p><pre><code>iMac:~ wuxiao$ ls -l /bin/*sh-r-xr-xr-x  1 root  wheel  1371648  6 Nov 16:52 /bin/bash-rwxr-xr-x  2 root  wheel   772992  6 Nov 16:52 /bin/csh-r-xr-xr-x  1 root  wheel  2180736  6 Nov 16:52 /bin/ksh-r-xr-xr-x  1 root  wheel  1371712  6 Nov 16:52 /bin/sh-rwxr-xr-x  2 root  wheel   772992  6 Nov 16:52 /bin/tcsh-rwxr-xr-x  1 root  wheel  1103984  6 Nov 16:52 /bin/zsh</code></pre><h1 id="高级编程语言"><a href="#高级编程语言" class="headerlink" title="高级编程语言"></a>高级编程语言</h1><p>理论上讲，只要一门语言提供了解释器（而不仅是编译器），这门语言就可以胜任脚本编程，常见的解释型语言都是可以用作脚本编程的，如：Perl、Tcl、Python、PHP、Ruby。Perl是最老牌的脚本编程语言了，Python这些年也成了一些linux发行版的预置解释器。</p><p>编译型语言，只要有解释器，也可以用作脚本编程，如C shell是内置的（/bin/csh），Java有第三方解释器Jshell，Ada有收费的解释器AdaScript。</p><h1 id="如何选择shell编程语言"><a href="#如何选择shell编程语言" class="headerlink" title="如何选择shell编程语言"></a>如何选择shell编程语言</h1><h2 id="熟悉-vs-陌生"><a href="#熟悉-vs-陌生" class="headerlink" title="熟悉 vs 陌生"></a>熟悉 vs 陌生</h2><p>如果你已经掌握了一门编程语言（如PHP、Python、Java、JavaScript），建议你就直接使用这门语言编写脚本程序，虽然某些地方会有点啰嗦，但你能利用在这门语言领域里的经验（单元测试、单步调试、IDE、第三方类库）。</p><p>新增的学习成本很小，只要学会怎么使用shell解释器（Jshell、AdaScript）就可以了。</p><h2 id="简单-vs-高级"><a href="#简单-vs-高级" class="headerlink" title="简单 vs 高级"></a>简单 vs 高级</h2><p>如果你觉得自己熟悉的语言（如Java、C）写shell脚本实在太啰嗦，你只是想做一些备份文件、安装软件、下载数据之类的事情，学着使用sh，bash会是一个好主意。</p><p>shell只定义了一个非常简单的编程语言，所以，如果你的脚本程序复杂度较高，或者要操作的数据结构比较复杂，那么还是应该使用Python、Perl这样的脚本语言，或者是你本来就已经很擅长的高级语言。因为sh和bash在这方面很弱，比如说：</p><p><strong><em>它的函数只能返回字串，无法返回数组</em></strong></p><p><strong><em>它不支持面向对象，你无法实现一些优雅的设计模式</em></strong></p><p><strong><em>它是解释型的，一边解释一边执行，连PHP那种预编译都不是，如果你的脚本包含错误(例如调用了不存在的函数)，只要没执行到这一行，就不会报错</em></strong></p><h2 id="环境兼容性"><a href="#环境兼容性" class="headerlink" title="环境兼容性"></a>环境兼容性</h2><p>如果你的脚本是提供给别的用户使用，使用sh或者bash，你的脚本将具有最好的环境兼容性，perl很早就是linux标配了，python这些年也成了一些linux发行版的标配，至于mac os，它默认安装了perl、python、ruby、php、java等主流编程语言。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】 <a href="https://www.runoob.com/w3cnote/shell-quick-start.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/shell-quick-start.html</a></p><p>【2】 <a href="https://github.com/qinjx/30min_guides/blob/master/shell.md" target="_blank" rel="noopener">https://github.com/qinjx/30min_guides/blob/master/shell.md</a></p><p>【3】 <a href="http://c.biancheng.net/view/735.html" target="_blank" rel="noopener">http://c.biancheng.net/view/735.html</a></p><p>【4】 <a href="http://tldp.org/LDP/abs/html/" target="_blank" rel="noopener">http://tldp.org/LDP/abs/html/</a> ，非常详细，非常易读，大量example，既可以当入门教材，也可以当做工具书查阅</p><p>【5】 <a href="http://www.tutorialspoint.com/unix/unix-shell.htm" target="_blank" rel="noopener">http://www.tutorialspoint.com/unix/unix-shell.htm</a></p><p>【6】 <a href="https://bash.cyberciti.biz/guide/Main_Page" target="_blank" rel="noopener">https://bash.cyberciti.biz/guide/Main_Page</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Shell脚本编程，懒虫的最爱。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Shell" scheme="http://yoursite.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Scala学习笔记I</title>
    <link href="http://yoursite.com/2019/09/10/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0I/"/>
    <id>http://yoursite.com/2019/09/10/Scala学习笔记I/</id>
    <published>2019-09-10T03:32:12.000Z</published>
    <updated>2019-09-10T10:31:50.546Z</updated>
    
    <content type="html"><![CDATA[<p>Scala学习</p><a id="more"></a><h1 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h1><h1 id="fold-foldLeft和foldRight区别与联系"><a href="#fold-foldLeft和foldRight区别与联系" class="headerlink" title="fold,foldLeft和foldRight区别与联系"></a>fold,foldLeft和foldRight区别与联系</h1><p>从本质上说，fold函数将一种格式的输入数据转化成另外一种格式返回。</p><pre><code>def fold(){  val a=List(1,2,3,4)  val res=a.fold(0){    (z,i) =&gt; z+i  }  println(res)  //res=10}</code></pre><p>List中的fold方法需要输入两个参数：初始值以及一个函数。输入的函数也需要输入两个参数：累加值和当前item的索引。那么上面的代码片段发生了什么事？</p><p>代码开始运行的时候，初始值0作为第一个参数传进到fold函数中，list中的第一个item作为第二个参数传进fold函数中。</p><p>1、fold函数开始对传进的两个参数进行计算，在本例中，仅仅是做加法计算，然后返回计算的值；</p><p>2、Fold函数然后将上一步返回的值作为输入函数的第一个参数，并且把list中的下一个item作为第二个参数传进继续计算，同样返回计算的值；</p><p>3、第2步将重复计算，直到list中的所有元素都被遍历之后，返回最后的计算值，整个过程结束；</p><p>4、这虽然是一个简单的例子，让我们来看看一些比较有用的东西。早在后面将会介绍foldLeft函数，并解释它和fold之间的区别，目前，你只需要想象foldLeft函数和fold函数运行过程一样。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】 <a href="https://www.iteblog.com/archives/1228.html" target="_blank" rel="noopener">https://www.iteblog.com/archives/1228.html</a><br>【2】</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Scala学习&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记VIII</title>
    <link href="http://yoursite.com/2019/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0VIII/"/>
    <id>http://yoursite.com/2019/09/06/Java学习笔记VIII/</id>
    <published>2019-09-06T10:43:12.000Z</published>
    <updated>2019-09-16T09:04:07.370Z</updated>
    
    <content type="html"><![CDATA[<p>使用Quzrtz 及Cron定时表达式语法解析</p><a id="more"></a><h1 id="Cron表达式范例："><a href="#Cron表达式范例：" class="headerlink" title="Cron表达式范例："></a>Cron表达式范例：</h1><pre><code>*/10 * * * * ?  每隔10秒执行一次0 */1 * * * ?  每隔1分钟执行一次0 0 23 * * ?  每天23点执行一次0 0 1 * * ?  每天凌晨1点执行一次：0 0 1 1 * ?  每月1号凌晨1点执行一次0 0 23 L * ?  每月最后一天23点执行一次0 0 1 ? * L  每周星期天凌晨1点实行一次0 26,29,33 * * * ?  在26分、29分、33分执行一次0 0 0,13,18,21 * * ? 每天的0点、13点、18点、21点都执行一次</code></pre><h1 id="Cron-表达式"><a href="#Cron-表达式" class="headerlink" title="Cron 表达式"></a>Cron 表达式</h1><p>Cron表达式由7个部分组成，各部分用空格隔开，例如0 0 12 ? * WED（每星期三下午12:00 执行）</p><p>Cron表达式的7个部分从左到右代表的含义如下</p><pre><code>Seconds Minutes Hours Day-of-Month Month Day-of-Week Year</code></pre><p>其中Year是可选的</p><h1 id="Cron表达式可选的值"><a href="#Cron表达式可选的值" class="headerlink" title="Cron表达式可选的值"></a>Cron表达式可选的值</h1><pre><code>Seconds秒：数字0－59Minutes分：数字0－59Hours时 ：数字0-23Day-of-Month月中的几号 ：可以用数字1-31 中的任一一个值，但要注意一些特别的月份Month一年中的几月：可以用0-11 或用字符串 “JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV and DEC” 表示Day-of-Week每周：数字1-7（1 ＝ 星期日），或用字符口串“SUN, MON, TUE, WED, THU, FRI and SAT”字段名                 允许的值                        允许的特殊字符  秒                    0-59                            , - * /  分                    0-59                            , - * /  小时                  0-23                            , - * /  日                    1-31                            , - * ? / L W C  月                    1-12 or JAN-DEC                 , - * /  周几                  1-7 or SUN-SAT                   , - * ? / L C #  年 (可选字段)          empty, 1970-2099                 , - * /</code></pre><h1 id="Cron中的符号"><a href="#Cron中的符号" class="headerlink" title="Cron中的符号"></a>Cron中的符号</h1><pre><code>* ：代表整个时间段./ ：表示每多长时间执行一次0/15表示每隔15分钟执行一次,“0”表示为从“0”分开始；3/20表示每隔20分钟执行一次，“3”表示从第3分钟开始执行? ：表示每月的某一天，或第几周的某一天L ：“6L”表示“每月的最后一个星期五”W：表示为最近工作日如“15W”放在每月（day-of-month）字段上表示为“到本月15日最近的工作日”#：是用来指定“的”每月第n个工作日&quot;6#3&quot;或者&quot;FRI#3&quot;:在每周（day-of-week）中表示“每月第三个星期五”问号(?)就是用来对日期和星期字段做互斥的，问号(?)的作用是指明该字段‘没有特定的值’，星号(*)和其它值，比如数字，都是给该字段指明特定的值，而星号(*)代表所有，在天时表示每一天。“?”字符：表示不确定的值“,”字符：指定数个值“-”字符：指定一个值的范围“/”字符：指定一个值的增加幅度。n/m表示从n开始，每次增加m“L”字符：用在日表示一个月中的最后一天，用在周表示该月最后一个星期X“W”字符：指定离给定日期最近的工作日(周一到周五)“#”字符：表示该月第几个周X。6#3表示该月第3个周五</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<br><a href="https://www.jianshu.com/p/f03b1497122a" target="_blank" rel="noopener">https://www.jianshu.com/p/f03b1497122a</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Quzrtz 及Cron定时表达式语法解析&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记VII</title>
    <link href="http://yoursite.com/2019/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0VII/"/>
    <id>http://yoursite.com/2019/09/06/Java学习笔记VII/</id>
    <published>2019-09-06T07:12:12.000Z</published>
    <updated>2019-09-06T07:43:28.956Z</updated>
    
    <content type="html"><![CDATA[<p>Java并发编程中synchronized的概念</p><a id="more"></a><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>synchronized 是 Java 中的关键字，是利用锁的机制来实现同步的。<br>锁机制有如下两种特性：</p><h2 id="互斥性："><a href="#互斥性：" class="headerlink" title="互斥性："></a>互斥性：</h2><p>即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程中的协调机制，这样在同一时间只有一个线程对需同步的代码块(复合操作)进行访问。互斥性我们也往往称为操作的原子性。</p><h2 id="可见性："><a href="#可见性：" class="headerlink" title="可见性："></a>可见性：</h2><p>必须确保在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的（即在获得锁时应获得最新共享变量的值），否则另一个线程可能是在本地缓存的某个副本上继续操作从而引起不一致。</p><h1 id="对象锁和类锁"><a href="#对象锁和类锁" class="headerlink" title="对象锁和类锁"></a>对象锁和类锁</h1><h2 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h2><p>在 Java 中，每个对象都会有一个 monitor 对象，这个对象其实就是 Java 对象的锁，通常会被称为“内置锁”或“对象锁”。类的对象可以有多个，所以每个对象有其独立的对象锁，互不干扰。</p><h2 id="类锁"><a href="#类锁" class="headerlink" title="类锁"></a>类锁</h2><p>在 Java 中，针对每个类也有一个锁，可以称为“类锁”，类锁实际上是通过对象锁实现的，即类的 Class 对象锁。每个类只有一个 Class 对象，所以每个类只有一个类锁。</p><h1 id="synchronized-的用法分类"><a href="#synchronized-的用法分类" class="headerlink" title="synchronized 的用法分类"></a>synchronized 的用法分类</h1><p>synchronized 的用法可以从两个维度上面分类：</p><h2 id="根据修饰对象分类"><a href="#根据修饰对象分类" class="headerlink" title="根据修饰对象分类"></a>根据修饰对象分类</h2><p>synchronized 可以修饰方法和代码块</p><h3 id="修饰代码块"><a href="#修饰代码块" class="headerlink" title="修饰代码块"></a>修饰代码块</h3><pre><code>synchronized(this|object) {}synchronized(类.class) {}</code></pre><h3 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h3><p>修饰非静态方法</p><p>修饰静态方法</p><h2 id="根据获取的锁分类"><a href="#根据获取的锁分类" class="headerlink" title="根据获取的锁分类"></a>根据获取的锁分类</h2><h3 id="获取对象锁"><a href="#获取对象锁" class="headerlink" title="获取对象锁"></a>获取对象锁</h3><pre><code>synchronized(this|object) {}</code></pre><p>修饰非静态方法</p><h3 id="获取类锁"><a href="#获取类锁" class="headerlink" title="获取类锁"></a>获取类锁</h3><pre><code>synchronized(类.class) {}</code></pre><p>修饰静态方法</p><h1 id="synchronized-的用法详解"><a href="#synchronized-的用法详解" class="headerlink" title="synchronized 的用法详解"></a>synchronized 的用法详解</h1><p>这里根据获取的锁分类来分析 synchronized 的用法</p><h2 id="获取对象锁-1"><a href="#获取对象锁-1" class="headerlink" title="获取对象锁"></a>获取对象锁</h2><h3 id="对于同一对象"><a href="#对于同一对象" class="headerlink" title="对于同一对象"></a>对于同一对象</h3><p>同步线程类：</p><pre><code>class SyncThread implements Runnable {    @Override    public void run() {        String threadName = Thread.currentThread().getName();        if (threadName.startsWith(&quot;A&quot;)) {            async();        } else if (threadName.startsWith(&quot;B&quot;)) {            sync1();        } else if (threadName.startsWith(&quot;C&quot;)) {            sync2();        }    }    /**     * 异步方法     */    private void async() {        try {            System.out.println(Thread.currentThread().getName() + &quot;_Async_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            Thread.sleep(2000);            System.out.println(Thread.currentThread().getName() + &quot;_Async_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));        } catch (InterruptedException e) {            e.printStackTrace();        }    }    /**     * 方法中有 synchronized(this|object) {} 同步代码块     */    private void sync1() {        System.out.println(Thread.currentThread().getName() + &quot;_Sync1: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));        synchronized (this) {            try {                System.out.println(Thread.currentThread().getName() + &quot;_Sync1_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));                Thread.sleep(2000);                System.out.println(Thread.currentThread().getName() + &quot;_Sync1_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }    /**     * synchronized 修饰非静态方法     */    private synchronized void sync2() {        System.out.println(Thread.currentThread().getName() + &quot;_Sync2: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));        try {            System.out.println(Thread.currentThread().getName() + &quot;_Sync2_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            Thread.sleep(2000);            System.out.println(Thread.currentThread().getName() + &quot;_Sync2_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><p>测试代码：</p><pre><code>public class SyncTest {    public static void main(String... args) {        SyncThread syncThread = new SyncThread();        Thread A_thread1 = new Thread(syncThread, &quot;A_thread1&quot;);        Thread A_thread2 = new Thread(syncThread, &quot;A_thread2&quot;);        Thread B_thread1 = new Thread(syncThread, &quot;B_thread1&quot;);        Thread B_thread2 = new Thread(syncThread, &quot;B_thread2&quot;);        Thread C_thread1 = new Thread(syncThread, &quot;C_thread1&quot;);        Thread C_thread2 = new Thread(syncThread, &quot;C_thread2&quot;);        A_thread1.start();        A_thread2.start();        B_thread1.start();        B_thread2.start();        C_thread1.start();        C_thread2.start();    }}</code></pre><p>运行结果：</p><pre><code>B_thread2_Sync1: 14:44:20A_thread1_Async_Start: 14:44:20B_thread1_Sync1: 14:44:20C_thread1_Sync2: 14:44:20A_thread2_Async_Start: 14:44:20C_thread1_Sync2_Start: 14:44:20A_thread1_Async_End: 14:44:22A_thread2_Async_End: 14:44:22C_thread1_Sync2_End: 14:44:22B_thread1_Sync1_Start: 14:44:22B_thread1_Sync1_End: 14:44:24B_thread2_Sync1_Start: 14:44:24B_thread2_Sync1_End: 14:44:26C_thread2_Sync2: 14:44:26C_thread2_Sync2_Start: 14:44:26C_thread2_Sync2_End: 14:44:28</code></pre><p>结果分析：</p><p>A 类线程访问方法中没有同步代码块，A 类线程是异步的，所以有线程访问对象的同步代码块时，另外的线程可以访问该对象的非同步代码块：</p><pre><code>A_thread1_Async_Start: 14:44:20A_thread2_Async_Start: 14:44:20A_thread1_Async_End: 14:44:22A_thread2_Async_End: 14:44:22</code></pre><p>B 类线程访问的方法中有同步代码块，B 类线程是同步的，一个线程在访问对象的同步代码块，另一个访问对象的同步代码块的线程会被阻塞：</p><pre><code>B_thread1_Sync1_End: 14:44:24B_thread2_Sync1_Start: 14:44:24B_thread2_Sync1_End: 14:44:26synchronized(this|object) {} 代码块 {} 之外的代码依然是异步的：B_thread2_Sync1: 14:44:20B_thread1_Sync1: 14:44:20</code></pre><p>C 类线程访问的是 synchronized 修饰非静态方法，C 类线程是同步的，一个线程在访问对象的同步代方法，另一个访问对象同步方法的线程会被阻塞：</p><pre><code>C_thread1_Sync2_Start: 14:44:20C_thread1_Sync2_End: 14:44:22C_thread2_Sync2_Start: 14:44:26C_thread2_Sync2_End: 14:44:28</code></pre><p>synchronized 修饰非静态方法，作用范围是整个方法，所以方法中所有的代码都是同步的：</p><pre><code>C_thread1_Sync2: 14:44:20C_thread2_Sync2: 14:44:26</code></pre><p>由结果可知 B 类和 C 类线程顺序执行，类中 synchronized(this|object) {} 代码块和 synchronized 修饰非静态方法获取的锁是同一个锁，即该类的对象的对象锁。所以 B 类线程和 C 类线程也是同步的：</p><pre><code>B_thread1_Sync1_Start: 14:44:22B_thread1_Sync1_End: 14:44:24C_thread1_Sync2_Start: 14:44:20C_thread1_Sync2_End: 14:44:22B_thread2_Sync1_Start: 14:44:24B_thread2_Sync1_End: 14:44:26C_thread2_Sync2_Start: 14:44:26C_thread2_Sync2_End: 14:44:28</code></pre><h3 id="对于不同对象"><a href="#对于不同对象" class="headerlink" title="对于不同对象"></a>对于不同对象</h3><p>修改测试代码为：</p><pre><code>public class SyncTest {    public static void main(String... args) {        Thread A_thread1 = new Thread(new SyncThread(), &quot;A_thread1&quot;);        Thread A_thread2 = new Thread(new SyncThread(), &quot;A_thread2&quot;);        Thread B_thread1 = new Thread(new SyncThread(), &quot;B_thread1&quot;);        Thread B_thread2 = new Thread(new SyncThread(), &quot;B_thread2&quot;);        Thread C_thread1 = new Thread(new SyncThread(), &quot;C_thread1&quot;);        Thread C_thread2 = new Thread(new SyncThread(), &quot;C_thread2&quot;);        A_thread1.start();        A_thread2.start();        B_thread1.start();        B_thread2.start();        C_thread1.start();        C_thread2.start();    }}</code></pre><p>运行结果：</p><pre><code>A_thread2_Async_Start: 15:01:34C_thread2_Sync2: 15:01:34B_thread2_Sync1: 15:01:34C_thread1_Sync2: 15:01:34B_thread2_Sync1_Start: 15:01:34B_thread1_Sync1: 15:01:34C_thread1_Sync2_Start: 15:01:34A_thread1_Async_Start: 15:01:34C_thread2_Sync2_Start: 15:01:34B_thread1_Sync1_Start: 15:01:34C_thread1_Sync2_End: 15:01:36A_thread1_Async_End: 15:01:36C_thread2_Sync2_End: 15:01:36B_thread2_Sync1_End: 15:01:36B_thread1_Sync1_End: 15:01:36A_thread2_Async_End: 15:01:36</code></pre><p>结果分析：</p><p>两个线程访问不同对象的 synchronized(this|object) {} 代码块和 synchronized 修饰非静态方法是异步的，同一个类的不同对象的对象锁互不干扰。</p><h2 id="获取类锁-1"><a href="#获取类锁-1" class="headerlink" title="获取类锁"></a>获取类锁</h2><h3 id="对于同一对象-1"><a href="#对于同一对象-1" class="headerlink" title="对于同一对象"></a>对于同一对象</h3><p>同步线程类：</p><pre><code>class SyncThread implements Runnable {    @Override    public void run() {        String threadName = Thread.currentThread().getName();        if (threadName.startsWith(&quot;A&quot;)) {            async();        } else if (threadName.startsWith(&quot;B&quot;)) {            sync1();        } else if (threadName.startsWith(&quot;C&quot;)) {            sync2();        }    }    /**     * 异步方法     */    private void async() {        try {            System.out.println(Thread.currentThread().getName() + &quot;_Async_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            Thread.sleep(2000);            System.out.println(Thread.currentThread().getName() + &quot;_Async_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));        } catch (InterruptedException e) {            e.printStackTrace();        }    }    /**     * 方法中有 synchronized(类.class) {} 同步代码块     */    private void sync1() {        System.out.println(Thread.currentThread().getName() + &quot;_Sync1: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));        synchronized (SyncThread.class) {            try {                System.out.println(Thread.currentThread().getName() + &quot;_Sync1_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));                Thread.sleep(2000);                System.out.println(Thread.currentThread().getName() + &quot;_Sync1_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }    /**     * synchronized 修饰静态方法     */    private synchronized static void sync2() {        System.out.println(Thread.currentThread().getName() + &quot;_Sync2: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));        try {            System.out.println(Thread.currentThread().getName() + &quot;_Sync2_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            Thread.sleep(2000);            System.out.println(Thread.currentThread().getName() + &quot;_Sync2_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><p>测试代码：</p><pre><code>public class SyncTest {    public static void main(String... args) {        SyncThread syncThread = new SyncThread();        Thread A_thread1 = new Thread(syncThread, &quot;A_thread1&quot;);        Thread A_thread2 = new Thread(syncThread, &quot;A_thread2&quot;);        Thread B_thread1 = new Thread(syncThread, &quot;B_thread1&quot;);        Thread B_thread2 = new Thread(syncThread, &quot;B_thread2&quot;);        Thread C_thread1 = new Thread(syncThread, &quot;C_thread1&quot;);        Thread C_thread2 = new Thread(syncThread, &quot;C_thread2&quot;);        A_thread1.start();        A_thread2.start();        B_thread1.start();        B_thread2.start();        C_thread1.start();        C_thread2.start();    }}</code></pre><p>运行结果：</p><pre><code>B_thread1_Sync1: 15:08:13C_thread1_Sync2: 15:08:13B_thread2_Sync1: 15:08:13A_thread1_Async_Start: 15:08:13C_thread1_Sync2_Start: 15:08:13A_thread2_Async_Start: 15:08:13C_thread1_Sync2_End: 15:08:15A_thread2_Async_End: 15:08:15A_thread1_Async_End: 15:08:15B_thread2_Sync1_Start: 15:08:15B_thread2_Sync1_End: 15:08:17B_thread1_Sync1_Start: 15:08:17B_thread1_Sync1_End: 15:08:19C_thread2_Sync2: 15:08:19C_thread2_Sync2_Start: 15:08:19C_thread2_Sync2_End: 15:08:21</code></pre><p>结果分析：</p><p>由结果可以看出，在同一对象的情况下，synchronized(类.class) {} 代码块或 synchronized 修饰静态方法和 synchronized(this|object) {} 代码块和 synchronized 修饰非静态方法的行为一致。</p><h3 id="对于不同对象-1"><a href="#对于不同对象-1" class="headerlink" title="对于不同对象"></a>对于不同对象</h3><p>修改测试代码为：</p><pre><code>public class SyncTest {    public static void main(String... args) {        Thread A_thread1 = new Thread(new SyncThread(), &quot;A_thread1&quot;);        Thread A_thread2 = new Thread(new SyncThread(), &quot;A_thread2&quot;);        Thread B_thread1 = new Thread(new SyncThread(), &quot;B_thread1&quot;);        Thread B_thread2 = new Thread(new SyncThread(), &quot;B_thread2&quot;);        Thread C_thread1 = new Thread(new SyncThread(), &quot;C_thread1&quot;);        Thread C_thread2 = new Thread(new SyncThread(), &quot;C_thread2&quot;);        A_thread1.start();        A_thread2.start();        B_thread1.start();        B_thread2.start();        C_thread1.start();        C_thread2.start();    }}</code></pre><p>运行结果：</p><pre><code>A_thread2_Async_Start: 15:17:28B_thread2_Sync1: 15:17:28A_thread1_Async_Start: 15:17:28B_thread1_Sync1: 15:17:28C_thread1_Sync2: 15:17:28C_thread1_Sync2_Start: 15:17:28C_thread1_Sync2_End: 15:17:30A_thread2_Async_End: 15:17:30B_thread1_Sync1_Start: 15:17:30A_thread1_Async_End: 15:17:30B_thread1_Sync1_End: 15:17:32B_thread2_Sync1_Start: 15:17:32B_thread2_Sync1_End: 15:17:34C_thread2_Sync2: 15:17:34C_thread2_Sync2_Start: 15:17:34C_thread2_Sync2_End: 15:17:36</code></pre><p>结果分析：</p><p>两个线程访问不同对象的 synchronized(类.class) {} 代码块或 synchronized 修饰静态方法还是同步的，类中 synchronized(类.class) {} 代码块和 synchronized 修饰静态方法获取的锁是类锁。对于同一个类的不同对象的类锁是同一个。</p><h2 id="类中同时有-synchronized-类-class-代码块或-synchronized-修饰静态方法和-synchronized-this-object-代码块和-synchronized-修饰非静态方法时会怎样？"><a href="#类中同时有-synchronized-类-class-代码块或-synchronized-修饰静态方法和-synchronized-this-object-代码块和-synchronized-修饰非静态方法时会怎样？" class="headerlink" title="类中同时有 synchronized(类.class) {} 代码块或 synchronized 修饰静态方法和 synchronized(this|object) {} 代码块和 synchronized 修饰非静态方法时会怎样？"></a>类中同时有 synchronized(类.class) {} 代码块或 synchronized 修饰静态方法和 synchronized(this|object) {} 代码块和 synchronized 修饰非静态方法时会怎样？</h2><p>修改同步线程类：</p><pre><code>class SyncThread implements Runnable {    @Override    public void run() {        String threadName = Thread.currentThread().getName();        if (threadName.startsWith(&quot;A&quot;)) {            async();        } else if (threadName.startsWith(&quot;B&quot;)) {            sync1();        } else if (threadName.startsWith(&quot;C&quot;)) {            sync2();        }    }    /**     * 异步方法     */    private void async() {        try {            System.out.println(Thread.currentThread().getName() + &quot;_Async_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            Thread.sleep(2000);            System.out.println(Thread.currentThread().getName() + &quot;_Async_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));        } catch (InterruptedException e) {            e.printStackTrace();        }    }    /**     * synchronized 修饰非静态方法     */    private synchronized void sync1() {        try {            System.out.println(Thread.currentThread().getName() + &quot;_Sync1_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            Thread.sleep(2000);            System.out.println(Thread.currentThread().getName() + &quot;_Sync1_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));        } catch (InterruptedException e) {            e.printStackTrace();        }    }    /**     * synchronized 修饰静态方法     */    private synchronized static void sync2() {        try {            System.out.println(Thread.currentThread().getName() + &quot;_Sync2_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            Thread.sleep(2000);            System.out.println(Thread.currentThread().getName() + &quot;_Sync2_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><p>修改测试代码：</p><pre><code>public class SyncTest {    public static void main(String... args) {        Thread B_thread1 = new Thread(syncThread, &quot;B_thread1&quot;);        Thread C_thread1 = new Thread(syncThread, &quot;C_thread1&quot;);        B_thread1.start();        C_thread1.start();    }}</code></pre><p>运行结果：</p><pre><code>B_thread1_Sync1_Start: 15:35:21C_thread1_Sync2_Start: 15:35:21B_thread1_Sync1_End: 15:35:23C_thread1_Sync2_End: 15:35:23</code></pre><p>运行结果分析：</p><p>由结果可以看到 B 类线程和 C 类线程是异步的，即 synchronized 修饰静态方法和 synchronized 修饰非静态方法是异步的，对于 synchronized(类.class) {} 代码块和 synchronized(this|object) {} 代码块也是一样的。所以对象锁和类锁是独立的，互不干扰。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>synchronized关键字不能继承。</p><p> 对于父类中的 synchronized 修饰方法，子类在覆盖该方法时，默认情况下不是同步的，必须显示的使用 synchronized 关键字修饰才行。</p><p>在定义接口方法时不能使用synchronized关键字。</p><p>构造方法不能使用synchronized关键字，但可以使用synchronized代码块来进行同步。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】 <a href="https://juejin.im/post/594a24defe88c2006aa01f1c" target="_blank" rel="noopener">https://juejin.im/post/594a24defe88c2006aa01f1c</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java并发编程中synchronized的概念&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记VI</title>
    <link href="http://yoursite.com/2019/09/05/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0VI/"/>
    <id>http://yoursite.com/2019/09/05/Java学习笔记VI/</id>
    <published>2019-09-05T07:12:12.000Z</published>
    <updated>2019-09-05T07:37:21.245Z</updated>
    
    <content type="html"><![CDATA[<p>Java基本数据类型和包装类的区别,不同类型为空的异常判断，集合操作</p><a id="more"></a><p>在实际的工程项目开发中，常遇到对于传入参数的异常处理，对于不同类型的参数需要进行不同的判断，例如有时int，long类型的参数需要判断是否为0，而Integer和Long类型的参数需要判断是否为空。String类型的需要使用StringUtils.isEmpty()</p><h1 id="StringUtils类中isEmpty与isBlank的区别"><a href="#StringUtils类中isEmpty与isBlank的区别" class="headerlink" title="StringUtils类中isEmpty与isBlank的区别"></a>StringUtils类中isEmpty与isBlank的区别</h1><p>org.apache.commons.lang.StringUtils类提供了String的常用操作,最为常用的判空有如下两种isEmpty(String str)和isBlank(String str)。</p><p>StringUtils.isEmpty(String str) 判断某字符串是否为空，为空的标准是 str==null 或 str.length()==0</p><pre><code>System.out.println(StringUtils.isEmpty(null));        //trueSystem.out.println(StringUtils.isEmpty(&quot;&quot;));          //trueSystem.out.println(StringUtils.isEmpty(&quot;   &quot;));       //falseSystem.out.println(StringUtils.isEmpty(&quot;dd&quot;));        //falseStringUtils.isNotEmpty(String str) 等价于 !isEmpty(String str)</code></pre><p>StringUtils.isBlank(String str) 判断某字符串是否为空或长度为0或由空白符(whitespace) 构成</p><pre><code>System.out.println(StringUtils.isBlank(null));        //trueSystem.out.println(StringUtils.isBlank(&quot;&quot;));          //trueSystem.out.println(StringUtils.isBlank(&quot;   &quot;));       //trueSystem.out.println(StringUtils.isBlank(&quot;dd&quot;));        //false    </code></pre><p>StringUtils.isBlank(String str) 等价于 !isBlank(String str)</p><h1 id="集合操作-CollectionUtils"><a href="#集合操作-CollectionUtils" class="headerlink" title="集合操作 CollectionUtils"></a>集合操作 CollectionUtils</h1><p>对于查询到的集合例如：</p><pre><code>List&lt;TblJobsEntity&gt; tblJobsEntityList = tblJobsEntityMapper.selectByExample(tblJobsEntityExample);</code></pre><p>进行判断时，不能使用</p><pre><code>if(tblJobsEntityList.isEmpty())</code></pre><p>因为若查询到的tblJobsEntityList为null，则null.isEmpty()会出现空指针异常，如</p><pre><code>Exception in thread &quot;main&quot; java.lang.NullPointerException</code></pre><p>需要使用CollectionUtils.isEmpty(tblJobsEntityList)来进行判断</p><h2 id="集合判断："><a href="#集合判断：" class="headerlink" title="集合判断："></a>集合判断：</h2><h3 id="判断集合是否为空"><a href="#判断集合是否为空" class="headerlink" title="判断集合是否为空:"></a>判断集合是否为空:</h3><pre><code>CollectionUtils.isEmpty(null): trueCollectionUtils.isEmpty(new ArrayList()): trueCollectionUtils.isEmpty({a,b}): false</code></pre><h3 id="判断集合是否不为空"><a href="#判断集合是否不为空" class="headerlink" title="判断集合是否不为空:"></a>判断集合是否不为空:</h3><pre><code>CollectionUtils.isNotEmpty(null): falseCollectionUtils.isNotEmpty(new ArrayList()): falseCollectionUtils.isNotEmpty({a,b}): true</code></pre><h3 id="2个集合间的操作："><a href="#2个集合间的操作：" class="headerlink" title="2个集合间的操作："></a>2个集合间的操作：</h3><pre><code>集合a: {1,2,3,3,4,5}集合b: {3,4,4,5,6,7}CollectionUtils.union(a, b)(并集): {1,2,3,3,4,4,5,6,7}CollectionUtils.intersection(a, b)(交集): {3,4,5}CollectionUtils.disjunction(a, b)(交集的补集): {1,2,3,4,6,7}CollectionUtils.disjunction(b, a)(交集的补集): {1,2,3,4,6,7}CollectionUtils.subtract(a, b)(A与B的差): {1,2,3}CollectionUtils.subtract(b, a)(B与A的差): {4,6,7}</code></pre><h1 id="Java基本数据类型和包装类的区别"><a href="#Java基本数据类型和包装类的区别" class="headerlink" title="Java基本数据类型和包装类的区别"></a>Java基本数据类型和包装类的区别</h1><p>Java的数据类型分两种：</p><p>基本类型：byte，short，int，long，boolean，float，double，char</p><p>引用类型：所有class和interface类型</p><p>引用类型可以赋值为null，表示空，但基本类型不能赋值为null：</p><pre><code>String s = null;int n = null; // compile error!</code></pre><p>如何把一个基本类型视为对象（引用类型）？</p><h2 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h2><p>比如，想要把int基本类型变成一个引用类型，我们可以定义一个Integer类，它只包含一个实例字段int，这样，Integer类就可以视为int的包装类（Wrapper Class）：</p><pre><code>public class Integer {    private int value;    public Integer(int value) {        this.value = value;    }    public int intValue() {        return this.value;    }}</code></pre><p>定义好了Integer类，我们就可以把int和Integer互相转换：</p><pre><code>Integer n = null;Integer n2 = new Integer(99);int n3 = n2.intValue();</code></pre><p>实际上，因为包装类型非常有用，Java核心库为每种基本类型都提供了对应的包装类型：</p><pre><code>基本类型      对应的引用类型boolean       java.lang.Booleanbyte         java.lang.Byteshort         java.lang.Shortint           java.lang.Integerlong         java.lang.Longfloat         java.lang.Floatdouble       java.lang.Doublechar         java.lang.Character</code></pre><p>我们可以直接使用，并不需要自己去定义：</p><pre><code>// Integer:public class Main {    public static void main(String[] args) {        int i = 100;        // 通过new操作符创建Integer实例(不推荐使用,会有编译警告):        Integer n1 = new Integer(i);        // 通过静态方法valueOf(int)创建Integer实例:        Integer n2 = Integer.valueOf(i);        // 通过静态方法valueOf(String)创建Integer实例:        Integer n3 = Integer.valueOf(&quot;100&quot;);        System.out.println(n3.intValue());    }}</code></pre><h2 id="Auto-Boxing"><a href="#Auto-Boxing" class="headerlink" title="Auto Boxing"></a>Auto Boxing</h2><p>因为int和Integer可以互相转换：</p><pre><code>int i = 100;Integer n = Integer.valueOf(i);int x = n.intValue();</code></pre><p>所以，Java编译器可以帮助我们自动在int和Integer之间转型：</p><pre><code>Integer n = 100; // 编译器自动使用Integer.valueOf(int)int x = n; // 编译器自动使用Integer.intValue()</code></pre><p>这种直接把int变为Integer的赋值写法，称为自动装箱（Auto Boxing），反过来，把Integer变为int的赋值写法，称为自动拆箱（Auto Unboxing）。</p><p>注意：自动装箱和自动拆箱只发生在编译阶段，目的是为了少写代码。</p><p>装箱和拆箱会影响代码的执行效率，因为编译后的class代码是严格区分基本类型和引用类型的。并且，自动拆箱执行时可能会报NullPointerException：</p><pre><code>// NullPointerExceptionpublic class Main {    public static void main(String[] args) {        Integer n = null;        int i = n;    }}</code></pre><h2 id="不变类"><a href="#不变类" class="headerlink" title="不变类"></a>不变类</h2><p>所有的包装类型都是不变类。我们查看Integer的源码可知，它的核心代码如下：</p><pre><code>public final class Integer {    private final int value;}</code></pre><p>因此，一旦创建了Integer对象，该对象就是不变的。</p><p>对两个Integer实例进行比较要特别注意：绝对不能用==比较，因为Integer是引用类型，必须使用equals()比较：</p><pre><code>// == or equals?public class Main {    public static void main(String[] args) {        Integer x = 127;        Integer y = 127;        Integer m = 99999;        Integer n = 99999;        System.out.println(&quot;x == y: &quot; + (x==y)); // true        System.out.println(&quot;m == n: &quot; + (m==n)); // false        System.out.println(&quot;x.equals(y): &quot; + x.equals(y)); // true        System.out.println(&quot;m.equals(n): &quot; + m.equals(n)); // true    }}</code></pre><p>仔细观察结果的童鞋可以发现，==比较，较小的两个相同的Integer返回true，较大的两个相同的Integer返回false，这是因为Integer是不变类，编译器把Integer x = 127;自动变为Integer x = Integer.valueOf(127);</p><p>为了节省内存，Integer.valueOf()对于较小的数，始终返回相同的实例，因此，==比较“恰好”为true，但我们绝不能因为Java标准库的Integer内部有缓存优化就用==比较，必须用equals()方法比较两个Integer。</p><p>按照语义编程，而不是针对特定的底层实现去“优化”。</p><p>因为Integer.valueOf()可能始终返回同一个Integer实例，因此，在我们自己创建Integer的时候，以下两种方法：</p><pre><code>方法1：Integer n = new Integer(100);方法2：Integer n = Integer.valueOf(100);</code></pre><p>方法2更好，因为方法1总是创建新的Integer实例，方法2把内部优化留给Integer的实现者去做，即使在当前版本没有优化，也有可能在下一个版本进行优化。</p><p>我们把能创建“新”对象的静态方法称为静态工厂方法。Integer.valueOf()就是静态工厂方法，它尽可能地返回缓存的实例以节省内存。</p><p> 创建新对象时，优先选用静态工厂方法而不是new操作符。</p><p>如果我们考察Byte.valueOf()方法的源码，可以看到，标准库返回的Byte实例全部是缓存实例，但调用者并不关心静态工厂方法以何种方式创建新实例还是直接返回缓存的实例。</p><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><p>Integer类本身还提供了大量方法，例如，最常用的静态方法parseInt()可以把字符串解析成一个整数：</p><pre><code>int x1 = Integer.parseInt(&quot;100&quot;); // 100int x2 = Integer.parseInt(&quot;100&quot;, 16); // 256,因为按16进制解析</code></pre><p>Integer还可以把整数格式化为指定进制的字符串：</p><pre><code>// Integer:public class Main {    public static void main(String[] args) {        System.out.println(Integer.toString(100)); // &quot;100&quot;,表示为10进制        System.out.println(Integer.toString(100, 36)); // &quot;2s&quot;,表示为36进制        System.out.println(Integer.toHexString(100)); // &quot;64&quot;,表示为16进制        System.out.println(Integer.toOctalString(100)); // &quot;144&quot;,表示为8进制        System.out.println(Integer.toBinaryString(100)); // &quot;1100100&quot;,表示为2进制    }}</code></pre><p>注意：上述方法的输出都是String，在计算机内存中，只用二进制表示，不存在十进制或十六进制的表示方法。int n = 100在内存中总是以4字节的二进制表示：</p><pre><code>┌────────┬────────┬────────┬────────┐│00000000│00000000│00000000│01100100│└────────┴────────┴────────┴────────┘</code></pre><p>我们经常使用的System.out.println(n);是依靠核心库自动把整数格式化为10进制输出并显示在屏幕上，使用Integer.toHexString(n)则通过核心库自动把整数格式化为16进制。</p><p>这里我们注意到程序设计的一个重要原则：数据的存储和显示要分离。</p><p>Java的包装类型还定义了一些有用的静态变量</p><pre><code>// boolean只有两个值true/false，其包装类型只需要引用Boolean提供的静态字段:Boolean t = Boolean.TRUE;Boolean f = Boolean.FALSE;// int可表示的最大/最小值:int max = Integer.MAX_VALUE; // 2147483647int min = Integer.MIN_VALUE; // -2147483648// long类型占用的bit和byte数量:int sizeOfLong = Long.SIZE; // 64 (bits)int bytesOfLong = Long.BYTES; // 8 (bytes)</code></pre><p>最后，所有的整数和浮点数的包装类型都继承自Number，因此，可以非常方便地直接通过包装类型获取各种基本类型：</p><pre><code>// 向上转型为Number:Number num = new Integer(999);// 获取byte, int, long, float, double:byte b = num.byteValue();int n = num.intValue();long ln = num.longValue();float f = num.floatValue();double d = num.doubleValue();</code></pre><h2 id="处理无符号整型"><a href="#处理无符号整型" class="headerlink" title="处理无符号整型"></a>处理无符号整型</h2><p>在Java中，并没有无符号整型（Unsigned）的基本数据类型。byte、short、int和long都是带符号整型，最高位是符号位。而C语言则提供了CPU支持的全部数据类型，包括无符号整型。无符号整型和有符号整型的转换在Java中就需要借助包装类型的静态方法完成。</p><p>例如，byte是有符号整型，范围是-128~+127，但如果把byte看作无符号整型，它的范围就是0~255。我们把一个负的byte按无符号整型转换为int：</p><pre><code>// Bytepublic class Main {    public static void main(String[] args) {        byte x = -1;        byte y = 127;        System.out.println(Byte.toUnsignedInt(x)); // 255        System.out.println(Byte.toUnsignedInt(y)); // 127    }}</code></pre><p>因为byte的-1的二进制表示是11111111，以无符号整型转换后的int就是255。</p><p>类似的，可以把一个short按unsigned转换为int，把一个int按unsigned转换为long。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Java核心库提供的包装类型可以把基本类型包装为class；</p><p>自动装箱和自动拆箱都是在编译期完成的（JDK&gt;=1.5）；</p><p>装箱和拆箱会影响执行效率，且拆箱时可能发生NullPointerException；</p><p>包装类型的比较必须使用equals()；</p><p>整数和浮点数的包装类型都继承自Number；</p><p>包装类型提供了大量实用方法。</p><h2 id="思考：Java中基本数据类型和包装类型有什么区别"><a href="#思考：Java中基本数据类型和包装类型有什么区别" class="headerlink" title="思考：Java中基本数据类型和包装类型有什么区别"></a>思考：Java中基本数据类型和包装类型有什么区别</h2><p>1、包装类是对象，拥有方法和字段，对象的调用都是通过引用对象的地址，基本类型不是</p><p>2、包装类型是引用的传递，基本类型是值的传递</p><p>3、声明方式不同，基本数据类型不需要new关键字，而包装类型需要new在堆内存中进行new来分配内存空间</p><p>4、存储位置不同，基本数据类型直接将值保存在值栈中，而包装类型是把对象放在堆中，然后通过对象的引用来调用他们</p><p>5、<strong><em>初始值不同，eg： int的初始值为 0 、 boolean的初始值为false 而包装类型的初始值为null</em></strong></p><p>6、使用方式不同，基本数据类型直接赋值使用就好 ，而包装类型是在集合如 collection Map时会使用</p><p>7.当需要往ArrayList，HashMap中放东西时，像int，double这种基本类型是放不进去的，因为容器都是装object的，这是就需要这些基本类型的外覆类了，比如</p><pre><code>List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="https://blog.csdn.net/shb_derek1/article/details/9624897" target="_blank" rel="noopener">https://blog.csdn.net/shb_derek1/article/details/9624897</a></p><p>【2】<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260473794166400" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1252599548343744/1260473794166400</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java基本数据类型和包装类的区别,不同类型为空的异常判断，集合操作&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Git学习笔记II</title>
    <link href="http://yoursite.com/2019/09/05/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0II/"/>
    <id>http://yoursite.com/2019/09/05/Git学习笔记II/</id>
    <published>2019-09-05T06:51:12.000Z</published>
    <updated>2019-09-05T07:01:26.944Z</updated>
    
    <content type="html"><![CDATA[<p>Git版本回滚</p><a id="more"></a><p>在当前branch上多次commit代码并且push后，发现不符合要求，需要回滚到特定的版本。步骤如下：</p><p>1、查找commitId</p><p>首先用命令行打开git项目路径，输入git log命令查看commit记录，如下：</p><pre><code>$ git log</code></pre><p>找到commitId是9a0d02d1578ea064479296ad7efa70c5cb1a3717记录，这是执行上面命令后打印出来的信息：</p><pre><code>commit 9a0d02d1578ea064479296ad7efa70c5cb1a3717</code></pre><p>2、找到需要回滚的commit，输入git reset –hard {commitId}，将本地文件回滚：</p><pre><code>$ git reset --hard c503cffa099332911d4fce2fc1399cb4bc3ba9d6HEAD is now at c503cffa0 add a constellation test case</code></pre><p>3、此时本地文件已经回滚到刚刚commit 9a0d02d1578ea064479296ad7efa70c5cb1a3717之后的状态，但是服务器仍然没有改变，需要继续远程回滚：</p><pre><code>$ git push -f</code></pre><p>执行，最终提示一系列内容，远程回滚成功</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】 <a href="https://blog.csdn.net/weixin_38569499/article/details/83017699" target="_blank" rel="noopener">https://blog.csdn.net/weixin_38569499/article/details/83017699</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git版本回滚&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>数据库学习笔记V</title>
    <link href="http://yoursite.com/2019/09/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0V/"/>
    <id>http://yoursite.com/2019/09/05/数据库学习笔记V/</id>
    <published>2019-09-05T02:12:12.000Z</published>
    <updated>2019-09-06T02:21:32.702Z</updated>
    
    <content type="html"><![CDATA[<p>使用ALTER命令修改数据表名或者修改数据表字段</p><a id="more"></a><p>当我们需要修改数据表名或者修改数据表字段时，就需要使用到MySQL ALTER命令。</p><h1 id="创建一张表"><a href="#创建一张表" class="headerlink" title="创建一张表"></a>创建一张表</h1><p>表名为：tablename。</p><pre><code>root@host# mysql -u root -p password;Enter password:*******mysql&gt; use RUNOOB;Database changedmysql&gt; create table tablename    -&gt; (    -&gt; i INT,    -&gt; c CHAR(1)    -&gt; );Query OK, 0 rows affected (0.05 sec)mysql&gt; SHOW COLUMNS FROM tablename;+-------+---------+------+-----+---------+-------+| Field | Type    | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| i     | int(11) | YES  |     | NULL    |       || c     | char(1) | YES  |     | NULL    |       |+-------+---------+------+-----+---------+-------+2 rows in set (0.00 sec)</code></pre><h1 id="删除，添加或修改表字段"><a href="#删除，添加或修改表字段" class="headerlink" title="删除，添加或修改表字段"></a>删除，添加或修改表字段</h1><p>如下命令使用了 ALTER 命令及 DROP 子句来删除以上创建表的 i 字段：</p><pre><code>mysql&gt; ALTER TABLE tablename  DROP i;</code></pre><p>如果数据表中只剩余一个字段则无法使用DROP来删除字段。</p><p>MySQL 中使用 ADD 子句来向数据表中添加列，如下实例在表 tablename 中添加 i 字段，并定义数据类型:</p><pre><code>mysql&gt; ALTER TABLE tablename ADD i INT;</code></pre><p>执行以上命令后，i 字段会自动添加到数据表字段的末尾。</p><pre><code>mysql&gt; SHOW COLUMNS FROM tablename;+-------+---------+------+-----+---------+-------+| Field | Type    | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| c     | char(1) | YES  |     | NULL    |       || i     | int(11) | YES  |     | NULL    |       |+-------+---------+------+-----+---------+-------+2 rows in set (0.00 sec)</code></pre><p>如果你需要指定新增字段的位置，可以使用MySQL提供的关键字 FIRST (设定位第一列)， AFTER 字段名（设定位于某个字段之后）。</p><p>尝试以下 ALTER TABLE 语句, 在执行成功后，使用 SHOW COLUMNS 查看表结构的变化：</p><pre><code>ALTER TABLE tablename DROP i;ALTER TABLE tablename ADD i INT FIRST;ALTER TABLE tablename DROP i;ALTER TABLE tablename ADD i INT AFTER c;</code></pre><p>FIRST 和 AFTER 关键字可用于 ADD 与 MODIFY 子句，所以如果你想重置数据表字段的位置就需要先使用 DROP 删除字段然后使用 ADD 来添加字段并设置位置。</p><h1 id="修改字段类型及名称"><a href="#修改字段类型及名称" class="headerlink" title="修改字段类型及名称"></a>修改字段类型及名称</h1><p>如果需要修改字段类型及名称, 你可以在ALTER命令中使用 MODIFY 或 CHANGE 子句 。</p><p>例如，把字段 c 的类型从 CHAR(1) 改为 CHAR(10)，可以执行以下命令:</p><pre><code>mysql&gt; ALTER TABLE tablename MODIFY c CHAR(10);</code></pre><p>使用 CHANGE 子句, 语法有很大的不同。 在 CHANGE 关键字之后，紧跟着的是你要修改的字段名，然后指定新字段名及类型。尝试如下实例：</p><pre><code>mysql&gt; ALTER TABLE tablename CHANGE i j BIGINT;mysql&gt; ALTER TABLE tablename CHANGE j j INT;</code></pre><h1 id="ALTER-TABLE-对-Null-值和默认值的影响"><a href="#ALTER-TABLE-对-Null-值和默认值的影响" class="headerlink" title="ALTER TABLE 对 Null 值和默认值的影响"></a>ALTER TABLE 对 Null 值和默认值的影响</h1><p>当你修改字段时，你可以指定是否包含值或者是否设置默认值。</p><p>以下实例，指定字段 j 为 NOT NULL 且默认值为100 。</p><pre><code>mysql&gt; ALTER TABLE tablename    -&gt; MODIFY j BIGINT NOT NULL DEFAULT 100;</code></pre><p>如果你不设置默认值，MySQL会自动设置该字段默认为 NULL。</p><h1 id="修改字段默认值"><a href="#修改字段默认值" class="headerlink" title="修改字段默认值"></a>修改字段默认值</h1><p>你可以使用 ALTER 来修改字段的默认值，尝试以下实例：</p><pre><code>mysql&gt; ALTER TABLE tablename ALTER i SET DEFAULT 1000;mysql&gt; SHOW COLUMNS FROM tablename;+-------+---------+------+-----+---------+-------+| Field | Type    | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| c     | char(1) | YES  |     | NULL    |       || i     | int(11) | YES  |     | 1000    |       |+-------+---------+------+-----+---------+-------+2 rows in set (0.00 sec)</code></pre><p>你也可以使用 ALTER 命令及 DROP子句来删除字段的默认值，如下实例：</p><pre><code>mysql&gt; ALTER TABLE tablename ALTER i DROP DEFAULT;mysql&gt; SHOW COLUMNS FROM tablename;+-------+---------+------+-----+---------+-------+| Field | Type    | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| c     | char(1) | YES  |     | NULL    |       || i     | int(11) | YES  |     | NULL    |       |+-------+---------+------+-----+---------+-------+2 rows in set (0.00 sec)Changing a Table Type:</code></pre><h1 id="修改数据表类型"><a href="#修改数据表类型" class="headerlink" title="修改数据表类型"></a>修改数据表类型</h1><p>可以使用 ALTER 命令及 TYPE 子句来完成。尝试以下实例，我们将表 tablename 的类型修改为 MYISAM ：</p><p>注意：查看数据表类型可以使用 SHOW TABLE STATUS 语句。</p><pre><code>mysql&gt; ALTER TABLE tablename ENGINE = MYISAM;mysql&gt;  SHOW TABLE STATUS LIKE &apos;tablename&apos;\G*************************** 1. row ****************           Name: tablename           Type: MyISAM     Row_format: Fixed           Rows: 0 Avg_row_length: 0    Data_length: 0Max_data_length: 25769803775   Index_length: 1024      Data_free: 0 Auto_increment: NULL    Create_time: 2007-06-03 08:04:36    Update_time: 2007-06-03 08:04:36     Check_time: NULL Create_options:        Comment:1 row in set (0.00 sec)</code></pre><h1 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h1><p>如果需要修改数据表的名称，可以在 ALTER TABLE 语句中使用 RENAME 子句来实现。</p><p>尝试以下实例将数据表 tablename 重命名为 alter_tbl：</p><pre><code>mysql&gt; ALTER TABLE tablename RENAME TO alter_tbl;</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="https://www.runoob.com/mysql/mysql-alter.html" target="_blank" rel="noopener">https://www.runoob.com/mysql/mysql-alter.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用ALTER命令修改数据表名或者修改数据表字段&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Git学习笔记I</title>
    <link href="http://yoursite.com/2019/09/04/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0I/"/>
    <id>http://yoursite.com/2019/09/04/Git学习笔记I/</id>
    <published>2019-09-04T09:08:12.000Z</published>
    <updated>2019-09-05T06:51:17.117Z</updated>
    
    <content type="html"><![CDATA[<p>Git切换新分支，git fetch与git pull的区别，及常用命令集锦</p><a id="more"></a><h1 id="查看本地已有的分支"><a href="#查看本地已有的分支" class="headerlink" title="查看本地已有的分支"></a>查看本地已有的分支</h1><pre><code>git branch</code></pre><h1 id="本地建立新分支并推送到远程仓库"><a href="#本地建立新分支并推送到远程仓库" class="headerlink" title="本地建立新分支并推送到远程仓库"></a>本地建立新分支并推送到远程仓库</h1><h2 id="创建本地分支"><a href="#创建本地分支" class="headerlink" title="创建本地分支"></a>创建本地分支</h2><p>  git checkout -b 新分支名字</p><p>执行该指令后，会在本地创建一个新分支，该分支是从当前分支上建出的，所以所有文件内容都和当前分支一模一样，这是正常的。创建成功后，将自动切换至新分支上。</p><h2 id="推送本地分支到远程仓库"><a href="#推送本地分支到远程仓库" class="headerlink" title="推送本地分支到远程仓库"></a>推送本地分支到远程仓库</h2><p>  git push –sest-upstream origin 分支名字</p><h1 id="将远程git仓库里的指定分支拉取到本地（本地不存在的分支）"><a href="#将远程git仓库里的指定分支拉取到本地（本地不存在的分支）" class="headerlink" title="将远程git仓库里的指定分支拉取到本地（本地不存在的分支）"></a>将远程git仓库里的指定分支拉取到本地（本地不存在的分支）</h1><p>首先更新远程分支列表</p><pre><code>git remote update origin --prune或者git remote update origin -p</code></pre><p>然后将指定分支拉取到本地</p><pre><code>git checkout -b 本地分支名 origin/远程分支名</code></pre><p>这个将会自动创建一个新的本地分支，并与指定的远程分支关联起来。</p><p>如果出现提示：</p><pre><code>fatal: Cannot update paths and switch to branch &apos;dev2&apos; at the same time.Did you intend to checkout &apos;origin/dev2&apos; which can not be resolved as commit?</code></pre><p>表示拉取不成功。我们需要先执行</p><pre><code>git fetch</code></pre><p>然后再执行</p><pre><code>git checkout -b 本地分支名 origin/远程分支名</code></pre><p>即可。</p><h1 id="git-fetch与git-pull的区别"><a href="#git-fetch与git-pull的区别" class="headerlink" title="git fetch与git pull的区别"></a>git fetch与git pull的区别</h1><p>FETCH_HEAD： 是一个版本链接，记录在本地的一个文件中，指向着目前已经从远程仓库取下来的分支的末端版本。</p><p>commit-id：在每次本地工作完成后，都会做一个git commit 操作来保存当前工作到本地的repo， 此时会产生一个commit-id，这是一个能唯一标识一个版本的序列号。 在使用git push后，这个序列号还会同步到远程仓库。</p><p>有了以上的概念再来说说git fetch</p><p>git fetch：这将更新git remote 中所有的远程仓库所包含分支的最新commit-id, 将其记录到.git/FETCH_HEAD文件中</p><p>git fetch更新远程仓库的方式如下：</p><pre><code>git fetch origin master:tmp//在本地新建一个temp分支，并将远程origin仓库的master分支代码下载到本地temp分支git diff tmp//来比较本地代码与刚刚从远程下载下来的代码的区别git merge tmp//合并temp分支到本地的master分支git branch -d temp//如果不想保留temp分支 可以用这步删除</code></pre><h2 id="如果直接使用git-fetch，则步骤如下："><a href="#如果直接使用git-fetch，则步骤如下：" class="headerlink" title="如果直接使用git fetch，则步骤如下："></a>如果直接使用git fetch，则步骤如下：</h2><p>创建并更新本地远程分支。即创建并更新origin/xxx 分支，拉取代码到origin/xxx分支上。</p><p>在FETCH_HEAD中设定当前分支-origin/当前分支对应，如直接到时候git merge就可以将origin/abc合并到abc分支上。</p><h2 id="git-fetch-origin"><a href="#git-fetch-origin" class="headerlink" title="git fetch origin"></a>git fetch origin</h2><p>只是手动指定了要fetch的remote。在不指定分支时通常默认为master</p><h2 id="git-fetch-origin-dev"><a href="#git-fetch-origin-dev" class="headerlink" title="git fetch origin dev"></a>git fetch origin dev</h2><p>指定远程remote和FETCH_HEAD，并且只拉取该分支的提交。</p><h2 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull :"></a>git pull :</h2><p>首先，基于本地的FETCH_HEAD记录，比对本地的FETCH_HEAD记录与远程仓库的版本号，然后git fetch 获得当前指向的远程分支的后续版本的数据，然后再利用git merge将其与本地的当前分支合并。所以可以认为git pull是git fetch和git merge两个步骤的结合。</p><p>git pull的用法如下：</p><pre><code>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;//取回远程主机某个分支的更新，再与本地的指定分支合并。</code></pre><p>因此，与git pull相比git fetch相当于是从远程获取最新版本到本地，但不会自动merge。如果需要有选择的合并git fetch是更好的选择。效果相同时git pull将更为快捷。</p><h1 id="git-命令集锦"><a href="#git-命令集锦" class="headerlink" title="git 命令集锦"></a>git 命令集锦</h1><h2 id="git-设定"><a href="#git-设定" class="headerlink" title="git 设定"></a>git 设定</h2><pre><code>git config --global user.namegit config --global user.emailgit config --global color.ui truegit config --global alias. &lt;命令名称&gt;比如：git config —global alias.st status</code></pre><h2 id="git常用"><a href="#git常用" class="headerlink" title="git常用"></a>git常用</h2><pre><code>git init其反操作：rm -rf .gitgit clonegit statusgit status -s：仅显示已修改的文档名称git status -s -b：显示分支名称git diffgit add .git add -Agit commit -m &quot;message&quot;git commit --amend &quot;message&quot; 修改上一次 commit 內容git pushgit pullgit loggit log --graph 查看分支合并图git log --pretty=onelinegit reflog 查看命令历史rm 删除本地filegit rm 删除版本库file</code></pre><h2 id="git分支操作"><a href="#git分支操作" class="headerlink" title="git分支操作"></a>git分支操作</h2><pre><code>git branchgit branch -r 显示远端分支git branch -a 显示所有分支git branch &lt;分支名称&gt; 建立分支git branch -m &lt;旧分支名称&gt; &lt;新分支名称&gt; 修改分支名字git branch -d &lt;分支名称&gt;git checkoutgit checkout -b &lt;分支名称&gt;：表示 建立並切換 至该分支git merge &lt;分支名称&gt;git reset --merge 放弃merge</code></pre><h2 id="远端操作"><a href="#远端操作" class="headerlink" title="远端操作"></a>远端操作</h2><pre><code>git remote 显示远端数据库列表git remote add &lt;名称&gt; 添加远端数据库git checkout &lt;本地分支名称&gt; origin/&lt;远端分支名称&gt;</code></pre><h2 id="取远端分支建立本地端分支"><a href="#取远端分支建立本地端分支" class="headerlink" title="取远端分支建立本地端分支"></a>取远端分支建立本地端分支</h2><pre><code>git push &lt;分支名称&gt;</code></pre><h2 id="在远端建立分支-上传-或更新-內容至远端分支"><a href="#在远端建立分支-上传-或更新-內容至远端分支" class="headerlink" title="在远端建立分支 / 上传(或更新)內容至远端分支"></a>在远端建立分支 / 上传(或更新)內容至远端分支</h2><pre><code>git fetch &lt;分支名称&gt;</code></pre><h2 id="查看远端数据库分支的修改內容"><a href="#查看远端数据库分支的修改內容" class="headerlink" title="查看远端数据库分支的修改內容"></a>查看远端数据库分支的修改內容</h2><pre><code>git pull &lt;分支名称&gt; 合并(或更新)远端至本地端分支注：pull = fetch + mergegit push :&lt;分支名称&gt; 刪除远端分支git remote set-url &lt;名称&gt; &lt;新连接位址&gt;</code></pre><h2 id="修改远端数据库地址"><a href="#修改远端数据库地址" class="headerlink" title="修改远端数据库地址"></a>修改远端数据库地址</h2><pre><code>git remote rename &lt;旧名称&gt; &lt;新名称&gt;</code></pre><h2 id="修改远端数据库名称"><a href="#修改远端数据库名称" class="headerlink" title="修改远端数据库名称"></a>修改远端数据库名称</h2><h2 id="暂存"><a href="#暂存" class="headerlink" title="暂存"></a>暂存</h2><pre><code>git stash 暂存现在的修改狀況git stash list 列出暂存清单git stash apply 取出上一次暂存git stash pop 取出上一次暂存(该暂存会被移除)git stash@{id} 指定特定暂存git stash clear 清空所有暂存</code></pre><h2 id="操作提交记录"><a href="#操作提交记录" class="headerlink" title="操作提交记录"></a>操作提交记录</h2><pre><code>git commit --amend 修改上一次的commitgit reset HEAD 放弃该修改记录 (reset)git reset --soft HEAD^ 取消上一次 commit，並 保留 修改纪录git reset --hard HEAD^ 取消上一次 commit，並 刪除 修改纪录</code></pre><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】 <a href="https://blog.csdn.net/riddle1981/article/details/74938111" target="_blank" rel="noopener">https://blog.csdn.net/riddle1981/article/details/74938111</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git切换新分支，git fetch与git pull的区别，及常用命令集锦&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>数据库学习笔记IV</title>
    <link href="http://yoursite.com/2019/09/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0IV/"/>
    <id>http://yoursite.com/2019/09/04/数据库学习笔记IV/</id>
    <published>2019-09-04T02:00:12.000Z</published>
    <updated>2019-09-16T03:32:29.509Z</updated>
    
    <content type="html"><![CDATA[<p>SQL插入，多表查询</p><a id="more"></a><h1 id="权限配置"><a href="#权限配置" class="headerlink" title="权限配置"></a>权限配置</h1><p>在reporting数据库中找到auth_users 表，代表的是用户信息，auth_roles代表的是不同的角色信息</p><p>auth_users_roles_rela代表的是不同用户所具有的角色，auth_resources代表资源，其中要添加之前写的inner和core里controller所具有的方法，type为FUNCTION，url就是执行的url，例如/notes/updateNote，level设置为1<br>auth_role_resources_rela是不同角色所具有的资源信息，<br>现在要使用SQL语句添加新的资源，将用户yang.kai</p><h1 id="INSERT语句"><a href="#INSERT语句" class="headerlink" title="INSERT语句"></a>INSERT语句</h1><p>基本语法是：</p><pre><code>INSERT INTO &lt;表名&gt; (字段1, 字段2, ...) VALUES (值1, 值2, ...);</code></pre><p>例如：<br>    INSERT INTO auth_resources<br>    (resource_name, external_id,resource_type,application_name,resource_url,status,parent_id,level,sort)<br>    VALUES<br>    (‘根据ID删除笔记’,-1,’FUNCTION’,’reporting’,’/notes/deleteNote’,’ACTIVE’,0,1,0)</p><p>还可以同时添加多条数据：</p><pre><code>INSERT INTO &lt;表名&gt; (字段1, 字段2, ...)VALUES (值1, 值2, ...),(值3, 值4, ...),(值5, 值6, ...);</code></pre><p>例如在auth_role_resources_rela中添加不同角色所拥有的资源信息：<br>    INSERT INTO auth_role_resources_rela<br>    (role_id,resource_id,status,created,updated)<br>    VALUES<br>    (3,1,’ACTIVE’,NOW(),NOW()),<br>    (3,2,’ACTIVE’,NOW(),NOW()),<br>    (3,3,’ACTIVE’,NOW(),NOW()),<br>    (3,4,’ACTIVE’,NOW(),NOW()),<br>    (3,6,’ACTIVE’,NOW(),NOW()),<br>    (3,9,’ACTIVE’,NOW(),NOW()),<br>    (3,10,’ACTIVE’,NOW(),NOW()),<br>    (3,11,’ACTIVE’,NOW(),NOW()),<br>    (3,12,’ACTIVE’,NOW(),NOW()),<br>    (3,23,’ACTIVE’,NOW(),NOW()),<br>    (3,24,’ACTIVE’,NOW(),NOW()),<br>    (3,25,’ACTIVE’,NOW(),NOW()),<br>    (3,26,’ACTIVE’,NOW(),NOW()),<br>    (3,27,’ACTIVE’,NOW(),NOW()),<br>    (3,28,’ACTIVE’,NOW(),NOW()),<br>    (3,29,’ACTIVE’,NOW(),NOW()),<br>    (3,30,’ACTIVE’,NOW(),NOW()),<br>    (3,31,’ACTIVE’,NOW(),NOW()),<br>    (3,32,’ACTIVE’,NOW(),NOW()),<br>    (3,33,’ACTIVE’,NOW(),NOW()),<br>    (3,34,’ACTIVE’,NOW(),NOW()),<br>    (3,37,’ACTIVE’,NOW(),NOW()),<br>    (3,38,’ACTIVE’,NOW(),NOW()),<br>    (3,39,’ACTIVE’,NOW(),NOW()),<br>    (3,40,’ACTIVE’,NOW(),NOW()),<br>    (3,41,’ACTIVE’,NOW(),NOW()),<br>    (3,42,’ACTIVE’,NOW(),NOW()),<br>    (3,43,’ACTIVE’,NOW(),NOW()),<br>    (3,44,’ACTIVE’,NOW(),NOW()),<br>    (3,45,’ACTIVE’,NOW(),NOW()),<br>    (3,46,’ACTIVE’,NOW(),NOW()),<br>    (3,47,’ACTIVE’,NOW(),NOW()),<br>    (3,48,’ACTIVE’,NOW(),NOW()),<br>    (3,49,’ACTIVE’,NOW(),NOW()),<br>    (3,50,’ACTIVE’,NOW(),NOW()),<br>    (3,51,’ACTIVE’,NOW(),NOW()),<br>    (3,52,’ACTIVE’,NOW(),NOW()),<br>    (3,53,’ACTIVE’,NOW(),NOW()),<br>    (3,54,’ACTIVE’,NOW(),NOW());</p><h1 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h1><p>auth_users表，代表的是用户信息，auth_roles代表的是不同的角色信息，</p><p>auth_users_roles_rela代表的是不同用户所具有的角色，</p><p>现在要根据用户账号查询某个用户所具有的所有角色id</p><pre><code>SELECT role_idFROM auth_usersINNER JOIN auth_user_roles_relaON auth_users.id=auth_user_roles_rela.user_idWHERE auth_users.account=&apos;kai.yang&apos;</code></pre><p>根据角色id到auth_role_resources_rela中找到该角色所拥有的资源resource_id<br>    SELECT resource_id<br>    FROM auth_role_resources_rela<br>    WHERE role_id=(<br>      SELECT role_id<br>      FROM auth_users<br>      INNER JOIN auth_user_roles_rela<br>      ON auth_users.id=auth_user_roles_rela.user_id<br>      WHERE auth_users.account=’kai.yang’<br>      )</p><p>根据角色id连接查询auth_resources中的资源名称</p><pre><code>SELECT auth_resources.id,resource_name,resource_type,resource_urlFROM auth_resourcesINNER JOIN auth_role_resources_relaON auth_resources.id=auth_role_resources_rela.resource_idWHERE auth_role_resources_rela.role_id=(  SELECT role_id  FROM auth_users  INNER JOIN auth_user_roles_rela  ON auth_users.id=auth_user_roles_rela.user_id  WHERE auth_users.account=&apos;kai.yang&apos;  )</code></pre><h2 id="注意INNER-JOIN查询的写法"><a href="#注意INNER-JOIN查询的写法" class="headerlink" title="注意INNER JOIN查询的写法"></a>注意INNER JOIN查询的写法</h2><pre><code>先确定主表，仍然使用FROM &lt;表1&gt;的语法；再确定需要连接的表，使用INNER JOIN &lt;表2&gt;的语法；然后确定连接条件，使用ON &lt;条件...&gt;，这里的条件是auth_users.id=auth_user_roles_rela.user_id，表示auth_users表的id列与auth_user_roles_rela表的user_id列相同的行需要连接；可选：加上WHERE子句、ORDER BY等子句。使用别名不是必须的，但可以更好地简化查询语句。</code></pre><h2 id="内连接和外连接的区别："><a href="#内连接和外连接的区别：" class="headerlink" title="内连接和外连接的区别："></a>内连接和外连接的区别：</h2><p>假设查询语句是：</p><pre><code>SELECT ... FROM tableA ??? JOIN tableB ON tableA.column1 = tableB.column2;</code></pre><p>我们把tableA看作左表，把tableB看成右表，那么</p><p><strong><em>INNER JOIN是选出两张表都存在的记录</em></strong></p><p><strong><em>LEFT OUTER JOIN是选出左表存在的记录</em></strong></p><p><strong><em>RIGHT OUTER JOIN是选出右表存在的记录</em></strong></p><p><strong><em>FULL OUTER JOIN则是选出左右表都存在的记录</em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SQL插入，多表查询&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot学习笔记X</title>
    <link href="http://yoursite.com/2019/08/28/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0X/"/>
    <id>http://yoursite.com/2019/08/28/SpringBoot学习笔记X/</id>
    <published>2019-08-28T09:18:12.000Z</published>
    <updated>2019-09-17T03:48:49.941Z</updated>
    
    <content type="html"><![CDATA[<p>SpringBoot系统学习。</p><a id="more"></a><p>邮件网页版申请会议室，新建-》会议请求</p><h1 id="写tc文件"><a href="#写tc文件" class="headerlink" title="写tc文件"></a>写tc文件</h1><p><a href="http://jira.yxapp.in/projects/STD/summary" target="_blank" rel="noopener">http://jira.yxapp.in/projects/STD/summary</a><br>上面的代号：STD-4545 report-tool项目重构<br>用户使用的查询网址：<br><a href="http://std-report-fe.laincloud.xyz/#/reportool/notes" target="_blank" rel="noopener">http://std-report-fe.laincloud.xyz/#/reportool/notes</a><br>要有用户名，有地址，把定时模块和笔记模块写上去，将该网址中的操作进行截图然后介绍如何使用</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p><a href="http://std-report-fe.laincloud.xyz/#/reportool/notes" target="_blank" rel="noopener">http://std-report-fe.laincloud.xyz/#/reportool/notes</a><br>登陆时失败，去lain中的日志中去找登陆失败的原因<br>cn.creditease.bdp.std.authorization.client.token</p><h2 id="同步定时"><a href="#同步定时" class="headerlink" title="同步定时"></a>同步定时</h2><p>线上查询网址：</p><p><a href="http://std-report-tool.yxapp.in/tool" target="_blank" rel="noopener">http://std-report-tool.yxapp.in/tool</a></p><p>查询列表将定时同步到kael-query的tbl_jobs表中,先将所有定时任务status都置为disable状态，然后第二次时将需要同步都都打开</p><pre><code>SELECT * from shangtongdai_rpt.rpt_sql_query_task</code></pre><h1 id="mysql-scheduler"><a href="#mysql-scheduler" class="headerlink" title="mysql-scheduler"></a>mysql-scheduler</h1><p>四个项目：<br>mysql-scheduler 计算进件信息的逻辑代码<br>user-referral 计算进件信息的逻辑代码<br>std-report 查询进件<br>std-query</p><p>如果字段有问题例如<a href="http://std-report.yxapp.in/bdStat页面中某客户的“能否进件”字段出现错误，" target="_blank" rel="noopener">http://std-report.yxapp.in/bdStat页面中某客户的“能否进件”字段出现错误，</a></p><p>先在Chrome中F12（检查）-》Network-&gt;Doc或All查看，执行页面中的查询选项可以看到Console中出现相应的请求，然后在请求中的data中找到相应字段对应的字段名字，shouldSuijie:”是”。<br>再在All-&gt;transports-&gt;Headers中找到Request URL: <a href="http://std-report.yxapp.in/internal/bd/transports" target="_blank" rel="noopener">http://std-report.yxapp.in/internal/bd/transports</a><br>在std-report中的conf/routes中找到与URL对应的接口，如果查不到相应定时就去user-referral里面去查</p><pre><code>POST        /internal/bd/transports                    controllers.TransportController.allTransports</code></pre><p>如果需要寻找更新逻辑则<br>去mysql-scheduler或者std-report全局搜字段shouldSuijie或suijie或should_suijie，因为在不同系统中同一个字段可能有不同字段名字，如果查不到相应定时就去user-referral里面去查,</p><p>例如查找更新信息则查到updateSuijieInfoById，再找到使用其的updateByLoans等三个接口，再找到使用其的方法，最后查到updateSuijieInfo接口</p><pre><code>GET         /updateSuijieInfo                       controllers.HomeController.updateSuijieInfo</code></pre><p>再发送带有对应参数的GET请求来更新用户信息，逻辑修改到相应的底层代码去改。</p><p>mysql-scheduler:<br>按sql和程序来更新字段，配置文件yxapp.in.conf<br>routes的找到对应字段的请求</p><p>shangtongdai_rpt.application_infos是mysql-scheduler里面跑出来的进件信息</p><p>项目主要使用shangtongdai_rpt数据库中的表</p><p>在<a href="http://std-report-tool.yxapp.in/tool查询工具中查询对应用户的身份证号或者信息" target="_blank" rel="noopener">http://std-report-tool.yxapp.in/tool查询工具中查询对应用户的身份证号或者信息</a></p><pre><code>select * from shangtongdai.user_authentications where user_name=&apos;李侠&apos;select * from shangtongdai.users where id=540721</code></pre><p>举个例子：姓名为田伟的用户需要查询</p><pre><code>select *from shangtongdai.user_authenticationswhere user_name=&apos;田伟&apos;</code></pre><p>查询结果：</p><pre><code>id    user_id    user_name    identification    card_number    source_type    addition_loan    is_deleted    deleted_at    created    updated4546    526765    田伟    610422197407190017    6228450226018907664    WEB    0    0    null    2018-10-26 12:04:20.0    2018-10-26 12:04:20.08506    146069    田伟    51013219830125661X    6222024402055205128    WEB    1    0    null    2018-12-15 20:07:20.0    2019-08-30 00:23:45.012195    475021    田伟    522730198601080314    6214835102106232    WEB    1    0    null    2019-01-21 13:03:45.0    2019-08-30 00:33:22.0</code></pre><p>多个重名，根据user_id 查询到编号475021的用户是我们要找的田伟</p><pre><code>select *from shangtongdai.userswhere id=475021id    email    email_confirmed    name    mobile    mobile_account    has_set_pwd    code    tracking    hashed_password    salt    signup_ip    created    updated475021    null    1    null    150****1468    150****1468    1    QDCYL674    null    9e286c2c3f2954070f0fd12067f7e7d4b351abc5    1928a1d1be554c8a9fb00faff215c881    null    2018-01-26 11:49:21.0    2018-08-15 10:44:42.0</code></pre><p>查询该用户的进件信息<br>    select id,transport_id,user_id,identification,should_suijie<br>    from shangtongdai_rpt.application_infos<br>    where identification =522730198601080314 and user_id=475021</p><p>查询结果</p><pre><code>id    transport_id    user_id    identification    should_suijie309722805    250658    475021    522730198601080314    0344227885    272763    475021    522730198601080314    0358453685    282782    475021    522730198601080314    0377322417    289761    475021    522730198601080314    0</code></pre><p>查询记录中should_suijie为NULL的条数</p><pre><code>select count(id)    from shangtongdai_rpt.application_infos    where should_suijie IS NULL</code></pre><p>查询对应的记录中有身份证信息的条数：</p><pre><code>select count(id)    from shangtongdai_rpt.application_infos    where should_suijie IS NULL and identification IS NOT NULL</code></pre><p>进件数据库生产环境在credit_audit,测试环境在creditreview</p><p>根据进件id在credit_audit.transports中查询should_suijie为NULL，身份证信息不为空的相应记录的更多信息</p><pre><code>select count(*)from shangtongdai_rpt.application_infosINNER JOIN credit_audit.transportsON shangtongdai_rpt.application_infos.transport_id=credit_audit.transports.idwhere should_suijie IS NULL and identification IS NOT NULL</code></pre><p>常用网址：<br>测试环境网址（暂时无权限）：</p><p><a href="http://std-report-old.laincloud.xyz/partner" target="_blank" rel="noopener">http://std-report-old.laincloud.xyz/partner</a></p><p>线上环境（scala）：</p><p><a href="http://std-report.yxapp.in/index" target="_blank" rel="noopener">http://std-report.yxapp.in/index</a></p><p>parnter界面：</p><p><a href="http://std-report.yxapp.in/partner" target="_blank" rel="noopener">http://std-report.yxapp.in/partner</a></p><p>运营界面：</p><p><a href="http://std-report.yxapp.in/stdTask" target="_blank" rel="noopener">http://std-report.yxapp.in/stdTask</a></p><p>bd界面：</p><p><a href="http://std-report.yxapp.in/bdStat" target="_blank" rel="noopener">http://std-report.yxapp.in/bdStat</a></p><p>新的report测试网址（java），对应项目std-query：</p><p><a href="http://std-report-fe.laincloud.xyz/#/" target="_blank" rel="noopener">http://std-report-fe.laincloud.xyz/#/</a><br>常见问题：数据不全</p><p>上午10：10前不要重启lain中的std-report-tool-pro<br>里面有重发接口</p><p>final_area,final_bd 今天更新昨天进件，本周更新上周进件，刷新code</p><p>定时卡住去查：</p><pre><code>SELECT *FROM shangtongdai_rpt.rpt_fetch_times ;</code></pre><p>里面有定时最后更新时间<br>如果查不到相应定时就去user-referral里面去查</p><h1 id="调试定时任务管理器TaskManager时要注意定时表达式满足条件时才会执行"><a href="#调试定时任务管理器TaskManager时要注意定时表达式满足条件时才会执行" class="headerlink" title="调试定时任务管理器TaskManager时要注意定时表达式满足条件时才会执行"></a>调试定时任务管理器TaskManager时要注意定时表达式满足条件时才会执行</h1><h1 id="使用lain在测试环境部署"><a href="#使用lain在测试环境部署" class="headerlink" title="使用lain在测试环境部署"></a>使用lain在测试环境部署</h1><p>登陆：<br><a href="http://kael-query-test.laincloud.xyz/auth/login/do?loginName=kai.yang&amp;password=123123" target="_blank" rel="noopener">http://kael-query-test.laincloud.xyz/auth/login/do?loginName=kai.yang&amp;password=123123</a><br>测试环境网址：<br><a href="http://console.laincloud.xyz/" target="_blank" rel="noopener">http://console.laincloud.xyz/</a><br>登陆后选择kael-query-test</p><p>先点击详情-》构建，然后在镜像选项中点击部署，进行项目的部署，<br>部署后选择SHELL，在/lain/logs/kael.log中查看日志</p><pre><code>tail -f</code></pre><h1 id="配置文件application-yml解读"><a href="#配置文件application-yml解读" class="headerlink" title="配置文件application.yml解读"></a>配置文件application.yml解读</h1><p>有必要解读一下SpringBoot项目中关于application.yml配置的一些问题：</p><p>首先看kael-starter中的pom.xml</p><pre><code>&lt;profiles&gt;    &lt;profile&gt;        &lt;id&gt;prod&lt;/id&gt;        &lt;properties&gt;            &lt;env&gt;prod&lt;/env&gt;        &lt;/properties&gt;    &lt;/profile&gt;    &lt;profile&gt;        &lt;id&gt;local&lt;/id&gt;        &lt;activation&gt;            &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;        &lt;/activation&gt;        &lt;properties&gt;            &lt;env&gt;local&lt;/env&gt;        &lt;/properties&gt;    &lt;/profile&gt;    &lt;profile&gt;        &lt;id&gt;staging&lt;/id&gt;        &lt;properties&gt;            &lt;env&gt;staging&lt;/env&gt;        &lt;/properties&gt;    &lt;/profile&gt;&lt;/profiles&gt;</code></pre><p>三个环境分别是生产环境，本地环境和测试环境，其中</p><pre><code>&lt;activation&gt;    &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;&lt;/activation&gt;  </code></pre><p>代表使用的是本地环境。</p><p>在这个pom.xml中还有：</p><pre><code>&lt;resources&gt;     &lt;resource&gt;         &lt;directory&gt;src/main/resources&lt;/directory&gt;         &lt;includes&gt;             &lt;include&gt;**/*.*&lt;/include&gt; &lt;!-- 此配置不可缺，否则mybatis的Mapper.xml将会丢失 --&gt;         &lt;/includes&gt;         &lt;filtering&gt;false&lt;/filtering&gt;     &lt;/resource&gt;     &lt;resource&gt;         &lt;directory&gt;src/main/resources.${env}&lt;/directory&gt;     &lt;/resource&gt; &lt;/resources&gt;</code></pre><p>在进行加载时首先加载resources文件夹中的application.yml<br>其中的内容是：</p><pre><code>spring:  profiles.active: env</code></pre><p>而在resources.local文件夹中的application-env.yml中</p><pre><code>application.mode: localspring:  zipkin:    base-url: http://std-zipkin.laincloud.xyz/  datasource:    url: jdbc:mysql://10.143.248.78:3306/kael_query?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;failOverReadOnly=false    driver-class-name: com.mysql.jdbc.Driver    username: root    password: 123456kael:  datasource:    druidDataSourceList:      #  前期通过yml配置，后期有需要可以迁移出去配置      - name: kael_query        type: com.alibaba.druid.pool.DruidDataSource        driver-class-name: com.mysql.jdbc.Driver        url: jdbc:mysql://10.143.248.78:3306/kael_query?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;failOverReadOnly=false        username: root        password: mojiti        #      filters: stat,wall,log4j,config        max-active: 20        initial-size: 10        max-wait: 1000        min-idle: 1        max-idle: 10        time-between-eviction-runs-millis: 60000        min-evictable-idle-time-millis: 300000        validation-query: select &apos;x&apos;        test-while-idle: true        test-on-borrow: false        test-on-return: false        pool-prepared-statements: true        max-open-prepared-statements: 50        max-pool-prepared-statement-per-connection-size: 20      - name: shangtongdai        type: com.alibaba.druid.pool.DruidDataSource        driver-class-name: com.mysql.jdbc.Driver        url: jdbc:mysql://10.143.248.78:3306/shangtongdai?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;failOverReadOnly=false        username: root        password: mojiti          #      filters: stat,wall,log4j,config        max-active: 20        initial-size: 10        max-wait: 1000        min-idle: 1        max-idle: 10        time-between-eviction-runs-millis: 60000        min-evictable-idle-time-millis: 300000        validation-query: select &apos;x&apos;        test-while-idle: true        test-on-borrow: false        test-on-return: false        pool-prepared-statements: true        max-open-prepared-statements: 50        max-pool-prepared-statement-per-connection-size: 20      #  前期通过yml配置，后期有需要可以迁移出去配置# Actuator 配置management.endpoints.web:  exposure.include: &quot;*&quot;  exposure.exclude: env,beanseureka:  client:    register-with-eureka: true    fetch-registry: true    serviceUrl:      defaultZone: http://std-eureka.laincloud.xyz/eureka/swagger:  enable: true</code></pre><p>其中指明了application.mode: local所以在加载的时候也要加载它，而</p><pre><code>spring:  profiles.active: env</code></pre><p>则说明在加载时读取的application-env.yml文件名中可以加上-env</p><h1 id="多条件模糊分页查询遇到的问题"><a href="#多条件模糊分页查询遇到的问题" class="headerlink" title="多条件模糊分页查询遇到的问题"></a>多条件模糊分页查询遇到的问题</h1><p>当一些查询条件为NULL或空字符串“”</p><pre><code>/**  * 分页查询  * 分页参数pageNo(页码） ，pageSize(每页查询数目）  */ @Override public PageInfo&lt;TblJobsEntity&gt; queryTblJobByPage(int pageNo, int pageSize, TblJobsEntity tblJobsEntity,     Date createTimeBegin, Date createTimeEnd, Date updateTimeBegin, Date updateTimeEnd) {     //查询     String tag = tblJobsEntity.getTag();     String receiver = tblJobsEntity.getReceiver();     PageHelper.startPage(pageNo, pageSize);     TblJobsEntityExample tblJobsEntityExample = new TblJobsEntityExample();     TblJobsEntityExample.Criteria criteria = tblJobsEntityExample.createCriteria();     //使用StringUtil.isEmpty()而不是==来判断，因为==判断的是地址     if (!StringUtils.isEmpty(tag)) {         //模糊匹配的通配符         tag = &quot;%&quot; + tag + &quot;%&quot;;         criteria.andTagLike(tag);     }     //如果存在该属性为NULL或空字符串&quot;&quot;的时候，需要进行判断，之前出现的错误是只判断该属性是否为NULL而未判断是否为&quot;&quot;空字符串     if (!StringUtils.isEmpty(receiver)) {         receiver = &quot;%&quot; + receiver + &quot;%&quot;;         criteria.andReceiverLike(receiver);     }     if (createTimeBegin != null &amp;&amp; createTimeEnd != null) {         criteria.andCreateTimeBetween(createTimeBegin, createTimeEnd);     }     if (updateTimeBegin != null &amp;&amp; updateTimeEnd != null) {         criteria.andUpdateTimeBetween(updateTimeBegin, updateTimeEnd);     }     List&lt;TblJobsEntity&gt; tblJobsEntityList = tblJobsEntityMapper.selectByExample(tblJobsEntityExample);     //用PageInfo对结果进行包装     PageInfo&lt;TblJobsEntity&gt; pageInfo = new PageInfo&lt;TblJobsEntity&gt;(tblJobsEntityList);     return pageInfo; }</code></pre><h1 id="通过日志调试定时任务执行情况"><a href="#通过日志调试定时任务执行情况" class="headerlink" title="通过日志调试定时任务执行情况"></a>通过日志调试定时任务执行情况</h1><p>在resources.local中添加logback.xml文件，改动 <logger name="cn.kael.query.inner.dao" level="DEBUG">中的level</logger></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt;    &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;        &lt;encoder&gt;            &lt;pattern&gt;%d{yyyy.MM.dd HH:mm:ss.SSS}|%X{TRACE_ID}|%thread|%p|%c:%line|%m%n&lt;/pattern&gt;        &lt;/encoder&gt;    &lt;/appender&gt;    &lt;root level=&quot;INFO&quot;&gt;        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;    &lt;/root&gt;    &lt;!--&lt;logger name=&quot;org.springframework.amqp&quot; level=&quot;info&quot; additivity=&quot;false&quot;&gt;--&gt;    &lt;!--&lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;--&gt;    &lt;!--&lt;/logger&gt;--&gt;    &lt;!--&lt;logger name=&quot;org.mybatis&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;--&gt;    &lt;!--&lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;--&gt;    &lt;!--&lt;/logger&gt;--&gt;    &lt;!--&lt;logger name=&quot;org.apache.zookeeper&quot; level=&quot;ERROR&quot; additivity=&quot;false&quot;&gt;--&gt;    &lt;!--&lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;--&gt;    &lt;!--&lt;/logger&gt;--&gt;    &lt;!--&lt;logger name=&quot;java.sql.Connection&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;--&gt;    &lt;!--&lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;--&gt;    &lt;!--&lt;/logger&gt;--&gt;    &lt;!--&lt;logger name=&quot;java.sql.Statement&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;--&gt;    &lt;!--&lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;--&gt;    &lt;!--&lt;/logger&gt;--&gt;    &lt;!--&lt;logger name=&quot;java.sql.PreparedStatement&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;--&gt;    &lt;!--&lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;--&gt;    &lt;!--&lt;/logger&gt;--&gt;    &lt;logger name=&quot;org.springframework.data.redis&quot; level=&quot;INFO&quot; additivity=&quot;false&quot;&gt;        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;    &lt;/logger&gt;    &lt;logger name=&quot;redis.clients&quot; level=&quot;INFO&quot; additivity=&quot;false&quot;&gt;        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;    &lt;/logger&gt;    &lt;logger name=&quot;cn.kael.query.inner.dao&quot; level=&quot;DEBUG&quot; /&gt;&lt;/configuration&gt;</code></pre><h1 id="Mybatis中自动生成主键"><a href="#Mybatis中自动生成主键" class="headerlink" title="Mybatis中自动生成主键"></a>Mybatis中自动生成主键</h1><h2 id="遇到的问题-1"><a href="#遇到的问题-1" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>在使用例如</p><pre><code>tblJobsEntityMapper.insertSelective(tblJobsEntity);</code></pre><p>进行数据插入时，由于数据库的ID为自动插入：</p><pre><code>`id` bigint(20) NOT NULL AUTO_INCREMENT,</code></pre><p>所以RequestDTO里往往没有传入id，这时会导致后面的在Quartz中添加定时任务时获取到的id为null</p><pre><code>//在Quartz中添加定时任务taskManager.addJob(tblJobsEntity.getId(), tblJobsEntity.getCron(), tblJobsEntity.getMemo());</code></pre><h2 id="解决的方法"><a href="#解决的方法" class="headerlink" title="解决的方法"></a>解决的方法</h2><p>可以在数据库中查询再获取id，但为了减小数据库查询的压力，所以要使用Mybatis的自带配置来进行自动插入id，</p><p>在TblJobsEntityMapper.xml中添加配置，在INSERT语句中，我们为可以自动生成（auto-generated）主键的列 id 插入值。</p><p>我们可以使用useGeneratedKeys和keyProperty属性让数据库生成auto_increment列的值，并将生成的值设置到其中一个输入对象属性内，如下所示：     </p><pre><code>&lt;/insert&gt;  &lt;insert id=&quot;insertSelective&quot; parameterType=&quot;cn.kael.query.inner.entity.TblJobsEntity&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;  ......&lt;/insert&gt;</code></pre><p> 这里id列值将会被数据库自动生成(如mysql)，并且生成的值会被设置到tblJobsEntity对象的id属性上</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://blog.csdn.net/suwu150/article/details/52895855" target="_blank" rel="noopener">https://blog.csdn.net/suwu150/article/details/52895855</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SpringBoot系统学习。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年8月" scheme="http://yoursite.com/categories/2019%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="SpringBoot，Java" scheme="http://yoursite.com/tags/SpringBoot%EF%BC%8CJava/"/>
    
  </entry>
  
  <entry>
    <title>数据库学习笔记III</title>
    <link href="http://yoursite.com/2019/08/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0III/"/>
    <id>http://yoursite.com/2019/08/27/数据库学习笔记III/</id>
    <published>2019-08-27T03:52:12.000Z</published>
    <updated>2019-08-27T07:24:35.636Z</updated>
    
    <content type="html"><![CDATA[<p>重新温习SQL语句中的模糊匹配</p><a id="more"></a><h1 id="模糊匹配"><a href="#模糊匹配" class="headerlink" title="模糊匹配"></a>模糊匹配</h1><p>在进行数据库查询的时候，有完整查询和模糊查询之分。<br>一般模糊查询语句如下：</p><p>  SELECT 字段 FROM 表 WHERE 某字段 Like 条件<br>其中的条件，SQL有四种匹配模式：</p><h2 id=""><a href="#" class="headerlink" title="%"></a>%</h2><p>表示任意0个或多个字符，可匹配任意类型和长度的字符，有些情况下若是中文，请使用两个百分号（%%）表示。</p><p>例如</p><pre><code>SELECT * FROM user WHERE name LIKE &apos;%一%&apos;</code></pre><p>将会把name为“一野”，”李一野”，“一休和尚”等等有”一”的记录都找出来。</p><p>另外如果需要找出name中既有“一”又有”野”的记录，请使用and条件</p><pre><code>SELECT *   FROM user  WHERE name  LIKE &apos;%一%&apos;  AND  name LIKE &apos;%野%&apos;</code></pre><p>而如果使用</p><pre><code>SELECT *  FROM user  WHERE name  LIKE &apos;%一%野%&apos;</code></pre><p>虽然能够搜索出“李一野”，但不能搜索出符合条件的”野一李”。</p><h2 id="-1"><a href="#-1" class="headerlink" title="_"></a>_</h2><p>表示任意单个字符，匹配单个任意字符，它常用来限制表达式的字符长度语句：</p><p>比如</p><pre><code>SELECT *  FROM user  WHERE name  LIKE &apos;_三_&apos;</code></pre><p>只能找出“唐三藏”这样name为三个字且中间一个字是”三”的；</p><p>例如</p><pre><code>SELECT *  FROM user  WHERE name  LIKE &apos;三__&apos;</code></pre><p>只能找出“三国杀”这样name为三个字且第一字为”三”的；</p><h2 id="-2"><a href="#-2" class="headerlink" title="[]"></a>[]</h2><p>表示括号内所列字符中的一个（类似正则表达式）。制定一个字符、字符串或范围，要求所匹配对象为它们中的人一个。</p><p>比如</p><pre><code>SELECT *  FROM user  WHERE name  LIKE &apos;[张王李]三&apos;</code></pre><p>搜索出的是“张三”，“王三”，”李三”，而不是“张王李三”；</p><p>如果[]内有一系列字符（01234，abcd之类)，则可以简写为“0-4”、“a-d”</p><pre><code>SELECT *  FROM user  WHERE name  LIKE &apos;大[a-d]&apos;</code></pre><p>将搜索出“大a”、……、“大d”；</p><h2 id="-3"><a href="#-3" class="headerlink" title="[^]"></a>[^]</h2><p>表示不在括号所列之内的单个字符。其取值和[]相同，但它要求所匹配对象为指定字符以外的任一个字符。</p><p>比如</p><pre><code>SELECT *  FROM user  WHERE name  LIKE &apos;[^张王李]三&apos;</code></pre><p>将找出不姓“张”，“王”，”李”的“赵三”，”孙三”等。</p><pre><code>SELECT *  FROM user  WHERE name  LIKE &apos;大[^a-d]&apos;</code></pre><p>将排除“大a”到“大d”，搜索“大e”、”大f”、……</p><h2 id="查询内容包含通配符时"><a href="#查询内容包含通配符时" class="headerlink" title="查询内容包含通配符时"></a>查询内容包含通配符时</h2><p>由于通配符会使得我们查询特殊字符“%”、”_”、“[”的语句无法正常实现，而把特殊字符用“[]”括起来便可以正常查询。</p><h2 id="多条件模糊查询"><a href="#多条件模糊查询" class="headerlink" title="多条件模糊查询"></a>多条件模糊查询</h2><p>看上去我们可以使用AND连接进行多条件模糊查询</p><pre><code>SELECT * FROM user WHERE name LIKE &apos;%三%&apos; AND phone LIKE ‘%1234%’</code></pre><p>但在实际使用时会发现如果数据库的查询字段不是都有值的情况下无法搜索到，</p><p>例如某记录name为“三国杀” ，phone没有值也不是null，因为电话没有值素以经过and运算后结果为false，没有输出。显然数据库中的对应字段必须有值，否则会漏掉正确的输出结果。</p><p>正确的输入应该为name为“三国杀”，phone为null，这样经过and运算后结果为true，可以输出正确结果</p><p>如何解决数据库中查询字段没有值时的多条件模糊匹配在网上搜了一些解决方法但暂未找到比较易懂但方法，留待后面解决</p><h2 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h2><p>sql语句</p><pre><code>sql=“select * from user where name like ...”</code></pre><p>必须在一行内输入完，而不能用回车符分段，因为vbs多行被认为是多个语句，这是许多初写者常犯的错误。如果你想分多段写，可以用上面的方法在现有变量基础上逐步增加查询语句的各个组成部分并把它存在同一变量内实现。在封闭引号之前或者在打开引号之后你需要增加空格，这样才能保证字符串连接起来的时候没有把几个词凑到了一块。</p><p>最后注意以上查询的LIKE后要加单引号。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="https://www.cnblogs.com/GT_Andy/archive/2009/12/25/1921914.html" target="_blank" rel="noopener">https://www.cnblogs.com/GT_Andy/archive/2009/12/25/1921914.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重新温习SQL语句中的模糊匹配&lt;/p&gt;
    
    </summary>
    
      <category term="2019年8月" scheme="http://yoursite.com/categories/2019%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记IV</title>
    <link href="http://yoursite.com/2019/08/12/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0IV/"/>
    <id>http://yoursite.com/2019/08/12/Java学习笔记IV/</id>
    <published>2019-08-12T06:48:12.000Z</published>
    <updated>2019-08-13T06:12:56.686Z</updated>
    
    <content type="html"><![CDATA[<p>MapReduce思想学习,对Java8中对新特性stream，map和reduce进行学习，Stream API部分主要来自于IBM Developer官网，原文写的非常详尽清晰。</p><a id="more"></a><h1 id="MapReduce思想及Java中的实现"><a href="#MapReduce思想及Java中的实现" class="headerlink" title="MapReduce思想及Java中的实现"></a>MapReduce思想及Java中的实现</h1><p>MapReduce源于Google一篇论文，它充分借鉴了分而治之的思想，将一个数据处理过程拆分为主要的Map(映射)与Reduce(化简)两步。用户不懂分布式计算框架的内部运行机制，只要能用Map和Reduce的思想描述清楚要处理的问题，即编写map()和reduce( )函数，就能轻松地使问题的计算实现分布式，并在Hadoop上运行。MapReduce的编程具有以下特点。</p><h2 id="开发简单"><a href="#开发简单" class="headerlink" title="开发简单:"></a>开发简单:</h2><p>得益于MapReduce的编程模型，用户可以不用考虑进程间通信、套接字编程，无需非常高深的技巧，只需要实现一些非常简单的逻辑，其他的交由MapReduce计算框架去完成，大大简化了分布式程序的编写难度。</p><h2 id="可扩展性强"><a href="#可扩展性强" class="headerlink" title="可扩展性强:"></a>可扩展性强:</h2><p>同HDFS一样，当集群资源不能满足计算需求时，可以通过增加节点的方式达到线性扩展集群的目的。</p><h2 id="容错性强"><a href="#容错性强" class="headerlink" title="容错性强:"></a>容错性强:</h2><p>对于节点故障导致的作业失败，MapReduce计算框架会自动将作业安排到健康节点重新执行，直到任务完成，而这些，对于用户来说都是透明的。</p><h2 id="MapReduce的编程思想"><a href="#MapReduce的编程思想" class="headerlink" title="MapReduce的编程思想"></a>MapReduce的编程思想</h2><p>Map(映射)与Reduce(化简)来源于LISP和其他函数式编程语言中的古老的映射和化简操作，MapReduce操作数据的最小单位是一个键值对。用户在使用MapReduce编程模型的时候，第一步就需要将数据抽象为键值对的形式，接着<strong><em>map函数</em></strong> 会以键值对作为输入，经过map函数的处理，产生一系类新的键值对作为中间结果输出到本地。MapReduce计算框架会自动将这些中间结果数据按照键做聚合处理，并将键相同的数据分发给reduce函数处理(用户可以设置分发规则)。<strong><em>reduce函数</em></strong> 以键和对应的值的集合作为输入，经过reduce函数的处理后，产生了另外一系列键值对作为最终输出。</p><p>如果用表达式表示，其过程如下式所示 :</p><pre><code>{Keyl，Value1}~{Key2, List&lt;Value2&gt;}~{Key3, Value3}</code></pre><p>读者可能觉得上面的描述和表达式非常抽象，那么让我们先来看一个例子。有一篮苹果，一些是红苹果，一些是青苹果，每个苹果有一个唯一编号，要解决的问题是统计该篮苹果的数目、红苹果(深色)的个数和青苹果(浅色)的个数。</p><p><img src="assets/markdown-img-paste-20190806142009358.png" alt="https://img-blog.csdn.net/20170502224501777?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDgwMTQzOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p><p>  假设有A, B, C三个人，A获得第一排苹果，B获得第二排苹果，这时，A和B分别统计自己手上的苹果的个数，然后将结果告知C, C将A, B的结果做一次汇总，得到最后结果。对于这个过程，其实用到了MapReduce的思想。我们可以从下一幅图看出端倪。</p><p><img src="assets/markdown-img-paste-20190806142045676.png" alt="https://img-blog.csdn.net/20170502224831447?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDgwMTQzOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p><p>A的map函数的输入的格式为键值对appleId-count，比女fl “ 11-1”表示appleId为11的苹果个数为1，经过map函数的累和，即将所有appleId的count相加，输出为新的键值对AppleCount-6，此时B也进行同样的操作，由于A和B的map函数输出的键值对的键相同，都为“AppleCount”，所以MapReduce框架会将其都分发到C作为reduce函数的输入，并在reduce函数中完成对键相同的值的累和，并输出最后结果AppleCount-12。如果用表达式表示，即为:</p><pre><code>(appleId, count}一&gt;(AppleCount，List&lt;count&gt;}一&gt;{AppleCount，count}</code></pre><p>在这个例子中，就是用MapReduce的思想来完成苹果计数的问题，细心的读者可能发现，这个例子中reduce函数只执行了一次，是否可以执行多次呢，答案是肯定的，下面来看用MapReduce思想解决对红苹果和青苹果分别计数的问题。</p><p>假设有A, B. C, D四个人，A获得第一排苹果，B获得第二排苹果，A将手上的红苹果给C、青苹果给D、B将手上的红苹果给C、青苹果给D。C, D再统计各自手上的结果，得到最后结果，如下图所示。</p><p><img src="assets/markdown-img-paste-20190806142148349.png" alt="https://img-blog.csdn.net/20170502225302823?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDgwMTQzOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p><p>A的map函数的输入同上次一样，在map函数中，用color和appleId作为新的键值对重新输出，B也做同样的操作。而A, B的map函数的输出的键值对会因为不同的键被分别分发到C和D执行:reduce函数，而真正的计数是由reduce函数完成，并输出最后结果。这里:reduce函数一共执行了两次，第一次是处理键为Red的数据.第二次是处理键为Green的数据。如果用表达式表示，即为:</p><pre><code>{appleId, count}~{color, List&lt;appleId&gt;}~{color, count}</code></pre><p>要理解MapReduce的编程思想，其核心的一点就是将数据用键值对表示。在现实生活中，很多数据要么本身就为键值对的形式，要么可以用键值对这种方式来表示，例如电话号码和通话记录，文件名和文件存储的数据等，键值对并不是高端数据挖掘独有的数据模型，而是存在于我们身边非常普通的模型。</p><p>利用分而治之的思想，可以将很多复杂的数据分析问题转变为一系列MapReduce作业，利用Hadoop的提供MapReduce计算框架，实现分布式计算，这样就能对海量数据进行复杂的数据分析，这也是MapReduce的意义所在。</p><h1 id="Java8-中的Stream"><a href="#Java8-中的Stream" class="headerlink" title="Java8 中的Stream"></a>Java8 中的Stream</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。所以说，Java 8 中首次出现的 java.util.stream 是一个函数式语言+多核时代综合影响的产物。</p><h2 id="什么是聚合操作"><a href="#什么是聚合操作" class="headerlink" title="什么是聚合操作"></a>什么是聚合操作</h2><p>在传统的 J2EE 应用中，Java 代码经常不得不依赖于关系型数据库的聚合操作来完成诸如：</p><p>客户每月平均消费金额</p><p>最昂贵的在售商品</p><p>本周完成的有效订单（排除了无效的）</p><p>取十个数据样本作为首页推荐</p><p>这类的操作。</p><p>但在当今这个数据大爆炸的时代，在数据来源多样化、数据海量化的今天，很多时候不得不脱离 RDBMS，或者以底层返回的数据为基础进行更上层的数据统计。而 Java 的集合 API 中，仅仅有极少量的辅助型方法，更多的时候是程序员需要用 Iterator 来遍历集合，完成相关的聚合应用逻辑。这是一种远不够高效、笨拙的方法。在 Java 7 中，如果要发现 type 为 grocery 的所有交易，然后返回以交易值降序排序好的交易 ID 集合，我们需要这样写：</p><h3 id="Java-7-的排序、取值实现"><a href="#Java-7-的排序、取值实现" class="headerlink" title="Java 7 的排序、取值实现"></a>Java 7 的排序、取值实现</h3><pre><code>List&lt;Transaction&gt; groceryTransactions = new Arraylist&lt;&gt;();for(Transaction t: transactions){ if(t.getType() == Transaction.GROCERY){ groceryTransactions.add(t); }}Collections.sort(groceryTransactions, new Comparator(){ public int compare(Transaction t1, Transaction t2){ return t2.getValue().compareTo(t1.getValue()); }});List&lt;Integer&gt; transactionIds = new ArrayList&lt;&gt;();for(Transaction t: groceryTransactions){ transactionsIds.add(t.getId());}</code></pre><p>而在 Java 8 使用 Stream，代码更加简洁易读；而且使用并发模式，程序执行速度更快。</p><h3 id="Java-8-的排序、取值实现"><a href="#Java-8-的排序、取值实现" class="headerlink" title="Java 8 的排序、取值实现"></a>Java 8 的排序、取值实现</h3><pre><code>List&lt;Integer&gt; transactionsIds = transactions.parallelStream(). filter(t -&gt; t.getType() == Transaction.GROCERY). sorted(comparing(Transaction::getValue).reversed()). map(Transaction::getId). collect(toList());</code></pre><h2 id="Stream总览"><a href="#Stream总览" class="headerlink" title="Stream总览"></a>Stream总览</h2><h3 id="什么是流"><a href="#什么是流" class="headerlink" title="什么是流"></a>什么是流</h3><p>Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。</p><p>Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。</p><p>而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。</p><p>而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。</p><p>Stream 的并行操作依赖于 Java7 中引入的 Fork/Join 框架（JSR166y）来拆分任务和加速处理过程。Java 的并行 API 演变历程基本如下：</p><p>1.0-1.4 中的 java.lang.Thread</p><p>5.0 中的 java.util.concurrent</p><p>6.0 中的 Phasers 等</p><p>7.0 中的 Fork/Join 框架</p><p>8.0 中的 Lambda</p><p>Stream 的另外一大特点是，数据源本身可以是无限的。</p><h3 id="流的构成"><a href="#流的构成" class="headerlink" title="流的构成"></a>流的构成</h3><p>当我们使用一个流的时候，通常包括三个基本步骤：</p><p>获取一个数据源（source）→ 数据转换→执行操作获取想要的结果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道，如下图所示。</p><p><img src="assets/markdown-img-paste-20190806173551210.png" alt="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/img001.png"></p><p>图1:流管道 (Stream Pipeline) 的构成</p><p>有多种方式生成 Stream Source：</p><h4 id="从-Collection-和数组"><a href="#从-Collection-和数组" class="headerlink" title="从 Collection 和数组"></a>从 Collection 和数组</h4><p>Collection.stream()</p><p>Collection.parallelStream()</p><p>Arrays.stream(T array) or Stream.of()</p><h4 id="从-BufferedReader"><a href="#从-BufferedReader" class="headerlink" title="从 BufferedReader"></a>从 BufferedReader</h4><p>java.io.BufferedReader.lines()</p><h4 id="静态工厂"><a href="#静态工厂" class="headerlink" title="静态工厂"></a>静态工厂</h4><p>java.util.stream.IntStream.range()<br>java.nio.file.Files.walk()</p><h4 id="自己构建"><a href="#自己构建" class="headerlink" title="自己构建"></a>自己构建</h4><p>java.util.Spliterator</p><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>Random.ints()</p><p>BitSet.stream()</p><p>Pattern.splitAsStream(java.lang.CharSequence)</p><p>JarFile.stream()</p><h3 id="流的操作类型分为两种："><a href="#流的操作类型分为两种：" class="headerlink" title="流的操作类型分为两种："></a>流的操作类型分为两种：</h3><h4 id="Intermediate："><a href="#Intermediate：" class="headerlink" title="Intermediate："></a>Intermediate：</h4><p>一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。</p><h4 id="Terminal："><a href="#Terminal：" class="headerlink" title="Terminal："></a>Terminal：</h4><p>一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。</p><p>在对于一个 Stream 进行多次转换操作 (Intermediate 操作)，每次都对 Stream 的每个元素进行转换，而且是执行多次，这样时间复杂度就是 N（转换次数）个 for 循环里把所有操作都做掉的总和吗？其实不是这样的，转换操作都是 lazy 的，多个转换操作只会在 Terminal 操作的时候融合起来，一次循环完成。</p><p>我们可以这样简单的理解，Stream 里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在 Terminal 操作的时候循环 Stream 对应的集合，然后对每个元素执行所有的函数。</p><p>还有一种操作被称为 <strong><em>short-circuiting</em></strong>。用以指：</p><p>对于一个 intermediate 操作，如果它接受的是一个无限大（infinite/unbounded）的 Stream，但返回一个有限的新 Stream。</p><p>对于一个 terminal 操作，如果它接受的是一个无限大的 Stream，但能在有限的时间计算出结果。</p><p>当操作一个无限大的 Stream，而又希望在有限时间内完成操作，则在管道内拥有一个 short-circuiting 操作是必要非充分条件。</p><h3 id="一个流操作的示例"><a href="#一个流操作的示例" class="headerlink" title="一个流操作的示例"></a>一个流操作的示例</h3><pre><code>int sum = widgets.stream().filter(w -&gt; w.getColor() == RED) .mapToInt(w -&gt; w.getWeight()) .sum();</code></pre><p>stream() 获取当前小物件的 source，filter 和 mapToInt 为 intermediate 操作，进行数据筛选和转换，最后一个 sum() 为 terminal 操作，对符合条件的全部小物件作重量求和。</p><h2 id="流的使用详解"><a href="#流的使用详解" class="headerlink" title="流的使用详解"></a>流的使用详解</h2><p>简单说，对 Stream 的使用就是实现一个 filter-map-reduce 过程，产生一个最终结果，或者导致一个副作用（side effect）。</p><p>流的构造与转换</p><p>下面提供最常见的几种构造 Stream 的样例。</p><h3 id="构造流的几种常见方法"><a href="#构造流的几种常见方法" class="headerlink" title="构造流的几种常见方法"></a>构造流的几种常见方法</h3><pre><code>// 1. Individual valuesStream stream = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);// 2. ArraysString [] strArray = new String[] {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;};stream = Stream.of(strArray);stream = Arrays.stream(strArray);// 3. CollectionsList&lt;String&gt; list = Arrays.asList(strArray);stream = list.stream();</code></pre><p>需要注意的是，对于基本数值型，目前有三种对应的包装类型 Stream：</p><p>IntStream、LongStream、DoubleStream。</p><p>当然我们也可以用 Stream<integer>、Stream<long> &gt;、Stream<double>，但是 boxing 和 unboxing 会很耗时，所以特别为这三种基本数值型提供了对应的 Stream。</double></long></integer></p><p>Java 8 中还没有提供其它数值型 Stream，因为这将导致扩增的内容较多。而常规的数值型聚合运算可以通过上面三种 Stream 进行。</p><h3 id="数值流的构造"><a href="#数值流的构造" class="headerlink" title="数值流的构造"></a>数值流的构造</h3><pre><code>IntStream.of(new int[]{1, 2, 3}).forEach(System.out::println);IntStream.range(1, 3).forEach(System.out::println);IntStream.rangeClosed(1, 3).forEach(System.out::println);</code></pre><h3 id="流转换为其它数据结构"><a href="#流转换为其它数据结构" class="headerlink" title="流转换为其它数据结构"></a>流转换为其它数据结构</h3><pre><code>// 1. ArrayString[] strArray1 = stream.toArray(String[]::new);// 2. CollectionList&lt;String&gt; list1 = stream.collect(Collectors.toList());List&lt;String&gt; list2 = stream.collect(Collectors.toCollection(ArrayList::new));Set set1 = stream.collect(Collectors.toSet());Stack stack1 = stream.collect(Collectors.toCollection(Stack::new));// 3. StringString str = stream.collect(Collectors.joining()).toString();</code></pre><p>一个 Stream 只可以使用一次，上面的代码为了简洁而重复使用了数次。</p><h2 id="流的操作"><a href="#流的操作" class="headerlink" title="流的操作"></a>流的操作</h2><p>接下来，当把一个数据结构包装成 Stream 后，就要开始对里面的元素进行各类操作了。常见的操作可以归类如下。</p><h3 id="Intermediate：-1"><a href="#Intermediate：-1" class="headerlink" title="Intermediate："></a>Intermediate：</h3><p>map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered</p><h3 id="Terminal：-1"><a href="#Terminal：-1" class="headerlink" title="Terminal："></a>Terminal：</h3><p>forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator</p><h3 id="Short-circuiting："><a href="#Short-circuiting：" class="headerlink" title="Short-circuiting："></a>Short-circuiting：</h3><p>anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit</p><p>我们下面看一下 Stream 的比较典型用法。</p><h2 id="map-flatMap"><a href="#map-flatMap" class="headerlink" title="map/flatMap"></a>map/flatMap</h2><p>我们先来看 map。如果你熟悉 scala 这类函数式语言，对这个方法应该很了解，它的作用就是把 input Stream 的每一个元素，映射成 output Stream 的另外一个元素。</p><h3 id="转换大写"><a href="#转换大写" class="headerlink" title="转换大写"></a>转换大写</h3><pre><code>List&lt;String&gt; output = wordList.stream().map(String::toUpperCase).collect(Collectors.toList());</code></pre><p>这段代码把所有的单词转换为大写。</p><h3 id="平方数"><a href="#平方数" class="headerlink" title="平方数"></a>平方数</h3><pre><code>List&lt;Integer&gt; nums = Arrays.asList(1, 2, 3, 4);List&lt;Integer&gt; squareNums = nums.stream().map(n -&gt; n * n).collect(Collectors.toList());</code></pre><p>  这段代码生成一个整数 list 的平方数 {1, 4, 9, 16}。</p><p>  从上面例子可以看出，map 生成的是个 1:1 映射，每个输入元素，都按照规则转换成为另外一个元素。还有一些场景，是一对多映射关系的，这时需要 flatMap。</p><h3 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h3><pre><code>Stream&lt;List&lt;Integer&gt;&gt; inputStream = Stream.of( Arrays.asList(1), Arrays.asList(2, 3), Arrays.asList(4, 5, 6) );Stream&lt;Integer&gt; outputStream = inputStream.flatMap((childList) -&gt; childList.stream());</code></pre><p>flatMap 把 input Stream 中的层级结构扁平化，就是将最底层元素抽出来放到一起，最终 output 的新 Stream 里面已经没有 List 了，都是直接的数字。</p><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>filter 对原始 Stream 进行某项测试，通过测试的元素被留下来生成一个新 Stream。</p><h3 id="留下偶数"><a href="#留下偶数" class="headerlink" title="留下偶数"></a>留下偶数</h3><pre><code>Integer[] sixNums = {1, 2, 3, 4, 5, 6};Integer[] evens =Stream.of(sixNums).filter(n -&gt; n%2 == 0).toArray(Integer[]::new);</code></pre><p>经过条件“被 2 整除”的 filter，剩下的数字为 {2, 4, 6}。</p><h3 id="把单词挑出来"><a href="#把单词挑出来" class="headerlink" title="把单词挑出来"></a>把单词挑出来</h3><pre><code>List&lt;String&gt; output = reader.lines(). flatMap(line -&gt; Stream.of(line.split(REGEXP))). filter(word -&gt; word.length() &gt; 0). collect(Collectors.toList());</code></pre><p>这段代码首先把每行的单词用 flatMap 整理到新的 Stream，然后保留长度不为 0 的，就是整篇文章中的全部单词了。</p><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><p>forEach 方法接收一个 Lambda 表达式，然后在 Stream 的每一个元素上执行该表达式。</p><h3 id="打印姓名（forEach-和-pre-java8-的对比）"><a href="#打印姓名（forEach-和-pre-java8-的对比）" class="headerlink" title="打印姓名（forEach 和 pre-java8 的对比）"></a>打印姓名（forEach 和 pre-java8 的对比）</h3><pre><code>// Java 8roster.stream() .filter(p -&gt; p.getGender() == Person.Sex.MALE) .forEach(p -&gt; System.out.println(p.getName()));// Pre-Java 8for (Person p : roster) { if (p.getGender() == Person.Sex.MALE) { System.out.println(p.getName()); }}</code></pre><p>对一个人员集合遍历，找出男性并打印姓名。可以看出来，forEach 是为 Lambda 而设计的，保持了最紧凑的风格。而且 Lambda 表达式本身是可以重用的，非常方便。当需要为多核系统优化时，可以 parallelStream().forEach()，只是此时原有元素的次序没法保证，并行的情况下将改变串行时操作的行为，此时 forEach 本身的实现不需要调整，而 Java8 以前的 for 循环 code 可能需要加入额外的多线程逻辑。</p><p>但一般认为，forEach 和常规 for 循环的差异不涉及到性能，它们仅仅是函数式风格与传统 Java 风格的差别。</p><p>另外一点需要注意，forEach 是 terminal 操作，因此它执行后，Stream 的元素就被“消费”掉了，你无法对一个 Stream 进行两次 terminal 运算。下面的代码是错误的：</p><pre><code>stream.forEach(element -&gt; doOneThing(element));stream.forEach(element -&gt; doAnotherThing(element));</code></pre><p>相反，具有相似功能的 intermediate 操作 peek 可以达到上述目的。如下是出现在该 api javadoc 上的一个示例。</p><h3 id="peek-对每个元素执行操作并返回一个新的-Stream"><a href="#peek-对每个元素执行操作并返回一个新的-Stream" class="headerlink" title="peek 对每个元素执行操作并返回一个新的 Stream"></a>peek 对每个元素执行操作并返回一个新的 Stream</h3><pre><code>Stream.of(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;) .filter(e -&gt; e.length() &gt; 3) .peek(e -&gt; System.out.println(&quot;Filtered value: &quot; + e)) .map(String::toUpperCase) .peek(e -&gt; System.out.println(&quot;Mapped value: &quot; + e)) .collect(Collectors.toList());</code></pre><p>forEach 不能修改自己包含的本地变量值，也不能用 break/return 之类的关键字提前结束循环。</p><h2 id="findFirst"><a href="#findFirst" class="headerlink" title="findFirst"></a>findFirst</h2><p>这是一个 termimal 兼 short-circuiting 操作，它总是返回 Stream 的第一个元素，或者空。<br>这里比较重点的是它的返回值类型：Optional。这也是一个模仿 Scala 语言中的概念，作为一个容器，它可能含有某值，或者不包含。使用它的目的是尽可能避免 NullPointerException。</p><h3 id="Optional-的两个用例"><a href="#Optional-的两个用例" class="headerlink" title="Optional 的两个用例"></a>Optional 的两个用例</h3><pre><code>String strA = &quot; abcd &quot;, strB = null;print(strA);print(&quot;&quot;);print(strB);getLength(strA);getLength(&quot;&quot;);getLength(strB);public static void print(String text) { // Java 8 Optional.ofNullable(text).ifPresent(System.out::println); // Pre-Java 8 if (text != null) {   System.out.println(text);  } }public static int getLength(String text) { // Java 8return Optional.ofNullable(text).map(String::length).orElse(-1); // Pre-Java 8// return if (text != null) ? text.length() : -1; };</code></pre><p>在更复杂的 if (xx != null) 的情况中，使用 Optional 代码的可读性更好，而且它提供的是编译时检查，能极大的降低 NPE 这种 Runtime Exception 对程序的影响，或者迫使程序员更早的在编码阶段处理空值问题，而不是留到运行时再发现和调试。</p><p>Stream 中的 findAny、max/min、reduce 等方法等返回 Optional 值。还有例如 IntStream.average() 返回 OptionalDouble 等等。</p><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><p>这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。例如 Stream 的 sum 就相当于</p><pre><code>Integer sum = integers.reduce(0, (a, b) -&gt; a+b);</code></pre><p>或</p><pre><code>Integer sum = integers.reduce(0, Integer::sum);</code></pre><p>也有没有起始值的情况，这时会把 Stream 的前面两个元素组合起来，返回的是 Optional。</p><h3 id="reduce-的用例"><a href="#reduce-的用例" class="headerlink" title="reduce 的用例"></a>reduce 的用例</h3><pre><code>// 字符串连接，concat = &quot;ABCD&quot;String concat = Stream.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;).reduce(&quot;&quot;, String::concat);// 求最小值，minValue = -3.0double minValue = Stream.of(-1.5, 1.0, -3.0, -2.0).reduce(Double.MAX_VALUE, Double::min);// 求和，sumValue = 10, 有起始值int sumValue = Stream.of(1, 2, 3, 4).reduce(0, Integer::sum);// 求和，sumValue = 10, 无起始值sumValue = Stream.of(1, 2, 3, 4).reduce(Integer::sum).get();// 过滤，字符串连接，concat = &quot;ace&quot;concat = Stream.of(&quot;a&quot;, &quot;B&quot;, &quot;c&quot;, &quot;D&quot;, &quot;e&quot;, &quot;F&quot;). filter(x -&gt; x.compareTo(&quot;Z&quot;) &gt; 0). reduce(&quot;&quot;, String::concat);</code></pre><p>上面代码例如第一个示例的 reduce()，第一个参数（空白字符）即为起始值，第二个参数（String::concat）为 BinaryOperator。这类有起始值的 reduce() 都返回具体的对象。而对于第四个示例没有起始值的 reduce()，由于可能没有足够的元素，返回的是 Optional，请留意这个区别。</p><h2 id="limit-skip"><a href="#limit-skip" class="headerlink" title="limit/skip"></a>limit/skip</h2><p>limit 返回 Stream 的前面 n 个元素；skip 则是扔掉前 n 个元素（它是由一个叫 subStream 的方法改名而来）。</p><h3 id="limit-和-skip-对运行次数的影响"><a href="#limit-和-skip-对运行次数的影响" class="headerlink" title="limit 和 skip 对运行次数的影响"></a>limit 和 skip 对运行次数的影响</h3><pre><code>public void testLimitAndSkip() { List&lt;Person&gt; persons = new ArrayList(); for (int i = 1; i &lt;= 10000; i++) { Person person = new Person(i, &quot;name&quot; + i); persons.add(person); }List&lt;String&gt; personList2 = persons.stream().map(Person::getName).limit(10).skip(3).collect(Collectors.toList()); System.out.println(personList2);}private class Person { public int no; private String name; public Person (int no, String name) { this.no = no; this.name = name; } public String getName() { System.out.println(name); return name; }}</code></pre><p>输出结果为：</p><pre><code>name1name2name3name4name5name6name7name8name9name10[name4, name5, name6, name7, name8, name9, name10]</code></pre><p>这是一个有 10，000 个元素的 Stream，但在 short-circuiting 操作 limit 和 skip 的作用下，管道中 map 操作指定的 getName() 方法的执行次数为 limit 所限定的 10 次，而最终返回结果在跳过前 3 个元素后只有后面 7 个返回。</p><p>有一种情况是 limit/skip 无法达到 short-circuiting 目的的，就是把它们放在 Stream 的排序操作后，原因跟 sorted 这个 intermediate 操作有关：此时系统并不知道 Stream 排序后的次序如何，所以 sorted 中的操作看上去就像完全没有被 limit 或者 skip 一样。</p><h3 id="limit-和-skip-对-sorted-后的运行次数无影响"><a href="#limit-和-skip-对-sorted-后的运行次数无影响" class="headerlink" title="limit 和 skip 对 sorted 后的运行次数无影响"></a>limit 和 skip 对 sorted 后的运行次数无影响</h3><pre><code>List&lt;Person&gt; persons = new ArrayList(); for (int i = 1; i &lt;= 5; i++) { Person person = new Person(i, &quot;name&quot; + i); persons.add(person); }List&lt;Person&gt; personList2 = persons.stream().sorted((p1, p2) -&gt;p1.getName().compareTo(p2.getName())).limit(2).collect(Collectors.toList());System.out.println(personList2);</code></pre><p>上面的示例对“peek 对每个元素执行操作并返回一个新的 Stream”做了微调，首先对 5 个元素的 Stream 排序，然后进行 limit 操作。输出结果为：</p><pre><code>name2name1name3name2name4name3name5name4[stream.StreamDW$Person@816f27d, stream.StreamDW$Person@87aac27]</code></pre><p>即虽然最后的返回元素数量是 2，但整个管道中的 sorted 表达式执行次数没有像前面例子相应减少。</p><p>最后有一点需要注意的是，对一个 parallel 的 Steam 管道来说，如果其元素是有序的，那么 limit 操作的成本会比较大，因为它的返回对象必须是前 n 个也有一样次序的元素。取而代之的策略是取消元素间的次序，或者不要用 parallel Stream。</p><h2 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h2><p>对 Stream 的排序通过 sorted 进行，它比数组的排序更强之处在于你可以首先对 Stream 进行各类 map、filter、limit、skip 甚至 distinct 来减少元素数量后，再排序，这能帮助程序明显缩短执行时间。我们对“Optional 的两个用例” 进行优化：</p><h3 id="优化：排序前进行-limit-和-skip"><a href="#优化：排序前进行-limit-和-skip" class="headerlink" title="优化：排序前进行 limit 和 skip"></a>优化：排序前进行 limit 和 skip</h3><pre><code>List&lt;Person&gt; persons = new ArrayList(); for (int i = 1; i &lt;= 5; i++) { Person person = new Person(i, &quot;name&quot; + i); persons.add(person); }List&lt;Person&gt; personList2 = persons.stream().limit(2).sorted((p1, p2) -&gt; p1.getName().compareTo(p2.getName())).collect(Collectors.toList());System.out.println(personList2);</code></pre><p>结果会简单很多：</p><pre><code>name2name1[stream.StreamDW$Person@6ce253f1, stream.StreamDW$Person@53d8d10a]</code></pre><p>当然，这种优化是有 business logic 上的局限性的：即不要求排序后再取值。<br>min/max/distinct</p><p>min 和 max 的功能也可以通过对 Stream 元素先排序，再 findFirst 来实现，但前者的性能会更好，为 O(n)，而 sorted 的成本是 O(n log n)。同时它们作为特殊的 reduce 方法被独立出来也是因为求最大最小值是很常见的操作。</p><h3 id="找出最长一行的长度"><a href="#找出最长一行的长度" class="headerlink" title="找出最长一行的长度"></a>找出最长一行的长度</h3><pre><code>BufferedReader br = new BufferedReader(new FileReader(&quot;c:\\SUService.log&quot;));int longest = br.lines(). mapToInt(String::length). max(). getAsInt();br.close();System.out.println(longest);</code></pre><p>下面的例子则使用 distinct 来找出不重复的单词。</p><h3 id="找出全文的单词，转小写，并排序"><a href="#找出全文的单词，转小写，并排序" class="headerlink" title="找出全文的单词，转小写，并排序"></a>找出全文的单词，转小写，并排序</h3><pre><code>List&lt;String&gt; words = br.lines(). flatMap(line -&gt; Stream.of(line.split(&quot; &quot;))). filter(word -&gt; word.length() &gt; 0). map(String::toLowerCase). distinct(). sorted(). collect(Collectors.toList());br.close();System.out.println(words);</code></pre><h2 id="Match"><a href="#Match" class="headerlink" title="Match"></a>Match</h2><p>Stream 有三个 match 方法，从语义上说：<br>allMatch：Stream 中全部元素符合传入的 predicate，返回 true<br>anyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 true<br>noneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true<br>它们都不是要遍历全部元素才能返回结果。例如 allMatch 只要一个元素不满足条件，就 skip 剩下的所有元素，返回 false。对清单 13 中的 Person 类稍做修改，加入一个 age 属性和 getAge 方法。</p><h3 id="使用-Match"><a href="#使用-Match" class="headerlink" title="使用 Match"></a>使用 Match</h3><pre><code>List&lt;Person&gt; persons = new ArrayList();persons.add(new Person(1, &quot;name&quot; + 1, 10));persons.add(new Person(2, &quot;name&quot; + 2, 21));persons.add(new Person(3, &quot;name&quot; + 3, 34));persons.add(new Person(4, &quot;name&quot; + 4, 6));persons.add(new Person(5, &quot;name&quot; + 5, 55));boolean isAllAdult = persons.stream(). allMatch(p -&gt; p.getAge() &gt; 18);System.out.println(&quot;All are adult? &quot; + isAllAdult);boolean isThereAnyChild = persons.stream(). anyMatch(p -&gt; p.getAge() &lt; 12);System.out.println(&quot;Any child? &quot; + isThereAnyChild);</code></pre><p>输出结果：<br>    1<br>    2<br>    All are adult? false<br>    Any child? true</p><h2 id="进阶：自己生成流"><a href="#进阶：自己生成流" class="headerlink" title="进阶：自己生成流"></a>进阶：自己生成流</h2><h2 id="Stream-generate"><a href="#Stream-generate" class="headerlink" title="Stream.generate"></a>Stream.generate</h2><p>通过实现 Supplier 接口，你可以自己来控制流的生成。这种情形通常用于随机数、常量的 Stream，或者需要前后元素间维持着某种状态信息的 Stream。把 Supplier 实例传递给 Stream.generate() 生成的 Stream，默认是串行（相对 parallel 而言）但无序的（相对 ordered 而言）。由于它是无限的，在管道中，必须利用 limit 之类的操作限制 Stream 大小。</p><h3 id="生成-10-个随机整数"><a href="#生成-10-个随机整数" class="headerlink" title="生成 10 个随机整数"></a>生成 10 个随机整数</h3><pre><code>Random seed = new Random();Supplier&lt;Integer&gt; random = seed::nextInt;Stream.generate(random).limit(10).forEach(System.out::println);//Another wayIntStream.generate(() -&gt; (int) (System.nanoTime() % 100)).limit(10).forEach(System.out::println);</code></pre><p>Stream.generate() 还接受自己实现的 Supplier。例如在构造海量测试数据的时候，用某种自动的规则给每一个变量赋值；或者依据公式计算 Stream 的每个元素值。这些都是维持状态信息的情形。</p><h3 id="自实现-Supplier"><a href="#自实现-Supplier" class="headerlink" title="自实现 Supplier"></a>自实现 Supplier</h3><pre><code>Stream.generate(new PersonSupplier()).limit(10).forEach(p -&gt; System.out.println(p.getName() + &quot;, &quot; + p.getAge()));private class PersonSupplier implements Supplier&lt;Person&gt; { private int index = 0; private Random random = new Random(); @Override public Person get() { return new Person(index++, &quot;StormTestUser&quot; + index, random.nextInt(100)); }}</code></pre><p>输出结果：</p><pre><code>StormTestUser1, 9StormTestUser2, 12StormTestUser3, 88StormTestUser4, 51StormTestUser5, 22StormTestUser6, 28StormTestUser7, 81StormTestUser8, 51StormTestUser9, 4StormTestUser10, 76</code></pre><h2 id="Stream-iterate"><a href="#Stream-iterate" class="headerlink" title="Stream.iterate"></a>Stream.iterate</h2><p>iterate 跟 reduce 操作很像，接受一个种子值，和一个 UnaryOperator（例如 f）。然后种子值成为 Stream 的第一个元素，f(seed) 为第二个，f(f(seed)) 第三个，以此类推。</p><h3 id="生成一个等差数列"><a href="#生成一个等差数列" class="headerlink" title="生成一个等差数列"></a>生成一个等差数列</h3><pre><code>Stream.iterate(0, n -&gt; n + 3).limit(10). forEach(x -&gt; System.out.print(x + &quot; &quot;));.</code></pre><p>输出结果：</p><pre><code>0 3 6 9 12 15 18 21 24 27</code></pre><p>与 Stream.generate 相仿，在 iterate 时候管道必须有 limit 这样的操作来限制 Stream 大小。</p><h2 id="进阶：用-Collectors-来进行-reduction-操作"><a href="#进阶：用-Collectors-来进行-reduction-操作" class="headerlink" title="进阶：用 Collectors 来进行 reduction 操作"></a>进阶：用 Collectors 来进行 reduction 操作</h2><p>java.util.stream.Collectors 类的主要作用就是辅助进行各类有用的 reduction 操作，例如转变输出为 Collection，把 Stream 元素进行归组。<br>groupingBy/partitioningBy</p><h3 id="按照年龄归组"><a href="#按照年龄归组" class="headerlink" title="按照年龄归组"></a>按照年龄归组</h3><pre><code>Map&lt;Integer, List&lt;Person&gt;&gt; personGroups = Stream.generate(new PersonSupplier()). limit(100). collect(Collectors.groupingBy(Person::getAge));Iterator it = personGroups.entrySet().iterator();while (it.hasNext()) { Map.Entry&lt;Integer, List&lt;Person&gt;&gt; persons = (Map.Entry) it.next(); System.out.println(&quot;Age &quot; + persons.getKey() + &quot; = &quot; + persons.getValue().size());}</code></pre><p>上面的 code，首先生成 100 人的信息，然后按照年龄归组，相同年龄的人放到同一个 list 中，可以看到如下的输出：</p><pre><code>Age 0 = 2Age 1 = 2Age 5 = 2Age 8 = 1Age 9 = 1Age 11 = 2……</code></pre><h3 id="按照未成年人和成年人归组"><a href="#按照未成年人和成年人归组" class="headerlink" title="按照未成年人和成年人归组"></a>按照未成年人和成年人归组</h3><pre><code>Map&lt;Boolean, List&lt;Person&gt;&gt; children = Stream.generate(new PersonSupplier()). limit(100). collect(Collectors.partitioningBy(p -&gt; p.getAge() &lt; 18));System.out.println(&quot;Children number: &quot; + children.get(true).size());System.out.println(&quot;Adult number: &quot; + children.get(false).size());</code></pre><p>输出结果：</p><pre><code>Children number: 23Adult number: 77</code></pre><p>在使用条件“年龄小于 18”进行分组后可以看到，不到 18 岁的未成年人是一组，成年人是另外一组。</p><p>partitioningBy 其实是一种特殊的 groupingBy，它依照条件测试的是否两种结果来构造返回的数据结构，get(true) 和 get(false) 能即为全部的元素对象。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>总之，Stream 的特性可以归纳为：</p><p>不是数据结构</p><p>它没有内部存储，它只是用操作管道从 source（数据结构、数组、generator function、IO channel）抓取数据。</p><p>它也绝不修改自己所封装的底层数据结构的数据。例如 Stream 的 filter 操作会产生一个不包含被过滤元素的新 Stream，而不是从 source 删除那些元素。</p><p>所有 Stream 的操作必须以 lambda 表达式为参数</p><p>不支持索引访问</p><p>你可以请求第一个元素，但无法请求第二个，第三个，或最后一个。不过请参阅下一项。</p><p>很容易生成数组或者 List</p><p>惰性化</p><p>很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。<br>Intermediate 操作永远是惰性化的。</p><p>并行能力</p><p>当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的。</p><p>可以是无限的</p><p>集合有固定大小，Stream 则不必。limit(n) 和 findFirst() 这类的 short-circuiting 操作可以对无限的 Stream 进行运算并很快完成。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/index.html</a></p><p>【2】<a href="https://www.ibm.com/developerworks/cn/java/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/</a></p><p>【3】<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html</a></p><p>【4】<a href="https://javarevisited.blogspot.com/2018/07/java-8-tutorials-resources-and-examples-lambda-expression-stream-api-functional-interfaces.html" target="_blank" rel="noopener">https://javarevisited.blogspot.com/2018/07/java-8-tutorials-resources-and-examples-lambda-expression-stream-api-functional-interfaces.html</a></p><p>【5】<a href="http://www.drdobbs.com/jvm/lambdas-and-streams-in-java-8-libraries/240166818" target="_blank" rel="noopener">http://www.drdobbs.com/jvm/lambdas-and-streams-in-java-8-libraries/240166818</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MapReduce思想学习,对Java8中对新特性stream，map和reduce进行学习，Stream API部分主要来自于IBM Developer官网，原文写的非常详尽清晰。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年8月" scheme="http://yoursite.com/categories/2019%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记V</title>
    <link href="http://yoursite.com/2019/08/12/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0V/"/>
    <id>http://yoursite.com/2019/08/12/Java学习笔记V/</id>
    <published>2019-08-12T06:48:12.000Z</published>
    <updated>2019-08-13T06:44:00.146Z</updated>
    
    <content type="html"><![CDATA[<p>学习Guaa中的字符串处理函数Joiner类的用法。</p><a id="more"></a><h1 id="Guava"><a href="#Guava" class="headerlink" title="Guava"></a>Guava</h1><p>Guava 是一个 Google 的基于java1.6的类库集合的扩展项目，Guava工程包含了若干被Google的 Java项目广泛依赖 的核心库，例如：集合 [collections] 、缓存 [caching] 、原生类型支持 [primitives support] 、并发库 [concurrency libraries] 、通用注解 [common annotations] 、字符串处理 [string processing] 、I/O 等等。</p><h1 id="连接器Joiner"><a href="#连接器Joiner" class="headerlink" title="连接器Joiner"></a>连接器Joiner</h1><p>用分隔符把字符串序列连接起来也可能会遇上不必要的麻烦。如果字符串序列中含有null，那连接操作会更难。Fluent风格的Joiner让连接字符串更简单。</p><p>  Joiner joiner = Joiner.on(“; “).skipNulls();<br>  return joiner.join(“Harry”, null, “Ron”, “Hermione”);</p><p>上述代码返回”Harry; Ron; Hermione”。另外，useForNull(String)方法可以给定某个字符串来替换null，而不像skipNulls()方法是直接忽略null。<br> Joiner也可以用来连接对象类型，在这种情况下，它会把对象的toString()值连接起来。</p><pre><code>Joiner.on(&quot;,&quot;).join(Arrays.asList(1, 5, 7)); // returns &quot;1,5,7&quot;</code></pre><p>警告：joiner实例总是不可变的。用来定义joiner目标语义的配置方法总会返回一个新的joiner实例。<br>这使得joiner实例都是线程安全的，你可以将其定义为static final常量。</p><h1 id="传统连接方法"><a href="#传统连接方法" class="headerlink" title="传统连接方法"></a>传统连接方法</h1><p>相比之下传统的以某个分隔符来进行拼接的代码如下：</p><pre><code>public static String concatString(List&lt;String&gt; lists,String delimiter){    StringBuilder builder=new StringBuilder();    for(String s:lists){        if(s!=null){            builder.append(s).append(delimiter);        }    }    builder.setLength(builder.length()-delimiter.length());    return builder.toString();}public  static  void  main(String[] args) {  List&lt;String&gt; list=new ArrayList();  list.add(&quot;Traditional&quot;);  list.add(&quot;delimiter&quot;);  list.add(&quot;codingstyle&quot;);  System.out.println(concatString(list,&quot;-&quot;));}</code></pre><h1 id="MapJoiner"><a href="#MapJoiner" class="headerlink" title="MapJoiner"></a>MapJoiner</h1><p>MapJoiner的用法和Joiner类似,不过MapJoiner主要针对map的字符串拼接例：</p><pre><code>Map&lt;String,String&gt; maps=Maps.newHashMap();maps.put(&quot;MapJoiner&quot;,&quot;1&quot;);maps.put(&quot;String&quot;,&quot;delimiter&quot;);String ss=Joiner.on(&quot;$&quot;).withKeyValueSeparator(&quot;=&quot;).join(maps);System.out.println(ss);</code></pre><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://wizardforcel.gitbooks.io/guava-tutorial/content/1.html" target="_blank" rel="noopener">https://wizardforcel.gitbooks.io/guava-tutorial/content/1.html</a></p><p>【2】<a href="https://blog.csdn.net/u012415194/article/details/84880258" target="_blank" rel="noopener">https://blog.csdn.net/u012415194/article/details/84880258</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习Guaa中的字符串处理函数Joiner类的用法。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年8月" scheme="http://yoursite.com/categories/2019%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记III</title>
    <link href="http://yoursite.com/2019/08/12/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0III/"/>
    <id>http://yoursite.com/2019/08/12/Java学习笔记III/</id>
    <published>2019-08-12T06:45:12.000Z</published>
    <updated>2019-08-13T06:13:13.593Z</updated>
    
    <content type="html"><![CDATA[<p>总结Java8 Lambda表达式，对涉及到到final关键字做了回顾</p><a id="more"></a><h1 id="Java8-Lambda表达式"><a href="#Java8-Lambda表达式" class="headerlink" title="Java8 Lambda表达式"></a>Java8 Lambda表达式</h1><p>Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。<br>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。<br>使用 Lambda 表达式可以使代码变的更加简洁紧凑。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>lambda 表达式的语法格式如下：</p><pre><code>(parameters) -&gt; expression或(parameters) -&gt;{ statements; }</code></pre><p>以下是lambda表达式的重要特征:</p><p>可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。</p><p>可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。</p><p>可选的大括号：如果主体包含了一个语句，就不需要使用大括号。</p><p>可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</p><h2 id="Lambda-表达式实例"><a href="#Lambda-表达式实例" class="headerlink" title="Lambda 表达式实例"></a>Lambda 表达式实例</h2><p>Lambda 表达式的简单例子:</p><pre><code>// 1. 不需要参数,返回值为 5  () -&gt; 5  // 2. 接收一个参数(数字类型),返回其2倍的值  x -&gt; 2 * x  // 3. 接受2个参数(数字),并返回他们的差值  (x, y) -&gt; x – y  // 4. 接收2个int型整数,返回他们的和  (int x, int y) -&gt; x + y  // 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  (String s) -&gt; System.out.print(s)</code></pre><p>在 Java8Tester.java 文件输入以下代码：</p><pre><code>public class Java8Tester {   public static void main(String args[]){      Java8Tester tester = new Java8Tester();      // 类型声明      MathOperation addition = (int a, int b) -&gt; a + b;      // 不用类型声明      MathOperation subtraction = (a, b) -&gt; a - b;      // 大括号中的返回语句      MathOperation multiplication = (int a, int b) -&gt; { return a * b; };      // 没有大括号及返回语句      MathOperation division = (int a, int b) -&gt; a / b;      System.out.println(&quot;10 + 5 = &quot; + tester.operate(10, 5, addition));      System.out.println(&quot;10 - 5 = &quot; + tester.operate(10, 5, subtraction));      System.out.println(&quot;10 x 5 = &quot; + tester.operate(10, 5, multiplication));      System.out.println(&quot;10 / 5 = &quot; + tester.operate(10, 5, division));      // 不用括号      GreetingService greetService1 = message -&gt;      System.out.println(&quot;Hello &quot; + message);      // 用括号      GreetingService greetService2 = (message) -&gt;      System.out.println(&quot;Hello &quot; + message);      greetService1.sayMessage(&quot;Runoob&quot;);      greetService2.sayMessage(&quot;Google&quot;);   }   interface MathOperation {      int operation(int a, int b);   }   interface GreetingService {      void sayMessage(String message);   }   private int operate(int a, int b, MathOperation mathOperation){      return mathOperation.operation(a, b);   }}</code></pre><p>执行以上脚本，输出结果为：</p><pre><code>$ javac Java8Tester.java$ java Java8Tester10 + 5 = 1510 - 5 = 510 x 5 = 5010 / 5 = 2Hello RunoobHello Google</code></pre><p>使用 Lambda 表达式需要注意以下两点：</p><p>Lambda 表达式主要用来定义行内执行的方法类型接口，例如，一个简单方法接口。在上面例子中，我们使用各种类型的Lambda表达式来定义MathOperation接口的方法。然后我们定义了sayMessage的执行。</p><p>Lambda 表达式免去了使用匿名方法的麻烦，并且给予Java简单但是强大的函数化的编程能力。</p><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>lambda 表达式只能引用标记了 final 的外层局部变量，这就是说不能在 lambda 内部修改定义在域外的局部变量，否则会编译错误。<br>在 Java8Tester.java 文件输入以下代码：</p><pre><code>public class Java8Tester {final static String salutation = &quot;Hello! &quot;;public static void main(String args[]){  GreetingService greetService1 = message -&gt;  System.out.println(salutation + message);  greetService1.sayMessage(&quot;Runoob&quot;);}interface GreetingService {  void sayMessage(String message);}}</code></pre><p>执行以上脚本，输出结果为：</p><pre><code>$ javac Java8Tester.java$ java Java8TesterHello! Runoob</code></pre><p>我们也可以直接在 lambda 表达式中访问外层的局部变量：</p><pre><code>public class Java8Tester {    public static void main(String args[]) {        final int num = 1;        Converter&lt;Integer, String&gt; s = (param) -&gt; System.out.println(String.valueOf(param + num));        s.convert(2);  // 输出结果为 3    }    public interface Converter&lt;T1, T2&gt; {        void convert(int i);    }}</code></pre><p>lambda 表达式的局部变量可以不用声明为 final，但是必须不可被后面的代码修改（即隐性的具有 final 的语义）</p><pre><code>int num = 1;  Converter&lt;Integer, String&gt; s = (param) -&gt; System.out.println(String.valueOf(param + num));s.convert(2);num = 5;  //报错信息：Local variable num defined in an enclosing scope must be final or effectively final</code></pre><p>在 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量。</p><pre><code>String first = &quot;&quot;;  Comparator&lt;String&gt; comparator = (first, second) -&gt; Integer.compare(first.length(), second.length());  //编译会出错</code></pre><h1 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h1><p>final是一个关键字，可以用于修饰类，成员变量，成员方法。</p><h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><p>它修饰的类不能被继承。</p><p>它修饰的成员变量是一个常量。</p><p>它修饰的成员方法是不能被子类重写的。</p><p>final修饰的常量定义一般都有书写规范,被final修饰的常量名称,所有字母都大写。</p><p>final修饰成员变量,必须初始化,初始化有两种</p><p>显示初始化；</p><p>构造方法初始化。</p><p>但是不能两个一起初始化</p><h2 id="final和private的区别："><a href="#final和private的区别：" class="headerlink" title="final和private的区别："></a>final和private的区别：</h2><p>final修饰的类可以访问；</p><p>private不可以修饰外部类，但可以修饰内部类（其实把外部类私有化是没有意义的）。</p><p>final修饰的方法不可以被子类重写；</p><p>private修饰的方法表面上看是可以被子类重写的，其实不可以，子类是看不到父类的私有方法的。</p><p>final修饰的变量只能在显示初始化或者构造函数初始化的时候赋值一次，以后不允许更改；</p><p>private修饰的变量，也不允许直接被子类或一个包中的其它类访问或修改，但是他可以通过set和get方法对其改值和取值。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://www.runoob.com/java/java8-lambda-expressions.html" target="_blank" rel="noopener">https://www.runoob.com/java/java8-lambda-expressions.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结Java8 Lambda表达式，对涉及到到final关键字做了回顾&lt;/p&gt;
    
    </summary>
    
      <category term="2019年8月" scheme="http://yoursite.com/categories/2019%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>数据库学习笔记II</title>
    <link href="http://yoursite.com/2019/08/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0II/"/>
    <id>http://yoursite.com/2019/08/09/数据库学习笔记II/</id>
    <published>2019-08-09T07:12:12.000Z</published>
    <updated>2019-08-13T07:20:00.734Z</updated>
    
    <content type="html"><![CDATA[<p>重新温习Mysqlkey 、primary key 、unique key 与index的区别</p><a id="more"></a><h1 id="key与primary-key区别"><a href="#key与primary-key区别" class="headerlink" title="key与primary key区别"></a>key与primary key区别</h1><pre><code>CREATE TABLE wh_logrecord (  logrecord_id int(11) NOT NULL auto_increment,  user_name varchar(100) default NULL,  operation_time datetime default NULL,  logrecord_operation varchar(100) default NULL,  PRIMARY KEY (logrecord_id),  KEY wh_logrecord_user_name (user_name)  )</code></pre><h2 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h2><p>  KEY wh_logrecord_user_name (user_name)</p><p>  本表的user_name字段与wh_logrecord_user_name表user_name字段建立外键</p><p>  括号外是建立外键的对应表，括号内是对应字段</p><p>  类似还有 KEY user(userid)</p><p>  当然，key未必都是外键</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>  Key是索引约束，对表中字段进行约束索引的，都是通过primary foreign unique等创建的。<br>  常见有foreign key，外键关联用的。</p><p>  KEY forum (status,type,displayorder)  # 是多列索引（键）</p><p>  KEY tid (tid)                         # 是单列索引（键）。</p><p>  如建表时： KEY forum (status,type,displayorder)</p><p>  select * from table group by status,type,displayorder 是否就自动用上了此索引，</p><p>  而当 select * from table group by status 此索引有用吗？</p><p>  key的用途：主要是用来加快查询速度的。</p><h1 id="KEY与INDEX区别"><a href="#KEY与INDEX区别" class="headerlink" title="KEY与INDEX区别"></a>KEY与INDEX区别</h1><p>KEY通常是INDEX同义词。</p><p>如果关键字属性PRIMARY KEY在列定义中已给定，则PRIMARY KEY也可以只指定为KEY。这么做的目的是与其它数据库系统兼容。</p><p>PRIMARY KEY是一个唯一KEY，此时，所有的关键字列必须定义为NOT NULL。</p><p>如果这些列没有被明确地定义为NOT NULL，MySQL应隐含地定义这些列。</p><p>一个表只有一个PRIMARY KEY。</p><h2 id="MySQL-中Index-与Key-的区别"><a href="#MySQL-中Index-与Key-的区别" class="headerlink" title="MySQL 中Index 与Key 的区别"></a>MySQL 中Index 与Key 的区别</h2><p>Key即键值，是关系模型理论中的一部份，比如有主键（Primary Key)，外键（Foreign Key）等，用于数据完整性检否与唯一性约束等。</p><p>而Index则处于实现层面，比如可以对表个的任意列建立索引，那么当建立索引的列处于SQL语句中的Where条件中时，就可以得到快速的数据定位，从而快速检索。</p><p>至于Unique Index，则只是属于Index中的一种而已，建立了Unique Index表示此列数据不可重复，猜想MySQL对Unique Index类型的索引可以做进一步特殊优化吧。</p><p>于是乎，在设计表的时候，Key只是要处于模型层面的，而当需要进行查询优化，则对相关列建立索引即可。</p><p>另外，在MySQL中，对于一个Primary Key的列，MySQL已经自动对其建立了Unique Index，无需重复再在上面建立索引了。</p><p>搜索到的一段解释：</p><p>Note that “primary” is called PRIMARY KEY not INDEX.</p><p>KEY is something on the logical level, describes your table and database design (i.e. enforces referential integrity …)</p><p>INDEX is something on the physical level, helps improve access time for table operations.</p><p>Behind every PK there is (usually) unique index created (automatically).</p><h1 id="mysql中UNIQUE-KEY和PRIMARY-KEY有什么区别"><a href="#mysql中UNIQUE-KEY和PRIMARY-KEY有什么区别" class="headerlink" title="mysql中UNIQUE KEY和PRIMARY KEY有什么区别"></a>mysql中UNIQUE KEY和PRIMARY KEY有什么区别</h1><p>1，Primary key的1个或多个列必须为NOT NULL，如果列为NULL，在增加PRIMARY KEY时，列自动更改为NOT NULL。而UNIQUE KEY 对列没有此要求</p><p>2，一个表只能有一个PRIMARY KEY，但可以有多个UNIQUE KEY</p><p>3，主键和唯一键约束是通过参考索引实施的，如果插入的值均为NULL，则根据索引的原理，全NULL值不被记录在索引上，所以插入全NULL值时，可以有重复的，而其他的则不能插入重复值。</p><pre><code>alter table t add constraint uk_t_1 unique (a,b);insert into t (a ,b ) values (null,1);    # 不能重复insert into t (a ,b ) values (null,null); # 可以重复</code></pre><h1 id="使用UNIQUE-KEY"><a href="#使用UNIQUE-KEY" class="headerlink" title="使用UNIQUE KEY"></a>使用UNIQUE KEY</h1><pre><code>CREATE TABLE `secure_vulnerability_warning` (  `id` int(10) NOT NULL auto_increment,  `date` date NOT NULL,  `type` varchar(100) NOT NULL,  `sub_type` varchar(100) NOT NULL,  `domain_name` varchar(128) NOT NULL,  `url` text NOT NULL,  `parameters` text NOT NULL,  `hash` varchar(100) NOT NULL,  `deal` int(1) NOT NULL,  `deal_date` date default NULL,  `remark` text,  `last_push_time` datetime default NULL,  `push_times` int(11) default &apos;1&apos;,  `first_set_ok_time` datetime default NULL,  `last_set_ok_time` datetime default NULL,  PRIMARY KEY  (`id`),  UNIQUE KEY `date` (`date`,`hash`)  ) ENGINE=InnoDB  DEFAULT CHARSET=utf8</code></pre><p>UNIQUE KEY的用途：主要是用来防止数据插入的时候重复的。</p><p>1，创建表时</p><pre><code>CREATE TABLE Persons(  Id_P int NOT NULL,  LastName varchar(255) NOT NULL,  FirstName varchar(255),  Address varchar(255),  City varchar(255),  UNIQUE (Id_P))</code></pre><p>如果需要命名 UNIQUE 约束，以及为多个列定义 UNIQUE 约束，请使用下面的 SQL 语法：</p><pre><code>CREATE TABLE Persons(  Id_P int NOT NULL,  LastName varchar(255) NOT NULL,  FirstName varchar(255),  Address varchar(255),  City varchar(255),  CONSTRAINT uc_PersonID UNIQUE (Id_P,LastName))</code></pre><p>2，当表已被创建时，如需在 “Id_P” 列创建 UNIQUE 约束，请使用下列 SQL：</p><p>ALTER TABLE PersonsADD UNIQUE (Id_P)<br>如需命名 UNIQUE 约束，并定义多个列的 UNIQUE 约束，请使用下面的 SQL 语法：</p><p>ALTER TABLE PersonsADD CONSTRAINT uc_PersonID UNIQUE (Id_P,LastName)</p><p>3，撤销 UNIQUE 约束如需撤销 UNIQUE 约束，请使用下面的 SQL：</p><p>MySQL:ALTER TABLE PersonsDROP INDEX uc_PersonID</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://www.jianshu.com/p/336170f4d649" target="_blank" rel="noopener">https://www.jianshu.com/p/336170f4d649</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重新温习Mysqlkey 、primary key 、unique key 与index的区别&lt;/p&gt;
    
    </summary>
    
      <category term="2019年8月" scheme="http://yoursite.com/categories/2019%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记II</title>
    <link href="http://yoursite.com/2019/08/07/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0II/"/>
    <id>http://yoursite.com/2019/08/07/Java学习笔记II/</id>
    <published>2019-08-07T07:37:12.000Z</published>
    <updated>2019-08-12T06:37:34.791Z</updated>
    
    <content type="html"><![CDATA[<p>重新温习Java中的异常处理</p><a id="more"></a><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>异常是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。</p><p>比如说，你的代码少了一个分号，那么运行出来结果是提示是错误 java.lang.Error；如果你用System.out.println(11/0)，那么你是因为你用0做了除数，会抛出 java.lang.ArithmeticException 的异常。</p><p>异常发生的原因有很多，通常包含以下几大类：</p><p>用户输入了非法数据。</p><p>要打开的文件不存在。</p><p>网络通信时连接中断，或者JVM内存溢出。</p><p>这些异常有的是因为用户错误引起，有的是程序错误引起的，还有其它一些是因为物理错误引起的。</p><p>要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常：</p><p>检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</p><p>运行时异常： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</p><p>错误： 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</p><h2 id="Exception-类的层次"><a href="#Exception-类的层次" class="headerlink" title="Exception 类的层次"></a>Exception 类的层次</h2><p>所有的异常类是从 java.lang.Exception 类继承的子类。</p><p>Exception 类是 Throwable 类的子类。除了Exception类外，Throwable还有一个子类Error 。</p><p>Java 程序通常不捕获错误。错误一般发生在严重故障时，它们在Java程序处理的范畴之外。</p><p>Error 用来指示运行时环境发生的错误。</p><p>例如，JVM 内存溢出。一般地，程序不会从错误中恢复。</p><p>异常类有两个主要的子类：IOException 类和 RuntimeException 类。</p><p><img src="assets/markdown-img-paste-20190807155403573.png" alt="https://www.runoob.com/wp-content/uploads/2013/12/12-130Q1234I6223.jpg"></p><h2 id="Java-内置异常类"><a href="#Java-内置异常类" class="headerlink" title="Java 内置异常类"></a>Java 内置异常类</h2><p>Java 语言定义了一些异常类在 java.lang 标准包中。</p><p>标准运行时异常类的子类是最常见的异常类。由于 java.lang 包是默认加载到所有的 Java 程序的，所以大部分从运行时异常类继承而来的异常都可以直接使用。</p><p>Java 根据各个类库也定义了一些其他的异常，下面的表中列出了 Java 的非检查性异常</p><table><thead><tr><th>异常</th><th>描述</th></tr></thead><tbody><tr><td>ArithmeticException</td><td>当出现异常的运算条件时，抛出此异常。例如，一个整数”除以零”时，抛出此类的一个实例。</td></tr><tr><td>ArrayIndexOutOfBoundsException</td><td>用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。</td></tr><tr><td>ArrayStoreException</td><td>试图将错误类型的对象存储到一个对象数组时抛出的异常。</td></tr><tr><td>ClassCastException</td><td>当试图将对象强制转换为不是实例的子类时，抛出该异常。</td></tr><tr><td>IllegalArgumentException</td><td>抛出的异常表明向方法传递了一个不合法或不正确的参数。</td></tr><tr><td>IllegalMonitorStateException</td><td>抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。</td></tr><tr><td>IllegalStateException</td><td>在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下。</td></tr><tr><td>IllegalThreadStateException</td><td>线程没有处于请求操作所要求的适当状态时抛出的异常。</td></tr><tr><td>IndexOutOfBoundsException</td><td>指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。</td></tr><tr><td>NegativeArraySizeException</td><td>如果应用程序试图创建大小为负的数组，则抛出该异常。</td></tr><tr><td>NullPointerException</td><td>当应用程序试图在需要对象的地方使用 null 时，抛出该异常</td></tr><tr><td>NumberFormatException</td><td>当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</td></tr><tr><td>SecurityException</td><td>由安全管理器抛出的异常，指示存在安全侵犯。</td></tr><tr><td>StringIndexOutOfBoundsException</td><td>此异常由 String 方法抛出，指示索引或者为负，或者超出字符串的大小。</td></tr><tr><td>UnsupportedOperationException</td><td>当不支持请求的操作时，抛出该异常。</td></tr></tbody></table><p>下面的表中列出了 Java 定义在 java.lang 包中的检查性异常类。</p><table><thead><tr><th>异常</th><th>描述</th></tr></thead><tbody><tr><td>ClassNotFoundException</td><td>应用程序试图加载类时，找不到相应的类，抛出该异常。</td></tr><tr><td>CloneNotSupportedException</td><td>当调用 Object 类中的 clone 方法克隆对象，但该对象的类无法实现 Cloneable 接口时，抛出该异常。</td></tr><tr><td>IllegalAccessException</td><td>拒绝访问一个类的时候，抛出该异常。</td></tr><tr><td>InstantiationException</td><td>当试图使用 Class 类中的 newInstance 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常。</td></tr><tr><td>InterruptedException</td><td>一个线程被另一个线程中断，抛出该异常。</td></tr><tr><td>NoSuchFieldException</td><td>请求的变量不存在</td></tr><tr><td>NoSuchMethodException</td><td>请求的方法不存在</td></tr></tbody></table><h2 id="异常方法"><a href="#异常方法" class="headerlink" title="异常方法"></a>异常方法</h2><p>下面的列表是 Throwable 类的主要方法:</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public String getMessage()</td><td>返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。</td></tr><tr><td>public Throwable getCause()</td><td>返回一个Throwable 对象代表异常原因。</td></tr><tr><td>public String toString()</td><td>使用getMessage()的结果返回类的串级名字。</td></tr><tr><td>public void printStackTrace()</td><td>打印toString()结果和栈层次到System.err，即错误输出流。</td></tr><tr><td>public StackTraceElement [] getStackTrace()</td><td>返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。</td></tr><tr><td>public Throwable fillInStackTrace()</td><td>用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中。</td></tr></tbody></table><h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><p>使用 try 和 catch 关键字可以捕获异常。try/catch 代码块放在异常可能发生的地方。</p><p>try/catch代码块中的代码称为保护代码，使用 try/catch 的语法如下：</p><pre><code>try{   // 程序代码}catch(ExceptionName e1){   //Catch 块}</code></pre><p>Catch 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。</p><p>如果发生的异常包含在 catch 块中，异常会被传递到该 catch 块，这和传递一个参数到方法是一样。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>下面的例子中声明有两个元素的一个数组，当代码试图访问数组的第三个元素的时候就会抛出一个异常。</p><p>ExcepTest.java 文件代码：</p><pre><code>// 文件名 : ExcepTest.javaimport java.io.*;public class ExcepTest{   public static void main(String args[]){      try{         int a[] = new int[2];         System.out.println(&quot;Access element three :&quot; + a[3]);      }catch(ArrayIndexOutOfBoundsException e){         System.out.println(&quot;Exception thrown  :&quot; + e);      }      System.out.println(&quot;Out of the block&quot;);   }}</code></pre><p>以上代码编译运行输出结果如下：</p><pre><code>Exception thrown  :java.lang.ArrayIndexOutOfBoundsException: 3Out of the block</code></pre><h3 id="多重捕获块"><a href="#多重捕获块" class="headerlink" title="多重捕获块"></a>多重捕获块</h3><p>一个 try 代码块后面跟随多个 catch 代码块的情况就叫多重捕获。</p><p>多重捕获块的语法如下所示：</p><pre><code>try{   // 程序代码}catch(异常类型1 异常的变量名1){  // 程序代码}catch(异常类型2 异常的变量名2){  // 程序代码}catch(异常类型2 异常的变量名2){  // 程序代码}</code></pre><p>上面的代码段包含了 3 个 catch块。</p><p>可以在 try 语句后面添加任意数量的 catch 块。</p><p>如果保护代码中发生异常，异常被抛给第一个 catch 块。</p><p>如果抛出异常的数据类型与 ExceptionType1 匹配，它在这里就会被捕获。</p><p>如果不匹配，它会被传递给第二个 catch 块。</p><p>如此，直到异常被捕获或者通过所有的 catch 块。</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>该实例展示了怎么使用多重 try/catch。</p><pre><code>try {    file = new FileInputStream(fileName);    x = (byte) file.read();} catch(FileNotFoundException f) { // Not valid!    f.printStackTrace();    return -1;} catch(IOException i) {    i.printStackTrace();    return -1;}</code></pre><h2 id="throws-throw-关键字："><a href="#throws-throw-关键字：" class="headerlink" title="throws/throw 关键字："></a>throws/throw 关键字：</h2><p>如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明。</p><p>throws 关键字放在方法签名的尾部。</p><p>也可以使用 throw 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的。</p><p>下面方法的声明抛出一个 RemoteException 异常：</p><pre><code>import java.io.*;public class className{  public void deposit(double amount) throws RemoteException  {    // Method implementation    throw new RemoteException();  }  //Remainder of class definition}</code></pre><p>一个方法可以声明抛出多个异常，多个异常之间用逗号隔开。</p><p>例如，下面的方法声明抛出 RemoteException 和 InsufficientFundsException：</p><pre><code>import java.io.*;public class className{   public void withdraw(double amount) throws RemoteException,                              InsufficientFundsException   {       // Method implementation   }   //Remainder of class definition}</code></pre><h2 id="finally关键字"><a href="#finally关键字" class="headerlink" title="finally关键字"></a>finally关键字</h2><p>finally 关键字用来创建在 try 代码块后面执行的代码块。</p><p>无论是否发生异常，finally 代码块中的代码总会被执行。</p><p>在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。</p><p>finally 代码块出现在 catch 代码块最后，语法如下：</p><pre><code>try{  // 程序代码}catch(异常类型1 异常的变量名1){  // 程序代码}catch(异常类型2 异常的变量名2){  // 程序代码}finally{  // 程序代码}</code></pre><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>ExcepTest.java 文件代码：</p><pre><code>public class ExcepTest{  public static void main(String args[]){    int a[] = new int[2];    try{       System.out.println(&quot;Access element three :&quot; + a[3]);    }catch(ArrayIndexOutOfBoundsException e){       System.out.println(&quot;Exception thrown  :&quot; + e);    }    finally{       a[0] = 6;       System.out.println(&quot;First element value: &quot; +a[0]);       System.out.println(&quot;The finally statement is executed&quot;);    }  }}</code></pre><p>以上实例编译运行结果如下：</p><pre><code>Exception thrown  :java.lang.ArrayIndexOutOfBoundsException: 3First element value: 6The finally statement is executed</code></pre><p>注意下面事项：</p><p>catch 不能独立于 try 存在。</p><p>在 try/catch 后面添加 finally 块并非强制性要求的。</p><p>try 代码后不能既没 catch 块也没 finally 块。</p><p>try, catch, finally 块之间不能添加任何代码。</p><h2 id="声明自定义异常"><a href="#声明自定义异常" class="headerlink" title="声明自定义异常"></a>声明自定义异常</h2><p>在 Java 中你可以自定义异常。编写自己的异常类时需要记住下面的几点。</p><p>所有异常都必须是 Throwable 的子类。</p><p>如果希望写一个检查性异常类，则需要继承 Exception 类。</p><p>如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。</p><p>可以像下面这样定义自己的异常类：</p><pre><code>class MyException extends Exception{}</code></pre><p>只继承Exception 类来创建的异常类是检查性异常类。</p><p>下面的 InsufficientFundsException 类是用户定义的异常类，它继承自 Exception。</p><p>一个异常类和其它任何类一样，包含有变量和方法。</p><h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><p>以下实例是一个银行账户的模拟，通过银行卡的号码完成识别，可以进行存钱和取钱的操作。</p><p>InsufficientFundsException.java 文件代码：</p><pre><code>// 文件名InsufficientFundsException.javaimport java.io.*;//自定义异常类，继承Exception类public class InsufficientFundsException extends Exception{  //此处的amount用来储存当出现异常（取出钱多于余额时）所缺乏的钱  private double amount;  public InsufficientFundsException(double amount)  {    this.amount = amount;  }  public double getAmount()  {    return amount;  }}</code></pre><p>为了展示如何使用我们自定义的异常类，</p><p>在下面的 CheckingAccount 类中包含一个 withdraw() 方法抛出一个 InsufficientFundsException 异常。</p><p>CheckingAccount.java 文件代码：</p><pre><code>// 文件名称 CheckingAccount.javaimport java.io.*;//此类模拟银行账户public class CheckingAccount{  //balance为余额，number为卡号   private double balance;   private int number;   public CheckingAccount(int number)   {      this.number = number;   }  //方法：存钱   public void deposit(double amount)   {      balance += amount;   }  //方法：取钱   public void withdraw(double amount) throws                              InsufficientFundsException   {      if(amount &lt;= balance)      {         balance -= amount;      }      else      {         double needs = amount - balance;         throw new InsufficientFundsException(needs);      }   }  //方法：返回余额   public double getBalance()   {      return balance;   }  //方法：返回卡号   public int getNumber()   {      return number;   }}</code></pre><p>下面的 BankDemo 程序示范了如何调用 CheckingAccount 类的 deposit() 和 withdraw() 方法。</p><p>BankDemo.java 文件代码：</p><pre><code>//文件名称 BankDemo.javapublic class BankDemo{   public static void main(String [] args)   {      CheckingAccount c = new CheckingAccount(101);      System.out.println(&quot;Depositing $500...&quot;);      c.deposit(500.00);      try      {         System.out.println(&quot;\nWithdrawing $100...&quot;);         c.withdraw(100.00);         System.out.println(&quot;\nWithdrawing $600...&quot;);         c.withdraw(600.00);      }catch(InsufficientFundsException e)      {         System.out.println(&quot;Sorry, but you are short $&quot;                                  + e.getAmount());         e.printStackTrace();      }    }}</code></pre><p>编译上面三个文件，并运行程序 BankDemo，得到结果如下所示：</p><pre><code>Depositing $500...Withdrawing $100...Withdrawing $600...Sorry, but you are short $200.0InsufficientFundsException        at CheckingAccount.withdraw(CheckingAccount.java:25)        at BankDemo.main(BankDemo.java:13)</code></pre><h2 id="通用异常"><a href="#通用异常" class="headerlink" title="通用异常"></a>通用异常</h2><p>在Java中定义了两种类型的异常和错误。</p><h3 id="JVM-Java虚拟机-异常："><a href="#JVM-Java虚拟机-异常：" class="headerlink" title="JVM(Java虚拟机) 异常："></a>JVM(Java虚拟机) 异常：</h3><p>由 JVM 抛出的异常或错误。例如：NullPointerException 类，ArrayIndexOutOfBoundsException 类，ClassCastException 类。</p><h3 id="程序级异常："><a href="#程序级异常：" class="headerlink" title="程序级异常："></a>程序级异常：</h3><p>由程序或者API程序抛出的异常。例如 IllegalArgumentException 类，IllegalStateException 类。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<br><a href="https://www.runoob.com/java/java-exceptions.html" target="_blank" rel="noopener">https://www.runoob.com/java/java-exceptions.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重新温习Java中的异常处理&lt;/p&gt;
    
    </summary>
    
      <category term="2019年8月" scheme="http://yoursite.com/categories/2019%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记I</title>
    <link href="http://yoursite.com/2019/08/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0I/"/>
    <id>http://yoursite.com/2019/08/06/Java学习笔记I/</id>
    <published>2019-08-06T07:12:12.000Z</published>
    <updated>2019-08-12T06:36:51.043Z</updated>
    
    <content type="html"><![CDATA[<p>重新温习Java中的抽象类和接口</p><a id="more"></a><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。</p><p>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。</p><p>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。</p><p>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。</p><p>在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p><p>在Java语言中使用abstract class来定义抽象类。如下实例：</p><p>Employee.java 文件代码：</p><pre><code>/* 文件名 : Employee.java */public abstract class Employee{   private String name;   private String address;   private int number;   public Employee(String name, String address, int number)   {      System.out.println(&quot;Constructing an Employee&quot;);      this.name = name;      this.address = address;      this.number = number;   }   public double computePay()   {     System.out.println(&quot;Inside Employee computePay&quot;);     return 0.0;   }   public void mailCheck()   {      System.out.println(&quot;Mailing a check to &quot; + this.name       + &quot; &quot; + this.address);   }   public String toString()   {      return name + &quot; &quot; + address + &quot; &quot; + number;   }   public String getName()   {      return name;   }   public String getAddress()   {      return address;   }   public void setAddress(String newAddress)   {      address = newAddress;   }   public int getNumber()   {     return number;   }}</code></pre><p>注意到该 Employee 类没有什么不同，尽管该类是抽象类，但是它仍然有 3 个成员变量，7 个成员方法和 1 个构造方法。 现在如果你尝试如下的例子：</p><p>AbstractDemo.java 文件代码：</p><pre><code>/* 文件名 : AbstractDemo.java */public class AbstractDemo{   public static void main(String [] args)   {      /* 以下是不允许的，会引发错误 */      Employee e = new Employee(&quot;George W.&quot;, &quot;Houston, TX&quot;, 43);      System.out.println(&quot;\n Call mailCheck using Employee reference--&quot;);      e.mailCheck();    }}</code></pre><p>当你尝试编译AbstractDemo类时，会产生如下错误：</p><pre><code>Employee.java:46: Employee is abstract; cannot be instantiated      Employee e = new Employee(&quot;George W.&quot;, &quot;Houston, TX&quot;, 43);                   ^1 error</code></pre><h2 id="继承抽象类"><a href="#继承抽象类" class="headerlink" title="继承抽象类"></a>继承抽象类</h2><p>我们能通过一般的方法继承Employee类：</p><p>Salary.java 文件代码：</p><pre><code>/* 文件名 : Salary.java */public class Salary extends Employee{   private double salary; //Annual salary   public Salary(String name, String address, int number, double      salary)   {       super(name, address, number);       setSalary(salary);   }   public void mailCheck()   {       System.out.println(&quot;Within mailCheck of Salary class &quot;);       System.out.println(&quot;Mailing check to &quot; + getName()       + &quot; with salary &quot; + salary);   }   public double getSalary()   {       return salary;   }   public void setSalary(double newSalary)   {       if(newSalary &gt;= 0.0)       {          salary = newSalary;       }   }   public double computePay()   {      System.out.println(&quot;Computing salary pay for &quot; + getName());      return salary/52;   }}</code></pre><p>尽管我们不能实例化一个 Employee 类的对象，但是如果我们实例化一个 Salary 类对象，该对象将从 Employee 类继承 7 个成员方法，且通过该方法可以设置或获取三个成员变量。</p><p>AbstractDemo.java 文件代码：</p><pre><code>/* 文件名 : AbstractDemo.java */public class AbstractDemo{   public static void main(String [] args)   {      Salary s = new Salary(&quot;Mohd Mohtashim&quot;, &quot;Ambehta, UP&quot;, 3, 3600.00);      Employee e = new Salary(&quot;John Adams&quot;, &quot;Boston, MA&quot;, 2, 2400.00);      System.out.println(&quot;Call mailCheck using Salary reference --&quot;);      s.mailCheck();      System.out.println(&quot;\n Call mailCheck using Employee reference--&quot;);      e.mailCheck();    }}</code></pre><p>以上程序编译运行结果如下：</p><pre><code>Constructing an EmployeeConstructing an EmployeeCall mailCheck using  Salary reference --Within mailCheck of Salary classMailing check to Mohd Mohtashim with salary 3600.0Call mailCheck using Employee reference--Within mailCheck of Salary classMailing check to John Adams with salary 2400.</code></pre><h2 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h2><p>如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。</p><p>Abstract 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。</p><p>抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。</p><pre><code>public abstract class Employee{   private String name;   private String address;   private int number;   public abstract double computePay();   //其余代码}</code></pre><p>声明抽象方法会造成以下两个结果：</p><p>如果一个类包含抽象方法，那么该类必须是抽象类。</p><p>任何子类必须重写父类的抽象方法，或者声明自身为抽象类。</p><p>继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。</p><p>如果Salary类继承了Employee类，那么它必须实现computePay()方法：</p><p>Salary.java 文件代码：</p><pre><code>/* 文件名 : Salary.java */public class Salary extends Employee{   private double salary; // Annual salary   public double computePay()   {      System.out.println(&quot;Computing salary pay for &quot; + getName());      return salary/52;   }   //其余代码}</code></pre><p>抽象类总结规定</p><ol><li><p>抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。</p></li><li><p>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p></li><li><p>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</p></li><li><p>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。</p></li><li><p>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</p></li></ol><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p><p>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。</p><p>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</p><p>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p><h2 id="接口与类相似点："><a href="#接口与类相似点：" class="headerlink" title="接口与类相似点："></a>接口与类相似点：</h2><p>一个接口可以有多个方法。</p><p>接口文件保存在 .java 结尾的文件中，文件名使用接口名。</p><p>接口的字节码文件保存在 .class 结尾的文件中。</p><p>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</p><h2 id="接口与类的区别："><a href="#接口与类的区别：" class="headerlink" title="接口与类的区别："></a>接口与类的区别：</h2><p>接口不能用于实例化对象。</p><p>接口没有构造方法。</p><p>接口中所有的方法必须是抽象方法。</p><p>接口不能包含成员变量，除了 static 和 final 变量。</p><p>接口不是被类继承了，而是要被类实现。</p><p>接口支持多继承。</p><h2 id="接口特性"><a href="#接口特性" class="headerlink" title="接口特性"></a>接口特性</h2><p>接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。</p><p>接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。</p><p>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。</p><h2 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h2><ol><li><p>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</p></li><li><p>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。</p></li><li><p>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</p></li><li><p>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p></li></ol><p>注：JDK 1.8 以后，接口里可以有静态方法和方法体了。</p><h2 id="接口的声明"><a href="#接口的声明" class="headerlink" title="接口的声明"></a>接口的声明</h2><p>接口的声明语法格式如下：</p><pre><code>[可见度] interface 接口名称 [extends 其他的接口名] {        // 声明变量        // 抽象方法}</code></pre><p>Interface关键字用来声明一个接口。下面是接口声明的一个简单例子。<br>NameOfInterface.java 文件代码：</p><pre><code>/* 文件名 : NameOfInterface.java */import java.lang.*;//引入包public interface NameOfInterface{   //任何类型 final, static 字段   //抽象方法}</code></pre><p>接口有以下特性：</p><p>接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。</p><p>接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键字。</p><p>接口中的方法都是公有的。</p><p>实例</p><pre><code>Animal.java 文件代码：/* 文件名 : Animal.java * /interface Animal {   public void eat();   public void travel();}</code></pre><h2 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h2><p>当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。</p><p>类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。</p><p>实现一个接口的语法，可以使用这个公式：</p><p>Animal.java 文件代码：</p><pre><code>...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ...</code></pre><p>实例<br>MammalInt.java 文件代码：</p><pre><code>/* 文件名 : MammalInt.java * /public class MammalInt implements Animal{   public void eat(){      System.out.println(&quot;Mammal eats&quot;);   }   public void travel(){      System.out.println(&quot;Mammal travels&quot;);   }   public int noOfLegs(){      return 0;   }   public static void main(String args[]){      MammalInt m = new MammalInt();      m.eat();      m.travel();   }}</code></pre><p>以上实例编译运行结果如下:</p><pre><code>Mammal eatsMammal travels</code></pre><p>重写接口中声明的方法时，需要注意以下规则：</p><p>类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。</p><p>类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。</p><p>如果实现接口的类是抽象类，那么就没必要实现该接口的方法。</p><p>在实现接口的时候，也要注意一些规则：</p><p>一个类可以同时实现多个接口。</p><p>一个类只能继承一个类，但是能实现多个接口。</p><p>一个接口能继承另一个接口，这和类之间的继承比较相似。</p><h2 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h2><p>一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。</p><p>下面的Sports接口被Hockey和Football接口继承：</p><pre><code>// 文件名: Sports.javapublic interface Sports{   public void setHomeTeam(String name);   public void setVisitingTeam(String name);}// 文件名: Football.javapublic interface Football extends Sports{   public void homeTeamScored(int points);   public void visitingTeamScored(int points);   public void endOfQuarter(int quarter);}// 文件名: Hockey.javapublic interface Hockey extends Sports{   public void homeGoalScored();   public void visitingGoalScored();   public void endOfPeriod(int period);   public void overtimePeriod(int ot);}</code></pre><p>Hockey接口自己声明了四个方法，从Sports接口继承了两个方法，这样，实现Hockey接口的类需要实现六个方法。</p><p>相似的，实现Football接口的类需要实现五个方法，其中两个来自于Sports接口。<br>接口的多继承</p><p>在Java中，类的多继承是不合法，但接口允许多继承。</p><p>在接口的多继承中extends关键字只需要使用一次，在其后跟着继承接口。 如下所示：</p><pre><code>public interface Hockey extends Sports, Event</code></pre><p>以上的程序片段是合法定义的子接口，与类不同的是，接口允许多继承，而 Sports及 Event 可能定义或是继承相同的方法</p><h2 id="标记接口"><a href="#标记接口" class="headerlink" title="标记接口"></a>标记接口</h2><p>最常用的继承接口是没有包含任何方法的接口。</p><p>标记接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。</p><p>标记接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。</p><p>例如：java.awt.event 包中的 MouseListener 接口继承的 java.util.EventListener 接口定义如下：</p><pre><code>package java.util;public interface EventListener{}</code></pre><p>没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的：</p><p>建立一个公共的父接口：</p><p>正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。</p><p>向一个类添加数据类型：</p><p>这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://www.runoob.com/java/java-abstraction.html" target="_blank" rel="noopener">https://www.runoob.com/java/java-abstraction.html</a></p><p>【2】<a href="https://www.runoob.com/java/java-interfaces.html" target="_blank" rel="noopener">https://www.runoob.com/java/java-interfaces.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重新温习Java中的抽象类和接口&lt;/p&gt;
    
    </summary>
    
      <category term="2019年8月" scheme="http://yoursite.com/categories/2019%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot学习笔记IX</title>
    <link href="http://yoursite.com/2019/08/05/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0IX/"/>
    <id>http://yoursite.com/2019/08/05/SpringBoot学习笔记IX/</id>
    <published>2019-08-05T03:22:12.000Z</published>
    <updated>2019-09-11T06:44:08.421Z</updated>
    
    <content type="html"><![CDATA[<p>CMS系统学习。</p><a id="more"></a><h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h1><p>cn.kael.query.inner中逻辑写在biz中，config/InnerDbConfig是内部数据库配置，<br>controller接口，dao数据库自动生成，</p><p>kael_query表中的tbl_jobs是定时任务相关的表,其中tag是标签名字，暂时是唯一索引，入参，不能改动，sql_note是sql语句内容，operator_no是操作者编号，cron是定时表达式，receiver是收件人，memo是备注内容，task_status是定时任务状态，datasoure_name要执行任务sql的数据源，out_type是输出类型（正文和附件）</p><p>增加定时任务的分页查询，包括附加条件的分页查询，比如模糊匹配名字，接收者的分页查询，固定时间范围内的分页查询,把分页查询都写到一个接口里，根据传进来的参数进行不同的查询。</p><p>增删改查完本地库，去Quartz 完成增删改查定时任务。用@Autowired注解注入</p><p>cn.creditease.std.query.kael.core.task.TaskManager</p><p>kaelContext.setEmailMode(tblJobsEntity.getOutType());</p><p>根据枚举的邮件输出类型设置emailMode为0或1</p><p>tbl_notes是笔记相关的表，tag是笔记名字，暂时不能改动，后面可以置为能改动的列，根据id来查，两张表都是tag和operator_no不能改动，其它可以改动</p><p>tbl_sql_warning 是SQL语句对应的表，</p><p>完成两张表到增删改查功能，在DatasourceInfoController中查询并返回可用的数据源列表。</p><p>中秋节前，9.12：<br>CMS业务分享PPT：<br>常用页面操作分享，<br>核心流程分享：进件流程，状态机修改流程，有哪些限制，<br>CMS常用表例如transport，history分享</p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p>出现找不到主类的错误首先将porm文件右键选择Add to the maven project添加到右侧到maven库中，然后再将工程文件右键Mark Directory as-&gt;Sources Root</p><p>java:程序包XXXX不存在</p><p>可以先删去导入的该包然后用快捷键Alt+Enter选择add to library搜索导入该包</p><p>不能全写到一个UserService里，要有相应的区分</p><p>ServiceImpl参数不能直接传实体，不利于可读性和可维护性，用哪些传哪些，里面只写数据库相关操作，涉及EntityMapper的，逻辑内容写到biz文件夹中,Service里返回Entity而不是DTO，biz中返回DTO</p><p>mybatis-config不用加到resources.local里面，在resources里面就行</p><p>config文件夹内还要有相应的数据库自动化配置和Mybatis配置文件</p><p>如果出现循环依赖的问题，例如query.inner和query.core相互依赖，则在两个子项目的porm.xml中去掉彼此的依赖项目</p><p>Maven执行clean和install在生命周期Lifecycle中选择相应的命令执行即可</p><p>pom.xml中的自动生成mapper.xml的依赖后期要注释掉，否则每次install maven都会覆盖掉原先的。</p><pre><code>CharacterEncoding=UTF-8&amp;autoReconnect=true&amp;failOverReadOnly=falsecom.mysql.jdbc.exceptions.jdbc4.MySQLNonTransientConnectionException: Could not create connection to database server. Attempted reconnect 3 times. Giving up.    at sun.reflect.GeneratedConstructorAccessor64.newInstance(Unknown Source)    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)    at java.lang.reflect.Constructor.newInstance(Constructor.java:423)</code></pre><h2 id="驼峰命名法"><a href="#驼峰命名法" class="headerlink" title="驼峰命名法"></a>驼峰命名法</h2><p>方法名开头字母要小写</p><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>之前处理异常的方法</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CMS系统学习。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年8月" scheme="http://yoursite.com/categories/2019%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="SpringBoot，Java" scheme="http://yoursite.com/tags/SpringBoot%EF%BC%8CJava/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot学习笔记VIII</title>
    <link href="http://yoursite.com/2019/08/05/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0VIII/"/>
    <id>http://yoursite.com/2019/08/05/SpringBoot学习笔记VIII/</id>
    <published>2019-08-05T03:22:12.000Z</published>
    <updated>2019-09-12T03:40:12.579Z</updated>
    
    <content type="html"><![CDATA[<p>CMS系统学习。</p><a id="more"></a><h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h1><p>先阅读cn.creditease.bdp.newcms.notice源码，定时相关，其中impl/CmsTaskNoticeHelperImpl/sendMsgByBatch函数是模块入口</p><h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><p>cn.creditease.bdp.newcms.cmswrapper.controller.PaymentScheduleController的源码，涉及到customer表，里面是借贷用户的信息</p><h2 id="阅读-1"><a href="#阅读-1" class="headerlink" title="阅读"></a>阅读</h2><p>cn.creditease.bdp.newcms.controller.creditreview.TransportController中的public Object create(@RequestBody(required = false) Transport transport)方法重点看FULL_FLOW，cn.creditease.bdp.newcms.service.creditreview.CreditFlowService.fullFlow中的评级部分代码</p><pre><code>CMSResponseCode cmsResponseCode = rateBoth(transport);</code></pre><p>和最后一段代码</p><pre><code>dataPrepareCheckAndCheckSuijieRule(transport);</code></pre><h2 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h2><p>cn.creditease.bdp.newcms.cmswrapper.controller.TransportQueryController中的getAll对应<a href="http://std-cms-fe.laincloud.xyz/#/incoming进件查询中的查询按钮，现在需要在标记一栏的返回值中加入新的返回信息。" target="_blank" rel="noopener">http://std-cms-fe.laincloud.xyz/#/incoming进件查询中的查询按钮，现在需要在标记一栏的返回值中加入新的返回信息。</a></p><p>cn.creditease.bdp.newcms.cmswrapper.service.cms.TransportQueryServiceTest中写测试样例</p><p>参见<a href="http://wiki.yxapp.in/pages/viewpage.action?pageId=68764493" target="_blank" rel="noopener">http://wiki.yxapp.in/pages/viewpage.action?pageId=68764493</a></p><p>/api/2.0/application/isDataloan/{transportId} 根据进件号查询是否为数据贷进件<br>在shangtongdai中site.conf.routes<br>controllers.api2.InternalApiController.isDataloan</p><p>/internal/api/v1/submitDebt 提交负债信息<br>在shangtongdai中site.conf.api2.routes<br>controllers.api.InternalApiController.submitDebt</p><p>先写submitDebt接口，即siteHelper.submitDebtInfo部分把商通贷中的逻辑写在cms中，scala-》Java</p><p>系统调用：Controller-&gt;Service-&gt;DAO-&gt;database<br>所以逻辑写在Service中，数据库操作写在DAO，一个方法做一件事，增强可读性。he</p><p>两个接口原先在shangtongdai中，用scala写成</p><p>现在需要迁移到cms中重构为Java</p><p>运行项目<br>sbt “project site” run</p><h1 id="系统介绍"><a href="#系统介绍" class="headerlink" title="系统介绍"></a>系统介绍</h1><p>最早的site系统，scala语言，编译运行比较慢，一小时左右，包括了application，postloan等所有系统</p><p>测试官网网址：<a href="http://shangtongdai.yxapp.xyz/newsite/?code=YANGKAI34#/loginReg/login" target="_blank" rel="noopener">http://shangtongdai.yxapp.xyz/newsite/?code=YANGKAI34#/loginReg/login</a></p><p>查询语句：</p><pre><code>select * from shangtongdai.users    where id in (      select user_id from shangtongdai.applications          where id in (                select application_id from shangtongdai.loans                      where loan_status_id=12 ))</code></pre><p>application系统：进件系统</p><p>巨星系统：数据中转</p><p>爬虫系统：爬取商户数据</p><p>miner系统：评级系统</p><p>postloan系统（贷后系统）</p><p>User系统：管理用户</p><p>User-refer系统：返还佣金</p><p>Report系统：做报表</p><p>Report-tool系统：基础查询</p><p>综合信贷系统：管理合同签约</p><p>新核心系统：管理还款计划表</p><p>结算系统：管理还款逻辑</p><p>添加店户会触发爬虫系统，爬取商户的数据，使用miner系统进行评级，巨星系统进行数据中转筛除。</p><p>评级通过之后，进件将由CMS系统进行审核，审核通过后，所有审核逻辑都在CMS系统中。</p><p>审核通过后，由postloan系统（贷后系统）处理，包括了：</p><p>1.合同管理：签约，管理状态,综合信贷系统管理合同签约</p><p>2.还款：还款计划表,新核心系统管理还款计划表</p><p>3.放款：结算系统管理还款逻辑</p><p>团队主要负责CMS，postloan和report，report-tool等系统。</p><p>application进件系统，爬虫系统，巨星系统，miner评级系统由进件团队负责。</p><p>CMS系统里有初审，复审，分发等36个状态。</p><p><strong><em>shangtongdai数据库表信息：</em></strong></p><p>transport表：进件表，维护进件状态，</p><p>transportlabel拒绝或接受打下标签</p><p>transportext 进件附加信息，以json格式存储（最重要）</p><p>transport_decisions:重大决策信息放款或其它</p><p>transport_assigned_history：客服分单给客户历史的信息</p><p>loan :合同</p><p>repayment：业务订单，用户还款会生成业务订单</p><p>loanrepayment：合同和业务订单的关系，一笔合同会有多笔订单</p><p>repayment_type字段，还款类型</p><p>repayment_order字段：</p><p>repaymenttags:业务订单信息</p><p>权限信息的相关表<br>privilege<br>role<br>role_privilege<br>user_role</p><p>任务相关的表<br>tb_cron_ini<br>cms_task</p><h1 id="CMS系统核心流程分析"><a href="#CMS系统核心流程分析" class="headerlink" title="CMS系统核心流程分析"></a>CMS系统核心流程分析</h1><p>核心流程有进件流程和状态机流程</p><h2 id="进件流程"><a href="#进件流程" class="headerlink" title="进件流程"></a>进件流程</h2><p>入口<br>cn.creditease.bdp.newcms.controller.creditreview.TransportController.create接口</p><h2 id="状态机流程"><a href="#状态机流程" class="headerlink" title="状态机流程"></a>状态机流程</h2><p>很多外界模块都会调用 NewtransportOpmachineServiceimpl/operateTransport<br>举例审核操作信审3.0系统 ，审核进件，批钱，批产品，校验身份，审核是否符合规定，可能也需要用户补充信息，例如电话核实信息，如果拒绝则调用信审系统，调用cms系统中cn.creditease.bdp.newcms.controller.creditreview.operate接口</p><p>目的是变换当前状态到下一个状态，其次是通知操作,label标定，记录备注都会调用状态机，状态不会改变。</p><h2 id="展示流程"><a href="#展示流程" class="headerlink" title="展示流程"></a>展示流程</h2><p>cms有页面，会串联很多系统有交互，会处理很多中间的进件流程。<br>比如applicatoin进件系统，当application将进件推给cms时，进件信息里很多存在transport_exts表中，CmsDetailController<br>chrome 右键检查可以看见请求，根据请求找代码</p><p>进件流程 ：画流程图<br>重点是transportService.create和fullflow两个</p><p>进件分为cn.creditease.bdp.newcms.dao.store检查是否有新进件，没有的话insert，待初审分配，<br>第二是重新进件</p><p>cn.creditease.bdp.newcms.service.creditreview.fullFlow<br>1.rateBoth full预估和partial预估<br>2.dataPrepareCheckAndCheckSuijieRule 随借 检查数据完整性是否能够推送到信审3.0，如果不够完整则创建redis任务，</p><p>#credit_audit<br>生产环境数据库，修改需要在yearning上提交工单，平时只能增加，不能修改或删除</p><h1 id="creditreview"><a href="#creditreview" class="headerlink" title="creditreview"></a>creditreview</h1><p>测试环境数据库<br>transport_assignee_history  分单处理历史,记录此进件该被谁处理了<br>transport_decisions 对一些进件状态需要重大改变的操作,都会存储此决策信息,此数据变更必会通知site、电销等系统,进行系统同步,当下一个操作状态为如下状态时,会生成decision<br>transport_labels 存储一些标签数据，不改变进件的状态，但可能以后会用到，所以打一个标签<br>transport_history 进件审核的历史信息<br>tb_cron_ini 定时任务配置<br>cms_task 定时任务记录表<br>customers 用户信息<br>transports 进件表，存储进件的基本信息状态<br>transport_states 进件状态<br>transport_exts 对一些外部系统操作,及外部系统调用返回结果的存储，以json格式存储<br>待审核-》初审-》复核</p><h1 id="页面显示"><a href="#页面显示" class="headerlink" title="页面显示"></a>页面显示</h1><p>在application.yml中</p><pre><code>cms-servlet-path: /cms/*cms-package-path: cn.creditease.bdp.newcms.cmswrapper.controller</code></pre><p>会在UserRequestRecordInterceptor中对相应请求做记录，然后自动的将有/cms/*的 HTTP请求转入相应的controller包中去<br>通过页面查询时检查-》Network-》All-》Headers可查询到相应的url，再通过url查询到相应接口</p><h2 id="进件查询"><a href="#进件查询" class="headerlink" title="进件查询"></a>进件查询</h2><p>身份证照片：cn.creditease.bdp.newcms.cmswrapper.controller.IDAddrContactController<br>常用联系人、地址、提款银行卡查询： cn.creditease.bdp.newcms.cmswrapper.controller.IDAddrContactController<br>姨搜查重，ID5查询：cn.creditease.bdp.newcms.cmswrapper.controller.cms4.CmsDetailController<br>外贸信息，内贸信息，数据贷信息，数据贷汇总信息，cms上传银行流水，评级信息,进件历史,信审平台查重，外部平台信息，企业材料：cn.creditease.bdp.newcms.cmswrapper.controller.cms4.CmsDetailController<br>对公银行流水：cn.creditease.bdp.newcms.cmswrapper.controller.BankFlowController<br>人行征信报告：cn.creditease.bdp.newcms.cmswrapper.controller.BankCreditReportController<br>个人银行流水：cn.creditease.bdp.newcms.cmswrapper.controller.BankFlowController<br>           cn.creditease.bdp.newcms.cmswrapper.controller.cms4.CmsDetailController<br>信审记录：cn.creditease.bdp.newcms.cmswrapper.controller.AuditRecordController<br>实地征信报告：cn.creditease.bdp.newcms.cmswrapper.controller.app.FieldQualifyAppOperatorController<br>还款计划表：cn.creditease.bdp.newcms.controller.creditreview.TransportController<br>姨搜归户：cn.creditease.bdp.newcms.cmswrapper.controller.YisouRegisterController</p><h2 id="客服："><a href="#客服：" class="headerlink" title="客服："></a>客服：</h2><p>cn.creditease.bdp.newcms.cmswrapper.controller.task.CustomerServiceTaskController</p><h2 id="初审"><a href="#初审" class="headerlink" title="初审"></a>初审</h2><h2 id="终审"><a href="#终审" class="headerlink" title="终审"></a>终审</h2><h2 id="复核"><a href="#复核" class="headerlink" title="复核"></a>复核</h2><h2 id="实地征信："><a href="#实地征信：" class="headerlink" title="实地征信："></a>实地征信：</h2><p>cn.creditease.bdp.newcms.cmswrapper.controller.cms3.FieldNewController</p><h2 id="反欺诈"><a href="#反欺诈" class="headerlink" title="反欺诈"></a>反欺诈</h2><h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理:"></a>权限管理:</h2><p>用户管理：cn.creditease.bdp.newcms.cmswrapper.controller.PrivilegeController<br>客服分单池：cn.creditease.bdp.newcms.cmswrapper.controller.assigneepool.CustomerServiceAssigneePoolController</p><h1 id="和其他系统消息同步"><a href="#和其他系统消息同步" class="headerlink" title="和其他系统消息同步"></a>和其他系统消息同步</h1><p>cn.creditease.bdp.newcms.service.creditreview.external  信息同步接口<br>例如推送信审3 Credit3Helper-》Credit3Service等<br>同步接口=》Credit3Controller<br>进件接口=》大批量数据<br>手动进件接口<br>同步接口-》同步时同步状态<br>手动同步接口</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<br><a href="https://blog.csdn.net/weixin_34112900/article/details/93630203" target="_blank" rel="noopener">https://blog.csdn.net/weixin_34112900/article/details/93630203</a><br>【2】<br><a href="http://wiki.yxapp.in/pages/viewpage.action?pageId=65372471" target="_blank" rel="noopener">http://wiki.yxapp.in/pages/viewpage.action?pageId=65372471</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CMS系统学习。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年8月" scheme="http://yoursite.com/categories/2019%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="SpringBoot，Java" scheme="http://yoursite.com/tags/SpringBoot%EF%BC%8CJava/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot学习笔记VII</title>
    <link href="http://yoursite.com/2019/08/01/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0VII/"/>
    <id>http://yoursite.com/2019/08/01/SpringBoot学习笔记VII/</id>
    <published>2019-08-01T09:12:12.000Z</published>
    <updated>2019-08-12T06:47:27.067Z</updated>
    
    <content type="html"><![CDATA[<p>CMS系统学习，对常用到的注解做详解</p><a id="more"></a><h1 id="CMS系统简介"><a href="#CMS系统简介" class="headerlink" title="CMS系统简介"></a>CMS系统简介</h1><p>内容管理系统（英语：content management system，缩写为 CMS）是指在一个合作模式下，用于管理工作流程的一套制度。该系统可应用于手工操作中，也可以应用到计算机或网络里。作为一种中央储存器（central repository），内容管理系统可将相关内容集中储存并具有群组管理、版本控制等功能。版本控制是内容管理系统的一个主要优势。<br>内容管理系统在物品或文案或数据的存储、掌管、修订（盘存）、语用充实、文档发布等方面有着广泛的应用。现在流行的开源CMS系统有WordPress、Joomla!、Drupal、Xoops、CmsTop等。</p><h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><p>进件 Transport 业务上增加贷款或商户的操作。</p><h1 id="任务描述"><a href="#任务描述" class="headerlink" title="任务描述"></a>任务描述</h1><h2 id="实现查询接口"><a href="#实现查询接口" class="headerlink" title="实现查询接口"></a>实现查询接口</h2><p>saas-cms 的Respository中建立自己的分支，在controller/creditreview/TransportController中画出getAllProcessHistory函数的流程图，自己重新实现一个查询接口<br>数据库配置文件在resources.local/application.yml中<br>使用的数据库是：jdbc:mysql://10.143.248.78:3306/creditreview?</p><p>其中该函数根据GET请求/{transportId}/{attr}中的attr参数（花括号内为参数值）查询相应的数据库transportLabel、transportExt、transportProcessHistory、transportDecision四个数据库</p><h2 id="画出putExts函数流程图（周一上午提交）"><a href="#画出putExts函数流程图（周一上午提交）" class="headerlink" title="画出putExts函数流程图（周一上午提交）"></a>画出putExts函数流程图（周一上午提交）</h2><h2 id="CMS排查问题记录"><a href="#CMS排查问题记录" class="headerlink" title="CMS排查问题记录"></a>CMS排查问题记录</h2><p>入手学习CMS系统</p><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>handler method 参数绑定常用的注解,根据处理的Request的不同内容部分分为四类：（主要讲解常用类型）</p><p>A、处理request uri 部分（这里指uri template中variable，不含queryString部分）的注解：@PathVariable;</p><p>B、处理request header部分的注解：   @RequestHeader, @CookieValue;</p><p>C、处理request body部分的注解：@RequestParam,  @RequestBody;</p><p>D、处理attribute类型是注解： @SessionAttributes, @ModelAttribute;</p><h2 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h2><p>当使用@RequestMapping URI template 样式映射时， 即 someUrl/{paramId}, 这时的paramId可通过 @Pathvariable注解绑定它传过来的值到方法的参数上。</p><p>示例代码：</p><pre><code>@Controller@RequestMapping(&quot;/owners/{ownerId}&quot;)public class RelativePathUriTemplateController {  @RequestMapping(&quot;/pets/{petId}&quot;)  public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) {        // implementation omitted  }}</code></pre><p>上面代码把URI template 中变量 ownerId的值和petId的值，绑定到方法的参数上。若方法参数名称和需要绑定的uri template中变量名称不一致，需要在@PathVariable(“name”)指定uri template中的名称。</p><h2 id="RequestHeader、-CookieValue"><a href="#RequestHeader、-CookieValue" class="headerlink" title="@RequestHeader、@CookieValue"></a>@RequestHeader、@CookieValue</h2><p><strong><em>@RequestHeader注解，可以把Request请求header部分的值绑定到方法的参数上。</em></strong></p><p>示例代码：</p><p>这是一个Request 的header部分：</p><pre><code>Host                    localhost:8080Accept                  text/html,application/xhtml+xml,application/xml;q=0.9Accept-Language         fr,en-gb;q=0.7,en;q=0.3Accept-Encoding         gzip,deflateAccept-Charset          ISO-8859-1,utf-8;q=0.7,*;q=0.7Keep-Alive              300</code></pre><p>下面的代码，把request header部分的 Accept-Encoding的值，绑定到参数encoding上了， Keep-Alive header的值绑定到参数keepAlive上。</p><pre><code>@RequestMapping(&quot;/displayHeaderInfo.do&quot;)public void displayHeaderInfo(@RequestHeader(&quot;Accept-Encoding&quot;) String encoding,                              @RequestHeader(&quot;Keep-Alive&quot;) long keepAlive)  {  //...}</code></pre><p><strong><em>@CookieValue 可以把Request header中关于cookie的值绑定到方法的参数上。</em></strong></p><p>例如有如下Cookie值：</p><pre><code>JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84</code></pre><p>参数绑定的代码：</p><pre><code>@RequestMapping(&quot;/displayHeaderInfo.do&quot;)public void displayHeaderInfo(@CookieValue(&quot;JSESSIONID&quot;) String cookie)  {  //...}</code></pre><p>即把JSESSIONID的值绑定到参数cookie上。</p><h2 id="RequestParam-RequestBody"><a href="#RequestParam-RequestBody" class="headerlink" title="@RequestParam, @RequestBody"></a>@RequestParam, @RequestBody</h2><h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h3><p>A） 常用来处理简单类型的绑定，通过Request.getParameter() 获取的String可直接转换为简单类型的情况（ String–&gt; 简单类型的转换操作由ConversionService配置的转换器来完成）；因为使用request.getParameter()方式获取参数，所以可以处理get 方式中queryString的值，也可以处理post方式中 body data的值；</p><p>B）用来处理Content-Type: 为 application/x-www-form-urlencoded编码的内容，提交方式GET、POST；</p><p>C) 该注解有两个属性： value、required； value用来指定要传入值的id名称，required用来指示参数是否必须绑定；</p><p>示例代码：</p><pre><code>@Controller@RequestMapping(&quot;/pets&quot;)@SessionAttributes(&quot;pet&quot;)public class EditPetForm {    // ...    @RequestMapping(method = RequestMethod.GET)    public String setupForm(@RequestParam(&quot;petId&quot;) int petId, ModelMap model) {        Pet pet = this.clinic.loadPet(petId);        model.addAttribute(&quot;pet&quot;, pet);        return &quot;petForm&quot;;    }    // ...</code></pre><h3 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h3><p>该注解常用来处理Content-Type: 不是application/x-www-form-urlencoded编码的内容，例如application/json, application/xml等；</p><p>它是通过使用HandlerAdapter 配置的HttpMessageConverters来解析post data body，然后绑定到相应的bean上的。</p><p>因为配置有FormHttpMessageConverter，所以也可以用来处理 application/x-www-form-urlencoded的内容，处理完的结果放在一个MultiValueMap&lt;String, String&gt;里，这种情况在某些特殊需求下使用，详情查看FormHttpMessageConverter api;</p><p>示例代码：</p><pre><code>@RequestMapping(value = &quot;/something&quot;, method = RequestMethod.PUT)public void handle(@RequestBody String body, Writer writer) throws IOException {  writer.write(body);</code></pre><h2 id="SessionAttributes-ModelAttribute"><a href="#SessionAttributes-ModelAttribute" class="headerlink" title="@SessionAttributes, @ModelAttribute"></a>@SessionAttributes, @ModelAttribute</h2><h3 id="SessionAttributes"><a href="#SessionAttributes" class="headerlink" title="@SessionAttributes:"></a>@SessionAttributes:</h3><p>该注解用来绑定HttpSession中的attribute对象的值，便于在方法中的参数里使用。</p><p>该注解有value、types两个属性，可以通过名字和类型指定要使用的attribute 对象；</p><p>示例代码：</p><pre><code>@Controller@RequestMapping(&quot;/editPet.do&quot;)@SessionAttributes(&quot;pet&quot;)public class EditPetForm {    // ...}</code></pre><h3 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a>@ModelAttribute</h3><p>该注解有两个用法，一个是用于方法上，一个是用于参数上；</p><p>用于方法上时：  通常用来在处理@RequestMapping之前，为请求绑定需要从后台查询的model；</p><p>用于参数上时： 用来通过名称对应，把相应名称的值绑定到注解的参数bean上；要绑定的值来源于：</p><p>A） @SessionAttributes 启用的attribute 对象上；</p><p>B） @ModelAttribute 用于方法上时指定的model对象；</p><p>C） 上述两种情况都没有时，new一个需要绑定的bean对象，然后把request中按名称对应的方式把值绑定到bean中。</p><p>用到方法上@ModelAttribute的示例代码：</p><pre><code>// Add one attribute// The return value of the method is added to the model under the name &quot;account&quot;// You can customize the name via @ModelAttribute(&quot;myAccount&quot;)@ModelAttributepublic Account addAccount(@RequestParam String number) {    return accountManager.findAccount(number);}</code></pre><p>这种方式实际的效果就是在调用@RequestMapping的方法之前，为request对象的model里put（“account”， Account）；</p><p>用在参数上的@ModelAttribute示例代码：</p><pre><code>@RequestMapping(value=&quot;/owners/{ownerId}/pets/{petId}/edit&quot;, method = RequestMethod.POST)public String processSubmit(@ModelAttribute Pet pet) {}</code></pre><p>首先查询 @SessionAttributes有无绑定的Pet对象，若没有则查询@ModelAttribute方法层面上是否绑定了Pet对象，若没有则将URI template中的值按对应的名称绑定到Pet对象的各属性上。</p><h2 id="在不给定注解的情况下，参数是怎样绑定的？"><a href="#在不给定注解的情况下，参数是怎样绑定的？" class="headerlink" title="在不给定注解的情况下，参数是怎样绑定的？"></a>在不给定注解的情况下，参数是怎样绑定的？</h2><p>通过分析AnnotationMethodHandlerAdapter和RequestMappingHandlerAdapter的源代码发现，方法的参数在不给定参数的情况下：</p><p>若要绑定的对象时简单类型：  调用@RequestParam来处理的。 </p><p>若要绑定的对象时复杂类型：  调用@ModelAttribute来处理的。</p><p>这里的简单类型指java的原始类型(boolean, int 等)、原始类型对象（Boolean, Int等）、String、Date等ConversionService里可以直接String转换成目标对象的类型；</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://blog.csdn.net/walkerJong/article/details/7946109" target="_blank" rel="noopener">https://blog.csdn.net/walkerJong/article/details/7946109</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CMS系统学习，对常用到的注解做详解&lt;/p&gt;
    
    </summary>
    
      <category term="2019年8月" scheme="http://yoursite.com/categories/2019%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
</feed>
