<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-10-06T11:23:41.870Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>146. LRU缓存机制</title>
    <link href="http://yoursite.com/2020/10/06/146.%20LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2020/10/06/146. LRU缓存机制/</id>
    <published>2020-10-06T02:03:12.000Z</published>
    <updated>2020-10-06T11:23:41.870Z</updated>
    
    <content type="html"><![CDATA[<p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。</p><a id="more"></a><p>它应该支持以下操作： </p><pre><code>获取数据 get 和 写入数据 put 。获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</code></pre><p>进阶:</p><pre><code>你是否可以在 O(1) 时间复杂度内完成这两种操作？</code></pre><p>示例:</p><pre><code>LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );cache.put(1, 1);cache.put(2, 2);cache.get(1);       // 返回  1cache.put(3, 3);    // 该操作会使得关键字 2 作废cache.get(2);       // 返回 -1 (未找到)cache.put(4, 4);    // 该操作会使得关键字 1 作废cache.get(1);       // 返回 -1 (未找到)cache.get(3);       // 返回  3cache.get(4);       // 返回  4</code></pre><h1 id="📺-视频题解"><a href="#📺-视频题解" class="headerlink" title="📺 视频题解"></a>📺 视频题解</h1><p><a href="42b5ca6a-4d69-4f7d-bf63-5c196aa23b44">146. LRU缓存机制.mp4</a></p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>实现本题的两种操作，需要用到一个哈希表和一个双向链表。在面试中，面试官一般会期望读者能够自己实现一个简单的双向链表，而不是使用语言自带的、封装好的数据结构。在 <code>Python</code> 语言中，有一种结合了哈希表与双向链表的数据结构 <code>OrderedDict</code>，只需要短短的几行代码就可以完成本题。在 <code>Java</code> 语言中，同样有类似的数据结构 <code>LinkedHashMap</code>。这些做法都不会符合面试官的要求，因此下面只给出使用封装好的数据结构实现的代码，而不多做任何阐述。</p><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[sol0-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span><span class="params">(collections.OrderedDict)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity: int)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.capacity = capacity</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        self.move_to_end(key)</span><br><span class="line">        <span class="keyword">return</span> self[key]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key: int, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self:</span><br><span class="line">            self.move_to_end(key)</span><br><span class="line">        self[key] = value</span><br><span class="line">        <span class="keyword">if</span> len(self) &gt; self.capacity:</span><br><span class="line">            self.popitem(last=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol0-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">Integer</span>, <span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(capacity, <span class="number">0.75F</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getOrDefault(key, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; capacity; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="方法一：哈希表-双向链表"><a href="#方法一：哈希表-双向链表" class="headerlink" title="方法一：哈希表 + 双向链表"></a>方法一：哈希表 + 双向链表</h2><p><strong>算法</strong></p><p>LRU 缓存机制可以通过哈希表辅以双向链表实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。</p><ul><li><p>双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。</p></li><li><p>哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。</p></li></ul><p>这样以来，我们首先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部，即可在 <em>O(1)</em> 的时间内完成 <code>get</code> 或者 <code>put</code> 操作。具体的方法如下：</p><ul><li><p>对于 <code>get</code> 操作，首先判断 <code>key</code> 是否存在：</p><ul><li><p>如果 <code>key</code> 不存在，则返回 <em>-1</em>；</p></li><li><p>如果 <code>key</code> 存在，则 <code>key</code> 对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值。</p></li></ul></li><li><p>对于 <code>put</code> 操作，首先判断 <code>key</code> 是否存在：</p><ul><li><p>如果 <code>key</code> 不存在，使用 <code>key</code> 和 <code>value</code> 创建一个新的节点，在双向链表的头部添加该节点，并将 <code>key</code> 和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项；</p></li><li><p>如果 <code>key</code> 存在，则与 <code>get</code> 操作类似，先通过哈希表定位，再将对应的节点的值更新为 <code>value</code>，并将该节点移到双向链表的头部。</p></li></ul></li></ul><p>上述各项操作中，访问哈希表的时间复杂度为 <em>O(1)<em>，在双向链表的头部添加节点、在双向链表的尾部删除节点的复杂度也为 *O(1)</em>。而将一个节点移到双向链表的头部，可以分成「删除该节点」和「在双向链表的头部添加节点」两步操作，都可以在 *O(1)</em> 时间内完成。</p><p><strong>小贴士</strong></p><p>在双向链表的实现中，使用一个<strong>伪头部</strong>（dummy head）和<strong>伪尾部</strong>（dummy tail）标记界限，这样在添加节点和删除节点的时候就不需要检查相邻的节点是否存在。</p><p> <a href="https://assets.leetcode-cn.com/solution-static/146/1.PNG" target="_blank" rel="noopener">fig1</a> <a href="https://assets.leetcode-cn.com/solution-static/146/2.PNG" target="_blank" rel="noopener">fig2</a> <a href="https://assets.leetcode-cn.com/solution-static/146/3.PNG" target="_blank" rel="noopener">fig3</a> <a href="https://assets.leetcode-cn.com/solution-static/146/4.PNG" target="_blank" rel="noopener">fig4</a> <a href="https://assets.leetcode-cn.com/solution-static/146/5.PNG" target="_blank" rel="noopener">fig5</a> <a href="https://assets.leetcode-cn.com/solution-static/146/6.PNG" target="_blank" rel="noopener">fig6</a> <a href="https://assets.leetcode-cn.com/solution-static/146/7.PNG" target="_blank" rel="noopener">fig7</a> <a href="https://assets.leetcode-cn.com/solution-static/146/8.PNG" target="_blank" rel="noopener">fig8</a> <a href="https://assets.leetcode-cn.com/solution-static/146/9.PNG" target="_blank" rel="noopener">fig9</a> <a href="https://assets.leetcode-cn.com/solution-static/146/10.PNG" target="_blank" rel="noopener">fig10</a> </p><details>    <summary>哈希表 + 双向链表Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DLinkedNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, key=<span class="number">0</span>, value=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.value = value</span><br><span class="line">        self.prev = <span class="keyword">None</span></span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity: int)</span>:</span></span><br><span class="line">        self.cache = dict()</span><br><span class="line">        <span class="comment"># 使用伪头部和伪尾部节点    </span></span><br><span class="line">        self.head = DLinkedNode()</span><br><span class="line">        self.tail = DLinkedNode()</span><br><span class="line">        self.head.next = self.tail</span><br><span class="line">        self.tail.prev = self.head</span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.cache:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="comment"># 如果 key 存在，先通过哈希表定位，再移到头部</span></span><br><span class="line">        node = self.cache[key]</span><br><span class="line">        self.moveToHead(node)</span><br><span class="line">        <span class="keyword">return</span> node.value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key: int, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.cache:</span><br><span class="line">            <span class="comment"># 如果 key 不存在，创建一个新的节点</span></span><br><span class="line">            node = DLinkedNode(key, value)</span><br><span class="line">            <span class="comment"># 添加进哈希表</span></span><br><span class="line">            self.cache[key] = node</span><br><span class="line">            <span class="comment"># 添加至双向链表的头部</span></span><br><span class="line">            self.addToHead(node)</span><br><span class="line">            self.size += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.size &gt; self.capacity:</span><br><span class="line">                <span class="comment"># 如果超出容量，删除双向链表的尾部节点</span></span><br><span class="line">                removed = self.removeTail()</span><br><span class="line">                <span class="comment"># 删除哈希表中对应的项</span></span><br><span class="line">                self.cache.pop(removed.key)</span><br><span class="line">                self.size -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span></span><br><span class="line">            node = self.cache[key]</span><br><span class="line">            node.value = value</span><br><span class="line">            self.moveToHead(node)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addToHead</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        node.prev = self.head</span><br><span class="line">        node.next = self.head.next</span><br><span class="line">        self.head.next.prev = node</span><br><span class="line">        self.head.next = node</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNode</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        node.prev.next = node.next</span><br><span class="line">        node.next.prev = node.prev</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveToHead</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        self.removeNode(node)</span><br><span class="line">        self.addToHead(node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeTail</span><span class="params">(self)</span>:</span></span><br><span class="line">        node = self.tail.prev</span><br><span class="line">        self.removeNode(node)</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure></details><details>    <summary>哈希表 + 双向链表Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DLinkedNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        DLinkedNode prev;</span><br><span class="line">        DLinkedNode next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DLinkedNode</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DLinkedNode</span><span class="params">(<span class="keyword">int</span> _key, <span class="keyword">int</span> _value)</span> </span>&#123;key = _key; value = _value;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, DLinkedNode&gt; cache = <span class="keyword">new</span> HashMap&lt;Integer, DLinkedNode&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> DLinkedNode head, tail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        <span class="comment">// 使用伪头部和伪尾部节点</span></span><br><span class="line">        head = <span class="keyword">new</span> DLinkedNode();</span><br><span class="line">        tail = <span class="keyword">new</span> DLinkedNode();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        DLinkedNode node = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 key 存在，先通过哈希表定位，再移到头部</span></span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        DLinkedNode node = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果 key 不存在，创建一个新的节点</span></span><br><span class="line">            DLinkedNode newNode = <span class="keyword">new</span> DLinkedNode(key, value);</span><br><span class="line">            <span class="comment">// 添加进哈希表</span></span><br><span class="line">            cache.put(key, newNode);</span><br><span class="line">            <span class="comment">// 添加至双向链表的头部</span></span><br><span class="line">            addToHead(newNode);</span><br><span class="line">            ++size;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">                <span class="comment">// 如果超出容量，删除双向链表的尾部节点</span></span><br><span class="line">                DLinkedNode tail = removeTail();</span><br><span class="line">                <span class="comment">// 删除哈希表中对应的项</span></span><br><span class="line">                cache.remove(tail.key);</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span></span><br><span class="line">            node.value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(DLinkedNode node)</span> </span>&#123;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.prev = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(DLinkedNode node)</span> </span>&#123;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(DLinkedNode node)</span> </span>&#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> DLinkedNode <span class="title">removeTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DLinkedNode res = tail.prev;</span><br><span class="line">        removeNode(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>哈希表 + 双向链表C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DLinkedNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key, value;</span><br><span class="line">    DLinkedNode* prev;</span><br><span class="line">    DLinkedNode* next;</span><br><span class="line">    DLinkedNode(): key(<span class="number">0</span>), value(<span class="number">0</span>), prev(<span class="literal">nullptr</span>), next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    DLinkedNode(<span class="keyword">int</span> _key, <span class="keyword">int</span> _value): key(_key), value(_value), prev(<span class="literal">nullptr</span>), next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, DLinkedNode*&gt; cache;</span><br><span class="line">    DLinkedNode* head;</span><br><span class="line">    DLinkedNode* tail;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LRUCache(<span class="keyword">int</span> _capacity): capacity(_capacity), size(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用伪头部和伪尾部节点</span></span><br><span class="line">        head = <span class="keyword">new</span> DLinkedNode();</span><br><span class="line">        tail = <span class="keyword">new</span> DLinkedNode();</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache.count(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 key 存在，先通过哈希表定位，再移到头部</span></span><br><span class="line">        DLinkedNode* node = cache[key];</span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache.count(key)) &#123;</span><br><span class="line">            <span class="comment">// 如果 key 不存在，创建一个新的节点</span></span><br><span class="line">            DLinkedNode* node = <span class="keyword">new</span> DLinkedNode(key, value);</span><br><span class="line">            <span class="comment">// 添加进哈希表</span></span><br><span class="line">            cache[key] = node;</span><br><span class="line">            <span class="comment">// 添加至双向链表的头部</span></span><br><span class="line">            addToHead(node);</span><br><span class="line">            ++size;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">                <span class="comment">// 如果超出容量，删除双向链表的尾部节点</span></span><br><span class="line">                DLinkedNode* removed = removeTail();</span><br><span class="line">                <span class="comment">// 删除哈希表中对应的项</span></span><br><span class="line">                cache.erase(removed-&gt;key);</span><br><span class="line">                <span class="comment">// 防止内存泄漏</span></span><br><span class="line">                <span class="keyword">delete</span> removed;</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span></span><br><span class="line">            DLinkedNode* node = cache[key];</span><br><span class="line">            node-&gt;value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;prev = head;</span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next-&gt;prev = node;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">DLinkedNode* <span class="title">removeTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DLinkedNode* node = tail-&gt;prev;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>哈希表 + 双向链表Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    size <span class="keyword">int</span></span><br><span class="line">    capacity <span class="keyword">int</span></span><br><span class="line">    cache <span class="keyword">map</span>[<span class="keyword">int</span>]*DLinkedNode</span><br><span class="line">    head, tail *DLinkedNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DLinkedNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    key, value <span class="keyword">int</span></span><br><span class="line">    prev, next *DLinkedNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initDLinkedNode</span><span class="params">(key, value <span class="keyword">int</span>)</span> *<span class="title">DLinkedNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;DLinkedNode&#123;</span><br><span class="line">        key: key,</span><br><span class="line">        value: value,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="keyword">int</span>)</span> <span class="title">LRUCache</span></span> &#123;</span><br><span class="line">    l := LRUCache&#123;</span><br><span class="line">        cache: <span class="keyword">map</span>[<span class="keyword">int</span>]*DLinkedNode&#123;&#125;,</span><br><span class="line">        head: initDLinkedNode(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        tail: initDLinkedNode(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        capacity: capacity,</span><br><span class="line">    &#125;</span><br><span class="line">    l.head.next = l.tail</span><br><span class="line">    l.tail.prev = l.head</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _, ok := this.cache[key]; !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    node := this.cache[key]</span><br><span class="line">    this.moveToHead(node)</span><br><span class="line">    <span class="keyword">return</span> node.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">Put</span><span class="params">(key <span class="keyword">int</span>, value <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">if</span> _, ok := this.cache[key]; !ok &#123;</span><br><span class="line">        node := initDLinkedNode(key, value)</span><br><span class="line">        this.cache[key] = node</span><br><span class="line">        this.addToHead(node)</span><br><span class="line">        this.size++</span><br><span class="line">        <span class="keyword">if</span> this.size &gt; this.capacity &#123;</span><br><span class="line">            removed := this.removeTail()</span><br><span class="line">            <span class="built_in">delete</span>(this.cache, removed.key)</span><br><span class="line">            this.size--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node := this.cache[key]</span><br><span class="line">        node.value = value</span><br><span class="line">        this.moveToHead(node)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">addToHead</span><span class="params">(node *DLinkedNode)</span></span> &#123;</span><br><span class="line">    node.prev = this.head</span><br><span class="line">    node.next = this.head.next</span><br><span class="line">    this.head.next.prev = node</span><br><span class="line">    this.head.next = node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">removeNode</span><span class="params">(node *DLinkedNode)</span></span> &#123;</span><br><span class="line">    node.prev.next = node.next</span><br><span class="line">    node.next.prev = node.prev</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">moveToHead</span><span class="params">(node *DLinkedNode)</span></span> &#123;</span><br><span class="line">    this.removeNode(node)</span><br><span class="line">    this.addToHead(node)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">removeTail</span><span class="params">()</span> *<span class="title">DLinkedNode</span></span> &#123;</span><br><span class="line">    node := this.tail.prev</span><br><span class="line">    this.removeNode(node)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>**复杂度分析**<ul><li><p>时间复杂度：对于 <code>put</code> 和 <code>get</code> 都是 <em>O(1)</em>。</p></li><li><p>空间复杂度：O(capacity) ，因为哈希表和双向链表最多存储 capacity+1 个元素。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年10月" scheme="http://yoursite.com/categories/2020%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Greedy" scheme="http://yoursite.com/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>134. 加油站</title>
    <link href="http://yoursite.com/2020/10/05/134.%20%E5%8A%A0%E6%B2%B9%E7%AB%99/"/>
    <id>http://yoursite.com/2020/10/05/134. 加油站/</id>
    <published>2020-10-04T17:17:12.000Z</published>
    <updated>2020-10-06T02:02:06.728Z</updated>
    
    <content type="html"><![CDATA[<p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p><a id="more"></a><p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p><p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p><p>说明: </p><p>如果题目有解，该答案即为唯一答案。<br>输入数组均为非空数组，且长度相同。<br>输入数组中的元素均为非负数。<br>示例 1:</p><pre><code>输入: gas  = [1,2,3,4,5]cost = [3,4,5,1,2]输出: 3解释:从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。因此，3 可为起始索引。</code></pre><p>示例 2:</p><pre><code>输入: gas  = [2,3,4]cost = [3,4,3]输出: -1解释:你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。因此，无论怎样，你都不可能绕环路行驶一周。</code></pre><h1 id="方法：一次遍历"><a href="#方法：一次遍历" class="headerlink" title="方法：一次遍历"></a>方法：一次遍历</h1><p><strong>想法</strong></p><p>第一想法是检查每一个加油站：</p><ul><li><p>选择该加油站为出发站</p></li><li><p>模拟汽车环路行驶，在每一个加油站检查我们还剩多少升汽油。</p></li></ul><p>这意味着 O(N^2)的时间复杂度。显然，我们可以做得更好。</p><p>首先注意两件事情：</p><blockquote><p>如果 <code>sum(gas) &lt; sum(cost)</code> ，那么不可能环行一圈，这种情况下答案是 <code>-1</code> 。</p></blockquote><p><a href="https://pic.leetcode-cn.com/4381241b2ed28ee64703425af2e6a4ddb85df5dad25d644c89d7bdbcd2927c8b-image.png" target="_blank" rel="noopener">image.png</a></p><p>我们可以用这个式子计算环行过程中邮箱里剩下的油：<code>total_tank = sum(gas) - sum(cost)</code>  ，如果 <code>total_tank &lt; 0</code> 则返回 <code>-1</code> 。</p><blockquote><p>对于加油站 <code>i</code> ，如果 <code>gas[i] - cost[i] &lt; 0</code> ，则不可能从这个加油站出发，因为在前往 <code>i + 1</code> 的过程中，汽油就不够了。</p></blockquote><p><a href="https://pic.leetcode-cn.com/5f9a6f57444dc93f334fdb782f4368e3863888b82fc90d4f9b490eeb53cf86fe-image.png" target="_blank" rel="noopener">image.png</a></p><p>第二个规则可以被一般化，我们引入变量 <code>curr_tank</code> ，记录当前油箱里剩余的总油量。如果在某一个加油站 <code>curr_tank</code>比 <code>0</code> 小，意味着我们无法到达这个加油站。<strong>一个站的收益如果小于0，肯定不能作为起点；而连续的多个站也可以等效地看做一个站，如果其累积收益小于0，就跳过，寻找下一个。</strong></p><p>下一步我们把这个加油站当做新的起点，并将 <code>curr_tank</code> 重置为 0 ，因为重新出发，油箱中的油为 0 。（从上一次重置的加油站到当前加油站的任意一个加油站出发，到达当前加油站之前， <code>curr_tank</code> 也一定会比 0 小,<strong>即如果A站不能到B站，那么A，B之间到任何一个站都不能到B站，（B站是A站第一个不能到的站）</strong> ）</p><p><strong>算法</strong></p><p>那么现在算法是很直接明了的：</p><ol><li><p>初始化 <code>total_tank</code> 和 <code>curr_tank</code> 为 0 ，并且选择 <code>0</code> 号加油站为起点。</p></li><li><p>遍历所有的加油站：</p><ul><li><p>每一步中，都通过加上 <code>gas[i]</code> 和减去 <code>cost[i]</code> 来更新 <code>total_tank</code> 和 <code>curr_tank</code> 。</p></li><li><p>如果在 <code>i + 1</code> 号加油站， <code>curr_tank &lt; 0</code> ，将 <code>i + 1</code> 号加油站作为新的起点，同时重置 <code>curr_tank = 0</code> ，让油箱也清空。</p></li></ul></li><li><p>如果 <code>total_tank &lt; 0</code> ，返回 <code>-1</code> ，否则返回 <code>starting station</code>。</p></li></ol><p><strong>算法原理</strong></p><p>想象 <code>total_tank &gt;= 0</code> 的情况，同时上述算法返回 <em>N_s</em> 作为出发加油站。</p><p>算法直接保证了从 <em>N_s</em> 可以到达 <em>0</em> ，但是剩余的路程，即从 <em>0</em> 到站 <em>N_s</em> 是否有足够的油呢？</p><blockquote><p>如何确保从 <em>N_s</em> 出发可以环行一圈？</p></blockquote><p>我们使用 <a href="https://baike.baidu.com/item/%E5%8F%8D%E8%AF%81%E6%B3%95/5017739?fr=aladdin" target="_blank" rel="noopener">反证法</a> 。假设存在 <em>0 &lt; k &lt; N_s</em> ，使得我们从 <em>N_s</em> 出发无法到达 <code>k</code> 号加油站。</p><p>条件 <code>total_tank &gt;= 0</code> 可以被写作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\sum_&#123;i=1&#125;^&#123;N&#125;&#123;\alpha_i&#125;\ge0\qquad(1)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\alpha_i&gt;=0</span><br></pre></td></tr></table></figure><p>,<br>其中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\alpha_i=gas[i]-cost[i]</span><br></pre></td></tr></table></figure><p>我们将出发站点 <em>N_s</em> 和无法到达站点 <code>k</code> 作为分隔点，将左式分成三个部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\sum_&#123;i=1&#125;^&#123;k&#125;&#123;\alpha_i&#125;+\sum_&#123;i=k+1&#125;^&#123;N_s-1&#125;&#123;\alpha_i&#125;+\sum_&#123;i=N_s&#125;^&#123;N&#125;&#123;\alpha_i&#125;\ge0\qquad(2)</span><br></pre></td></tr></table></figure><p>根据算法流程，第二项为负，因为每一个出发点前面一段路途的 <code>curr_tank</code> 一定为负。否则，出发点应该是比 <em>N_s</em> 更靠前的一个加油站而不是 <em>N_s</em> 。当且仅当 <em>k = N_s - 1</em> ，第二项才为 0 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\sum_&#123;i=k+1&#125;^&#123;i=N_s-1&#125;&#123;\alpha_i&#125;\le0\qquad(3)</span><br></pre></td></tr></table></figure><p>结合不等式 <code>(2)</code> 和 <code>(3)</code> ，可以得到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\sum_&#123;i=0&#125;^&#123;i=k&#125;&#123;\alpha_i&#125;+\sum_&#123;i=N_s&#125;^&#123;i=N&#125;&#123;\alpha_i&#125;\ge0\qquad(4)</span><br></pre></td></tr></table></figure><p>同时，因为 <em>k</em> 是一个从 <em>N_s</em> 出发不可到达的站点，意味着</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\sum_&#123;i=N_s&#125;^&#123;i=N&#125;&#123;\alpha_i&#125;+\sum_&#123;i=0&#125;^&#123;i=k&#125;&#123;\alpha_i&#125;&lt;0\qquad(5)</span><br></pre></td></tr></table></figure><p>结合不等式 <code>(4)</code> 和 <code>(5)</code> ，可以得到一个矛盾。因此，假设 “存在一个 <em>0 &lt; k &lt; N_s</em> ，从 <em>N_s</em> 出发无法到达 <em>k</em>” 不成立。</p><p>因此，从 <em>N_s</em> 出发一定能环行一圈， <em>N_s</em> 是一个可行解。根据题目描述，答案是唯一的。</p><p>上面的官方题解看起来很饶，公式（5）存在以结论证结论的问题，而以每站汽油累计量profit[i] = gas[i] - cost[i]思考这个问题更容易理解。</p><p>若sum(gas) &gt;= sum(cost)，则必定存在解（贪心策略不用严格证明，大家以汽油累计量为0，每站汽油累计量可正可负，极限条件画个环形图理解下：大致就是左边累积量少，我就往右边走，反之亦然）</p><p>再加上题目条件若有解则唯一，</p><p>我们只需找到以i开头的总累计油量有剩余cur_tank + gas[i] - cost[i] &gt;= 0即可——这就是本题贪心策略的依据</p><p><strong>实现</strong></p><p> <a href="https://pic.leetcode-cn.com/87e7bb7a0745fe4916de8deb8687b4a84b3482daab0643f1ae6d4a02cf03ceb0-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/4dad65b5a9ed763e2760129635f1704be4a9e093ea66bc4e244657cb59c35744-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/022e56703b9ce5f53fb8ad9c6d51cc74468bff670eb29dfa48cb0625c9d57cba-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/256c9491248c8cf0e8fca7370346ea22333edc4394c57f211c1783a6b163235a-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/d1cef311a434c64d3fd85ea0d1adb5374e1b16d802110c90c833ceb4121bb19c-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/6be953413c1dbb884e5b2e92837cc4384ba32fa662f7c2c0784cb8e1bff973b2-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/ca82d1cec3e8d2a325c20f1dab270bcae405e21f4990e46f38f5394fe6c65249-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/469511c0afc12420e34588cf19cb373ee22e9d4fb5c472d6b92e764f12e0fd7e-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/dcbe6e6975e1ee7d2cedfbdc9cff3d8212b066e6d5d63535ba435aceec67af9c-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/8c6d7bb66df5271a3383bce38fadbf0bfd52c1b035582903c3a6ebd4df8d1989-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/f1aea61b070c96e2e5c718dd3b9a35e40fa74f769204398fbdbd0a7466fa7eff-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/d450f8d85053fbdd914e21e6e0d56b0b7ebd797bea4cfb6fa5b250f794bcaf61-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/67399856acdd96570218a3de68ec86de6d6f385e517cc5e1991493433ca58b05-image.png" target="_blank" rel="noopener">image.png</a> </p><details>    <summary>一次遍历Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canCompleteCircuit</span><span class="params">(self, gas, cost)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type gas: List[int]</span></span><br><span class="line"><span class="string">        :type cost: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(gas)</span><br><span class="line">        </span><br><span class="line">        total_tank, curr_tank = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        starting_station = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            total_tank += gas[i] - cost[i]</span><br><span class="line">            curr_tank += gas[i] - cost[i]</span><br><span class="line">            <span class="comment"># If one couldn't get here,</span></span><br><span class="line">            <span class="keyword">if</span> curr_tank &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># Pick up the next station as the starting one.</span></span><br><span class="line">                starting_station = i + <span class="number">1</span></span><br><span class="line">                <span class="comment"># Start with an empty tank.</span></span><br><span class="line">                curr_tank = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> starting_station <span class="keyword">if</span> total_tank &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></details><details>    <summary>一次遍历Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="keyword">int</span>[] gas, <span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = gas.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> total_tank = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> curr_tank = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> starting_station = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      total_tank += gas[i] - cost[i];</span><br><span class="line">      curr_tank += gas[i] - cost[i];</span><br><span class="line">      <span class="comment">// If one couldn't get here,</span></span><br><span class="line">      <span class="keyword">if</span> (curr_tank &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Pick up the next station as the starting one.</span></span><br><span class="line">        starting_station = i + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// Start with an empty tank.</span></span><br><span class="line">        curr_tank = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total_tank &gt;= <span class="number">0</span> ? starting_station : -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>一次遍历C++</summary><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; gas, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = gas.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> total_tank = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> curr_tank = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> starting_station = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      total_tank += gas[i] - cost[i];</span><br><span class="line">      curr_tank += gas[i] - cost[i];</span><br><span class="line">      <span class="comment">// If one couldn't get here,</span></span><br><span class="line">      <span class="keyword">if</span> (curr_tank &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Pick up the next station as the starting one.</span></span><br><span class="line">        starting_station = i + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// Start with an empty tank.</span></span><br><span class="line">        curr_tank = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total_tank &gt;= <span class="number">0</span> ? starting_station : <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度： O(N) ， 这是因为只有一个遍历了所有加油站一次的循环。</p></li><li><p>空间复杂度： O(1)  ，因为此算法只使用了常数个变量。</p></li></ul><p><strong>延伸阅读</strong></p><p>还有许多加油站问题的变种问题，这里是一些例子：</p><p><a href="https://www.sciencedirect.com/science/article/pii/S002001901730203X" target="_blank" rel="noopener">允许 Δ 次停留的加油站间最小路径开销</a> </p><p><a href="https://link.springer.com/chapter/10.1007/978-3-540-75520-3_48" target="_blank" rel="noopener">油箱有容量限制下的加油站间最小路径开销</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年10月" scheme="http://yoursite.com/categories/2020%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Greedy" scheme="http://yoursite.com/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>412. Fizz Buzz</title>
    <link href="http://yoursite.com/2020/10/05/412.%20Fizz%20Buzz/"/>
    <id>http://yoursite.com/2020/10/05/412. Fizz Buzz/</id>
    <published>2020-10-04T16:26:12.000Z</published>
    <updated>2020-10-04T17:02:23.520Z</updated>
    
    <content type="html"><![CDATA[<p>写一个程序，输出从 1 到 n 数字的字符串表示。</p><a id="more"></a><ol><li><p>如果n是3的倍数，输出“Fizz”；</p></li><li><p>如果n是5的倍数，输出“Buzz”；</p></li><li><p>如果n同时是3和5的倍数，输出 “FizzBuzz”。</p></li></ol><p>示例：</p><pre><code>n = 15,</code></pre><p>返回:</p><pre><code>[    &quot;1&quot;,    &quot;2&quot;,    &quot;Fizz&quot;,    &quot;4&quot;,    &quot;Buzz&quot;,    &quot;Fizz&quot;,    &quot;7&quot;,    &quot;8&quot;,    &quot;Fizz&quot;,    &quot;Buzz&quot;,    &quot;11&quot;,    &quot;Fizz&quot;,    &quot;13&quot;,    &quot;14&quot;,    &quot;FizzBuzz&quot;]</code></pre><h1 id="方法一：-模拟法"><a href="#方法一：-模拟法" class="headerlink" title="方法一： 模拟法"></a>方法一： 模拟法</h1><p><strong>思路</strong></p><p>就像你每次玩 FizzBuzz 那样，你只需要判断这个数是能被 <code>3</code> 整除？ 还是能被 <code>5</code> 整除？ 或者是都能被整除。</p><p><strong>算法</strong></p><ol><li>初始化一个空的答案列表。</li><li>遍历 <em>1 … N</em>。</li><li>对于每个数，判断它能不能同时被 3 和 5 整除，如果可以就把 FizzBuzz 加入答案列表。</li><li>如果不行，判断它能不能被 3 整除，如果可以，把 Fizz 加入答案列表。</li><li>如果还是不行，判断它能不能被 5 整除，如果可以，把 Buzz 加入答案列表。</li><li>如果以上都不行，把这个数加入答案列表。<details> <summary>模拟法Java</summary></details></li></ol><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">fizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ans list</span></span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">1</span>; num &lt;= n; num++) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">boolean</span> divisibleBy3 = (num % <span class="number">3</span> == <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">boolean</span> divisibleBy5 = (num % <span class="number">5</span> == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (divisibleBy3 &amp;&amp; divisibleBy5) &#123;</span><br><span class="line">        <span class="comment">// Divides by both 3 and 5, add FizzBuzz</span></span><br><span class="line">        ans.add(<span class="string">"FizzBuzz"</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (divisibleBy3) &#123;</span><br><span class="line">        <span class="comment">// Divides by 3, add Fizz</span></span><br><span class="line">        ans.add(<span class="string">"Fizz"</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (divisibleBy5) &#123;</span><br><span class="line">        <span class="comment">// Divides by 5, add Buzz</span></span><br><span class="line">        ans.add(<span class="string">"Buzz"</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Not divisible by 3 or 5, add the number</span></span><br><span class="line">        ans.add(Integer.toString(num));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details>    <summary>模拟法Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fizzBuzz</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># ans list</span></span><br><span class="line">        ans = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line"></span><br><span class="line">            divisible_by_3 = (num % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">            divisible_by_5 = (num % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> divisible_by_3 <span class="keyword">and</span> divisible_by_5:</span><br><span class="line">                <span class="comment"># Divides by both 3 and 5, add FizzBuzz</span></span><br><span class="line">                ans.append(<span class="string">"FizzBuzz"</span>)</span><br><span class="line">            <span class="keyword">elif</span> divisible_by_3:</span><br><span class="line">                <span class="comment"># Divides by 3, add Fizz</span></span><br><span class="line">                ans.append(<span class="string">"Fizz"</span>)</span><br><span class="line">            <span class="keyword">elif</span> divisible_by_5:</span><br><span class="line">                <span class="comment"># Divides by 5, add Buzz</span></span><br><span class="line">                ans.append(<span class="string">"Buzz"</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># Not divisible by 3 or 5, add the number</span></span><br><span class="line">                ans.append(str(num))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度： <em>O(N)</em></li><li>空间复杂度： <em>O(1)</em></li></ul><h1 id="方法二：-字符串连接"><a href="#方法二：-字符串连接" class="headerlink" title="方法二： 字符串连接"></a>方法二： 字符串连接</h1><p><strong>思路</strong></p><p>这个方法不会降低渐进复杂度，但是当 <code>FizzBuzz</code> 的规则变得更复杂的时候，这将会是个更优雅的解法。比方说，玩个 <code>FizzBuzzJazz</code> 的游戏。规则如下：</p><pre>3 ---> "Fizz" , 5 ---> "Buzz", 7 ---> "Jazz"</pre><p>如果你还是用之前的方法来解决这个问题的话，那将会有非常多的条件需要判断哦~</p><ol><li>能不能被 3 整除</li><li>能不能被 5 整除</li><li>能不能被 7 整除</li><li>能不能同时被 3 和 5 整除</li><li>能不能同时被 5 和 7 整除</li><li>能不能同时被 3 和 7 整除</li><li>能不能同时被 3，5，7 整除</li><li>不能被 3，5，7 其中任何一个数整除</li></ol><p>如果 <code>FizzBuzz</code> 照着这种方式变地更复杂的话，那么你要写的判断可能会让你抓狂。</p><p><strong>算法</strong></p><p>我们放弃使用之前的联合判断，取而代之依次判断是否能被给定的数整数。这道题中，就是依次判断能不能被 3 整除，能不能被 5 整除。如果能被 3 整除，就把对应的 <code>Fizz</code> 连接到答案字符串，如果能被 5 整除，就把 <code>Buzz</code> 连接到答案字符串。</p><p>举个例子，现在需要判断 15，步骤将会是下面这样的：</p><blockquote><p>条件 1： 15 % 3 == 0, num_ans_str = “Fizz”<br>条件 2： 15 % 5 == 0, num_ans_str += “Buzz”<br>=&gt; num_ans_str = “FizzBuzz”</p></blockquote><p>对于 <code>FizzBuzz</code> 来说，只需要判断两个条件就可以了，而不需要像方法一中那样判断三个条件。</p><p>同样的，对于 <code>FizzBuzzJazz</code>，现在只需要判断三个条件就可以了。</p><details>    <summary>字符串连接Java</summary><figure class="highlight java"><figcaption><span>[solution-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">fizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ans list</span></span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">1</span>; num &lt;= n; num++) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">boolean</span> divisibleBy3 = (num % <span class="number">3</span> == <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">boolean</span> divisibleBy5 = (num % <span class="number">5</span> == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      String numAnsStr = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (divisibleBy3) &#123;</span><br><span class="line">        <span class="comment">// Divides by 3, add Fizz</span></span><br><span class="line">        numAnsStr += <span class="string">"Fizz"</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (divisibleBy5) &#123;</span><br><span class="line">        <span class="comment">// Divides by 5, add Buzz</span></span><br><span class="line">        numAnsStr += <span class="string">"Buzz"</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (numAnsStr.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">        <span class="comment">// Not divisible by 3 or 5, add the number</span></span><br><span class="line">        numAnsStr += Integer.toString(num);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Append the current answer str to the ans list</span></span><br><span class="line">      ans.add(numAnsStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>字符串连接Python</summary><figure class="highlight python"><figcaption><span>[solution-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fizzBuzz</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># ans list</span></span><br><span class="line">        ans = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line"></span><br><span class="line">            divisible_by_3 = (num % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">            divisible_by_5 = (num % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            num_ans_str = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> divisible_by_3:</span><br><span class="line">                <span class="comment"># Divides by 3</span></span><br><span class="line">                num_ans_str += <span class="string">"Fizz"</span></span><br><span class="line">            <span class="keyword">if</span> divisible_by_5:</span><br><span class="line">                <span class="comment"># Divides by 5</span></span><br><span class="line">                num_ans_str += <span class="string">"Buzz"</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> num_ans_str:</span><br><span class="line">                <span class="comment"># Not divisible by 3 or 5</span></span><br><span class="line">                num_ans_str = str(num)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Append the current answer str to the ans list</span></span><br><span class="line">            ans.append(num_ans_str)  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details>**复杂度分析**<ul><li>时间复杂度： <em>O(N)</em></li><li>空间复杂度： <em>O(1)</em><br><br></li></ul><h1 id="方法三-用散列表"><a href="#方法三-用散列表" class="headerlink" title="方法三 用散列表"></a>方法三 用散列表</h1><p><strong>思路</strong></p><p>这个方法是对方法二的优化。当数字和答案的映射是定好的，那么方法二用起来也还可以。但是如果你遇到一个变态的面试官，他跟你说他需要更自由的映射关系呢？</p><p>每个映射一个判断显然是不可行的，这样写出来的代码一定是丑陋不堪且难以维护的。</p><p>如果老板有这样一个需求，明天你把映射关系换掉或者删除一个映射关系吧。对于这种要求，我们只能一个个去修改判断条件的代码。</p><p>但我们实际上有个更优雅的做法，那就是把映射关系放在 <code>散列表</code> 里面。</p><p><strong>算法</strong></p><ol><li>把所有的映射关系放在散列表 <code>fizzBuzzHash</code> 中，这个散列表形如 <code>{ 3: &#39;Fizz&#39;, 5: &#39;Buzz&#39; }</code>。</li><li>遍历 <em>1 … N</em>。</li><li>对于每个数字，遍历 <code>fizzBuzzHash</code> 中的键，检查是否能被它整除。</li><li>如果这个数能被键整除，就把当前键映射的值加到到答案字符串后面去。对于散列表的每个键值对，都这样操作。</li><li>最后将答案字符串加入答案列表。</li></ol><blockquote><p>通过这样的方式你可以对散列表<code>添加/删除</code>映射关系，同时还不需要修改太多代码。</p></blockquote><p>而对于 <code>FizzBuzzJazz</code> 这个问题，散列表就可以是这样的，<code>{ 3: &#39;Fizz&#39;, 5: &#39;Buzz&#39;, 7: &#39;Jazz&#39; }</code>。</p><details>    <summary>用散列表Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">fizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ans list</span></span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hash map to store all fizzbuzz mappings.</span></span><br><span class="line">    HashMap&lt;Integer, String&gt; fizzBizzDict =</span><br><span class="line">        <span class="keyword">new</span> HashMap&lt;Integer, String&gt;() &#123;</span><br><span class="line">          &#123;</span><br><span class="line">            put(<span class="number">3</span>, <span class="string">"Fizz"</span>);</span><br><span class="line">            put(<span class="number">5</span>, <span class="string">"Buzz"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">1</span>; num &lt;= n; num++) &#123;</span><br><span class="line"></span><br><span class="line">      String numAnsStr = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (Integer key : fizzBizzDict.keySet()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the num is divisible by key,</span></span><br><span class="line">        <span class="comment">// then add the corresponding string mapping to current numAnsStr</span></span><br><span class="line">        <span class="keyword">if</span> (num % key == <span class="number">0</span>) &#123;</span><br><span class="line">          numAnsStr += fizzBizzDict.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (numAnsStr.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">        <span class="comment">// Not divisible by 3 or 5, add the number</span></span><br><span class="line">        numAnsStr += Integer.toString(num);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Append the current answer str to the ans list</span></span><br><span class="line">      ans.add(numAnsStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>用散列表Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fizzBuzz</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># ans list</span></span><br><span class="line">        ans = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Dictionary to store all fizzbuzz mappings</span></span><br><span class="line">        fizz_buzz_dict = &#123;<span class="number">3</span> : <span class="string">"Fizz"</span>, <span class="number">5</span> : <span class="string">"Buzz"</span>&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line"></span><br><span class="line">            num_ans_str = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> key <span class="keyword">in</span> fizz_buzz_dict.keys():</span><br><span class="line"></span><br><span class="line">                <span class="comment"># If the num is divisible by key,</span></span><br><span class="line">                <span class="comment"># then add the corresponding string mapping to current num_ans_str</span></span><br><span class="line">                <span class="keyword">if</span> num % key == <span class="number">0</span>:</span><br><span class="line">                    num_ans_str += fizz_buzz_dict[key]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> num_ans_str:</span><br><span class="line">                num_ans_str = str(num)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Append the current answer str to the ans list</span></span><br><span class="line">            ans.append(num_ans_str)  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度： <em>O(N)</em></li><li>空间复杂度： <em>O(1)</em></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写一个程序，输出从 1 到 n 数字的字符串表示。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年10月" scheme="http://yoursite.com/categories/2020%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>371. 两整数之和</title>
    <link href="http://yoursite.com/2020/10/04/371.%20%E4%B8%A4%E6%95%B4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://yoursite.com/2020/10/04/371. 两整数之和/</id>
    <published>2020-10-04T04:40:12.000Z</published>
    <updated>2020-10-04T16:25:24.939Z</updated>
    
    <content type="html"><![CDATA[<p>不使用运算符 + 和 -，计算两整数a、b之和。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: a = 1, b = 2输出: 3</code></pre><p>示例 2:</p><pre><code>输入: a = -2, b = 3输出: 1</code></pre><h1 id="利用位操作实现加法"><a href="#利用位操作实现加法" class="headerlink" title="利用位操作实现加法"></a>利用位操作实现加法</h1><p>首先看十进制是如何做的： 5+7=12，三步走 </p><ul><li>第一步：相加各位的值，不算进位，得到2。 </li><li>第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。  </li><li>第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。 </li></ul><p>同样我们可以用三步走的方式计算二进制值相加： 5—101，7—111 </p><ul><li>第一步：相加各位的值，不算进位，得到010，<strong>二进制每位相加就相当于各位做异或操作</strong>，101^111。 </li><li>第二步：计算进位值，得到1010，<strong>相当于各位进行与操作得到101，再向左移一位得到1010</strong>，(101&amp;111)&lt;&lt;1。  </li><li>第三步重复上述两步，各位相加 010^1010=1000，进位值为100=(010 &amp; 1010)&lt;&lt;1。 </li><li>继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。 </li><li>结束条件：<strong>进位为0，即a为最终的求和结果。</strong><details>  <summary>利用位操作实现加法</summary></details></li></ul><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(b != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = a ^ b;</span><br><span class="line">            b = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            a = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回顾一下我们小学就开始学习的十进制的加法，比如<code>15+7</code>，最低位<code>5+7</code>得到<code>12</code>，对<code>10</code>取模得到<code>2</code>，进位为<code>1</code>，再高位相加<code>1+0</code>再加上进位<code>1</code>就得到高位结果<code>2</code>,组合起来就是<code>22</code>。这里面涉及到了两个数字，一个是相加得到的低位，也就是<code>5+7</code>得到的结果<code>2</code>，第二个是进位<code>1</code>。在二进制的计算中就是要通过位操作来得到结果的低位和进位，对于不同的情况，用表格来表示一下，两个数字分别为<code>a</code>和<code>b</code></p><table><thead><tr><th align="center">a</th><th align="center">b</th><th align="center">低位</th><th align="center">进位</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">1</td></tr></tbody></table><p>从上面的表格就可以发现，<code>低位 = a^b</code>，<code>进位 = a &amp; b</code>。这样的计算可能要持续多次，回想一下在十进制的计算中，如果进位一直大于0，就得往后面进行计算，在这里也是一样，只要进位不是0，我们就得一直重复计算低位和进位的操作（需要在下一次计算之前要把进位向左移动一位，这样进位才能和更高位进行运算）。这个时候的<code>a</code>和<code>b</code>就是刚才计算的低位和进位，用简单的加法迭代的代码表示：</p><details>    <summary>利用位操作实现加法</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a==<span class="number">0</span>) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">if</span> (b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">int</span> lower;</span><br><span class="line">    <span class="keyword">int</span> carrier;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        lower = a^b;    <span class="comment">// 计算低位</span></span><br><span class="line">        carrier = a&amp;b;  <span class="comment">// 计算进位</span></span><br><span class="line">        <span class="keyword">if</span> (carrier==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        a = lower;</span><br><span class="line">        b = carrier&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lower;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不使用运算符 + 和 -，计算两整数a、b之和。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年10月" scheme="http://yoursite.com/categories/2020%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
  <entry>
    <title>202. 快乐数</title>
    <link href="http://yoursite.com/2020/10/04/202.%20%E5%BF%AB%E4%B9%90%E6%95%B0/"/>
    <id>http://yoursite.com/2020/10/04/202. 快乐数/</id>
    <published>2020-10-04T01:30:12.000Z</published>
    <updated>2020-10-04T04:38:25.560Z</updated>
    
    <content type="html"><![CDATA[<p>编写一个算法来判断一个数 n 是不是快乐数。</p><a id="more"></a><p>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为1，那么这个数就是快乐数。</p><p>如果 n 是快乐数就返回 True ；不是，则返回 False 。</p><p>示例：</p><pre><code>输入：19输出：true解释：1^2 + 9^2 = 828^2 + 2^2 = 686^2 + 8^2 = 1001^2 + 0^2 + 0^2 = 1</code></pre><h1 id="📺-视频题解"><a href="#📺-视频题解" class="headerlink" title="📺 视频题解"></a>📺 视频题解</h1><p><a href="9d8ce931-e835-45d1-a3d2-ab54b52b5377">202. 快乐数 - Lizzi.mp4</a></p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="方法一：用-HashSet-检测循环"><a href="#方法一：用-HashSet-检测循环" class="headerlink" title="方法一：用 HashSet 检测循环"></a>方法一：用 HashSet 检测循环</h2><p>我们可以先举几个例子。我们从 <em>7</em> 开始。则下一个数字是 <em>49<em>（因为 *7^2=49</em>），然后下一个数字是 <em>97</em>（因为 <em>4^2+9^2=97</em>）。我们可以不断重复该的过程，直到我们得到 <em>1</em>。因为我们得到了 <em>1</em>，我们知道 *7</em> 是一个快乐数，函数应该返回 <code>true</code>。</p><p><a href="https://assets.leetcode-cn.com/solution-static/202/202_fig1.png" target="_blank" rel="noopener">fig1</a></p><p>再举一个例子，让我们从 <em>116</em> 开始。通过反复通过平方和计算下一个数字，我们最终得到 <em>58</em>，再继续计算之后，我们又回到 <em>58</em>。由于我们回到了一个已经计算过的数字，可以知道有一个循环，因此不可能达到 <em>1</em>。所以对于 <em>116</em>，函数应该返回 <code>false</code>。</p><p><a href="https://assets.leetcode-cn.com/solution-static/202/202_fig2.png" target="_blank" rel="noopener">fig2</a></p><p>根据我们的探索，我们猜测会有以下三种可能。</p><ol><li>最终会得到 <em>1</em>。</li><li>最终会进入循环。</li><li>值会越来越大，最后接近无穷大。</li></ol><p>第三个情况比较难以检测和处理。我们怎么知道它会继续变大，而不是最终得到 <em>1</em> 呢？我们可以仔细想一想，每一位数的最大数字的下一位数是多少。</p><table><thead><tr><th>Digits</th><th align="center">Largest</th><th align="right">Next</th></tr></thead><tbody><tr><td>1</td><td align="center">9</td><td align="right">81</td></tr><tr><td>2</td><td align="center">99</td><td align="right">162</td></tr><tr><td>3</td><td align="center">999</td><td align="right">243</td></tr><tr><td>4</td><td align="center">9999</td><td align="right">324</td></tr><tr><td>13</td><td align="center">9999999999999</td><td align="right">1053</td></tr></tbody></table><p>对于 <em>3</em> 位数的数字，它不可能大于 <em>243*。这意味着它要么被困在 *243</em> 以下的循环内，要么跌到 <em>1</em>。<em>4</em> 位或 <em>4</em> 位以上的数字在每一步都会丢失一位，直到降到 <em>3</em> 位为止。所以我们知道，最坏的情况下，算法可能会在 <em>243</em> 以下的所有数字上循环，然后回到它已经到过的一个循环或者回到 <em>1</em>。但它不会无限期地进行下去，所以我们排除第三种选择。</p><p>即使在代码中你不需要处理第三种情况，你仍然需要理解为什么它永远不会发生，这样你就可以证明为什么你不处理它。</p><p><strong>算法：</strong></p><p>算法分为两部分，我们需要设计和编写代码。</p><ol><li>给一个数字 <em>n</em>，它的下一个数字是什么？</li><li>按照一系列的数字来判断我们是否进入了一个循环。</li></ol><p>第 1 部分我们按照题目的要求做数位分离，求平方和。</p><p>第 2 部分可以使用 HashSet 完成。每次生成链中的下一个数字时，我们都会检查它是否已经在 HashSet 中。</p><ul><li>如果它不在 HashSet 中，我们应该添加它。</li><li>如果它在 HashSet 中，这意味着我们处于一个循环中，因此应该返回 <code>false</code>。</li></ul><p>我们使用 HashSet  而不是向量、列表或数组的原因是因为我们反复检查其中是否存在某数字。检查数字是否在哈希集中需要 <em>O(1)</em> 的时间，而对于其他数据结构，则需要 <em>O(n)</em> 的时间。选择正确的数据结构是解决这些问题的关键部分。</p><details>    <summary>用 HashSet 检测循环Python</summary><figure class="highlight python"><figcaption><span>[solution1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isHappy</span><span class="params">(self, n: int)</span> -&gt; bool:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next</span><span class="params">(n)</span>:</span></span><br><span class="line">        total_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            n, digit = divmod(n, <span class="number">10</span>)</span><br><span class="line">            total_sum += digit ** <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> total_sum</span><br><span class="line"></span><br><span class="line">    seen = set()</span><br><span class="line">    <span class="keyword">while</span> n != <span class="number">1</span> <span class="keyword">and</span> n <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">        seen.add(n)</span><br><span class="line">        n = get_next(n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span></span><br></pre></td></tr></table></figure></details><details>    <summary>用 HashSet 检测循环Java</summary><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = n % <span class="number">10</span>;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">            totalSum += d * d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; seen = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">1</span> &amp;&amp; !seen.contains(n)) &#123;</span><br><span class="line">            seen.add(n);</span><br><span class="line">            n = getNext(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>用 HashSet 检测循环C#</summary><figure class="highlight csharp"><figcaption><span>[solution1-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNext</span>(<span class="params"><span class="keyword">int</span> n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = n % <span class="number">10</span>;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">            totalSum += d * d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsHappy</span>(<span class="params"><span class="keyword">int</span> n</span>) </span>&#123;</span><br><span class="line">        HashSet &lt;<span class="keyword">int</span>&gt; seen = <span class="keyword">new</span> HashSet&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">1</span> &amp;&amp; !seen.Contains(n)) &#123;</span><br><span class="line">            seen.Add(n);</span><br><span class="line">            n = getNext(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>用 HashSet 检测循环Golang</summary><figure class="highlight golang"><figcaption><span>[solution1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isHappy</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> ; n != <span class="number">1</span> &amp;&amp; !m[n]; n, m[n] = step(n), <span class="literal">true</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">step</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        sum += (n%<span class="number">10</span>) * (n%<span class="number">10</span>)</span><br><span class="line">        n = n/<span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><p>确定这个问题的时间复杂度对于一个 “简单” 级别的问题来说是一个挑战。如果您对这些问题还不熟悉，可以尝试只计算  <code>getNext(n)</code> 函数的时间复杂度。</p><ul><li>时间复杂度：<br>O(243 *3 + logn+loglogn+logloglogn)…=O(logn)。<ul><li>查找给定数字的下一个值的成本为O(logn) ，因为我们正在处理数字中的每位数字，而数字中的位数由 logn 给定。</li><li>要计算出总的时间复杂度，我们需要仔细考虑循环中有多少个数字，它们有多大。</li></ul><ul><li>我们在上面确定，一旦一个数字低于 <em>243*，它就不可能回到 *243</em> 以上。因此，我们就可以用 <em>243</em> 以下最长循环的长度来代替 <em>243</em>，不过，因为常数无论如何都无关紧要，所以我们不会担心它。</li><li>对于高于 <em>243</em> 的 <em>n</em>，我们需要考虑循环中每个数高于 <em>243</em> 的成本。通过数学运算，我们可以证明在最坏的情况下，这些成本将是 O(logn)+O(loglogn)+O(logloglogn) 。幸运的是，O(logn)  是占主导地位的部分，而其他部分相比之下都很小（总的来说，它们的总和小于O(logn)），所以我们可以忽略它们。</li></ul></li><li>空间复杂度：O(logn) 。与时间复杂度密切相关的是衡量我们放入 HashSet 中的数字以及它们有多大的指标。对于足够大的 <em>n</em>，大部分空间将由 <em>n</em> 本身占用。我们可以很容易地优化到O(243<em>3)=O(1) ，方法是只保存集合中小于 *243</em> 的数字，因为对于较高的数字，无论如何都不可能返回到它们。</li></ul><h2 id="方法二：快慢指针法"><a href="#方法二：快慢指针法" class="headerlink" title="方法二：快慢指针法"></a>方法二：快慢指针法</h2><p>通过反复调用 <code>getNext(n)</code> 得到的链是一个隐式的链表。隐式意味着我们没有实际的链表节点和指针，但数据仍然形成链表结构。起始数字是链表的头 “节点”，链中的所有其他数字都是节点。<code>next</code> 指针是通过调用 <code>getNext(n)</code> 函数获得。</p><p>意识到我们实际有个链表，那么这个问题就可以转换为检测一个链表是否有环。因此我们在这里可以使用弗洛伊德循环查找算法。这个算法是两个奔跑选手，一个跑的快，一个跑得慢。在龟兔赛跑的寓言中，跑的快的称为 “乌龟”，跑得快的称为 “兔子”。</p><p>不管乌龟和兔子在循环中从哪里开始，它们最终都会相遇。这是因为兔子每走一步就向乌龟靠近一个节点（在它们的移动方向上）。</p><p> <a href="https://assets.leetcode-cn.com/solution-static/202/1.jpg" target="_blank" rel="noopener">fig1</a> <a href="https://assets.leetcode-cn.com/solution-static/202/2.jpg" target="_blank" rel="noopener">fig2</a> <a href="https://assets.leetcode-cn.com/solution-static/202/3.jpg" target="_blank" rel="noopener">fig3</a> <a href="https://assets.leetcode-cn.com/solution-static/202/4.jpg" target="_blank" rel="noopener">fig4</a> <a href="https://assets.leetcode-cn.com/solution-static/202/5.jpg" target="_blank" rel="noopener">fig5</a> <a href="https://assets.leetcode-cn.com/solution-static/202/6.jpg" target="_blank" rel="noopener">fig6</a> <a href="https://assets.leetcode-cn.com/solution-static/202/7.jpg" target="_blank" rel="noopener">fig7</a> <a href="https://assets.leetcode-cn.com/solution-static/202/8.jpg" target="_blank" rel="noopener">fig8</a> </p><p><strong>算法：</strong></p><p>我们不是只跟踪链表中的一个值，而是跟踪两个值，称为快跑者和慢跑者。在算法的每一步中，慢速在链表中前进 1 个节点，快跑者前进 2 个节点（对 <code>getNext(n)</code> 函数的嵌套调用）。</p><p>如果 <code>n</code> 是一个快乐数，即没有循环，那么快跑者最终会比慢跑者先到达数字 1。</p><p>如果 <code>n</code> 不是一个快乐的数字，那么最终快跑者和慢跑者将在同一个数字上相遇。</p><details>    <summary>快慢指针法Python</summary><figure class="highlight python"><figcaption><span>[solution2-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isHappy</span><span class="params">(self, n: int)</span> -&gt; bool:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next</span><span class="params">(number)</span>:</span></span><br><span class="line">        total_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> number &gt; <span class="number">0</span>:</span><br><span class="line">            number, digit = divmod(number, <span class="number">10</span>)</span><br><span class="line">            total_sum += digit ** <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> total_sum</span><br><span class="line"></span><br><span class="line">    slow_runner = n</span><br><span class="line">    fast_runner = get_next(n)</span><br><span class="line">    <span class="keyword">while</span> fast_runner != <span class="number">1</span> <span class="keyword">and</span> slow_runner != fast_runner:</span><br><span class="line">        slow_runner = get_next(slow_runner)</span><br><span class="line">        fast_runner = get_next(get_next(fast_runner))</span><br><span class="line">    <span class="keyword">return</span> fast_runner == <span class="number">1</span></span><br></pre></td></tr></table></figure></details><details>    <summary>快慢指针法Java</summary><figure class="highlight java"><figcaption><span>[solution2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = n % <span class="number">10</span>;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">            totalSum += d * d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slowRunner = n;</span><br><span class="line">        <span class="keyword">int</span> fastRunner = getNext(n);</span><br><span class="line">        <span class="keyword">while</span> (fastRunner != <span class="number">1</span> &amp;&amp; slowRunner != fastRunner) &#123;</span><br><span class="line">            slowRunner = getNext(slowRunner);</span><br><span class="line">            fastRunner = getNext(getNext(fastRunner));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fastRunner == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>快慢指针法C#</summary><figure class="highlight csharp"><figcaption><span>[solution2-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNext</span>(<span class="params"><span class="keyword">int</span> n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = n % <span class="number">10</span>;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">            totalSum += d * d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsHappy</span>(<span class="params"><span class="keyword">int</span> n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slowRunner = n;</span><br><span class="line">        <span class="keyword">int</span> fastRunner = getNext(n);</span><br><span class="line">        <span class="keyword">while</span> (fastRunner != <span class="number">1</span> &amp;&amp; slowRunner != fastRunner) &#123;</span><br><span class="line">            slowRunner = getNext(slowRunner);</span><br><span class="line">            fastRunner = getNext(getNext(fastRunner));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fastRunner == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>快慢指针法Golang</summary><figure class="highlight golang"><figcaption><span>[solution2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isHappy</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    slow, fast := n, step(n)</span><br><span class="line">    <span class="keyword">for</span> fast != <span class="number">1</span> &amp;&amp; slow != fast &#123;</span><br><span class="line">        slow = step(slow)</span><br><span class="line">        fast = step(step(fast))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fast == <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">step</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        sum += (n%<span class="number">10</span>) * (n%<span class="number">10</span>)</span><br><span class="line">        n = n/<span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(logn)  。该分析建立在对前一种方法的分析的基础上，但是这次我们需要跟踪两个指针而不是一个指针来分析，以及在它们相遇前需要绕着这个循环走多少次。<ul><li>如果没有循环，那么快跑者将先到达 1，慢跑者将到达链表中的一半。我们知道最坏的情况下，成本是    O(2logn) = O(logn) 。</li><li>一旦两个指针都在循环中，在每个循环中，快跑者将离慢跑者更近一步。一旦快跑者落后慢跑者一步，他们就会在下一步相遇。假设循环中有 <em>k</em> 个数字。如果他们的起点是相隔 <em>k-1</em> 的位置（这是他们可以开始的最远的距离），那么快跑者需要 <em>k-1</em> 步才能到达慢跑者，这对于我们的目的来说也是不变的。因此，主操作仍然在计算起始 n 的下一个值，即 O(logn)  。</li></ul></li><li>空间复杂度：<em>O(1)</em>，对于这种方法，我们不需要哈希集来检测循环。指针需要常数的额外空间。</li></ul><h2 id="方法三：数学"><a href="#方法三：数学" class="headerlink" title="方法三：数学"></a>方法三：数学</h2><p>前两种方法是你在面试中应该想到的。第三种方法不是你在面试中会写的，而是针对对数学好奇的人，因为它很有趣。</p><p>下一个值可能比自己大的最大数字是什么？根据我们之前的分析，我们知道它必须低于 243。因此，我们知道任何循环都必须包含小于 243 的数字，用这么小的数字，编写一个能找到所有周期的强力程序并不困难。</p><p>如果这样做，您会发现只有一个循环：4→16→37→58→89→145→42→20→4 。所有其他数字都在进入这个循环的链上，或者在进入 <em>1</em> 的链上。</p><p>因此，我们可以硬编码一个包含这些数字的散列集，如果我们达到其中一个数字，那么我们就知道在循环中。</p><p><strong>算法：</strong></p><details>    <summary>数学Python</summary><figure class="highlight python"><figcaption><span>[solution3-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isHappy</span><span class="params">(self, n: int)</span> -&gt; bool:</span></span><br><span class="line"></span><br><span class="line">    cycle_members = &#123;<span class="number">4</span>, <span class="number">16</span>, <span class="number">37</span>, <span class="number">58</span>, <span class="number">89</span>, <span class="number">145</span>, <span class="number">42</span>, <span class="number">20</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next</span><span class="params">(number)</span>:</span></span><br><span class="line">        total_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> number &gt; <span class="number">0</span>:</span><br><span class="line">            number, digit = divmod(number, <span class="number">10</span>)</span><br><span class="line">            total_sum += digit ** <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> total_sum</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> n != <span class="number">1</span> <span class="keyword">and</span> n <span class="keyword">not</span> <span class="keyword">in</span> cycle_members:</span><br><span class="line">        n = get_next(n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span></span><br></pre></td></tr></table></figure></details><details>    <summary>数学Java</summary><figure class="highlight java"><figcaption><span>[solution3-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Set&lt;Integer&gt; cycleMembers =</span><br><span class="line">        <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="number">4</span>, <span class="number">16</span>, <span class="number">37</span>, <span class="number">58</span>, <span class="number">89</span>, <span class="number">145</span>, <span class="number">42</span>, <span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = n % <span class="number">10</span>;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">            totalSum += d * d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">1</span> &amp;&amp; !cycleMembers.contains(n)) &#123;</span><br><span class="line">            n = getNext(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>数学C#</summary><figure class="highlight csharp"><figcaption><span>[solution3-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNext</span>(<span class="params"><span class="keyword">int</span> n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = n % <span class="number">10</span>;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">            totalSum += d * d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsHappy</span>(<span class="params"><span class="keyword">int</span> n</span>) </span>&#123;</span><br><span class="line">        HashSet&lt;<span class="keyword">int</span>&gt; cycleMembers =</span><br><span class="line">            <span class="keyword">new</span> HashSet&lt;<span class="keyword">int</span>&gt;(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>] &#123;<span class="number">4</span>, <span class="number">16</span>, <span class="number">37</span>, <span class="number">58</span>, <span class="number">89</span>, <span class="number">145</span>, <span class="number">42</span>, <span class="number">20</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">1</span> &amp;&amp; !cycleMembers.Contains(n)) &#123;</span><br><span class="line">            n = getNext(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>数学Golang</summary><figure class="highlight golang"><figcaption><span>[solution3-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isHappy</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    cycle := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>&#123;<span class="number">4</span>: <span class="literal">true</span>, <span class="number">6</span>: <span class="literal">true</span>, <span class="number">37</span>: <span class="literal">true</span>, <span class="number">58</span>: <span class="literal">true</span>, <span class="number">89</span>: <span class="literal">true</span>, <span class="number">145</span>: <span class="literal">true</span>, <span class="number">42</span>: <span class="literal">true</span>, <span class="number">20</span>: <span class="literal">true</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> n != <span class="number">1</span> &amp;&amp; !cycle[n] &#123;</span><br><span class="line">        n = step(n)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">step</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        sum += (n%<span class="number">10</span>) * (n%<span class="number">10</span>)</span><br><span class="line">        n = n/<span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(logn)  。和上面一样。</li><li>空间复杂度：<em>O(1)</em>，我们没有保留我们所遇到的数字的历史记录。硬编码哈希集的大小是固定的。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写一个算法来判断一个数 n 是不是快乐数。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年10月" scheme="http://yoursite.com/categories/2020%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>326. 3的幂</title>
    <link href="http://yoursite.com/2020/09/30/326.%203%E7%9A%84%E5%B9%82/"/>
    <id>http://yoursite.com/2020/09/30/326. 3的幂/</id>
    <published>2020-09-30T06:30:12.000Z</published>
    <updated>2020-10-03T16:14:24.038Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数，写一个函数来判断它是否是3的幂次方。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: 27输出: true</code></pre><p>示例 2:</p><pre><code>输入: 0输出: false</code></pre><p>示例 3:</p><pre><code>输入: 9输出: true</code></pre><p>示例 4:</p><pre><code>输入: 45输出: false</code></pre><p>进阶：</p><pre><code>你能不使用循环或者递归来完成本题吗？</code></pre><h1 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h1><p>在本文中，我们将探讨加速简单计算的方法，以及为什么在实践中有用。 </p><h2 id="方法一：循环迭代"><a href="#方法一：循环迭代" class="headerlink" title="方法一：循环迭代"></a>方法一：循环迭代</h2><p>找出数字 <code>n</code> 是否是数字 <code>b</code> 的幂的一个简单方法是，<code>n%3</code>  只要余数为 0，就一直将 <code>n</code> 除以 <code>b</code>。</p><pre><code>n=b^x * n=b*b*...*b</code></pre><p>因此，应该可以将 <code>n</code> 除以 <code>b</code>  x 次，每次都有 0 的余数，最终结果是 1。 </p><details>    <summary>循环迭代</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            n /= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>注意我们需要一个警卫来检查那个 <code>n！=0</code>，否则 while 循环将永远不会结束。对于负数，该算法没有意义，因此我们也将包括该保护。 </p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(log_b(n)) ，在我们的例子中是O(logn) 。除数是用对数表示的。 </li><li>空间复杂度：<em>O(1)</em>，没有使用额外的空间。</li></ul><h2 id="方法二：基准转换"><a href="#方法二：基准转换" class="headerlink" title="方法二：基准转换"></a>方法二：基准转换</h2><p>在基数 10 中，10 的所有幂都从数字 1 开始，然后只跟 0（例如10、100、1000）。其他基地及其各自的权力也是如此。例如，在基数 2 中，<em>10 _2<em>、</em>100 _2</em> 和 <em>1000 _2</em> 分别表示为  <em>2_{10}</em>, <em>4_{10}</em> 和 <em>8_{10}</em>。因此，如果我们把我们的数转换成基3，并且表示形式是 100…0，那么这个数就是3的幂。</p><p><strong>证明 ：</strong><br>给定以 3 为底的数字表示为数组 <code>s</code>，第 0 位开始为有效数。<br>因此，只有一个数字 1，其余的都是 0，这意味着这个数字是 3 的幂。 </p><p><strong>实现：</strong></p><ul><li>我们所要做的就是将数字转换为以3为底的基数 ，并检查它是否为前导1，后跟所有 0。 </li><li>两个内置的Java函数将帮助我们前进。 </li></ul><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String baseChange = Integer.toString(number, base);</span><br></pre></td></tr></table></figure><ul><li>上面的代码将 <code>number</code> 转换以 <code>base</code> 为底的基数，并以字符串形式返回结果。例如，<code>integer.toString（5，2）=“101”</code> 和 <code>integer.toString（5，3）=“12”</code>。 </li></ul><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> matches = myString.matches(<span class="string">"123"</span>);</span><br></pre></td></tr></table></figure><p>上面的代码检查字符串中是否存在特定的正则表达式。例如，如果字符串 <code>mystring</code> 中存在子字符串 “123”，上面的内容将返回 true。 </p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> powerOfThree = baseChange.matches(<span class="string">"^10**"</span>)</span><br></pre></td></tr></table></figure><p>我们将使用上面的正则表达式来检查字符串是否以1 <code>^1</code> 开头，后跟 0 或 多个 0 <code>0*</code> 并且不包含任何其他值 <code>*</code>。</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.toString(n, <span class="number">3</span>).matches(<span class="string">"^10**"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(log_3n)</em>。<ul><li>假设：<ul><li><code>Integer.toString()</code> - 基转换通常是作为一个重复的除法来实现的。复杂性应该类似于我们的方法 1:<em>O（\ log_3n）</em>的复杂性。</li><li><code>String.matches()</code> - 方法迭代整个字符串。<code>n</code> 以 3 为基数表示的位数是<em>O（\log_3n）</em>。 </li></ul></li></ul></li><li>空间复杂度：<em>O(\log_3n)</em>。我们使用两个附加变量。<ul><li>以 3 为基数表示数字的字符串（大小为 <em>\log_3n</em>）</li><li>正则表达式的字符串（常量大小） </li></ul></li></ul><h2 id="方法三：运算法"><a href="#方法三：运算法" class="headerlink" title="方法三：运算法"></a>方法三：运算法</h2><p>我们可以用下面的数学公式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n = 3^i </span><br><span class="line"></span><br><span class="line">\ i = \ log_3(n) </span><br><span class="line"></span><br><span class="line">\ i = \frac&#123;\ log_b(n)&#125;&#123;\ log_b(3)&#125;</span><br></pre></td></tr></table></figure><p>若 <code>n</code> 是 3 的幂则 <code>i</code> 是整数。在 Java 中，我们通过取小数部分（利用 <code>% 1</code>）来检查数字是否是整数，并检查它是否是 0。 </p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Math.log10(n) / Math.log10(<span class="number">3</span>)) % <span class="number">1</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>常见的陷阱 :</strong><br>这个解决方案是有问题的，因为我们开始使用 <code>double</code> s，这意味着我们会遇到精度错误。说明在比较双精度数时不应使用 <code>==</code>。这是因为 <code>Math.log10(n)/Math.log10(3)</code> 的结果可能是 <code>5.0000001</code> 或 <code>4.9999999</code>。使用 <code>Math.log()</code> 函数而不是<code>Math.log10()</code> 可以观察到这种效果。 </p><p>为了解决这个问题，我们需要将结果与 <code>epsilon</code> 进行比较。</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (Math.log(n) / Math.log(<span class="number">3</span>) + epsilon) % <span class="number">1</span> &lt;= <span class="number">2</span> * epsilon;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：*Unknown$。这里主要消耗时间的运算是 <code>Math.log</code>，它限制了我们算法的时间复杂性。实现依赖于我们使用的语言和编译器 。</li><li>空间复杂度： <em>O(1)</em>，我们没有使用任何额外的内存。<code>epsilon</code> 变量可以是内联的。 </li></ul><h2 id="方法四：整数限制"><a href="#方法四：整数限制" class="headerlink" title="方法四：整数限制"></a>方法四：整数限制</h2><p>一个重要的信息可以从函数名中推导出来。</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br></pre></td></tr></table></figure><p>我们可以看出 <code>n</code> 的类型是  <code>int</code>。在 Java 中说明了该变量是四个字节，他的最大值为 <strong>2147483647</strong>。有三种方法可以计算出该最大值。</p><ol><li><a href="http://stackoverflow.com/questions/15004944/max-value-of-integer" target="_blank" rel="noopener">Google</a></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3. MaxInt = 2^32/2 - 1 ,因为我们使用 32 位来表示数字，所以范围的一半用于负数，0 是正数的一部分。</span><br><span class="line"></span><br><span class="line">知道了 `n` 的限制，我们现在可以推断出 `n` 的最大值，也就是 3 的幂，是 **1162261467**。我们计算如下： </span><br><span class="line"></span><br><span class="line">```math</span><br><span class="line">3^&#123;\lfloor&#123;&#125;\log_3&#123;MaxInt&#125;\rfloor&#123;&#125;&#125; = 3^&#123;\lfloor&#123;&#125;19.56\rfloor&#123;&#125;&#125; = 3^&#123;19&#125; = 1162261467</span><br></pre></td></tr></table></figure></li></ol><p>因此，我们应该返回 <code>true</code> 的 <code>n</code> 的可能值是 <em>3^0<em>，</em>3^1<em>…</em>3 ^ {19}*。因为 3 是质数，所以 *3^{19}</em> 的除数只有 <em>3^0<em>，</em>3^1<em>…</em>3 ^{19}*，因此我们只需要将 *3^{19}</em> 除以 <code>n</code>。若余数为 <strong>0</strong> 意味着 <code>n</code> 是 *3^{19}$ 的除数，因此是 3 的幂。 </p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; <span class="number">1162261467</span> % n == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(1)</em>。我们只做了一次操作。 </li><li>空间复杂度： <em>O(1)</em>，没有使用额外空间。</li></ul><h2 id="性能测量-："><a href="#性能测量-：" class="headerlink" title="性能测量 ："></a>性能测量 ：</h2><p>函数的单次运行使得难以测量两种解的差别。在 leetcode 上的 $Accepted* <em>Solutions</em>  <em>Runtime</em> <em>Distribution</em> 页面上，所有解决方案都在 <code>15 ms</code> 到 <code>20 ms</code> 之间。为了完整性，我们提出了以下基准，以了解这两个解决方案的区别。 </p><p><strong>Java基准码 :</strong></p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Solution sol = <span class="keyword">new</span> Solution();</span><br><span class="line">    <span class="keyword">int</span> iterations = <span class="number">1</span>; <span class="comment">// See table header for this value</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">        sol.isPowerOfThree(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在下表中，以秒为单位。<br>| Iterations |<em>10^6</em> |<em>10^7</em>|<em>10^8</em>|<em>10^9</em>|*Maxint$|<br>|–|–|–|–|–|–|<br>| Java Approach 1: (Naive) | 0.04 |0.07|0.30|2.47|5.26|<br>|Java Approach 2: (Strings) | 0.68 |4.02|38.90|409.16|893.89|<br>| Java Approach 3: (Logarithms) | 0.09 |0.50|4.59|45.53|97.50|<br>|Java Approach 4: (Fast) | 0.04 |0.06|0.08|0.41|0.78|</p><p>正如我们所看到的，对于小的 N 值，差异并不明显，但是随着我们进行更多的迭代，并且传递给 <code>isPowerOfThree()</code> 的 <code>n</code> 的值增长，我们看到方法 4 的性能显著提高。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论 :"></a>结论 :</h2><p>像这样的简单优化似乎可以忽略不计，但历史上，当计算能力成为一个问题时，它允许某些计算机程序（如Quake 3）成为可能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数，写一个函数来判断它是否是3的幂次方。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>268. 缺失数字</title>
    <link href="http://yoursite.com/2020/09/30/268.%20%E7%BC%BA%E5%A4%B1%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2020/09/30/268. 缺失数字/</id>
    <published>2020-09-30T02:30:12.000Z</published>
    <updated>2020-09-30T03:16:46.091Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: [3,0,1]输出: 2</code></pre><p>示例 2:</p><pre><code>输入: [9,6,4,2,3,5,7,0,1]输出: 8</code></pre><p>说明:</p><pre><code>你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现?</code></pre><h1 id="方法一：排序"><a href="#方法一：排序" class="headerlink" title="方法一：排序"></a>方法一：排序</h1><p><strong>分析</strong></p><p>如果数组是有序的，那么就很容易知道缺失的数字是哪个了。</p><p><strong>算法</strong></p><p>首先我们对数组进行排序，随后我们可以在常数时间内判断两种特殊情况：0 没有出现在数组的首位，以及 <em>n</em> 没有出现在数组的末位。如果这两种特殊情况都不满足，那么缺失的数字一定在 0 和 <em>n</em> 之间（不包括两者）。此时我们可以在线性时间内扫描这个数组，如果某一个数比它前面的那个数大了超过 1，那么这两个数之间的那个数即为缺失的数字。</p><details>    <summary>排序Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断 n 是否出现在末位</span></span><br><span class="line">        <span class="keyword">if</span> (nums[nums.length-<span class="number">1</span>] != nums.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断 0 是否出现在首位</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[<span class="number">0</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时缺失的数字一定在 (0, n) 中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> expectedNum = nums[i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != expectedNum) &#123;</span><br><span class="line">                <span class="keyword">return</span> expectedNum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 未缺失任何数字（保证函数有返回值）</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>排序Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        nums.sort()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Ensure that n is at the last index</span></span><br><span class="line">        <span class="keyword">if</span> nums[<span class="number">-1</span>] != len(nums):</span><br><span class="line">            <span class="keyword">return</span> len(nums)</span><br><span class="line">        <span class="comment"># Ensure that 0 is at the first index</span></span><br><span class="line">        <span class="keyword">elif</span> nums[<span class="number">0</span>] != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># If we get here, then the missing number is on the range (0, n)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            expected_num = nums[i<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] != expected_num:</span><br><span class="line">                <span class="keyword">return</span> expected_num</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(nlogn)。由于排序的时间复杂度为 O(nlogn) ，扫描数组的时间复杂度为 <em>O(n)</em>，因此总的时间复杂度为O(nlogn)。</li><li>空间复杂度：<em>O(1)</em> 或 <em>O(n)*。空间复杂度取决于使用的排序算法，根据排序算法是否进行原地排序（即不使用额外的数组进行临时存储），空间复杂度为 *O(1)</em> 或 <em>O(n)</em>。</li></ul><h1 id="方法二：哈希表"><a href="#方法二：哈希表" class="headerlink" title="方法二：哈希表"></a>方法二：哈希表</h1><p><strong>分析</strong></p><p>我们可以直接查询每个数是否在数组中出现过来找出缺失的数字。如果使用哈希表，那么每一次查询操作都是常数时间的。</p><p><strong>算法</strong></p><p>我们将数组中的所有数插入到一个集合中，这样每次查询操作的时间复杂度都是 <em>O(1)</em> 的。</p><details>    <summary>哈希表Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; numSet = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) numSet.add(num);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> expectedNumCount = nums.length + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> number = <span class="number">0</span>; number &lt; expectedNumCount; number++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!numSet.contains(number)) &#123;</span><br><span class="line">                <span class="keyword">return</span> number;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>哈希表Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        num_set = set(nums)</span><br><span class="line">        n = len(nums) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> number <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> number <span class="keyword">not</span> <span class="keyword">in</span> num_set:</span><br><span class="line">                <span class="keyword">return</span> number</span><br></pre></td></tr></table></figure></details>**复杂度分析**<ul><li>时间复杂度：<em>O(n)<em>。集合的插入操作的时间复杂度都是 *O(1)</em>，一共插入了 *n</em> 个数，时间复杂度为 <em>O(n)<em>。集合的查询操作的时间复杂度同样是 *O(1)</em>，最多查询 *n+1</em> 次，时间复杂度为 <em>O(n)</em>。因此总的时间复杂度为 <em>O(n)</em>。</li><li>空间复杂度：<em>O(n)*。集合中会存储 *n</em> 个数，因此空间复杂度为 <em>O(n)</em>。</li></ul><h1 id="方法三：位运算"><a href="#方法三：位运算" class="headerlink" title="方法三：位运算"></a>方法三：位运算</h1><p><strong>分析</strong></p><p>由于异或运算（XOR）满足结合律，并且对一个数进行两次完全相同的异或运算会得到原来的数，因此我们可以通过异或运算找到缺失的数字。</p><p><strong>算法</strong></p><p>我们知道数组中有 <em>n</em> 个数，并且缺失的数在 <em>[0..n]</em> 中。因此我们可以先得到 <em>[0..n]</em> 的异或值，再将结果对数组中的每一个数进行一次异或运算。未缺失的数在 <em>[0..n]</em> 和数组中各出现一次，因此异或后得到 0。而缺失的数字只在 <em>[0..n]</em> 中出现了一次，在数组中没有出现，因此最终的异或结果即为这个缺失的数字。</p><p>在编写代码时，由于 <em>[0..n]</em> 恰好是这个数组的下标加上 <em>n</em>，因此可以用一次循环完成所有的异或运算，例如下面这个例子：</p><table><thead><tr><th>下标</th><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>数字</td><td>0</td><td>1</td><td>3</td><td>4</td></tr></tbody></table><p>可以将结果的初始值设为 <em>n</em>，再对数组中的每一个数以及它的下标进行一个异或运算，<br>就得到了缺失的数字为 2。</p><details>    <summary>位运算Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> missing = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            missing ^= i ^ nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> missing;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>位运算Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        missing = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            missing ^= i ^ num</span><br><span class="line">        <span class="keyword">return</span> missing</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(n)*。这里假设异或运算的时间复杂度是常数的，总共会进行 *O(n)</em> 次异或运算，因此总的时间复杂度为 <em>O(n)</em>。</li><li>空间复杂度：<em>O(1)*。算法中只用到了 *O(1)</em> 的额外空间，用来存储答案。</li></ul><h1 id="方法四：数学"><a href="#方法四：数学" class="headerlink" title="方法四：数学"></a>方法四：数学</h1><p><strong>分析</strong></p><p>我们可以用 <a href="https://baike.baidu.com/item/%E9%AB%98%E6%96%AF%E6%B1%82%E5%92%8C" target="_blank" rel="noopener">高斯求和公式</a> 求出 <em>[0..n]</em> 的和，减去数组中所有数的和，就得到了缺失的数字。</p><p><strong>算法</strong></p><p>我们在线性时间内可以求出数组中所有数的和，并在常数时间内求出前 <em>n+1</em> 个自然数（包括 0）的和，将后者减去前者，就得到了缺失的数字。</p><details>    <summary>数学Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> expectedSum = nums.length*(nums.length + <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> actualSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) actualSum += num;</span><br><span class="line">        <span class="keyword">return</span> expectedSum - actualSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>数学Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        expected_sum = len(nums)*(len(nums)+<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line">        actual_sum = sum(nums)</span><br><span class="line">        <span class="keyword">return</span> expected_sum - actual_sum</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(n)</em>。求出数组中所有数的和的时间复杂度为 <em>O(n)</em>，高斯求和公式的时间复杂度为 <em>O(1)</em>，因此总的时间复杂度为 <em>O(n)</em>。</li><li>空间复杂度：<em>O(1)*。算法中只用到了 *O(1)</em> 的额外空间，用来存储答案。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>204. 计数质数</title>
    <link href="http://yoursite.com/2020/09/29/204.%20%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0/"/>
    <id>http://yoursite.com/2020/09/29/204. 计数质数/</id>
    <published>2020-09-29T08:30:12.000Z</published>
    <updated>2020-09-30T02:45:06.077Z</updated>
    
    <content type="html"><![CDATA[<p>统计所有小于非负整数 n 的质数的数量。</p><a id="more"></a><p>示例 1：</p><pre><code>输入：n = 10输出：4解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</code></pre><p>示例 2：</p><pre><code>输入：n = 0输出：0</code></pre><p>示例 3：</p><pre><code>输入：n = 1输出：0</code></pre><p>提示：</p><pre><code>0 &lt;= n &lt;= 5 * 106</code></pre><h1 id="总括："><a href="#总括：" class="headerlink" title="总括："></a>总括：</h1><p>此篇题解将共讲述暴力算法、优化暴力算法、厄拉多塞（话说这位老哥第一个量了地球周长）所创造的厄拉多塞筛法、及运用厄拉多塞筛法时于内存上的优化方法。在解释思路时，将尽量一步步地进行详细解读。</p><p>希望对大家能有所帮助！</p><hr><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h1><h2 id="暴力法（计算超时）："><a href="#暴力法（计算超时）：" class="headerlink" title="暴力法（计算超时）："></a><strong>暴力法（计算超时）：</strong></h2><p>验证一个数是否为质数（素数）有很多方法。但最容易想到的莫非用暴力计算的方式一步步碾压过去的方法。虽然这种方法不是最优的，但是其对于我们了解素数仍是有所帮助的。</p><p>思路：验证某个数是否为质数时，将其对每一个比其小的数进行取余运算，并对取余为零的情况进行计数。由于质数是指在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。所以，当计数结果为 1 时，该数为质数。</p><p>在实际操作中，由于 1 和任意一个数必然取余为零，所以可以直接排除。并当没有取余为零的情况时，其才为质数。</p><p>得代码如下：</p><details>    <summary>暴力法Csharp</summary><figure class="highlight csharp"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CountPrimes</span>(<span class="params"><span class="keyword">int</span> n</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> sign = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % j == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sign = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sign)</span><br><span class="line">            count++; ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>暴力法C++</summary><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">bool</span> sign = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i % j == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sign = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sign)</span><br><span class="line">            count++; ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="优化暴力算法："><a href="#优化暴力算法：" class="headerlink" title="优化暴力算法："></a><strong>优化暴力算法：</strong></h2><p>细究暴力计算的方法，我们可以发现，假如一个数为 9 ，那么其二分之一（4.5）后的数都可以不用进行计算，因为肯定是有余的 。事实上情况会比这更好一些：对正整数 n ，如果用 2 到 √n 之间(包含边界)的所有整数去除，均无法整除，则 n 为质数。</p><p>并且，我们可以发现，一切非 2 偶数一定不可能为质数。所以，我们可以在此处进行另一步的优化。</p><p>有个这些令人庆幸的发现，我们的代码也将如虎添翼：</p><details>    <summary>暴力法Csharp</summary><figure class="highlight csharp"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CountPrimes</span>(<span class="params"><span class="keyword">int</span> n</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;;</span><br><span class="line">    <span class="comment">//从3开始验算，所以初始值为1（2为质数）。</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当某个数为 2 的 n 次方时（n为自然数），其 &amp; (n - 1) 所得值将等价于取余运算所得值</span></span><br><span class="line">        <span class="comment">//*如果 x = 2^n ，则 x &amp; (n - 1) == x % n</span></span><br><span class="line">        <span class="comment">//if(i % 2 == 0)</span></span><br><span class="line">        <span class="keyword">if</span> ((i &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>; ;</span><br><span class="line">        <span class="keyword">bool</span> sign = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//用 j * j &lt;= i 代替 j &lt;= √i 会更好。</span></span><br><span class="line">        <span class="comment">//因为我们已经排除了所有偶数，所以每次循环加二将规避偶数会减少循环次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">3</span>; j * j &lt;=i; j+=<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % j == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sign = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sign)</span><br><span class="line">            count++; ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>暴力法C++</summary><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;;</span><br><span class="line">    <span class="comment">//从3开始验算，所以初始值为1（2为质数）。</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="comment">//当某个数为 2 的 n 次方时（n为自然数），其 &amp; (n - 1) 所得值将等价于取余运算所得值</span></span><br><span class="line">        <span class="comment">//*如果 x = 2^n ，则 x &amp; (n - 1) == x % n</span></span><br><span class="line">        <span class="comment">//if(i % 2 == 0)</span></span><br><span class="line">        <span class="keyword">if</span> ((i &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>; ;</span><br><span class="line">        <span class="keyword">bool</span> sign = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//用 j * j &lt;= i 代替 j &lt;= √i 会更好。</span></span><br><span class="line">        <span class="comment">//因为我们已经排除了所有偶数，所以每次循环加二将规避偶数会减少循环次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">3</span>; j * j &lt;=i; j+=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i % j == <span class="number">0</span>)&#123;</span><br><span class="line">                sign = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sign)</span><br><span class="line">            count++; ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>暴力法Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (odd(i)) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">odd</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i*i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>(暴力法系列的 C# 和 C++ 的代码几乎相同。)</p><p>经过对暴力算法的此番优化，我们的代码初步达到了应用的最低门槛，但显然还是不大理想，好似总感觉存在不必要的操作。但我们经过以上的研究（可以早一步排除偶数），再结合质数的性质，可以推想出：如果我们在进行顺序遍历时，每取得一个数（排除0、1），如果将它所有的倍数（排除0、1、本身）都清除，那么，剩下的数是不是必为素数？</p><p>没错，这个有趣且实用的方法便是著名的<strong>厄拉多塞筛法</strong>！</p><h2 id="三、厄拉多塞筛法："><a href="#三、厄拉多塞筛法：" class="headerlink" title="三、厄拉多塞筛法："></a><strong>三、厄拉多塞筛法：</strong></h2><p>使用厄拉多塞筛法进行 1 到 64 的质数查找的过程如下：</p><p> <a href="https://pic.leetcode-cn.com/a1faca1423ae40210283ae99735d3816702ccf4ea3d14b452bd31b52dc5c1ab7-%E8%B4%A8%E6%95%B001.png" target="_blank" rel="noopener">质数01.png</a> <a href="https://pic.leetcode-cn.com/9ce249c55336894269a24b07b24aeda45c9282d2bd7bcfe8b6a4924010f30c56-%E8%B4%A8%E6%95%B002.png" target="_blank" rel="noopener">质数02.png</a> <a href="https://pic.leetcode-cn.com/9907eb6310771945b98d85507e9ac396066eca6687d4a124d8d580cb4cb77331-%E8%B4%A8%E6%95%B003.png" target="_blank" rel="noopener">质数03.png</a> <a href="https://pic.leetcode-cn.com/44a83633f6e730b105c747efe1ea99f1ade9461278735ac1bb310264fe7f7890-%E8%B4%A8%E6%95%B004.png" target="_blank" rel="noopener">质数04.png</a> <a href="https://pic.leetcode-cn.com/11cdfac5138c3a0a1529407157264c066cc36b2acbd6160cb94fe848d5882c47-%E8%B4%A8%E6%95%B005.png" target="_blank" rel="noopener">质数05.png</a> <a href="https://pic.leetcode-cn.com/1474c46f44db885dd00a70dfb475d68cdde33a882cbd9f0e8f16561189441bd6-%E8%B4%A8%E6%95%B006.png" target="_blank" rel="noopener">质数06.png</a> <a href="https://pic.leetcode-cn.com/d1892c5f2c2fc9c76f7d998ac0bf57fa8f11579fb17a6e3305896d40c263b41e-%E8%B4%A8%E6%95%B007.png" target="_blank" rel="noopener">质数07.png</a> <a href="https://pic.leetcode-cn.com/4983199ef4fd10fff41c3e11f052793ea4c7e8fa1122ff1c31ece11a94eea561-%E8%B4%A8%E6%95%B008.png" target="_blank" rel="noopener">质数08.png</a> <a href="https://pic.leetcode-cn.com/cd1a2a9c42fc47a45c907c2e72f88421847d995275a677fd75c0eacce8996c06-%E8%B4%A8%E6%95%B009.png" target="_blank" rel="noopener">质数09.png</a> <a href="https://pic.leetcode-cn.com/e5172309e50d91eb5fced486d2b479677a6cbf594f157e18cc2b080b2cf7acdd-%E8%B4%A8%E6%95%B010.png" target="_blank" rel="noopener">质数10.png</a> <a href="https://pic.leetcode-cn.com/d9c9c9a293b63a9ae6b991f491add5a527b4ed0590c5c1e55bc1d7adf0bbcd30-%E8%B4%A8%E6%95%B011.png" target="_blank" rel="noopener">质数11.png</a> <a href="https://pic.leetcode-cn.com/f6bbb60ddcd9b5ad283163d9ac1612e128fc909120125192e86d77bdf80db6e9-%E8%B4%A8%E6%95%B012.png" target="_blank" rel="noopener">质数12.png</a> <a href="https://pic.leetcode-cn.com/95d13d8085953ddd6cba4298479fe110672e7331922b43b105c8eedaed14a870-%E8%B4%A8%E6%95%B013.png" target="_blank" rel="noopener">质数13.png</a> <a href="https://pic.leetcode-cn.com/9f6f86ac5a51f27e5abbeb25dd25cc527125ef7bcb3822e7ff6229b739166e7b-%E8%B4%A8%E6%95%B014.png" target="_blank" rel="noopener">质数14.png</a> <a href="https://pic.leetcode-cn.com/a81d726b272aec84d583574a6f8ab82245bf85591495a07aff84ed4f5db3db96-%E8%B4%A8%E6%95%B015.png" target="_blank" rel="noopener">质数15.png</a> <a href="https://pic.leetcode-cn.com/95be087f2ccf42f1e020ca2b762ab31eb82209c02a1f2dd5ddcf0ce3dec28eb3-%E8%B4%A8%E6%95%B016.png" target="_blank" rel="noopener">质数16.png</a> <a href="https://pic.leetcode-cn.com/d173b60cd95b8b6cbdadb8a8c5ccc477a8afd48093c3b4bac07216e1d0cd6b83-%E8%B4%A8%E6%95%B017.png" target="_blank" rel="noopener">质数17.png</a> </p><p>（做图片的时候把质数弄成了素数……）</p><p>对此，我们可以声明一个长度为最大限制数的布尔数组。用布尔值来区别筛选出的数和质数。</p><p>运用厄拉多塞筛法得代码如下：</p><details>    <summary>厄拉多塞筛法Csharp</summary><figure class="highlight csharp"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CountPrimes</span>(<span class="params"><span class="keyword">int</span> n</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span>[] signs = <span class="keyword">new</span> <span class="keyword">bool</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//因为在 C# 中，布尔类型的默认值为 假。所以在此处用了逻辑非（！）操作符。</span></span><br><span class="line">        <span class="keyword">if</span> (!signs[i])</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt; n; j += i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//排除不是质数的数</span></span><br><span class="line">                signs[j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>厄拉多塞筛法C++</summary><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//初始默认所有数为质数</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; signs(n, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (signs[i]) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt; n; j += i) &#123;</span><br><span class="line">                <span class="comment">//排除不是质数的数</span></span><br><span class="line">                signs[j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>厄拉多塞筛法Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] signs = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//因为在 Java 中，布尔类型的默认值为 假。所以在此处用了逻辑非（！）操作符。</span></span><br><span class="line">            <span class="keyword">if</span> (!signs[i]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt; n; j += i) &#123;</span><br><span class="line">                    signs[j] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>## **四、运用比特表（Bitmap）算法对筛法进行内存优化：**<p>上面运用厄拉多塞筛法求一定范围内的质数已经十分高效了。然而，我们使用布尔数组标记一个数是否为质数时，每个值都占用了一个字节（Byte）。但是，我们仅需要两个不同的值来表示是否为质数即可。即一个比特（bit）来表示即可（0、1）。如果这样的话，我们便最优可节省八分之七的空间（然而，还得结合代码和实际情况，并不是用了就一定有效果）。</p><ul><li>关于比特表算法在此便简要概述以下（可略过）：</li></ul><p>假如有从 1 至 8 总共八个数。现有一个字节大小的内存空间可供使用（仅供参考，不考虑实际用途及比特算法的最佳用处）。如何将每个数登记下来，并可以随时检查一个数是否存在呢？</p><p>如果用一个数组表示，即使不考虑数组的内存开销，哪怕用一个 byte 类型的变量记录每一数也将超出内存可使用范围。但是由于每个字节共有八个比特位，则可以用每个比特位来表示每个数字则恰好可以登记完所有的数字。</p><p>示例：</p><ol><li>登记数字 1 ：0 0 0 0 0 0 0 1</li><li>登记数字 1、3：0 0 0 0 0 1 0 1</li><li>登记数字 1、2、3、4、5 ：0 0 0 1 1 1 1 1</li></ol><p>得代码如下：</p><details>    <summary>运用比特表Csharp</summary><figure class="highlight csharp"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CountPrimes</span>(<span class="params"><span class="keyword">int</span> n</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//一个 int 变量占用 32 字节</span></span><br><span class="line">    <span class="comment">//在C#中，提供了点阵列（BitArray）数组，用这玩意可读性一定会好于我写的代码。</span></span><br><span class="line">    <span class="keyword">int</span>[] signs = <span class="keyword">new</span> <span class="keyword">int</span>[n / <span class="number">32</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将元素和需确定得数字经行按位或运算，如果值改变，说明不存在该数字（未登记该数字），则其为质数。</span></span><br><span class="line">        <span class="comment">//(当某个数为 2 的 n 次方时（n为自然数），其 &amp; (n - 1) 所得值将等价于取余运算所得值)</span></span><br><span class="line">        <span class="comment">//*如果 x = 2^n ，则 x &amp; (n - 1) == x % n</span></span><br><span class="line">        <span class="comment">//下面判断可以写成</span></span><br><span class="line">        <span class="comment">//if ((signs[i / size] &amp; (1 &lt;&lt; (i % 32))) == 0)</span></span><br><span class="line">        <span class="keyword">if</span> ((signs[i / <span class="number">32</span>] &amp; (<span class="number">1</span> &lt;&lt; (i &amp; <span class="number">31</span>))) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt; n; j += i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//登记该数字</span></span><br><span class="line">                signs[j / <span class="number">32</span>] |= <span class="number">1</span> &lt;&lt; (j &amp; <span class="number">31</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>运用比特表C++</summary><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//一个 int 变量不知道占多少字节（但请注意，这里采用了常量）</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; signs(n / size + <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="comment">//将元素和需确定得数字经行按位或运算，如果值改变，说明不存在该数字（未登记该数字），则其为质数。</span></span><br><span class="line">        <span class="comment">//在C++中，其提供了 bitset 来操作位，在此便不做介绍了。如果用了，可读性肯定会更好。</span></span><br><span class="line">        <span class="comment">//(当某个数为 2 的 n 次方时（n为自然数），其 &amp; (n - 1) 所得值将等价于取余运算所得值)</span></span><br><span class="line">        <span class="comment">//*如果 x = 2^n ，则 x &amp; (n - 1) == x % n</span></span><br><span class="line">        <span class="comment">//下面判断可以写成</span></span><br><span class="line">        <span class="comment">//if ((signs[i / size] &amp; (1 &lt;&lt; (i % 32))) == 0)</span></span><br><span class="line">        <span class="keyword">if</span> ((signs[i / size] &amp; (<span class="number">1</span> &lt;&lt; (i &amp; (size - <span class="number">1</span>)))) == <span class="number">0</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt; n; j += i)&#123;</span><br><span class="line">                <span class="comment">//登记该数字</span></span><br><span class="line">            signs[j / size] |= <span class="number">1</span> &lt;&lt; (j &amp; (size - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>经测试，C# 内存优化效果较为明显，但 C++ 效果不大明显。但这种方法显然是为了特殊情况而准备（比如一亿个数）。不过也可能是我写的不好。仅作参考，如果有所错误恳请您斧正。<p>（其实有时候代码的可读性要胜于代码改动所带来的一点的性能上的提升。）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;统计所有小于非负整数 n 的质数的数量。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>191. 位1的个数</title>
    <link href="http://yoursite.com/2020/09/28/191.%20%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>http://yoursite.com/2020/09/28/191. 位1的个数/</id>
    <published>2020-09-28T03:27:12.000Z</published>
    <updated>2020-09-29T08:37:42.516Z</updated>
    
    <content type="html"><![CDATA[<p>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。</p><a id="more"></a><p>示例 1：</p><pre><code>输入：00000000000000000000000000001011输出：3解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &apos;1&apos;。</code></pre><p>示例 2：</p><pre><code>输入：00000000000000000000000010000000输出：1解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &apos;1&apos;。</code></pre><p>示例 3：</p><pre><code>输入：11111111111111111111111111111101输出：31解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &apos;1&apos;。</code></pre><p>提示：</p><p>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</p><p>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。</p><p>进阶:</p><pre><code>如果多次调用这个函数，你将如何优化你的算法？</code></pre><h1 id="方法-1：循环和位移动"><a href="#方法-1：循环和位移动" class="headerlink" title="方法 1：循环和位移动"></a>方法 1：循环和位移动</h1><p><strong>算法</strong></p><p>这个方法比较直接。我们遍历数字的 32 位。如果某一位是 <em>1</em> ，将计数器加一。</p><p>我们使用 <em>位掩码</em> 来检查数字的第 <em>i^{th}</em> 位。一开始，掩码 <em>m=1</em> 因为 <em>1</em> 的二进制表示是</p><pre><code>0000 0000 0000 0000 0000 0000 0000 0001</code></pre><p>显然，任何数字跟掩码 <em>1</em> 进行逻辑与运算，都可以让我们获得这个数字的最低位。检查下一位时，我们将掩码左移一位。</p><pre><code>0000 0000 0000 0000 0000 0000 0000 0010</code></pre><p>并重复此过程。</p><details>    <summary>循环和位移动</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bits = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mask = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n &amp; mask) != <span class="number">0</span>) &#123;</span><br><span class="line">            bits++;</span><br><span class="line">        &#125;</span><br><span class="line">        mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(1)</em> 。运行时间依赖于数字 <em>n</em> 的位数。由于这题中 <em>n</em> 是一个 32 位数，所以运行时间是 <em>O(1)</em> 的。</p></li><li><p>空间复杂度：<em>O(1)</em>。没有使用额外空间。</p></li></ul><h1 id="方法-2：位操作的小技巧"><a href="#方法-2：位操作的小技巧" class="headerlink" title="方法 2：位操作的小技巧"></a>方法 2：位操作的小技巧</h1><p><strong>算法</strong></p><p>我们可以把前面的算法进行优化。我们不再检查数字的每一个位，而是不断把数字最后一个 <em>1</em> 反转，并把答案加一。当数字变成 <em>0</em> 的时候偶，我们就知道它没有 <em>1</em> 的位了，此时返回答案。</p><p>这里关键的想法是对于任意数字 <em>n</em> ，将 <em>n</em> 和 <em>n - 1</em> 做与运算，会把最后一个 <em>1</em> 的位变成 <em>0</em> 。为什么？考虑 <em>n</em> 和 <em>n - 1</em> 的二进制表示。</p><p><a href="https://pic.leetcode-cn.com/abfd6109e7482d70d20cb8fc1d632f90eacf1b5e89dfecb2e523da1bcb562f66-image.png" target="_blank" rel="noopener">image.png</a></p><p><em>图片 1. 将 *n</em> 和 <em>n-1</em> 做与运算会将最低位的 <em>1</em> 变成 <em>0*</em></p><p>在二进制表示中，数字 <em>n</em> 中最低位的 <em>1</em> 总是对应 <em>n - 1</em> 中的 <em>0</em> 。因此，将 <em>n</em> 和 <em>n - 1</em> 与运算总是能把 <em>n</em> 中最低位的 <em>1</em> 变成 <em>0</em> ，并保持其他位不变。</p><p>使用这个小技巧，代码变得非常简单。</p><details>    <summary>位操作的小技巧</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        sum++;</span><br><span class="line">        n &amp;= (n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>**复杂度分析**<ul><li><p>时间复杂度：<em>O(1)</em> 。运行时间与 <em>n</em> 中位为 <em>1</em> 的有关。在最坏情况下， <em>n</em> 中所有位都是 <em>1</em> 。对于 32 位整数，运行时间是 <em>O(1)</em> 的。</p></li><li><p>空间复杂度：<em>O(1)</em> 。没有使用额外空间。</p></li></ul><h1 id="位运算技巧"><a href="#位运算技巧" class="headerlink" title="位运算技巧"></a>位运算技巧</h1><h2 id="n-amp-n-1-把最后一个-1-的位变成-0"><a href="#n-amp-n-1-把最后一个-1-的位变成-0" class="headerlink" title="n &amp; (n-1) 把最后一个 1 的位变成 0"></a>n &amp; (n-1) 把最后一个 1 的位变成 0</h2><p>任意数字 n ，将 n 和 n - 1 做与运算，会把最后一个 1 的位变成 0</p><h2 id="n-amp-n-保留-n-最右边的-1"><a href="#n-amp-n-保留-n-最右边的-1" class="headerlink" title="n &amp; (-n) 保留 n 最右边的 1"></a>n &amp; (-n) 保留 <code>n</code> 最右边的 <code>1</code></h2><p>我们通过 <code>n &amp; (-n)</code> 保留 <code>n</code> 最右边的 <code>1</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
  <entry>
    <title>172. 阶乘后的零</title>
    <link href="http://yoursite.com/2020/09/27/172.%20%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6/"/>
    <id>http://yoursite.com/2020/09/27/172. 阶乘后的零/</id>
    <published>2020-09-27T07:27:12.000Z</published>
    <updated>2020-09-27T07:56:47.989Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数 n，返回 n! 结果尾数中零的数量。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: 3输出: 0解释: 3! = 6, 尾数中没有零。</code></pre><p>示例 2:</p><pre><code>输入: 5输出: 1解释: 5! = 120, 尾数中有 1 个零.说明: 你算法的时间复杂度应为 O(log n) 。</code></pre><h1 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h1><p>看到这道题首先排除掉计算阶乘，先求乘数中含有10，5，2的个数，零的数量取决于这三个因子</p><details>    <summary>解法一</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int trailingZeroes(int n) &#123;</span><br><span class="line">        int numfive=0;</span><br><span class="line">        int numtwo=0;</span><br><span class="line">        int numten=0;</span><br><span class="line">        for (int j = 1; j &lt;= n; j++) &#123;</span><br><span class="line">            int i = j;</span><br><span class="line">            while (i % 10 == 0) &#123;</span><br><span class="line">                numten++;</span><br><span class="line">                i = i / 10;</span><br><span class="line">            &#125;</span><br><span class="line">            while (i % 5 == 0) &#123;</span><br><span class="line">                numfive++;</span><br><span class="line">                i = i / 5;</span><br><span class="line">            &#125;</span><br><span class="line">            while (i % 2 == 0) &#123;</span><br><span class="line">                numtwo++;</span><br><span class="line">                i = i / 2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return numten + Math.min(numfive, numtwo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h1><p>之前小红书面试的时候碰到的一道题，没想到又是 leetcode 的原题。这种没有通用解法的题，完全依靠于对题目的分析理解了，自己当时也是在面试官的提示下慢慢出来的，要是想不到题目的点，还是比较难做的。</p><p>首先肯定不能依赖于把阶乘算出来再去判断有多少个零了，因为阶乘很容易就溢出了，所以先一步一步理一下思路吧。</p><p>首先末尾有多少个 <code>0</code> ，只需要给当前数乘以一个 <code>10</code> 就可以加一个 <code>0</code>。</p><p>再具体对于 <code>5!</code>，也就是 <code>5 * 4 * 3 * 2 * 1 = 120</code>，我们发现结果会有一个 <code>0</code>，原因就是 <code>2</code> 和 <code>5</code> 相乘构成了一个 <code>10</code>。而对于 <code>10</code> 的话，其实也只有 <code>2 * 5</code>  可以构成，所以我们只需要找有多少对 <code>2/5</code>。</p><p>我们把每个乘数再稍微分解下，看一个例子。</p><p><code>11! = 11 * 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1 = 11 * (2 * 5) * 9 * (4 * 2) * 7 * (3 * 2) * (1 * 5) * (2 * 2) * 3 * (1 * 2) * 1</code></p><p>对于含有 <code>2</code> 的因子的话是  <code>1 * 2, 2 * 2, 3 * 2, 4 * 2 ...</code></p><p>对于含有 <code>5</code> 的因子的话是  <code>1 * 5, 2 * 5...</code></p><p>含有 <code>2</code> 的因子每两个出现一次，含有 <code>5</code> 的因子每 <code>5</code> 个出现一次，所有 <code>2</code> 出现的个数远远多于 <code>5</code>，换言之找到一个 <code>5</code>，一定能找到一个 <code>2</code> 与之配对。所以我们只需要找有多少个 <code>5</code>。</p><p>直接的，我们只需要判断每个累乘的数有多少个 <code>5</code> 的因子即可。</p><details>    <summary>解法二</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> N = i;</span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (N % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                N /= <span class="number">5</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>但发生了超时，我们继续分析。</p><p>对于一个数的阶乘，就如之前分析的，<code>5</code> 的因子一定是每隔 <code>5</code> 个数出现一次，也就是下边的样子。</p><p><code>n! = 1 * 2 * 3 * 4 * (1 * 5) * ... * (2 * 5) * ... * (3 * 5) *... * n</code></p><p>因为每隔 <code>5</code> 个数出现一个 <code>5</code>，所以计算出现了多少个 <code>5</code>，我们只需要用 <code>n/5</code> 就可以算出来。</p><p>但还没有结束，继续分析。</p><p><code>... * (1 * 5) * ... * (1 * 5 * 5) * ... * (2 * 5 * 5) * ... * (3 * 5 * 5) * ... * n</code></p><p>每隔 <code>25</code> 个数字，出现的是两个 <code>5</code>，所以除了每隔 <code>5</code> 个数算作一个 <code>5</code>，每隔 <code>25</code> 个数，还需要多算一个 <code>5</code>。</p><p>也就是我们需要再加上 <code>n / 25</code> 个 <code>5</code>。</p><p>同理我们还会发现每隔 <code>5 * 5 * 5 = 125</code> 个数字，会出现 <code>3</code> 个 <code>5</code>，所以我们还需要再加上 <code>n / 125</code> 。</p><p>综上，规律就是每隔 <code>5</code> 个数，出现一个 <code>5</code>，每隔 <code>25</code> 个数，出现 <code>2</code> 个 <code>5</code>，每隔 <code>125</code> 个数，出现 <code>3</code> 个 <code>5</code>… 以此类推。</p><p>最终 <code>5</code> 的个数就是 <code>n / 5 + n / 25 + n / 125 ...</code></p><p>写程序的话，如果直接按照上边的式子计算，分母可能会造成溢出。所以算 <code>n / 25</code> 的时候，我们先把 <code>n</code> 更新，<code>n = n / 5</code>，然后再计算 <code>n / 5</code> 即可。后边的同理。</p><details>    <summary>解法二</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        count += n / <span class="number">5</span>;</span><br><span class="line">        n = n / <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数 n，返回 n! 结果尾数中零的数量。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>190. 颠倒二进制位</title>
    <link href="http://yoursite.com/2020/09/27/190.%20%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/"/>
    <id>http://yoursite.com/2020/09/27/190. 颠倒二进制位/</id>
    <published>2020-09-27T07:27:12.000Z</published>
    <updated>2020-09-28T03:12:13.275Z</updated>
    
    <content type="html"><![CDATA[<p>颠倒给定的 32 位无符号整数的二进制位。</p><a id="more"></a><p>示例 1：</p><pre><code>输入: 00000010100101000001111010011100输出: 00111001011110000010100101000000解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。</code></pre><p>示例 2：</p><pre><code>输入：11111111111111111111111111111101输出：10111111111111111111111111111111解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。</code></pre><p>提示：</p><pre><code>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。</code></pre><p>进阶:</p><pre><code>如果多次调用这个函数，你将如何优化你的算法？</code></pre><h1 id="方法一：逐位颠倒"><a href="#方法一：逐位颠倒" class="headerlink" title="方法一：逐位颠倒"></a>方法一：逐位颠倒</h1><p>虽然这个问题并不难，但它常常是面试开始时的一个热身问题。重点是测试一个人对数据类型和位操作的基本知识。</p><p>在面试的时候逐位颠倒作为最直接的解决方案。</p><p><a href="https://pic.leetcode-cn.com/15bcf5b6db9b5211046655737571e3fe2668f9ecfc24ce517cd2b0882824aecd-file_1585801736085" target="_blank" rel="noopener">逐位颠倒</a></p><p>尽管听起来很简单，但上述逻辑的不同实现产生不同的解决方案。例如，要检索整数 <code>n</code> 中最右边的位，可以应用模运算（即 <code>n%2</code>）或与运算（即 <code>n &amp;1</code>）。另一个例子是，为了组合反转位（例如 <em>2^a，2^b</em>）的结果，可以使用加法运算（即 <em>2^a+2^b</em>）或再次使用位或运算（即 <em>2^a | 2^b</em>）。</p><p><strong>算法：</strong><br>在这里，我们将展示基于上述逻辑的实现示例。</p><p><a href="https://pic.leetcode-cn.com/ca2460d77758bd033e787f6b1602f5571891520acae4eefa7bcc7f1fe48b5a2e-file_1585801736110" target="_blank" rel="noopener">实现示例</a><br>关键思想是，对于位于索引 <code>i</code> 处的位，在反转之后，其位置应为 <code>31-i</code>（注：索引从零开始）。</p><ul><li>我们从右到左遍历输入整数的位字符串（即 <code>n=n&gt;&gt;1</code>）。要检索整数的最右边的位，我们应用与运算（<code>n&amp;1</code>）。</li><li>对于每个位，我们将其反转到正确的位置（即<code>（n&amp;1）&lt;&lt;power</code>）。然后添加到最终结果。</li><li>当 <code>n==0</code> 时，我们终止迭代。</li></ul><details>    <summary>逐位颠倒Java</summary><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 1. 将给定的二进制数,由低到高位逐个取出</span></span><br><span class="line">            <span class="comment">// 1.1 右移 i 位,</span></span><br><span class="line">            <span class="keyword">int</span> tmp = n &gt;&gt; i;</span><br><span class="line">            <span class="comment">// 1.2  取有效位</span></span><br><span class="line">            tmp = tmp &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 2. 然后通过位运算将其放置到反转后的位置.</span></span><br><span class="line">            tmp = tmp &lt;&lt; (<span class="number">31</span> - i);</span><br><span class="line">            <span class="comment">// 3. 将上述结果再次通过运算结合到一起</span></span><br><span class="line">            result |= tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>逐位颠倒Python</summary><figure class="highlight python"><figcaption><span>[solution1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param n, an integer</span></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBits</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        ret, power = <span class="number">0</span>, <span class="number">31</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            ret += (n &amp; <span class="number">1</span>) &lt;&lt; power</span><br><span class="line">            n = n &gt;&gt; <span class="number">1</span></span><br><span class="line">            power -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure></details><details>    <summary>逐位颠倒C++</summary><figure class="highlight c++"><figcaption><span>[solution1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">uint32_t</span> reverseBits(<span class="keyword">uint32_t</span> n) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> ret = <span class="number">0</span>, power = <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">      ret += (n &amp; <span class="number">1</span>) &lt;&lt; power;</span><br><span class="line">      n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      power -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>逐位颠倒Go</summary><figure class="highlight go"><figcaption><span>[solution1-Go]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseBits</span><span class="params">(num <span class="keyword">uint32</span>)</span> <span class="title">uint32</span></span> &#123;</span><br><span class="line">    ret := <span class="keyword">uint32</span>(<span class="number">0</span>)</span><br><span class="line">    power := <span class="keyword">uint32</span>(<span class="number">31</span>)</span><br><span class="line">    <span class="keyword">for</span> num != <span class="number">0</span> &#123;</span><br><span class="line">        ret += (num &amp; <span class="number">1</span>) &lt;&lt; power</span><br><span class="line">        num = num &gt;&gt; <span class="number">1</span></span><br><span class="line">        power -= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>**复杂度分析**<ul><li>时间复杂度：log_2(N) 。在算法中，我们有一个循环来迭代输入的最高非零位，即log_2(N)  。</li><li>空间复杂度：O(1) ，因为不管输入是什么，内存的消耗是固定的。</li></ul><h1 id="方法二：带记忆化的按字节颠倒"><a href="#方法二：带记忆化的按字节颠倒" class="headerlink" title="方法二：带记忆化的按字节颠倒"></a>方法二：带记忆化的按字节颠倒</h1><p>有人可能会说，每字节（8 位的比特位）反转可能更有效。由于该题的输入是固定的 32 位整数，所以在本题中不一定是这样的。但是在处理长字节流时，它会变得更有效。</p><p><a href="https://pic.leetcode-cn.com/365599a4030d26a019d37ad97c201e64e2fa3ae9fd7b43d689e8a4d7f802141e-file_1585801736122" target="_blank" rel="noopener">带记忆化的按字节颠倒</a></p><p>使用字节作为迭代单位的另一个隐含优点是，我们可以使用记忆化技术，可以缓存先前计算的值，以避免重新计算。</p><p>记忆化的后续问题是：如果该函数多次被调用，你该如何优化。</p><p>若要按自己为单位反转位，可以应用上述所示的算法。在这里，我们展示一种完全基于算术和位操作，不基于任何循环语句，如下所示：</p><figure class="highlight python"><figcaption><span>[example-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseByte</span><span class="params">(byte)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (byte * <span class="number">0x0202020202</span> &amp; <span class="number">0x010884422010</span>) % <span class="number">1023</span></span><br></pre></td></tr></table></figure><p>这个算法为用 3 个操作反转一个字节中的位，在 Sean Eron Anderson 的在线电子书 Bit Twiddling Hacks 中可以看到更多的细节。</p><p><strong>算法：</strong></p><ul><li>我们按字节遍历整数。为了检索整数中最右边的字节，我们应用位掩码为 <code>11111111</code> 的与操作（即 <code>n&amp;0xff</code>）。</li><li>对于每个字节，首先我们通过一个名为 <code>reverseByte(byte)</code> 的函数来反转字节中的位。然后将反转的结果添加到答案中。</li><li>对于函数 <code>reverseByte(byte)</code>，我们使用记忆化技术，它缓存函数的结果并直接返回结果，以便将来遇到相同的输入。</li></ul><p>注意，可以选择更小的单位而不是字节，例如 4 位的单位，这将需要更多的计算来交换更少的缓存空间。记忆化技术是空间和计算时间之间的权衡。</p><details>    <summary>带记忆化的按字节颠倒Python</summary><figure class="highlight python"><figcaption><span>[solution21-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param n, an integer</span></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBits</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        ret, power = <span class="number">0</span>, <span class="number">24</span></span><br><span class="line">        cache = dict()</span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            ret += self.reverseByte(n &amp; <span class="number">0xff</span>, cache) &lt;&lt; power</span><br><span class="line">            n = n &gt;&gt; <span class="number">8</span></span><br><span class="line">            power -= <span class="number">8</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseByte</span><span class="params">(self, byte, cache)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> byte <span class="keyword">not</span> <span class="keyword">in</span> cache:</span><br><span class="line">            cache[byte] = (byte * <span class="number">0x0202020202</span> &amp; <span class="number">0x010884422010</span>) % <span class="number">1023</span> </span><br><span class="line">        <span class="keyword">return</span> cache[byte]</span><br></pre></td></tr></table></figure></details><details>    <summary>带记忆化的按字节颠倒Python</summary><figure class="highlight python"><figcaption><span>[solution21-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param n, an integer</span></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBits</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        ret, power = <span class="number">0</span>, <span class="number">24</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            ret += self.reverseByte(n &amp; <span class="number">0xff</span>) &lt;&lt; power</span><br><span class="line">            n = n &gt;&gt; <span class="number">8</span></span><br><span class="line">            power -= <span class="number">8</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">    <span class="comment"># memoization with decorator</span></span><br><span class="line"><span class="meta">    @functools.lru_cache(maxsize=256)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseByte</span><span class="params">(self, byte)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (byte * <span class="number">0x0202020202</span> &amp; <span class="number">0x010884422010</span>) % <span class="number">1023</span></span><br></pre></td></tr></table></figure></details><details>    <summary>带记忆化的按字节颠倒C++</summary><figure class="highlight c++"><figcaption><span>[solution21-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">uint32_t</span> reverseByte(<span class="keyword">uint32_t</span> byte, <span class="built_in">map</span>&lt;<span class="keyword">uint32_t</span>, <span class="keyword">uint32_t</span>&gt; cache) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache.find(byte) != cache.end()) &#123;</span><br><span class="line">            <span class="keyword">return</span> cache[byte];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">uint32_t</span> value = (byte * <span class="number">0x0202020202</span> &amp; <span class="number">0x010884422010</span>) % <span class="number">1023</span>;</span><br><span class="line">        cache.emplace(byte, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> reverseBits(<span class="keyword">uint32_t</span> n) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> ret = <span class="number">0</span>, power = <span class="number">24</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">uint32_t</span>, <span class="keyword">uint32_t</span>&gt; cache;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            ret += reverseByte(n &amp; <span class="number">0xff</span>, cache) &lt;&lt; power;</span><br><span class="line">            n = n &gt;&gt; <span class="number">8</span>;</span><br><span class="line">            power -= <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>带记忆化的按字节颠倒Go</summary><figure class="highlight go"><figcaption><span>[solution21-Go]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseByte</span><span class="params">(b <span class="keyword">uint32</span>, cache <span class="keyword">map</span>[<span class="keyword">uint32</span>]<span class="keyword">uint64</span>)</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line">    value, ok := cache[b]</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">    value = (<span class="keyword">uint64</span>(b) * <span class="number">0x0202020202</span> &amp; <span class="number">0x010884422010</span>) % <span class="number">1023</span></span><br><span class="line">    cache[b] = value</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseBits</span><span class="params">(num <span class="keyword">uint32</span>)</span> <span class="title">uint32</span></span> &#123;</span><br><span class="line">    ret := <span class="keyword">uint64</span>(<span class="number">0</span>)</span><br><span class="line">    power := <span class="keyword">uint64</span>(<span class="number">24</span>)</span><br><span class="line">    <span class="keyword">var</span> cache = <span class="keyword">map</span>[<span class="keyword">uint32</span>]<span class="keyword">uint64</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> num != <span class="number">0</span> &#123;</span><br><span class="line">        ret += reverseByte(num &amp; <span class="number">0xff</span>, cache) &lt;&lt; power</span><br><span class="line">        num = num &gt;&gt; <span class="number">8</span></span><br><span class="line">        power -= <span class="number">8</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">uint32</span>(ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(1) 。尽管我们在算法中有一个循环，但是无论输入是什么，迭代次数都是固定的，因为在我们的问题中整数是固定大小（32 位）的。</li><li>空间复杂度：O(1) ，同样，尽管我们使用了缓存来保留反转字节的结果，但缓存中的大小总数限制为 <em>2^8=256</em>。</li></ul><h1 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h1><p>在方法 2 中，我们展示了一个关于如何在不使用循环语句的情况下反转字节中的位的示例。</p><p><strong>在面试过程中，你可能会被要求在不使用循环的情况下反转整个 32 位。</strong> </p><p>在这里，我们提出了一种只使用位操作的解决方案。</p><p>这种思想可以看作是一种分治的策略，我们通过掩码将 32 位整数划分成具有较少位的块，然后通过将每个块反转，最后将每个块的结果合并得到最终结果。</p><p>在下图中，我们演示如何使用上述思想反转两个位。同样的，这个想法可以应用到比特块上。</p><p><a href="https://pic.leetcode-cn.com/c57a82424197ba1f4091a67cc4a6c575b35dcc0bf9d077415838d3b22d4b1ff3-file_1585801736118" target="_blank" rel="noopener">不使用循环语句的情况下反转字节中的位</a></p><p><strong>算法：</strong></p><p>我们可以通过以下步骤实现该算法：</p><ul><li>首先，我们将原来的 32 位分为 2 个 16 位的块。</li><li>然后我们将 16 位块分成 2 个 8 位的块。</li><li>然后我们继续将这些块分成更小的块，直到达到 1 位的块。</li><li>在上述每个步骤中，我们将中间结果合并为一个整数，作为下一步的输入。</li></ul><p>既然知道 int 值一共32位，那么可以采用分治思想，反转左右16位，然后反转每个16位中的左右8位，依次类推，最后反转2位，反转后合并即可，同时可以利用位运算在原地反转。JDK中的Integer.bitCount()函数也是使用类似的方法。</p><p>这么说比较抽象，可以直接结合代码看下面的步骤，也可以拿代码在IDE中debug一下，看每一步都做了什么</p><ol><li>首先随便找一个数 (为了看的清楚用_作分隔，可以忽略)</li></ol><pre><code>十进制43261596;   // 0000 ‭0010 1001 0100 _ 0001 1110 1001 1100‬</code></pre><ol start="2"><li>左边16位移到右边，右边16位移到左边，然后使用|符号合并起来</li></ol><pre><code>Java中的无符号位移 &gt;&gt;&gt;：无论是正数还是负数，高位通通补0。&gt;&gt;：带符号右移。正数右移高位补0，负数右移高位补1。|：按位或逻辑，该位只要有一位为1，结果就为1，这里用来合并</code></pre><ol start="3"><li>使用一些有规律的数，将16位，再分成左右8位进行反转后合并，起始数字变为‭0001 1110 1001 1100 _ 0000 0010 1001 0100‬</li></ol><pre><code>0xff00ff00 表示16进制数1111 1111 0000 0000 _ 1111 1111 0000 0000 ，0x00ff00ff 表示16进制数0000 0000 1111 1111 _ 0000 0000 1111 1111，</code></pre><ol start="4"><li><p>重复以上步骤，分组、合并，最后得到反转后的结果。</p></li><li><p>总结来说就是利用位运算进行反转，同时存储反转后的数，继续分治进行反转，直到全部反转完成，变化过程为：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 原数字43261596</span><br><span class="line"> 0000 ‭0010 1001 0100 _ 0001 1110 1001 1100‬ </span><br><span class="line">// 反转左右16位：</span><br><span class="line">‭ 0001 1110 1001 1100 _ 0000 0010 1001 0100‬ </span><br><span class="line">// 继续分为8位一组反转：</span><br><span class="line"> 1001 1100 0001 1110 _ 1001 0100 0000 0010</span><br><span class="line">// 4位一组反转：</span><br><span class="line"> 1100 1001 1110 0001 _ 0100 1001 0010 0000‬</span><br><span class="line">// 2位一组反转：</span><br><span class="line"> 0011 0110 1011 0100 _ 0001 0110 1000 0000</span><br><span class="line">// 每两位再反转一下</span><br><span class="line">‭ 0011 1001 0111 1000 _ 0010 1001 0100 0000‬‬</span><br><span class="line">// 这就是43261596反转后的结果：‭964176192‬</span><br></pre></td></tr></table></figure><details>    <summary>不使用循环语句的情况下反转字节中的位Java</summary><figure class="highlight java"><figcaption><span>[solution3-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        n = (n &gt;&gt;&gt; <span class="number">16</span>) | (n &lt;&lt; <span class="number">16</span>); </span><br><span class="line">        n = ((n &amp; <span class="number">0xff00ff00</span>) &gt;&gt;&gt; <span class="number">8</span>) | ((n &amp; <span class="number">0x00ff00ff</span>) &lt;&lt; <span class="number">8</span>); </span><br><span class="line">        n = ((n &amp; <span class="number">0xf0f0f0f0</span>) &gt;&gt;&gt; <span class="number">4</span>) | ((n &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span>); </span><br><span class="line">        n = ((n &amp; <span class="number">0xcccccccc</span>) &gt;&gt;&gt; <span class="number">2</span>) | ((n &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span>); </span><br><span class="line">        n = ((n &amp; <span class="number">0xaaaaaaaa</span>) &gt;&gt;&gt; <span class="number">1</span>) | ((n &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span>); </span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>不使用循环语句的情况下反转字节中的位Python</summary><figure class="highlight python"><figcaption><span>[solution3-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param n, an integer</span></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBits</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        n = (n &gt;&gt; <span class="number">16</span>) | (n &lt;&lt; <span class="number">16</span>)</span><br><span class="line">        n = ((n &amp; <span class="number">0xff00ff00</span>) &gt;&gt; <span class="number">8</span>) | ((n &amp; <span class="number">0x00ff00ff</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">        n = ((n &amp; <span class="number">0xf0f0f0f0</span>) &gt;&gt; <span class="number">4</span>) | ((n &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span>)</span><br><span class="line">        n = ((n &amp; <span class="number">0xcccccccc</span>) &gt;&gt; <span class="number">2</span>) | ((n &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span>)</span><br><span class="line">        n = ((n &amp; <span class="number">0xaaaaaaaa</span>) &gt;&gt; <span class="number">1</span>) | ((n &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n</span><br></pre></td></tr></table></figure></details><details>    <summary>不使用循环语句的情况下反转字节中的位C++</summary><figure class="highlight c++"><figcaption><span>[solution3-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">uint32_t</span> reverseBits(<span class="keyword">uint32_t</span> n) &#123;</span><br><span class="line">        n = (n &gt;&gt; <span class="number">16</span>) | (n &lt;&lt; <span class="number">16</span>);</span><br><span class="line">        n = ((n &amp; <span class="number">0xff00ff00</span>) &gt;&gt; <span class="number">8</span>) | ((n &amp; <span class="number">0x00ff00ff</span>) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">        n = ((n &amp; <span class="number">0xf0f0f0f0</span>) &gt;&gt; <span class="number">4</span>) | ((n &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span>);</span><br><span class="line">        n = ((n &amp; <span class="number">0xcccccccc</span>) &gt;&gt; <span class="number">2</span>) | ((n &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        n = ((n &amp; <span class="number">0xaaaaaaaa</span>) &gt;&gt; <span class="number">1</span>) | ((n &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>不使用循环语句的情况下反转字节中的位Go</summary><figure class="highlight go"><figcaption><span>[solution3-Go]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseBits</span><span class="params">(num <span class="keyword">uint32</span>)</span> <span class="title">uint32</span></span> &#123;</span><br><span class="line">    num = (num &gt;&gt; <span class="number">16</span>) | (num &lt;&lt; <span class="number">16</span>)</span><br><span class="line">    num = ((num &amp; <span class="number">0xff00ff</span>00) &gt;&gt; <span class="number">8</span>) | ((num &amp; <span class="number">0x00ff00ff</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">    num = ((num &amp; <span class="number">0xf0f0f0f</span>0) &gt;&gt; <span class="number">4</span>) | ((num &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span>)</span><br><span class="line">    num = ((num &amp; <span class="number">0xcccccccc</span>) &gt;&gt; <span class="number">2</span>) | ((num &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span>)</span><br><span class="line">    num = ((num &amp; <span class="number">0xaaaaaaaa</span>) &gt;&gt; <span class="number">1</span>) | ((num &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(1) ，没有使用循环。</li><li>空间复杂度：O(1) ，没有使用变量。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;颠倒给定的 32 位无符号整数的二进制位。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
  <entry>
    <title>166. 分数到小数</title>
    <link href="http://yoursite.com/2020/09/18/166.%20%E5%88%86%E6%95%B0%E5%88%B0%E5%B0%8F%E6%95%B0/"/>
    <id>http://yoursite.com/2020/09/18/166. 分数到小数/</id>
    <published>2020-09-18T09:27:12.000Z</published>
    <updated>2020-09-27T07:22:11.464Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个整数，分别表示分数的分子numerator和分母denominator，以字符串形式返回小数。</p><a id="more"></a><p>如果小数部分为循环小数，则将循环的部分括在括号内。</p><p>示例 1:</p><pre><code>输入: numerator = 1, denominator = 2输出: &quot;0.5&quot;</code></pre><p>示例 2:</p><pre><code>输入: numerator = 2, denominator = 1输出: &quot;2&quot;</code></pre><p>示例 3:</p><pre><code>输入: numerator = 2, denominator = 3输出: &quot;0.(6)&quot;</code></pre><h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>这是一道非常直观的代码题，但需要考虑很多细节。</p><h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><ol><li>不需要复杂的数学知识，只需要数学的基本知识。了解长除法的运算规则。</li><li>使用长除法计算 4/9 ，循环节很显然就会找到。那么计算 4/333 呢，能找到规律吗？</li><li>注意边界情况！列出所有你可以想到的测试数据并验证你的代码。</li></ol><h1 id="方法：长除法"><a href="#方法：长除法" class="headerlink" title="方法：长除法"></a>方法：长除法</h1><p><strong>思路</strong></p><p>核心思想是当余数出现循环的时候，对应的商也会循环。参见<a href="https://leetcode-cn.com/problems/fraction-to-recurring-decimal/solution/fen-shu-dao-xiao-shu-by-leetcode/" target="_blank" rel="noopener">^1</a></p><p><strong>算法</strong></p><p>需要用一个哈希表记录余数出现在小数部分的位置，当你发现已经出现的余数，就可以将重复出现的小数部分用括号括起来。</p><p>再出发过程中余数可能为 0，意味着不会出现循环小数，立刻停止程序。</p><p>就像 <a href="(https://leetcode-cn.com/problems/divide-two-integers/)">两数相除</a> 问题一样，要考虑负分数以及极端情况，比如说-2147483648/-1  。</p><p>下面列出了一些很好的测试样例：</p><table><thead><tr><th>测试样例</th><th>解释</th></tr></thead><tbody><tr><td>0/1</td><td>被除数为 0。</td></tr><tr><td>1/0</td><td>除数为 0，应当抛出异常，这里为了简单起见不考虑。</td></tr><tr><td>20/4</td><td>答案是整数，不包括小数部分。</td></tr><tr><td>1/2</td><td>答案是 0.5，是有限小数。</td></tr><tr><td>-1/4 or 1/-4</td><td>除数被除数有一个为负数，结果为负数。</td></tr><tr><td>-1/-4</td><td>除数和被除数都是负数，结果为正数。</td></tr><tr><td>-2147483648/-1</td><td>转成整数时注意可能溢出。</td></tr></tbody></table><details>    <summary>长除法</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">fractionToDecimal</span><span class="params">(<span class="keyword">int</span> numerator, <span class="keyword">int</span> denominator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numerator == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder fraction = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">// If either one is negative (not both)</span></span><br><span class="line">    <span class="keyword">if</span> (numerator &lt; <span class="number">0</span> ^ denominator &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        fraction.append(<span class="string">"-"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Convert to Long or else abs(-2147483648) overflows</span></span><br><span class="line">    <span class="keyword">long</span> dividend = Math.abs(Long.valueOf(numerator));</span><br><span class="line">    <span class="keyword">long</span> divisor = Math.abs(Long.valueOf(denominator));</span><br><span class="line">    fraction.append(String.valueOf(dividend / divisor));</span><br><span class="line">    <span class="keyword">long</span> remainder = dividend % divisor;</span><br><span class="line">    <span class="keyword">if</span> (remainder == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fraction.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    fraction.append(<span class="string">"."</span>);</span><br><span class="line">    Map&lt;Long, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (remainder != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(remainder)) &#123;</span><br><span class="line">            fraction.insert(map.get(remainder), <span class="string">"("</span>);</span><br><span class="line">            fraction.append(<span class="string">")"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(remainder, fraction.length());</span><br><span class="line">        remainder *= <span class="number">10</span>;</span><br><span class="line">        fraction.append(String.valueOf(remainder / divisor));</span><br><span class="line">        remainder %= divisor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fraction.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个整数，分别表示分数的分子numerator和分母denominator，以字符串形式返回小数。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>149. 直线上最多的点数</title>
    <link href="http://yoursite.com/2020/09/18/149.%20%E7%9B%B4%E7%BA%BF%E4%B8%8A%E6%9C%80%E5%A4%9A%E7%9A%84%E7%82%B9%E6%95%B0/"/>
    <id>http://yoursite.com/2020/09/18/149. 直线上最多的点数/</id>
    <published>2020-09-18T01:27:12.000Z</published>
    <updated>2020-09-18T09:50:19.555Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二维平面，平面上有 n 个点，求最多有多少个点在同一条直线上。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: [[1,1],[2,2],[3,3]]输出: 3解释:^||        o|     o|  o  +-------------&gt;0  1  2  3  4</code></pre><p>示例 2:</p><pre><code>输入: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]输出: 4解释:^||  o|     o        o|        o|  o        o+-------------------&gt;0  1  2  3  4  5  6</code></pre><h1 id="题目描述（困难难度）"><a href="#题目描述（困难难度）" class="headerlink" title="题目描述（困难难度）"></a>题目描述（困难难度）</h1><p>平面上有很多点，找出经过某一条直线最多有多少个点。</p><h1 id="解法一-暴力破解"><a href="#解法一-暴力破解" class="headerlink" title="解法一 暴力破解"></a>解法一 暴力破解</h1><p>两点确定一条直线，最简单的方式考虑任意两点组成一条直线，然后判断其他点在不在这条直线上。</p><p>两点确定一条直线，直线方程可以表示成下边的样子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\frac&#123;y_2-y_1&#125;&#123;x_2-x_1&#125;=\frac&#123;y-y_2&#125;&#123;x-x_2&#125;</span><br></pre></td></tr></table></figure><p>所以当来了一个点 <code>(x,y)</code> 的时候，理论上，我们只需要代入到上边的方程进行判断即可。</p><p>但是在计算机中，算上边的除法的时候，结果可能是小数，计算机中用浮点数存储，但小数并不能精确表示，可以参考这篇 <a href="https://zhuanlan.zhihu.com/p/75581822" target="_blank" rel="noopener">浮点数</a> 的讲解。所以我们不能直接去判断等式两边是否相等。</p><p>第一个想法是，等式两边分子乘分母，转换为乘法的形式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(y_2-y_1)*(x-x_2)=(y-y_2)*(x_2-x_1)</span><br></pre></td></tr></table></figure><p>所以我们可以写一个 <code>test</code> 函数来判断点 <code>(x,y)</code> 是否在由点 <code>(x1,y1)</code> 和 <code>(x2,y2)</code> 组成的直线上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (y2 - y1) * (x - x2) == (y - y2) * (x2 - x1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上边看起来没问题，但如果乘积过大的话就可能造成溢出，从而产生问题。</p><p>最直接的解决方案就是不用 <code>int</code> 存，改用 <code>long</code> 存，可以暂时解决上边的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">long</span>)(y2 - y1) * (x - x2) == (<span class="keyword">long</span>)(y - y2) * (x2 - x1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但如果数据过大，依旧可能造成溢出，再直接的方法就是用 <code>java</code> 提供的 <code>BigInteger</code> 类处理。记得 <code>import java.math.BigInteger;</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;        </span><br><span class="line">    BigInteger x11 = BigInteger.valueOf(x1);</span><br><span class="line">    BigInteger x22 = BigInteger.valueOf(x2);</span><br><span class="line">    BigInteger y11 = BigInteger.valueOf(y1);</span><br><span class="line">   BigInteger y22 = BigInteger.valueOf(y2);</span><br><span class="line">    BigInteger x0 = BigInteger.valueOf(x);</span><br><span class="line">    BigInteger y0 = BigInteger.valueOf(y);</span><br><span class="line">    <span class="keyword">return</span> y22.subtract(y11).multiply(x0.subtract(x22)).equals(y0.subtract(y22).multiply(x22.subtract(x11)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，还有一个方案。</p><p>对于下边的等式，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\frac&#123;y_2-y_1&#125;&#123;x_2-x_1&#125;=\frac&#123;y-y_2&#125;&#123;x-x_2&#125;</span><br></pre></td></tr></table></figure><p>还可以理解成判断两个分数相等，回到数学上，我们只需要将两个分数约分到最简，然后分别判断分子和分母是否相等即可。</p><p>所以，我们需要求分子和分母的最大公约数，直接用<a href="https://baike.baidu.com/item/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/1647675?fromtitle=%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95&fromid=4625352" target="_blank" rel="noopener">辗转相除法</a>即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a % b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后 <code>test</code> 函数就可以写成下边的样子。需要注意的是，我们求了<code>y - y2</code> 和 <code>x - x2</code> 最大公约数，所以要保证他俩都不是 <code>0</code> ，防止除零错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> g1 = gcd(y2 - y1, x2 - x1);</span><br><span class="line">    <span class="keyword">if</span>(y == y2 &amp;&amp; x == x2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> g2 = gcd(y - y2, x - x2);</span><br><span class="line">    <span class="keyword">return</span> (y2 - y1) / g1 == (y - y2) / g2 &amp;&amp; (x2 - x1) / g1 == (x - x2) / g2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了 <code>test</code> 函数，接下来，我们只需要三层遍历。前两层遍历选择两个点的所有组合构成一条直线，第三层遍历其他所有点，来判断当前点在不在之前两个点组成的直线上。</p><p>需要注意的是，因为我们两点组成一条直线，必须保证这两个点不重合。所以我们进入第三层循环之前，如果两个点相等就可以直接跳过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (points[i][<span class="number">0</span>] == points[j][<span class="number">0</span>] &amp;&amp; points[i][<span class="number">1</span>] == points[j][<span class="number">1</span>]) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，我们还需要考虑所有点都相等的情况，这样就可以看做所有点都在一条直线上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; i &lt; points.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (points[i][<span class="number">0</span>] != points[i + <span class="number">1</span>][<span class="number">0</span>] || points[i][<span class="number">1</span>] != points[i + <span class="number">1</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i == points.length - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> points.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有就是点的数量只有两个，或者一个，零个的时候，直接返回点的数量即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (points.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> points.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上所述，代码就出来了，其中 <code>test</code> 函数有三种写法。</p><details>    <summary>暴力破解</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (points.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> points.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; points.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (points[i][<span class="number">0</span>] != points[i + <span class="number">1</span>][<span class="number">0</span>] || points[i][<span class="number">1</span>] != points[i + <span class="number">1</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == points.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> points.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; points.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (points[i][<span class="number">0</span>] == points[j][<span class="number">0</span>] &amp;&amp; points[i][<span class="number">1</span>] == points[j][<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> tempMax = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; points.length; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k != i &amp;&amp; k != j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (test(points[i][<span class="number">0</span>], points[i][<span class="number">1</span>], points[j][<span class="number">0</span>], points[j][<span class="number">1</span>], points[k][<span class="number">0</span>], points[k][<span class="number">1</span>])) &#123;</span><br><span class="line">                        tempMax++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tempMax &gt; max) &#123;</span><br><span class="line">                max = tempMax;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加上直线本身的两个点</span></span><br><span class="line">    <span class="keyword">return</span> max + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*private boolean test(int x1, int y1, int x2, int y2, int x, int y) &#123;</span></span><br><span class="line"><span class="comment">return (long)(y2 - y1) * (x - x2) == (long)(y - y2) * (x2 - x1);</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*private boolean test(int x1, int y1, int x2, int y2, int x, int y) &#123;        </span></span><br><span class="line"><span class="comment">    BigInteger x11 = BigInteger.valueOf(x1);</span></span><br><span class="line"><span class="comment">    BigInteger x22 = BigInteger.valueOf(x2);</span></span><br><span class="line"><span class="comment">    BigInteger y11 = BigInteger.valueOf(y1);</span></span><br><span class="line"><span class="comment">   BigInteger y22 = BigInteger.valueOf(y2);</span></span><br><span class="line"><span class="comment">    BigInteger x0 = BigInteger.valueOf(x);</span></span><br><span class="line"><span class="comment">    BigInteger y0 = BigInteger.valueOf(y);</span></span><br><span class="line"><span class="comment">    return y22.subtract(y11).multiply(x0.subtract(x22)).equals(y0.subtract(y22).multiply(x22.subtract(x11)));</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> g1 = gcd(y2 - y1, x2 - x1);</span><br><span class="line">    <span class="keyword">if</span>(y == y2 &amp;&amp; x == x2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> g2 = gcd(y - y2, x - x2);</span><br><span class="line">    <span class="keyword">return</span> (y2 - y1) / g1 == (y - y2) / g2 &amp;&amp; (x2 - x1) / g1 == (x - x2) / g2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a % b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h1><p>解法一很暴力，我们考虑在其基础上进行优化。</p><p>注意到，如果是下边的情况。</p><p><a href="https://pic.leetcode-cn.com/c2640aab030eac4f019a44b6b88b830002ed056f571c04b4b8dd6a3910bfae5c.jpg" target="_blank" rel="noopener">情况</a></p><p>对于解法一的算法，我们会经过下边的流程。</p><p>我们先考虑 <code>1,2</code> 组成的直线，看 <code>3,4,5,6</code>在不在 <code>1,2</code> 的直线上。</p><p>再考虑 <code>1,3</code> 组成的直线，看 <code>2,4,5,6</code>在不在 <code>1,3</code> 的直线上。</p><p>再考虑 <code>1,4</code> 组成的直线，看 <code>2,3,5,6</code>在不在 <code>1,4</code> 的直线上。</p><p>….</p><p>上边的问题很明显了，对于 <code>1,2</code>，<code>1,3</code>，<code>1,4</code>  … 组成的直线，其实是同一条，我们只需要判断一次就可以了。</p><p>所以我们需要做的是，怎么保证在判断完 <code>1,2</code> 构成的直线后，把 <code>1,3</code>，<code>1,4</code>… 这些在 <code>1,2</code> 直线上的点直接跳过。</p><p>回到数学上，给定两个点可以唯一的确定一条直线，表达式为 <code>y = kx + b</code>。</p><p>对于 <code>1,2</code>，<code>1,3</code>，<code>1,4</code> 这些点求出来的表达式都是唯一确定的。</p><p>所以我们当考虑 <code>1,2</code> 两个点的时候，我们可以求出 <code>k</code> 和 <code>b</code> 把它存到 <code>HashSet</code> 中，然后当考虑 <code>1,3</code> 以及后边的点的时候，先求出 <code>k</code> 和 <code>b</code>，然后从 <code>HashSet</code> 中看是否存在即可。</p><p>当然存的时候，我们可以用一个技巧，<code>key</code> 存一个  <code>String</code> ，也就是 <code>k + &quot;@&quot; + b</code> 。</p><details>    <summary>暴力破解优化</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(points.length &lt; <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> points.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//判断所有点是否都相同的特殊情况</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; points.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (points[i][<span class="number">0</span>] != points[i + <span class="number">1</span>][<span class="number">0</span>] || points[i][<span class="number">1</span>] != points[i + <span class="number">1</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == points.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> points.length;</span><br><span class="line">    &#125;</span><br><span class="line">    HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; points.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (points[i][<span class="number">0</span>] == points[j][<span class="number">0</span>] &amp;&amp; points[i][<span class="number">1</span>] == points[j][<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String key = getK(points[i][<span class="number">0</span>], points[i][<span class="number">1</span>], points[j][<span class="number">0</span>], points[j][<span class="number">1</span>])</span><br><span class="line">                       + <span class="string">"@"</span></span><br><span class="line">                       + getB(points[i][<span class="number">0</span>], points[i][<span class="number">1</span>], points[j][<span class="number">0</span>], points[j][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (set.contains(key)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> tempMax = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; points.length; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k != i &amp;&amp; k != j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (test(points[i][<span class="number">0</span>], points[i][<span class="number">1</span>], points[j][<span class="number">0</span>], points[j][<span class="number">1</span>], points[k][<span class="number">0</span>], points[k][<span class="number">1</span>])) &#123;</span><br><span class="line">                        tempMax++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tempMax &gt; max) &#123;</span><br><span class="line">                max = tempMax;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">getB</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (y2 == y1) &#123;</span><br><span class="line">        <span class="keyword">return</span> Double.POSITIVE_INFINITY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">double</span>) (x2 - x1) * (-y1) / (y2 - y1) + x1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">getK</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x2 - x1 == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Double.POSITIVE_INFINITY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">double</span>) (y2 - y1) / (x2 - x1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">long</span>)(y2 - y1) * (x - x2) == (<span class="keyword">long</span>)(y - y2) * (x2 - x1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>上边的算法虽然能 <code>AC</code>，但如果严格来说其实是有问题的。还是因为之前说的浮点数的问题，计算机并不能精确表示小数。这就造成不同的直线可能会求出相同的 <code>k</code> 和 <code>b</code>。</p><p>如果要修改的话，我们可以用分数表示小数，同时必须进行约分，使得分数化成最简。</p><p>对于上边的算法，有两个变量都需要用小数表示，所以可能会复杂些，可以看一下解法三的思路。</p><h1 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h1><p>解法二中，我们相当于是对直线的分类，一条直线一条直线的考虑，去求直线上的点。</p><p><a href="https://leetcode.com/problems/max-points-on-a-line/discuss/47113/A-java-solution-with-notes" target="_blank" rel="noopener">这里</a> 看到另一种想法，分享一下。</p><p>灵感应该来自于直线方程的另一种表示方式，「点斜式」，换句话，一个点加一个斜率即可唯一的确定一条直线。</p><p>所以我们可以对「点」进行分类然后去求，问题转换成，经过某个点的直线，哪条直线上的点最多。</p><p><a href="https://pic.leetcode-cn.com/f9da822aada3c01a0eaf203d6df4107c58cf0cf06dc99082a32fa31360368c6d.jpg" target="_blank" rel="noopener">示意图</a></p><p>当确定一个点后，平面上的其他点都和这个点可以求出一个斜率，斜率相同的点就意味着在同一条直线上。</p><p>所以我们可以用 <code>HashMap</code> 去计数，斜率作为 <code>key</code>，然后遍历平面上的其他点，相同的 <code>key</code> 意味着在同一条直线上。</p><p>上边的思想解决了「经过某个点的直线，哪条直线上的点最多」的问题。接下来只需要换一个点，然后用同样的方法考虑完所有的点即可。</p><p>当然还有一个问题就是斜率是小数，怎么办。</p><p>之前提到过了，我们用分数去表示，求分子分母的最大公约数，然后约分，最后将 「分子 + “@” + “分母”」作为 <code>key</code> 即可。</p><p>最后还有一个细节就是，当确定某个点的时候，平面内如果有和这个重叠的点，如果按照正常的算法约分的话，会出现除 <code>0</code> 的情况，所以我们需要单独用一个变量记录重复点的个数，而重复点一定是过当前点的直线的。</p><details>    <summary>暴力破解</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (points.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> points.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历每个点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> duplicate = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;<span class="comment">//保存经过当前点的直线中，最多的点</span></span><br><span class="line">        HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; points.length; j++) &#123;</span><br><span class="line">            <span class="comment">//求出分子分母</span></span><br><span class="line">            <span class="keyword">int</span> x = points[j][<span class="number">0</span>] - points[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = points[j][<span class="number">1</span>] - points[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//重叠的点</span></span><br><span class="line">                duplicate++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进行约分</span></span><br><span class="line">            <span class="keyword">int</span> gcd = gcd(x, y);</span><br><span class="line">            x = x / gcd;</span><br><span class="line">            y = y / gcd;</span><br><span class="line">            String key = x + <span class="string">"@"</span> + y;</span><br><span class="line">            map.put(key, map.getOrDefault(key, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            max = Math.max(max, map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1 代表当前考虑的点，duplicate 代表和当前的点重复的点</span></span><br><span class="line">        res = Math.max(res, max + duplicate + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a % b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="解惑"><a href="#解惑" class="headerlink" title="解惑"></a>解惑</h1><p>解法三还是不太明白，如果有两条平行直线，那么斜率一样，不就都存到一个哈希key里去了吗？</p><p>以注意下循环和辅助哈希表的创建位置，最外层的循环已经确保了当前哈希表里的斜率是对当前节点points[i]的。每次循环到一个点都会重新定义一个哈希表，所以会避免这种情况</p><h1 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h1><p>这道题首先还是去想暴力的想法，然后去考虑重复的情况，对情况进行分类从而优化时间复杂度。同样解法三其实也是一种分类的思想，会减少很多不必要情况的讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个二维平面，平面上有 n 个点，求最多有多少个点在同一条直线上。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>260. 只出现一次的数字III</title>
    <link href="http://yoursite.com/2020/09/17/260.%20%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97III/"/>
    <id>http://yoursite.com/2020/09/17/260. 只出现一次的数字III/</id>
    <published>2020-09-17T09:55:12.000Z</published>
    <updated>2020-09-17T10:37:15.626Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。</p><a id="more"></a><p> 示例 :</p><pre><code>输入: [1,2,1,3,2,5]输出: [3,5]</code></pre><p> 注意：</p><pre><code>结果输出的顺序并不重要，对于上面的例子， [5, 3] 也是正确答案。你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？</code></pre><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>使用哈希表可以在 O(N) 的时间复杂度和 O(N)  的空间复杂度中解决该问题。</p><p>这个问题在常数的空间复杂度中解决有点困难，但可以借助两个位掩码来实现。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjYwL3R3bzIucG5n?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><h1 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h1><p>建立一个值到频率的映射关系的哈希表，返回频率为 1 的数字。</p><p><strong>算法：</strong></p><details>    <summary>哈希表Python</summary><figure class="highlight python"><figcaption><span>[solution1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums: int)</span> -&gt; List[int]:</span></span><br><span class="line">        hashmap = Counter(nums)</span><br><span class="line">        <span class="keyword">return</span> [x <span class="keyword">for</span> x <span class="keyword">in</span> hashmap <span class="keyword">if</span> hashmap[x] == <span class="number">1</span>]</span><br></pre></td></tr></table></figure></details><details>    <summary>哈希表Java</summary><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumber(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; hashmap = <span class="keyword">new</span> HashMap();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : nums)</span><br><span class="line">      hashmap.put(n, hashmap.getOrDefault(n, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] output = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; item : hashmap.entrySet())</span><br><span class="line">      <span class="keyword">if</span> (item.getValue() == <span class="number">1</span>) output[idx++] = item.getKey();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(N)。</li><li>空间复杂度：O(N) ，哈希表所使用的空间。</li></ul><h1 id="方法二：两个掩码"><a href="#方法二：两个掩码" class="headerlink" title="方法二：两个掩码"></a>方法二：两个掩码</h1><p>本文将使用两个按位技巧：</p><ul><li>使用异或运算可以帮助我们消除出现两次的数字；我们计算 <code>bitmask ^= x</code>，则 <code>bitmask</code> 留下的就是出现奇数次的位。</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjYwL3hvcjMucG5n?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><ul><li><code>x &amp; (-x)</code> 是保留位中最右边 <code>1</code> ，且将其余的 <code>1</code> 设位 <code>0</code> 的方法。</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjYwL2lzb2xhdGUzLnBuZw?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><p><strong>算法：</strong></p><p>首先计算 <code>bitmask ^= x</code>，则 <code>bitmask</code> 不会保留出现两次数字的值，因为相同数字的异或值为 <code>0</code>。</p><p>但是 <code>bitmask</code> 会保留只出现一次的两个数字（<code>x</code> 和 <code>y</code>）之间的差异。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjYwL2RpZmZfbmV3LnBuZw?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><p>我们可以直接从 <code>bitmask</code> 中提取 <code>x</code> 和 <code>y</code> 吗？不能，但是我们可以用 <code>bitmask</code> 作为标记来分离 <code>x</code> 和 <code>y</code>。</p><p>我们通过 <code>bitmask &amp; (-bitmask)</code> 保留 <code>bitmask</code> 最右边的 <code>1</code>，这个 <code>1</code> 要么来自 <code>x</code>，要么来自 <code>y</code>。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjYwL2lzb2xhdGUyX25ldy5wbmc?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>当我们找到了 <code>x</code>，那么 <code>y = bitmask^x</code>。</p><details>    <summary>两个掩码Python</summary><figure class="highlight python"><figcaption><span>[solution2-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># difference between two numbers (x and y) which were seen only once</span></span><br><span class="line">        bitmask = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            bitmask ^= num</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># rightmost 1-bit diff between x and y</span></span><br><span class="line">        diff = bitmask &amp; (-bitmask)</span><br><span class="line">        </span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># bitmask which will contain only x</span></span><br><span class="line">            <span class="keyword">if</span> num &amp; diff:</span><br><span class="line">                x ^= num</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [x, bitmask^x]</span><br></pre></td></tr></table></figure></details><details>    <summary>两个掩码Java</summary><figure class="highlight java"><figcaption><span>[solution2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumber(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="comment">// difference between two numbers (x and y) which were seen only once</span></span><br><span class="line">    <span class="keyword">int</span> bitmask = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) bitmask ^= num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rightmost 1-bit diff between x and y</span></span><br><span class="line">    <span class="keyword">int</span> diff = bitmask &amp; (-bitmask);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// bitmask which will contain only x</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) <span class="keyword">if</span> ((num &amp; diff) != <span class="number">0</span>) x ^= num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x, bitmask^x&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(N) 的时间遍历输入数组。</li><li>空间复杂度：O(1)。</li></ul><h2 id="解惑"><a href="#解惑" class="headerlink" title="解惑"></a>解惑</h2><p><strong>这里我一开始有些疑惑，为什么要么来自于x要么来自于y呢，后来才想到如果x和y最右边的1位相同的话那么在bitmask中该位一定是0，bitmask中最右边的1一定是x和y从右边开始第一个不同的位</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
  <entry>
    <title>136. 只出现一次的数字</title>
    <link href="http://yoursite.com/2020/09/16/136.%20%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2020/09/16/136. 只出现一次的数字/</id>
    <published>2020-09-16T09:12:12.000Z</published>
    <updated>2020-09-16T09:01:09.183Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><a id="more"></a><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p>示例 1:</p><pre><code>输入: [2,2,1]输出: 1</code></pre><p>示例 2:</p><pre><code>输入: [4,1,2,1,2]输出: 4</code></pre><h1 id="📺-视频题解"><a href="#📺-视频题解" class="headerlink" title="📺 视频题解"></a>📺 视频题解</h1><p><a href="47a527e0-e01f-4ece-a158-140764b7c319">136. 只出现一次的数字.mp4</a></p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="方法一：位运算"><a href="#方法一：位运算" class="headerlink" title="方法一：位运算"></a>方法一：位运算</h2><p>如果没有时间复杂度和空间复杂度的限制，这道题有很多种解法，可能的解法有如下几种。</p><ul><li><p>使用集合存储数字。遍历数组中的每个数字，如果集合中没有该数字，则将该数字加入集合，如果集合中已经有该数字，则将该数字从集合中删除，最后剩下的数字就是只出现一次的数字。</p></li><li><p>使用哈希表存储每个数字和该数字出现的次数。遍历数组即可得到每个数字出现的次数，并更新哈希表，最后遍历哈希表，得到只出现一次的数字。</p></li><li><p>使用集合存储数组中出现的所有数字，并计算数组中的元素之和。由于集合保证元素无重复，因此计算集合中的所有元素之和的两倍，即为每个元素出现两次的情况下的元素之和。由于数组中只有一个元素出现一次，其余元素都出现两次，因此用集合中的元素之和的两倍减去数组中的元素之和，剩下的数就是数组中只出现一次的数字。</p></li></ul><p>上述三种解法都需要额外使用 <em>O(n)</em> 的空间，其中 <em>n</em> 是数组长度。如果要求使用线性时间复杂度和常数空间复杂度，上述三种解法显然都不满足要求。那么，如何才能做到线性时间复杂度和常数空间复杂度呢？</p><p>答案是使用位运算。对于这道题，可使用异或运算 ^ 。异或运算有以下三个性质。</p><ol><li>任何数和 <em>0</em> 做异或运算，结果仍然是原来的数。</li><li>任何数和其自身做异或运算，结果是 <em>0</em>。</li><li>异或运算满足交换律和结合律.</li></ol><p>假设数组中有 <em>2m+1</em> 个数，其中有 <em>m</em> 个数各出现两次，一个数出现一次。令 <em>a_{1}<em>、</em>a_{2}<em>、…、</em>a_{m}</em> 为出现两次的 <em>m</em> 个数，<em>a_{m+1}</em> 为出现一次的数。</p><p>因此，数组中的全部元素的异或运算结果即为数组中只出现一次的数字。</p><details>    <summary>位运算Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> single = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            single ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>位运算C++</summary><figure class="highlight cpp"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> e: nums) ret ^= e;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>位运算Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y: x ^ y, nums)</span><br></pre></td></tr></table></figure></details><details>    <summary>位运算C#</summary><figure class="highlight csharp"><figcaption><span>[sol1-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">SingleNumber</span>(<span class="params"><span class="keyword">int</span>[] nums</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">int</span> e <span class="keyword">in</span> nums) ret ^= e;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>位运算Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">singleNumber</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    single := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        single ^= num</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> single</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)*，其中 *n</em> 是数组长度。只需要对数组遍历一次。</p></li><li><p>空间复杂度：<em>O(1)</em>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>137. 只出现一次的数字II</title>
    <link href="http://yoursite.com/2020/09/16/137.%20%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97II/"/>
    <id>http://yoursite.com/2020/09/16/137. 只出现一次的数字II/</id>
    <published>2020-09-16T09:12:12.000Z</published>
    <updated>2020-09-17T09:53:05.162Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。 </p><a id="more"></a><p> 说明： </p><pre><code>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ </code></pre><p> 示例 1: </p><pre><code>输入: [2,2,3,2]输出: 3</code></pre><p> 示例 2: </p><pre><code>输入: [0,1,0,1,0,1,99]输出: 99 </code></pre><h1 id="解题思路-1："><a href="#解题思路-1：" class="headerlink" title="解题思路^1："></a>解题思路<a href="https://leetcode-cn.com/problems/single-number-ii/solution/single-number-ii-mo-ni-san-jin-zhi-fa-by-jin407891/" target="_blank" rel="noopener">^1</a>：</h1><p>如下图所示，考虑数字的二进制形式，对于出现三次的数字，各 <strong>二进制位</strong> 出现的次数都是 <em>3</em> 的倍数。<br>因此，统计所有数字的各二进制位中 <em>1</em> 的出现次数，并对 <em>3</em> 求余，结果则为只出现一次的数字。</p><p><a href="https://pic.leetcode-cn.com/28f2379be5beccb877c8f1586d8673a256594e0fc45422b03773b8d4c8418825-Picture1.png" target="_blank" rel="noopener">Picture1.png</a></p><h1 id="方法一：有限状态自动机"><a href="#方法一：有限状态自动机" class="headerlink" title="方法一：有限状态自动机"></a>方法一：有限状态自动机</h1><p>各二进制位的 <strong>位运算规则相同</strong> ，因此只需考虑一位即可。如下图所示，对于所有数字中的某二进制位 <em>1</em> 的个数，存在 3 种状态，即对 3 余数为 <em>0, 1, 2</em> 。</p><ul><li>若输入二进制位 <em>1</em> ，则状态按照以下顺序转换；</li><li>若输入二进制位 <em>0</em> ，则状态不变。</li></ul><p>0-&gt;1-&gt;2-&gt;0-&gt;…</p><p><a href="https://pic.leetcode-cn.com/ab00d4d1ad961a3cd4fc1840e34866992571162096000325e7ce10ff75fda770-Picture2.png" target="_blank" rel="noopener">Picture2.png</a></p><p>如下图所示，由于二进制只能表示 <em>0, 1</em> ，因此需要使用两个二进制位来表示 <em>3</em> 个状态。设此两位分别为 <em>two</em> , <em>one</em> ，则状态转换变为：</p><p>00-&gt;01-&gt;10-&gt;00</p><p><a href="https://pic.leetcode-cn.com/0a7ea5bca055b095673620d8bb4c98ef6c610a22f999294ed11ae35d43621e93-Picture3.png" target="_blank" rel="noopener">Picture3.png</a></p><p>接下来，需要通过 <strong>状态转换表</strong> 导出 <strong>状态转换的计算公式</strong> 。首先回忆一下位运算特点，对于任意二进制位 <em>x</em> ，有：</p><ul><li>异或运算：<code>x ^ 0 = x</code>​ ， <code>x ^ 1 = ~x</code></li><li>与运算：<code>x &amp; 0 = 0</code> ， <code>x &amp; 1 = x</code></li></ul><p><strong>计算 <em>one</em> 方法：</strong></p><p>设当前状态为 <em>two</em> <em>one</em> ，此时输入二进制位 <em>n</em> 。如下图所示，通过对状态表的情况拆分，可推出 <em>one</em> 的计算方法为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> two == <span class="number">0</span>:</span><br><span class="line">  <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">    one = one</span><br><span class="line">  <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">    one = ~one</span><br><span class="line"><span class="keyword">if</span> two == <span class="number">1</span>:</span><br><span class="line">    one = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>引入 <strong>异或运算</strong> ，可将以上拆分简化为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> two == <span class="number">0</span>:</span><br><span class="line">    one = one ^ n</span><br><span class="line"><span class="keyword">if</span> two == <span class="number">1</span>:</span><br><span class="line">    one = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>引入 <strong>与运算</strong> ，可继续简化为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one = one ^ n &amp; ~two</span><br></pre></td></tr></table></figure><p><a href="https://pic.leetcode-cn.com/f75d89219ad93c69757b187c64784b4c7a57dce7911884fe82f14073d654d32f-Picture4.png" target="_blank" rel="noopener">Picture4.png</a></p><p><strong>计算 <em>two</em> 方法：</strong></p><p>由于是先计算 <em>one</em> ，因此应在新 <em>one</em> 的基础上计算 <em>two</em> 。<br>如下图所示，修改为新 <em>one</em> 后，得到了新的状态图。观察发现，可以使用同样的方法计算 <em>two</em> ，即：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">two = two ^ n &amp; ~one</span><br></pre></td></tr></table></figure><p><strong>这部分我一开始看时有些疑惑，但仔细看下面这张图会发现其中one都是新的变化后的，可以再把one和two调换位置就发现整个状态变化图是等效的了。</strong></p><p><a href="https://pic.leetcode-cn.com/6ba76dba1ac98ee2bb982e011fdffd1df9a6963f157b2780461dbce453f0ded3-Picture5.png" target="_blank" rel="noopener">Picture5.png</a></p><p><strong>返回值：</strong></p><p>以上是对数字的二进制中 “一位” 的分析，而 <code>int</code> 类型的其他 31 位具有相同的运算规则，因此可将以上公式直接套用在 32 位数上。</p><p>遍历完所有数字后，各二进制位都处于状态 <em>00</em> 和状态 <em>01</em> （取决于 “只出现一次的数字” 的各二进制位是 <em>1</em> 还是 <em>0</em> ），而此两状态是由 <em>one</em> 来记录的（此两状态下 <em>twos</em> 恒为 <em>0</em> ），因此返回 <em>ones</em> 即可。</p><h2 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h2><ul><li><p><strong>时间复杂度 <em>O(N)</em> ：</strong> 其中 <em>N</em> 位数组 <em>nums</em> 的长度；遍历数组占用 <em>O(N)</em> ，每轮中的常数个位运算操作占用 O(32<em>3</em>2)=O(1)。</p></li><li><p><strong>空间复杂度 <em>O(1)</em> ：</strong> 变量 <em>ones</em> , <em>twos</em> 使用常数大小的额外空间。</p><p><a href="https://pic.leetcode-cn.com/045023f05080e0844f05b8ee5b68885e1b9e41926d3e4ab054c68e6dceacfc0a-Picture6.png" target="_blank" rel="noopener">Picture6.png</a> <a href="https://pic.leetcode-cn.com/fd0ab6b3cd20c18729321957f6b4bedbf6480fd6862c01de1c5d598c82a26d2b-Picture7.png" target="_blank" rel="noopener">Picture7.png</a> <a href="https://pic.leetcode-cn.com/46b0974b13206beda512dd037df10772fae1c7375a97a7a05abb4a736dc0ebb3-Picture8.png" target="_blank" rel="noopener">Picture8.png</a> <a href="https://pic.leetcode-cn.com/4cfe4cf13367851efdb9dee5fceed969326cc3478be0769c8f60294ef5d2866d-Picture9.png" target="_blank" rel="noopener">Picture9.png</a> <a href="https://pic.leetcode-cn.com/fa2e7ecb991d5183e2f53ca7741150ae18badb087b01bff4a32caaec245fec79-Picture10.png" target="_blank" rel="noopener">Picture10.png</a> <a href="https://pic.leetcode-cn.com/6a6b8561c913c45d7be3428ff8553a2188890fee0687a1a113a7c2bea12b95a9-Picture11.png" target="_blank" rel="noopener">Picture11.png</a> </p></li></ul><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><details>    <summary>有限状态自动机python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        ones, twos = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            ones = ones ^ num &amp; ~twos</span><br><span class="line">            twos = twos ^ num &amp; ~ones</span><br><span class="line">        <span class="keyword">return</span> ones</span><br></pre></td></tr></table></figure></details><details>    <summary>有限状态自动机java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            ones = ones ^ num &amp; ~twos;</span><br><span class="line">            twos = twos ^ num &amp; ~ones;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ones;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="方法二：遍历统计"><a href="#方法二：遍历统计" class="headerlink" title="方法二：遍历统计"></a>方法二：遍历统计</h1><blockquote><p>此方法相对容易理解，但效率较低，总体推荐方法一。</p></blockquote><p>使用 <strong>与运算</strong> ，可获取二进制数字 <em>num</em> 的最右一位 <em>n_1</em> ：</p><p>n_1=num &amp; i</p><p>配合 <strong>无符号右移操作</strong> ，可获取 <em>num</em> 所有位的值（即 <em>n_1</em> ~ <em>n_{32}</em> ）：</p><p>num = num &gt;&gt;&gt; 1</p><p>建立一个长度为 32 的数组 <em>counts</em> ，通过以上方法可记录所有数字的各二进制位的 <em>1</em> 的出现次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span>; j++) &#123;</span><br><span class="line">        counts[j] += nums[i] &amp; <span class="number">1</span>; <span class="comment">// 更新第 j 位</span></span><br><span class="line">        nums[i] &gt;&gt;&gt;= <span class="number">1</span>; <span class="comment">// 第 j 位 --&gt; 第 j + 1 位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 <em>counts</em> 各元素对 <em>3</em> 求余，则结果为 “只出现一次的数字” 的各二进制位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">    counts[i] %= <span class="number">3</span>; <span class="comment">// 得到 只出现一次的数字 的第 (31 - i) 位 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用 <strong>左移操作</strong> 和 <strong>或运算</strong> ，可将 <em>counts</em> 数组中各二进位的值恢复到数字 <em>res</em> 上（循环区间是 <img src="./p__i_in__0,_31__.png" alt="i\in\[0,31\] ">  ）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; counts.length; i++) &#123;</span><br><span class="line">    res &lt;&lt;= <span class="number">1</span>; <span class="comment">// 左移 1 位</span></span><br><span class="line">    res |= counts[<span class="number">31</span> - i]; <span class="comment">// 恢复第 i 位的值到 res</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终返回 <em>res</em> 即可。</p><blockquote><p>由于 Python 的存储负数的特殊性，需要先将 <em>0</em> - <em>32</em> 位取反（即 <code>res ^ 0xffffffff</code> ），再将所有位取反（即 <code>~</code> ）。<br>两个组合操作实质上是将数字 <em>32</em> 以上位取反， <em>0</em> - <em>32</em> 位不变。</p></blockquote><h2 id="复杂度分析：-1"><a href="#复杂度分析：-1" class="headerlink" title="复杂度分析："></a>复杂度分析：</h2><ul><li><strong>时间复杂度 <em>O(N)</em> ：</strong> 其中 <em>N</em> 位数组 <em>nums</em> 的长度；遍历数组占用 <em>O(N)</em> ，每轮中的常数个位运算操作占用 <em>O(1)</em> 。</li><li><strong>空间复杂度 <em>O(1)</em> ：</strong> 数组 <em>counts</em> 长度恒为 <em>32</em> ，占用常数大小的额外空间。</li></ul><h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><p>实际上，只需要修改求余数值 <em>m</em> ，即可实现解决 <strong>除了一个数字以外，其余数字都出现 <em>m</em> 次</strong> 的通用问题。</p><details>    <summary>遍历统计python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        counts = [<span class="number">0</span>] * <span class="number">32</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">                counts[j] += num &amp; <span class="number">1</span></span><br><span class="line">                num &gt;&gt;= <span class="number">1</span></span><br><span class="line">        res, m = <span class="number">0</span>, <span class="number">3</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">            res &lt;&lt;= <span class="number">1</span></span><br><span class="line">            res |= counts[<span class="number">31</span> - i] % m</span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> counts[<span class="number">31</span>] % m == <span class="number">0</span> <span class="keyword">else</span> ~(res ^ <span class="number">0xffffffff</span>)</span><br></pre></td></tr></table></figure></details><details>    <summary>遍历统计java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span>; j++) &#123;</span><br><span class="line">                counts[j] += num &amp; <span class="number">1</span>;</span><br><span class="line">                num &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, m = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            res &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            res |= counts[<span class="number">31</span> - i] % m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。 &lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
  <entry>
    <title>210. 课程表II</title>
    <link href="http://yoursite.com/2020/09/15/210.%20%E8%AF%BE%E7%A8%8B%E8%A1%A8II/"/>
    <id>http://yoursite.com/2020/09/15/210. 课程表II/</id>
    <published>2020-09-15T03:12:12.000Z</published>
    <updated>2020-09-16T08:37:41.944Z</updated>
    
    <content type="html"><![CDATA[<p>给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。</p><a id="more"></a><p>现在你总共有 n 门课需要选，记为 0 到 n-1。</p><p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]</p><p>给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。</p><p>可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。</p><p>示例 1:</p><pre><code>输入: 2, [[1,0]] 输出: [0,1]解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。</code></pre><p>示例 2:</p><pre><code>输入: 4, [[1,0],[2,0],[3,1],[3,2]]输出: [0,1,2,3] or [0,2,1,3]解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。     因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。</code></pre><p>说明:</p><ul><li>输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。</li><li>你可以假定输入的先决条件中没有重复的边。</li></ul><p>提示:</p><ul><li>这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。</li><li>通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。</li><li>拓扑排序也可以通过 BFS 完成。</li></ul><h1 id="📺-视频题解"><a href="#📺-视频题解" class="headerlink" title="📺 视频题解"></a>📺 视频题解</h1><p><a href="def715df-7ba6-462e-b957-ebaf4120b1ce">210. 课程表 II的.mp4</a></p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本题是一道经典的「拓扑排序」问题。</p><p>给定一个包含 <em>n</em> 个节点的有向图 <em>G</em>，我们给出它的节点编号的一种排列，如果满足：</p><blockquote><p>对于图 <em>G</em> 中的任意一条有向边 <em>(u, v)<em>，</em>u</em> 在排列中都出现在 <em>v</em> 的前面。</p></blockquote><p>那么称该排列是图 <em>G</em> 的「拓扑排序」。根据上述的定义，我们可以得出两个结论：</p><ul><li>如果图 <em>G</em> 中存在环（即图 <em>G</em> 不是「有向无环图」），那么图 <em>G</em> 不存在拓扑排序。这是因为假设图中存在环 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x_1,x_2,...,x_n,x_1</span><br></pre></td></tr></table></figure><p>，那么 <em>x_1</em> 在排列中必须出现在 <em>x_n</em> 的前面，但 <em>x_n</em> 同时也必须出现在 <em>x_1</em> 的前面，因此不存在一个满足要求的排列，也就不存在拓扑排序；</p><ul><li>如果图 <em>G</em> 是有向无环图，那么它的拓扑排序可能不止一种。举一个最极端的例子，如果图 <em>G</em> 值包含 <em>n</em> 个节点却没有任何边，那么任意一种编号的排列都可以作为拓扑排序。</li></ul><p>有了上述的简单分析，我们就可以将本题建模成一个求拓扑排序的问题了：</p><ul><li><p>我们将每一门课看成一个节点；</p></li><li><p>如果想要学习课程 <em>A</em> 之前必须完成课程 <em>B</em>，那么我们从 <em>B</em> 到 <em>A</em> 连接一条有向边。这样以来，在拓扑排序中，<em>B</em> 一定出现在 <em>A</em> 的前面。</p></li></ul><p>求出该图的拓扑排序，就可以得到一种符合要求的课程学习顺序。下面介绍两种求解拓扑排序的方法。</p><h2 id="方法一：深度优先搜索"><a href="#方法一：深度优先搜索" class="headerlink" title="方法一：深度优先搜索"></a>方法一：深度优先搜索</h2><p><strong>思路</strong></p><p>我们可以将深度优先搜索的流程与拓扑排序的求解联系起来，用一个栈来存储所有<strong>已经搜索完成的节点</strong>。</p><blockquote><p>对于一个节点 <em>u</em>，如果它的所有相邻节点都已经搜索完成，那么在搜索回溯到 <em>u</em> 的时候，<em>u</em> 本身也会变成一个已经搜索完成的节点。这里的「相邻节点」指的是从 <em>u</em> 出发通过一条有向边可以到达的所有节点。</p></blockquote><p>假设我们当前搜索到了节点 <em>u</em>，如果它的所有相邻节点都已经搜索完成，那么这些节点都已经在栈中了，此时我们就可以把 <em>u</em> 入栈。可以发现，如果我们从栈顶往栈底的顺序看，由于 <em>u</em> 处于栈顶的位置，那么 <em>u</em> 出现在所有 <em>u</em> 的相邻节点的前面。因此对于 <em>u</em> 这个节点而言，它是满足拓扑排序的要求的。</p><p>这样以来，我们对图进行一遍深度优先搜索。当每个节点进行回溯的时候，我们把该节点放入栈中。最终从栈顶到栈底的序列就是一种拓扑排序。</p><p><strong>算法</strong></p><p>对于图中的任意一个节点，它在搜索的过程中有三种状态，即：</p><ul><li><p>「未搜索」：我们还没有搜索到这个节点；</p></li><li><p>「搜索中」：我们搜索过这个节点，但还没有回溯到该节点，即该节点还没有入栈，还有相邻的节点没有搜索完成）；</p></li><li><p>「已完成」：我们搜索过并且回溯过这个节点，即该节点已经入栈，并且所有该节点的相邻节点都出现在栈的更底部的位置，满足拓扑排序的要求。</p></li></ul><p>通过上述的三种状态，我们就可以给出使用深度优先搜索得到拓扑排序的算法流程，在每一轮的搜索搜索开始时，我们任取一个「未搜索」的节点开始进行深度优先搜索。</p><ul><li><p>我们将当前搜索的节点 <em>u</em> 标记为「搜索中」，遍历该节点的每一个相邻节点 <em>v</em>：</p><ul><li><p>如果 <em>v</em> 为「未搜索」，那么我们开始搜索 <em>v</em>，待搜索完成回溯到 <em>u</em>；</p></li><li><p>如果 <em>v</em> 为「搜索中」，那么我们就找到了图中的一个环，因此是不存在拓扑排序的；</p></li><li><p>如果 <em>v</em> 为「已完成」，那么说明 <em>v</em> 已经在栈中了，而 <em>u</em> 还不在栈中，因此 <em>u</em> 无论何时入栈都不会影响到 <em>(u, v)</em> 之前的拓扑关系，以及不用进行任何操作。</p></li></ul></li><li><p>当 <em>u</em> 的所有相邻节点都为「已完成」时，我们将 <em>u</em> 放入栈中，并将其标记为「已完成」。</p></li></ul><p>在整个深度优先搜索的过程结束后，如果我们没有找到图中的环，那么栈中存储这所有的 <em>n</em> 个节点，从栈顶到栈底的顺序即为一种拓扑排序。</p><p>下面的幻灯片给出了深度优先搜索的可视化流程。图中的「白色」「黄色」「绿色」节点分别表示「未搜索」「搜索中」「已完成」的状态。</p><p> <a href="https://assets.leetcode-cn.com/solution-static/207/1.png" target="_blank" rel="noopener">DFS1</a> <a href="https://assets.leetcode-cn.com/solution-static/207/2.png" target="_blank" rel="noopener">DFS2</a> <a href="https://assets.leetcode-cn.com/solution-static/207/3.png" target="_blank" rel="noopener">DFS3</a> <a href="https://assets.leetcode-cn.com/solution-static/207/4.png" target="_blank" rel="noopener">DFS4</a> <a href="https://assets.leetcode-cn.com/solution-static/207/5.png" target="_blank" rel="noopener">DFS5</a> <a href="https://assets.leetcode-cn.com/solution-static/207/6.png" target="_blank" rel="noopener">DFS6</a> <a href="https://assets.leetcode-cn.com/solution-static/207/7.png" target="_blank" rel="noopener">DFS7</a> <a href="https://assets.leetcode-cn.com/solution-static/207/8.png" target="_blank" rel="noopener">DFS8</a> <a href="https://assets.leetcode-cn.com/solution-static/207/9.png" target="_blank" rel="noopener">DFS9</a> <a href="https://assets.leetcode-cn.com/solution-static/207/10.png" target="_blank" rel="noopener">DFS10</a> <a href="https://assets.leetcode-cn.com/solution-static/207/11.png" target="_blank" rel="noopener">DFS11</a> <a href="https://assets.leetcode-cn.com/solution-static/207/12.png" target="_blank" rel="noopener">DFS12</a> <a href="https://assets.leetcode-cn.com/solution-static/207/13.png" target="_blank" rel="noopener">DFS13</a> <a href="https://assets.leetcode-cn.com/solution-static/207/14.png" target="_blank" rel="noopener">DFS14</a> <a href="https://assets.leetcode-cn.com/solution-static/207/15.png" target="_blank" rel="noopener">DFS15</a> <a href="https://assets.leetcode-cn.com/solution-static/207/16.png" target="_blank" rel="noopener">DFS16</a> <a href="https://assets.leetcode-cn.com/solution-static/207/17.png" target="_blank" rel="noopener">DFS17</a> <a href="https://assets.leetcode-cn.com/solution-static/207/18.png" target="_blank" rel="noopener">DFS18</a> <a href="https://assets.leetcode-cn.com/solution-static/207/19.png" target="_blank" rel="noopener">DFS19</a> <a href="https://assets.leetcode-cn.com/solution-static/207/20.png" target="_blank" rel="noopener">DFS20</a> </p><details>    <summary>深度优先搜索C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 存储有向图</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; edges;</span><br><span class="line">    <span class="comment">// 标记每个节点的状态：0=未搜索，1=搜索中，2=已完成</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line">    <span class="comment">// 用数组来模拟栈，下标 0 为栈底，n-1 为栈顶</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="comment">// 判断有向图中是否有环</span></span><br><span class="line">    <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将节点标记为「搜索中」</span></span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 搜索其相邻节点</span></span><br><span class="line">        <span class="comment">// 只要发现有环，立刻停止搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v: edges[u]) &#123;</span><br><span class="line">            <span class="comment">// 如果「未搜索」那么搜索相邻节点</span></span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(v);</span><br><span class="line">                <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果「搜索中」说明找到了环</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == <span class="number">1</span>) &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将节点标记为「已完成」</span></span><br><span class="line">        visited[u] = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 将节点入栈</span></span><br><span class="line">        result.push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findOrder(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">        edges.resize(numCourses);</span><br><span class="line">        visited.resize(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; info: prerequisites) &#123;</span><br><span class="line">            edges[info[<span class="number">1</span>]].push_back(info[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每次挑选一个「未搜索」的节点，开始进行深度优先搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有环，那么就有拓扑排序</span></span><br><span class="line">        <span class="comment">// 注意下标 0 为栈底，因此需要将数组反序输出</span></span><br><span class="line">        reverse(result.begin(), result.end());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>深度优先搜索Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存储有向图</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; edges;</span><br><span class="line">    <span class="comment">// 标记每个节点的状态：0=未搜索，1=搜索中，2=已完成</span></span><br><span class="line">    <span class="keyword">int</span>[] visited;</span><br><span class="line">    <span class="comment">// 用数组来模拟栈，下标 n-1 为栈底，0 为栈顶</span></span><br><span class="line">    <span class="keyword">int</span>[] result;</span><br><span class="line">    <span class="comment">// 判断有向图中是否有环</span></span><br><span class="line">    <span class="keyword">boolean</span> valid = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 栈下标</span></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">        edges = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            edges.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        result = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        index = numCourses - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] info : prerequisites) &#123;</span><br><span class="line">            edges.get(info[<span class="number">1</span>]).add(info[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每次挑选一个「未搜索」的节点，开始进行深度优先搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有环，那么就有拓扑排序</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将节点标记为「搜索中」</span></span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 搜索其相邻节点</span></span><br><span class="line">        <span class="comment">// 只要发现有环，立刻停止搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v: edges.get(u)) &#123;</span><br><span class="line">            <span class="comment">// 如果「未搜索」那么搜索相邻节点</span></span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(v);</span><br><span class="line">                <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果「搜索中」说明找到了环</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == <span class="number">1</span>) &#123;</span><br><span class="line">                valid = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将节点标记为「已完成」</span></span><br><span class="line">        visited[u] = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 将节点入栈</span></span><br><span class="line">        result[index--] = u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>深度优先搜索Python</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findOrder</span><span class="params">(self, numCourses: int, prerequisites: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 存储有向图</span></span><br><span class="line">        edges = collections.defaultdict(list)</span><br><span class="line">        <span class="comment"># 标记每个节点的状态：0=未搜索，1=搜索中，2=已完成</span></span><br><span class="line">        visited = [<span class="number">0</span>] * numCourses</span><br><span class="line">        <span class="comment"># 用数组来模拟栈，下标 0 为栈底，n-1 为栈顶</span></span><br><span class="line">        result = list()</span><br><span class="line">        <span class="comment"># 判断有向图中是否有环</span></span><br><span class="line">        valid = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> info <span class="keyword">in</span> prerequisites:</span><br><span class="line">            edges[info[<span class="number">1</span>]].append(info[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(u: int)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> valid</span><br><span class="line">            <span class="comment"># 将节点标记为「搜索中」</span></span><br><span class="line">            visited[u] = <span class="number">1</span></span><br><span class="line">            <span class="comment"># 搜索其相邻节点</span></span><br><span class="line">            <span class="comment"># 只要发现有环，立刻停止搜索</span></span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> edges[u]:</span><br><span class="line">                <span class="comment"># 如果「未搜索」那么搜索相邻节点</span></span><br><span class="line">                <span class="keyword">if</span> visited[v] == <span class="number">0</span>:</span><br><span class="line">                    dfs(v)</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> valid:</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                <span class="comment"># 如果「搜索中」说明找到了环</span></span><br><span class="line">                <span class="keyword">elif</span> visited[v] == <span class="number">1</span>:</span><br><span class="line">                    valid = <span class="keyword">False</span></span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 将节点标记为「已完成」</span></span><br><span class="line">            visited[u] = <span class="number">2</span></span><br><span class="line">            <span class="comment"># 将节点入栈</span></span><br><span class="line">            result.append(u)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 每次挑选一个「未搜索」的节点，开始进行深度优先搜索</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(numCourses):</span><br><span class="line">            <span class="keyword">if</span> valid <span class="keyword">and</span> <span class="keyword">not</span> visited[i]:</span><br><span class="line">                dfs(i)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> valid:</span><br><span class="line">            <span class="keyword">return</span> list()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果没有环，那么就有拓扑排序</span></span><br><span class="line">        <span class="comment"># 注意下标 0 为栈底，因此需要将数组反序输出</span></span><br><span class="line">        <span class="keyword">return</span> result[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></details><details>    <summary>深度优先搜索Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findOrder</span><span class="params">(numCourses <span class="keyword">int</span>, prerequisites [][]<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        edges = <span class="built_in">make</span>([][]<span class="keyword">int</span>, numCourses)</span><br><span class="line">        visited = <span class="built_in">make</span>([]<span class="keyword">int</span>, numCourses)</span><br><span class="line">        result []<span class="keyword">int</span></span><br><span class="line">        valid <span class="keyword">bool</span> = <span class="literal">true</span></span><br><span class="line">        dfs <span class="function"><span class="keyword">func</span><span class="params">(u <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">    )</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">dfs</span> = <span class="title">func</span><span class="params">(u <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        visited[u] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _, v := <span class="keyword">range</span> edges[u] &#123;</span><br><span class="line">            <span class="keyword">if</span> visited[v] == <span class="number">0</span> &#123;</span><br><span class="line">                dfs(v)</span><br><span class="line">                <span class="keyword">if</span> !valid &#123;</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> visited[v] == <span class="number">1</span> &#123;</span><br><span class="line">                valid = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[u] = <span class="number">2</span></span><br><span class="line">        result = <span class="built_in">append</span>(result, u)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, info := <span class="keyword">range</span> prerequisites &#123;</span><br><span class="line">        edges[info[<span class="number">1</span>]] = <span class="built_in">append</span>(edges[info[<span class="number">1</span>]], info[<span class="number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> visited[i] == <span class="number">0</span> &#123;</span><br><span class="line">            dfs(i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !valid &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(result)/<span class="number">2</span>; i ++ &#123;</span><br><span class="line">        result[i], result[numCourses-i<span class="number">-1</span>] = result[numCourses-i<span class="number">-1</span>], result[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>深度优先搜索C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>** edges;</span><br><span class="line"><span class="keyword">int</span>* edgeColSize;</span><br><span class="line"><span class="keyword">int</span>* visited;</span><br><span class="line"><span class="keyword">int</span>* result;</span><br><span class="line"><span class="keyword">int</span> resultSize;</span><br><span class="line"><span class="keyword">bool</span> valid;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    visited[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edgeColSize[u]; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[edges[u][i]] == <span class="number">0</span>) &#123;</span><br><span class="line">            dfs(edges[u][i]);</span><br><span class="line">            <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (visited[edges[u][i]] == <span class="number">1</span>) &#123;</span><br><span class="line">            valid = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[u] = <span class="number">2</span>;</span><br><span class="line">    result[resultSize++] = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">findOrder</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>** prerequisites, <span class="keyword">int</span> prerequisitesSize, <span class="keyword">int</span>* prerequisitesColSize, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">    valid = <span class="literal">true</span>;</span><br><span class="line">    edges = (<span class="keyword">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*) * numCourses);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        edges[i] = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    edgeColSize = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * numCourses);</span><br><span class="line">    <span class="built_in">memset</span>(edgeColSize, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * numCourses);</span><br><span class="line">    visited = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * numCourses);</span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * numCourses);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisitesSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = prerequisites[i][<span class="number">1</span>], b = prerequisites[i][<span class="number">0</span>];</span><br><span class="line">        edgeColSize[a]++;</span><br><span class="line">        edges[a] = (<span class="keyword">int</span>*)<span class="built_in">realloc</span>(edges[a], <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * edgeColSize[a]);</span><br><span class="line">        edges[a][edgeColSize[a] - <span class="number">1</span>] = b;</span><br><span class="line">    &#125;</span><br><span class="line">    result = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * numCourses);</span><br><span class="line">    resultSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            dfs(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(edges[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(edges);</span><br><span class="line">    <span class="built_in">free</span>(edgeColSize);</span><br><span class="line">    <span class="built_in">free</span>(visited);</span><br><span class="line">    <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">        *returnSize = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        *returnSize = numCourses;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = result[i];</span><br><span class="line">        result[i] = result[numCourses - i - <span class="number">1</span>], result[numCourses - i - <span class="number">1</span>] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度: <em>O(n+m)*，其中 *n</em> 为课程数，<em>m</em> 为先修课程的要求数。这其实就是对图进行深度优先搜索的时间复杂度。</p></li><li><p>空间复杂度: <em>O(n+m)<em>。题目中是以列表形式给出的先修课程关系，为了对图进行深度优先搜索，我们需要存储成邻接表的形式，空间复杂度为 *O(n+m)</em>。在深度优先搜索的过程中，我们需要最多 *O(n)</em> 的栈空间（递归）进行深度优先搜索，并且还需要若干个 <em>O(n)</em> 的空间存储节点状态、最终答案等。</p></li></ul><h2 id="方法二：广度优先搜索"><a href="#方法二：广度优先搜索" class="headerlink" title="方法二：广度优先搜索"></a>方法二：广度优先搜索</h2><p><strong>思路</strong></p><p>方法一的深度优先搜索是一种「逆向思维」：最先被放入栈中的节点是在拓扑排序中最后面的节点。我们也可以使用正向思维，顺序地生成拓扑排序，这种方法也更加直观。</p><p>我们考虑拓扑排序中最前面的节点，该节点一定不会有任何入边，也就是它没有任何的先修课程要求。当我们将一个节点加入答案中后，我们就可以移除它的所有出边，代表着它的相邻节点<strong>少了一门先修课程的要求</strong>。如果某个相邻节点变成了「没有任何入边的节点」，那么就代表着这门课可以开始学习了。按照这样的流程，我们不断地将没有入边的节点加入答案，直到答案中包含所有的节点（得到了一种拓扑排序）或者不存在没有入边的节点（图中包含环）。</p><p>上面的想法类似于广度优先搜索，因此我们可以将广度优先搜索的流程与拓扑排序的求解联系起来。</p><p><strong>算法</strong></p><p>我们使用一个队列来进行广度优先搜索。开始时，所有入度为 <em>0</em> 的节点都被放入队列中，它们就是可以作为拓扑排序最前面的节点，并且它们之间的相对顺序是无关紧要的。</p><p>在广度优先搜索的每一步中，我们取出队首的节点 <em>u</em>：</p><ul><li><p>我们将 <em>u</em> 放入答案中；</p></li><li><p>我们移除 <em>u</em> 的所有出边，也就是将 <em>u</em> 的所有相邻节点的入度减少 <em>1</em>。如果某个相邻节点 <em>v</em> 的入度变为 <em>0</em>，那么我们就将 <em>v</em> 放入队列中。</p></li></ul><p>在广度优先搜索的过程结束后。如果答案中包含了这 <em>n</em> 个节点，那么我们就找到了一种拓扑排序，否则说明图中存在环，也就不存在拓扑排序了。</p><p>下面的幻灯片给出了广度优先搜索的可视化流程。</p><p> <a href="https://assets.leetcode-cn.com/solution-static/207/fig1.png" target="_blank" rel="noopener">BFS1</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig2.png" target="_blank" rel="noopener">BFS2</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig3.png" target="_blank" rel="noopener">BFS3</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig4.png" target="_blank" rel="noopener">BFS4</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig5.png" target="_blank" rel="noopener">BFS5</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig6.png" target="_blank" rel="noopener">BFS6</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig7.png" target="_blank" rel="noopener">BFS7</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig8.png" target="_blank" rel="noopener">BFS8</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig9.png" target="_blank" rel="noopener">BFS9</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig10.png" target="_blank" rel="noopener">BFS10</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig11.png" target="_blank" rel="noopener">BFS11</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig12.png" target="_blank" rel="noopener">BFS12</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig13.png" target="_blank" rel="noopener">BFS13</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig14.png" target="_blank" rel="noopener">BFS14</a> </p><details>    <summary>广度优先搜索C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 存储有向图</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; edges;</span><br><span class="line">    <span class="comment">// 存储每个节点的入度</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indeg;</span><br><span class="line">    <span class="comment">// 存储答案</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findOrder(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">        edges.resize(numCourses);</span><br><span class="line">        indeg.resize(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; info: prerequisites) &#123;</span><br><span class="line">            edges[info[<span class="number">1</span>]].push_back(info[<span class="number">0</span>]);</span><br><span class="line">            ++indeg[info[<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="comment">// 将所有入度为 0 的节点放入队列中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indeg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="comment">// 从队首取出一个节点</span></span><br><span class="line">            <span class="keyword">int</span> u = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="comment">// 放入答案中</span></span><br><span class="line">            result.push_back(u);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v: edges[u]) &#123;</span><br><span class="line">                --indeg[v];</span><br><span class="line">                <span class="comment">// 如果相邻节点 v 的入度为 0，就可以选 v 对应的课程了</span></span><br><span class="line">                <span class="keyword">if</span> (indeg[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result.size() != numCourses) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>广度优先搜索Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存储有向图</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; edges;</span><br><span class="line">    <span class="comment">// 存储每个节点的入度</span></span><br><span class="line">    <span class="keyword">int</span>[] indeg;</span><br><span class="line">    <span class="comment">// 存储答案</span></span><br><span class="line">    <span class="keyword">int</span>[] result;</span><br><span class="line">    <span class="comment">// 答案下标</span></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">        edges = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            edges.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        indeg = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        result = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] info : prerequisites) &#123;</span><br><span class="line">            edges.get(info[<span class="number">1</span>]).add(info[<span class="number">0</span>]);</span><br><span class="line">            ++indeg[info[<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">// 将所有入度为 0 的节点放入队列中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indeg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 从队首取出一个节点</span></span><br><span class="line">            <span class="keyword">int</span> u = queue.poll();</span><br><span class="line">            <span class="comment">// 放入答案中</span></span><br><span class="line">            result[index++] = u;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v: edges.get(u)) &#123;</span><br><span class="line">                --indeg[v];</span><br><span class="line">                <span class="comment">// 如果相邻节点 v 的入度为 0，就可以选 v 对应的课程了</span></span><br><span class="line">                <span class="keyword">if</span> (indeg[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    queue.offer(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index != numCourses) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>广度优先搜索Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findOrder</span><span class="params">(self, numCourses: int, prerequisites: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 存储有向图</span></span><br><span class="line">        edges = collections.defaultdict(list)</span><br><span class="line">        <span class="comment"># 存储每个节点的入度</span></span><br><span class="line">        indeg = [<span class="number">0</span>] * numCourses</span><br><span class="line">        <span class="comment"># 存储答案</span></span><br><span class="line">        result = list()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> info <span class="keyword">in</span> prerequisites:</span><br><span class="line">            edges[info[<span class="number">1</span>]].append(info[<span class="number">0</span>])</span><br><span class="line">            indeg[info[<span class="number">0</span>]] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将所有入度为 0 的节点放入队列中</span></span><br><span class="line">        q = collections.deque([u <span class="keyword">for</span> u <span class="keyword">in</span> range(numCourses) <span class="keyword">if</span> indeg[u] == <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            <span class="comment"># 从队首取出一个节点</span></span><br><span class="line">            u = q.popleft()</span><br><span class="line">            <span class="comment"># 放入答案中</span></span><br><span class="line">            result.append(u)</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> edges[u]:</span><br><span class="line">                indeg[v] -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># 如果相邻节点 v 的入度为 0，就可以选 v 对应的课程了</span></span><br><span class="line">                <span class="keyword">if</span> indeg[v] == <span class="number">0</span>:</span><br><span class="line">                    q.append(v)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(result) != numCourses:</span><br><span class="line">            result = list()</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></details><details>    <summary>广度优先搜索Golang</summary><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findOrder</span><span class="params">(numCourses <span class="keyword">int</span>, prerequisites [][]<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        edges = <span class="built_in">make</span>([][]<span class="keyword">int</span>, numCourses)</span><br><span class="line">        indeg = <span class="built_in">make</span>([]<span class="keyword">int</span>, numCourses)</span><br><span class="line">        result []<span class="keyword">int</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, info := <span class="keyword">range</span> prerequisites &#123;</span><br><span class="line">        edges[info[<span class="number">1</span>]] = <span class="built_in">append</span>(edges[info[<span class="number">1</span>]], info[<span class="number">0</span>])</span><br><span class="line">        indeg[info[<span class="number">0</span>]]++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    q := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numCourses; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> indeg[i] == <span class="number">0</span> &#123;</span><br><span class="line">            q = <span class="built_in">append</span>(q, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(q) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        u := q[<span class="number">0</span>]</span><br><span class="line">        q = q[<span class="number">1</span>:]</span><br><span class="line">        result = <span class="built_in">append</span>(result, u)</span><br><span class="line">        <span class="keyword">for</span> _, v := <span class="keyword">range</span> edges[u] &#123;</span><br><span class="line">            indeg[v]--</span><br><span class="line">            <span class="keyword">if</span> indeg[v] == <span class="number">0</span> &#123;</span><br><span class="line">                q = <span class="built_in">append</span>(q, v)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(result) != numCourses &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>广度优先搜索C</summary><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">findOrder</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>** prerequisites, <span class="keyword">int</span> prerequisitesSize, <span class="keyword">int</span>* prerequisitesColSize, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>** edges = (<span class="keyword">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*) * numCourses);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        edges[i] = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> edgeColSize[numCourses];</span><br><span class="line">    <span class="built_in">memset</span>(edgeColSize, <span class="number">0</span>, <span class="keyword">sizeof</span>(edgeColSize));</span><br><span class="line">    <span class="keyword">int</span> indeg[numCourses];</span><br><span class="line">    <span class="built_in">memset</span>(indeg, <span class="number">0</span>, <span class="keyword">sizeof</span>(indeg));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisitesSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = prerequisites[i][<span class="number">1</span>], b = prerequisites[i][<span class="number">0</span>];</span><br><span class="line">        edgeColSize[a]++;</span><br><span class="line">        edges[a] = (<span class="keyword">int</span>*)<span class="built_in">realloc</span>(edges[a], <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * edgeColSize[a]);</span><br><span class="line">        edges[a][edgeColSize[a] - <span class="number">1</span>] = b;</span><br><span class="line">        ++indeg[b];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> q[numCourses];</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indeg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            q[++r] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* result = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * numCourses);</span><br><span class="line">    <span class="keyword">int</span> resultSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> visited = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        ++visited;</span><br><span class="line">        <span class="keyword">int</span> u = q[l++];</span><br><span class="line">        result[resultSize++] = u;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edgeColSize[u]; ++i) &#123;</span><br><span class="line">            --indeg[edges[u][i]];</span><br><span class="line">            <span class="keyword">if</span> (indeg[edges[u][i]] == <span class="number">0</span>) &#123;</span><br><span class="line">                q[++r] = edges[u][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(edges[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(edges);</span><br><span class="line">    <span class="keyword">if</span> (visited == numCourses) &#123;</span><br><span class="line">        *returnSize = numCourses;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *returnSize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度: <em>O(n+m)*，其中 *n</em> 为课程数，<em>m</em> 为先修课程的要求数。这其实就是对图进行广度优先搜索的时间复杂度。</p></li><li><p>空间复杂度: <em>O(n+m)<em>。题目中是以列表形式给出的先修课程关系，为了对图进行广度优先搜索，我们需要存储成邻接表的形式，空间复杂度为 *O(n+m)</em>。在广度优先搜索的过程中，我们需要最多 *O(n)</em> 的队列空间（迭代）进行广度优先搜索，并且还需要若干个 <em>O(n)</em> 的空间存储节点入度、最终答案等。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Breadth-first Search" scheme="http://yoursite.com/tags/Breadth-first-Search/"/>
    
      <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Graph" scheme="http://yoursite.com/tags/Graph/"/>
    
      <category term="Topological sort" scheme="http://yoursite.com/tags/Topological-sort/"/>
    
  </entry>
  
  <entry>
    <title>207. 课程表</title>
    <link href="http://yoursite.com/2020/09/14/207.%20%E8%AF%BE%E7%A8%8B%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/09/14/207. 课程表/</id>
    <published>2020-09-14T08:45:12.000Z</published>
    <updated>2020-09-15T03:11:08.819Z</updated>
    
    <content type="html"><![CDATA[<p>给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？</p><a id="more"></a><p>你这个学期必须选修 numCourse 门课程，记为0到numCourse-1 。</p><p>在选修某些课程之前需要一些先修课程。例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]</p><p>给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？</p><p>示例 1:</p><pre><code>输入: 2, [[1,0]] 输出: true解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。</code></pre><p>示例 2:</p><pre><code>输入: 2, [[1,0],[0,1]]输出: false解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</code></pre><p>提示：</p><pre><code>输入的先决条件是由 边缘列表 表示的图形，而不是 邻接矩阵 。详情请参见图的表示法。你可以假定输入的先决条件中没有重复的边。1 &lt;= numCourses &lt;= 10^5</code></pre><h1 id="📺-视频题解"><a href="#📺-视频题解" class="headerlink" title="📺 视频题解"></a>📺 视频题解</h1><p><a href="29da2f01-af1a-45a6-bb69-aea71f42900f">207.课程表 2.mp4</a></p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>本题和 <a href="https://leetcode-cn.com/problems/course-schedule-ii/" target="_blank" rel="noopener">210. 课程表 II</a> 是几乎一样的题目。如果在过去完成过该题，那么只要将代码中的返回值从「非空数组 / 空数组」修改成[True/False]就可以通过本题。</p></blockquote><p>本题是一道经典的「拓扑排序」问题。</p><p>给定一个包含 <em>n</em> 个节点的有向图 <em>G</em>，我们给出它的节点编号的一种排列，如果满足：</p><blockquote><p>对于图 <em>G</em> 中的任意一条有向边 <em>(u, v)<em>，</em>u</em> 在排列中都出现在 <em>v</em> 的前面。</p></blockquote><p>那么称该排列是图 <em>G</em> 的「拓扑排序」。根据上述的定义，我们可以得出两个结论：</p><ul><li>如果图 <em>G</em> 中存在环（即图 <em>G</em> 不是「有向无环图」），那么图 <em>G</em> 不存在拓扑排序。这是因为假设图中存在环 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x_1,x_2,...,x_n,x_1</span><br></pre></td></tr></table></figure><p>，那么 <em>x_1</em> 在排列中必须出现在 <em>x_n</em> 的前面，但 <em>x_n</em> 同时也必须出现在 <em>x_1</em> 的前面，因此不存在一个满足要求的排列，也就不存在拓扑排序；</p><ul><li>如果图 <em>G</em> 是有向无环图，那么它的拓扑排序可能不止一种。举一个最极端的例子，如果图 <em>G</em> 值包含 <em>n</em> 个节点却没有任何边，那么任意一种编号的排列都可以作为拓扑排序。</li></ul><p>有了上述的简单分析，我们就可以将本题建模成一个求拓扑排序的问题了：</p><ul><li><p>我们将每一门课看成一个节点；</p></li><li><p>如果想要学习课程 <em>A</em> 之前必须完成课程 <em>B</em>，那么我们从 <em>B</em> 到 <em>A</em> 连接一条有向边。这样以来，在拓扑排序中，<em>B</em> 一定出现在 <em>A</em> 的前面。</p></li></ul><p>求出该图是否存在拓扑排序，就可以判断是否有一种符合要求的课程学习顺序。事实上，<strong>由于求出一种拓扑排序方法的最优时间复杂度为 <em>O(n+m)*，其中 *n</em> 和 <em>m</em> 分别是有向图 <em>G</em> 的节点数和边数，方法见 <a href="https://leetcode-cn.com/problems/course-schedule-ii/solution/ke-cheng-biao-ii-by-leetcode-solution/" target="_blank" rel="noopener">210. 课程表 II 的官方题解</a>。而判断图 <em>G</em> 是否存在拓扑排序，至少也要对其进行一次完整的遍历，时间复杂度也为 <em>O(n+m)*。因此不可能存在一种仅判断图是否存在拓扑排序的方法，它的时间复杂度在渐进意义上严格优于 *O(n+m)</em></strong>。这样一来，我们使用和 <a href="https://leetcode-cn.com/problems/course-schedule-ii/" target="_blank" rel="noopener">210. 课程表 II</a> 完全相同的方法，但无需使用数据结构记录实际的拓扑排序。为了叙述的完整性，下面的两种方法与 <a href="https://leetcode-cn.com/problems/course-schedule-ii/solution/ke-cheng-biao-ii-by-leetcode-solution/" target="_blank" rel="noopener">210. 课程表 II 的官方题解</a> 完全相同，但在「算法」部分后的「优化」部分说明了如何省去对应的数据结构。</p><h2 id="方法一：深度优先搜索"><a href="#方法一：深度优先搜索" class="headerlink" title="方法一：深度优先搜索"></a>方法一：深度优先搜索</h2><p><strong>思路</strong></p><p>我们可以将深度优先搜索的流程与拓扑排序的求解联系起来，用一个栈来存储所有<strong>已经搜索完成的节点</strong>。</p><blockquote><p>对于一个节点 <em>u</em>，如果它的所有相邻节点都已经搜索完成，那么在搜索回溯到 <em>u</em> 的时候，<em>u</em> 本身也会变成一个已经搜索完成的节点。这里的「相邻节点」指的是从 <em>u</em> 出发通过一条有向边可以到达的所有节点。</p></blockquote><p>假设我们当前搜索到了节点 <em>u</em>，如果它的所有相邻节点都已经搜索完成，那么这些节点都已经在栈中了，此时我们就可以把 <em>u</em> 入栈。可以发现，如果我们从栈顶往栈底的顺序看，由于 <em>u</em> 处于栈顶的位置，那么 <em>u</em> 出现在所有 <em>u</em> 的相邻节点的前面。因此对于 <em>u</em> 这个节点而言，它是满足拓扑排序的要求的。</p><p>这样以来，我们对图进行一遍深度优先搜索。当每个节点进行回溯的时候，我们把该节点放入栈中。最终从栈顶到栈底的序列就是一种拓扑排序。</p><p><strong>算法</strong></p><p>对于图中的任意一个节点，它在搜索的过程中有三种状态，即：</p><ul><li><p>「未搜索」：我们还没有搜索到这个节点；</p></li><li><p>「搜索中」：我们搜索过这个节点，但还没有回溯到该节点，即该节点还没有入栈，还有相邻的节点没有搜索完成）；</p></li><li><p>「已完成」：我们搜索过并且回溯过这个节点，即该节点已经入栈，并且所有该节点的相邻节点都出现在栈的更底部的位置，满足拓扑排序的要求。</p></li></ul><p>通过上述的三种状态，我们就可以给出使用深度优先搜索得到拓扑排序的算法流程，在每一轮的搜索搜索开始时，我们任取一个「未搜索」的节点开始进行深度优先搜索。</p><ul><li><p>我们将当前搜索的节点 <em>u</em> 标记为「搜索中」，遍历该节点的每一个相邻节点 <em>v</em>：</p><ul><li><p>如果 <em>v</em> 为「未搜索」，那么我们开始搜索 <em>v</em>，待搜索完成回溯到 <em>u</em>；</p></li><li><p>如果 <em>v</em> 为「搜索中」，那么我们就找到了图中的一个环，因此是不存在拓扑排序的；</p></li><li><p>如果 <em>v</em> 为「已完成」，那么说明 <em>v</em> 已经在栈中了，而 <em>u</em> 还不在栈中，因此 <em>u</em> 无论何时入栈都不会影响到 <em>(u, v)</em> 之前的拓扑关系，以及不用进行任何操作。</p></li></ul></li><li><p>当 <em>u</em> 的所有相邻节点都为「已完成」时，我们将 <em>u</em> 放入栈中，并将其标记为「已完成」。</p></li></ul><p>在整个深度优先搜索的过程结束后，如果我们没有找到图中的环，那么栈中存储这所有的 <em>n</em> 个节点，从栈顶到栈底的顺序即为一种拓扑排序。</p><p>下面的幻灯片给出了深度优先搜索的可视化流程。图中的「白色」「黄色」「绿色」节点分别表示「未搜索」「搜索中」「已完成」的状态。</p><p> <a href="https://assets.leetcode-cn.com/solution-static/207/1.png" target="_blank" rel="noopener">DFS1</a> <a href="https://assets.leetcode-cn.com/solution-static/207/2.png" target="_blank" rel="noopener">DFS2</a> <a href="https://assets.leetcode-cn.com/solution-static/207/3.png" target="_blank" rel="noopener">DFS3</a> <a href="https://assets.leetcode-cn.com/solution-static/207/4.png" target="_blank" rel="noopener">DFS4</a> <a href="https://assets.leetcode-cn.com/solution-static/207/5.png" target="_blank" rel="noopener">DFS5</a> <a href="https://assets.leetcode-cn.com/solution-static/207/6.png" target="_blank" rel="noopener">DFS6</a> <a href="https://assets.leetcode-cn.com/solution-static/207/7.png" target="_blank" rel="noopener">DFS7</a> <a href="https://assets.leetcode-cn.com/solution-static/207/8.png" target="_blank" rel="noopener">DFS8</a> <a href="https://assets.leetcode-cn.com/solution-static/207/9.png" target="_blank" rel="noopener">DFS9</a> <a href="https://assets.leetcode-cn.com/solution-static/207/10.png" target="_blank" rel="noopener">DFS10</a> <a href="https://assets.leetcode-cn.com/solution-static/207/11.png" target="_blank" rel="noopener">DFS11</a> <a href="https://assets.leetcode-cn.com/solution-static/207/12.png" target="_blank" rel="noopener">DFS12</a> <a href="https://assets.leetcode-cn.com/solution-static/207/13.png" target="_blank" rel="noopener">DFS13</a> <a href="https://assets.leetcode-cn.com/solution-static/207/14.png" target="_blank" rel="noopener">DFS14</a> <a href="https://assets.leetcode-cn.com/solution-static/207/15.png" target="_blank" rel="noopener">DFS15</a> <a href="https://assets.leetcode-cn.com/solution-static/207/16.png" target="_blank" rel="noopener">DFS16</a> <a href="https://assets.leetcode-cn.com/solution-static/207/17.png" target="_blank" rel="noopener">DFS17</a> <a href="https://assets.leetcode-cn.com/solution-static/207/18.png" target="_blank" rel="noopener">DFS18</a> <a href="https://assets.leetcode-cn.com/solution-static/207/19.png" target="_blank" rel="noopener">DFS19</a> <a href="https://assets.leetcode-cn.com/solution-static/207/20.png" target="_blank" rel="noopener">DFS20</a> </p><p><strong>优化</strong></p><p>由于我们只需要判断是否存在一种拓扑排序，而栈的作用仅仅是存放最终的拓扑排序结果，因此我们可以只记录每个节点的状态，而省去对应的栈。</p><p><strong>代码</strong></p><details>    <summary>深度优先搜索C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; edges;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line">    <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v: edges[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(v);</span><br><span class="line">                <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == <span class="number">1</span>) &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[u] = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        edges.resize(numCourses);</span><br><span class="line">        visited.resize(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; info: prerequisites) &#123;</span><br><span class="line">            edges[info[<span class="number">1</span>]].push_back(info[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>深度优先搜索Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; edges;</span><br><span class="line">    <span class="keyword">int</span>[] visited;</span><br><span class="line">    <span class="keyword">boolean</span> valid = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        edges = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            edges.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] info : prerequisites) &#123;</span><br><span class="line">            edges.get(info[<span class="number">1</span>]).add(info[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//我们将当前搜索的节点 u 标记为「搜索中」，遍历该节点的每一个相邻节点 v</span></span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : edges.get(u)) &#123;</span><br><span class="line">            <span class="comment">//如果 v 为「未搜索」，那么我们开始搜索 v，待搜索完成回溯到 u</span></span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(v);</span><br><span class="line">                <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//如果 v 为「搜索中」，那么我们就找到了图中的一个环，因此是不存在拓扑排序的；</span></span><br><span class="line">                valid = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当 u 的所有相邻节点都为「已完成」时，我们将 u 放入栈中，并将其标记为「已完成」。</span></span><br><span class="line">        visited[u] = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>深度优先搜索Python</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canFinish</span><span class="params">(self, numCourses: int, prerequisites: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">        edges = collections.defaultdict(list)</span><br><span class="line">        visited = [<span class="number">0</span>] * numCourses</span><br><span class="line">        result = list()</span><br><span class="line">        valid = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> info <span class="keyword">in</span> prerequisites:</span><br><span class="line">            edges[info[<span class="number">1</span>]].append(info[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(u: int)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> valid</span><br><span class="line">            visited[u] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> edges[u]:</span><br><span class="line">                <span class="keyword">if</span> visited[v] == <span class="number">0</span>:</span><br><span class="line">                    dfs(v)</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> valid:</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">elif</span> visited[v] == <span class="number">1</span>:</span><br><span class="line">                    valid = <span class="keyword">False</span></span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">            visited[u] = <span class="number">2</span></span><br><span class="line">            result.append(u)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(numCourses):</span><br><span class="line">            <span class="keyword">if</span> valid <span class="keyword">and</span> <span class="keyword">not</span> visited[i]:</span><br><span class="line">                dfs(i)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> valid</span><br></pre></td></tr></table></figure></details><details>    <summary>深度优先搜索C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>** edges;</span><br><span class="line"><span class="keyword">int</span>* edgeColSize;</span><br><span class="line"><span class="keyword">int</span>* visited;</span><br><span class="line"><span class="keyword">bool</span> valid;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    visited[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edgeColSize[u]; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[edges[u][i]] == <span class="number">0</span>) &#123;</span><br><span class="line">            dfs(edges[u][i]);</span><br><span class="line">            <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (visited[edges[u][i]] == <span class="number">1</span>) &#123;</span><br><span class="line">            valid = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[u] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>** prerequisites, <span class="keyword">int</span> prerequisitesSize, <span class="keyword">int</span>* prerequisitesColSize)</span> </span>&#123;</span><br><span class="line">    valid = <span class="literal">true</span>;</span><br><span class="line">    edges = (<span class="keyword">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*) * numCourses);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        edges[i] = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    edgeColSize = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * numCourses);</span><br><span class="line">    <span class="built_in">memset</span>(edgeColSize, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * numCourses);</span><br><span class="line">    visited = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * numCourses);</span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * numCourses);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisitesSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = prerequisites[i][<span class="number">1</span>], b = prerequisites[i][<span class="number">0</span>];</span><br><span class="line">        edgeColSize[a]++;</span><br><span class="line">        edges[a] = (<span class="keyword">int</span>*)<span class="built_in">realloc</span>(edges[a], <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * edgeColSize[a]);</span><br><span class="line">        edges[a][edgeColSize[a] - <span class="number">1</span>] = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            dfs(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(edges[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(edges);</span><br><span class="line">    <span class="built_in">free</span>(edgeColSize);</span><br><span class="line">    <span class="built_in">free</span>(visited);</span><br><span class="line">    <span class="keyword">return</span> valid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>深度优先搜索Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canFinish</span><span class="params">(numCourses <span class="keyword">int</span>, prerequisites [][]<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        edges = <span class="built_in">make</span>([][]<span class="keyword">int</span>, numCourses)</span><br><span class="line">        visited = <span class="built_in">make</span>([]<span class="keyword">int</span>, numCourses)</span><br><span class="line">        result []<span class="keyword">int</span></span><br><span class="line">        valid = <span class="literal">true</span></span><br><span class="line">        dfs <span class="function"><span class="keyword">func</span><span class="params">(u <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">    )</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">dfs</span> = <span class="title">func</span><span class="params">(u <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        visited[u] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _, v := <span class="keyword">range</span> edges[u] &#123;</span><br><span class="line">            <span class="keyword">if</span> visited[v] == <span class="number">0</span> &#123;</span><br><span class="line">                dfs(v)</span><br><span class="line">                <span class="keyword">if</span> !valid &#123;</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> visited[v] == <span class="number">1</span> &#123;</span><br><span class="line">                valid = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[u] = <span class="number">2</span></span><br><span class="line">        result = <span class="built_in">append</span>(result, u)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, info := <span class="keyword">range</span> prerequisites &#123;</span><br><span class="line">        edges[info[<span class="number">1</span>]] = <span class="built_in">append</span>(edges[info[<span class="number">1</span>]], info[<span class="number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> visited[i] == <span class="number">0</span> &#123;</span><br><span class="line">            dfs(i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> valid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度: <em>O(n+m)*，其中 *n</em> 为课程数，<em>m</em> 为先修课程的要求数。这其实就是对图进行深度优先搜索的时间复杂度。</p></li><li><p>空间复杂度: <em>O(n+m)<em>。题目中是以列表形式给出的先修课程关系，为了对图进行深度优先搜索，我们需要存储成邻接表的形式，空间复杂度为 *O(n+m)</em>。在深度优先搜索的过程中，我们需要最多 *O(n)</em> 的栈空间（递归）进行深度优先搜索，因此总空间复杂度为 <em>O(n+m)</em>。</p></li></ul><h2 id="方法二-广度优先搜索"><a href="#方法二-广度优先搜索" class="headerlink" title="方法二: 广度优先搜索"></a>方法二: 广度优先搜索</h2><p><strong>思路</strong></p><p>方法一的深度优先搜索是一种「逆向思维」：最先被放入栈中的节点是在拓扑排序中最后面的节点。我们也可以使用正向思维，顺序地生成拓扑排序，这种方法也更加直观。</p><p>我们考虑拓扑排序中最前面的节点，该节点一定不会有任何入边，也就是它没有任何的先修课程要求。当我们将一个节点加入答案中后，我们就可以移除它的所有出边，代表着它的相邻节点<strong>少了一门先修课程的要求</strong>。如果某个相邻节点变成了「没有任何入边的节点」，那么就代表着这门课可以开始学习了。按照这样的流程，我们不断地将没有入边的节点加入答案，直到答案中包含所有的节点（得到了一种拓扑排序）或者不存在没有入边的节点（图中包含环）。</p><p>上面的想法类似于广度优先搜索，因此我们可以将广度优先搜索的流程与拓扑排序的求解联系起来。</p><p><strong>算法</strong></p><p>我们使用一个队列来进行广度优先搜索。初始时，所有入度为 <em>0</em> 的节点都被放入队列中，它们就是可以作为拓扑排序最前面的节点，并且它们之间的相对顺序是无关紧要的。</p><p>在广度优先搜索的每一步中，我们取出队首的节点 <em>u</em>：</p><ul><li><p>我们将 <em>u</em> 放入答案中；</p></li><li><p>我们移除 <em>u</em> 的所有出边，也就是将 <em>u</em> 的所有相邻节点的入度减少 <em>1</em>。如果某个相邻节点 <em>v</em> 的入度变为 <em>0</em>，那么我们就将 <em>v</em> 放入队列中。</p></li></ul><p>在广度优先搜索的过程结束后。如果答案中包含了这 <em>n</em> 个节点，那么我们就找到了一种拓扑排序，否则说明图中存在环，也就不存在拓扑排序了。</p><p>下面的幻灯片给出了广度优先搜索的可视化流程。</p><p> <a href="https://assets.leetcode-cn.com/solution-static/207/fig1.png" target="_blank" rel="noopener">BFS1</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig2.png" target="_blank" rel="noopener">BFS2</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig3.png" target="_blank" rel="noopener">BFS3</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig4.png" target="_blank" rel="noopener">BFS4</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig5.png" target="_blank" rel="noopener">BFS5</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig6.png" target="_blank" rel="noopener">BFS6</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig7.png" target="_blank" rel="noopener">BFS7</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig8.png" target="_blank" rel="noopener">BFS8</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig9.png" target="_blank" rel="noopener">BFS9</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig10.png" target="_blank" rel="noopener">BFS10</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig11.png" target="_blank" rel="noopener">BFS11</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig12.png" target="_blank" rel="noopener">BFS12</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig13.png" target="_blank" rel="noopener">BFS13</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig14.png" target="_blank" rel="noopener">BFS14</a> </p><p><strong>优化</strong></p><p>由于我们只需要判断是否存在一种拓扑排序，因此我们省去存放答案数组，而是只用一个变量记录被放入答案数组的节点个数。在广度优先搜索结束之后，我们判断该变量的值是否等于课程数，就能知道是否存在一种拓扑排序。</p><p><strong>代码</strong></p><details>    <summary>广度优先搜索C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; edges;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indeg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        edges.resize(numCourses);</span><br><span class="line">        indeg.resize(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; info: prerequisites) &#123;</span><br><span class="line">            edges[info[<span class="number">1</span>]].push_back(info[<span class="number">0</span>]);</span><br><span class="line">            ++indeg[info[<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indeg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> visited = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            ++visited;</span><br><span class="line">            <span class="keyword">int</span> u = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v: edges[u]) &#123;</span><br><span class="line">                --indeg[v];</span><br><span class="line">                <span class="keyword">if</span> (indeg[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> visited == numCourses;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>广度优先搜索Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; edges;</span><br><span class="line">    <span class="keyword">int</span>[] indeg;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        edges = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            edges.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        indeg = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] info : prerequisites) &#123;</span><br><span class="line">            edges.get(info[<span class="number">1</span>]).add(info[<span class="number">0</span>]);</span><br><span class="line">            ++indeg[info[<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//在广度优先搜索的每一步中，我们取出队首的节点 u：</span></span><br><span class="line">        <span class="comment">//我们将 u 放入答案中；</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indeg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> visited = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            visited++;</span><br><span class="line">            <span class="keyword">int</span> u = queue.poll();</span><br><span class="line">            <span class="comment">//我们移除 u 的所有出边，也就是将 u 的所有相邻节点的入度减少 1。如果某个相邻节点 v 的入度变为 0，那么我们就将 v 放入队列中。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v : edges.get(u)) &#123;</span><br><span class="line">                --indeg[v];</span><br><span class="line">                <span class="keyword">if</span> (indeg[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    queue.offer(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在广度优先搜索的过程结束后。如果答案中包含了这 n 个节点，那么我们就找到了一种拓扑排序，否则说明图中存在环，也就不存在拓扑排序了。</span></span><br><span class="line">        <span class="keyword">return</span> visited == numCourses;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>广度优先搜索Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canFinish</span><span class="params">(self, numCourses: int, prerequisites: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">        edges = collections.defaultdict(list)</span><br><span class="line">        indeg = [<span class="number">0</span>] * numCourses</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> info <span class="keyword">in</span> prerequisites:</span><br><span class="line">            edges[info[<span class="number">1</span>]].append(info[<span class="number">0</span>])</span><br><span class="line">            indeg[info[<span class="number">0</span>]] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        q = collections.deque([u <span class="keyword">for</span> u <span class="keyword">in</span> range(numCourses) <span class="keyword">if</span> indeg[u] == <span class="number">0</span>])</span><br><span class="line">        visited = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            visited += <span class="number">1</span></span><br><span class="line">            u = q.popleft()</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> edges[u]:</span><br><span class="line">                indeg[v] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> indeg[v] == <span class="number">0</span>:</span><br><span class="line">                    q.append(v)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> visited == numCourses</span><br></pre></td></tr></table></figure></details><details>    <summary>广度优先搜索C</summary><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>** prerequisites, <span class="keyword">int</span> prerequisitesSize, <span class="keyword">int</span>* prerequisitesColSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>** edges = (<span class="keyword">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*) * numCourses);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        edges[i] = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> edgeColSize[numCourses];</span><br><span class="line">    <span class="built_in">memset</span>(edgeColSize, <span class="number">0</span>, <span class="keyword">sizeof</span>(edgeColSize));</span><br><span class="line">    <span class="keyword">int</span> indeg[numCourses];</span><br><span class="line">    <span class="built_in">memset</span>(indeg, <span class="number">0</span>, <span class="keyword">sizeof</span>(indeg));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisitesSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = prerequisites[i][<span class="number">1</span>], b = prerequisites[i][<span class="number">0</span>];</span><br><span class="line">        edgeColSize[a]++;</span><br><span class="line">        edges[a] = (<span class="keyword">int</span>*)<span class="built_in">realloc</span>(edges[a], <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * edgeColSize[a]);</span><br><span class="line">        edges[a][edgeColSize[a] - <span class="number">1</span>] = b;</span><br><span class="line">        ++indeg[b];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> q[numCourses];</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indeg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            q[++r] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> visited = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        ++visited;</span><br><span class="line">        <span class="keyword">int</span> u = q[l++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edgeColSize[u]; ++i) &#123;</span><br><span class="line">            --indeg[edges[u][i]];</span><br><span class="line">            <span class="keyword">if</span> (indeg[edges[u][i]] == <span class="number">0</span>) &#123;</span><br><span class="line">                q[++r] = edges[u][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(edges[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(edges);</span><br><span class="line">    <span class="keyword">return</span> visited == numCourses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>广度优先搜索Golang</summary><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canFinish</span><span class="params">(numCourses <span class="keyword">int</span>, prerequisites [][]<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        edges = <span class="built_in">make</span>([][]<span class="keyword">int</span>, numCourses)</span><br><span class="line">        indeg = <span class="built_in">make</span>([]<span class="keyword">int</span>, numCourses)</span><br><span class="line">        result []<span class="keyword">int</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, info := <span class="keyword">range</span> prerequisites &#123;</span><br><span class="line">        edges[info[<span class="number">1</span>]] = <span class="built_in">append</span>(edges[info[<span class="number">1</span>]], info[<span class="number">0</span>])</span><br><span class="line">        indeg[info[<span class="number">0</span>]]++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    q := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numCourses; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> indeg[i] == <span class="number">0</span> &#123;</span><br><span class="line">            q = <span class="built_in">append</span>(q, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(q) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        u := q[<span class="number">0</span>]</span><br><span class="line">        q = q[<span class="number">1</span>:]</span><br><span class="line">        result = <span class="built_in">append</span>(result, u)</span><br><span class="line">        <span class="keyword">for</span> _, v := <span class="keyword">range</span> edges[u] &#123;</span><br><span class="line">            indeg[v]--</span><br><span class="line">            <span class="keyword">if</span> indeg[v] == <span class="number">0</span> &#123;</span><br><span class="line">                q = <span class="built_in">append</span>(q, v)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(result) == numCourses</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>**复杂度分析**<ul><li><p>时间复杂度: <em>O(n+m)*，其中 *n</em> 为课程数，<em>m</em> 为先修课程的要求数。这其实就是对图进行广度优先搜索的时间复杂度。</p></li><li><p>空间复杂度: <em>O(n+m)<em>。题目中是以列表形式给出的先修课程关系，为了对图进行广度优先搜索，我们需要存储成邻接表的形式，空间复杂度为 *O(n+m)</em>。在广度优先搜索的过程中，我们需要最多 *O(n)</em> 的队列空间（迭代）进行广度优先搜索。因此总空间复杂度为 <em>O(n+m)</em>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？&lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Breadth-first Search" scheme="http://yoursite.com/tags/Breadth-first-Search/"/>
    
      <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Graph" scheme="http://yoursite.com/tags/Graph/"/>
    
      <category term="Topological sort" scheme="http://yoursite.com/tags/Topological-sort/"/>
    
  </entry>
  
  <entry>
    <title>200. 岛屿数量</title>
    <link href="http://yoursite.com/2020/09/14/200.%20%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/"/>
    <id>http://yoursite.com/2020/09/14/200. 岛屿数量/</id>
    <published>2020-09-14T07:45:12.000Z</published>
    <updated>2020-09-14T08:51:15.789Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><a id="more"></a><p>岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p>示例 1:</p><pre><code>输入:[[&apos;1&apos;,&apos;1&apos;,&apos;1&apos;,&apos;1&apos;,&apos;0&apos;],[&apos;1&apos;,&apos;1&apos;,&apos;0&apos;,&apos;1&apos;,&apos;0&apos;],[&apos;1&apos;,&apos;1&apos;,&apos;0&apos;,&apos;0&apos;,&apos;0&apos;],[&apos;0&apos;,&apos;0&apos;,&apos;0&apos;,&apos;0&apos;,&apos;0&apos;]]输出: 1</code></pre><p>示例 2:</p><pre><code>输入:[[&apos;1&apos;,&apos;1&apos;,&apos;0&apos;,&apos;0&apos;,&apos;0&apos;],[&apos;1&apos;,&apos;1&apos;,&apos;0&apos;,&apos;0&apos;,&apos;0&apos;],[&apos;0&apos;,&apos;0&apos;,&apos;1&apos;,&apos;0&apos;,&apos;0&apos;],[&apos;0&apos;,&apos;0&apos;,&apos;0&apos;,&apos;1&apos;,&apos;1&apos;]]输出: 3解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。</code></pre><h1 id="📺-视频题解"><a href="#📺-视频题解" class="headerlink" title="📺 视频题解"></a>📺 视频题解</h1><p><a href="0a3f7b6f-abd0-4af8-87ef-89c565b967d4">LeetCode 200 ZYH.mp4</a></p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="方法一：深度优先搜索"><a href="#方法一：深度优先搜索" class="headerlink" title="方法一：深度优先搜索"></a>方法一：深度优先搜索</h2><p>我们可以将二维网格看成一个无向图，竖直或水平相邻的 <em>1</em> 之间有边相连。</p><p>为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 <em>1</em>，则以其为起始节点开始进行深度优先搜索。在深度优先搜索的过程中，每个搜索到的 <em>1</em> 都会被重新标记为 <em>0</em>。</p><p>最终岛屿的数量就是我们进行深度优先搜索的次数。</p><p>下面的动画展示了整个算法。</p><p> <a href="https://pic.leetcode-cn.com/5dae0de2a06f4eae5113f9cadfa5c51bbcf0b9347c5861aa73c93d7bc1d50b34-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/61a98091fe75de107bf886a608e87d5bb29d810b9e7eb1e00c541f49194ea543-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/6d060f275561dc390841f78d85124fd193efb0801ea2dc865b2767f1093e4f3a-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/233368eab82832268c3c7266fd7fe65c78626de9fd89cb90b3f36a7b4e52860d-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/bf055c3d5f6b310f6a110ada65d503de6d7793276f5638731c81c53b4276b835-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/195ba530a5350e0a8f8e372319d061c85316c1064017d5c00d7cfc2b0c055de6-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/c21a88bde9450ad83d6164c2df4677b16154fa5990408459a2a45982b9cd70fd-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/0cfddec2d15ed9a56c434f470ff07eb3dfc83dccbda0160583d1bce469077274-image.png" target="_blank" rel="noopener">image.png</a> </p><details>    <summary>深度优先搜索C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nr = grid.size();</span><br><span class="line">        <span class="keyword">int</span> nc = grid[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">        grid[r][c] = <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span> (r - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r<span class="number">-1</span>][c] == <span class="string">'1'</span>) dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">        <span class="keyword">if</span> (r + <span class="number">1</span> &lt; nr &amp;&amp; grid[r+<span class="number">1</span>][c] == <span class="string">'1'</span>) dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">        <span class="keyword">if</span> (c - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r][c<span class="number">-1</span>] == <span class="string">'1'</span>) dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; nc &amp;&amp; grid[r][c+<span class="number">1</span>] == <span class="string">'1'</span>) dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nr = grid.size();</span><br><span class="line">        <span class="keyword">if</span> (!nr) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nc = grid[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num_islands = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; nr; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; nc; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    ++num_islands;</span><br><span class="line">                    dfs(grid, r, c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num_islands;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>深度优先搜索Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nr = grid.length;</span><br><span class="line">        <span class="keyword">int</span> nc = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r &gt;= nr || c &gt;= nc || grid[r][c] == <span class="string">'0'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        grid[r][c] = <span class="string">'0'</span>;</span><br><span class="line">        dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">        dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">        dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">        dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> nr = grid.length;</span><br><span class="line">        <span class="keyword">int</span> nc = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> num_islands = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; nr; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; nc; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    ++num_islands;</span><br><span class="line">                    dfs(grid, r, c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num_islands;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>深度优先搜索Python</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, grid, r, c)</span>:</span></span><br><span class="line">        grid[r][c] = <span class="number">0</span></span><br><span class="line">        nr, nc = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> [(r - <span class="number">1</span>, c), (r + <span class="number">1</span>, c), (r, c - <span class="number">1</span>), (r, c + <span class="number">1</span>)]:</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= x &lt; nr <span class="keyword">and</span> <span class="number">0</span> &lt;= y &lt; nc <span class="keyword">and</span> grid[x][y] == <span class="string">"1"</span>:</span><br><span class="line">                self.dfs(grid, x, y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span><span class="params">(self, grid: List[List[str]])</span> -&gt; int:</span></span><br><span class="line">        nr = len(grid)</span><br><span class="line">        <span class="keyword">if</span> nr == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        nc = len(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        num_islands = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(nr):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(nc):</span><br><span class="line">                <span class="keyword">if</span> grid[r][c] == <span class="string">"1"</span>:</span><br><span class="line">                    num_islands += <span class="number">1</span></span><br><span class="line">                    self.dfs(grid, r, c)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> num_islands</span><br></pre></td></tr></table></figure></details>**复杂度分析**<ul><li><p>时间复杂度：<em>O(MN)*，其中 *M</em> 和 <em>N</em> 分别为行数和列数。</p></li><li><p>空间复杂度：<em>O(MN)</em>，在最坏情况下，整个网格均为陆地，深度优先搜索的深度达到 <em>M N</em>。</p></li></ul><h2 id="方法二：广度优先搜索"><a href="#方法二：广度优先搜索" class="headerlink" title="方法二：广度优先搜索"></a>方法二：广度优先搜索</h2><p>同样地，我们也可以使用广度优先搜索代替深度优先搜索。</p><p>为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 <em>1</em>，则将其加入队列，开始进行广度优先搜索。在广度优先搜索的过程中，每个搜索到的 <em>1</em> 都会被重新标记为 <em>0</em>。直到队列为空，搜索结束。</p><p>最终岛屿的数量就是我们进行广度优先搜索的次数。</p><details>    <summary>广度优先搜索C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nr = grid.size();</span><br><span class="line">        <span class="keyword">if</span> (!nr) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nc = grid[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num_islands = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; nr; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; nc; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    ++num_islands;</span><br><span class="line">                    grid[r][c] = <span class="string">'0'</span>;</span><br><span class="line">                    <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; neighbors;</span><br><span class="line">                    neighbors.push(&#123;r, c&#125;);</span><br><span class="line">                    <span class="keyword">while</span> (!neighbors.empty()) &#123;</span><br><span class="line">                        <span class="keyword">auto</span> rc = neighbors.front();</span><br><span class="line">                        neighbors.pop();</span><br><span class="line">                        <span class="keyword">int</span> row = rc.first, col = rc.second;</span><br><span class="line">                        <span class="keyword">if</span> (row - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[row<span class="number">-1</span>][col] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                            neighbors.push(&#123;row<span class="number">-1</span>, col&#125;);</span><br><span class="line">                            grid[row<span class="number">-1</span>][col] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (row + <span class="number">1</span> &lt; nr &amp;&amp; grid[row+<span class="number">1</span>][col] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                            neighbors.push(&#123;row+<span class="number">1</span>, col&#125;);</span><br><span class="line">                            grid[row+<span class="number">1</span>][col] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (col - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[row][col<span class="number">-1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                            neighbors.push(&#123;row, col<span class="number">-1</span>&#125;);</span><br><span class="line">                            grid[row][col<span class="number">-1</span>] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (col + <span class="number">1</span> &lt; nc &amp;&amp; grid[row][col+<span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                            neighbors.push(&#123;row, col+<span class="number">1</span>&#125;);</span><br><span class="line">                            grid[row][col+<span class="number">1</span>] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num_islands;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>广度优先搜索Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> nr = grid.length;</span><br><span class="line">        <span class="keyword">int</span> nc = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> num_islands = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; nr; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; nc; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    ++num_islands;</span><br><span class="line">                    grid[r][c] = <span class="string">'0'</span>;</span><br><span class="line">                    Queue&lt;Integer&gt; neighbors = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                    neighbors.add(r * nc + c);</span><br><span class="line">                    <span class="keyword">while</span> (!neighbors.isEmpty()) &#123;</span><br><span class="line">                        <span class="keyword">int</span> id = neighbors.remove();</span><br><span class="line">                        <span class="keyword">int</span> row = id / nc;</span><br><span class="line">                        <span class="keyword">int</span> col = id % nc;</span><br><span class="line">                        <span class="keyword">if</span> (row - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[row-<span class="number">1</span>][col] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                            neighbors.add((row-<span class="number">1</span>) * nc + col);</span><br><span class="line">                            grid[row-<span class="number">1</span>][col] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (row + <span class="number">1</span> &lt; nr &amp;&amp; grid[row+<span class="number">1</span>][col] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                            neighbors.add((row+<span class="number">1</span>) * nc + col);</span><br><span class="line">                            grid[row+<span class="number">1</span>][col] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (col - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[row][col-<span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                            neighbors.add(row * nc + col-<span class="number">1</span>);</span><br><span class="line">                            grid[row][col-<span class="number">1</span>] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (col + <span class="number">1</span> &lt; nc &amp;&amp; grid[row][col+<span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                            neighbors.add(row * nc + col+<span class="number">1</span>);</span><br><span class="line">                            grid[row][col+<span class="number">1</span>] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num_islands;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>广度优先搜索Python</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span><span class="params">(self, grid: List[List[str]])</span> -&gt; int:</span></span><br><span class="line">        nr = len(grid)</span><br><span class="line">        <span class="keyword">if</span> nr == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        nc = len(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        num_islands = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(nr):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(nc):</span><br><span class="line">                <span class="keyword">if</span> grid[r][c] == <span class="string">"1"</span>:</span><br><span class="line">                    num_islands += <span class="number">1</span></span><br><span class="line">                    grid[r][c] = <span class="string">"0"</span></span><br><span class="line">                    neighbors = collections.deque([(r, c)])</span><br><span class="line">                    <span class="keyword">while</span> neighbors:</span><br><span class="line">                        row, col = neighbors.popleft()</span><br><span class="line">                        <span class="keyword">for</span> x, y <span class="keyword">in</span> [(row - <span class="number">1</span>, col), (row + <span class="number">1</span>, col), (row, col - <span class="number">1</span>), (row, col + <span class="number">1</span>)]:</span><br><span class="line">                            <span class="keyword">if</span> <span class="number">0</span> &lt;= x &lt; nr <span class="keyword">and</span> <span class="number">0</span> &lt;= y &lt; nc <span class="keyword">and</span> grid[x][y] == <span class="string">"1"</span>:</span><br><span class="line">                                neighbors.append((x, y))</span><br><span class="line">                                grid[x][y] = <span class="string">"0"</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> num_islands</span><br></pre></td></tr></table></figure></details>**复杂度分析**<ul><li><p>时间复杂度：<em>O(MN)*，其中 *M</em> 和 <em>N</em> 分别为行数和列数。</p></li><li><p>空间复杂度：O(min(M,N)) ，在最坏情况下，整个网格均为陆地，队列的大小可以达到 min(M,N)。</p></li></ul><h2 id="方法三：并查集"><a href="#方法三：并查集" class="headerlink" title="方法三：并查集"></a>方法三：并查集</h2><p>同样地，我们也可以使用并查集代替搜索。</p><p>为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 <em>1</em>，则将其与相邻四个方向上的 <em>1</em> 在并查集中进行合并。</p><p>最终岛屿的数量就是并查集中连通分量的数目。</p><p>下面的动画展示了整个算法。</p><p> <a href="https://pic.leetcode-cn.com/41b6ce1794ba80a7a82b31dc4c0642b26ccd280457d254d2fdad37a1f5a73ca6-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/82fa6f7b52294fdd8a2f4a0a28d4ca2dd3d71e86e7ddf5fa5ef4b18a13d3c438-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/773a3ac931ca2b397b0ba6cac17a15a0dd21fe2d0f2887d6b90405d9025c3f85-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/6c1a18d84a24f74c18654e0f20b17c263646a9fad911e6bb227e665688abb037-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/1a35068b177ce3ed70de37d3e7a1fb3e91ba0e5588ab3e3633ddb963f3d64f68-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/6f35cbfc7410e54ec80f96af3123c5eed5e5b8f73e6a1cc2fa4aea0f911e919c-image.png" target="_blank" rel="noopener">image.png</a> </p><details>    <summary>并查集C++</summary><figure class="highlight c++"><figcaption><span>[sol3-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UnionFind(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size();</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    parent.push_back(i * n + j);</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    parent.push_back(<span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                rank.push_back(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[i] != i) &#123;</span><br><span class="line">            parent[i] = find(parent[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootx = find(x);</span><br><span class="line">        <span class="keyword">int</span> rooty = find(y);</span><br><span class="line">        <span class="keyword">if</span> (rootx != rooty) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rank[rootx] &lt; rank[rooty]) &#123;</span><br><span class="line">                swap(rootx, rooty);</span><br><span class="line">            &#125;</span><br><span class="line">            parent[rooty] = rootx;</span><br><span class="line">            <span class="keyword">if</span> (rank[rootx] == rank[rooty]) rank[rootx] += <span class="number">1</span>;</span><br><span class="line">            --count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rank;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nr = grid.size();</span><br><span class="line">        <span class="keyword">if</span> (!nr) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nc = grid[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">        <span class="function">UnionFind <span class="title">uf</span><span class="params">(grid)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> num_islands = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; nr; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; nc; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    grid[r][c] = <span class="string">'0'</span>;</span><br><span class="line">                    <span class="keyword">if</span> (r - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r<span class="number">-1</span>][c] == <span class="string">'1'</span>) uf.unite(r * nc + c, (r<span class="number">-1</span>) * nc + c);</span><br><span class="line">                    <span class="keyword">if</span> (r + <span class="number">1</span> &lt; nr &amp;&amp; grid[r+<span class="number">1</span>][c] == <span class="string">'1'</span>) uf.unite(r * nc + c, (r+<span class="number">1</span>) * nc + c);</span><br><span class="line">                    <span class="keyword">if</span> (c - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r][c<span class="number">-1</span>] == <span class="string">'1'</span>) uf.unite(r * nc + c, r * nc + c - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (c + <span class="number">1</span> &lt; nc &amp;&amp; grid[r][c+<span class="number">1</span>] == <span class="string">'1'</span>) uf.unite(r * nc + c, r * nc + c + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> uf.getCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>并查集Java</summary><figure class="highlight java"><figcaption><span>[sol3-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">int</span>[] parent;</span><br><span class="line">        <span class="keyword">int</span>[] rank;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> m = grid.length;</span><br><span class="line">            <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="keyword">int</span>[m * n];</span><br><span class="line">            rank = <span class="keyword">new</span> <span class="keyword">int</span>[m * n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                        parent[i * n + j] = i * n + j;</span><br><span class="line">                        ++count;</span><br><span class="line">                    &#125;</span><br><span class="line">                    rank[i * n + j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (parent[i] != i) parent[i] = find(parent[i]);</span><br><span class="line">            <span class="keyword">return</span> parent[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> rootx = find(x);</span><br><span class="line">            <span class="keyword">int</span> rooty = find(y);</span><br><span class="line">            <span class="keyword">if</span> (rootx != rooty) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rank[rootx] &gt; rank[rooty]) &#123;</span><br><span class="line">                    parent[rooty] = rootx;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootx] &lt; rank[rooty]) &#123;</span><br><span class="line">                    parent[rootx] = rooty;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    parent[rooty] = rootx;</span><br><span class="line">                    rank[rootx] += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                --count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> nr = grid.length;</span><br><span class="line">        <span class="keyword">int</span> nc = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> num_islands = <span class="number">0</span>;</span><br><span class="line">        UnionFind uf = <span class="keyword">new</span> UnionFind(grid);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; nr; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; nc; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    grid[r][c] = <span class="string">'0'</span>;</span><br><span class="line">                    <span class="keyword">if</span> (r - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r-<span class="number">1</span>][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                        uf.union(r * nc + c, (r-<span class="number">1</span>) * nc + c);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (r + <span class="number">1</span> &lt; nr &amp;&amp; grid[r+<span class="number">1</span>][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                        uf.union(r * nc + c, (r+<span class="number">1</span>) * nc + c);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (c - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r][c-<span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                        uf.union(r * nc + c, r * nc + c - <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (c + <span class="number">1</span> &lt; nc &amp;&amp; grid[r][c+<span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                        uf.union(r * nc + c, r * nc + c + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> uf.getCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>并查集Python</summary><figure class="highlight python"><figcaption><span>[sol3-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        m, n = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line">        self.parent = [<span class="number">-1</span>] * (m * n)</span><br><span class="line">        self.rank = [<span class="number">0</span>] * (m * n)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">"1"</span>:</span><br><span class="line">                    self.parent[i * n + j] = i * n + j</span><br><span class="line">                    self.count += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.parent[i] != i:</span><br><span class="line">            self.parent[i] = self.find(self.parent[i])</span><br><span class="line">        <span class="keyword">return</span> self.parent[i]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        rootx = self.find(x)</span><br><span class="line">        rooty = self.find(y)</span><br><span class="line">        <span class="keyword">if</span> rootx != rooty:</span><br><span class="line">            <span class="keyword">if</span> self.rank[rootx] &lt; self.rank[rooty]:</span><br><span class="line">                rootx, rooty = rooty, rootx</span><br><span class="line">            self.parent[rooty] = rootx</span><br><span class="line">            <span class="keyword">if</span> self.rank[rootx] == self.rank[rooty]:</span><br><span class="line">                self.rank[rootx] += <span class="number">1</span></span><br><span class="line">            self.count -= <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getCount</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.count</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span><span class="params">(self, grid: List[List[str]])</span> -&gt; int:</span></span><br><span class="line">        nr = len(grid)</span><br><span class="line">        <span class="keyword">if</span> nr == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        nc = len(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        uf = UnionFind(grid)</span><br><span class="line">        num_islands = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(nr):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(nc):</span><br><span class="line">                <span class="keyword">if</span> grid[r][c] == <span class="string">"1"</span>:</span><br><span class="line">                    grid[r][c] = <span class="string">"0"</span></span><br><span class="line">                    <span class="keyword">for</span> x, y <span class="keyword">in</span> [(r - <span class="number">1</span>, c), (r + <span class="number">1</span>, c), (r, c - <span class="number">1</span>), (r, c + <span class="number">1</span>)]:</span><br><span class="line">                        <span class="keyword">if</span> <span class="number">0</span> &lt;= x &lt; nr <span class="keyword">and</span> <span class="number">0</span> &lt;= y &lt; nc <span class="keyword">and</span> grid[x][y] == <span class="string">"1"</span>:</span><br><span class="line">                            uf.union(r * nc + c, x * nc + y)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> uf.getCount()</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(MN*\alpha(MN))</span><br></pre></td></tr></table></figure></li></ul><p>，其中 <em>M</em> 和 <em>N</em> 分别为行数和列数。注意当使用路径压缩（见 <code>find</code> 函数）和按秩合并（见数组 <code>rank</code>）实现并查集时，单次操作的时间复杂度为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\alpha(MN)</span><br></pre></td></tr></table></figure><p>，其中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\alpha(x)</span><br></pre></td></tr></table></figure><p>为反阿克曼函数，当自变量 <em>x</em> 的值在人类可观测的范围内（宇宙中粒子的数量）时，函数 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\alpha(x)</span><br></pre></td></tr></table></figure><p>的值不会超过 <em>5</em>，因此也可以看成是常数时间复杂度。</p><ul><li>空间复杂度：<em>O(MN)</em>，这是并查集需要使用的空间。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Breadth-first Search" scheme="http://yoursite.com/tags/Breadth-first-Search/"/>
    
      <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Union Find" scheme="http://yoursite.com/tags/Union-Find/"/>
    
  </entry>
  
  <entry>
    <title>127. 单词接龙</title>
    <link href="http://yoursite.com/2020/09/09/127.%20%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/"/>
    <id>http://yoursite.com/2020/09/09/127. 单词接龙/</id>
    <published>2020-09-09T09:45:12.000Z</published>
    <updated>2020-09-14T07:42:39.750Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。</p><a id="more"></a><p>转换需遵循如下规则：</p><ul><li>每次转换只能改变一个字母。</li><li>转换过程中的中间单词必须是字典中的单词。</li></ul><p>说明:</p><ul><li>如果不存在这样的转换序列，返回 0。</li><li>所有单词具有相同的长度。</li><li>所有单词只由小写字母组成。</li><li>字典中不存在重复的单词。</li><li>你可以假设 beginWord 和 endWord 是非空的，且二者不相同。</li></ul><p>示例 1:</p><pre><code>输入:beginWord = &quot;hit&quot;,endWord = &quot;cog&quot;,wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]输出: 5解释: 一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;, 返回它的长度 5。</code></pre><p>示例 2:</p><pre><code>输入:beginWord = &quot;hit&quot;endWord = &quot;cog&quot;wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]输出: 0解释: endWord &quot;cog&quot; 不在字典中，所以无法进行转换。</code></pre><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>拥有一个 <code>beginWord</code> 和一个 <code>endWord</code>，分别表示图上的 <code>start node</code> 和  <code>end node</code>。我们希望利用一些中间节点（单词）从  <code>start node</code> 到  <code>end node</code>，中间节点是 <code>wordList</code> 给定的单词。我们对这个单词接龙每个步骤的唯一条件是相邻单词只可以改变<code>一个字母</code>。</p><p><a href="https://pic.leetcode-cn.com/fc3a60e60cb7a80723feea0689c25a6f1637df8c64cfec0d70a264eee7e88254-Word_Ladder_1.png" target="_blank" rel="noopener">Word_Ladder_1.png</a></p><p>我们将问题抽象在一个无向无权图中，每个单词作为节点，差距只有一个字母的两个单词之间连一条边。问题变成找到从起点到终点的最短路径，如果存在的话。因此可以使用<code>广度优先搜索</code>方法。</p><p>算法中最重要的步骤是找出相邻的节点，也就是只差一个字母的两个单词。为了快速的找到这些相邻节点，我们对给定的 <code>wordList</code> 做一个预处理，将单词中的某个字母用 <code>*</code> 代替。</p><p><a href="https://pic.leetcode-cn.com/7212249f3e224d9d5ccbc292e902e48b572f965236378e034d8e03924404cba2-Word_Ladder_2.png" target="_blank" rel="noopener">Word_Ladder_2.png</a></p><p>这个预处理帮我们构造了一个单词变换的通用状态。例如：<code>Dog ----&gt; D*g &lt;---- Dig</code>，<code>Dog</code> 和 <code>Dig</code> 都指向了一个通用状态 <code>D*g</code>。</p><p>这步预处理找出了单词表中所有单词改变某个字母后的通用状态，并帮助我们更方便也更快的找到相邻节点。否则，对于每个单词我们需要遍历整个字母表查看是否存在一个单词与它相差一个字母，这将花费很多时间。预处理操作在广度优先搜索之前高效的建立了邻接表。</p><p>例如，在广搜时我们需要访问 <code>Dug</code> 的所有邻接点，我们可以先生成 <code>Dug</code> 的所有通用状态：</p><ol><li><code>Dug =&gt; *ug</code></li><li><code>Dug =&gt; D*g</code></li><li><code>Dug =&gt; Du*</code></li></ol><p>第二个变换 <code>D*g</code> 可以同时映射到 <code>Dog</code> 或者 <code>Dig</code>，因为他们都有相同的通用状态。拥有相同的通用状态意味着两个单词只相差一个字母，他们的节点是相连的。</p><h1 id="方法-1：广度优先搜索"><a href="#方法-1：广度优先搜索" class="headerlink" title="方法 1：广度优先搜索"></a>方法 1：广度优先搜索</h1><p><strong>想法</strong></p><p>利用广度优先搜索搜索从 <code>beginWord</code> 到 <code>endWord</code> 的路径。</p><p><strong>算法</strong></p><ol><li><p>对给定的 <code>wordList</code> 做预处理，找出所有的通用状态。将通用状态记录在字典中，键是通用状态，值是所有具有通用状态的单词。</p></li><li><p>将包含 <code>beginWord</code> 和 <code>1</code> 的元组放入队列中，<code>1</code> 代表节点的层次。我们需要返回 <code>endWord</code> 的层次也就是从 <code>beginWord</code> 出发的最短距离。</p></li><li><p>为了防止出现环，使用访问数组记录。</p></li><li><p>当队列中有元素的时候，取出第一个元素，记为 <code>current_word</code>。</p></li><li><p>找到 <code>current_word</code> 的所有通用状态，并检查这些通用状态是否存在其它单词的映射，这一步通过检查 <code>all_combo_dict</code> 来实现。</p></li><li><p>从 <code>all_combo_dict</code> 获得的所有单词，都和 <code>current_word</code> 共有一个通用状态，所以都和 <code>current_word</code> 相连，因此将他们加入到队列中。</p></li><li><p>对于新获得的所有单词，向队列中加入元素 <code>(word, level + 1)</code> 其中 <code>level</code> 是 <code>current_word</code> 的层次。</p></li><li><p>最终当你到达期望的单词，对应的层次就是最短变换序列的长度。</p><blockquote><p>标准广度优先搜索的终止条件就是找到结束单词。</p></blockquote></li></ol><details>    <summary>广度优先搜索Java</summary><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Since all words are of same length.</span></span><br><span class="line">    <span class="keyword">int</span> L = beginWord.length();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dictionary to hold combination of words that can be formed,</span></span><br><span class="line">    <span class="comment">// from any given word. By changing one letter at a time.</span></span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; allComboDict = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    wordList.forEach(</span><br><span class="line">        word -&gt; &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L; i++) &#123;</span><br><span class="line">            <span class="comment">// Key is the generic word</span></span><br><span class="line">            <span class="comment">// Value is a list of words which have the same intermediate generic word.</span></span><br><span class="line">            String newWord = word.substring(<span class="number">0</span>, i) + <span class="string">'*'</span> + word.substring(i + <span class="number">1</span>, L);</span><br><span class="line">            List&lt;String&gt; transformations = allComboDict.getOrDefault(newWord, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            transformations.add(word);</span><br><span class="line">            allComboDict.put(newWord, transformations);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Queue for BFS</span></span><br><span class="line">    Queue&lt;Pair&lt;String, Integer&gt;&gt; Q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Q.add(<span class="keyword">new</span> Pair(beginWord, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Visited to make sure we don't repeat processing same word.</span></span><br><span class="line">    Map&lt;String, Boolean&gt; visited = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    visited.put(beginWord, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!Q.isEmpty()) &#123;</span><br><span class="line">      Pair&lt;String, Integer&gt; node = Q.remove();</span><br><span class="line">      String word = node.getKey();</span><br><span class="line">      <span class="keyword">int</span> level = node.getValue();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Intermediate words for current word</span></span><br><span class="line">        String newWord = word.substring(<span class="number">0</span>, i) + <span class="string">'*'</span> + word.substring(i + <span class="number">1</span>, L);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Next states are all the words which share the same intermediate state.</span></span><br><span class="line">        <span class="keyword">for</span> (String adjacentWord : allComboDict.getOrDefault(newWord, <span class="keyword">new</span> ArrayList&lt;&gt;())) &#123;</span><br><span class="line">          <span class="comment">// If at any point if we find what we are looking for</span></span><br><span class="line">          <span class="comment">// i.e. the end word - we can return with the answer.</span></span><br><span class="line">          <span class="keyword">if</span> (adjacentWord.equals(endWord)) &#123;</span><br><span class="line">            <span class="keyword">return</span> level + <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// Otherwise, add it to the BFS Queue. Also mark it visited</span></span><br><span class="line">          <span class="keyword">if</span> (!visited.containsKey(adjacentWord)) &#123;</span><br><span class="line">            visited.put(adjacentWord, <span class="keyword">true</span>);</span><br><span class="line">            Q.add(<span class="keyword">new</span> Pair(adjacentWord, level + <span class="number">1</span>));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>广度优先搜索Python</summary><figure class="highlight python"><figcaption><span>[solution1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ladderLength</span><span class="params">(self, beginWord, endWord, wordList)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type beginWord: str</span></span><br><span class="line"><span class="string">        :type endWord: str</span></span><br><span class="line"><span class="string">        :type wordList: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> endWord <span class="keyword">not</span> <span class="keyword">in</span> wordList <span class="keyword">or</span> <span class="keyword">not</span> endWord <span class="keyword">or</span> <span class="keyword">not</span> beginWord <span class="keyword">or</span> <span class="keyword">not</span> wordList:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Since all words are of same length.</span></span><br><span class="line">        L = len(beginWord)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Dictionary to hold combination of words that can be formed,</span></span><br><span class="line">        <span class="comment"># from any given word. By changing one letter at a time.</span></span><br><span class="line">        all_combo_dict = defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> wordList:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(L):</span><br><span class="line">                <span class="comment"># Key is the generic word</span></span><br><span class="line">                <span class="comment"># Value is a list of words which have the same intermediate generic word.</span></span><br><span class="line">                all_combo_dict[word[:i] + <span class="string">"*"</span> + word[i+<span class="number">1</span>:]].append(word)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Queue for BFS</span></span><br><span class="line">        queue = [(beginWord, <span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># Visited to make sure we don't repeat processing same word.</span></span><br><span class="line">        visited = &#123;beginWord: <span class="keyword">True</span>&#125;</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            current_word, level = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(L):</span><br><span class="line">                <span class="comment"># Intermediate words for current word</span></span><br><span class="line">                intermediate_word = current_word[:i] + <span class="string">"*"</span> + current_word[i+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Next states are all the words which share the same intermediate state.</span></span><br><span class="line">                <span class="keyword">for</span> word <span class="keyword">in</span> all_combo_dict[intermediate_word]:</span><br><span class="line">                    <span class="comment"># If at any point if we find what we are looking for</span></span><br><span class="line">                    <span class="comment"># i.e. the end word - we can return with the answer.</span></span><br><span class="line">                    <span class="keyword">if</span> word == endWord:</span><br><span class="line">                        <span class="keyword">return</span> level + <span class="number">1</span></span><br><span class="line">                    <span class="comment"># Otherwise, add it to the BFS Queue. Also mark it visited</span></span><br><span class="line">                    <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                        visited[word] = <span class="keyword">True</span></span><br><span class="line">                        queue.append((word, level + <span class="number">1</span>))</span><br><span class="line">                all_combo_dict[intermediate_word] = []</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(M\times N)</span><br></pre></td></tr></table></figure></li></ul><p>，其中 <em>M</em> 是单词的长度 <em>N</em> 是单词表中单词的总数。找到所有的变换需要对每个单词做 <em>M</em> 次操作。同时，最坏情况下广度优先搜索也要访问所有的 <em>N</em> 个单词。</p><ul><li>空间复杂度：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(M\times N)</span><br></pre></td></tr></table></figure></li></ul><p>，要在 <code>all_combo_dict</code> 字典中记录每个单词的 <em>M</em> 个通用状态。访问数组的大小是 <em>N</em>。广搜队列最坏情况下需要存储 <em>N</em> 个单词。</p><h1 id="方法-2：双向广度优先搜索"><a href="#方法-2：双向广度优先搜索" class="headerlink" title="方法 2：双向广度优先搜索"></a>方法 2：双向广度优先搜索</h1><p><strong>想法</strong></p><p>根据给定字典构造的图可能会很大，而广度优先搜索的搜索空间大小依赖于每层节点的分支数量。假如每个节点的分支数量相同，搜索空间会随着层数的增长指数级的增加。考虑一个简单的二叉树，每一层都是满二叉树的扩展，节点的数量会以 <code>2</code> 为底数呈指数增长。</p><p>如果使用两个同时进行的广搜可以有效地减少搜索空间。一边从 <code>beginWord</code> 开始，另一边从 <code>endWord</code> 开始。我们每次从两边各扩展一个节点，当发现某一时刻两边都访问了某一顶点时就停止搜索。这就是<code>双向广度优先搜索</code>，它可以可观地减少搜索空间大小，从而降低时间和空间复杂度。</p><p><a href="https://pic.leetcode-cn.com/be92086801e264f49bb1c01593dbfee5b08e52c600b62576c5fa0c1ef2d54eb8-Word_Ladder_3.png" target="_blank" rel="noopener">Word_Ladder_3.png</a></p><p><strong>算法</strong></p><ol><li><p>算法与之前描述的标准广搜方法相类似。</p></li><li><p>唯一的不同是我们从两个节点同时开始搜索，同时搜索的结束条件也有所变化。</p></li><li><p>我们现在有两个访问数组，分别记录从对应的起点是否已经访问了该节点。</p></li><li><p>如果我们发现一个节点被两个搜索同时访问，就结束搜索过程。因为我们找到了双向搜索的交点。过程如同从中间相遇而不是沿着搜索路径一直走。</p><blockquote><p>双向搜索的结束条件是找到一个单词被两边搜索都访问过了。</p></blockquote></li><li><p>最短变换序列的长度就是中间节点在两边的层次之和。因此，我们可以在访问数组中记录节点的层次。</p></li></ol><p><a href="https://pic.leetcode-cn.com/77ff942730428bad804a3f3e8bcddb618ce7b26a2df85cae104c5c2563803dde-Word_Ladder_4.png" target="_blank" rel="noopener">Word_Ladder_4.png</a></p><details>    <summary>双向广度优先搜索Java</summary><figure class="highlight java"><figcaption><span>[solution2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> L;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, List&lt;String&gt;&gt; allComboDict;</span><br><span class="line"></span><br><span class="line">  Solution() &#123;</span><br><span class="line">    <span class="keyword">this</span>.L = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dictionary to hold combination of words that can be formed,</span></span><br><span class="line">    <span class="comment">// from any given word. By changing one letter at a time.</span></span><br><span class="line">    <span class="keyword">this</span>.allComboDict = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">visitWordNode</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Queue&lt;Pair&lt;String, Integer&gt;&gt; Q,</span></span></span><br><span class="line"><span class="function"><span class="params">      Map&lt;String, Integer&gt; visited,</span></span></span><br><span class="line"><span class="function"><span class="params">      Map&lt;String, Integer&gt; othersVisited)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Pair&lt;String, Integer&gt; node = Q.remove();</span><br><span class="line">    String word = node.getKey();</span><br><span class="line">    <span class="keyword">int</span> level = node.getValue();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.L; i++) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Intermediate words for current word</span></span><br><span class="line">      String newWord = word.substring(<span class="number">0</span>, i) + <span class="string">'*'</span> + word.substring(i + <span class="number">1</span>, L);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Next states are all the words which share the same intermediate state.</span></span><br><span class="line">      <span class="keyword">for</span> (String adjacentWord : <span class="keyword">this</span>.allComboDict.getOrDefault(newWord, <span class="keyword">new</span> ArrayList&lt;&gt;())) &#123;</span><br><span class="line">        <span class="comment">// If at any point if we find what we are looking for</span></span><br><span class="line">        <span class="comment">// i.e. the end word - we can return with the answer.</span></span><br><span class="line">        <span class="keyword">if</span> (othersVisited.containsKey(adjacentWord)) &#123;</span><br><span class="line">          <span class="keyword">return</span> level + othersVisited.get(adjacentWord);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!visited.containsKey(adjacentWord)) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Save the level as the value of the dictionary, to save number of hops.</span></span><br><span class="line">          visited.put(adjacentWord, level + <span class="number">1</span>);</span><br><span class="line">          Q.add(<span class="keyword">new</span> Pair(adjacentWord, level + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!wordList.contains(endWord)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Since all words are of same length.</span></span><br><span class="line">    <span class="keyword">this</span>.L = beginWord.length();</span><br><span class="line"></span><br><span class="line">    wordList.forEach(</span><br><span class="line">        word -&gt; &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L; i++) &#123;</span><br><span class="line">            <span class="comment">// Key is the generic word</span></span><br><span class="line">            <span class="comment">// Value is a list of words which have the same intermediate generic word.</span></span><br><span class="line">            String newWord = word.substring(<span class="number">0</span>, i) + <span class="string">'*'</span> + word.substring(i + <span class="number">1</span>, L);</span><br><span class="line">            List&lt;String&gt; transformations =</span><br><span class="line">                <span class="keyword">this</span>.allComboDict.getOrDefault(newWord, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            transformations.add(word);</span><br><span class="line">            <span class="keyword">this</span>.allComboDict.put(newWord, transformations);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Queues for birdirectional BFS</span></span><br><span class="line">    <span class="comment">// BFS starting from beginWord</span></span><br><span class="line">    Queue&lt;Pair&lt;String, Integer&gt;&gt; Q_begin = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// BFS starting from endWord</span></span><br><span class="line">    Queue&lt;Pair&lt;String, Integer&gt;&gt; Q_end = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Q_begin.add(<span class="keyword">new</span> Pair(beginWord, <span class="number">1</span>));</span><br><span class="line">    Q_end.add(<span class="keyword">new</span> Pair(endWord, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Visited to make sure we don't repeat processing same word.</span></span><br><span class="line">    Map&lt;String, Integer&gt; visitedBegin = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;String, Integer&gt; visitedEnd = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    visitedBegin.put(beginWord, <span class="number">1</span>);</span><br><span class="line">    visitedEnd.put(endWord, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!Q_begin.isEmpty() &amp;&amp; !Q_end.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// One hop from begin word</span></span><br><span class="line">      <span class="keyword">int</span> ans = visitWordNode(Q_begin, visitedBegin, visitedEnd);</span><br><span class="line">      <span class="keyword">if</span> (ans &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// One hop from end word</span></span><br><span class="line">      ans = visitWordNode(Q_end, visitedEnd, visitedBegin);</span><br><span class="line">      <span class="keyword">if</span> (ans &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>双向广度优先搜索Python</summary><figure class="highlight python"><figcaption><span>[solution2-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.length = <span class="number">0</span></span><br><span class="line">        <span class="comment"># Dictionary to hold combination of words that can be formed,</span></span><br><span class="line">        <span class="comment"># from any given word. By changing one letter at a time.</span></span><br><span class="line">        self.all_combo_dict = defaultdict(list)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visitWordNode</span><span class="params">(self, queue, visited, others_visited)</span>:</span></span><br><span class="line">        current_word, level = queue.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.length):</span><br><span class="line">            <span class="comment"># Intermediate words for current word</span></span><br><span class="line">            intermediate_word = current_word[:i] + <span class="string">"*"</span> + current_word[i+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Next states are all the words which share the same intermediate state.</span></span><br><span class="line">            <span class="keyword">for</span> word <span class="keyword">in</span> self.all_combo_dict[intermediate_word]:</span><br><span class="line">                <span class="comment"># If the intermediate state/word has already been visited from the</span></span><br><span class="line">                <span class="comment"># other parallel traversal this means we have found the answer.</span></span><br><span class="line">                <span class="keyword">if</span> word <span class="keyword">in</span> others_visited:</span><br><span class="line">                    <span class="keyword">return</span> level + others_visited[word]</span><br><span class="line">                <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    <span class="comment"># Save the level as the value of the dictionary, to save number of hops.</span></span><br><span class="line">                    visited[word] = level + <span class="number">1</span></span><br><span class="line">                    queue.append((word, level + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ladderLength</span><span class="params">(self, beginWord, endWord, wordList)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type beginWord: str</span></span><br><span class="line"><span class="string">        :type endWord: str</span></span><br><span class="line"><span class="string">        :type wordList: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> endWord <span class="keyword">not</span> <span class="keyword">in</span> wordList <span class="keyword">or</span> <span class="keyword">not</span> endWord <span class="keyword">or</span> <span class="keyword">not</span> beginWord <span class="keyword">or</span> <span class="keyword">not</span> wordList:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Since all words are of same length.</span></span><br><span class="line">        self.length = len(beginWord)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> wordList:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(self.length):</span><br><span class="line">                <span class="comment"># Key is the generic word</span></span><br><span class="line">                <span class="comment"># Value is a list of words which have the same intermediate generic word.</span></span><br><span class="line">                self.all_combo_dict[word[:i] + <span class="string">"*"</span> + word[i+<span class="number">1</span>:]].append(word)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Queues for birdirectional BFS</span></span><br><span class="line">        queue_begin = [(beginWord, <span class="number">1</span>)] <span class="comment"># BFS starting from beginWord</span></span><br><span class="line">        queue_end = [(endWord, <span class="number">1</span>)] <span class="comment"># BFS starting from endWord</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Visited to make sure we don't repeat processing same word</span></span><br><span class="line">        visited_begin = &#123;beginWord: <span class="number">1</span>&#125;</span><br><span class="line">        visited_end = &#123;endWord: <span class="number">1</span>&#125;</span><br><span class="line">        ans = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># We do a birdirectional search starting one pointer from begin</span></span><br><span class="line">        <span class="comment"># word and one pointer from end word. Hopping one by one.</span></span><br><span class="line">        <span class="keyword">while</span> queue_begin <span class="keyword">and</span> queue_end:</span><br><span class="line"></span><br><span class="line">            <span class="comment"># One hop from begin word</span></span><br><span class="line">            ans = self.visitWordNode(queue_begin, visited_begin, visited_end)</span><br><span class="line">            <span class="keyword">if</span> ans:</span><br><span class="line">                <span class="keyword">return</span> ans</span><br><span class="line">            <span class="comment"># One hop from end word</span></span><br><span class="line">            ans = self.visitWordNode(queue_end, visited_end, visited_begin)</span><br><span class="line">            <span class="keyword">if</span> ans:</span><br><span class="line">                <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(M\times N)</span><br></pre></td></tr></table></figure></li></ul><p>，其中 <em>M</em> 是单词的长度 <em>N</em> 是单词表中单词的总数。与单向搜索相同的是，找到所有的变换需要 <em>M * N</em> 次操作。但是搜索时间会被缩小一半，因为两个搜索会在中间某处相遇。</p><ul><li>空间复杂度：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(M\times N)</span><br></pre></td></tr></table></figure><p>，要在 <code>all_combo_dict</code> 字典中记录每个单词的 <em>M</em> 个通用状态，这与单向搜索相同。但是因为会在中间相遇，所以双向搜索的搜索空间变小。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Breadth-first Search" scheme="http://yoursite.com/tags/Breadth-first-Search/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
</feed>
