<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-30T04:45:57.821Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>542. 01 Matrix 01 矩阵</title>
    <link href="http://yoursite.com/2018/08/30/542.%2001%20Matrix%2001%20%E7%9F%A9%E9%98%B5/"/>
    <id>http://yoursite.com/2018/08/30/542. 01 Matrix 01 矩阵/</id>
    <published>2018-08-30T04:45:43.000Z</published>
    <updated>2018-08-30T04:45:57.821Z</updated>
    
    <content type="html"><![CDATA[<h1 id="542-01-Matrix-01-矩阵"><a href="#542-01-Matrix-01-矩阵" class="headerlink" title="542. 01 Matrix 01 矩阵"></a>542. 01 Matrix 01 矩阵</h1><p>给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。</p><p>两个相邻元素间的距离为 1 。</p><a id="more"></a><p>示例 1:<br>输入:</p><pre><code>0 0 00 1 00 0 0</code></pre><p>输出:</p><pre><code>0 0 00 1 00 0 0</code></pre><p>示例 2:<br>输入:</p><pre><code>0 0 00 1 01 1 1</code></pre><p>输出:</p><pre><code>0 0 00 1 01 2 1</code></pre><p>注意:</p><p>给定矩阵的元素个数不超过 10000。<br>给定矩阵中至少有一个元素是 0。<br>矩阵中的元素只在四个方向上相邻: 上、下、左、右。</p><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>计算的距离是<a href="https://baike.baidu.com/item/%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB/743092?fr=aladdin" target="_blank" rel="noopener">曼哈顿距离</a></p><p>因为这道题是求值为1的点到值为0的区域的最短距离，因为是在图上求最短距离，所以可以用广度优先搜索方法求解，该方法在求最小生成树和迪杰斯特拉最短路径算法的思想中都有体现。本质上是有一个已知最优路线（最优一般指距离最短）区域，这个区域被放进queue中，这道题的这个区域就是0区域，所以一开始要将0区域都找出来，并把它们push进queue里，然后开始BFS，每遇到一个<strong>未访问过的点（matrix[i][j]值为-1）和合法的点（不超过map）</strong>的区域，就将它加一并push进queue中，这样，图map总会被遍历完，而且总是最小值。</p><pre><code>class Solution {public:    vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {        int m=matrix.size();        int n=matrix[0].size();        queue&lt;pair&lt;int,int&gt;&gt; que;        for(int i=0;i&lt;m;i++){            for(int j=0;j&lt;n;j++){                if(matrix[i][j]==0) que.push(make_pair(i,j));                else matrix[i][j]=-1;            }        }        vector&lt;vector&lt;int&gt;&gt; dirs={            {-1,0},            {1,0},            {0,-1},            {0,1}        };        while(!que.empty()){            auto q=que.front();            que.pop();            for(int d=0;d&lt;4;d++){                int r=q.first+dirs[d][0];                int c=q.second+dirs[d][1];                if(r&gt;=0 &amp;&amp; r&lt;m &amp;&amp; c&gt;=0 &amp;&amp; c&lt;n &amp;&amp; matrix[r][c]==-1 ) {                que.push(make_pair(r,c));                matrix[r][c]=matrix[q.first][q.second]+1; //distance++                                                                                             }            }        }        return matrix;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;542-01-Matrix-01-矩阵&quot;&gt;&lt;a href=&quot;#542-01-Matrix-01-矩阵&quot; class=&quot;headerlink&quot; title=&quot;542. 01 Matrix 01 矩阵&quot;&gt;&lt;/a&gt;542. 01 Matrix 01 矩阵&lt;/h1&gt;&lt;p&gt;给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。&lt;/p&gt;
&lt;p&gt;两个相邻元素间的距离为 1 。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>C++输入总结</title>
    <link href="http://yoursite.com/2018/08/29/C++%E8%BE%93%E5%85%A5/"/>
    <id>http://yoursite.com/2018/08/29/C++输入/</id>
    <published>2018-08-29T02:33:12.000Z</published>
    <updated>2018-08-29T02:41:27.063Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-输入总结"><a href="#C-输入总结" class="headerlink" title="C++输入总结"></a>C++输入总结</h1><p>总结常用的C++输入</p><a id="more"></a><p>总结下常用的C++字符，字符串，数字输入方法和问题：</p><h3 id="1-while里面用cin-gt-gt-val如何结束"><a href="#1-while里面用cin-gt-gt-val如何结束" class="headerlink" title="1.while里面用cin &gt;&gt; val如何结束"></a>1.while里面用cin &gt;&gt; val如何结束</h3><h3 id="2-如何在while（cin-gt-gt-val）跳出循环后能继续执行程序中其他的输入操作"><a href="#2-如何在while（cin-gt-gt-val）跳出循环后能继续执行程序中其他的输入操作" class="headerlink" title="2.如何在while（cin &gt;&gt; val）跳出循环后能继续执行程序中其他的输入操作"></a>2.如何在while（cin &gt;&gt; val）跳出循环后能继续执行程序中其他的输入操作</h3><h3 id="3-getline和cin-getline-的区别及使用方法"><a href="#3-getline和cin-getline-的区别及使用方法" class="headerlink" title="3.getline和cin.getline()的区别及使用方法"></a>3.getline和cin.getline()的区别及使用方法</h3><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;cctype&gt;#include&lt;string&gt;using namespace std;int main(){    /*    Q1:    while里面用cin &gt;&gt; val是什么意思，用这个当条件的话，通过检测其流的状态来判断结束；    （1）若流是有效的，即流未遇到错误，那么检测成功；    （2）若遇到文件结束符，或遇到一个无效的输入时（例如输入的值不是一个整数），istream对象的状态会变为无效，条件就为假；    怎样才是文件结束符呢？    不同的操作系统有不同的约定，在windows系统中，输入文件结束符的方法是先按Ctrl+Z，然后再按Enter；在UNIX系统中，包括Mac OS X系统中，文件结束输入为Ctrl+D;     */    //freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);    int val;    vector&lt;int&gt;nums;      while (cin &gt;&gt; val ) {//在键盘输入时要ctrl+z再按回车,文件输入则不用         nums.push_back(val);    }    for (auto n : nums) cout &lt;&lt; n &lt;&lt; &quot;  &quot;;    cout &lt;&lt; endl;    /*    Q2:    如何在while（cin &gt;&gt; val）跳出循环后能继续执行程序中其他的输入操作:    输入ctrl+z使程序跳出了while(cin&gt;&gt;val)的循环，但是它并不能继续执行循环外的输入操作也就是直接退出了程序。    那这是为什么呢？    要理清这件事首先我们要对了解的处理机制，cin遇到ctrl+z便认为输入结束，也就是不再接受键盘的输入（但是它会读取缓冲区已经存在的数据），    但是ctrl+z还是会留在缓冲区内    也就是说当我们输入换行+（ctrl+z）+换行后。程序跳出while循环，但是ctrl+z还在缓冲区内，当程序继续执行时，    当cin再去读的时候，发现缓冲区存在ctrl+z（上次跳出循环遗留下的），于是它就走了，也就是什么都没读到。所以用户也无法输入。    解决方法很简单    就是及时清除缓冲区    也就是在程序跳出循环后利用函数    cin.clear();    cin.ignore();    */    cin.clear();    cin.ignore();    string str;    getline(cin, str);    cout &lt;&lt; str &lt;&lt; endl;    /*    用于string类的。使用需包含头文件#include&lt;string&gt;。getline(cin,string s)，接收一个字符串，可以接收空格、回车等    与cin.getline()的区别：1.cin.getline()接收输入字符串的是数组，getline（）是string类型。    2.cin.getline()可以接收空格，但不能接收回车；getline()可以接收空格和回车    3.cin.getline()会在数组结尾是&apos;\0&apos;，getline()不会    */    char s[20];    cin.getline(s,20);    cout &lt;&lt; s &lt;&lt; endl;    /*实际是cin.getline(接收字符串到m，接收个数n，结束字符)。接收一个字符串，可以接收空格等，最后一个字符为‘\0’。结束符可以通过设置第三个参数自己设置，默认是回车。m不能为string类型。    注意：实际接收到的要比n少一个，因为最后一个字符为&apos;\0&apos;。    */    char c;    cin.get(c);    cout &lt;&lt; c &lt;&lt; endl;    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;C-输入总结&quot;&gt;&lt;a href=&quot;#C-输入总结&quot; class=&quot;headerlink&quot; title=&quot;C++输入总结&quot;&gt;&lt;/a&gt;C++输入总结&lt;/h1&gt;&lt;p&gt;总结常用的C++输入&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="stdin" scheme="http://yoursite.com/tags/stdin/"/>
    
  </entry>
  
  <entry>
    <title>操作系统基础概念I</title>
    <link href="http://yoursite.com/2018/08/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5I/"/>
    <id>http://yoursite.com/2018/08/28/操作系统基础概念I/</id>
    <published>2018-08-28T02:42:12.000Z</published>
    <updated>2018-08-30T01:36:00.574Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统基础概念I"><a href="#操作系统基础概念I" class="headerlink" title="操作系统基础概念I"></a>操作系统基础概念I</h1><p>总结操作系统基础概念</p><a id="more"></a><h2 id="（一）请分别简单说一说进程和线程以及它们的区别。"><a href="#（一）请分别简单说一说进程和线程以及它们的区别。" class="headerlink" title="（一）请分别简单说一说进程和线程以及它们的区别。"></a>（一）请分别简单说一说进程和线程以及它们的区别。</h2><p>进程是具有一定功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源调度和分配的一个独立单位。<br>线程是进程的实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。<br>一个进程可以有多个线程，多个线程也可以并发执行</p><p>如果你对进程或者线程不太熟悉，建议阅读：<a href="https://link.zhihu.com/?target=http%3A//www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="noopener">进程与线程的一个简单解释</a></p><h2 id="（二）线程同步的方式有哪些？"><a href="#（二）线程同步的方式有哪些？" class="headerlink" title="（二）线程同步的方式有哪些？"></a>（二）线程同步的方式有哪些？</h2><p>互斥量：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。<br>信号量：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。<br>事件（信号）：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</p><p>如果你对线程同步的方式不太熟悉，建议阅读：<a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/lebronjames/archive/2010/08/11/1797702.html" target="_blank" rel="noopener">线程同步的几种方式</a></p><h2 id="（三）进程的通信方式有哪些？"><a href="#（三）进程的通信方式有哪些？" class="headerlink" title="（三）进程的通信方式有哪些？"></a>（三）进程的通信方式有哪些？</h2><p>主要分为：管道、系统IPC（包括消息队列、信号量、共享存储）、SOCKET</p><p>管道主要分为：普通管道PIPE 、流管道（s_pipe）、命名管道（name_pipe）</p><p>管道是一种半双工的通信方式，数据只能单项流动，并且只能在具有亲缘关系的进程间流动，进程的亲缘关系通常是父子进程<br>命名管道也是半双工的通信方式，它允许无亲缘关系的进程间进行通信<br>信号量是一个计数器，用来控制多个进程对资源的访问，它通常作为一种锁机制。<br>消息队列是消息的链表，存放在内核中并由消息队列标识符标识。<br>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。<br>共享内存就是映射一段能被其它进程访问的内存，这段共享内存由一个进程创建，但是多个进程可以访问。<br>如果你对进程的通信方式不太熟悉，建议阅读： <a href="https://blog.csdn.net/yufaw/article/details/7409596" target="_blank" rel="noopener">进程间的几种通信方式</a></p><h2 id="（四）什么是缓冲区溢出？有什么危害？其原因是什么？"><a href="#（四）什么是缓冲区溢出？有什么危害？其原因是什么？" class="headerlink" title="（四）什么是缓冲区溢出？有什么危害？其原因是什么？"></a>（四）什么是缓冲区溢出？有什么危害？其原因是什么？</h2><p>缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。</p><p>危害有以下两点：</p><p>程序崩溃，导致拒绝额服务<br>跳转并且执行一段恶意代码<br>造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入。 </p><p>如果你想深入了解缓冲区溢出，推荐阅读：<a href="http://www.cnblogs.com/fanzhidongyzby/archive/2013/08/10/3250405.html" target="_blank" rel="noopener">缓冲区溢出攻击</a></p><h2 id="（五）什么是死锁？死锁产生的条件？"><a href="#（五）什么是死锁？死锁产生的条件？" class="headerlink" title="（五）什么是死锁？死锁产生的条件？"></a>（五）什么是死锁？死锁产生的条件？</h2><p>在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲就是两个或多个进程无限期的阻塞、相互等待的一种状态。</p><p>死锁产生的四个条件（有一个条件不成立，则不会产生死锁）</p><p>互斥条件：一个资源一次只能被一个进程使用<br>请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放<br>不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺<br>循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系<br>如果对死锁还不是太熟悉，建议阅读：<a href="http://www.cnblogs.com/Jessy/p/3540724.html" target="_blank" rel="noopener">死锁产生的原因和解锁的方法</a></p><h2 id="（六）进程有哪几种状态？"><a href="#（六）进程有哪几种状态？" class="headerlink" title="（六）进程有哪几种状态？"></a>（六）进程有哪几种状态？</h2><p>就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源<br>运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数<br>阻塞状态： 进程等待某种条件，在条件满足之前无法执行<br>如果你对进程的几种状态以及中间的装换不太了解，建议阅读：<a href="http://www.cnblogs.com/Jessy/p/3540724.html" target="_blank" rel="noopener">进程的三种状态及转换</a></p><h2 id="（七）分页和分段有什么区别？"><a href="#（七）分页和分段有什么区别？" class="headerlink" title="（七）分页和分段有什么区别？"></a>（七）分页和分段有什么区别？</h2><p>段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 ；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的。<br>段的大小不固定，有它所完成的功能决定；页大大小固定，由系统决定<br>段向用户提供二维地址空间；页向用户提供的是一维地址空间<br>段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。<br>如果你对分页和分段还不太了解，建议阅读：<a href="https://blog.csdn.net/wangrunmin/article/details/7967293" target="_blank" rel="noopener">分段和分页</a></p><h2 id="（八）-操作系统中进程调度策略有哪几种？"><a href="#（八）-操作系统中进程调度策略有哪几种？" class="headerlink" title="（八） 操作系统中进程调度策略有哪几种？"></a>（八） 操作系统中进程调度策略有哪几种？</h2><p>FCFS(先来先服务)，优先级，时间片轮转，多级反馈</p><p>如果你想深入的了解这几种调度策略，推荐阅读：<a href="https://blog.csdn.net/luyafei_89430/article/details/12971171" target="_blank" rel="noopener">几个常用的操作系统进程调度算法</a> </p><h2 id="（九）说一说进程同步有哪几种机制。"><a href="#（九）说一说进程同步有哪几种机制。" class="headerlink" title="（九）说一说进程同步有哪几种机制。"></a>（九）说一说进程同步有哪几种机制。</h2><p>原子操作、信号量机制、自旋锁管程、会合、分布式系统</p><p>如果你想深入的了解这几种机制，推荐阅读： <a href="http://www.cnblogs.com/sonic4x/archive/2011/07/05/2098036.html" target="_blank" rel="noopener">进程同步的几种机制</a></p><h2 id="（十）说一说死锁的处理基本策略和常用方法。"><a href="#（十）说一说死锁的处理基本策略和常用方法。" class="headerlink" title="（十）说一说死锁的处理基本策略和常用方法。"></a>（十）说一说死锁的处理基本策略和常用方法。</h2><p>解决死锁的基本方法如下： </p><p>预防死锁、避免死锁、检测死锁、解除死锁 </p><p>解决四多的常用策略如下： </p><p>鸵鸟策略、预防策略、避免策略、检测与解除死锁<br>如果你对死锁的处理策略不是太熟悉，推荐阅读：<a href="https://blog.csdn.net/bxyill/article/details/8237339" target="_blank" rel="noopener">产生死锁的原因和必要条件+解决死锁的基本方法</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统基础概念I&quot;&gt;&lt;a href=&quot;#操作系统基础概念I&quot; class=&quot;headerlink&quot; title=&quot;操作系统基础概念I&quot;&gt;&lt;/a&gt;操作系统基础概念I&lt;/h1&gt;&lt;p&gt;总结操作系统基础概念&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Operating System" scheme="http://yoursite.com/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>688. Knight Probability in Chessboard“马”在棋盘上的概率</title>
    <link href="http://yoursite.com/2018/08/27/688.%20Knight%20Probability%20in%20Chessboard%E2%80%9C%E9%A9%AC%E2%80%9D%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87/"/>
    <id>http://yoursite.com/2018/08/27/688. Knight Probability in Chessboard“马”在棋盘上的概率/</id>
    <published>2018-08-27T10:48:10.000Z</published>
    <updated>2018-08-27T13:03:04.729Z</updated>
    
    <content type="html"><![CDATA[<h1 id="688-Knight-Probability-in-Chessboard“马”在棋盘上的概率"><a href="#688-Knight-Probability-in-Chessboard“马”在棋盘上的概率" class="headerlink" title="688. Knight Probability in Chessboard“马”在棋盘上的概率"></a>688. Knight Probability in Chessboard“马”在棋盘上的概率</h1><p> 已知一个 NxN 的国际象棋棋盘，棋盘的行号和列号都是从0开始。即最左上角的格子记为 (0, 0), 最右下角的记为 (N-1, N-1)。 </p><p>现有一个“马”（也译作“骑士”）位于 (r, c) ，并打算进行 K 次移动。 </p><a id="more"></a><p>如下图所示，国际象棋的“马”每一步先沿水平或垂直方向移动2个格子，然后向与之相垂直的方向再移动1个格子，共有8个可选的位置。</p><p><img src="http://ww1.sinaimg.cn/large/0071ouepgy1fuogeyhztfj30ba0baq32.jpg" alt="image"></p><p>现在“马”每一步都从可选的位置（包括棋盘外部的）中独立随机地选择一个进行移动，直到移动了 K 次或跳到了棋盘外面。</p><p>求移动结束后，“马”仍留在棋盘上的概率。</p><p>例:</p><p>输入: </p><pre><code>3, 2, 0, 0</code></pre><p>输出: 0.0625<br>解释:<br>输入的数据依次为 N, K, r, c<br>第1步时，有且只有2种走法令“马”可以留在棋盘上(跳到(1,2)或(2,1))。对于以上的两种情况，各自在第2步均有且只有2种走法令“马”仍然留在棋盘上。<br>所以“马”在结束后仍在棋盘上的概率为0.0625。<br>注意:</p><p>N 的取值范围为 [1, 25]<br>K 的取值范围为 [0, 100]<br>开始时，“马”总是位于棋盘上</p><h2 id="解法：动态规划"><a href="#解法：动态规划" class="headerlink" title="解法：动态规划"></a>解法：动态规划</h2><p>令f[r][c][steps]成为在第steps步后落在区域(r,c)的概率，递推式如下：</p><pre><code>\$\$ f[r][c][steps]=∑_​{dr,dc​​} f[r+dr][c+dc][steps−1]/8.0 \$\$  </code></pre><p>(dr,dc)包括八个可能（2,1), (2, -1),(2,−1), (-2, 1),(−2,1), (-2, -1),(−2,−1), (1, 2),(1,2), (1, -2),(1,−2), (-1, 2),(−1,2), (-1, -2)(−1,−2)</p><p>为了不使用三维数组f，我们会使用两个二维dp,dp2，存储最近使用的两层，其中dp2会代表f[][][steps],dp会代表f[][][steps-1]</p><p>时间复杂度：<br>O(KN^​2)<br>空间复杂度：<br>O(N^​2)</p><pre><code>class Solution {    public double knightProbability(int N, int K, int sr, int sc) {        double[][] dp = new double[N][N];        int[] dr = new int[]{2, 2, 1, 1, -1, -1, -2, -2};        int[] dc = new int[]{1, -1, 2, -2, 2, -2, 1, -1};        dp[sr][sc] = 1;        for (; K &gt; 0; K--) {            double[][] dp2 = new double[N][N];            for (int r = 0; r &lt; N; r++) {                for (int c = 0; c &lt; N; c++) {                    for (int k = 0; k &lt; 8; k++) {                        int cr = r + dr[k];                        int cc = c + dc[k];                        if (0 &lt;= cr &amp;&amp; cr &lt; N &amp;&amp; 0 &lt;= cc &amp;&amp; cc &lt; N) {                            dp2[cr][cc] += dp[r][c] / 8.0;                        }                    }                }            }            dp = dp2;        }        double ans = 0.0;        for (double[] row: dp) {            for (double x: row) ans += x;        }        return ans;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;688-Knight-Probability-in-Chessboard“马”在棋盘上的概率&quot;&gt;&lt;a href=&quot;#688-Knight-Probability-in-Chessboard“马”在棋盘上的概率&quot; class=&quot;headerlink&quot; title=&quot;688. Knight Probability in Chessboard“马”在棋盘上的概率&quot;&gt;&lt;/a&gt;688. Knight Probability in Chessboard“马”在棋盘上的概率&lt;/h1&gt;&lt;p&gt; 已知一个 NxN 的国际象棋棋盘，棋盘的行号和列号都是从0开始。即最左上角的格子记为 (0, 0), 最右下角的记为 (N-1, N-1)。 &lt;/p&gt;
&lt;p&gt;现有一个“马”（也译作“骑士”）位于 (r, c) ，并打算进行 K 次移动。 &lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>139. Word Break单词拆分</title>
    <link href="http://yoursite.com/2018/08/26/139.%20Word%20Break%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/"/>
    <id>http://yoursite.com/2018/08/26/139. Word Break单词拆分/</id>
    <published>2018-08-26T12:33:12.000Z</published>
    <updated>2018-08-27T14:08:19.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="139-Word-Break单词拆分"><a href="#139-Word-Break单词拆分" class="headerlink" title="139. Word Break单词拆分"></a>139. Word Break单词拆分</h1><p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p><a id="more"></a><p>说明：</p><p>拆分时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。<br>示例 1：</p><pre><code>输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]输出: true解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</code></pre><p>示例 2：</p><pre><code>输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]输出: true解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。     注意你可以重复使用字典中的单词。</code></pre><p>示例 3：</p><pre><code>输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]输出: false</code></pre><h2 id="思路：动态规划"><a href="#思路：动态规划" class="headerlink" title="思路：动态规划"></a>思路：动态规划</h2><p>使用一个bool型的数组dp,dp[i]被设置为真如果一个有效词在这里终结。优化方法是从当前位置i逆向搜索只要找到dp[j]==true的位置就截取之后的子字符串搜索是否在字典中</p><pre><code>class Solution {public:    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) {        if(s.size()&lt;=0) return false;        vector&lt;bool&gt; dp(s.size()+1,false);        dp[0]=true;        for(int i=1;i&lt;=s.size();i++){            for(int j=i-1;j&gt;=0;j--){                if(dp[j]){                    string word=s.substr(j,i-j);                    if(findword(wordDict,word)){                        dp[i]=true;                        break;//next i                    }                }            }        }        return dp[s.size()];    }    bool findword(vector&lt;string&gt;&amp; wordDict,string word){        for(int i=0;i&lt;wordDict.size();i++){            if(wordDict[i]==word) return true;        }        return false;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;139-Word-Break单词拆分&quot;&gt;&lt;a href=&quot;#139-Word-Break单词拆分&quot; class=&quot;headerlink&quot; title=&quot;139. Word Break单词拆分&quot;&gt;&lt;/a&gt;139. Word Break单词拆分&lt;/h1&gt;&lt;p&gt;给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>626. Exchange Seats换座位</title>
    <link href="http://yoursite.com/2018/08/26/626.%20Exchange%20Seats%E6%8D%A2%E5%BA%A7%E4%BD%8D/"/>
    <id>http://yoursite.com/2018/08/26/626. Exchange Seats换座位/</id>
    <published>2018-08-26T12:33:12.000Z</published>
    <updated>2018-08-26T13:27:54.554Z</updated>
    
    <content type="html"><![CDATA[<h1 id="626-Exchange-Seats换座位"><a href="#626-Exchange-Seats换座位" class="headerlink" title="626. Exchange Seats换座位"></a>626. Exchange Seats换座位</h1><p>小美是一所中学的信息科技老师，她有一张 seat 座位表，平时用来储存学生名字和与他们相对应的座位 id。</p><p>其中纵列的 id 是连续递增的</p><p>小美想改变相邻俩学生的座位。</p><p>你能不能帮她写一个 SQL query 来输出小美想要的结果呢？</p><a id="more"></a><p>示例：</p><pre><code>+---------+---------+|    id   | student |+---------+---------+|    1    | Abbot   ||    2    | Doris   ||    3    | Emerson ||    4    | Green   ||    5    | Jeames  |+---------+---------+</code></pre><p>假如数据输入的是上表，则输出结果如下：</p><pre><code>+---------+---------+|    id   | student |+---------+---------+|    1    | Doris   ||    2    | Abbot   ||    3    | Green   ||    4    | Emerson ||    5    | Jeames  |+---------+---------+</code></pre><p>注意：</p><p>如果学生人数是奇数，则不需要改变最后一个同学的座位。</p><h2 id="思路I：使用流控制语句CASE"><a href="#思路I：使用流控制语句CASE" class="headerlink" title="思路I：使用流控制语句CASE"></a>思路I：使用流控制语句CASE</h2><h3 id="算法："><a href="#算法：" class="headerlink" title="算法："></a>算法：</h3><p>对于奇数ID的学生，交换后新的ID是（ID+1），最后一个座位的学生除外。</p><p>对于偶数ID的学生，新的ID是（ID-1），为了查询ID数量，可以使用查询：</p><pre><code>SELECT    COUNT(*) AS countsFROM    seat</code></pre><p>然后我们可以使用CASE语句和MOD()函数来为每个学生交换座位</p><h3 id="MYSQL"><a href="#MYSQL" class="headerlink" title="MYSQL"></a>MYSQL</h3><pre><code>SELECT    (CASE        WHEN MOD(id,2) != 0 AND counts !=id THEN id+1        WHEN MOD(id,2) !=0 AND counts =id THEN id        ELSE id-1    END) AS id,    studentFROM    seat,    (SELECT COUNT(*) AS counts    FROM        seat) AS seat_countsORDER BY id ASC;</code></pre><h2 id="思路II：使用位运算和COALESCE"><a href="#思路II：使用位运算和COALESCE" class="headerlink" title="思路II：使用位运算和COALESCE()"></a>思路II：使用位运算和COALESCE()</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>位运算表达式(id+1)^1-1能够计算交换后的新的id</p><pre><code>SELECT id,(id+1)^1-1, student FROM seat;| id | (id+1)^1-1 | student ||----|------------|---------|| 1  | 2          | Abbot   || 2  | 1          | Doris   || 3  | 4          | Emerson || 4  | 3          | Green   || 5  | 6          | Jeames  |</code></pre><p>然后我们能够用一个临时的表将座位填入</p><pre><code>SELECT    *FROM    seat s1        LEFT JOIN    seat s2 ON (s1.id+1)^1-1 = s2.idORDER BY s1.id;| id | student | id | student ||----|---------|----|---------|| 1  | Abbot   | 2  | Doris   || 2  | Doris   | 1  | Abbot   || 3  | Emerson | 4  | Green   || 4  | Green   | 3  | Emerson || 5  | Jeames  |    |         |</code></pre><p>前两列来自s1后两列来自s2</p><p>最后我们可以输出s1.id 和 s2.student。可是s2.student时空的当id为末尾时，因此我们可以使用函数COALESCE()来生成最后一个记录的正确输出</p><h3 id="MYSQL-1"><a href="#MYSQL-1" class="headerlink" title="MYSQL"></a>MYSQL</h3><pre><code>SELECT    s1.id, COALESCE(s2.student,s1.student) AS studentFROM    seat s1        LEFT JOIN    seat s2 ON ((S1.id+1)^1)-1= s2.idORDER BY s1.id;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;626-Exchange-Seats换座位&quot;&gt;&lt;a href=&quot;#626-Exchange-Seats换座位&quot; class=&quot;headerlink&quot; title=&quot;626. Exchange Seats换座位&quot;&gt;&lt;/a&gt;626. Exchange Seats换座位&lt;/h1&gt;&lt;p&gt;小美是一所中学的信息科技老师，她有一张 seat 座位表，平时用来储存学生名字和与他们相对应的座位 id。&lt;/p&gt;
&lt;p&gt;其中纵列的 id 是连续递增的&lt;/p&gt;
&lt;p&gt;小美想改变相邻俩学生的座位。&lt;/p&gt;
&lt;p&gt;你能不能帮她写一个 SQL query 来输出小美想要的结果呢？&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="SQL" scheme="http://yoursite.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Kickstart-Round-E-2018-ProblemA.Yogurt</title>
    <link href="http://yoursite.com/2018/08/26/Kickstart-Round-E-2018-ProblemA.Yogurt/"/>
    <id>http://yoursite.com/2018/08/26/Kickstart-Round-E-2018-ProblemA.Yogurt/</id>
    <published>2018-08-26T07:07:00.000Z</published>
    <updated>2018-08-26T12:07:12.750Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kickstart-Round-E-2018-ProblemA-Yogurt"><a href="#Kickstart-Round-E-2018-ProblemA-Yogurt" class="headerlink" title="Kickstart-Round-E-2018-ProblemA.Yogurt"></a>Kickstart-Round-E-2018-ProblemA.Yogurt</h1><p>酸奶可以作为开胃菜、主菜或甜点的营养成分，但它必须在过期前食用，而且可能很快过期!此外，不同的酸奶会在不同的日子过期。露西很喜欢酸奶，她刚买了N杯酸奶，但她担心自己可能无法在酸奶过期前全部喝完。从今天开始，第i杯酸奶会过期，在过期当天或之后的任何一天都不能喝。虽然露西很喜欢酸奶，但她每天最多只能喝K杯酸奶。从今天开始，她最多能喝多少杯酸奶?</p><a id="more"></a><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>Problem<br>Yogurt can be a nutritious part of an appetizer, main course, or dessert, but it must be consumed before it expires, and it might expire quickly! Moreover, different cups of yogurt might expire on different days.</p><p>Lucy loves yogurt, and she has just bought N cups of yogurt, but she is worried that she might not be able to consume all of them before they expire. The i-th cup of yogurt will expire Ai days from today, and a cup of yogurt cannot be consumed on the day it expires, or on any day after that.</p><p>As much as Lucy loves yogurt, she can still only consume at most K cups of yogurt each day. What is the largest number of cups of yogurt that she can consume, starting from today?</p><p>Input<br>The first line of the input gives the number of test cases, T. T test cases follow. Each test case starts with one line containing two integers N and K, as described above. Then, there is one more line with N integers Ai, as described above.</p><p>Output<br>For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the maximum number of cups of yogurt that Lucy can consume, as described above.</p><p>Limits<br>1 ≤ T ≤ 100.<br>1 ≤ K ≤ N.<br>1 ≤ Ai ≤ 109, for all i.<br>Small dataset<br>1 ≤ N ≤ 1000.<br>K = 1.<br>Large dataset<br>1 ≤ N ≤ 5000.<br>Sample</p><p>Input </p><p>Output </p><pre><code>42 11 15 13 2 3 2 32 21 16 21 1 1 7 7 7Case #1: 1Case #2: 3Case #3: 2Case #4: 5</code></pre><p>Note that the last two sample cases would not appear in the Small dataset.</p><p>In Sample Case #1, each of the two cups of yogurt will expire in one day. Today, Lucy can consume one of them, but she can only consume at most one cup each day, so she cannot consume both. Tomorrow, Lucy cannot consume the remaining cup of yogurt, because it will have expired.</p><p>In Sample Case #3, Lucy can consume up to two cups each day, so she can consume all of the yogurt.</p><h2 id="思路1（Brute-force"><a href="#思路1（Brute-force" class="headerlink" title="思路1（Brute force)"></a>思路1（Brute force)</h2><p>模拟每天发生的过程，先将输入的保质期数组A排序，将最大的保质期天数定义为maxday，然后从今天到maxday进行循环，每天更新最多能喝的杯数和当前的保质期数组。<br>这里在比赛过程中犯了两个错误，见代码注释</p><pre><code>#include &lt;iostream&gt;#include&lt;unordered_map&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#include&lt;set&gt;using namespace std;void solve() {// brute force TLE    int N = 0, K = 0;    cin &gt;&gt; N &gt;&gt; K;    vector&lt;int&gt; a;     for (int i = 0; i &lt; N; i++) {    int temp;    cin &gt;&gt; temp;     a.push_back(temp);    }    sort(a.begin(), a.end());      /*  cout &lt;&lt; &quot;a[N-1]=&quot; &lt;&lt; a[N - 1] &lt;&lt; &quot;  &quot;;     cout &lt;&lt; &quot;After sort:   &quot;; output(a);*/    int num = 0;    int maxday = a[N - 1];    for (int i = 0; i &lt; maxday; i++) {//error i &lt; a[N - 1] 因为a[N-1]会动态变化       // cout &lt;&lt; &quot;i=&quot; &lt;&lt; i &lt;&lt; &quot;  &quot;;    int k = 0;    for (int j = 0; j &lt; N ; j++) {    //cout &lt;&lt; &quot;j=&quot; &lt;&lt; j &lt;&lt; endl;    if ((a[j] &gt; 0)&amp;&amp;(k&lt;K)) {//error (k&lt;K)条件要放到这个if里而不能放到for循环中    a[j] = 0;    k++;    num++;        }    }   // cout &lt;&lt; &quot;  num=&quot; &lt;&lt; num&lt;&lt;&quot;  &quot;; output(a);    for (int mm = 0; mm &lt; N; mm++) { a[mm] -= 1; }    }    cout &lt;&lt; num &lt;&lt; endl;}int main() {    freopen(&quot;C:\\Users\\yiye\\Downloads\\A-small-attempt0.in&quot;, &quot;r&quot;, stdin);    //freopen(&quot;C:\\Users\\yiye\\Downloads\\out.txt&quot;, &quot;w&quot;, stdout);    int T;    scanf(&quot;%d&quot;, &amp;T);    for (int i = 1; i &lt;= T; i++) {         printf(&quot;Case #%d: &quot;, i);         solve();    }        //===========================        //fclose(stdin);//关闭文件         //fclose(stdout);//关闭文件         return 0;}</code></pre><h2 id="思路2（Brute-force-改进版本"><a href="#思路2（Brute-force-改进版本" class="headerlink" title="思路2（Brute force)改进版本"></a>思路2（Brute force)改进版本</h2><p>在每天的模拟过程中用lower_bound找到第一个非零的位置，然后将改天中连续K个杯子状态置为已喝，这样可以将时间复杂度从O(n*n)变为O(nlog(n))</p><pre><code>#include &lt;iostream&gt;#include&lt;unordered_map&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;stack&gt; #include &lt;functional&gt; #include&lt;set&gt;using namespace std;void solve() {// brute force TLE    int N = 0, K = 0;    cin &gt;&gt; N &gt;&gt; K;    vector&lt;int&gt; a;    for (int i = 0; i &lt; N; i++) {        int temp;        cin &gt;&gt; temp;        a.push_back(temp);    }    sort(a.begin(), a.end());    int num = 0;        int maxday = a[N - 1];        for (int i = 0; i &lt; maxday; i++) {//error i &lt; a[N - 1] 因为a[N-1]会动态变化            //cout &lt;&lt; &quot;i=&quot; &lt;&lt; i &lt;&lt; &quot;  &quot;;                int k = 0;            vector&lt;int&gt;::iterator nonezeroindex = lower_bound(a.begin(), a.end(), 1);            for (int j = nonezeroindex-a.begin(); j &lt;nonezeroindex - a.begin()+ K &amp;&amp; j&lt;N ; j++) {                a[j] = 0;                num++;                        }            //cout &lt;&lt; &quot;  nonezeroindex=&quot;&lt;&lt;(nonezeroindex-a.begin())&lt;&lt;&quot;  num=&quot; &lt;&lt; num&lt;&lt;&quot;  &quot;; output(a);            for (int mm = nonezeroindex - a.begin(); mm &lt; N; mm++) { a[mm] -= 1; }        }    cout &lt;&lt; num &lt;&lt; endl;}int main() {    //freopen(&quot;C:\\Users\\yiye\\Downloads\\A-small-attempt0.in&quot;, &quot;r&quot;, stdin);    //freopen(&quot;C:\\Users\\yiye\\Downloads\\out.txt&quot;, &quot;w&quot;, stdout);    freopen(&quot;out.txt&quot;, &quot;r&quot;, stdin);    int T;    scanf(&quot;%d&quot;, &amp;T);    for (int i = 1; i &lt;= T; i++) {        printf(&quot;Case #%d: &quot;, i);        solve();    }        //===========================        //fclose(stdin);//关闭文件         //fclose(stdout);//关闭文件         return 0;    } </code></pre><h2 id="思路3："><a href="#思路3：" class="headerlink" title="思路3："></a>思路3：</h2><p>这是E轮中第一名选手ijn的解法，核心代码用五行实现了我十行的功能，浓缩的都是精华啊</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int t,n,m,a[5005],i,j,k,ans;int main(){    freopen(&quot;a.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;a.out&quot;,&quot;w&quot;,stdout);    scanf(&quot;%d&quot;,&amp;t);    for(int xxx=1;xxx&lt;=t;xxx++)    {        printf(&quot;Case #%d: &quot;,xxx);        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);//m为K        for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,a+i);        sort(a+1,a+n+1);        for(i=k=1,ans=0;i&lt;=n;k++)        {            j=min(i+m,n+1);            ans+=j-i;            i=j;            for(;i&lt;=n&amp;&amp;a[i]&lt;=k;i++);        }        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre><p>将其    改写成易于理解的形式    </p><pre><code>void solve() {    int N, K;    cin &gt;&gt; N &gt;&gt; K;    vector&lt;int&gt; a(N+1,0);    for (int i = 1; i &lt;= N; i++) cin &gt;&gt; a[i];    sort(a.begin(), a.end());//实现排序功能    int  num=0;    for (int k = 1, i = 1; i &lt;= N; k++) {//对数组进行遍历，ans为最多能喝的杯数，k为已经过去的天数        int j = min(i + K, N + 1);//寻找可以喝的酸奶序列的终点        num += j - i;//更新        i = j;        for (; i &lt;= N &amp;&amp; a[i] &lt;= k; i++);//跳过过期的杯子    }    cout &lt;&lt; num &lt;&lt; endl;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Kickstart-Round-E-2018-ProblemA-Yogurt&quot;&gt;&lt;a href=&quot;#Kickstart-Round-E-2018-ProblemA-Yogurt&quot; class=&quot;headerlink&quot; title=&quot;Kickstart-Round-E-2018-ProblemA.Yogurt&quot;&gt;&lt;/a&gt;Kickstart-Round-E-2018-ProblemA.Yogurt&lt;/h1&gt;&lt;p&gt;酸奶可以作为开胃菜、主菜或甜点的营养成分，但它必须在过期前食用，而且可能很快过期!此外，不同的酸奶会在不同的日子过期。露西很喜欢酸奶，她刚买了N杯酸奶，但她担心自己可能无法在酸奶过期前全部喝完。从今天开始，第i杯酸奶会过期，在过期当天或之后的任何一天都不能喝。虽然露西很喜欢酸奶，但她每天最多只能喝K杯酸奶。从今天开始，她最多能喝多少杯酸奶?&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="Kickstart" scheme="http://yoursite.com/tags/Kickstart/"/>
    
      <category term="Google" scheme="http://yoursite.com/tags/Google/"/>
    
  </entry>
  
  <entry>
    <title>865. Smallest Subtree with all the Deepest Nodes具有所有最深结点的最小子树</title>
    <link href="http://yoursite.com/2018/08/24/865.%20Smallest%20Subtree%20with%20all%20the%20Deepest%20Nodes%E5%85%B7%E6%9C%89%E6%89%80%E6%9C%89%E6%9C%80%E6%B7%B1%E7%BB%93%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E6%A0%91/"/>
    <id>http://yoursite.com/2018/08/24/865. Smallest Subtree with all the Deepest Nodes具有所有最深结点的最小子树/</id>
    <published>2018-08-24T13:06:12.000Z</published>
    <updated>2018-08-24T15:00:41.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="865-Smallest-Subtree-with-all-the-Deepest-Nodes具有所有最深结点的最小子树"><a href="#865-Smallest-Subtree-with-all-the-Deepest-Nodes具有所有最深结点的最小子树" class="headerlink" title="865. Smallest Subtree with all the Deepest Nodes具有所有最深结点的最小子树"></a>865. Smallest Subtree with all the Deepest Nodes具有所有最深结点的最小子树</h1><p>给定一个根为 root 的二叉树，每个结点的深度是它到根的最短距离。</p><p>如果一个结点在整个树的任意结点之间具有最大的深度，则该结点是最深的。</p><p>一个结点的子树是该结点加上它的所有后代的集合。</p><p>返回能满足“以该结点为根的子树中包含所有最深的结点”这一条件的具有最大深度的结点。</p><a id="more"></a><p>示例：</p><p>输入：</p><pre><code>[3,5,1,6,2,0,8,null,null,7,4]</code></pre><p>输出：</p><pre><code>[2,7,4]</code></pre><p><img src="https://ws1.sinaimg.cn/large/0071ouepgy1ful3h7lug7j30k20h2t9l.jpg" alt="image"></p><p>解释：</p><p>我们返回值为 2 的结点，在图中用黄色标记。<br>在图中用蓝色标记的是树的最深的结点。<br>输入 “[3, 5, 1, 6, 2, 0, 8, null, null, 7, 4]” 是对给定的树的序列化表述。<br>输出 “[2, 7, 4]” 是对根结点的值为 2 的子树的序列化表述。<br>输入和输出都具有 TreeNode 类型。</p><p>提示：</p><p>树中结点的数量介于 1 和 500 之间。<br>每个结点的值都是独一无二的。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>写一个子函数 deep(TreeNode root)<br>返回一个 pair(int depth, TreeNode subtreeWithAllDeepest)</p><p>在子函数中：<br>若是结点为空，返回pair(0,null)<br>left=deep(root-&gt;left)<br>right=deep(root-&gt;right)</p><p>如果left depth== right depth<br>有最深的结点同时存在于左右子树中<br>返回pair(left.depth+1,root)</p><p>如果left depth &gt; right depth<br>只有左子树中存在最深结点<br>返回pair(left.depth+1,left subtree)</p><p>如果left depth &lt; right depth<br>只有右子树中存在最深结点<br>返回pair(right.depth+1, right subtree)</p><pre><code>TreeNode* subtreeWithAllDeepest(TreeNode* root) {    return deep(root).second;}pair&lt;int, TreeNode*&gt; deep(TreeNode* root) {    if (!root) return {0, NULL};    pair&lt;int, TreeNode*&gt; l = deep(root-&gt;left), r = deep(root-&gt;right);    int d1 = l.first, d2 = r.first;    return {max(d1, d2) + 1, d1 == d2 ? root : d1 &gt; d2 ? l.second : r.second};}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;865-Smallest-Subtree-with-all-the-Deepest-Nodes具有所有最深结点的最小子树&quot;&gt;&lt;a href=&quot;#865-Smallest-Subtree-with-all-the-Deepest-Nodes具有所有最深结点的最小子树&quot; class=&quot;headerlink&quot; title=&quot;865. Smallest Subtree with all the Deepest Nodes具有所有最深结点的最小子树&quot;&gt;&lt;/a&gt;865. Smallest Subtree with all the Deepest Nodes具有所有最深结点的最小子树&lt;/h1&gt;&lt;p&gt;给定一个根为 root 的二叉树，每个结点的深度是它到根的最短距离。&lt;/p&gt;
&lt;p&gt;如果一个结点在整个树的任意结点之间具有最大的深度，则该结点是最深的。&lt;/p&gt;
&lt;p&gt;一个结点的子树是该结点加上它的所有后代的集合。&lt;/p&gt;
&lt;p&gt;返回能满足“以该结点为根的子树中包含所有最深的结点”这一条件的具有最大深度的结点。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>485. Max Consecutive Ones最大连续1的个数</title>
    <link href="http://yoursite.com/2018/08/24/485.%20Max%20Consecutive%20Ones/"/>
    <id>http://yoursite.com/2018/08/24/485. Max Consecutive Ones/</id>
    <published>2018-08-24T05:36:12.000Z</published>
    <updated>2018-08-24T07:05:48.492Z</updated>
    
    <content type="html"><![CDATA[<h1 id="485-Max-Consecutive-Ones最大连续1的个数"><a href="#485-Max-Consecutive-Ones最大连续1的个数" class="headerlink" title="485. Max Consecutive Ones最大连续1的个数"></a>485. Max Consecutive Ones最大连续1的个数</h1><p>给定一个二进制数组， 计算其中最大连续1的个数。</p><a id="more"></a><p>示例 1:</p><p>输入: </p><pre><code>[1,1,0,1,1,1]</code></pre><p>输出: 3<br>解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3.<br>注意：</p><p>输入的数组只包含 0 和1。<br>输入数组的长度是正整数，且不超过 10,000。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>定义局部最大和全局最大</p><pre><code>class Solution {public:    int findMaxConsecutiveOnes(vector&lt;int&gt;&amp; nums) {        int maxlen=0,locallen=0;        for(auto n:nums){            if((n&amp;1)==0) locallen=0;            else {                locallen++;                maxlen=max(maxlen,locallen);            }        }        return maxlen;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;485-Max-Consecutive-Ones最大连续1的个数&quot;&gt;&lt;a href=&quot;#485-Max-Consecutive-Ones最大连续1的个数&quot; class=&quot;headerlink&quot; title=&quot;485. Max Consecutive Ones最大连续1的个数&quot;&gt;&lt;/a&gt;485. Max Consecutive Ones最大连续1的个数&lt;/h1&gt;&lt;p&gt;给定一个二进制数组， 计算其中最大连续1的个数。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>697. Degree of an Array数组的度</title>
    <link href="http://yoursite.com/2018/08/24/697.%20Degree%20of%20an%20Array%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%A6/"/>
    <id>http://yoursite.com/2018/08/24/697. Degree of an Array数组的度/</id>
    <published>2018-08-24T05:36:12.000Z</published>
    <updated>2018-08-24T07:05:54.170Z</updated>
    
    <content type="html"><![CDATA[<h1 id="697-Degree-of-an-Array数组的度"><a href="#697-Degree-of-an-Array数组的度" class="headerlink" title="697. Degree of an Array数组的度"></a>697. Degree of an Array数组的度</h1><p>给定一个非空且只包含非负数的整数数组 nums, 数组的度的定义是指数组里任一元素出现频数的最大值。</p><p>你的任务是找到与 nums 拥有相同大小的度的最短连续子数组，返回其长度。</p><a id="more"></a><p>示例 1:</p><p>输入: </p><pre><code>[1, 2, 2, 3, 1]</code></pre><p>输出: 2<br>解释:<br>输入数组的度是2，因为元素1和2的出现频数最大，均为2.<br>连续子数组里面拥有相同度的有如下所示:</p><pre><code>[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]</code></pre><p>最短连续子数组[2, 2]的长度为2，所以返回2.<br>示例 2:</p><p>输入: </p><pre><code>[1,2,2,3,1,4,2]</code></pre><p>输出: 6<br>注意:</p><p>nums.length 在1到50,000区间范围内。<br>nums[i] 是一个在0到49,999范围内的整数。</p><!-- more --><h2 id="Brute-Force思路"><a href="#Brute-Force思路" class="headerlink" title="Brute Force思路"></a>Brute Force思路</h2><p>穷举所有的子数组然后将其度与原数组的度比较，相等则更新最小长度。但会超时。</p><pre><code>class Solution {public:    int findShortestSubArray(vector&lt;int&gt;&amp; nums) {        int minlen=nums.size();        int degree=getdegree(nums,0,nums.size()-1);        for(int i=0;i&lt;nums.size();i++){            for(int j=i+1;j&lt;nums.size();j++){                if(getdegree(nums,i,j)==degree) minlen=min(minlen,j-i+1);            }        }        return minlen;    }    int getdegree(vector&lt;int&gt;&amp; arr,int begin,int end){        int degree=0;        unordered_map&lt;int,int&gt; fre;        for(int i=begin;i&lt;=end;i++){            fre[arr[i]]++;        }        for(auto d:fre){            degree=max(degree,d.second);        }        return degree;    }};</code></pre><h2 id="O-n-解法"><a href="#O-n-解法" class="headerlink" title="O(n)解法"></a>O(n)解法</h2><p>使用两个哈希表，一个记录字符的开始位置，另一个记录字符的出现频率<br>一旦一个特定字符的频率大于其他的，我们更新这个变量的长度，当两个变量有同样的频率，只比较它们的长度选择较短的一个</p><pre><code>class Solution {public:    int findShortestSubArray(vector&lt;int&gt;&amp; nums) {        unordered_map&lt;int,int&gt; startindex,frequency;        int fre=0,len=nums.size();        for(int i=0;i&lt;nums.size();i++){            frequency[nums[i]]++;            if(startindex.count(nums[i])==0) startindex[nums[i]]=i;//first appear            if(frequency[nums[i]]==fre){//第i个字符的度与截止到当前的数组度相同                len=min(len,i-startindex[nums[i]]+1);            }            else if(frequency[nums[i]]&gt;fre){//需要更新度和长度                fre=frequency[nums[i]];                len=i-startindex[nums[i]]+1;            }        }        return len;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;697-Degree-of-an-Array数组的度&quot;&gt;&lt;a href=&quot;#697-Degree-of-an-Array数组的度&quot; class=&quot;headerlink&quot; title=&quot;697. Degree of an Array数组的度&quot;&gt;&lt;/a&gt;697. Degree of an Array数组的度&lt;/h1&gt;&lt;p&gt;给定一个非空且只包含非负数的整数数组 nums, 数组的度的定义是指数组里任一元素出现频数的最大值。&lt;/p&gt;
&lt;p&gt;你的任务是找到与 nums 拥有相同大小的度的最短连续子数组，返回其长度。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>538. Convert BST to Greater Tree把二叉搜索树转换为累加树</title>
    <link href="http://yoursite.com/2018/08/24/538.%20Convert%20BST%20to%20Greater%20Tree%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/"/>
    <id>http://yoursite.com/2018/08/24/538. Convert BST to Greater Tree把二叉搜索树转换为累加树/</id>
    <published>2018-08-24T05:36:12.000Z</published>
    <updated>2018-08-24T13:02:28.972Z</updated>
    
    <content type="html"><![CDATA[<h1 id="538-Convert-BST-to-Greater-Tree把二叉搜索树转换为累加树"><a href="#538-Convert-BST-to-Greater-Tree把二叉搜索树转换为累加树" class="headerlink" title="538. Convert BST to Greater Tree把二叉搜索树转换为累加树"></a>538. Convert BST to Greater Tree把二叉搜索树转换为累加树</h1><p>给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。</p><a id="more"></a><p>例如：</p><p>输入: 二叉搜索树:<br>              5<br>            /   \<br>           2     13</p><p>输出: 转换为累加树:<br>             18<br>            /   \<br>          20     13</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>二叉搜索树有一个重要的性质，就是中序遍历序列是非递减的<br>解法是一种中序遍历的镜像遍历方法，先用遍历右子树，再改变根节点的值,将其改为所有右子树结点之和，遍历左子树</p><pre><code>class Solution {private:    int cur_sum = 0;public:    void travel(TreeNode* root){        if (!root) return;        if (root-&gt;right) travel(root-&gt;right);        root-&gt;val = (cur_sum += root-&gt;val);        if (root-&gt;left) travel(root-&gt;left);    }    TreeNode* convertBST(TreeNode* root) {        travel(root);        return root;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;538-Convert-BST-to-Greater-Tree把二叉搜索树转换为累加树&quot;&gt;&lt;a href=&quot;#538-Convert-BST-to-Greater-Tree把二叉搜索树转换为累加树&quot; class=&quot;headerlink&quot; title=&quot;538. Convert BST to Greater Tree把二叉搜索树转换为累加树&quot;&gt;&lt;/a&gt;538. Convert BST to Greater Tree把二叉搜索树转换为累加树&lt;/h1&gt;&lt;p&gt;给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Binary Search Tree" scheme="http://yoursite.com/tags/Binary-Search-Tree/"/>
    
  </entry>
  
  <entry>
    <title>885. Spiral Matrix III螺旋矩阵 III</title>
    <link href="http://yoursite.com/2018/08/24/885.%20Spiral%20Matrix%20III/"/>
    <id>http://yoursite.com/2018/08/24/885. Spiral Matrix III/</id>
    <published>2018-08-24T02:32:12.000Z</published>
    <updated>2018-08-24T12:53:30.507Z</updated>
    
    <content type="html"><![CDATA[<h1 id="885-Spiral-Matrix-III螺旋矩阵-III"><a href="#885-Spiral-Matrix-III螺旋矩阵-III" class="headerlink" title="885. Spiral Matrix III螺旋矩阵 III"></a>885. Spiral Matrix III螺旋矩阵 III</h1><p>在 R 行 C 列的矩阵上，我们从 (r0, c0) 面朝东面开始</p><p>这里，网格的西北角位于第一行第一列，网格的东南角位于最后一行最后一列。</p><p>现在，我们以顺时针按螺旋状行走，访问此网格中的每个位置。</p><p>每当我们移动到网格的边界之外时，我们会继续在网格之外行走（但稍后可能会返回到网格边界）。</p><p>最终，我们到过网格的所有 R * C 个空间。</p><p>按照访问顺序返回表示网格位置的坐标列表。</p><a id="more"></a><p>示例 1：</p><pre><code>输入：R = 1, C = 4, r0 = 0, c0 = 0输出：[[0,0],[0,1],[0,2],[0,3]]</code></pre><p><img src="https://ws1.sinaimg.cn/large/0071ouepgy1ful2oluezbj304u02rglf.jpg" alt="image"></p><p>示例 2：</p><pre><code>输入：R = 5, C = 6, r0 = 1, c0 = 4输出：[[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]</code></pre><p><img src="https://ws1.sinaimg.cn/large/0071ouepgy1ful2oluezbj304u02rglf.jpg" alt="image"></p><p>提示：</p><p>1 &lt;= R &lt;= 100<br>1 &lt;= C &lt;= 100<br>0 &lt;= r0 &lt; R<br>0 &lt;= c0 &lt; C</p><h2 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h2><p>分步走，如果位置在格子内则将它加入res</p><p>观察运动轨迹：<br>右移一步，向右转<br>下移一步，向右转</p><p>左移两步，向右转<br>上移两步，向右转</p><p>右移三步，向右转<br>下移三步，向右转</p><p>左移四步，向右转<br>上移四步，向右转</p><p>所以问题变为如何生成序列：1，1，2，2，3，3，4，4，5，5…<br>和如何向右转</p><p>生成序列：<br>a[index]=index/2+1</p><p>右转：<br>使用叉乘假设当前的方向在平面中是（x,y),在空间中则为(x,y,0)<br>那么右转后的方向是(x,y,0)X(0,0,1)=(y,-x,0)<br>变成代码：temp=x;x=y;y=-temp;</p><p>方向数组是：<br>(0,1),(1,0),(0,-1),(-1,0)，可以用两个变量来表示</p><p>时间复杂度：<br>O(max(M,N) ^ 2)</p><pre><code>vector&lt;vector&lt;int&gt;&gt; spiralMatrixIII(int R, int C, int r, int c) {    vector&lt;vector&lt;int&gt;&gt; res = {{r, c}};    int x = 0, y = 1, tmp;    for (int n = 0; res.size() &lt; R * C; n++) {//every position        for (int i = 0; i &lt; n / 2 + 1; i++) {//on one direction            r += x, c += y;            if (0 &lt;= r &amp;&amp; r &lt; R &amp;&amp; 0 &lt;= c &amp;&amp; c &lt; C)                res.push_back({r, c});        }        tmp = x, x = y, y = -tmp;    }    return res;}</code></pre><h2 id="思路2："><a href="#思路2：" class="headerlink" title="思路2："></a>思路2：</h2><pre><code>class Solution {public:    vector&lt;vector&lt;int&gt;&gt; spiralMatrixIII(int R, int C, int r0, int c0) {        int rpos=r0,cpos=c0,dir=0,go=1;//dir is the direction in the dr[4] and dc[4]        int distan=0,total=0;        int dr[4]={0,1,0,-1};        int dc[4]={1,0,-1,0};        vector&lt;vector&lt;int&gt;&gt; res;        res.push_back({rpos,cpos});//push back the start position        total++;        while(total&lt;R*C){//total is the total visit numbers            for(int i=1;i&lt;=go;i++){                rpos+=dr[dir];//start to go                cpos+=dc[dir];                if(rpos&gt;=0 &amp;&amp; rpos&lt;R &amp;&amp; cpos&gt;=0 &amp;&amp; cpos&lt;C){// push back the eanswer if it is in the grid                    res.push_back({rpos,cpos});                    total++;                }            }            if(distan &amp;1){//每隔两次访问步数加1，即恰好为奇数时访问步数加1                go++;            }            distan++;            dir++;            dir%=4;//change direction        }        return res;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;885-Spiral-Matrix-III螺旋矩阵-III&quot;&gt;&lt;a href=&quot;#885-Spiral-Matrix-III螺旋矩阵-III&quot; class=&quot;headerlink&quot; title=&quot;885. Spiral Matrix III螺旋矩阵 III&quot;&gt;&lt;/a&gt;885. Spiral Matrix III螺旋矩阵 III&lt;/h1&gt;&lt;p&gt;在 R 行 C 列的矩阵上，我们从 (r0, c0) 面朝东面开始&lt;/p&gt;
&lt;p&gt;这里，网格的西北角位于第一行第一列，网格的东南角位于最后一行最后一列。&lt;/p&gt;
&lt;p&gt;现在，我们以顺时针按螺旋状行走，访问此网格中的每个位置。&lt;/p&gt;
&lt;p&gt;每当我们移动到网格的边界之外时，我们会继续在网格之外行走（但稍后可能会返回到网格边界）。&lt;/p&gt;
&lt;p&gt;最终，我们到过网格的所有 R * C 个空间。&lt;/p&gt;
&lt;p&gt;按照访问顺序返回表示网格位置的坐标列表。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络概念I</title>
    <link href="http://yoursite.com/2018/08/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5I/"/>
    <id>http://yoursite.com/2018/08/24/计算机网络概念I/</id>
    <published>2018-08-24T02:08:12.000Z</published>
    <updated>2018-08-30T01:13:43.795Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络概念I"><a href="#计算机网络概念I" class="headerlink" title="计算机网络概念I"></a>计算机网络概念I</h1><p>总结计算机网络概念</p><a id="more"></a><h2 id="（一）请简述TCP-UDP的区别"><a href="#（一）请简述TCP-UDP的区别" class="headerlink" title="（一）请简述TCP\UDP的区别"></a>（一）请简述TCP\UDP的区别</h2><p>TCP和UDP是OSI模型中的运输层中的协议。TCP提供可靠的通信传输，而UDP则常被用于让广播和细节控制交给应用的通信传输。</p><p>两者的区别大致如下：</p><p>TCP面向连接，UDP面向非连接即发送数据前不需要建立链接<br>TCP提供可靠的服务（数据传输），UDP无法保证<br>TCP面向字节流，UDP面向报文<br>TCP数据传输慢，UDP数据传输快<br>如果还不是太了解这两者的区别，点击阅读：<a href="https://blog.csdn.net/yipiankongbai/article/details/24435977" target="_blank" rel="noopener">TCP与UDP的区别</a></p><h2 id="（二）请简单说一下你了解的端口及对应的服务？"><a href="#（二）请简单说一下你了解的端口及对应的服务？" class="headerlink" title="（二）请简单说一下你了解的端口及对应的服务？"></a>（二）请简单说一下你了解的端口及对应的服务？</h2><p><img src="http://ww1.sinaimg.cn/large/0071ouepgy1fuqwow0id9j30cb06gq38.jpg" alt="image"></p><p>了解更多的端口，点击阅读：<a href="http://blog.sina.com.cn/s/blog_66ea0e2801011vb3.html" target="_blank" rel="noopener">常用端口号与对应的服务以及端口关闭</a></p><h2 id="（三）说一说TCP的三次握手"><a href="#（三）说一说TCP的三次握手" class="headerlink" title="（三）说一说TCP的三次握手"></a>（三）说一说TCP的三次握手</h2><p>在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。</p><p>下面详细说一下三次握手（来自简析TCP的三次握手与四次分手）<br><img src="http://ww1.sinaimg.cn/large/0071ouepgy1fuqwq2b646j30k00mb0u1.jpg" alt="image"></p><p><img src="http://ww1.sinaimg.cn/large/0071ouepgy1fuqwrg1lunj30gh07b75e.jpg" alt="image"></p><p>更加深入的了解TCP的三次握手与四次分手：<a href="https://www.jellythink.com/archives/705" target="_blank" rel="noopener">简析TCP的三次握手与四次分手</a></p><h2 id="（四）有哪些私有（保留）地址？"><a href="#（四）有哪些私有（保留）地址？" class="headerlink" title="（四）有哪些私有（保留）地址？"></a>（四）有哪些私有（保留）地址？</h2><p>A类：10.0.0.0 - 10.255.255.255<br>B类：172.16.0.0 - 172.31.255.255<br>C类：192.168.0.0 - 192.168.255.255</p><h2 id="（五）IP地址分为哪几类？简单说一下各个分类"><a href="#（五）IP地址分为哪几类？简单说一下各个分类" class="headerlink" title="（五）IP地址分为哪几类？简单说一下各个分类"></a>（五）IP地址分为哪几类？简单说一下各个分类</h2><p><img src="http://ww1.sinaimg.cn/large/0071ouepgy1fuqwscdo7yj30ix06i0td.jpg" alt="image"><br>IPv6 – 采用128bit，首部固定部分为40字节。</p><h2 id="（六）在浏览器中输入网址之后执行会发生什么？"><a href="#（六）在浏览器中输入网址之后执行会发生什么？" class="headerlink" title="（六）在浏览器中输入网址之后执行会发生什么？"></a>（六）在浏览器中输入网址之后执行会发生什么？</h2><p>查找域名对应的IP地址。这一步会依次查找浏览器缓存，系统缓存，路由器缓存，ISPNDS缓存，根域名服务器<br>浏览器向IP对应的web服务器发送一个HTTP请求<br>服务器响应请求，发回网页内容<br>浏览器解析网页内容</p><p>更加详细的一种说法（以百度为例）（来自计算机网络之面试常考 - 牛客网）<br><img src="http://ww1.sinaimg.cn/large/0071ouepgy1fuqwt38bprj30ga0an40f.jpg" alt="image"></p><p>如果你想要更加深入的了解这个过程，点击阅读：<a href="">从输入网址到显示网页的全过程分析</a></p><h2 id="（七）简单解释一些ARP协议的工作过程"><a href="#（七）简单解释一些ARP协议的工作过程" class="headerlink" title="（七）简单解释一些ARP协议的工作过程"></a>（七）简单解释一些ARP协议的工作过程</h2><p><img src="http://ww1.sinaimg.cn/large/0071ouepgy1fuqwu74fpuj30go0afjt2.jpg" alt="image"></p><p>以上的说明解释来自（思想时光机），如果你想了解：<a href="https://blog.csdn.net/microtong/article/details/3029931" target="_blank" rel="noopener">ARP协议工作原理</a></p><h2 id="（八）说一说OSI七层模型"><a href="#（八）说一说OSI七层模型" class="headerlink" title="（八）说一说OSI七层模型"></a>（八）说一说OSI七层模型</h2><p><img src="http://ww1.sinaimg.cn/large/0071ouepgy1furg8ainkrj30k00scad0.jpg" alt="image"></p><p>了解OSI七层模型，请点击阅读：<a href="https://blog.csdn.net/yaopeng_2005/article/details/7064869" target="_blank" rel="noopener">OSI七层模型详解 （下面的图片来自啊该网址）</a></p><h2 id="（九）说一说TCP-IP四层模型"><a href="#（九）说一说TCP-IP四层模型" class="headerlink" title="（九）说一说TCP/IP四层模型"></a>（九）说一说TCP/IP四层模型</h2><p>如果你不了解，请直接点击阅读：<a href="http://www.cnblogs.com/BlueTzar/articles/811160.html" target="_blank" rel="noopener">TCP/IP四层模型</a></p><h2 id="（十）HTTP-协议包括哪些请求？"><a href="#（十）HTTP-协议包括哪些请求？" class="headerlink" title="（十）HTTP 协议包括哪些请求？"></a>（十）HTTP 协议包括哪些请求？</h2><p>GET：对服务器资源的简单请求<br>POST：用于发送包含用户提交数据的请求<br>————以及————</p><p>HEAD：类似于GET请求，不过返回的响应中没有具体内容，用于获取报头<br>PUT：传说中请求文档的一个版本<br>DELETE：发出一个删除指定文档的请求<br>TRACE：发送一个请求副本，以跟踪其处理进程<br>OPTIONS：返回所有可用的方法，检查服务器支持哪些方法<br>CONNECT：用于ssl隧道的基于代理的请求</p><h2 id="（十一）简述HTTP中GET和POST的区别"><a href="#（十一）简述HTTP中GET和POST的区别" class="headerlink" title="（十一）简述HTTP中GET和POST的区别"></a>（十一）简述HTTP中GET和POST的区别</h2><p>从原理性看：</p><p>根据HTTP规范，GET用于信息获取，而且应该是安全和幂等的<br>根据HTTP规范，POST请求表示可能修改服务器上资源的请求</p><p>从表面上看：</p><p>GET请求的数据会附在URL后面，POST的数据放在HTTP包体<br>POST安全性比GET安全性高</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计算机网络概念I&quot;&gt;&lt;a href=&quot;#计算机网络概念I&quot; class=&quot;headerlink&quot; title=&quot;计算机网络概念I&quot;&gt;&lt;/a&gt;计算机网络概念I&lt;/h1&gt;&lt;p&gt;总结计算机网络概念&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Computer Network" scheme="http://yoursite.com/tags/Computer-Network/"/>
    
  </entry>
  
  <entry>
    <title>数据库基础概念I</title>
    <link href="http://yoursite.com/2018/08/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5I/"/>
    <id>http://yoursite.com/2018/08/24/数据库基础概念I/</id>
    <published>2018-08-24T02:08:12.000Z</published>
    <updated>2018-08-29T12:04:46.477Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库基础概念I"><a href="#数据库基础概念I" class="headerlink" title="数据库基础概念I"></a>数据库基础概念I</h1><p>总结数据库基础概念</p><a id="more"></a><h2 id="（一）什么是存储过程？有哪些优缺点？"><a href="#（一）什么是存储过程？有哪些优缺点？" class="headerlink" title="（一）什么是存储过程？有哪些优缺点？"></a>（一）什么是存储过程？有哪些优缺点？</h2><p>存储过程是一些预编译的SQL语句。</p><p>更加直白的理解：存储过程可以说是一个记录集，它是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。</p><p>存储过程是一个预编译的代码块，执行效率比较高<br>一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率<br>可以一定程度上确保数据安全<br>如果你对存储过程不熟悉，建议阅读：<a href="http://www.cnblogs.com/knowledgesea/archive/2013/01/02/2841588.html" target="_blank" rel="noopener">存储过程详解-博客园</a></p><h2 id="（二）索引是什么？有什么作用以及优缺点？"><a href="#（二）索引是什么？有什么作用以及优缺点？" class="headerlink" title="（二）索引是什么？有什么作用以及优缺点？"></a>（二）索引是什么？有什么作用以及优缺点？</h2><p>索引是对数据库表中一或多个列的值进行排序的结构，是帮助MySQL高效获取数据的数据结构</p><p>你也可以这样理解：索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而不必扫描整个数据库。</p><p>MySQL数据库几个基本的索引类型：普通索引、唯一索引、主键索引、全文索引</p><p>索引加快数据库的检索速度<br>索引降低了插入、删除、修改等维护任务的速度<br>唯一索引可以确保每一行数据的唯一性<br>通过使用索引，可以在查询的过程中使用优化隐藏器，提高 系统的性能<br>索引需要占物理和数据空间<br>如果你对索引还不太熟悉，建议阅读：<a href="https://kb.cnblogs.com/page/45712/" target="_blank" rel="noopener">漫谈数据库索引</a></p><h2 id="（三）什么是事务？"><a href="#（三）什么是事务？" class="headerlink" title="（三）什么是事务？"></a>（三）什么是事务？</h2><p>事务（Transaction）是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。</p><p>如果你对索引还不太熟悉，建议阅读：<a href="https://blog.csdn.net/zdwzzu2006/article/details/5947062" target="_blank" rel="noopener">数据库事务 - Mr. David 专栏</a></p><h2 id="（四）数据库的乐观锁和悲观锁是什么？"><a href="#（四）数据库的乐观锁和悲观锁是什么？" class="headerlink" title="（四）数据库的乐观锁和悲观锁是什么？"></a>（四）数据库的乐观锁和悲观锁是什么？</h2><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。</p><p>乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p><p>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作<br>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。<br>如果你对两种锁还不太熟悉，建议阅读：<a href="http://www.open-open.com/lib/view/open1452046967245.html" target="_blank" rel="noopener">深入理解乐观锁与悲观锁</a></p><h2 id="（五）-使用索引查询一定能提高查询的性能吗？为什么"><a href="#（五）-使用索引查询一定能提高查询的性能吗？为什么" class="headerlink" title="（五） 使用索引查询一定能提高查询的性能吗？为什么"></a>（五） 使用索引查询一定能提高查询的性能吗？为什么</h2><p>通常,通过索引查询数据比全表扫描要快.但是我们也必须注意到它的代价.</p><p>索引需要空间来存储,也需要定期维护, 每当有记录在表中增减或索引列被修改时,索引本身也会被修改. 这意味着每条记录的INSERT,DELETE,UPDATE将为此多付出4,5 次的磁盘I/O. 因为索引需要额外的存储空间和处理,那些不必要的索引反而会使查询反应时间变慢.使用索引查询不一定能提高查询性能,索引范围查询(INDEX RANGE SCAN)适用于两种情况:</p><p>基于一个范围的检索,一般查询返回结果集小于表中记录数的30%<br>基于非唯一性索引的检索</p><h2 id="（六）简单说一说drop、delete与truncate的区别"><a href="#（六）简单说一说drop、delete与truncate的区别" class="headerlink" title="（六）简单说一说drop、delete与truncate的区别"></a>（六）简单说一说drop、delete与truncate的区别</h2><p>SQL中的drop、delete、truncate都表示删除，但是三者有一些差别</p><p>delete和truncate只删除表的数据不删除表的结构<br>速度,一般来说: drop&gt; truncate &gt;delete<br>delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效;<br>如果有相应的trigger,执行的时候将被触发. truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger.<br>如果你对这三者的用法还不太熟悉，建议阅读： <a href="https://blog.csdn.net/ws0513/article/details/49980547" target="_blank" rel="noopener">drop、truncate和delete的区别</a></p><h2 id="（七）drop、delete与truncate分别在什么场景之下使用？"><a href="#（七）drop、delete与truncate分别在什么场景之下使用？" class="headerlink" title="（七）drop、delete与truncate分别在什么场景之下使用？"></a>（七）drop、delete与truncate分别在什么场景之下使用？</h2><p>不再需要一张表的时候，用drop<br>想删除部分数据行时候，用delete，并且带上where子句<br>保留表而删除所有数据的时候用truncate</p><h2 id="（八）-超键、候选键、主键、外键分别是什么？"><a href="#（八）-超键、候选键、主键、外键分别是什么？" class="headerlink" title="（八） 超键、候选键、主键、外键分别是什么？"></a>（八） 超键、候选键、主键、外键分别是什么？</h2><p>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</p><p>候选键：是最小超键，即没有冗余元素的超键。</p><p>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</p><p>外键：在一个表中存在的另一个表的主键称此表的外键。</p><h2 id="（九）什么是视图？以及视图的使用场景有哪些？"><a href="#（九）什么是视图？以及视图的使用场景有哪些？" class="headerlink" title="（九）什么是视图？以及视图的使用场景有哪些？"></a>（九）什么是视图？以及视图的使用场景有哪些？</h2><p>视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。</p><p>只暴露部分字段给访问者，所以就建一个虚表，就是视图。<br>查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异</p><h2 id="（十）说一说三个范式。"><a href="#（十）说一说三个范式。" class="headerlink" title="（十）说一说三个范式。"></a>（十）说一说三个范式。</h2><p>第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。</p><p>第二范式（2NF）：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。<br>第三范式（3NF）：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如 果存在”A → B → C”的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系： 关键字段 → 非关键字段 x → 非关键字段y</p><p>如果你对三个还不太了解，建议阅读：<a href="https://www.zhihu.com/question/24696366" target="_blank" rel="noopener">解释一下关系数据库的第一第二第三范式？</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据库基础概念I&quot;&gt;&lt;a href=&quot;#数据库基础概念I&quot; class=&quot;headerlink&quot; title=&quot;数据库基础概念I&quot;&gt;&lt;/a&gt;数据库基础概念I&lt;/h1&gt;&lt;p&gt;总结数据库基础概念&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Database" scheme="http://yoursite.com/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>20.PrintMatrix顺时针打印矩阵(CodingInterview)</title>
    <link href="http://yoursite.com/2018/08/24/%E5%89%91%E6%8C%87Offer20.%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"/>
    <id>http://yoursite.com/2018/08/24/剑指Offer20.顺时针打印矩阵/</id>
    <published>2018-08-24T01:35:00.000Z</published>
    <updated>2018-08-24T01:35:58.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="20-PrintMatrix顺时针打印矩阵-CodingInterview"><a href="#20-PrintMatrix顺时针打印矩阵-CodingInterview" class="headerlink" title="20.PrintMatrix顺时针打印矩阵(CodingInterview)"></a>20.PrintMatrix顺时针打印矩阵(CodingInterview)</h1><p>与其类似的一道题是LeetCode上的54. Spiral Matrix</p><p>题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><a id="more"></a><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>设矩阵的行数为row，列数为col，以一个5X5的矩阵为例，第一圈左上角坐标为（0，0），第二圈左上角坐标为（1，1），行列坐标相同，因此选取（start，start）作为起点。</p><p>最后一圈只有一个数字，对应坐标为（2，2）。注意到5&gt;2<em>2。对于6X6的矩阵6&gt;2</em>2仍然成立。因此可以得到让循环继续的条件是</p><pre><code>col&gt;start*2 &amp;&amp; row&gt;start*2</code></pre><p>可以解释为因为矩阵是对称的，所以为了能完整打印一圈startX和startY不会超出行列数的一半</p><p>考虑如何实现打印一圈的功能，可以分为向右-&gt;向下-&gt;向上-&gt;向左四步，值得注意的是最后一圈可能退化成只有一行，一列或一个数字，因此此时打印一圈就不需要四步，而缩减为三步、两步、一步。<br>所以要分析打印每一步的前提条件。</p><p>打印第一步时候不需要前提条件</p><p>打印第二步时至少需要有两行，endY&gt;startY</p><p>打印第三步时除了至少需要有两行还至少需要有两列 endY&gt;startY &amp;&amp; endX&gt;startX</p><p>打印第四步时至少需要三行两列 endY&gt;startY+1 &amp;&amp; endX&gt;startX</p><p>与此同时还要注意每一步的起始位置不要与上一步重合</p><pre><code>//==================================================================// 《剑指Offer——名企面试官精讲典型编程题》代码// 面试题29：顺时针打印矩阵// 题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。#include &lt;cstdio&gt;void PrintMatrixInCircle(int** numbers, int columns, int rows, int start);void printNumber(int number);void PrintMatrixClockwisely(int** numbers, int columns, int rows){    if (numbers == nullptr || columns &lt;= 0 || rows &lt;= 0)        return;    int start = 0;    while (columns &gt; start * 2 &amp;&amp; rows &gt; start * 2)    {        PrintMatrixInCircle(numbers, columns, rows, start);        ++start;    }}void PrintMatrixInCircle(int** numbers, int columns, int rows, int start){    int endX = columns - 1 - start;    int endY = rows - 1 - start;    // 从左到右打印一行    for (int i = start; i &lt;= endX; ++i)    {        int number = numbers[start][i];        printNumber(number);    }    // 从上到下打印一列    if (start &lt; endY)    {        for (int i = start + 1; i &lt;= endY; ++i)        {            int number = numbers[i][endX];            printNumber(number);        }    }    // 从右到左打印一行    if (start &lt; endX &amp;&amp; start &lt; endY)    {        for (int i = endX - 1; i &gt;= start; --i)        {            int number = numbers[endY][i];            printNumber(number);        }    }    // 从下到上打印一行    if (start &lt; endX &amp;&amp; start &lt; endY - 1)    {        for (int i = endY - 1; i &gt;= start + 1; --i)        {            int number = numbers[i][start];            printNumber(number);        }    }}void printNumber(int number){    printf(&quot;%d\t&quot;, number);}// ====================测试代码====================void Test(int columns, int rows){    printf(&quot;Test Begin: %d columns, %d rows.\n&quot;, columns, rows);    if (columns &lt; 1 || rows &lt; 1)        return;    int** numbers = new int*[rows];    for (int i = 0; i &lt; rows; ++i)    {        numbers[i] = new int[columns];        for (int j = 0; j &lt; columns; ++j)        {            numbers[i][j] = i * columns + j + 1;        }    }    PrintMatrixClockwisely(numbers, columns, rows);    printf(&quot;\n&quot;);    for (int i = 0; i &lt; rows; ++i)        delete[](int*)numbers[i];    delete[] numbers;}int main(int argc, char* argv[]){    /*    1    */    Test(1, 1);    /*    1    2    3    4    */    Test(2, 2);    /*    1    2    3    4    5    6    7    8    9    10   11   12    13   14   15   16    */    Test(4, 4);    /*    1    2    3    4    5    6    7    8    9    10    11   12   13   14   15    16   17   18   19   20    21   22   23   24   25    */    Test(5, 5);    /*    1    2    3    4    5    */    Test(1, 5);    /*    1    2    3    4    5    6    7    8    9    10    */    Test(2, 5);    /*    1    2    3    4    5    6    7    8    9    10   11   12    13   14   15    */    Test(3, 5);    /*    1    2    3    4    5    6    7    8    9    10   11   12    13   14   15   16    17   18   19   20    */    Test(4, 5);    /*    1    2    3    4    5    */    Test(5, 1);    /*    1    2    3    4    5    6    7    8    9    10    */    Test(5, 2);    /*    1    2    3    4    5    6    7    8    9    10    11   12   13   14    15    */    Test(5, 3);    /*    1    2    3    4    5    6    7    8    9    10    11   12   13   14   15    16   17   18   19   20    */    Test(5, 4);    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;20-PrintMatrix顺时针打印矩阵-CodingInterview&quot;&gt;&lt;a href=&quot;#20-PrintMatrix顺时针打印矩阵-CodingInterview&quot; class=&quot;headerlink&quot; title=&quot;20.PrintMatrix顺时针打印矩阵(CodingInterview)&quot;&gt;&lt;/a&gt;20.PrintMatrix顺时针打印矩阵(CodingInterview)&lt;/h1&gt;&lt;p&gt;与其类似的一道题是LeetCode上的54. Spiral Matrix&lt;/p&gt;
&lt;p&gt;题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Coding Interviews" scheme="http://yoursite.com/tags/Coding-Interviews/"/>
    
  </entry>
  
  <entry>
    <title>59. Spiral Matrix II螺旋矩阵 II</title>
    <link href="http://yoursite.com/2018/08/24/59.%20Spiral%20Matrix%20II%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%20II/"/>
    <id>http://yoursite.com/2018/08/24/59. Spiral Matrix II螺旋矩阵 II/</id>
    <published>2018-08-24T01:30:12.000Z</published>
    <updated>2018-08-24T07:09:48.754Z</updated>
    
    <content type="html"><![CDATA[<h1 id="59-Spiral-Matrix-II螺旋矩阵-II"><a href="#59-Spiral-Matrix-II螺旋矩阵-II" class="headerlink" title="59. Spiral Matrix II螺旋矩阵 II"></a>59. Spiral Matrix II螺旋矩阵 II</h1><p>给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p><a id="more"></a><p>示例:</p><p>输入: 3<br>输出:</p><pre><code>[ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ]]</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>此题可以参见剑指Offer20.PrintMatrix顺时针打印矩阵(CodingInterview)和54. Spiral Matrix螺旋矩阵</p><p>所不同的是可以先生成一个n*n规模的矩阵然后螺旋将数字填入，时间复杂度是O(n^2)。</p><pre><code>class Solution {public:    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) {        vector&lt;vector&lt;int&gt;&gt; res(n,vector&lt;int&gt;(n,0));        int start=0;        int num=1;        while(start*2&lt;n){            generate(res,start,num,n);            start++;        }        return res;    }    void generate(vector&lt;vector&lt;int&gt;&gt; &amp;res,int start,int &amp;num,int n){        int endy=n-start-1;        int endx=n-start-1;        for(int j=start;j&lt;=endy;j++){            res[start][j]=num;            num++;        }        for(int i=start+1;i&lt;=endx;i++){            res[i][endy]=num;            num++;        }        for(int j=endy-1;j&gt;=start;j--){            res[endx][j]=num;            num++;        }        for(int i=endx-1;i&gt;start;i--){            res[i][start]=num;            num++;        }    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;59-Spiral-Matrix-II螺旋矩阵-II&quot;&gt;&lt;a href=&quot;#59-Spiral-Matrix-II螺旋矩阵-II&quot; class=&quot;headerlink&quot; title=&quot;59. Spiral Matrix II螺旋矩阵 II&quot;&gt;&lt;/a&gt;59. Spiral Matrix II螺旋矩阵 II&lt;/h1&gt;&lt;p&gt;给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>650. 2 Keys Keyboard只有两个键的键盘</title>
    <link href="http://yoursite.com/2018/08/24/650.%202%20Keys%20Keyboard%E5%8F%AA%E6%9C%89%E4%B8%A4%E4%B8%AA%E9%94%AE%E7%9A%84%E9%94%AE%E7%9B%98/"/>
    <id>http://yoursite.com/2018/08/24/650. 2 Keys Keyboard只有两个键的键盘/</id>
    <published>2018-08-24T01:30:12.000Z</published>
    <updated>2018-08-26T11:12:29.003Z</updated>
    
    <content type="html"><![CDATA[<h1 id="650-2-Keys-Keyboard只有两个键的键盘"><a href="#650-2-Keys-Keyboard只有两个键的键盘" class="headerlink" title="650. 2 Keys Keyboard只有两个键的键盘"></a>650. 2 Keys Keyboard只有两个键的键盘</h1><p>最初在一个记事本上只有一个字符 ‘A’。你每次可以对这个记事本进行两种操作：</p><p>Copy All (复制全部) : 你可以复制这个记事本中的所有字符(部分的复制是不允许的)。<br>Paste (粘贴) : 你可以粘贴你上一次复制的字符。<br>给定一个数字 n 。你需要使用最少的操作次数，在记事本中打印出恰好 n 个 ‘A’。输出能够打印出 n 个 ‘A’ 的最少操作次数。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: 3输出: 3解释:最初, 我们只有一个字符 &apos;A&apos;。第 1 步, 我们使用 Copy All 操作。第 2 步, 我们使用 Paste 操作来获得 &apos;AA&apos;。第 3 步, 我们使用 Paste 操作来获得 &apos;AAA&apos;。</code></pre><p>说明:</p><pre><code>n 的取值范围是 [1, 1000] 。</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>其实这道题就是将N分解为M个数字的乘积，且M个数字的和最小</p><p>我们寻找一个因子d使得我们能够做d次拷贝（n/d）来得到n</p><p>做d次拷贝需要采取d步（第一步全部复制，d-1次粘贴）</p><p>我们需要通过循环来找到这个d</p><p>时间复杂度评估：<br>最好的情况下O（log(n)) ，例如n=1024时需要十次迭代<br>最差情况下当n为一些大的质数的乘积</p><pre><code>public int minSteps(int n) {       int s = 0;       for (int d = 2; d &lt;= n; d++) {           while (n % d == 0) {               s += d;               n /= d;           }       }       return s;   }</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;650-2-Keys-Keyboard只有两个键的键盘&quot;&gt;&lt;a href=&quot;#650-2-Keys-Keyboard只有两个键的键盘&quot; class=&quot;headerlink&quot; title=&quot;650. 2 Keys Keyboard只有两个键的键盘&quot;&gt;&lt;/a&gt;650. 2 Keys Keyboard只有两个键的键盘&lt;/h1&gt;&lt;p&gt;最初在一个记事本上只有一个字符 ‘A’。你每次可以对这个记事本进行两种操作：&lt;/p&gt;
&lt;p&gt;Copy All (复制全部) : 你可以复制这个记事本中的所有字符(部分的复制是不允许的)。&lt;br&gt;Paste (粘贴) : 你可以粘贴你上一次复制的字符。&lt;br&gt;给定一个数字 n 。你需要使用最少的操作次数，在记事本中打印出恰好 n 个 ‘A’。输出能够打印出 n 个 ‘A’ 的最少操作次数。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>在浏览器地址栏输入URL，按下回车后发生了什么</title>
    <link href="http://yoursite.com/2018/08/23/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5URL%EF%BC%8C%E6%8C%89%E4%B8%8B%E5%9B%9E%E8%BD%A6%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>http://yoursite.com/2018/08/23/在浏览器地址栏输入URL，按下回车后发生了什么/</id>
    <published>2018-08-23T01:06:12.000Z</published>
    <updated>2018-08-23T01:30:21.787Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在浏览器地址栏输入URL，按下回车后发生了什么"><a href="#在浏览器地址栏输入URL，按下回车后发生了什么" class="headerlink" title="在浏览器地址栏输入URL，按下回车后发生了什么"></a>在浏览器地址栏输入URL，按下回车后发生了什么</h1><p>这道题目没有所谓的完全的正确答案，这个题目可以让你在任意的一个点深入下去， 只要你对这个点是熟悉的。以下是一个大概流程：</p><a id="more"></a><h2 id="解答1："><a href="#解答1：" class="headerlink" title="解答1："></a>解答1：</h2><h3 id="1-浏览器向DNS服务器查找输入URL对应的IP地址。"><a href="#1-浏览器向DNS服务器查找输入URL对应的IP地址。" class="headerlink" title="1.浏览器向DNS服务器查找输入URL对应的IP地址。"></a>1.浏览器向DNS服务器查找输入URL对应的IP地址。</h3><h3 id="2-DNS服务器返回网站的IP地址。"><a href="#2-DNS服务器返回网站的IP地址。" class="headerlink" title="2.DNS服务器返回网站的IP地址。"></a>2.DNS服务器返回网站的IP地址。</h3><h3 id="3-浏览器根据IP地址与目标web服务器在80端口上建立TCP连接"><a href="#3-浏览器根据IP地址与目标web服务器在80端口上建立TCP连接" class="headerlink" title="3.浏览器根据IP地址与目标web服务器在80端口上建立TCP连接"></a>3.浏览器根据IP地址与目标web服务器在80端口上建立TCP连接</h3><h3 id="4-浏览器获取请求页面的html代码。"><a href="#4-浏览器获取请求页面的html代码。" class="headerlink" title="4.浏览器获取请求页面的html代码。"></a>4.浏览器获取请求页面的html代码。</h3><h3 id="5-浏览器在显示窗口内渲染HTML。"><a href="#5-浏览器在显示窗口内渲染HTML。" class="headerlink" title="5.浏览器在显示窗口内渲染HTML。"></a>5.浏览器在显示窗口内渲染HTML。</h3><h3 id="6-窗口关闭时，浏览器终止与服务器的连接。"><a href="#6-窗口关闭时，浏览器终止与服务器的连接。" class="headerlink" title="6.窗口关闭时，浏览器终止与服务器的连接。"></a>6.窗口关闭时，浏览器终止与服务器的连接。</h3><p>这其中最有趣的是第1步和第2步(域名解析)。我们输入的网址(域名)是IP地址的一个别名， 在一个DNS内，一个域名对应一个IP地址。域名系统(DNS) 的工作就是将域名与它的IP地址对应起来。DNS是分布式的，同时也是具有层级关系的。</p><h2 id="解答2："><a href="#解答2：" class="headerlink" title="解答2："></a>解答2：</h2><p>当我们用浏览器访问一个网页时，浏览器先尝试从Host文件中获取 <a href="http://www.baidu.com/对应的IP地址，如何不能取到就是用DNS协议来获取IP。在DNS协议中PC会向你的本地DNS服务器求助（一般是路由器），希望从本地DNS服务器那里得到百度的IP，如果得不到本地DNS服务器会向更高层次的DNS服务器求助.......,最终总能得到百度的IP。" target="_blank" rel="noopener">http://www.baidu.com/对应的IP地址，如何不能取到就是用DNS协议来获取IP。在DNS协议中PC会向你的本地DNS服务器求助（一般是路由器），希望从本地DNS服务器那里得到百度的IP，如果得不到本地DNS服务器会向更高层次的DNS服务器求助.......,最终总能得到百度的IP。</a></p><p>得到百度的IP，下一步使用TCP协议，建立TCP连接。在TCP协议中建立TCP需要与百度服务器握手三次，你先告诉服务器你要给服务器发东西（SYN），服务器应答你并告诉你它也要给你发东西（SYN，ACK），然后你向应答服务器（SYN，ACK）做出应答，总共来回了三次，成为3次握手。不过，建立TCP连接有个前提，你必须能够成功地把消息发到服务器上。</p><p>为了将消息从你的PC上传到服务器上，需要用到IP协议、ARP协议和OSPF协议。我们都知道，你的PC和百度服务器之间一般会有许多路由器之类的东西，IP协议指定了出发地和目的地；你的数据会经过一个又一个路由器，OSPF决定了会经过哪些路由器（用一种路由算法，找出最佳路径）从一个路由器怎么传给下一个路由器，这是ARP协议的工作，ARP负责求下一个节点的地址。IP协议使用的是IP地址，整个发送过程中只涉及出发地和目的地2个IP地址，而ARP协议使用的是MAC地址，整个发送过程中涉及到每一个节点的MAC地址。</p><p>现在，我们能和服务器通信，还建立TCP连接，下一步就是用HTTP协议请求网页内容了。你发个http请求报文给服务器，如果服务器禁止你访问就给你回个“forbidden”，如果他暂时挂掉了就给你回个“内部服务错误”，如果它正常才给你回个“OK”，并将你要的数据传给你；如果你有其他需要的东西再去给他要。你收到了服务器的回复，是一坨html的文本，浏览器必须能够理解文本的内容，并快速的渲染到屏幕上。渲染出来后，就可以看到网页了。</p><h2 id="解答3"><a href="#解答3" class="headerlink" title="解答3"></a>解答3</h2><h3 id="基本流程："><a href="#基本流程：" class="headerlink" title="基本流程："></a>基本流程：</h3><p>①查询ip地址</p><p>②建立tcp连接，接入服务器</p><p>③浏览器发起http请求</p><p>④服务器后台操作并做出http响应</p><p>⑤网页的解析与渲染</p><h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><p>查询ip地址<br>①浏览器解析出url中的域名。</p><p>②查询浏览器的DNS缓存。</p><p>③浏览器中没有DNS缓存，则查找本地客户端hosts文件有无对应的ip地址。</p><p>④hosts中无，则查找本地DNS服务器（运营商提供的DNS服务器）有无对应的DNS缓存。</p><p>⑤若本地DNS没有DNS缓存，则向根服务器查询，进行递归查找。</p><p>⑥递归查找从顶级域名开始（如.com）,一步步缩小范围，最终客户端取得ip地址。</p><p>tcp连接与http连接<br>①http协议建立在tcp协议之上，http请求前，需先进行tcp连接，形成客户端到服务器的稳定的通道。俗称TCP的三次握手。</p><p>②tcp连接完成后，http请求开始，请求有多种方式，常见的有get，post等。</p><p>③http请求包含请求头，也可能包含请求体两部分，请求头中包含我们希望对请求文件的操作的信息，请求体中包含传递给后台的参数。</p><p>④服务器收到http请求后，后台开始工作，如负载平衡，跨域等，这里就是后端的工作了。</p><p>⑤文件处理完毕，生成响应数据包，响应也包含两部分，响应头和相应体，响应体就是我们所请求的文件。</p><p>⑥经过网络传输，文件被下载到本地客户端，客户端开始加载。</p><p>html渲染<br>①客户端浏览器加载了html文件后，由上到下解析html为DOM树（DOM Tree）。</p><p>②遇到css文件，css中的url发起http请求。</p><p>③这是第二次http请求，由于http1.1协议增加了Connection: keep-alive声明，故tcp连接不会关闭，可以复用。</p><p>④http连接是无状态连接，客户端与服务器端需要重新发起请求–响应。</p><p>在请求css的过程中，解析器继续解析html，然后到了script标签。</p><p>⑤由于script可能会改变DOM结构，故解析器停止生成DOM树，解析器被js阻塞，等待js文件发起http请求，然后加载。这是第三次http请求。js执行完成后解析器继续解析。</p><p>⑥由于css文件可能会影响js文件的执行结果，因此需等css文件加载完成后再执行。</p><p>⑦浏览器收到css文件后，开始解析css文件为CSSOM树（CSS Rule Tree）。</p><p>⑧CSSOM树生成后，DOM Tree与CSS Rule Tree结合生成渲染树（Render Tree）。</p><p>⑨Render Tree会被css文件阻塞，渲染树生成后，先布局，绘制渲染树中节点的属性(位置，宽度，大小等)，然后渲染，页面就会呈现信息。</p><p>⑩继续边解析边渲染，遇到了另一个js文件，js文件执行后改变了DOM树，渲染树从被改变的dom开始再次渲染。</p><p>⑪继续向下渲染，碰到一个img标签，浏览器发起http请求，不会等待img加载完成，继续向下渲染，之后再重新渲染此部分。</p><p>⑫DOM树遇到html结束标签，停止解析，进而渲染结束。</p><h3 id="扩展思考"><a href="#扩展思考" class="headerlink" title="扩展思考"></a>扩展思考</h3><p>有那些网站优化的方法？<br>①减少DNS查询:将服务器域名的ip信息加入本地host文件。</p><p>②减少http请求数量，对于图片使用雪碧图,对于html文件和css文件，js文件分别进行合并操作。</p><p>③减少下载时间：压缩图片，使用压缩应用压缩文档中的空格，删除文件多余的语句和注释，创造自己的js精简库和精简框架,使用本地浏览器缓存。</p><p>④提前渲染开始时间：将css链接放在html头部。</p><p>⑤减轻解析器的阻塞：将js链接放在body尾部</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;在浏览器地址栏输入URL，按下回车后发生了什么&quot;&gt;&lt;a href=&quot;#在浏览器地址栏输入URL，按下回车后发生了什么&quot; class=&quot;headerlink&quot; title=&quot;在浏览器地址栏输入URL，按下回车后发生了什么&quot;&gt;&lt;/a&gt;在浏览器地址栏输入URL，按下回车后发生了什么&lt;/h1&gt;&lt;p&gt;这道题目没有所谓的完全的正确答案，这个题目可以让你在任意的一个点深入下去， 只要你对这个点是熟悉的。以下是一个大概流程：&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="TCPIP" scheme="http://yoursite.com/tags/TCPIP/"/>
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>59.SymmetricalBinaryTree对称的二叉树(CodingInterview)</title>
    <link href="http://yoursite.com/2018/08/23/%E5%89%91%E6%8C%87Offer59.%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2018/08/23/剑指Offer59.对称的二叉树/</id>
    <published>2018-08-23T00:45:12.000Z</published>
    <updated>2018-08-24T02:04:28.134Z</updated>
    
    <content type="html"><![CDATA[<h1 id="59-SymmetricalBinaryTree对称的二叉树-CodingInterview"><a href="#59-SymmetricalBinaryTree对称的二叉树-CodingInterview" class="headerlink" title="59.SymmetricalBinaryTree对称的二叉树(CodingInterview)"></a>59.SymmetricalBinaryTree对称的二叉树(CodingInterview)</h1><p>与其类似的一道题是LeetCode上的101. Symmetric Tree</p><p>请实现一个函数，用来判断一颗二叉树是不是对称的。<br>注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p><a id="more"></a><h2 id="Recursive递归解法："><a href="#Recursive递归解法：" class="headerlink" title="Recursive递归解法："></a>Recursive递归解法：</h2><p>定义一种对称的前序遍历算法，即先遍历父节点，再遍历它的右子节点，最后遍历它的左子节点。</p><p>可以通过对比二叉树的前序遍历序列和对称前序遍历序列来判断二叉树是不是对称的。如果两个序列是一样的那么二叉树是对称的。</p><pre><code>bool isSymmetrical(BinaryTreeNode* pRoot1, BinaryTreeNode* pRoot2);bool isSymmetrical(BinaryTreeNode* pRoot){    return isSymmetrical(pRoot, pRoot);}bool isSymmetrical(BinaryTreeNode* pRoot1, BinaryTreeNode* pRoot2){    if (pRoot1 == NULL &amp;&amp; pRoot2 == NULL) return true;    else if (pRoot1 == NULL || pRoot2 == NULL) return false;    else if (pRoot1-&gt;m_nValue != pRoot2-&gt;m_nValue) return false;    return isSymmetrical(pRoot1-&gt;m_pLeft, pRoot2-&gt;m_pRight) &amp;&amp; isSymmetrical(pRoot2-&gt;m_pRight, pRoot1-&gt;m_pLeft);}</code></pre><h2 id="Non-Recursive-use-queue-非递归解法"><a href="#Non-Recursive-use-queue-非递归解法" class="headerlink" title="Non-Recursive(use queue)非递归解法:"></a>Non-Recursive(use queue)非递归解法:</h2><p>使用队列进行层次遍历，当队列非空的时候对队列中的结点进行判断，再每次将下一层的所有节点按照对称的顺序入队</p><pre><code>#include&lt;iostream&gt;#include &lt;cstdio&gt;#include &quot;BinaryTree.h&quot;using namespace std;bool isSymmetrical(BinaryTreeNode* pRoot){    if (pRoot == NULL) return true;    queue&lt;BinaryTreeNode*&gt; queue;    queue.push(pRoot-&gt;m_pLeft);    queue.push(pRoot-&gt;m_pRight);    while (!queue.empty())    {        BinaryTreeNode *left = queue.front(); queue.pop();        BinaryTreeNode *right = queue.front(); queue.pop();        if (!left &amp;&amp; !right) continue;        else if (!left || !right) return false;        else if (left-&gt;m_nValue != right-&gt;m_nValue) return false;        queue.push(left-&gt;m_pLeft);        queue.push(right-&gt;m_pRight);        queue.push(left-&gt;m_pRight);        queue.push(right-&gt;m_pLeft);    }    return true;}// ====================测试代码====================void Test(char* testName, BinaryTreeNode* pRoot, bool expected){    if (testName != nullptr)        printf(&quot;%s begins: &quot;, testName);    if (isSymmetrical(pRoot) == expected)        printf(&quot;Passed.\n&quot;);    else        printf(&quot;FAILED.\n&quot;);}//            8//        6      6//       5 7    7 5void Test1(){    BinaryTreeNode* pNode8 = CreateBinaryTreeNode(8);    BinaryTreeNode* pNode61 = CreateBinaryTreeNode(6);    BinaryTreeNode* pNode62 = CreateBinaryTreeNode(6);    BinaryTreeNode* pNode51 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode71 = CreateBinaryTreeNode(7);    BinaryTreeNode* pNode72 = CreateBinaryTreeNode(7);    BinaryTreeNode* pNode52 = CreateBinaryTreeNode(5);    ConnectTreeNodes(pNode8, pNode61, pNode62);    ConnectTreeNodes(pNode61, pNode51, pNode71);    ConnectTreeNodes(pNode62, pNode72, pNode52);    Test(&quot;Test1&quot;, pNode8, true);    DestroyTree(pNode8);}//            8//        6      9//       5 7    7 5void Test2(){    BinaryTreeNode* pNode8 = CreateBinaryTreeNode(8);    BinaryTreeNode* pNode61 = CreateBinaryTreeNode(6);    BinaryTreeNode* pNode9 = CreateBinaryTreeNode(9);    BinaryTreeNode* pNode51 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode71 = CreateBinaryTreeNode(7);    BinaryTreeNode* pNode72 = CreateBinaryTreeNode(7);    BinaryTreeNode* pNode52 = CreateBinaryTreeNode(5);    ConnectTreeNodes(pNode8, pNode61, pNode9);    ConnectTreeNodes(pNode61, pNode51, pNode71);    ConnectTreeNodes(pNode9, pNode72, pNode52);    Test(&quot;Test2&quot;, pNode8, false);    DestroyTree(pNode8);}//            8//        6      6//       5 7    7void Test3(){    BinaryTreeNode* pNode8 = CreateBinaryTreeNode(8);    BinaryTreeNode* pNode61 = CreateBinaryTreeNode(6);    BinaryTreeNode* pNode62 = CreateBinaryTreeNode(6);    BinaryTreeNode* pNode51 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode71 = CreateBinaryTreeNode(7);    BinaryTreeNode* pNode72 = CreateBinaryTreeNode(7);    ConnectTreeNodes(pNode8, pNode61, pNode62);    ConnectTreeNodes(pNode61, pNode51, pNode71);    ConnectTreeNodes(pNode62, pNode72, nullptr);    Test(&quot;Test3&quot;, pNode8, false);    DestroyTree(pNode8);}//               5//              / \//             3   3//            /     \//           4       4//          /         \//         2           2//        /             \//       1               1void Test4(){    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode31 = CreateBinaryTreeNode(3);    BinaryTreeNode* pNode32 = CreateBinaryTreeNode(3);    BinaryTreeNode* pNode41 = CreateBinaryTreeNode(4);    BinaryTreeNode* pNode42 = CreateBinaryTreeNode(4);    BinaryTreeNode* pNode21 = CreateBinaryTreeNode(2);    BinaryTreeNode* pNode22 = CreateBinaryTreeNode(2);    BinaryTreeNode* pNode11 = CreateBinaryTreeNode(1);    BinaryTreeNode* pNode12 = CreateBinaryTreeNode(1);    ConnectTreeNodes(pNode5, pNode31, pNode32);    ConnectTreeNodes(pNode31, pNode41, nullptr);    ConnectTreeNodes(pNode32, nullptr, pNode42);    ConnectTreeNodes(pNode41, pNode21, nullptr);    ConnectTreeNodes(pNode42, nullptr, pNode22);    ConnectTreeNodes(pNode21, pNode11, nullptr);    ConnectTreeNodes(pNode22, nullptr, pNode12);    Test(&quot;Test4&quot;, pNode5, true);    DestroyTree(pNode5);}//               5//              / \//             3   3//            /     \//           4       4//          /         \//         6           2//        /             \//       1               1void Test5(){    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode31 = CreateBinaryTreeNode(3);    BinaryTreeNode* pNode32 = CreateBinaryTreeNode(3);    BinaryTreeNode* pNode41 = CreateBinaryTreeNode(4);    BinaryTreeNode* pNode42 = CreateBinaryTreeNode(4);    BinaryTreeNode* pNode6 = CreateBinaryTreeNode(6);    BinaryTreeNode* pNode22 = CreateBinaryTreeNode(2);    BinaryTreeNode* pNode11 = CreateBinaryTreeNode(1);    BinaryTreeNode* pNode12 = CreateBinaryTreeNode(1);    ConnectTreeNodes(pNode5, pNode31, pNode32);    ConnectTreeNodes(pNode31, pNode41, nullptr);    ConnectTreeNodes(pNode32, nullptr, pNode42);    ConnectTreeNodes(pNode41, pNode6, nullptr);    ConnectTreeNodes(pNode42, nullptr, pNode22);    ConnectTreeNodes(pNode6, pNode11, nullptr);    ConnectTreeNodes(pNode22, nullptr, pNode12);    Test(&quot;Test5&quot;, pNode5, false);    DestroyTree(pNode5);}//               5//              / \//             3   3//            /     \//           4       4//          /         \//         2           2//                      \//                       1void Test6(){    BinaryTreeNode* pNode5 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode31 = CreateBinaryTreeNode(3);    BinaryTreeNode* pNode32 = CreateBinaryTreeNode(3);    BinaryTreeNode* pNode41 = CreateBinaryTreeNode(4);    BinaryTreeNode* pNode42 = CreateBinaryTreeNode(4);    BinaryTreeNode* pNode21 = CreateBinaryTreeNode(2);    BinaryTreeNode* pNode22 = CreateBinaryTreeNode(2);    BinaryTreeNode* pNode12 = CreateBinaryTreeNode(1);    ConnectTreeNodes(pNode5, pNode31, pNode32);    ConnectTreeNodes(pNode31, pNode41, nullptr);    ConnectTreeNodes(pNode32, nullptr, pNode42);    ConnectTreeNodes(pNode41, pNode21, nullptr);    ConnectTreeNodes(pNode42, nullptr, pNode22);    ConnectTreeNodes(pNode21, nullptr, nullptr);    ConnectTreeNodes(pNode22, nullptr, pNode12);    Test(&quot;Test6&quot;, pNode5, false);    DestroyTree(pNode5);}// 只有一个结点void Test7(){    BinaryTreeNode* pNode1 = CreateBinaryTreeNode(1);    Test(&quot;Test7&quot;, pNode1, true);    DestroyTree(pNode1);}// 没有结点void Test8(){    Test(&quot;Test8&quot;, nullptr, true);}// 所有结点都有相同的值，树对称//               5//              / \//             5   5//            /     \//           5       5//          /         \//         5           5void Test9(){    BinaryTreeNode* pNode1 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode21 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode22 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode31 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode32 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode41 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode42 = CreateBinaryTreeNode(5);    ConnectTreeNodes(pNode1, pNode21, pNode22);    ConnectTreeNodes(pNode21, pNode31, nullptr);    ConnectTreeNodes(pNode22, nullptr, pNode32);    ConnectTreeNodes(pNode31, pNode41, nullptr);    ConnectTreeNodes(pNode32, nullptr, pNode42);    ConnectTreeNodes(pNode41, nullptr, nullptr);    ConnectTreeNodes(pNode42, nullptr, nullptr);    Test(&quot;Test9&quot;, pNode1, true);    DestroyTree(pNode1);}// 所有结点都有相同的值，树不对称//               5//              / \//             5   5//            /     \//           5       5//          /       ///         5       5void Test10(){    BinaryTreeNode* pNode1 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode21 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode22 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode31 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode32 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode41 = CreateBinaryTreeNode(5);    BinaryTreeNode* pNode42 = CreateBinaryTreeNode(5);    ConnectTreeNodes(pNode1, pNode21, pNode22);    ConnectTreeNodes(pNode21, pNode31, nullptr);    ConnectTreeNodes(pNode22, nullptr, pNode32);    ConnectTreeNodes(pNode31, pNode41, nullptr);    ConnectTreeNodes(pNode32, pNode42, nullptr);    ConnectTreeNodes(pNode41, nullptr, nullptr);    ConnectTreeNodes(pNode42, nullptr, nullptr);    Test(&quot;Test10&quot;, pNode1, false);    DestroyTree(pNode1);}void main(int argc, char* argv[]){    Test1();    Test2();    Test3();    Test4();    Test5();    Test6();    Test7();    Test8();    Test9();    Test10();}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;59-SymmetricalBinaryTree对称的二叉树-CodingInterview&quot;&gt;&lt;a href=&quot;#59-SymmetricalBinaryTree对称的二叉树-CodingInterview&quot; class=&quot;headerlink&quot; title=&quot;59.SymmetricalBinaryTree对称的二叉树(CodingInterview)&quot;&gt;&lt;/a&gt;59.SymmetricalBinaryTree对称的二叉树(CodingInterview)&lt;/h1&gt;&lt;p&gt;与其类似的一道题是LeetCode上的101. Symmetric Tree&lt;/p&gt;
&lt;p&gt;请实现一个函数，用来判断一颗二叉树是不是对称的。&lt;br&gt;注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Coding Interviews" scheme="http://yoursite.com/tags/Coding-Interviews/"/>
    
      <category term="BinaryTree" scheme="http://yoursite.com/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer思路总结</title>
    <link href="http://yoursite.com/2018/08/23/%E5%89%91%E6%8C%87offer%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/08/23/剑指offer思路总结/</id>
    <published>2018-08-23T00:45:12.000Z</published>
    <updated>2018-08-23T03:26:40.658Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指offer思路总结"><a href="#剑指offer思路总结" class="headerlink" title="剑指offer思路总结"></a>剑指offer思路总结</h1><p>剑指offer已经刷过两遍，总结一下思路方便回忆</p><a id="more"></a><h2 id="13-在O-1-时间删除链表结点"><a href="#13-在O-1-时间删除链表结点" class="headerlink" title="13.在O(1)时间删除链表结点"></a>13.在O(1)时间删除链表结点</h2><pre><code>分情况讨论：先在链表中顺序搜索要删除的节点i不是尾结点：{    先将i的下一个结点j的内容复制到i    然后把i的指针指向结点j的下一个结点；    此时再删除结点j}链表只有一个结点{    则删除该结点    然后将其置为NULL    将头结点置为空}链表有多个结点而且要删除的结点是尾结点{    从头结点顺序遍历，只要找到该结点i的前序结点就可以，然后执行删除操作}</code></pre><h2 id="14-调整数组顺序使奇数位于偶数前面"><a href="#14-调整数组顺序使奇数位于偶数前面" class="headerlink" title="14.调整数组顺序使奇数位于偶数前面"></a>14.调整数组顺序使奇数位于偶数前面</h2><h3 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute Force"></a>Brute Force</h3><p>顺序扫描碰到偶数就将其放到末尾</p><h3 id="初级解法"><a href="#初级解法" class="headerlink" title="初级解法"></a>初级解法</h3><p>双指针指向头尾部分，头偶尾奇则交换两个数字</p><h3 id="可扩展解法"><a href="#可扩展解法" class="headerlink" title="可扩展解法"></a>可扩展解法</h3><p>仍使用头尾指针，但用函数指针的方法将判断奇偶的函数解耦出来，整体逻辑框架不需要改动</p><h2 id="15-链表中倒数第K个节点"><a href="#15-链表中倒数第K个节点" class="headerlink" title="15.链表中倒数第K个节点"></a>15.链表中倒数第K个节点</h2><p>快慢指针，快指针比慢指针领先k-1步出发，快指针到尾节点时慢指针指向的是所求</p><h3 id="举一反三"><a href="#举一反三" class="headerlink" title="举一反三"></a>举一反三</h3><h4 id="1-求链表中间结点"><a href="#1-求链表中间结点" class="headerlink" title="1.求链表中间结点"></a>1.求链表中间结点</h4><p>快慢指针，快指针每次走两步，慢指针每次走一步，快指针到末尾时慢指针指向中间结点</p><h4 id="2-判断单向链表是否成环"><a href="#2-判断单向链表是否成环" class="headerlink" title="2.判断单向链表是否成环"></a>2.判断单向链表是否成环</h4><p>同前面，若快指针追上慢指针则成环</p><h2 id="16-反转链表"><a href="#16-反转链表" class="headerlink" title="16.反转链表"></a>16.反转链表</h2><p>需要定义三个指针，指向当前遍历的结点，前一个结点和后一个结点,先要找到反转链表后的头结点即原始链表的尾节点，需要满足的条件是后结点为空</p><pre><code>////Non-RecursiveListNode* ReverseList(ListNode* pHead){    ListNode* pReversedHead = nullptr;    ListNode* pNode = pHead;    ListNode* pPrev = nullptr;    while (pNode != nullptr)    {        ListNode *pNext = pNode-&gt;m_pNext;        if (pNext == NULL) {//find the last node            pReversedHead = pNode;        }        pNode-&gt;m_pNext = pPrev;//Revserse        pPrev = pNode;// forward        pNode = pNext;    }    return pReversedHead;}ListNode* ReverseList(ListNode* pHead){    if (pHead == NULL || pHead-&gt;m_pNext == nullptr) return pHead;    ListNode *PReverseHead = pHead;    pHead=ReverseList(pHead-&gt;m_pNext);    PReverseHead-&gt;m_pNext-&gt;m_pNext = PReverseHead;//进入尾节点    PReverseHead-&gt;m_pNext = NULL;    return pHead;}</code></pre><h2 id="28-字符串的排列"><a href="#28-字符串的排列" class="headerlink" title="28.字符串的排列"></a>28.字符串的排列</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;剑指offer思路总结&quot;&gt;&lt;a href=&quot;#剑指offer思路总结&quot; class=&quot;headerlink&quot; title=&quot;剑指offer思路总结&quot;&gt;&lt;/a&gt;剑指offer思路总结&lt;/h1&gt;&lt;p&gt;剑指offer已经刷过两遍，总结一下思路方便回忆&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Coding Interviews" scheme="http://yoursite.com/tags/Coding-Interviews/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
  </entry>
  
</feed>
