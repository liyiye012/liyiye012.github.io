<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-11T16:01:39.936Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Latex极简教程</title>
    <link href="http://yoursite.com/2020/07/10/Latex%E6%9E%81%E7%AE%80%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/07/10/Latex极简教程/</id>
    <published>2020-07-10T15:55:12.000Z</published>
    <updated>2020-07-11T16:01:39.936Z</updated>
    
    <content type="html"><![CDATA[<p>在mac上快速安装使用Latex</p><a id="more"></a><h1 id="快速安装"><a href="#快速安装" class="headerlink" title="快速安装"></a>快速安装</h1><p>步骤参照<a href="https://www.cnblogs.com/ouyangsong/p/9348175.html" target="_blank" rel="noopener">^1</a><br>Latex 是个复杂但是很强大的排版工具，在 MAC 系统上如果不想安装 3G 大的 MacTex 的话，可以试试 BasicTex。</p><p>安装<br>MacTex 安装包非常大，而且自带了很多图形应用。我更喜欢用命令行，所以选择 BasicTex。使用 Homebrew 安装非常简单，一条命令即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew cask install basictex</span><br></pre></td></tr></table></figure><p>安装完还不能直接使用，还需要把 texlive 添加到环境变量中，才能找到相关的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=/usr/local/texlive/2020basic/bin/x86_64-darwin:$PATH</span><br></pre></td></tr></table></figure><p>然后就是安装相关的包，以及更新包,要cd到目录/usr/local/texlive/2020basic/bin/x86_64-darwin中运行下列命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo tlmgr update --self --repository http://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/tlnet</span><br><span class="line">sudo tlmgr install latexmk --repository http://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/tlnet</span><br></pre></td></tr></table></figure><p>安装包的时候推荐使用清华的 CTAN 镜像，不然的话下载速度实在太慢了。</p><h1 id="Atom开发"><a href="#Atom开发" class="headerlink" title="Atom开发"></a>Atom开发</h1><p>配合Atom来运行latex，参照<a href="https://blog.csdn.net/violet_echo_0908/article/details/78160273" target="_blank" rel="noopener">^2</a></p><p>安装好插件后会报错缺失一些包可以更新插件或者npm install相应的包</p><h1 id="命令行直接编译"><a href="#命令行直接编译" class="headerlink" title="命令行直接编译"></a>命令行直接编译</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xelatex demo.tex</span><br></pre></td></tr></table></figure><h1 id="遇到错误-LaTeX-Error-File-xifthen-sty-39-not-found"><a href="#遇到错误-LaTeX-Error-File-xifthen-sty-39-not-found" class="headerlink" title="遇到错误 ! LaTeX Error: File `xifthen.sty&#39; not found"></a>遇到错误 <code>! LaTeX Error: File `xifthen.sty&#39; not found</code></h1><p>那么去搜索一下它被包含在哪个包中，比如 xifthen.sty 就是包含在 xifthen 中。那么使用 tlmgr 安装即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tlmgr install xifthen</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在mac上快速安装使用Latex&lt;/p&gt;
    
    </summary>
    
      <category term="2020年7月" scheme="http://yoursite.com/categories/2020%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="Latex" scheme="http://yoursite.com/tags/Latex/"/>
    
  </entry>
  
  <entry>
    <title>378. 有序矩阵中第K小的元素</title>
    <link href="http://yoursite.com/2020/07/09/378.%20%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2020/07/09/378. 有序矩阵中第K小的元素/</id>
    <published>2020-07-09T09:41:12.000Z</published>
    <updated>2020-07-11T16:01:30.107Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。<br>请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。</p><a id="more"></a><p>示例：</p><pre><code>matrix = [   [ 1,  5,  9],   [10, 11, 13],   [12, 13, 15]],k = 8,返回 13。</code></pre><p>提示：<br>你可以假设 k 的值永远是有效的，1 ≤ k ≤ n^2 。</p><h1 id="方法一：直接排序"><a href="#方法一：直接排序" class="headerlink" title="方法一：直接排序"></a>方法一：直接排序</h1><p><strong>思路及算法</strong><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/solution/you-xu-ju-zhen-zhong-di-kxiao-de-yuan-su-by-leetco/" target="_blank" rel="noopener">^1</a></p><p>最直接的做法是将这个二维数组另存为为一维数组，并对该一维数组进行排序。最后这个一维数组中的第 <em>k</em> 个数即为答案。</p><p><strong>代码</strong></p><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; row : matrix) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> it : row) &#123;</span><br><span class="line">                rec.push_back(it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(rec.begin(), rec.end());</span><br><span class="line">        <span class="keyword">return</span> rec[k - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length, columns = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[] sorted = <span class="keyword">new</span> <span class="keyword">int</span>[rows * columns];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : matrix) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : row) &#123;</span><br><span class="line">                sorted[index++] = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(sorted);</span><br><span class="line">        <span class="keyword">return</span> sorted[k - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, matrix: List[List[int]], k: int)</span> -&gt; int:</span></span><br><span class="line">        rec = sorted(sum(matrix, []))</span><br><span class="line">        <span class="keyword">return</span> rec[k - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">kthSmallest</span><span class="params">(matrix [][]<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    rows, columns := <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">    sorted := <span class="built_in">make</span>([]<span class="keyword">int</span>, rows * columns)</span><br><span class="line">    index := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, row := <span class="keyword">range</span> matrix &#123;</span><br><span class="line">        <span class="keyword">for</span> _, num := <span class="keyword">range</span> row &#123;</span><br><span class="line">            sorted[index] = num</span><br><span class="line">            index++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Ints(sorted)</span><br><span class="line">    <span class="keyword">return</span> sorted[k<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span> </span>&#123; <span class="keyword">return</span> (*(<span class="keyword">int</span> *)a - *(<span class="keyword">int</span> *)b); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="keyword">int</span> **matrix, <span class="keyword">int</span> matrixSize, <span class="keyword">int</span> *matrixColSize, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *rec = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(matrixSize * matrixSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrixSize; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrixColSize[i]; j++) &#123;</span><br><span class="line">            rec[num++] = matrix[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    qsort(rec, num, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), cmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rec[k - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度 O(n^2log{n}) ，对 <em>n^2</em> 个数排序。</p></li><li><p>空间复杂度：<em>O(n^2)*，一维数组需要存储这 *n^2</em> 个数。</p></li></ul><h1 id="方法二：归并排序"><a href="#方法二：归并排序" class="headerlink" title="方法二：归并排序"></a>方法二：归并排序</h1><p><strong>思路及算法</strong></p><p>由题目给出的性质可知，这个矩阵的每一行均为一个有序数组。问题即转化为从这 <em>n</em> 个有序数组中找第 <em>k</em> 大的数，可以想到利用归并排序的做法，归并到第 <em>k</em> 个数即可停止。</p><p>一般归并排序是两个数组归并，而本题是 <em>n</em> 个数组归并，所以需要用小根堆维护，以优化时间复杂度。</p><p>具体如何归并，可以参考力扣 <a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">23. 合并K个排序链表</a>。</p><p><strong>代码</strong></p><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">            <span class="keyword">int</span> val, x, y;</span><br><span class="line">            point(<span class="keyword">int</span> val, <span class="keyword">int</span> x, <span class="keyword">int</span> y) : val(val), x(x), y(y) &#123;&#125;</span><br><span class="line">            <span class="keyword">bool</span> <span class="keyword">operator</span>&gt; (<span class="keyword">const</span> point&amp; a) <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;val &gt; a.val; &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        priority_queue&lt;point, <span class="built_in">vector</span>&lt;point&gt;, greater&lt;point&gt;&gt; que;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            que.emplace(matrix[i][<span class="number">0</span>], i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            point now = que.top();</span><br><span class="line">            que.pop();</span><br><span class="line">            <span class="keyword">if</span> (now.y != n - <span class="number">1</span>) &#123;</span><br><span class="line">                que.emplace(matrix[now.x][now.y + <span class="number">1</span>], now.x, now.y + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> que.top().val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;<span class="keyword">int</span>[]&gt;(<span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;matrix[i][<span class="number">0</span>], i, <span class="number">0</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] now = pq.poll();</span><br><span class="line">            <span class="keyword">if</span> (now[<span class="number">2</span>] != n - <span class="number">1</span>) &#123;</span><br><span class="line">                pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;matrix[now[<span class="number">1</span>]][now[<span class="number">2</span>] + <span class="number">1</span>], now[<span class="number">1</span>], now[<span class="number">2</span>] + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq.poll()[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, matrix: List[List[int]], k: int)</span> -&gt; int:</span></span><br><span class="line">        n = len(matrix)</span><br><span class="line">        pq = [(matrix[i][<span class="number">0</span>], i, <span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        heapq.heapify(pq)</span><br><span class="line"></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k - <span class="number">1</span>):</span><br><span class="line">            num, x, y = heapq.heappop(pq)</span><br><span class="line">            <span class="keyword">if</span> y != n - <span class="number">1</span>:</span><br><span class="line">                heapq.heappush(pq, (matrix[x][y + <span class="number">1</span>], x, y + <span class="number">1</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> heapq.heappop(pq)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">kthSmallest</span><span class="params">(matrix [][]<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    h := &amp;IHeap&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(matrix); i++ &#123;</span><br><span class="line">        heap.Push(h, [<span class="number">3</span>]<span class="keyword">int</span>&#123;matrix[i][<span class="number">0</span>], i, <span class="number">0</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++ &#123;</span><br><span class="line">        now := heap.Pop(h).([<span class="number">3</span>]<span class="keyword">int</span>)</span><br><span class="line">        <span class="keyword">if</span> now[<span class="number">2</span>] != <span class="built_in">len</span>(matrix) - <span class="number">1</span> &#123;</span><br><span class="line">            heap.Push(h, [<span class="number">3</span>]<span class="keyword">int</span>&#123;matrix[now[<span class="number">1</span>]][now[<span class="number">2</span>]+<span class="number">1</span>], now[<span class="number">1</span>], now[<span class="number">2</span>]+<span class="number">1</span>&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heap.Pop(h).([<span class="number">3</span>]<span class="keyword">int</span>)[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IHeap [][<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> h[i][<span class="number">0</span>] &lt; h[j][<span class="number">0</span>] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">*h = <span class="built_in">append</span>(*h, x.([<span class="number">3</span>]<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">old := *h</span><br><span class="line">n := <span class="built_in">len</span>(old)</span><br><span class="line">x := old[n<span class="number">-1</span>]</span><br><span class="line">*h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val, x, y;</span><br><span class="line">&#125; point;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(point a, point b)</span> </span>&#123; <span class="keyword">return</span> a.val &gt;= b.val; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(point* a, point* b)</span> </span>&#123;</span><br><span class="line">    point t = *a;</span><br><span class="line">    *a = *b, *b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(point heap[], <span class="keyword">int</span>* size, point* p)</span> </span>&#123;</span><br><span class="line">    heap[++(*size)] = *p;</span><br><span class="line">    <span class="keyword">int</span> s = (*size);</span><br><span class="line">    <span class="keyword">while</span> (s &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cmp(heap[s], heap[s &gt;&gt; <span class="number">1</span>])) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(&amp;heap[s], &amp;heap[s &gt;&gt; <span class="number">1</span>]);</span><br><span class="line">        s &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(point heap[], <span class="keyword">int</span>* size)</span> </span>&#123;</span><br><span class="line">    heap[<span class="number">1</span>] = heap[(*size)--];</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">1</span>, s = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (s &lt;= (*size)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s &lt; (*size) &amp;&amp; !cmp(heap[s + <span class="number">1</span>], heap[s])) &#123;</span><br><span class="line">            s++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cmp(heap[s], heap[p])) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(&amp;heap[s], &amp;heap[p]);</span><br><span class="line">        p = s, s = p &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="keyword">int</span>** matrix, <span class="keyword">int</span> matrixSize, <span class="keyword">int</span>* matrixColSize, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    point heap[matrixSize + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrixSize; i++) &#123;</span><br><span class="line">        point p = &#123;matrix[i][<span class="number">0</span>], i, <span class="number">0</span>&#125;;</span><br><span class="line">        push(heap, &amp;size, &amp;p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        point now = heap[<span class="number">1</span>];</span><br><span class="line">        pop(heap, &amp;size);</span><br><span class="line">        <span class="keyword">if</span> (now.y != matrixSize - <span class="number">1</span>) &#123;</span><br><span class="line">            point p = &#123;matrix[now.x][now.y + <span class="number">1</span>], now.x, now.y + <span class="number">1</span>&#125;;</span><br><span class="line">            push(heap, &amp;size, &amp;p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heap[<span class="number">1</span>].val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(klogn)，归并 <em>k</em> 次，每次堆中插入和弹出的操作时间复杂度均为 logn 。</p></li><li><p>空间复杂度：<em>O(n)</em>，堆的大小始终为 <em>n</em>。</p></li></ul><blockquote><p>需要注意的是，<em>k</em> 在最坏情况下是 <em>n^2</em>，因此该解法最坏时间复杂度为 O(n^2logn)。</p></blockquote><h1 id="方法三：二分查找"><a href="#方法三：二分查找" class="headerlink" title="方法三：二分查找"></a>方法三：二分查找</h1><p><strong>思路及算法</strong></p><p>由题目给出的性质可知，这个矩阵内的元素是从左上到右下递增的（假设矩阵左上角为 <em>matrix[0][0]</em>）。以下图为例：</p><p> <a href="https://assets.leetcode-cn.com/solution-static/378/378_fig1.png" target="_blank" rel="noopener">fig1</a></p><p>我们知道整个二维数组中 <em>matrix[0][0]</em> 为最小值，<em>matrix[n - 1][n - 1]</em> 为最大值，现在我们将其分别记作 <em>l</em> 和 <em>r</em>。</p><p>可以发现一个性质：任取一个数 <em>mid</em> 满足 l≤mid≤r ，那么矩阵中不大于 <em>mid</em> 的数，肯定全部分布在矩阵的左上角。</p><p>例如下图，取 <em>mid=8</em>：</p><p> <a href="https://assets.leetcode-cn.com/solution-static/378/378_fig2.png" target="_blank" rel="noopener">fig2</a></p><p>我们可以看到，矩阵中大于 <em>mid</em> 的数就和不大于 <em>mid</em> 的数分别形成了两个板块，沿着一条锯齿线将这个矩形分开。其中左上角板块的大小即为矩阵中不大于 <em>mid</em> 的数的数量。</p><p>读者也可以自己取一些 <em>mid</em> 值，通过画图以加深理解。</p><p>我们只要沿着这条锯齿线走一遍即可计算出这两个板块的大小，也自然就统计出了这个矩阵中不大于 <em>mid</em> 的数的个数了。</p><p>走法演示如下，依然取 <em>mid=8</em>：</p><p> <a href="https://assets.leetcode-cn.com/solution-static/378/378_fig3.png" target="_blank" rel="noopener">fig3</a></p><p>可以这样描述走法：</p><ul><li><p>初始位置在 <em>matrix[n - 1][0]</em>（即左下角）；</p></li><li><p>设当前位置为 <em>matrix[i][j]*。若 matrix[i][j]&lt;=mid，则将当前所在列的不大于 *mid</em> 的数的数量（即 <em>i + 1</em>）累加到答案中，并向右移动，否则向上移动；</p></li><li><p>不断移动直到走出格子为止。</p></li></ul><p>我们发现这样的走法时间复杂度为 <em>O(n)</em>，即我们可以线性计算对于任意一个 <em>mid</em>，矩阵中有多少数不大于它。这满足了二分查找的性质。</p><p>不妨假设答案为 <em>x</em>，那么可以知道  l≤x≤r ，这样就确定了二分查找的上下界。</p><p>每次对于「猜测」的答案 <em>mid*，计算矩阵中有多少数不大于 *mid</em> ：</p><ul><li>如果数量不少于 <em>k</em>，那么说明最终答案 <em>x</em> 不大于 <em>mid</em>；</li><li>如果数量少于 <em>k</em>，那么说明最终答案 <em>x</em> 大于 <em>mid</em>。</li></ul><p>这样我们就可以计算出最终的结果 <em>x</em> 了。</p><p><strong>代码</strong></p><figure class="highlight c++"><figcaption><span>[sol3-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> mid, <span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] &lt;= mid) &#123;</span><br><span class="line">                num += i + <span class="number">1</span>;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num &gt;= k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> left = matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> right = matrix[n - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (check(matrix, mid, k, n)) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[sol3-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> left = matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> right = matrix[n - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (check(matrix, mid, k, n)) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> mid, <span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] &lt;= mid) &#123;</span><br><span class="line">                num += i + <span class="number">1</span>;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num &gt;= k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[sol3-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, matrix: List[List[int]], k: int)</span> -&gt; int:</span></span><br><span class="line">        n = len(matrix)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(mid)</span>:</span></span><br><span class="line">            i, j = n - <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">            num = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt; n:</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] &lt;= mid:</span><br><span class="line">                    num += i + <span class="number">1</span></span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    i -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> num &gt;= k</span><br><span class="line"></span><br><span class="line">        left, right = matrix[<span class="number">0</span>][<span class="number">0</span>], matrix[<span class="number">-1</span>][<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> check(mid):</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><figure class="highlight golang"><figcaption><span>[sol3-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">kthSmallest</span><span class="params">(matrix [][]<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(matrix)</span><br><span class="line">    left, right := matrix[<span class="number">0</span>][<span class="number">0</span>], matrix[n<span class="number">-1</span>][n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        mid := left + (right - left) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> check(matrix, mid, k, n) &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(matrix [][]<span class="keyword">int</span>, mid, k, n <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    i, j := n - <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    num := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n &#123;</span><br><span class="line">        <span class="keyword">if</span> matrix[i][j] &lt;= mid &#123;</span><br><span class="line">            num += i + <span class="number">1</span></span><br><span class="line">            j++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num &gt;= k</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><figcaption><span>[sol3-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> **matrix, <span class="keyword">int</span> mid, <span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[i][j] &lt;= mid) &#123;</span><br><span class="line">            num += i + <span class="number">1</span>;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num &gt;= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="keyword">int</span> **matrix, <span class="keyword">int</span> matrixSize, <span class="keyword">int</span> *matrixColSize, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> right = matrix[matrixSize - <span class="number">1</span>][matrixSize - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (check(matrix, mid, k, matrixSize)) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(nlog(r−l)) ，二分查找进行次数为 O(log(r−l)) ，每次操作时间复杂度为 <em>O(n)</em>。</p></li><li><p>空间复杂度：<em>O(1)</em>。</p></li></ul><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>上述三种解法，第一种没有利用矩阵的性质，所以时间复杂度最差；第二种解法只利用了一部分性质（每一行是一个有序数列，而忽视了列之间的关系）；第三种解法则利用了全部性质，所以时间复杂度最佳。</p><p>这也启示我们要认真把握题目中的条件与性质，更有利于我们解题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。&lt;br&gt;请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年7月" scheme="http://yoursite.com/categories/2020%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Heap" scheme="http://yoursite.com/tags/Heap/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>295. 数据流的中位数</title>
    <link href="http://yoursite.com/2020/07/06/295.%20%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://yoursite.com/2020/07/06/295. 数据流的中位数/</id>
    <published>2020-07-06T07:41:12.000Z</published>
    <updated>2020-07-08T06:46:42.807Z</updated>
    
    <content type="html"><![CDATA[<p>中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。</p><a id="more"></a><h1 id="题目描述（困难难度）"><a href="#题目描述（困难难度）" class="headerlink" title="题目描述（困难难度）"></a>题目描述（困难难度）</h1><p>例如，</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><pre><code>void addNum(int num) - 从数据流中添加一个整数到数据结构中。double findMedian() - 返回目前所有元素的中位数。</code></pre><p>示例：</p><pre><code>addNum(1)addNum(2)findMedian() -&gt; 1.5addNum(3) findMedian() -&gt; 2</code></pre><p>进阶:</p><ul><li>如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法？</li><li>如果数据流中 99% 的整数都在 0 到 100 范围内，你将如何优化你的算法？</li></ul><h1 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h1><p>先分享 <a href="https://leetcode.com/problems/find-median-from-data-stream/solution/" target="_blank" rel="noopener">官方</a> 给我们提供的两个最容易的解法。<a href="https://leetcode.com/problems/find-median-from-data-stream/solution/" target="_blank" rel="noopener">^1</a></p><p>把添加的数字放到 <code>list</code> 中，如果需要返回中位数，把 <code>list</code> 排序即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        list.add(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        <span class="keyword">int</span> n = list.size();</span><br><span class="line">        <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list.get(n / <span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ((<span class="keyword">double</span>) list.get(n / <span class="number">2</span>) + list.get(n / <span class="number">2</span> - <span class="number">1</span>)) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单明了。但是时间复杂度有点儿高，对于 <code>findMedian</code> 函数，因为每次都需要排序。如果是快速排序，那时间复杂度也是 <code>O(nlog(n))</code>。</p><p>这里可以做一个简单的优化。我们不需要每次返回中位数都去排序。我们可以将排序融入到 <code>addNum</code> 中，假设之前已经有序了，然后将添加的数字插入到相应的位置即可。也就是插入排序的思想。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** initialize your data structure here. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 寻找第一个大于 num 的数的下标</span></span><br><span class="line"><span class="keyword">for</span> (; i &lt; list.size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (num &lt; list.get(i)) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将当前数插入</span></span><br><span class="line">list.add(i, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = list.size();</span><br><span class="line"><span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> list.get(n / <span class="number">2</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ((<span class="keyword">double</span>) list.get(n / <span class="number">2</span>) + list.get(n / <span class="number">2</span> - <span class="number">1</span>)) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上边的话 <code>findMedian()</code> 就不需要排序了，时间复杂度就是 <code>O(1)</code>了。对于 <code>addNum()</code> 函数的话时间复杂度就是 <code>O(n)</code> 了。</p><p><code>addNum()</code> 还可以做一点优化。因为我们要在有序数组中寻找第一个大于 <code>num</code> 的下标，提到有序数组找某个值，可以想到二分的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> insert = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = list.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (num &lt;= list.get(mid)) &#123;</span><br><span class="line">            <span class="comment">//判断 num 是否大于等于前边的数</span></span><br><span class="line">            <span class="keyword">int</span> pre = mid &gt; <span class="number">0</span> ? list.get(mid - <span class="number">1</span>) : Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= pre) &#123;</span><br><span class="line">                insert = mid;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (insert == -<span class="number">1</span>) &#123;</span><br><span class="line">        insert = list.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将当前数插入</span></span><br><span class="line">    list.add(insert, num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二分法还需要好好练习，我写的时候有两个小细节没注意就犯错了，一个是<br><code>while (low &lt;= high)</code>另一个是Integer.MIN_VALUE写成了Integer.MAX_VALUE。</p><p>虽然我们使用了二分去查找要插入的位置，对应的时间复杂度是 <code>O(log(n))</code>，但是 <code>list.add(insert, num)</code> 的时间复杂度是 <code>O(n)</code>。所以整体上依旧是 <code>O(n)</code>。</p><p>参考 <a href="https://leetcode.com/problems/find-median-from-data-stream/discuss/74057/Tired-of-TWO-HEAPSET-solutions-See-this-segment-dividing-solution-(c%2B%2B)" target="_blank" rel="noopener">这里</a>，还能继续优化，这个思想也比较常见，分享一下。</p><p>我们每次添加数字的时候，都需要从所有数字中寻找要插入的位置，如果数字太多的话，速度会很慢。</p><p>我们可以将数字分成若干个子序列，类似于下图。</p><p> <a href="https://pic.leetcode-cn.com/5f1bc07eab0823d670c741ae432c6e6728564a90495f01596321c6c6fe66881b.jpg" target="_blank" rel="noopener">将数字分成若干个子序列</a></p><p>上边每一个长方形内数字都是有序的。添加数字的时候，分成两步。先找到数字应该加入的长方形，然后将数字添加到该长方形内。这样做的好处很明显，我们只需要将数字加入长方形内的有序数列中，长方形内的数字个数相对于整个序列会小很多。</p><p>我们可以设置每个长方形内最多存多少数字，如果超过了限制，就将长方形平均分成两个。</p><p>举个简单的例子，接着上图，假设每个长方形内最多存 <code>3</code> 个数字，现在添加数字 <code>9</code>。</p><p>我们首先找到 <code>9</code> 应该属于第 <code>2</code> 个长方形，然后将 <code>9</code> 插入。然后发现此时的数量超过了 <code>3</code> 个，此时我们就把该长方形平均分成两个，如下图。</p><p> <a href="https://pic.leetcode-cn.com/11236f39867ae59fc81e3d46aaa778b11d9c1333b74a413adea1800fed1df15a.jpg" target="_blank" rel="noopener">把该长方形平均分成两个</a></p><p>至于最多存多少，我们可以根据总共有多少个数字来自己设定。但不是很好控制，太小了的话，寻找长方形的时候比较耗时间，太大的话，加入到长方形里的时候比较耗时间。事先不知道数字有多少的话，就更麻烦了。</p><p><a href="https://leetcode.com/stefanpochmann" target="_blank" rel="noopener">StefanPochmann</a>  提出了一个建议。我们可以将大小设置成一个动态的，每个长方形最多存多少根据当前数字的总个数实时改变。假设当前数字总量是 <code>n</code>。长方形里数字个数是 <code>len</code> ，如果 <code>len * len &gt; n</code> ，那么当前长方形就分割为两个。也就是每个长方形最多存 <code>sqrt(n)</code> 个数字。</p><p>这里就偷个懒直接分享下 <a href="https://leetcode.com/mission4success" target="_blank" rel="noopener">@mission4success</a> 的代码。主要就是找长方形以及找中位数那里判断的情况会多一些。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;LinkedList&lt;Integer&gt;&gt; buckets; <span class="comment">// store all ranges</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> total_size;</span><br><span class="line"></span><br><span class="line">    MedianFinder() &#123;</span><br><span class="line">        total_size = <span class="number">0</span>;</span><br><span class="line">        buckets = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        buckets.add(<span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; correctRange = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> targetIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find the correct range to insert given num</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buckets.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (buckets.size() == <span class="number">1</span> ||</span><br><span class="line">                    (i == <span class="number">0</span> &amp;&amp; num &lt;= buckets.get(i).getLast()) ||</span><br><span class="line">                    (i == buckets.size() - <span class="number">1</span> &amp;&amp; num &gt;= buckets.get(i).getFirst()) ||</span><br><span class="line">                    (buckets.get(i).getFirst() &lt;= num &amp;&amp; num &lt;= buckets.get(i).getLast()) ||</span><br><span class="line">                    (num &gt; buckets.get(i).getLast() &amp;&amp; num &lt; buckets.get(i+<span class="number">1</span>).getFirst())) &#123;</span><br><span class="line">                        correctRange = buckets.get(i);</span><br><span class="line">                        targetIndex = i;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// put num at back of correct range, and sort it to keep increasing sequence</span></span><br><span class="line">        total_size++;</span><br><span class="line">        correctRange.add(num);</span><br><span class="line">        Collections.sort(correctRange);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if currentRange's size &gt; threshold, split it into two halves and add them back to buckets</span></span><br><span class="line">        <span class="keyword">int</span> len = correctRange.size();</span><br><span class="line">        <span class="comment">//if (len &gt; 10) &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (len * len &gt; total_size) &#123;</span><br><span class="line">            LinkedList&lt;Integer&gt; half1 = <span class="keyword">new</span> LinkedList&lt;&gt;(correctRange.subList(<span class="number">0</span>, (len) / <span class="number">2</span>));</span><br><span class="line">            LinkedList&lt;Integer&gt; half2 = <span class="keyword">new</span> LinkedList&lt;&gt;(correctRange.subList((len) / <span class="number">2</span>, len));</span><br><span class="line"></span><br><span class="line">            buckets.set(targetIndex, half1); <span class="comment">//replaces</span></span><br><span class="line">            buckets.add(targetIndex + <span class="number">1</span>, half2); <span class="comment">//inserts</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// iterate thru all ranges in buckets to find median value</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (total_size==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid1 = total_size/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> mid2 = mid1 + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftCount=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> first = <span class="number">0.0</span>, second = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; bucket : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftCount&lt;mid1 &amp;&amp; mid1&lt;=leftCount+bucket.size())</span><br><span class="line">                first = bucket.get(mid1 - leftCount - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (leftCount&lt;mid2 &amp;&amp; mid2&lt;=leftCount+bucket.size()) &#123;</span><br><span class="line">                second = bucket.get(mid2 - leftCount - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            leftCount += bucket.size();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (total_size % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> second;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> (first + second)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h1><p>分享 <a href="https://leetcode.com/problems/find-median-from-data-stream/discuss/74166/Solution-using-Binary-Search-Tree" target="_blank" rel="noopener">这里</a> 的解法。</p><p>可以借助二分查找树，二分查找树的性质。</p><blockquote><ol><li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li><li>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li><li>任意节点的左、右子树也分别为二叉查找树；</li><li>没有键值相等的节点。</li></ol></blockquote><p>如果我们将数字存到二分查找树中，当找中位数的时候有一个明显的好处。如果我们知道了左子树的数量 <code>leftNum</code> ，找假设把数据排序后的第 <code>k</code> 个数，<code>k</code> 从 <code>0</code> 计数。</p><p>如果 <code>leftNum == k</code> ，那么根节点就是我们要找的。</p><p>如果 <code>leftNum &gt; k</code>，我们只需要再从左子树中找第 <code>k</code> 个数。</p><p>如果 <code>leftNum &lt; k</code>，我们只需要从右子树中找第 <code>k - leftNum - 1</code> 个数。</p><p>代码的话，我们首先定义一个二分查找树。和普通的二分查找树不同的地方在于，节点多了一个成员变量，记录以当前节点为根节点的二叉树的总节点数量。</p><p>此外实现了 <code>find</code> 函数，来返回有序情况下第 <code>k</code> 个节点的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BST</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">int</span> size;</span><br><span class="line">        Node left, right;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> v) &#123;</span><br><span class="line">            val = v;</span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    BST() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新增节点</span></span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(val);</span><br><span class="line">        <span class="comment">// 当前节点</span></span><br><span class="line">        Node current = root;</span><br><span class="line">        <span class="comment">// 上个节点</span></span><br><span class="line">        Node parent = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 如果根节点为空</span></span><br><span class="line">        <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">            root = newNode;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            parent = current;</span><br><span class="line">            <span class="comment">//向左子树添加节点</span></span><br><span class="line">            <span class="keyword">if</span> (val &lt; current.val) &#123;</span><br><span class="line">                current = current.left;</span><br><span class="line">                parent.size++;</span><br><span class="line">                <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    parent.left = newNode;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">//向右子树添加节点    </span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current = current.right;</span><br><span class="line">                parent.size++;</span><br><span class="line">                <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    parent.right = newNode;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Node t = root;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> leftSize = t.left != <span class="keyword">null</span> ? t.left.size : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (leftSize == k)</span><br><span class="line">                <span class="keyword">return</span> t.val;</span><br><span class="line">            <span class="keyword">if</span> (leftSize &gt; k) &#123;</span><br><span class="line">                t = t.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k = k - leftSize - <span class="number">1</span>;</span><br><span class="line">                t = t.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root.size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line">    BST bst;</span><br><span class="line"></span><br><span class="line">    MedianFinder() &#123;</span><br><span class="line">        bst = <span class="keyword">new</span> BST();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Adds a number into the data structure.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        bst.add(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = bst.size();</span><br><span class="line">        <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((<span class="keyword">double</span>)bst.find(num / <span class="number">2</span>) + bst.find(num / <span class="number">2</span> - <span class="number">1</span>)) / <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> bst.find(num / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度的话，最好的情况 <code>addNum</code> 和 <code>findMedian</code> 都是 <code>O(log(n))</code>。但如果二叉树分布不均，类似于下边这种，那么时间复杂度就都是 <code>O(n)</code> 了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">2</span></span><br><span class="line">   \</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">4</span></span><br></pre></td></tr></table></figure><h1 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h1><p>什么是中位数？如果是偶数个数字，我们把它分成两个集合。左边的集合的所有数字小于右边集合的所有数字。中位数就是左边集合最大数和右边集合最小的数取一个平均数。</p><p>想到上边这个点，会发现我们只关心集合的最大数和最小数，立马就会想到优先队列。</p><p>添加数字的时候，我们把数字放到两个优先队列中。始终保证两个优先队列的大小相等。如果总数是奇数，我们就让左边集合多一个数。</p><p>有了上边的想法可以写代码了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line">    <span class="comment">//左边的队列，每次取最大值</span></span><br><span class="line">    Queue&lt;Integer&gt; leftQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer i1, Integer i2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i2 - i1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//右边的队列，每次取最小值</span></span><br><span class="line">    Queue&lt;Integer&gt; rightQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> median = <span class="number">0</span>; <span class="comment">//保存当前的中位数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> leftSize = leftQueue.size();</span><br><span class="line">        <span class="keyword">int</span> rightSize = rightQueue.size();</span><br><span class="line">        <span class="comment">//如果当前数量相等</span></span><br><span class="line">        <span class="keyword">if</span> (leftSize == rightSize) &#123;</span><br><span class="line">            <span class="comment">//当前没有数字，将将数字加到左半部分</span></span><br><span class="line">            <span class="keyword">if</span> (leftSize == <span class="number">0</span>) &#123;</span><br><span class="line">                leftQueue.add(num);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前数字小于等于右半部分最小的数字, num 属于左边</span></span><br><span class="line">            <span class="keyword">if</span> (num &lt;= rightQueue.peek()) &#123;</span><br><span class="line">                leftQueue.add(num);</span><br><span class="line">            <span class="comment">//当前数字大于右半部分最小的数字, num 应该属于右边    </span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//维持两边平衡. 将右边拿出一个放到左边</span></span><br><span class="line">                leftQueue.add(rightQueue.poll());</span><br><span class="line">                <span class="comment">//将 num 放到右边</span></span><br><span class="line">                rightQueue.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//如果当前数量不等</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//num 大于等于左边最大的数字, num 属于右边</span></span><br><span class="line">            <span class="keyword">if</span> (num &gt;= leftQueue.peek()) &#123;</span><br><span class="line">                rightQueue.add(num);</span><br><span class="line">            <span class="comment">//num 小于左边最大的数字, num 应该属于左边  </span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//维持两边平衡, 左边拿出一个放到右边</span></span><br><span class="line">                rightQueue.add(leftQueue.poll());</span><br><span class="line">                <span class="comment">//左边将 num 放入</span></span><br><span class="line">                leftQueue.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (leftQueue.size() &gt; rightQueue.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> leftQueue.peek();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ((<span class="keyword">double</span>)leftQueue.peek() + rightQueue.peek()) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上边代码由于使用了优先队列，<code>addNum()</code> 的时间复杂度就是 <code>O(log(n))</code>。<code>findMedian()</code>的时间复杂度是 <code>O(1)</code>。上边为了保持两边集合的数量关系，写的代码比较多。再看一下 <a href="https://leetcode.com/problems/find-median-from-data-stream/discuss/74062/Short-simple-JavaC%2B%2BPython-O(log-n)-%2B-O(1)" target="_blank" rel="noopener">stefanpochmann </a> 同样思路下的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Long&gt; left = <span class="keyword">new</span> PriorityQueue(),</span><br><span class="line">    right = <span class="keyword">new</span> PriorityQueue();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        left.add((<span class="keyword">long</span>) num);</span><br><span class="line">        right.add(-left.poll());</span><br><span class="line">        <span class="keyword">if</span> (left.size() &lt; right.size())</span><br><span class="line">            left.add(-right.poll());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left.size() &gt; right.size()</span><br><span class="line">            ? left.peek()</span><br><span class="line">            : (left.peek() - right.peek()) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>简洁而优雅，这大概就是艺术吧。</p><p>他首先将数字加入到左边，然后再拿一个数字加到右边。然后判断一下左边数量是否小于右边，如果是的话将从右边拿回一个放到左边。</p><p>当加入新的数字之前，不管两边集合数字的数量相等，还是左边比右边多一个。通过上边的代码，依旧可以保证添加完数字以后两边的数量相等或者左边比右边多一个。</p><p>还使用了一个技巧，会发现它是用了两个默认的优先队列。对于右边的优先队列添加元素的时候将原来的数字取了相反数。这样做的好处就是，不管默认的优先队列是取最大数，还是取最小数。由于其中一个添加元素使用的是相反数，最终实现的效果就是两个优先队列一定是相反的效果。如果其中一个是取最小数，另外一个就是取最大数。</p><p>因为使用了相反数，对于 <code>-Integer.MIN_VALUE</code> 会溢出，所以我们添加元素的时候强转成了 <code>long</code>。</p><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>If all integer numbers from the stream are between 0 and 100, how would you optimize it?</p><p>分享 <a href="https://leetcode.com/problems/find-median-from-data-stream/discuss/286238/Java-Simple-Code-Follow-Up" target="_blank" rel="noopener">这里</a> 的思路。</p><p>这样的话，我们可以用一个数组，<code>num[i]</code>记录数字 <code>i</code> 的数量。此外用一个变量 <code>n</code> 统计当前数字的总数量。这样求中位数的时候，我们只需要找到第 <code>n/2+1</code>个数或者 <code>n/2,n/2+1</code>个数即可。注意因为这里计数是从<code>1</code> 开始的，所以和解法一看起来找到数字不一样，解法一找的是下标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] backets = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">101</span>];</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        backets[num]++;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//如果是 5 个数，就寻找第 5 / 2 + 1 = 3 个数</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            count += backets[right];</span><br><span class="line">            <span class="keyword">if</span> (count &gt;= n / <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//奇数的情况直接返回</span></span><br><span class="line">        <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是 4 个数, 之前找到了第 4/2+1=3 个数, 还需要前一个数</span></span><br><span class="line">        <span class="keyword">int</span> left;</span><br><span class="line">        <span class="comment">//如果之前找的数只占一个, 向前寻找上一个数</span></span><br><span class="line">       <span class="keyword">if</span> (backets[right] == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = right - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (backets[temp] == <span class="number">0</span>) &#123;</span><br><span class="line">temp--;</span><br><span class="line">&#125;</span><br><span class="line">left = temp;</span><br><span class="line">        <span class="comment">//如果之前找的数占多个, 前一个数等于当前数</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">left = right;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">return</span> (left + right) / <span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?</p><p>这个也没有说清楚，我们假设一种简单的情况。当调用 <code>findMedian</code> 的时候，解一定落在 <code>0 - 100</code> 之中。那么接着上边的代码，我们只需要增加一个变量 <code>less</code>，记录小于 <code>0</code> 的个数。原来找第 <code>n / 2 + 1</code> 个数，现在找第<code>n/2 - less + 1</code>就可以了。</p><p>如果调用 <code>findMedian</code> 的时候解落在哪里不一定，那么我们就增加两个 <code>list</code> 分别来保存小于 <code>0</code> 和大于 <code>100</code> 的数即可。</p><h1 id="再扩展"><a href="#再扩展" class="headerlink" title="再扩展"></a>再扩展</h1><p>题目说的是从数据流中找到中位数。如果这个数据流很大，很大，无法全部加载到内存呢？</p><p>分享 <a href="https://stackoverflow.com/questions/10657503/find-running-median-from-a-stream-of-integers/10693752#10693752" target="_blank" rel="noopener">这里</a> 的想法。</p><p>如果数据整体呈某种概率分布，比如正态分布。我们可以通过 <strong>蓄水池抽样</strong><a href="https://www.jianshu.com/p/7a9ea6ece2af" target="_blank" rel="noopener">^2</a><code>reservoir sampling</code> 的方法。我们保存固定数量的数字，当存满的时候，就随机替代掉某个数字。伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;  <span class="comment">// Running count of elements observed so far  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 10000</span></span><br><span class="line"><span class="keyword">int</span> reservoir[SIZE];  </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(streamHasData())</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> x = readNumberFromStream();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt; SIZE)</span><br><span class="line">  &#123;</span><br><span class="line">       reservoir[n++] = x;</span><br><span class="line">  &#125;         </span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">int</span> p = random(++n); <span class="comment">// Choose a random number 0 &gt;= p &lt; n</span></span><br><span class="line">      <span class="keyword">if</span> (p &lt; SIZE)</span><br><span class="line">      &#123;</span><br><span class="line">           reservoir[p] = x;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于从一个大的数据集下进行了取样，然后找中位数的时候，把我们保存的数组排个序去找就可以了。</p><p>算法思路大致如下：</p><ol><li>如果接收的数据量小于m，则依次放入蓄水池。</li><li>当接收到第i个数据时，i &gt;= m，在[0, i]范围内取以随机数d，若d的落在[0, m-1]范围内，则用接收到的第i个数据替换蓄水池中的第d个数据。</li><li>重复步骤2。</li></ol><p>算法的精妙之处在于：当处理完所有的数据时，蓄水池中的每个数据都是以m/N的概率获得的。</p><h1 id="字节AML后端开发终面：变形题"><a href="#字节AML后端开发终面：变形题" class="headerlink" title="字节AML后端开发终面：变形题"></a>字节AML后端开发终面：变形题</h1><p>在本题基础上增加erase功能，需要把堆改成BST（即set），保证删除性能</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总结了好多，但 <a href="https://leetcode.com/problems/find-median-from-data-stream/solution/" target="_blank" rel="noopener">Solution</a> 里提到的还有一些没有介绍，主要就是涉及到一些新的数据结构，比如 <code>Multiset</code> 、<code>Segment Trees</code> 和 <code>Order Statistic Trees</code>。</p><p>针对这道题最优的话还是优先队列比较好，既简单，又容易想到。其他的解法可以当扩展思路了，其中用到的一些思想都很有意思。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年7月" scheme="http://yoursite.com/categories/2020%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Heap" scheme="http://yoursite.com/tags/Heap/"/>
    
      <category term="Design" scheme="http://yoursite.com/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>215. 数组中的第K个最大元素</title>
    <link href="http://yoursite.com/2020/07/06/215.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2020/07/06/215. 数组中的第K个最大元素/</id>
    <published>2020-07-06T01:36:12.000Z</published>
    <updated>2020-07-07T09:35:40.395Z</updated>
    
    <content type="html"><![CDATA[<p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。此题比较经典，对于两种解法我还有些没吃透，需要再次认真温习。</p><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>示例 1:</p><pre><code>输入: [3,2,1,5,6,4] 和 k = 2输出: 5</code></pre><p>示例 2:</p><pre><code>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4</code></pre><p>说明:</p><pre><code>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</code></pre><h1 id="📖文字题解"><a href="#📖文字题解" class="headerlink" title="📖文字题解"></a>📖文字题解</h1><ul><li><p>约定：假设这里数组的长度为 <em>n</em>。</p></li><li><p>题目分析：本题希望我们返回数组排序之后的倒数第 <em>k</em> 个位置。</p></li></ul><h4 id="方法一：基于快速排序的选择方法"><a href="#方法一：基于快速排序的选择方法" class="headerlink" title="方法一：基于快速排序的选择方法"></a>方法一：基于快速排序的选择方法</h4><p><strong>思路和算法</strong></p><p>我们可以用快速排序来解决这个问题，先对原数组排序，再返回倒数第 <em>k</em> 个位置，这样平均时间复杂度是 O(nlogn)  ，但其实我们可以做的更快。</p><p>首先我们来回顾一下快速排序，这是一个典型的分治算法。我们对数组 a[l…r]做快速排序的过程是（参考《算法导论》）：</p><ul><li><strong>分解：</strong> 将数组 a[l…r] 「划分」成两个子数组 a[l…q-1]<br>、a[q+1…r]，使得 a[l…q-1]中的每个元素小于等于 <em>a[q]*，且 *a[q]</em> 小于等于a[q+1…r]中的每个元素。其中，计算下标 <em>q</em> 也是「划分」过程的一部分。</li><li><strong>解决：</strong> 通过递归调用快速排序，对子数组 a[l…q-1]<br>、a[q+1…r] 进行排序。</li><li><strong>合并：</strong> 因为子数组都是原址排序的，所以不需要进行合并操作，a[l…r]  已经有序。</li><li>上文中提到的 <strong>「划分」</strong> 过程是：从子数组 a[l…r]   中选择任意一个元素 <em>x</em> 作为主元，<strong>调整子数组的元素使得左边的元素都小于等于它，右边的元素都大于等于它，</strong> <em>x</em> 的最终位置就是 <em>q</em>。</li></ul><p>由此可以发现每次经过「划分」操作后，我们一定可以确定一个元素的最终位置，即 <em>x</em> 的最终位置为 <em>q</em>，并且保证 a[l…q-1] 中的每个元素小于等于 <em>a[q]*，且 *a[q]</em> 小于等于 a[q+1…r]中的每个元素。<strong>所以只要某次划分的 <em>q</em> 为倒数第 <em>k</em> 个下标的时候，我们就已经找到了答案。</strong> 我们只关心这一点，至于 a[l…q-1] 和a[q+1…r]  是否是有序的，我们不关心。</p><p>因此我们可以改进快速排序算法来解决这个问题：在分解的过程当中，我们会对子数组进行划分，如果划分得到的 <em>q</em> 正好就是我们需要的下标，就直接返回 <em>a[q]*；否则，如果 *q</em> 比目标下标小，就递归右子区间，否则递归左子区间。这样就可以把原来递归两个区间变成只递归一个区间，提高了时间效率。这就是「快速选择」算法。</p><p>我们知道快速排序的性能和「划分」出的子数组的长度密切相关。直观地理解如果每次规模为 <em>n</em> 的问题我们都划分成 <em>1</em> 和 <em>n - 1*，每次递归的时候又向 *n - 1</em> 的集合中递归，这种情况是最坏的，时间代价是 <em>O(n ^ 2)</em>。我们可以引入随机化来加速这个过程，它的时间代价的期望是 <em>O(n)</em>，证明过程可以参考「《算法导论》9.2：期望为线性的选择算法」。</p><p>我试了一下<code>Arrays.sort(nums);</code>居然也过了，因为题目并没有要求不能用库函数所以其实两行代码就能解决问题</p><p><strong>代码</strong></p><figure class="highlight cpp"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">quickSelect</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> q = randomPartition(a, l, r);</span><br><span class="line">        <span class="keyword">if</span> (q == index) &#123;</span><br><span class="line">            <span class="keyword">return</span> a[q];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> q &lt; index ? quickSelect(a, q + <span class="number">1</span>, r, index) : quickSelect(a, l, q - <span class="number">1</span>, index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">randomPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = rand() % (r - l + <span class="number">1</span>) + l;</span><br><span class="line">        swap(a[i], a[r]);</span><br><span class="line">        <span class="keyword">return</span> partition(a, l, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = a[r], i = l - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = l; j &lt; r; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt;= x) &#123;</span><br><span class="line">                swap(a[++i], a[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a[i + <span class="number">1</span>], a[r]);</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        srand(time(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span> quickSelect(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>, nums.size() - k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> quickSelect(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, nums.length - k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">quickSelect</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> q = randomPartition(a, l, r);</span><br><span class="line">        <span class="keyword">if</span> (q == index) &#123;</span><br><span class="line">            <span class="keyword">return</span> a[q];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> q &lt; index ? quickSelect(a, q + <span class="number">1</span>, r, index) : quickSelect(a, l, q - <span class="number">1</span>, index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">randomPartition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = random.nextInt(r - l + <span class="number">1</span>) + l;</span><br><span class="line">        swap(a, i, r);</span><br><span class="line">        <span class="keyword">return</span> partition(a, l, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = a[r], i = l - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = l; j &lt; r; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt;= x) &#123;</span><br><span class="line">                swap(a, ++i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a, i + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = a[r], i = l - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = l; j &lt; r; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[j] &lt;= x) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = a[++i];</span><br><span class="line">            a[i] = a[j], a[j] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t = a[i + <span class="number">1</span>];</span><br><span class="line">    a[i + <span class="number">1</span>] = a[r], a[r] = t;</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">randomPartition</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = rand() % (r - l + <span class="number">1</span>) + l;</span><br><span class="line">    <span class="keyword">int</span> t = a[i];</span><br><span class="line">    a[i] = a[r], a[r] = t;</span><br><span class="line">    <span class="keyword">return</span> partition(a, l, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quickSelect</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q = randomPartition(a, l, r);</span><br><span class="line">    <span class="keyword">if</span> (q == index) &#123;</span><br><span class="line">        <span class="keyword">return</span> a[q];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> q &lt; index ? quickSelect(a, q + <span class="number">1</span>, r, index)</span><br><span class="line">                         : quickSelect(a, l, q - <span class="number">1</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> quickSelect(nums, <span class="number">0</span>, numsSize - <span class="number">1</span>, numsSize - k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findKthLargest</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    <span class="keyword">return</span> quickSelect(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>, <span class="built_in">len</span>(nums)-k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSelect</span><span class="params">(a []<span class="keyword">int</span>, l, r, index <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    q := randomPartition(a, l, r)</span><br><span class="line">    <span class="keyword">if</span> q == index &#123;</span><br><span class="line">        <span class="keyword">return</span> a[q]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> q &lt; index &#123;</span><br><span class="line">        <span class="keyword">return</span> quickSelect(a, q + <span class="number">1</span>, r, index)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> quickSelect(a, l, q - <span class="number">1</span>, index)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomPartition</span><span class="params">(a []<span class="keyword">int</span>, l, r <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    i := rand.Int() % (r - l + <span class="number">1</span>) + l</span><br><span class="line">    a[i], a[r] = a[r], a[i]</span><br><span class="line">    <span class="keyword">return</span> partition(a, l, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(a []<span class="keyword">int</span>, l, r <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    x := a[r]</span><br><span class="line">    i := l - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j := l; j &lt; r; j++ &#123;</span><br><span class="line">        <span class="keyword">if</span> a[j] &lt;= x &#123;</span><br><span class="line">            i++</span><br><span class="line">            a[i], a[j] = a[j], a[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[i+<span class="number">1</span>], a[r] = a[r], a[i+<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(n)</em>，如上文所述，证明过程可以参考「《算法导论》9.2：期望为线性的选择算法」。</li><li>空间复杂度：O(logn)，递归使用栈空间的空间代价的期望为O(logn)。</li></ul><h4 id="方法二：基于堆排序的选择方法"><a href="#方法二：基于堆排序的选择方法" class="headerlink" title="方法二：基于堆排序的选择方法"></a>方法二：基于堆排序的选择方法</h4><p><strong>思路和算法</strong></p><p>我们也可以使用堆排序来解决这个问题——建立一个大根堆，做 <em>k - 1</em> 次删除操作后堆顶元素就是我们要找的答案。在很多语言中，都有优先队列或者堆的的容器可以直接使用，但是在面试中，面试官更倾向于让更面试者自己实现一个堆。所以建议读者掌握这里大根堆的实现方法，在这道题中尤其要搞懂「建堆」、「调整」和「删除」的过程。</p><p><strong>友情提醒：「堆排」在很多大公司的面试中都很常见，不了解的同学建议参考《算法导论》或者大家的数据结构教材，一定要学会这个知识点哦! ^_^</strong></p><p>  <a href="https://assets.leetcode-cn.com/solution-static/215/1.png" target="_blank" rel="noopener">fig1</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/2.png" target="_blank" rel="noopener">fig2</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/3.png" target="_blank" rel="noopener">fig3</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/4.png" target="_blank" rel="noopener">fig4</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/5.png" target="_blank" rel="noopener">fig5</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/6.png" target="_blank" rel="noopener">fig6</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/7.png" target="_blank" rel="noopener">fig7</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/8.png" target="_blank" rel="noopener">fig8</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/9.png" target="_blank" rel="noopener">fig9</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/10.png" target="_blank" rel="noopener">fig10</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/11.png" target="_blank" rel="noopener">fig11</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/12.png" target="_blank" rel="noopener">fig12</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/13.png" target="_blank" rel="noopener">fig13</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/14.png" target="_blank" rel="noopener">fig14</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/15.png" target="_blank" rel="noopener">fig15</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/16.png" target="_blank" rel="noopener">fig16</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/17.png" target="_blank" rel="noopener">fig17</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/18.png" target="_blank" rel="noopener">fig18</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/19.png" target="_blank" rel="noopener">fig19</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/20.png" target="_blank" rel="noopener">fig20</a> </p><p><strong>代码</strong></p><figure class="highlight cpp"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> i, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = i * <span class="number">2</span> + <span class="number">1</span>, r = i * <span class="number">2</span> + <span class="number">2</span>, largest = i;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; heapSize &amp;&amp; a[l] &gt; a[largest]) &#123;</span><br><span class="line">            largest = l;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (r &lt; heapSize &amp;&amp; a[r] &gt; a[largest]) &#123;</span><br><span class="line">            largest = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            swap(a[i], a[largest]);</span><br><span class="line">            maxHeapify(a, largest, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = heapSize / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            maxHeapify(a, i, heapSize);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> heapSize = nums.size();</span><br><span class="line">        buildMaxHeap(nums, heapSize);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt;= nums.size() - k + <span class="number">1</span>; --i) &#123;</span><br><span class="line">            swap(nums[<span class="number">0</span>], nums[i]);</span><br><span class="line">            --heapSize;</span><br><span class="line">            maxHeapify(nums, <span class="number">0</span>, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> heapSize = nums.length;</span><br><span class="line">        buildMaxHeap(nums, heapSize);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= nums.length - k + <span class="number">1</span>; --i) &#123;</span><br><span class="line">            swap(nums, <span class="number">0</span>, i);</span><br><span class="line">            --heapSize;</span><br><span class="line">            maxHeapify(nums, <span class="number">0</span>, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = heapSize / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            maxHeapify(a, i, heapSize);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = i * <span class="number">2</span> + <span class="number">1</span>, r = i * <span class="number">2</span> + <span class="number">2</span>, largest = i;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; heapSize &amp;&amp; a[l] &gt; a[largest]) &#123;</span><br><span class="line">            largest = l;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (r &lt; heapSize &amp;&amp; a[r] &gt; a[largest]) &#123;</span><br><span class="line">            largest = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            swap(a, i, largest);</span><br><span class="line">            maxHeapify(a, largest, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> i, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = i * <span class="number">2</span> + <span class="number">1</span>, r = i * <span class="number">2</span> + <span class="number">2</span>, largest = i;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; heapSize &amp;&amp; a[l] &gt; a[largest]) &#123;</span><br><span class="line">        largest = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; heapSize &amp;&amp; a[r] &gt; a[largest]) &#123;</span><br><span class="line">        largest = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = a[i];</span><br><span class="line">        a[i] = a[largest], a[largest] = t;</span><br><span class="line">        maxHeapify(a, largest, heapSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = heapSize / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        maxHeapify(a, i, heapSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> heapSize = numsSize;</span><br><span class="line">    buildMaxHeap(nums, heapSize);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = numsSize - <span class="number">1</span>; i &gt;= numsSize - k + <span class="number">1</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = nums[<span class="number">0</span>];</span><br><span class="line">        nums[<span class="number">0</span>] = nums[i], nums[i] = t;</span><br><span class="line">        --heapSize;</span><br><span class="line">        maxHeapify(nums, <span class="number">0</span>, heapSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findKthLargest</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    heapSize := <span class="built_in">len</span>(nums)</span><br><span class="line">    buildMaxHeap(nums, heapSize)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(nums) - <span class="number">1</span>; i &gt;= <span class="built_in">len</span>(nums) - k + <span class="number">1</span>; i-- &#123;</span><br><span class="line">        nums[<span class="number">0</span>], nums[i] = nums[i], nums[<span class="number">0</span>]</span><br><span class="line">        heapSize--</span><br><span class="line">        maxHeapify(nums, <span class="number">0</span>, heapSize)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildMaxHeap</span><span class="params">(a []<span class="keyword">int</span>, heapSize <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := heapSize/<span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        maxHeapify(a, i, heapSize)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxHeapify</span><span class="params">(a []<span class="keyword">int</span>, i, heapSize <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    l, r, largest := i * <span class="number">2</span> + <span class="number">1</span>, i * <span class="number">2</span> + <span class="number">2</span>, i</span><br><span class="line">    <span class="keyword">if</span> l &lt; heapSize &amp;&amp; a[l] &gt; a[largest] &#123;</span><br><span class="line">        largest = l</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> r &lt; heapSize &amp;&amp; a[r] &gt; a[largest] &#123;</span><br><span class="line">        largest = r</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> largest != i &#123;</span><br><span class="line">        a[i], a[largest] = a[largest], a[i]</span><br><span class="line">        maxHeapify(a, largest, heapSize)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(nlogn) ，建堆的时间代价是 <em>O(n)</em>，删除的总代价是 O(klogn) ，因为 <em>k &lt; n</em>，故渐进时间复杂为 O(n+klogn) 。</li><li>空间复杂度：O(nlogn)，即递归使用栈空间的空间代价。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。此题比较经典，对于两种解法我还有些没吃透，需要再次认真温习。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年7月" scheme="http://yoursite.com/categories/2020%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Heap" scheme="http://yoursite.com/tags/Heap/"/>
    
      <category term="Divide and Conquer" scheme="http://yoursite.com/tags/Divide-and-Conquer/"/>
    
  </entry>
  
  <entry>
    <title>238. 除自身以外数组的乘积</title>
    <link href="http://yoursite.com/2020/07/02/238.%20%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF/"/>
    <id>http://yoursite.com/2020/07/02/238. 除自身以外数组的乘积/</id>
    <published>2020-07-02T14:52:12.000Z</published>
    <updated>2020-07-02T14:38:21.897Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。</p><a id="more"></a><p>示例:</p><pre><code>输入: [1,2,3,4]输出: [24,12,8,6]提示：题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。</code></pre><p>进阶：</p><p>你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）</p><h3 id="📺视频题解"><a href="#📺视频题解" class="headerlink" title="📺视频题解"></a>📺视频题解</h3><p> <a href="5f8f385b-1288-4c91-8a65-e7490a96764c">238.除自身以外数组的乘积.mp4</a></p><h3 id="📖文字题解"><a href="#📖文字题解" class="headerlink" title="📖文字题解"></a>📖文字题解</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>这似乎是一个简单的问题，可以在线性时间和空间内解决。先计算给定数组所有元素的乘积，然后对数组中的每个元素 <em>x</em>，将总的乘积除以 <em>x</em> 来求得除自身值的以外数组的乘积。</p><p>然而这样的解决方法有一个问题，就是如果输入数组中出现 0，那么这个方法就失效了。而且在问题中说明了不允许使用除法运算。这增加了这个问题的难度。</p><h4 id="方法一：左右乘积列表"><a href="#方法一：左右乘积列表" class="headerlink" title="方法一：左右乘积列表"></a>方法一：左右乘积列表</h4><p><strong>思路</strong></p><p>我们不必将所有数字的乘积除以给定索引处的数字得到相应的答案，而是利用索引左侧所有数字的乘积和右侧所有数字的乘积（即前缀与后缀）相乘得到答案。</p><p>对于给定索引 <em>i</em>，我们将使用它左边所有数字的乘积乘以右边所有数字的乘积。下面让我们更加具体的描述这个算法。</p><p><strong>算法</strong></p><ol><li>初始化两个空数组 <code>L</code> 和 <code>R</code>。对于给定索引 <code>i</code>，<code>L[i]</code> 代表的是 <code>i</code> 左侧所有数字的乘积，<code>R[i]</code> 代表的是 <code>i</code> 右侧所有数字的乘积。</li><li>我们需要用两个循环来填充 <code>L</code> 和 <code>R</code> 数组的值。对于数组 <code>L</code>，<code>L[0]</code> 应该是 <code>1</code>，因为第一个元素的左边没有元素。对于其他元素：<code>L[i] = L[i-1] * nums[i-1]</code>。</li><li>同理，对于数组 <code>R</code>，<code>R[length-1]</code> 应为 <code>1</code>。<code>length</code> 指的是输入数组的大小。其他元素：<code>R[i] = R[i+1] * nums[i+1]</code>。</li><li>当 <code>R</code> 和 <code>L</code> 数组填充完成，我们只需要在输入数组上迭代，且索引 <code>i</code> 处的值为：<code>L[i] * R[i]</code>。</li></ol><p>让我们用以下图片看看算法是如何工作的：</p><p>  <a href="https://assets.leetcode-cn.com/solution-static/238/1.PNG" target="_blank" rel="noopener">fig1</a>  <a href="https://assets.leetcode-cn.com/solution-static/238/2.PNG" target="_blank" rel="noopener">fig2</a>  <a href="https://assets.leetcode-cn.com/solution-static/238/3.PNG" target="_blank" rel="noopener">fig3</a>  <a href="https://assets.leetcode-cn.com/solution-static/238/4.PNG" target="_blank" rel="noopener">fig4</a>  <a href="https://assets.leetcode-cn.com/solution-static/238/5.PNG" target="_blank" rel="noopener">fig5</a>  <a href="https://assets.leetcode-cn.com/solution-static/238/6.PNG" target="_blank" rel="noopener">fig6</a>  <a href="https://assets.leetcode-cn.com/solution-static/238/7.PNG" target="_blank" rel="noopener">fig7</a>  <a href="https://assets.leetcode-cn.com/solution-static/238/8.PNG" target="_blank" rel="noopener">fig8</a>  <a href="https://assets.leetcode-cn.com/solution-static/238/9.PNG" target="_blank" rel="noopener">fig9</a>  <a href="https://assets.leetcode-cn.com/solution-static/238/10.PNG" target="_blank" rel="noopener">fig10</a> </p><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; productExceptSelf(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// L 和 R 分别表示左右两侧的乘积列表</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; L(length, <span class="number">0</span>), R(length, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; answer(length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// L[i] 为索引 i 左侧所有元素的乘积</span></span><br><span class="line">        <span class="comment">// 对于索引为 '0' 的元素，因为左侧没有元素，所以 L[0] = 1</span></span><br><span class="line">        L[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            L[i] = nums[i - <span class="number">1</span>] * L[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// R[i] 为索引 i 右侧所有元素的乘积</span></span><br><span class="line">        <span class="comment">// 对于索引为 'length-1' 的元素，因为右侧没有元素，所以 R[length-1] = 1</span></span><br><span class="line">        R[length - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            R[i] = nums[i + <span class="number">1</span>] * R[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于索引 i，除 nums[i] 之外其余各元素的乘积就是左侧所有元素的乘积乘以右侧所有元素的乘积</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            answer[i] = L[i] * R[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        length = len(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># L 和 R 分别表示左右两侧的乘积列表</span></span><br><span class="line">        L, R, answer = [<span class="number">0</span>]*length, [<span class="number">0</span>]*length, [<span class="number">0</span>]*length</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># L[i] 为索引 i 左侧所有元素的乘积</span></span><br><span class="line">        <span class="comment"># 对于索引为 '0' 的元素，因为左侧没有元素，所以 L[0] = 1</span></span><br><span class="line">        L[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, length):</span><br><span class="line">            L[i] = nums[i - <span class="number">1</span>] * L[i - <span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># R[i] 为索引 i 右侧所有元素的乘积</span></span><br><span class="line">        <span class="comment"># 对于索引为 'length-1' 的元素，因为右侧没有元素，所以 R[length-1] = 1</span></span><br><span class="line">        R[length - <span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(length - <span class="number">1</span>)):</span><br><span class="line">            R[i] = nums[i + <span class="number">1</span>] * R[i + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对于索引 i，除 nums[i] 之外其余各元素的乘积就是左侧所有元素的乘积乘以右侧所有元素的乘积</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">            answer[i] = L[i] * R[i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// L 和 R 分别表示左右两侧的乘积列表</span></span><br><span class="line">        <span class="keyword">int</span>[] L = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">int</span>[] R = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// L[i] 为索引 i 左侧所有元素的乘积</span></span><br><span class="line">        <span class="comment">// 对于索引为 '0' 的元素，因为左侧没有元素，所以 L[0] = 1</span></span><br><span class="line">        L[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            L[i] = nums[i - <span class="number">1</span>] * L[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// R[i] 为索引 i 右侧所有元素的乘积</span></span><br><span class="line">        <span class="comment">// 对于索引为 'length-1' 的元素，因为右侧没有元素，所以 R[length-1] = 1</span></span><br><span class="line">        R[length - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            R[i] = nums[i + <span class="number">1</span>] * R[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于索引 i，除 nums[i] 之外其余各元素的乘积就是左侧所有元素的乘积乘以右侧所有元素的乘积</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            answer[i] = L[i] * R[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">productExceptSelf</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    length := <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// L 和 R 分别表示左右两侧的乘积列表</span></span><br><span class="line">    L, R, answer := <span class="built_in">make</span>([]<span class="keyword">int</span>, length), <span class="built_in">make</span>([]<span class="keyword">int</span>, length), <span class="built_in">make</span>([]<span class="keyword">int</span>, length)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// L[i] 为索引 i 左侧所有元素的乘积</span></span><br><span class="line">    <span class="comment">// 对于索引为 '0' 的元素，因为左侧没有元素，所以 L[0] = 1</span></span><br><span class="line">    L[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; length; i++ &#123;</span><br><span class="line">        L[i] = nums[i<span class="number">-1</span>] * L[i<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R[i] 为索引 i 右侧所有元素的乘积</span></span><br><span class="line">    <span class="comment">// 对于索引为 'length-1' 的元素，因为右侧没有元素，所以 R[length-1] = 1</span></span><br><span class="line">    R[length<span class="number">-1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        R[i] = nums[i+<span class="number">1</span>] * R[i+<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对于索引 i，除 nums[i] 之外其余各元素的乘积就是左侧所有元素的乘积乘以右侧所有元素的乘积</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line">        answer[i] = L[i] * R[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><figcaption><span>[sol1-TypeScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> productExceptSelf = <span class="function"><span class="keyword">function</span>(<span class="params">nums: <span class="built_in">number</span>[]</span>): <span class="title">number</span>[] </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> length = nums.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// L 和 R 分别表示左右两侧的乘积列表</span></span><br><span class="line">    <span class="keyword">const</span> L = <span class="keyword">new</span> <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt;(length);</span><br><span class="line">    <span class="keyword">const</span> R = <span class="keyword">new</span> <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt;(length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> answer = <span class="keyword">new</span> <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt;(length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// L[i] 为索引 i 左侧所有元素的乘积</span></span><br><span class="line">    <span class="comment">// 对于索引为 '0' 的元素，因为左侧没有元素，所以 L[0] = 1</span></span><br><span class="line">    L[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">        L[i] = nums[i - <span class="number">1</span>] * L[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R[i] 为索引 i 右侧所有元素的乘积</span></span><br><span class="line">    <span class="comment">// 对于索引为 'length-1' 的元素，因为右侧没有元素，所以 R[length-1] = 1</span></span><br><span class="line">    R[length - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        R[i] = nums[i + <span class="number">1</span>] * R[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于索引 i，除 nums[i] 之外其余各元素的乘积就是左侧所有元素的乘积乘以右侧所有元素的乘积</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        answer[i] = L[i] * R[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(N)*，其中 *N</em> 指的是数组 <code>nums</code> 的大小。预处理 <code>L</code> 和 <code>R</code> 数组以及最后的遍历计算都是 <em>O(N)</em> 的时间复杂度。</li><li>空间复杂度：<em>O(N)*，其中 *N</em> 指的是数组 <code>nums</code> 的大小。使用了 <code>L</code> 和 <code>R</code> 数组去构造答案，<code>L</code> 和 <code>R</code> 数组的长度为数组 <code>nums</code> 的大小。</li></ul><h4 id="方法二：空间复杂度-O-1-的方法"><a href="#方法二：空间复杂度-O-1-的方法" class="headerlink" title="方法二：空间复杂度 O(1) 的方法"></a>方法二：空间复杂度 <em>O(1)</em> 的方法</h4><p><strong>思路</strong></p><p>尽管上面的方法已经能够很好的解决这个问题，但是空间复杂度并不为常数。</p><p>由于输出数组不算在空间复杂度内，那么我们可以将 <code>L</code> 或 <code>R</code> 数组用输出数组来计算。先把输出数组当作 <code>L</code> 数组来计算，然后再动态构造 <code>R</code> 数组得到结果。让我们来看看基于这个思想的算法。</p><p><strong>算法</strong></p><ol><li>初始化 <code>answer</code> 数组，对于给定索引 <code>i</code>，<code>answer[i]</code> 代表的是 <code>i</code> 左侧所有数字的乘积。</li><li>构造方式与之前相同，只是我们试图节省空间，先把 <code>answer</code> 作为方法一的 <code>L</code> 数组。</li><li>这种方法的唯一变化就是我们没有构造 <code>R</code> 数组。而是用一个遍历来跟踪右边元素的乘积。并更新数组 <em>answer[i]=answer[i]<em>R</em>。然后 *R</em> 更新为 <em>R=R<em>nums[i]</em>，其中变量 *R</em> 表示的就是索引右侧数字的乘积。</li></ol><figure class="highlight cpp"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; productExceptSelf(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; answer(length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// answer[i] 表示索引 i 左侧所有元素的乘积</span></span><br><span class="line">        <span class="comment">// 因为索引为 '0' 的元素左侧没有元素， 所以 answer[0] = 1</span></span><br><span class="line">        answer[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            answer[i] = nums[i - <span class="number">1</span>] * answer[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// R 为右侧所有元素的乘积</span></span><br><span class="line">        <span class="comment">// 刚开始右边没有元素，所以 R = 1</span></span><br><span class="line">        <span class="keyword">int</span> R = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R</span></span><br><span class="line">            answer[i] = answer[i] * R;</span><br><span class="line">            <span class="comment">// R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上</span></span><br><span class="line">            R *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        length = len(nums)</span><br><span class="line">        answer = [<span class="number">0</span>]*length</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># answer[i] 表示索引 i 左侧所有元素的乘积</span></span><br><span class="line">        <span class="comment"># 因为索引为 '0' 的元素左侧没有元素， 所以 answer[0] = 1</span></span><br><span class="line">        answer[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, length):</span><br><span class="line">            answer[i] = nums[i - <span class="number">1</span>] * answer[i - <span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># R 为右侧所有元素的乘积</span></span><br><span class="line">        <span class="comment"># 刚开始右边没有元素，所以 R = 1</span></span><br><span class="line">        R = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(length)):</span><br><span class="line">            <span class="comment"># 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R</span></span><br><span class="line">            answer[i] = answer[i] * R</span><br><span class="line">            <span class="comment"># R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上</span></span><br><span class="line">            R *= nums[i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// answer[i] 表示索引 i 左侧所有元素的乘积</span></span><br><span class="line">        <span class="comment">// 因为索引为 '0' 的元素左侧没有元素， 所以 answer[0] = 1</span></span><br><span class="line">        answer[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            answer[i] = nums[i - <span class="number">1</span>] * answer[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// R 为右侧所有元素的乘积</span></span><br><span class="line">        <span class="comment">// 刚开始右边没有元素，所以 R = 1</span></span><br><span class="line">        <span class="keyword">int</span> R = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R</span></span><br><span class="line">            answer[i] = answer[i] * R;</span><br><span class="line">            <span class="comment">// R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上</span></span><br><span class="line">            R *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">productExceptSelf</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    length := <span class="built_in">len</span>(nums)</span><br><span class="line">    answer := <span class="built_in">make</span>([]<span class="keyword">int</span>, length)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// answer[i] 表示索引 i 左侧所有元素的乘积</span></span><br><span class="line">    <span class="comment">// 因为索引为 '0' 的元素左侧没有元素， 所以 answer[0] = 1</span></span><br><span class="line">    answer[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; length; i++ &#123;</span><br><span class="line">        answer[i] = nums[i<span class="number">-1</span>] * answer[i<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R 为右侧所有元素的乘积</span></span><br><span class="line">    <span class="comment">// 刚开始右边没有元素，所以 R = 1</span></span><br><span class="line">    R := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="comment">// 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R</span></span><br><span class="line">        answer[i] = answer[i] * R</span><br><span class="line">        <span class="comment">// R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上</span></span><br><span class="line">        R *= nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><figcaption><span>[sol2-TypeScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> productExceptSelf = <span class="function"><span class="keyword">function</span>(<span class="params">nums: <span class="built_in">number</span>[]</span>): <span class="title">number</span>[] </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> length = nums.length;</span><br><span class="line">    <span class="keyword">const</span> answer = <span class="keyword">new</span> <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt;(length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// answer[i] 表示索引 i 左侧所有元素的乘积</span></span><br><span class="line">    <span class="comment">// 因为索引为 '0' 的元素左侧没有元素， 所以 answer[0] = 1</span></span><br><span class="line">    answer[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">        answer[i] = nums[i - <span class="number">1</span>] * answer[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R 为右侧所有元素的乘积</span></span><br><span class="line">    <span class="comment">// 刚开始右边没有元素，所以 R = 1</span></span><br><span class="line">    <span class="keyword">let</span> R = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R</span></span><br><span class="line">        answer[i] = answer[i] * R;</span><br><span class="line">        <span class="comment">// R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上</span></span><br><span class="line">        R *= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(N)*，其中 *N</em> 指的是数组 <code>nums</code> 的大小。分析与方法一相同。</li><li>空间复杂度：<em>O(1)</em>，输出数组不算进空间复杂度中，因此我们只需要常数的空间存放变量。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你一个长度为 n 的整数数组 nums，其中 n &amp;gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年7月" scheme="http://yoursite.com/categories/2020%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>155. 最小栈</title>
    <link href="http://yoursite.com/2020/07/02/155.%20%20%E6%9C%80%E5%B0%8F%E6%A0%88/"/>
    <id>http://yoursite.com/2020/07/02/155.  最小栈/</id>
    <published>2020-07-02T14:36:12.000Z</published>
    <updated>2020-07-06T01:04:42.706Z</updated>
    
    <content type="html"><![CDATA[<p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p><a id="more"></a><h1 id="题目描述（简单难度）"><a href="#题目描述（简单难度）" class="headerlink" title="题目描述（简单难度）"></a>题目描述（简单难度）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push(x) —— 将元素 x 推入栈中。</span><br><span class="line">pop() —— 删除栈顶的元素。</span><br><span class="line">top() —— 获取栈顶元素。</span><br><span class="line">getMin() —— 检索栈中的最小元素。</span><br></pre></td></tr></table></figure><p>示例:</p><pre><code>输入：[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;][[],[-2],[0],[-3],[],[],[],[]]输出：[null,null,null,null,-3,null,0,-2]解释：MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin();   --&gt; 返回 -3.minStack.pop();minStack.top();      --&gt; 返回 0.minStack.getMin();   --&gt; 返回 -2.</code></pre><p>提示：</p><p>pop、top 和 getMin 操作总是在 非空栈 上调用。</p><p>最初的想法是用两个栈来实现，pop,push和top可用stack自带的pop,push和peek函数来实现，然后每次找最小值时都将一个栈中元素倒豆子一样倒进另一个栈中，此过程中获得最小值，之后再倒回去，但这种方法超时了。</p><h1 id="解法一-1"><a href="#解法一-1" class="headerlink" title="解法一^1"></a>解法一<a href="https://leetcode.wang" target="_blank" rel="noopener">^1</a></h1><p>要实现一个 <code>stack</code>，那么我们还能用 <code>java</code> 自带的 <code>stack</code> 吗？也不用纠结，这道题的关键其实是实现「得到最小值这个功能」，所以为了代码简洁些，我们就直接使用系统自带的 <code>stack</code> 了。</p><p>这道题最直接的解法就是我们可以用两个栈，一个栈去保存正常的入栈出栈的值，另一个栈去存最小值，也就是用栈顶保存当前所有元素的最小值。存最小值的栈的具体操作流程如下：</p><p>将第一个元素入栈。</p><p>新加入的元素如果大于栈顶元素，那么新加入的元素就不处理。</p><p>新加入的元素如果小于等于栈顶元素，那么就将新元素入栈。</p><p>出栈元素不等于栈顶元素，不操作。</p><p>出栈元素等于栈顶元素，那么就将栈顶元素出栈。</p><p>举个例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">入栈 <span class="number">3</span> </span><br><span class="line">|   |    |   |</span><br><span class="line">|   |    |   |</span><br><span class="line">|_3_|    |_3_|</span><br><span class="line">stack  minStack</span><br><span class="line"></span><br><span class="line">入栈 <span class="number">5</span> ， <span class="number">5</span> 大于 minStack 栈顶，不处理</span><br><span class="line">|   |    |   |</span><br><span class="line">| <span class="number">5</span> |    |   |</span><br><span class="line">|_3_|    |_3_|</span><br><span class="line">stack  minStack</span><br><span class="line"></span><br><span class="line">入栈 <span class="number">2</span> ，此时右边的 minStack 栈顶就保存了当前最小值 <span class="number">2</span> </span><br><span class="line">| <span class="number">2</span> |    |   |</span><br><span class="line">| <span class="number">5</span> |    | <span class="number">2</span> |</span><br><span class="line">|_3_|    |_3_|</span><br><span class="line">stack  minStack</span><br><span class="line"></span><br><span class="line">出栈 <span class="number">2</span>，此时右边的 minStack 栈顶就保存了当前最小值 <span class="number">3</span></span><br><span class="line">|   |    |   |</span><br><span class="line">| <span class="number">5</span> |    |   |</span><br><span class="line">|_3_|    |_3_|</span><br><span class="line">stack  minStack</span><br><span class="line"></span><br><span class="line">出栈 <span class="number">5</span>，右边 minStack 不处理</span><br><span class="line">|   |    |   |</span><br><span class="line">|   |    |   |</span><br><span class="line">|_3_|    |_3_|</span><br><span class="line">stack  minStack</span><br><span class="line"></span><br><span class="line">出栈 <span class="number">3</span></span><br><span class="line">|   |    |   |</span><br><span class="line">|   |    |   |</span><br><span class="line">|_ _|    |_ _|</span><br><span class="line">stack  minStack</span><br></pre></td></tr></table></figure><p>代码的话就很好写了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minStack;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line">        <span class="keyword">if</span> (!minStack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> top = minStack.peek();</span><br><span class="line">            <span class="comment">//小于的时候才入栈</span></span><br><span class="line">            <span class="keyword">if</span> (x &lt;= top) &#123;</span><br><span class="line">                minStack.push(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            minStack.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pop = stack.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> top = minStack.peek();</span><br><span class="line">        <span class="comment">//等于的时候再出栈</span></span><br><span class="line">        <span class="comment">//此处不能写作if(minStack.peek() == stack.peek())否则判断不生效</span></span><br><span class="line">        <span class="comment">//因为包装类型间的相等判断应该用equals而非==</span></span><br><span class="line">        <span class="keyword">if</span> (pop == top) &#123;</span><br><span class="line">            minStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我犯了一个错误 </p><p>出栈操作判断时不能写作<code>if(minStack.peek() == stack.peek())</code>否则判断不生效,因为包装类型间的相等判断应该用equals而非==</p><h1 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h1><p>解法一中用了两个栈去实现，那么我们能不能用一个栈去实现呢？</p><p>参考了  <a href="https://leetcode.com/problems/min-stack/discuss/49014/Java-accepted-solution-using-one-stack" target="_blank" rel="noopener">这里</a>。</p><p>解法一中单独用了一个栈去保存所有最小值，那么我们能不能只用一个变量去保存最小值呢？</p><p>再看一下上边的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">入栈 <span class="number">3</span> </span><br><span class="line">|   |   min = <span class="number">3</span></span><br><span class="line">|   |     </span><br><span class="line">|_3_|    </span><br><span class="line">stack   </span><br><span class="line"></span><br><span class="line">入栈 <span class="number">5</span> </span><br><span class="line">|   |   min = <span class="number">3</span></span><br><span class="line">| <span class="number">5</span> |     </span><br><span class="line">|_3_|    </span><br><span class="line">stack  </span><br><span class="line"></span><br><span class="line">入栈 <span class="number">2</span> </span><br><span class="line">| <span class="number">2</span> |   min = <span class="number">2</span>?</span><br><span class="line">| <span class="number">5</span> |     </span><br><span class="line">|_3_|    </span><br><span class="line">stack</span><br></pre></td></tr></table></figure><p>如果只用一个变量就会遇到一个问题，如果把 <code>min</code> 更新为 <code>2</code>，那么之前的最小值 <code>3</code> 就丢失了。</p><p>怎么把 <code>3</code> 保存起来呢？把它在 <code>2</code> 之前压入栈中即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">入栈 <span class="number">2</span> ，同时将之前的 min 值 <span class="number">3</span> 入栈，再把 <span class="number">2</span> 入栈，同时更新 min = <span class="number">2</span></span><br><span class="line">| <span class="number">2</span> |   min = <span class="number">2</span></span><br><span class="line">| <span class="number">3</span> |  </span><br><span class="line">| <span class="number">5</span> |     </span><br><span class="line">|_3_|    </span><br><span class="line">stack  </span><br><span class="line"></span><br><span class="line">入栈 <span class="number">6</span> </span><br><span class="line">| <span class="number">6</span> |  min = <span class="number">2</span></span><br><span class="line">| <span class="number">2</span> |   </span><br><span class="line">| <span class="number">3</span> |  </span><br><span class="line">| <span class="number">5</span> |     </span><br><span class="line">|_3_|    </span><br><span class="line">stack  </span><br><span class="line"></span><br><span class="line">出栈 <span class="number">6</span>     </span><br><span class="line">| <span class="number">2</span> |   min = <span class="number">2</span></span><br><span class="line">| <span class="number">3</span> |  </span><br><span class="line">| <span class="number">5</span> |     </span><br><span class="line">|_3_|    </span><br><span class="line">stack  </span><br><span class="line"></span><br><span class="line">出栈 <span class="number">2</span>     </span><br><span class="line">| <span class="number">2</span> |   min = <span class="number">2</span></span><br><span class="line">| <span class="number">3</span> |  </span><br><span class="line">| <span class="number">5</span> |     </span><br><span class="line">|_3_|    </span><br><span class="line">stack</span><br></pre></td></tr></table></figure><p>上边的最后一个状态，当出栈元素是最小元素我们该如何处理呢？</p><p>我们只需要把 <code>2</code> 出栈，然后再出栈一次，把 <code>3</code> 赋值给 <code>min</code> 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">出栈 <span class="number">2</span>     </span><br><span class="line">|   |  min = <span class="number">3</span>   </span><br><span class="line">| <span class="number">5</span> |   </span><br><span class="line">|_3_|    </span><br><span class="line">stack</span><br></pre></td></tr></table></figure><p>通过上边的方式，我们就只需要一个栈了。当有更小的值来的时候，我们只需要把之前的最小值入栈，当前更小的值再入栈即可。当这个最小值要出栈的时候，下一个值便是之前的最小值了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当前值更小</span></span><br><span class="line">        <span class="keyword">if</span>(x &lt;= min)&#123;   </span><br><span class="line">            <span class="comment">//将之前的最小值保存</span></span><br><span class="line">            stack.push(min);</span><br><span class="line">            <span class="comment">//更新最小值</span></span><br><span class="line">            min=x;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果弹出的值是最小值，那么将下一个元素更新为最小值</span></span><br><span class="line">        <span class="keyword">if</span>(stack.pop() == min) &#123;</span><br><span class="line">            min=stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h1><p>参考 <a href="https://leetcode.com/problems/min-stack/discuss/49031/Share-my-Java-solution-with-ONLY-ONE-stack" target="_blank" rel="noopener">这里</a>，再分享利用一个栈的另一种思路。</p><p>通过解法二的分析，我们关键要解决的问题就是当有新的更小值的时候，之前的最小值该怎么办？</p><p>解法二中通过把之前的最小值入栈解决问题。</p><p>这里的话，用了另一种思路。同样是用一个 <code>min</code> 变量保存最小值。只不过栈里边我们不去保存原来的值，而是去存储入栈的值和最小值的差值。然后得到之前的最小值的话，我们就可以通过 <code>min</code> 值和栈顶元素得到，举个例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">入栈 <span class="number">3</span>，存入 <span class="number">3</span> - <span class="number">3</span> = <span class="number">0</span></span><br><span class="line">|   |   min = <span class="number">3</span></span><br><span class="line">|   |     </span><br><span class="line">|_0_|    </span><br><span class="line">stack   </span><br><span class="line"></span><br><span class="line">入栈 <span class="number">5</span>，存入 <span class="number">5</span> - <span class="number">3</span> = <span class="number">2</span></span><br><span class="line">|   |   min = <span class="number">3</span></span><br><span class="line">| <span class="number">2</span> |     </span><br><span class="line">|_0_|    </span><br><span class="line">stack  </span><br><span class="line"></span><br><span class="line">入栈 <span class="number">2</span>，因为出现了更小的数，所以我们会存入一个负数，这里很关键</span><br><span class="line">也就是存入  <span class="number">2</span> - <span class="number">3</span> = -<span class="number">1</span>, 并且更新 min = <span class="number">2</span> </span><br><span class="line">对于之前的 min 值 <span class="number">3</span>, 我们只需要用更新后的 min - 栈顶元素 -<span class="number">1</span> 就可以得到    </span><br><span class="line">| -<span class="number">1</span>|   min = <span class="number">2</span></span><br><span class="line">| <span class="number">5</span> |     </span><br><span class="line">|_3_|    </span><br><span class="line">stack  </span><br><span class="line"></span><br><span class="line">入栈 <span class="number">6</span>，存入  <span class="number">6</span> - <span class="number">2</span> = <span class="number">4</span></span><br><span class="line">| <span class="number">4</span> |   min = <span class="number">2</span></span><br><span class="line">| -<span class="number">1</span>| </span><br><span class="line">| <span class="number">5</span> |     </span><br><span class="line">|_3_|    </span><br><span class="line">stack  </span><br><span class="line"></span><br><span class="line">出栈，返回的值就是栈顶元素 <span class="number">4</span> 加上 min，就是 <span class="number">6</span></span><br><span class="line">|   |   min = <span class="number">2</span></span><br><span class="line">| -<span class="number">1</span>| </span><br><span class="line">| <span class="number">5</span> |     </span><br><span class="line">|_3_|    </span><br><span class="line">stack  </span><br><span class="line"></span><br><span class="line">出栈，此时栈顶元素是负数，说明之前对 min 值进行了更新。</span><br><span class="line">入栈元素 - min = 栈顶元素，入栈元素其实就是当前的 min 值 <span class="number">2</span></span><br><span class="line">所以更新前的 min 就等于入栈元素 <span class="number">2</span> - 栈顶元素(-<span class="number">1</span>) = <span class="number">3</span></span><br><span class="line">|   | min = <span class="number">3</span></span><br><span class="line">| <span class="number">5</span> |     </span><br><span class="line">|_3_|    </span><br><span class="line">stack</span><br></pre></td></tr></table></figure><p>再理一下上边的思路，我们每次存入的是 <code>原来值 - 当前最小值</code>。</p><p>当原来值大于等于当前最小值的时候，我们存入的肯定就是非负数，所以出栈的时候就是 <code>栈中的值 + 当前最小值</code> 。</p><p>当原来值小于当前最小值的时候，我们存入的肯定就是负值，此时的值我们不入栈，用 <code>min</code> 保存起来，同时将差值入栈。</p><p>当后续如果出栈元素是负数的时候，那么要出栈的元素其实就是 <code>min</code>。此外之前的 <code>min</code> 值，我们可以通过栈顶的值和当前 <code>min</code> 值进行还原，就是用 <code>min</code> 减去栈顶元素即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> min;</span><br><span class="line">Stack&lt;Long&gt; stack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">min = x;</span><br><span class="line">stack.push(x - min);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">stack.push(x - min);</span><br><span class="line"><span class="keyword">if</span> (x &lt; min)&#123;</span><br><span class="line">min = x; <span class="comment">// 更新最小值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (stack.isEmpty())</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> pop = stack.pop();</span><br><span class="line"></span><br><span class="line"><span class="comment">//弹出的是负值，要更新 min</span></span><br><span class="line"><span class="keyword">if</span> (pop &lt; <span class="number">0</span>) &#123;</span><br><span class="line">min = min - pop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> top = stack.peek();</span><br><span class="line"><span class="comment">//负数的话，出栈的值保存在 min 中</span></span><br><span class="line"><span class="keyword">if</span> (top &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>) (min);</span><br><span class="line">        <span class="comment">//出栈元素加上最小值即可</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>) (top + min);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>) min;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上边的解法的一个缺点就是由于我们保存的是差值，所以可能造成溢出，所以我们用了数据范围更大的 <code>long</code> 类型。</p><p>此外相对于解法二，最小值需要更新的时候，我们并没有将之前的最小值存起来，我们每次都是通过当前最小值和栈顶元素推出了之前的最小值，所以会省一些空间。</p><h1 id="解法四"><a href="#解法四" class="headerlink" title="解法四"></a>解法四</h1><p>再分享一个有趣的解法，参考 <a href="https://leetcode.com/problems/min-stack/discuss/49217/6ms-Java-Solution-using-Linked-List.-Clean-self-explanatory-and-efficient." target="_blank" rel="noopener">这里</a> 。</p><p>回到最初的疑虑，我们要不要用 <code>java</code> 提供的 <code>stack</code> 。如果不用的话，可以怎么做的？</p><p>直接用一个链表即可实现栈的基本功能，那么最小值该怎么得到呢？我们可以在 <code>Node</code> 节点中增加一个 <code>min</code> 字段，这样的话每次加入一个节点的时候，我们同时只要确定它的 <code>min</code> 值即可。</p><p>代码很简洁，我直接把代码贴过来吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">int</span> min;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> x, <span class="keyword">int</span> min)&#123;</span><br><span class="line">            <span class="keyword">this</span>.value=x;</span><br><span class="line">            <span class="keyword">this</span>.min=min;</span><br><span class="line">            next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Node head;</span><br><span class="line">    <span class="comment">//每次加入的节点放到头部</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span>==head)&#123;</span><br><span class="line">            head = <span class="keyword">new</span> Node(x,x);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//当前值和之前头结点的最小值较小的做为当前的 min</span></span><br><span class="line">            Node n = <span class="keyword">new</span> Node(x, Math.min(x,head.min));</span><br><span class="line">            n.next=head;</span><br><span class="line">            head=n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head!=<span class="keyword">null</span>)</span><br><span class="line">            head =head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head!=<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head.value;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span>!=head)</span><br><span class="line">            <span class="keyword">return</span> head.min;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然题目比较简单，但解法二和解法三真的让人耳目一新，一个通过存储，一个通过差值解决了「保存之前值」的问题，思路很值得借鉴。解法四更像降维打击一样，回到改底层数据结构，从而更加简洁的解决了问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年7月" scheme="http://yoursite.com/categories/2020%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
      <category term="Design" scheme="http://yoursite.com/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>240. 搜索二维矩阵II</title>
    <link href="http://yoursite.com/2020/06/30/240.%20%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5II/"/>
    <id>http://yoursite.com/2020/06/30/240. 搜索二维矩阵II/</id>
    <published>2020-06-30T14:52:12.000Z</published>
    <updated>2020-06-30T16:10:49.197Z</updated>
    
    <content type="html"><![CDATA[<p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。</p><a id="more"></a><p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：</p><p>每行的元素从左到右升序排列。<br>每列的元素从上到下升序排列。<br>示例:</p><pre><code>现有矩阵 matrix 如下：[  [1,   4,  7, 11, 15],  [2,   5,  8, 12, 19],  [3,   6,  9, 16, 22],  [10, 13, 14, 17, 24],  [18, 21, 23, 26, 30]]给定 target = 5，返回 true。给定 target = 20，返回 false。</code></pre><p>这道题出的不好，因为可以用74.搜索二维矩阵题一样的方法从左下角搜索来解决。</p><h1 id="从左下角开始搜索"><a href="#从左下角开始搜索" class="headerlink" title="从左下角开始搜索"></a>从左下角开始搜索</h1><p>因为矩阵的行和列是排序的（分别从左到右和从上到下），所以在查看任何特定值时，我们可以修剪O(m)或O(n)元素。</p><p>算法：</p><p>首先，我们初始化一个指向矩阵左下角的 (row，col) 指针。然后，直到找到目标并返回 true（或者指针指向矩阵维度之外的 (row，col) 为止，我们执行以下操作：</p><p>如果当前指向的值大于目标值，则可以 “向上” 移动一行。 </p><p>否则，如果当前指向的值小于目标值，则可以移动一列。不难理解为什么这样做永远不会删减正确的答案；因为行是从左到右排序的，所以我们知道当前值右侧的每个值都较大。 </p><p>因此，如果当前值已经大于目标值，我们知道它右边的每个值会比较大。也可以对列进行非常类似的论证，因此这种搜索方式将始终在矩阵中找到目标（如果存在）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean searchMatrix(int[][] matrix, int target) &#123;</span><br><span class="line">//        二维数组为空，要检查三个部分:</span><br><span class="line">//        一是数组首地址是否为空</span><br><span class="line">//        二是是否为&#123;&#125;，也就是array.length==0的情况</span><br><span class="line">//        三是&#123;&#123;&#125;&#125;，这时array.length=1，但是array[0].length==0。满足任意一个条件就可以返回false了。</span><br><span class="line">        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return false;</span><br><span class="line">        int row = matrix.length;</span><br><span class="line">        int col = matrix[0].length;</span><br><span class="line">        int rowindex = row - 1;</span><br><span class="line">        int colindex = 0;</span><br><span class="line"></span><br><span class="line">        while (colindex &lt; col &amp;&amp; rowindex &gt;= 0) &#123;</span><br><span class="line">            if (target == matrix[rowindex][colindex]) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else if (target &gt; matrix[rowindex][colindex]) &#123;</span><br><span class="line">                colindex++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                rowindex--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其它方法见<a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/solution/sou-suo-er-wei-ju-zhen-ii-by-leetcode-2/" target="_blank" rel="noopener">^1</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Divide and Conquer" scheme="http://yoursite.com/tags/Divide-and-Conquer/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>74. 搜索二维矩阵</title>
    <link href="http://yoursite.com/2020/06/30/74.%20%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/"/>
    <id>http://yoursite.com/2020/06/30/74. 搜索二维矩阵/</id>
    <published>2020-06-30T14:52:12.000Z</published>
    <updated>2020-06-30T16:11:22.253Z</updated>
    
    <content type="html"><![CDATA[<p>编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。</p><a id="more"></a><p>该矩阵具有如下特性：</p><p>每行中的整数从左到右按升序排列。<br>每行的第一个整数大于前一行的最后一个整数。<br>示例 1:</p><pre><code>输入:matrix = [  [1,   3,  5,  7],  [10, 11, 16, 20],  [23, 30, 34, 50]]</code></pre><p>target = 3<br>输出: true<br>示例 2:</p><pre><code>输入:matrix = [  [1,   3,  5,  7],  [10, 11, 16, 20],  [23, 30, 34, 50]]target = 13输出: false</code></pre><h1 id="从左下角开始搜索"><a href="#从左下角开始搜索" class="headerlink" title="从左下角开始搜索"></a>从左下角开始搜索</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean searchMatrix(int[][] matrix, int target) &#123;</span><br><span class="line">//        二维数组为空，要检查三个部分:</span><br><span class="line">//        一是数组首地址是否为空</span><br><span class="line">//        二是是否为&#123;&#125;，也就是array.length==0的情况</span><br><span class="line">//        三是&#123;&#123;&#125;&#125;，这时array.length=1，但是array[0].length==0。满足任意一个条件就可以返回false了。</span><br><span class="line">        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return false;</span><br><span class="line">        int row = matrix.length;</span><br><span class="line">        int col = matrix[0].length;</span><br><span class="line">        int rowindex = row - 1;</span><br><span class="line">        int colindex = 0;</span><br><span class="line"></span><br><span class="line">        while (colindex &lt; col &amp;&amp; rowindex &gt;= 0) &#123;</span><br><span class="line">            if (target == matrix[rowindex][colindex]) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else if (target &gt; matrix[rowindex][colindex]) &#123;</span><br><span class="line">                colindex++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                rowindex--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法：二分查找"><a href="#方法：二分查找" class="headerlink" title="方法：二分查找"></a>方法：二分查找</h1><p><strong>直觉</strong></p><p>注意到输入的 <code>m x n</code> 矩阵可以视为长度为 <code>m x n</code>的有序数组。</p><p> <a href="https://pic.leetcode-cn.com/d9b47b40a4de17b0c56446b0a4935a5042490ea1d92a6f4c529c2aaa0095c189-287711dcb87bd4d4681fa117f792d1baaaa7ce3e2c65d6a4f6439c0cbbb0345e-image.png" target="_blank" rel="noopener">二分查找</a></p><p>由于该 <em>虚</em> 数组的序号可以由下式方便地转化为原矩阵中的行和列 (<em>我们当然不会真的创建一个新数组</em>) ，该有序数组非常适合二分查找。</p><blockquote><p><code>row = idx // n</code> ， <code>col = idx % n</code>。</p></blockquote><p><strong>算法</strong></p><p>这是一个标准二分查找算法 : </p><ul><li><p>初始化左右序号<br><code>left = 0</code> 和 <code>right = m x n - 1</code>。</p></li><li><p>While <code>left &lt; right</code> :</p><ul><li><p>选取虚数组最中间的序号作为中间序号: <code>pivot_idx = (left + right) / 2</code>。</p></li><li><p>该序号对应于原矩阵中的 <code>row = pivot_idx // n</code>行 <code>col = pivot_idx % n</code> 列, 由此可以拿到中间元素<code>pivot_element</code>。该元素将虚数组分为两部分。</p></li><li><p>比较 <code>pivot_element</code> 与 <code>target</code> 以确定在哪一部分进行进一步查找。</p></li></ul></li></ul><p><strong>实现</strong></p><figure class="highlight java"><figcaption><span>[solution1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分查找</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = m * n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> pivotIdx, pivotElement;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">      pivotIdx = (left + right) / <span class="number">2</span>;</span><br><span class="line">      pivotElement = matrix[pivotIdx / n][pivotIdx % n];</span><br><span class="line">      <span class="keyword">if</span> (target == pivotElement) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; pivotElement) right = pivotIdx - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> left = pivotIdx + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[solution1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span><span class="params">(self, matrix: List[List[int]], target: int)</span> -&gt; bool:</span></span><br><span class="line">        m = len(matrix)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        n = len(matrix[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#二分查找</span></span><br><span class="line">        left, right = <span class="number">0</span>, m * n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">                pivot_idx = (left + right) // <span class="number">2</span></span><br><span class="line">                pivot_element = matrix[pivot_idx // n][pivot_idx % n]</span><br><span class="line">                <span class="keyword">if</span> target == pivot_element:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> target &lt; pivot_element:</span><br><span class="line">                        right = pivot_idx - <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        left = pivot_idx + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>[solution1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分查找</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = m * n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> pivotIdx, pivotElement;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">      pivotIdx = (left + right) / <span class="number">2</span>;</span><br><span class="line">      pivotElement = matrix[pivotIdx / n][pivotIdx % n];</span><br><span class="line">      <span class="keyword">if</span> (target == pivotElement) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; pivotElement) right = pivotIdx - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> left = pivotIdx + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 : 由于是标准的二分查找，时间复杂度为O(log(mn)) 。</li><li>空间复杂度 : <em>O(1)</em>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>334. 递增的三元子序列</title>
    <link href="http://yoursite.com/2020/06/30/334.%E9%80%92%E5%A2%9E%E7%9A%84%E4%B8%89%E5%85%83%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2020/06/30/334.递增的三元子序列/</id>
    <published>2020-06-30T12:52:12.000Z</published>
    <updated>2020-06-30T13:09:57.486Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个未排序的数组，判断这个数组中是否存在长度为 3 的递增子序列。</p><a id="more"></a><p>数学表达式如下:</p><p>如果存在这样的 i, j, k,  且满足 0 ≤ i &lt; j &lt; k ≤ n-1，<br>使得 arr[i] &lt; arr[j] &lt; arr[k] ，返回 true ; 否则返回 false 。<br>说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1) 。</p><p>示例 1:</p><pre><code>输入: [1,2,3,4,5]输出: true</code></pre><p>示例 2:</p><pre><code>输入: [5,4,3,2,1]输出: false</code></pre><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ol><li>第一种方法采用了双指针的思想，针对这个题的三元子序列，如果是四元或更高元则不通用。主要思路是维护当前访问数组的最小值和最小值右侧大于最小值的最小的一个。具体步骤顺序遍历数组，首先确定当前已访问的数组的最小值，即如果小于等于min值的话更新min值，如果大于min，判断是否小于等于max值，如果是，更新max值。如果大于max值，则说明有三元子序列。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">increasingTriplet</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE, max = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num &lt;= min)&#123;</span><br><span class="line">                min = num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num &lt;= max)&#123;</span><br><span class="line">                max = num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>第二种方法是动态规划的思想，主要思路是维护和更新以i为结尾的三元子序列的最长递增长度。转移方程为dp[i] = max{dp[i], dp[j] + 1} (0&lt;=j&lt;i).</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">increasingTriplet</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个未排序的数组，判断这个数组中是否存在长度为 3 的递增子序列。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>350. 两个数组的交集II</title>
    <link href="http://yoursite.com/2020/06/29/350.%20%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86II/"/>
    <id>http://yoursite.com/2020/06/29/350. 两个数组的交集II/</id>
    <published>2020-06-29T15:52:12.000Z</published>
    <updated>2020-06-30T13:09:41.642Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个数组，编写一个函数来计算它们的交集。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: nums1 = [1,2,2,1], nums2 = [2,2]输出: [2,2]</code></pre><p>示例 2:</p><pre><code>输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [4,9]</code></pre><p>说明：</p><pre><code>输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。我们可以不考虑输出结果的顺序。</code></pre><p>进阶:</p><pre><code>如果给定的数组已经排好序呢？你将如何优化你的算法？如果 nums1 的大小比 nums2 小很多，哪种方法更优？如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？</code></pre><h1 id="方法一：哈希映射"><a href="#方法一：哈希映射" class="headerlink" title="方法一：哈希映射"></a>方法一：哈希映射</h1><p>前面的问题 <a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/" target="_blank" rel="noopener">349. 两个数组的交集</a>，我们使用 <code>set</code> 来实现线性时间复杂度。在这里，我们需要使用 <code>HashMap</code> 来跟踪每个数字出现的次数。</p><p>我们先在 <code>HashMap</code> 记录一个数组中的存在的数字和对应出现的次数。然后，我们遍历第二个数组，检查数字在 <code>HashMap</code> 中是否存在，如果存在且计数为正，则将该数字添加到答案并减少 <code>HashMap</code> 中的计数。<br> <a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMzUwLzM1MF9hcHByb2FjaDEtdjIucG5n?x-oss-process=image/format,png" target="_blank" rel="noopener">哈希映射</a><br>检查数组的大小并对较小的数组进行哈希映射是一个小细节，当其中一个数组较大时，会减少内存的使用。</p><p><strong>算法：</strong></p><ul><li>如果 <code>nums1</code> 元素个数大于 <code>nums2</code>，则交换数组元素。</li><li>对于 <code>nums1</code> 的每个元素，添加到 <code>HashMap m</code> 中，如果元素已经存在则增加对应的计数。</li><li>初始化 <code>k = 0</code>，记录当前交集元素个数。</li><li>遍历数组 <code>nums2</code>：<ul><li>检查元素在 <code>m</code> 是否存在，若存在且计数为正：<ul><li>将元素拷贝到 <code>nums1[k]</code>，且 <code>k++</code>。</li><li>减少 <code>m</code> 中对应元素的计数。</li></ul></li></ul></li><li>返回 <code>nums1</code> 前 <code>k</code> 个元素。</li></ul><figure class="highlight c++"><figcaption><span>[solution1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersect(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums1.size() &gt; nums2.size()) &#123;</span><br><span class="line">        <span class="keyword">return</span> intersect(nums2, nums1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n : nums1) &#123;</span><br><span class="line">        ++m[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n : nums2) &#123;</span><br><span class="line">        <span class="keyword">auto</span> it = m.find(n);</span><br><span class="line">        <span class="keyword">if</span> (it != end(m) &amp;&amp; --it-&gt;second &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[k++] = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vector</span>(begin(nums1), begin(nums1) + k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums1.length &gt; nums2.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> intersect(nums2, nums1);</span><br><span class="line">    &#125;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : nums1) &#123;</span><br><span class="line">        m.put(n, m.getOrDefault(n, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : nums2) &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = m.getOrDefault(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[k++] = n;</span><br><span class="line">            m.put(n, cnt - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOfRange(nums1, <span class="number">0</span>, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n+m) 。其中 <em>n</em>，<em>m</em> 分别代表了数组的大小。</li><li>空间复杂度：O(min(n,m)) ，我们对较小的数组进行哈希映射使用的空间。</li></ul><h1 id="方法二：排序"><a href="#方法二：排序" class="headerlink" title="方法二：排序"></a>方法二：排序</h1><p>当输入数据是有序的，推荐使用此方法。在这里，我们对两个数组进行排序，并且使用两个指针在一次扫面找出公共的数字。<br> <a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMzUwLzM1MF9hcHByb2FjaDItdjIucG5n?x-oss-process=image/format,png" target="_blank" rel="noopener">排序</a></p><p><strong>算法：</strong></p><ul><li>对数组 <code>nums1</code> 和 <code>nums2</code> 排序。</li><li>初始化指针 <code>i</code>，<code>j</code> 和 <code>k</code> 为 <code>0</code>。</li><li>指针 <code>i</code> 指向 <code>nums1</code>，指针 <code>j</code> 指向 <code>nums2</code>：<ul><li>如果 <code>nums1[i] &lt; nums2[j]</code>，则 <code>i++</code>。 </li><li>如果 <code>nums1[i] &gt; nums2[j]</code>，则 <code>j++</code>。 </li><li>如果 <code>nums1[i] == nums2[j]</code>，将元素拷贝到 <code>nums1[k]</code>，且 <code>i++</code>，<code>j++</code>，<code>k++</code>。</li></ul></li><li>返回数组 <code>nums1</code> 前 <code>k</code> 个元素。</li></ul><figure class="highlight c++"><figcaption><span>[solution2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersect(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">    sort(begin(nums1), end(nums1));</span><br><span class="line">    sort(begin(nums2), end(nums2));</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; nums1.size() &amp;&amp; j &lt; nums2.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[i] &lt; nums2[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums1[k++] = nums1[i++];</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(begin(nums1), begin(nums1) + k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[solution2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    Arrays.sort(nums1);</span><br><span class="line">    Arrays.sort(nums2);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; nums1.length &amp;&amp; j &lt; nums2.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[i] &lt; nums2[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums1[k++] = nums1[i++];</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOfRange(nums1, <span class="number">0</span>, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="public-static-int-copyOfRange-int-original-int-from-int-to"><a href="#public-static-int-copyOfRange-int-original-int-from-int-to" class="headerlink" title="public static int[] copyOfRange(int[] original, int from, int to)"></a>public static int[] copyOfRange(int[] original, int from, int to)</h2><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(nlogn+mlogm 。其中 <em>n</em>，<em>m</em> 分别代表了数组的大小。我们对数组进行了排序然后进行了线性扫描。</li><li>空间复杂度：<em>O(1)</em>，我们忽略存储答案所使用的空间，因为它对算法本身并不重要。</li></ul><h1 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h1><p><strong>算法：</strong></p><p>这类似于方法 2。我们不使用两个指针进行迭代，而是使用内置函数来查找公共元素。在 C++ 中，我们可以使用 <code>set_intersection</code> 来排序数组（或 <code>multisets</code>）。</p><p>在 Java 中的 <code>retainAll</code> 方法并不关心一个元素在另一个集合中出现的次数。这就有点尴尬了，我一开始想到的就是用内置函数但遇到用例<code>[1,2]，[1,2]</code>就错了，怎么写也没弄出来，所以Java此法暂不可行。</p><figure class="highlight c++"><figcaption><span>[solution3-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersect(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">    sort(begin(nums1), end(nums1));</span><br><span class="line">    sort(begin(nums2), end(nums2));</span><br><span class="line">    nums1.erase(set_intersection(begin(nums1), end(nums1), </span><br><span class="line">        begin(nums2), end(nums2), begin(nums1)), end(nums1));</span><br><span class="line">    <span class="keyword">return</span> nums1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时空复杂度：与方法二相同。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个数组，编写一个函数来计算它们的交集。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>349. 两个数组的交集</title>
    <link href="http://yoursite.com/2020/06/29/349.%20%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/"/>
    <id>http://yoursite.com/2020/06/29/349. 两个数组的交集/</id>
    <published>2020-06-29T12:42:12.000Z</published>
    <updated>2020-06-29T15:51:47.249Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个数组，编写一个函数来计算它们的交集。</p><a id="more"></a><p>示例 1：</p><pre><code>输入：nums1 = [1,2,2,1], nums2 = [2,2]输出：[2]</code></pre><p>示例 2：</p><pre><code>输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出：[9,4]</code></pre><p>说明：</p><pre><code>输出结果中的每个元素一定是唯一的。我们可以不考虑输出结果的顺序。</code></pre><h4 id="方法一：两个set"><a href="#方法一：两个set" class="headerlink" title="方法一：两个set"></a>方法一：两个set</h4><p>最直观的方法是迭代并检查第一个数组 <code>nums1</code> 中的每个值是否也存在于 <code>nums2</code> 中。如果存在，则将值添加到输出。这种方法的时间复杂度为 O(n*m)  ，其中 <code>n</code> 和 <code>m</code> 分别为数组 <code>nums1</code> 和 <code>nums2</code> 的长度。 </p><p>为了在线性时间内解决这个问题，我们使用集合 <code>set</code> 这一数据结构，该结构可以提供平均时间复杂度为 <em>O(1)</em> 的 <code>in/contains</code> 操作（用于测试某一元素是否为该集合的成员）。</p><p>本解法先将两个数组都转换为集合，然后迭代较小的集合，检查其中的每个元素是否同样存在于较大的集合中。平均情况下，这种方法的时间复杂度为 <em>O(n+m)</em> 。 </p><p><strong>实现：</strong></p><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_intersection</span><span class="params">(self, set1, set2)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> [x <span class="keyword">for</span> x <span class="keyword">in</span> set1 <span class="keyword">if</span> x <span class="keyword">in</span> set2]</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersection</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span>  </span><br><span class="line">        set1 = set(nums1)</span><br><span class="line">        set2 = set(nums2)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> len(set1) &lt; len(set2):</span><br><span class="line">            <span class="keyword">return</span> self.set_intersection(set1, set2)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.set_intersection(set2, set1)</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] set_intersection(HashSet&lt;Integer&gt; set1, HashSet&lt;Integer&gt; set2) &#123;</span><br><span class="line">    <span class="keyword">int</span> [] output = <span class="keyword">new</span> <span class="keyword">int</span>[set1.size()];</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Integer s : set1)</span><br><span class="line">      <span class="keyword">if</span> (set2.contains(s)) output[idx++] = s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(output, idx);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    HashSet&lt;Integer&gt; set1 = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Integer n : nums1) set1.add(n);</span><br><span class="line">    HashSet&lt;Integer&gt; set2 = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Integer n : nums2) set2.add(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (set1.size() &lt; set2.size()) <span class="keyword">return</span> set_intersection(set1, set2);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> set_intersection(set2, set1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(m+n)*，其中 <code>n</code> 和 <code>m</code> 是数组的长度。将 <code>nums1</code> 转换为集合需要 *O(n)</em> 的时间，类似地，将 <code>nums2</code> 转换为集合需要 <em>O(m)</em> 的时间。而在平均情况下，集合的 <code>in/contains</code> 操作只需要 <em>O(1)</em> 的时间。 </li><li>空间复杂度：<em>O(m+n)</em>，最坏的情况是数组中的所有元素都不同。 </li></ul><h3 id="Arrays-copyOf"><a href="#Arrays-copyOf" class="headerlink" title="Arrays.copyOf()"></a>Arrays.copyOf()</h3><p>original - 要复制的数组 </p><p>newLength - 要返回的副本的长度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*original - 要复制的数组 </span><br><span class="line">*newLength - 要返回的副本的长度</span><br><span class="line">*/</span><br><span class="line">public static int[] copyOf(int[] original, int newLength) &#123;</span><br><span class="line">        int[] copy = new int[newLength];</span><br><span class="line">        System.arraycopy(original, 0, copy, 0,</span><br><span class="line">                         Math.min(original.length, newLength));</span><br><span class="line">        return copy;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="方法二：内置函数"><a href="#方法二：内置函数" class="headerlink" title="方法二：内置函数"></a>方法二：内置函数</h4><p>如果使用内置函数：那么平均情况下，时间复杂度为 <em>O(n+m)</em> ；而最坏的情况下，时间复杂度是O(n*m)  。</p><p>Python 提供了可用于求交集的 <code>&amp;</code> 运算符，而 Java 提供了 <code>retainAll()</code>  函数。</p><p><strong>实现:</strong></p><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersection</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span>  </span><br><span class="line">        set1 = set(nums1)</span><br><span class="line">        set2 = set(nums2)</span><br><span class="line">        <span class="keyword">return</span> list(set2 &amp; set1)</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    HashSet&lt;Integer&gt; set1 = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Integer n : nums1) set1.add(n);</span><br><span class="line">    HashSet&lt;Integer&gt; set2 = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Integer n : nums2) set2.add(n);</span><br><span class="line"></span><br><span class="line">    set1.retainAll(set2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> [] output = <span class="keyword">new</span> <span class="keyword">int</span>[set1.size()];</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s : set1) output[idx++] = s;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：一般情况下是 <em>O(m+n)</em>，最坏情况下是 O(m*n)</li><li>空间复杂度：最坏的情况是 <em>O(m+n)</em>，数组中的所有元素都不同。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个数组，编写一个函数来计算它们的交集。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>384. 打乱数组</title>
    <link href="http://yoursite.com/2020/06/29/384.%20%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2020/06/29/384. 打乱数组/</id>
    <published>2020-06-29T10:02:12.000Z</published>
    <updated>2020-06-29T12:41:22.009Z</updated>
    
    <content type="html"><![CDATA[<p>打乱一个没有重复元素的数组。</p><a id="more"></a><p>示例:</p><pre><code>// 以数字集合 1, 2 和 3 初始化数组。int[] nums = {1,2,3};Solution solution = new Solution(nums);// 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。solution.shuffle();// 重设数组到它的初始状态[1,2,3]。solution.reset();// 随机返回数组[1,2,3]打乱后的结果。solution.shuffle();</code></pre><h1 id="绪章-1"><a href="#绪章-1" class="headerlink" title="绪章^1"></a>绪章<a href="https://leetcode-cn.com/problems/shuffle-an-array/solution/da-luan-shu-zu-by-leetcode/" target="_blank" rel="noopener">^1</a></h1><p>对于洗牌问题，Fisher-Yates 洗牌算法即是通俗解法，同时也是渐进最优的解法。</p><p>在我们开始之前需要了解一些关于随机化的知识 - 下面介绍的两个方法都假设编程语言中提供的伪随机数生成器是足够随机的。我们给出的示例代码也都采用了最简单的方法来得到伪随机数，但为了让数组的每个排列出现的可能性尽可能相等，还是有一些其他东西需要注意的。例如，一个长度为 <em>n</em> 的数组有 <em>n!</em> 个不同的排列组合。因此，为了能将所有的排列在整数空间编码，我们需要lg(n!) 比特，这是默认的伪随机数不能保证的。</p><h1 id="方法一：-暴力-【通过】"><a href="#方法一：-暴力-【通过】" class="headerlink" title="方法一： 暴力 【通过】"></a>方法一： 暴力 【通过】</h1><p><strong>思路</strong></p><p>假设我们把每个数都放在一个 ”帽子“ 里面，然后我们从帽子里面把它们一个个摸出来，摸出来的数按顺序放入数组，这个数组正好就是我们要的洗牌后的数组。</p><p><strong>算法</strong></p><p>暴力算法简单的来说就是把每个数放在一个 ”帽子“ 里面，每次从 ”帽子“ 里面随机摸一个数出来，直到 “帽子” 为空。下面是具体操作，首先我们把数组 <code>array</code> 复制一份给数组 <code>aux</code>，之后每次随机从 <code>aux</code> 中取一个数，为了防止数被重复取出，每次取完就把这个数从 <code>aux</code> 中移除。<code>重置</code> 的实现方式很简单，只需把 <code>array</code> 恢复称最开始的状态就可以了。 </p><p>这个算法的正确性在于，每次 <code>for</code> 循环中，任何一个元素都会以等可能的概率被选中。为了证明这一点，我们可以算出来，一个特定的元素 <em>e</em> 在第 <em>k</em> 轮被选中的概率为</p><p><em>P</em>(<em>e</em> 在第 <em>k</em> 轮被选中) ·  <em>P</em>(<em>e</em> 在前 <em>k</em> 轮不被选中)。</p><p>假设洗牌的数组有 <em>n</em> 个元素，这个概率公式见<a href="https://leetcode-cn.com/problems/shuffle-an-array/solution/da-luan-shu-zu-by-leetcode/" target="_blank" rel="noopener">^1</a></p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] original;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">getArrayCopy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; asList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            asList.add(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> asList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        array = nums;</span><br><span class="line">        original = nums.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reset() &#123;</span><br><span class="line">        array = original;</span><br><span class="line">        original = original.clone();</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] shuffle() &#123;</span><br><span class="line">        List&lt;Integer&gt; aux = getArrayCopy();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> removeIdx = rand.nextInt(aux.size());</span><br><span class="line">            array[i] = aux.get(removeIdx);</span><br><span class="line">            aux.remove(removeIdx);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度： <em>O(n^2)</em><br>乘方时间复杂度来自于 <code>list.remove</code>（<code>list.pop</code>）。每次操作都是线性时间的，总共发生 <em>n</em> 次。</p></li><li><p>空间复杂度： <em>O(n)</em><br>因为需要实现 <code>重置</code> 方法，需要额外的空间把原始数组另存一份，在重置的时候用来恢复原始状态。</p></li></ul><h4 id="方法二：-Fisher-Yates-洗牌算法-【通过】"><a href="#方法二：-Fisher-Yates-洗牌算法-【通过】" class="headerlink" title="方法二： Fisher-Yates 洗牌算法 【通过】"></a>方法二： Fisher-Yates 洗牌算法 【通过】</h4><p><strong>思路</strong></p><p>我们可以用一个简单的技巧来降低之前算法的时间复杂度和空间复杂度，那就是让数组中的元素互相交换，这样就可以避免掉每次迭代中用于修改列表的时间了。</p><p><strong>算法</strong></p><p>Fisher-Yates 洗牌算法跟暴力算法很像。在每次迭代中，生成一个范围在当前下标到数组末尾元素下标之间的随机整数。接下来，将当前元素和随机选出的下标所指的元素互相交换 - 这一步模拟了每次从 “帽子” 里面摸一个元素的过程，其中选取下标范围的依据在于每个被摸出的元素都不可能再被摸出来了。此外还有一个需要注意的细节，当前元素是可以和它本身互相交换的 - 否则生成最后的排列组合的概率就不对了。为了更清楚地理解这一过程，可以看下面这些动画：</p><p>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates1.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates2.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates3.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates4.png" target="_blank" rel="noopener">1000</a></p><p>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates5.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates6.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates7.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates8.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates9.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates10.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates11.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates12.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates13.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates14.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates15.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates16.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates17.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates18.png" target="_blank" rel="noopener">1000</a> </p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] original;</span><br><span class="line"></span><br><span class="line">    Random rand = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">randRange</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rand.nextInt(max - min) + min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swapAt</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        array = nums;</span><br><span class="line">        original = nums.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reset() &#123;</span><br><span class="line">        array = original;</span><br><span class="line">        original = original.clone();</span><br><span class="line">        <span class="keyword">return</span> original;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] shuffle() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            swapAt(i, randRange(i, array.length));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度 ： <em>O(n)</em><br>Fisher-Yates 洗牌算法时间复杂度是线性的，因为算法中生成随机序列，交换两个元素这两种操作都是常数时间复杂度的。</p></li><li><p>空间复杂度： <em>O(n)</em><br>因为要实现 <code>重置</code> 功能，原始数组必须得保存一份，因此空间复杂度并没有优化。</p></li></ul><h2 id="Random-nextInt-方法，随机产生某个范围内的整数"><a href="#Random-nextInt-方法，随机产生某个范围内的整数" class="headerlink" title="Random.nextInt()方法，随机产生某个范围内的整数"></a>Random.nextInt()方法，随机产生某个范围内的整数</h2><pre><code>int nextInt()            //随机返回一个int型整数int nextInt(int num)         //随机返回一个值在[0,num)的int类型的整数,包括0不包括num</code></pre><p>nextInt能接受一个整数作为它所产生的随机整数的上限,下限为零，若要达到非零下限的效果，必须把上限减去下限的结果传给 nextInt( )，然后把下限加入 nextInt( ) 返回的整数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;打乱一个没有重复元素的数组。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>283. 移动零</title>
    <link href="http://yoursite.com/2020/06/29/283.%20%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
    <id>http://yoursite.com/2020/06/29/283. 移动零/</id>
    <published>2020-06-29T09:49:12.000Z</published>
    <updated>2020-06-29T10:00:39.219Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><a id="more"></a><p>示例:</p><pre><code>输入: [0,1,0,3,12]输出: [1,3,12,0,0]</code></pre><p>说明:</p><p>必须在原数组上操作，不能拷贝额外的数组。<br>尽量减少操作次数。</p><p>我首先想到的解法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void moveZeroes(int[] nums) &#123;</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (nums[i] == 0) &#123;</span><br><span class="line">                swap(nums,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void swap(int[] nums, int zeroindex) &#123;</span><br><span class="line">        int i=zeroindex;</span><br><span class="line">        while (i &lt; nums.length) &#123;</span><br><span class="line">            if (nums[i] == 0) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                nums[zeroindex] = nums[i];</span><br><span class="line">                nums[i]=0;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">解答成功:</span><br><span class="line">执行耗时:5 ms,击败了12.67% 的Java用户</span><br><span class="line">内存消耗:40.4 MB,击败了5.62% 的Java用户</span><br></pre></td></tr></table></figure><p>这种方法效率较低，有没有更高效的方法呢？</p><h1 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h1><ol><li>定义一个非零的指针 <code>j=0</code>，循环遍历数组用指针<code>j</code>记录非零值<code>nums[j] = num[i]</code>;</li><li>判断两个指针<code>i</code>与<code>j</code>是否相等，这里两个指针初始值都为0，<code>j</code>指针只有在非零的情况下会<code>j++</code>；</li><li>因此可以判断<code>j</code>指针对应的值都为非零的数据，且保存原有顺序；</li><li>所以，原有数组继续遍历情况下，<code>nums[i]</code>都为0。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void moveZeroes(int[] nums) &#123;</span><br><span class="line">        int j = 0;</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (nums[i] != 0) &#123;</span><br><span class="line">                nums[j] = nums[i];</span><br><span class="line">                if( i != j)&#123;</span><br><span class="line">                    nums[i] = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">            解答成功:</span><br><span class="line">执行耗时:0 ms,击败了100.00% 的Java用户</span><br><span class="line">内存消耗:39.6 MB,击败了5.62% 的Java用户</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>Java之TreeSet类</title>
    <link href="http://yoursite.com/2020/06/29/Java%E4%B9%8BTreeSet%E7%B1%BB/"/>
    <id>http://yoursite.com/2020/06/29/Java之TreeSet类/</id>
    <published>2020-06-29T08:21:12.000Z</published>
    <updated>2020-06-29T09:09:17.746Z</updated>
    
    <content type="html"><![CDATA[<p>java.util.TreeSet 类实现Set接口。</p><a id="more"></a><p>以下是关于TreeSet的要点<a href="http://gitbook.net/java/util/java_util_treeset.html" target="_blank" rel="noopener">^1</a>：</p><ul><li>TreeSet类保证该映射将在升序键顺序，由TreeMap支持。</li><li>该映射是按照自然排序方法该键类，或在集创建时提供的比较器，这将取决于其构造函数中使用排序。</li><li>顺序必须是总为了使树到功能属性。</li></ul><p>这里仅列出几个常用的方法，更多详见<a href="http://gitbook.net/java/util/java_util_treeset.html" target="_blank" rel="noopener">^1</a></p><h1 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h1><h2 id="E-ceiling-E-e-方法"><a href="#E-ceiling-E-e-方法" class="headerlink" title="E ceiling(E e) 方法"></a>E ceiling(E e) 方法</h2><p>用来返回大于或等于给定的元素的最小元素，如果不存在这样的元素返回null。</p><h2 id="E-floor-E-e-方法"><a href="#E-floor-E-e-方法" class="headerlink" title="E floor(E e) 方法"></a>E floor(E e) 方法</h2><p>此方法返回小于或等于给定的元素的最大元素，如果不存在这样的元素返回null。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java.util.TreeSet 类实现Set接口。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="TreeSet" scheme="http://yoursite.com/tags/TreeSet/"/>
    
  </entry>
  
  <entry>
    <title>220. 存在重复元素III</title>
    <link href="http://yoursite.com/2020/06/29/220.%20%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0III/"/>
    <id>http://yoursite.com/2020/06/29/220. 存在重复元素III/</id>
    <published>2020-06-29T06:59:12.000Z</published>
    <updated>2020-06-29T09:31:29.444Z</updated>
    
    <content type="html"><![CDATA[<p>在整数数组 nums 中，是否存在两个下标 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值小于等于 t ，且满足 i 和 j 的差的绝对值也小于等于 ķ 。</p><a id="more"></a><p>如果存在则返回 true，不存在返回 false。</p><p>示例 1:</p><pre><code>输入: nums = [1,2,3,1], k = 3, t = 0输出: true</code></pre><p>示例 2:</p><pre><code>输入: nums = [1,0,1,1], k = 1, t = 2输出: true</code></pre><p>示例 3:</p><pre><code>输入: nums = [1,5,9,1,5,9], k = 2, t = 3输出: false</code></pre><h1 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h1><p>首先想到用HashSet来解决但超时了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            for (int j = nums[i] - t; j &lt;= nums[i] + t; j++) &#123;</span><br><span class="line">                if (set.contains(j)) &#123;</span><br><span class="line">//                    System.out.println(&quot;i=&quot;+i+&quot;, j=&quot;+j);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">            if (set.size() &gt; k) &#123;</span><br><span class="line">                set.remove(nums[i - k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看一下官方题解<a href="https://leetcode-cn.com/problems/contains-duplicate-iii/solution/cun-zai-zhong-fu-yuan-su-iii-by-leetcode/" target="_blank" rel="noopener">^1</a></p><h1 id="二叉搜索树-【通过】"><a href="#二叉搜索树-【通过】" class="headerlink" title="二叉搜索树 【通过】"></a>二叉搜索树 【通过】</h1><p>总结一下该方法引入自平衡二叉搜索树，来保证能在O(logn) 时间内完成 插入，搜索，删除 操作。减少对滑动窗口中符合条件的元素操作所需的时间。</p><p>下面给出整个算法的伪代码：</p><pre><code>初始化一颗空的二叉搜索树 set对于每个元素xx，遍历整个数组    在 set 上查找大于等于xx的最小的数，如果s - x \leq ts−x≤t则返回 true    在 set 上查找小于等于xx的最大的数，如果x - g \leq tx−g≤t则返回 true    在 set 中插入xx    如果树的大小超过了kk, 则移除最早加入树的那个数。返回 false</code></pre><p>我们把大于等于 <em>x</em> 的最小的数 <em>s</em> 当做 <em>x</em> 在 BST 中的后继节点。同样的，我们能把小于等于 <em>x</em> 最大的数 <em>g</em> 当做 <em>x</em> 在 BST 中的前继节点。<em>s</em> 和 <em>g</em> 这两个数是距离 <em>x</em> 最近的数。因此只需要检查它们和 <em>x</em> 的距离就能知道条件二是否满足了。</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="comment">// Find the successor of current element</span></span><br><span class="line">        Integer s = set.ceiling(nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span> &amp;&amp; s &lt;= nums[i] + t) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find the predecessor of current element</span></span><br><span class="line">        Integer g = set.floor(nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (g != <span class="keyword">null</span> &amp;&amp; nums[i] &lt;= g + t) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        set.add(nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (set.size() &gt; k) &#123;</span><br><span class="line">            set.remove(nums[i - k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-ceiling-E-e-方法-2"><a href="#E-ceiling-E-e-方法-2" class="headerlink" title="E ceiling(E e) 方法^2"></a>E ceiling(E e) 方法<a href="http://gitbook.net/java/util/java_util_treeset.html" target="_blank" rel="noopener">^2</a></h2><p>用来返回大于或等于给定的元素的最小元素，如果不存在这样的元素返回null。</p><h2 id="E-floor-E-e-方法"><a href="#E-floor-E-e-方法" class="headerlink" title="E floor(E e) 方法"></a>E floor(E e) 方法</h2><p>此方法返回小于或等于给定的元素的最大元素，如果不存在这样的元素返回null。</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(n log (min(n,k)))<br>我们需要遍历这个 n 长度的数组。对于每次遍历，在 BST 中 搜索，插入 或者 删除 都需要花费 O(logmin(k, n))的时间。</p><p>空间复杂度：O(min(n,k))<br>空间复杂度由 BST 的大小决定，其大小的上限由 k 和 n 共同决定。</p><h2 id="溢出错误"><a href="#溢出错误" class="headerlink" title="溢出错误"></a>溢出错误</h2><p>当数组中的元素非常大的时候，进行数学运算可能造成溢出。所以可以考虑使用支持大数的数据类型，例如 long。</p><p>C++ 中的 std::set，std::set::upper_bound 和 std::set::lower_bound 分别等价于 Java 中的 TreeSet，TreeSet::ceiling 和 TreeSet::floor。Python 标准库不提供自平衡 BST。</p><p>当测试用例为</p><pre><code>[-2147483648,-2147483647]33</code></pre><p>时会溢出，为了解决这个问题，使用long类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) &#123;</span><br><span class="line">        TreeSet&lt;Long&gt; set = new TreeSet&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            // Find the successor of current element</span><br><span class="line">            Long s = set.ceiling((long) nums[i]);</span><br><span class="line">            if (s != null &amp;&amp; s &lt;= (long) nums[i] + t) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Find the predecessor of current element</span><br><span class="line">            Long g = set.floor((long) nums[i]);</span><br><span class="line">            if (g != null &amp;&amp; g &gt;= (long) nums[i] - t) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            set.add((long) nums[i]);</span><br><span class="line">            if (set.size() &gt; k) &#123;</span><br><span class="line">                set.remove((long) nums[i - k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法三-（桶）-【通过】"><a href="#方法三-（桶）-【通过】" class="headerlink" title="方法三 （桶） 【通过】"></a>方法三 （桶） 【通过】</h1><p><strong>思路</strong></p><p>受 <code>桶排序</code> 的启发，我们可以把 <em>桶</em> 当做窗口来实现一个线性复杂度的解法。</p><p><strong>算法</strong></p><p>桶排序是一种把元素分散到不同桶中的排序算法。接着把每个桶再独立地用不同的排序算法进行排序。桶排序的概览如下所示：</p><p>在上面的例子中，我们有 8 个未排序的整数。我们首先来创建五个桶，这五个桶分别包含 <em>[0,9], [10,19], [20, 29], [30, 39], [40, 49]</em> 这几个区间。这 8 个元素中的任何一个元素都在一个桶里面。对于值为 <em>x</em> 的元素来说，它所属桶的标签为 <em>x/w</em>，在这里我们让 <em>w = 10</em>。对于每个桶我们单独用其他排序算法进行排序，最后按照桶的顺序收集所有的元素就可以得到一个有序的数组了。</p><p>回到这个问题，我们尝试去解决的最大的问题在于：</p><blockquote><ol><li>对于给定的元素 <em>x</em>, 在窗口中是否有存在区间 <em>[x-t, x+t]</em> 内的元素？  </li><li>我们能在常量时间内完成以上判断嘛？</li></ol></blockquote><p>我们不妨把把每个元素当做一个人的生日来考虑一下吧。假设你是班上新来的一位学生，你的生日在 <em>三月</em> 的某一天，你想知道班上是否有人生日跟你生日在 <em>t=30</em> 天以内。在这里我们先假设每个月都是<em>30<em>天，很明显，我们只需要检查所有生日在 *二月</em>，<em>三月</em>，*四月</em> 的同学就可以了。</p><p>之所以能这么做的原因在于，我们知道每个人的生日都属于一个桶，我们把这个桶称作月份！每个桶所包含的区间范围都是 <em>t</em>，这能极大的简化我们的问题。很显然，任何不在同一个桶或相邻桶的两个元素之间的距离一定是大于 <em>t</em> 的。</p><p>我们把上面提到的桶的思想应用到这个问题里面来，我们设计一些桶，让他们分别包含区间 <em>…, [0,t], [t+1, 2t+1], …*。我们把桶来当做窗口，于是每次我们只需要检查 *x</em> 所属的那个桶和相邻桶中的元素就可以了。终于，我们可以在常量时间解决在窗口中搜索的问题了。</p><p>还有一件值得注意的事！</p><p>这个问题和桶排序的不同之处在于每次我们的桶里只需要包含最多一个元素就可以了，因为如果任意一个桶中包含了两个元素，那么这也就是意味着这两个元素是 <em>足够接近的</em> 了，这时候我们就直接得到答案了。因此，我们只需使用一个标签为桶序号的散列表就可以了。 </p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Get the ID of the bucket from element value x and bucket width w</span></span><br><span class="line">    <span class="comment">// In Java, `-3 / 5 = 0` and but we need `-3 / 5 = -1`.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getID</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; <span class="number">0</span> ? (x + <span class="number">1</span>) / w - <span class="number">1</span> : x / w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// Key: ID of the bucket   Value: bucket  value</span></span><br><span class="line">        Map&lt;Long, Long&gt; d = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">long</span> w = (<span class="keyword">long</span>)t + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">long</span> m = getID(nums[i], w);</span><br><span class="line">            <span class="comment">// check if bucket m is empty, each bucket may contain at most one element</span></span><br><span class="line">            <span class="keyword">if</span> (d.containsKey(m))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// check the neighbor buckets for almost duplicate</span></span><br><span class="line">            <span class="keyword">if</span> (d.containsKey(m - <span class="number">1</span>) &amp;&amp; Math.abs(nums[i] - d.get(m - <span class="number">1</span>)) &lt; w)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (d.containsKey(m + <span class="number">1</span>) &amp;&amp; Math.abs(nums[i] - d.get(m + <span class="number">1</span>)) &lt; w)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// now bucket m is empty and no almost duplicate in nei***or buckets</span></span><br><span class="line">            d.put(m, (<span class="keyword">long</span>)nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k) d.remove(getID(nums[i - k], w));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(n)</em></li></ul><p>对于这 <em>n</em> 个元素中的任意一个元素来说，我们最多只需要在散列表中做三次 <code>搜索</code>，一次 <code>插入</code> 和一次 <code>删除</code>。这些操作是常量时间复杂度的。因此，整个算法的时间复杂度为 <em>O(n)</em>。</p><ul><li>空间复杂度：O(min(n,k))<br>需要开辟的额外空间取决了散列表的大小，其大小跟它所包含的元素数量成线性关系。散列表的大小的上限同时由 <em>n</em> 和 <em>k</em> 决定。因此，空间复杂度为O(min(n,k))  。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在整数数组 nums 中，是否存在两个下标 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值小于等于 t ，且满足 i 和 j 的差的绝对值也小于等于 ķ 。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Sort" scheme="http://yoursite.com/tags/Sort/"/>
    
      <category term="Ordered Map" scheme="http://yoursite.com/tags/Ordered-Map/"/>
    
  </entry>
  
  <entry>
    <title>219. 存在重复元素II</title>
    <link href="http://yoursite.com/2020/06/29/219.%20%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II/"/>
    <id>http://yoursite.com/2020/06/29/219. 存在重复元素II/</id>
    <published>2020-06-29T06:33:12.000Z</published>
    <updated>2020-06-29T06:55:28.045Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: nums = [1,2,3,1], k = 3输出: true</code></pre><p>示例 2:</p><pre><code>输入: nums = [1,0,1,1], k = 1输出: true</code></pre><p>示例 3:</p><pre><code>输入: nums = [1,2,3,1,2,3], k = 2输出: false</code></pre><h1 id="解法一：HashMap"><a href="#解法一：HashMap" class="headerlink" title="解法一：HashMap"></a>解法一：HashMap</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean containsNearbyDuplicate(int[] nums, int k) &#123;</span><br><span class="line">        //Key-&gt;nums[i] , Value-&gt;i</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; hashMap=new HashMap&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (hashMap.containsKey(nums[i])) &#123;</span><br><span class="line">                if (Math.abs(i - hashMap.get(nums[i])) &lt;= k) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            hashMap.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法二-（散列表）"><a href="#方法二-（散列表）" class="headerlink" title="方法二 （散列表）"></a>方法二 （散列表）</h1><p><strong>思路</strong></p><p>用散列表来维护这个<em>k</em>大小的滑动窗口。<a href="https://leetcode-cn.com/problems/contains-duplicate-ii/solution/cun-zai-zhong-fu-yuan-su-ii-by-leetcode/" target="_blank" rel="noopener">^1</a></p><p><strong>算法</strong></p><p>在之前的方法中，我们知道了对数时间复杂度的 <code>搜索</code> 操作是不够的。在这个方法里面，我们需要一个支持在常量时间内完成 <code>搜索</code>，<code>删除</code>，<code>插入</code> 操作的数据结构，那就是散列表。这个算法的实现跟方法二几乎是一样的。</p><ul><li>遍历数组，对于每个元素做以下操作：<ul><li>在散列表中搜索当前元素，如果找到了就返回 <code>true</code>。</li><li>在散列表中插入当前元素。</li><li>如果当前散列表的大小超过了 <em>k</em>， 删除散列表中最旧的元素。</li></ul></li><li>返回 <code>false</code>。</li></ul><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(nums[i])) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        set.add(nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (set.size() &gt; k) &#123;</span><br><span class="line">            set.remove(nums[i - k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)</em><br>我们会做 <em>n</em> 次 <code>搜索</code>，<code>删除</code>，<code>插入</code> 操作，每次操作都耗费常数时间。</p></li><li><p>空间复杂度：O(min(n,k)) </p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>217. 存在重复元素</title>
    <link href="http://yoursite.com/2020/06/29/217.%20%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2020/06/29/217. 存在重复元素/</id>
    <published>2020-06-29T06:33:12.000Z</published>
    <updated>2020-06-29T06:41:10.110Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数数组，判断是否存在重复元素。如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。</p><a id="more"></a><h1 id="哈希表解决"><a href="#哈希表解决" class="headerlink" title="哈希表解决"></a>哈希表解决</h1><p>可以用Set或HashMap来解决</p><figure class="highlight java"><figcaption><span>[solution 3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(nums.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x: nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(x)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        set.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多详细分析见<a href="https://leetcode-cn.com/problems/contains-duplicate/solution/cun-zai-zhong-fu-yuan-su-by-leetcode/" target="_blank" rel="noopener">^1</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://leetcode-cn.com/problems/contains-duplicate-ii/" target="_blank" rel="noopener">219 存在重复元素 II</a></li><li><a href="https://leetcode-cn.com/problems/contains-duplicate-iii/" target="_blank" rel="noopener">220 存在重复元素 III</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数数组，判断是否存在重复元素。如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>152. 乘积最大子数组</title>
    <link href="http://yoursite.com/2020/06/29/152.%20%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2020/06/29/152. 乘积最大子数组/</id>
    <published>2020-06-29T06:06:12.000Z</published>
    <updated>2020-06-29T06:23:19.793Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。</code></pre><p>示例 2:</p><pre><code>输入: [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</code></pre><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这道题比较经典，官方解法可以见<a href="https://leetcode-cn.com/problems/maximum-product-subarray/solution/cheng-ji-zui-da-zi-shu-zu-by-leetcode-solution/" target="_blank" rel="noopener">^1</a>,我首先想到用全局变量和局部变量的方法来解决，但是要注意两个测试样例[-2]和[0,2]，需要对全局和局部最大变量做相应处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProduct(int[] nums) &#123;</span><br><span class="line">        int maxpro=nums[0];</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            int localpro=nums[i];</span><br><span class="line">            maxpro = Math.max(maxpro, localpro);</span><br><span class="line">            for (int j = i+1; j &lt; nums.length; j++) &#123;</span><br><span class="line">                localpro *= nums[j];</span><br><span class="line">                maxpro = Math.max(maxpro, localpro);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxpro;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>189. 旋转数组</title>
    <link href="http://yoursite.com/2020/06/29/189.%20%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2020/06/29/189. 旋转数组/</id>
    <published>2020-06-29T06:06:12.000Z</published>
    <updated>2020-06-29T06:23:14.982Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4]</code></pre><p>示例 2:</p><pre><code>输入: [-1,-100,3,99] 和 k = 2输出: [3,99,-1,-100]解释: 向右旋转 1 步: [99,-1,-100,3]向右旋转 2 步: [3,99,-1,-100]</code></pre><p>说明:</p><pre><code>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。要求使用空间复杂度为 O(1) 的 原地 算法。</code></pre><h2 id="方法-1：暴力"><a href="#方法-1：暴力" class="headerlink" title="方法 1：暴力"></a>方法 1：暴力</h2><p>最简单的方法是旋转 k 次，每次将数组旋转 1 个元素。</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp, previous;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            previous = nums[nums.length - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                temp = nums[j];</span><br><span class="line">                nums[j] = previous;</span><br><span class="line">                previous = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(n*k)</em> 。每个元素都被移动 1 步（<em>O(n)</em>） k次（<em>O(k)</em>） 。</li><li>空间复杂度：<em>O(1)</em> 。没有额外空间被使用。</li></ul><h2 id="方法-2：使用额外的数组"><a href="#方法-2：使用额外的数组" class="headerlink" title="方法 2：使用额外的数组"></a>方法 2：使用额外的数组</h2><p><strong>算法</strong></p><p>我们可以用一个额外的数组来将每个元素放到正确的位置上，也就是原本数组里下标为 <em>i</em> 的我们把它放到 <img src="./p___i+k_%%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6_.png" alt="(i+k)\%数组长度 ">  的位置。然后把新的数组拷贝到原数组中。</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            a[(i + k) % nums.length] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度： <em>O(n)</em> 。将数字放到新的数组中需要一遍遍历，另一边来把新数组的元素拷贝回原数组。</li><li>空间复杂度： <em>O(n)</em>。另一个数组需要原数组长度的空间。</li></ul><h2 id="方法-3：使用环状替换"><a href="#方法-3：使用环状替换" class="headerlink" title="方法 3：使用环状替换"></a>方法 3：使用环状替换</h2><p><strong>算法</strong></p><p>如果我们直接把每一个数字放到它最后的位置，但这样的后果是遗失原来的元素。因此，我们需要把被替换的数字保存在变量 <em>temp</em> 里面。然后，我们将被替换数字（<em>temp*）放到它正确的位置，并继续这个过程 *n</em> 次， <em>n</em> 是数组的长度。这是因为我们需要将数组里所有的元素都移动。但是，这种方法可能会有个问题，如果 <img src="./p__n%k==0_.png" alt="n\%k==0 "> ，其中 <img src="./p__k=k%n_.png" alt="k=k\%n ">  （因为如果 <em>k</em> 大于 <em>n</em> ，移动 <em>k</em> 次实际上相当于移动 <img src="./p__k%n_.png" alt="k\%n ">  次）。这种情况下，我们会发现在没有遍历所有数字的情况下回到出发数字。此时，我们应该从下一个数字开始再重复相同的过程。</p><p>现在，我们看看上面方法的证明。假设，数组里我们有 <em>n</em> 个元素并且 <em>k</em> 是要求移动的次数。更进一步，假设 <img src="./p__n%k=0_.png" alt="n\%k=0 ">  。第一轮中，所有移动数字的下标 <em>i</em> 满足 <img src="./p__i%k==0_.png" alt="i\%k==0 ">  。这是因为我们每跳 <em>k</em> 步，我们只会到达相距为 <em>k</em> 个位置下标的数。每一轮，我们都会移动 <img src="./p__frac%7Bn%7D%7Bk%7D_.png" alt="\frac{n}{k} ">  个元素。下一轮中，我们会移动满足 <img src="./p__i%k==1_.png" alt="i\%k==1 ">  的位置的数。这样的轮次会一直持续到我们再次遇到 <img src="./p__i%k==0_.png" alt="i\%k==0 ">  的地方为止，此时 <em>i=k</em> 。此时在正确位置上的数字共有 <img src="./p__k_times_frac%7Bn%7D%7Bk%7D=n_.png" alt="k\times\frac{n}{k}=n ">  个。因此所有数字都在正确位置上。</p><p>让我们看一下接下来的例子，以更好地说明这个过程：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums: [1, 2, 3, 4, 5, 6]</span><br><span class="line">k: 2</span><br></pre></td></tr></table></figure></p><p> <a href="https://pic.leetcode-cn.com/f0493a97cdb7bc46b37306ca14e555451496f9f9c21effcad8517a81a26f30d6-image.png" target="_blank" rel="noopener">例子</a></p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k = k % nums.length;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; count &lt; nums.length; start++) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = start;</span><br><span class="line">            <span class="keyword">int</span> prev = nums[start];</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> next = (current + k) % nums.length;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[next];</span><br><span class="line">                nums[next] = prev;</span><br><span class="line">                prev = temp;</span><br><span class="line">                current = next;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">while</span> (start != current);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(n)</em> 。只遍历了每个元素一次。</li><li>空间复杂度：<em>O(1)</em> 。使用了常数个额外空间。</li></ul><h2 id="方法-4：使用反转"><a href="#方法-4：使用反转" class="headerlink" title="方法 4：使用反转"></a>方法 4：使用反转</h2><p><strong>算法</strong></p><p>这个方法基于这个事实：当我们旋转数组 k 次， <img src="./p__k%n_.png" alt="k\%n ">  个尾部元素会被移动到头部，剩下的元素会被向后移动。</p><p>在这个方法中，我们首先将所有元素反转。然后反转前 k 个元素，再反转后面 <em>n-k</em> 个元素，就能得到想要的结果。</p><p>我用这种方法来解决时遇到数组越界错误，是因为没有把k取模，因为有些情况下k可能大于数组长度。这个易错点需要注意。</p><p>假设 <em>n=7</em> 且 <em>k=3</em> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原始数组                  : 1 2 3 4 5 6 7</span><br><span class="line">反转所有数字后             : 7 6 5 4 3 2 1</span><br><span class="line">反转前 k 个数字后          : 5 6 7 4 3 2 1</span><br><span class="line">反转后 n-k 个数字后        : 5 6 7 1 2 3 4 --&gt; 结果</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k %= nums.length;</span><br><span class="line">        reverse(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, k, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[start];</span><br><span class="line">            nums[start] = nums[end];</span><br><span class="line">            nums[end] = temp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(n)</em> 。 <em>n</em> 个元素被反转了总共 3 次。</li><li>空间复杂度：<em>O(1)</em> 。 没有使用额外的空间。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>63. 不同路径II</title>
    <link href="http://yoursite.com/2020/06/28/63.%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II/"/>
    <id>http://yoursite.com/2020/06/28/63. 不同路径II/</id>
    <published>2020-06-28T12:50:12.000Z</published>
    <updated>2020-06-29T06:22:31.214Z</updated>
    
    <content type="html"><![CDATA[<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><a id="more"></a><p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p><p>说明：m 和 n 的值均不超过 100。</p><p>示例1:</p><pre><code>输入:[  [0,0,0],  [0,1,0],  [0,0,0]]输出: 2解释:3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</code></pre><h2 id="方法-1：动态规划-1"><a href="#方法-1：动态规划-1" class="headerlink" title="方法 1：动态规划^1"></a>方法 1：动态规划<a href="https://leetcode-cn.com/problems/unique-paths-ii/solution/bu-tong-lu-jing-ii-by-leetcode/" target="_blank" rel="noopener">^1</a></h2><p><strong>直觉</strong></p><p>机器人只可以向下和向右移动，因此第一行的格子只能从左边的格子移动到，第一列的格子只能从上方的格子移动到。</p><p>如果格子上有障碍，那么我们不考虑包含这个格子的任何路径。我们从左至右、从上至下的遍历整个数组，那么在到达某个顶点之前我们就已经获得了到达前驱节点的方案数，这就变成了一个<code>动态规划</code>问题。我们只需要一个 <code>obstacleGrid</code> 数组作为 DP 数组。</p><p><code>注意：</code> 根据题目描述，包含障碍物的格点有权值 <code>1</code>，我们依此来判断是否包含在路径中，然后我们可以用这个空间来存储到达这个格点的方案数。</p><p><strong>算法</strong></p><ol><li>如果第一个格点 <code>obstacleGrid[0,0]</code> 是 <code>1</code>，说明有障碍物，那么机器人不能做任何移动，我们返回结果 <code>0</code>。</li><li>否则，如果 <code>obstacleGrid[0,0]</code> 是 <code>0</code>，我们初始化这个值为 <code>1</code> 然后继续算法。</li><li>遍历第一行，如果有一个格点初始值为 <code>1</code> ，说明当前节点有障碍物，没有路径可以通过，设值为 <code>0</code> ；否则设这个值是前一个节点的值 <code>obstacleGrid[i,j] = obstacleGrid[i,j-1]</code>。</li><li>遍历第一列，如果有一个格点初始值为 <code>1</code> ，说明当前节点有障碍物，没有路径可以通过，设值为 <code>0</code> ；否则设这个值是前一个节点的值 <code>obstacleGrid[i,j] = obstacleGrid[i-1,j]</code>。</li><li>现在，从 <code>obstacleGrid[1,1]</code> 开始遍历整个数组，如果某个格点初始不包含任何障碍物，就把值赋为上方和左侧两个格点方案数之和 <code>obstacleGrid[i,j] = obstacleGrid[i-1,j] + obstacleGrid[i,j-1]</code>。</li><li>如果这个点有障碍物，设值为 <code>0</code> ，这可以保证不会对后面的路径产生贡献。</li></ol><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> R = obstacleGrid.length;</span><br><span class="line">        <span class="keyword">int</span> C = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the starting cell has an obstacle, then simply return as there would be</span></span><br><span class="line">        <span class="comment">// no paths to the destination.</span></span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Number of ways of reaching the starting cell = 1.</span></span><br><span class="line">        obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Filling the values for the first column</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; R; i++) &#123;</span><br><span class="line">            obstacleGrid[i][<span class="number">0</span>] = (obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; obstacleGrid[i - <span class="number">1</span>][<span class="number">0</span>] == <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Filling the values for the first row</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; C; i++) &#123;</span><br><span class="line">            obstacleGrid[<span class="number">0</span>][i] = (obstacleGrid[<span class="number">0</span>][i] == <span class="number">0</span> &amp;&amp; obstacleGrid[<span class="number">0</span>][i - <span class="number">1</span>] == <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Starting from cell(1,1) fill up the values</span></span><br><span class="line">        <span class="comment">// No. of ways of reaching cell[i][j] = cell[i - 1][j] + cell[i][j - 1]</span></span><br><span class="line">        <span class="comment">// i.e. From above and left.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; R; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; C; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    obstacleGrid[i][j] = obstacleGrid[i - <span class="number">1</span>][j] + obstacleGrid[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    obstacleGrid[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return value stored in rightmost bottommost cell. That is the destination.</span></span><br><span class="line">        <span class="keyword">return</span> obstacleGrid[R - <span class="number">1</span>][C - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 ： O(M\timesN)   。长方形网格的大小是 M\timesN ，而访问每个格点恰好一次。</li><li>空间复杂度 ： <em>O(1)</em>。我们利用 <code>obstacleGrid</code> 作为 DP 数组，因此不需要额外的空间。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
</feed>
