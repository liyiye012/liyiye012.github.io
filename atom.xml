<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-01-15T09:24:39.646Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo的spfk主题修改</title>
    <link href="http://yoursite.com/2020/01/15/Hexo%E7%9A%84spfk%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9/"/>
    <id>http://yoursite.com/2020/01/15/Hexo的spfk主题修改/</id>
    <published>2020-01-15T03:34:12.000Z</published>
    <updated>2020-01-15T09:24:39.646Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo的spfk主题修改</p><a id="more"></a><p>新年新气象，使用Hexo的spfk主题博客很久了，想要做一些主题上的改动，准备在保持简洁风格前提下适当加一些有趣的小功能。</p><h1 id="Hexo博客添加live2d卡通人物"><a href="#Hexo博客添加live2d卡通人物" class="headerlink" title="Hexo博客添加live2d卡通人物"></a>Hexo博客添加live2d卡通人物</h1><p>因为之前自己对卡通形象不太感冒所以没有在博客里加入卡通人物，这次在live2d里找到了几个还比较有趣的形象。<br>参见：<br><a href="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md" target="_blank" rel="noopener">https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md</a><br>Hexo</p><h2 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块:"></a>安装模块:</h2><pre><code>npm install --save hexo-helper-live2d</code></pre><h2 id="配置："><a href="#配置：" class="headerlink" title="配置："></a>配置：</h2><p>请向Hexo的_config.yml 文件或主题的_config.yml 文件中添加配置:</p><pre><code>live2d:  enable: true  scriptFrom: local  pluginRootPath: live2dw/  pluginJsPath: lib/  pluginModelPath: assets/  tagMode: false  debug: false  model:    use: live2d-widget-model-gf  display:    position: right    width: 150    height: 300  mobile:    show: true  react:    opacity: 0.7</code></pre><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>有许多方法来使用不同的模型:</p><p>a. live2d_models子目录名称<br>在博客根目录下创建一个 live2d_models 文件夹.</p><p>在此文件夹内新建一个子文件夹.</p><p>将 Live2D 模型复制到这个子文件夹中.</p><p>将子文件夹的名称输入_config.yml 的 model.use 中.</p><p>示例</p><pre><code>你的模型叫 mymiku.在博客根目录 (应当有_config.yml 、sources 、 themes ) 新建名为 mymiku 的子文件夹.将模型复制到 /live2d_models/mymiku/ 中.现在, 在这里应当有一个 .model.json 文件 (例如 mymiku.model.json)在 /live2d_models/mymiku/ 中.将 mymiku 输入到位于_config.yml 的 model.use 中.</code></pre><p>b. 相对于博客根目录的自定义路径<br>可直接输入相对于博客根目录的自定义路径到 model.use 中.</p><p>示例: ./wives/wanko</p><p>c. npm 模块名<br>使用现有的的模型<br>需要先使用 npm install 模型的包名 来安装,</p><p>然后将包名输入位于_config.yml 的 model.use 中.</p><p>但在安装过程中遇到问题：</p><pre><code>make: *** [Release/obj.target/fse/fsevents.o] Error 1gyp ERR! build errorgyp ERR! stack Error: `make` failed with exit code: 2gyp ERR! stack     at ChildProcess.onExit (/usr/local/lib/node_modules/npm/node_modules/node-gyp/lib/build.js:262:23)gyp ERR! stack     at ChildProcess.emit (events.js:203:13)gyp ERR! stack     at Process.ChildProcess._handle.onexit (internal/child_process.js:272:12)gyp ERR! System Darwin 18.7.0gyp ERR! command &quot;/usr/local/Cellar/node/12.6.0/bin/node&quot; &quot;/usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js&quot; &quot;build&quot; &quot;--fallback-to-build&quot; &quot;--module=/Users/liyiye/yiye-project/liyiye012.github.io/node_modules/fsevents/lib/binding/Release/node-v72-darwin-x64/fse.node&quot; &quot;--module_name=fse&quot; &quot;--module_path=/Users/liyiye/yiye-project/liyiye012.github.io/node_modules/fsevents/lib/binding/Release/node-v72-darwin-x64&quot; &quot;--napi_version=4&quot; &quot;--node_abi_napi=napi&quot;gyp ERR! cwd /Users/liyiye/yiye-project/liyiye012.github.io/node_modules/fseventsgyp ERR! node -v v12.6.0gyp ERR! node-gyp -v v3.8.0gyp ERR! not oknode-pre-gyp ERR! build errornode-pre-gyp ERR! stack Error: Failed to execute &apos;/usr/local/Cellar/node/12.6.0/bin/node /usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js build --fallback-to-build --module=/Users/liyiye/yiye-project/liyiye012.github.io/node_modules/fsevents/lib/binding/Release/node-v72-darwin-x64/fse.node --module_name=fse --module_path=/Users/liyiye/yiye-project/liyiye012.github.io/node_modules/fsevents/lib/binding/Release/node-v72-darwin-x64 --napi_version=4 --node_abi_napi=napi&apos; (1)</code></pre><p>类似问题在<a href="https://github.com/nodejs/node-gyp/issues/1547中找到：" target="_blank" rel="noopener">https://github.com/nodejs/node-gyp/issues/1547中找到：</a></p><p>执行命令：</p><pre><code>sudo npm i --unsafe-permsudo npm audit fix --forcesudo npm install live2d-widget-model-gf</code></pre><p>但做完这个功能后个人感觉有点花哨，容易分散阅读注意力，就暂时不上线了。</p><h1 id="添加字数统计和阅读时长"><a href="#添加字数统计和阅读时长" class="headerlink" title="添加字数统计和阅读时长"></a>添加字数统计和阅读时长</h1><p>先在博客目录下执行以下命令安装 hexo-wordcount 插件：</p><pre><code>$ npm i --save hexo-wordcount</code></pre><p>同样的，以 spfk 主题为例，在 \themes\hexo-theme-spfk\layout_partial\post 目录下创建 word.ejs 文件，在 word.ejs 文件中写入以下代码：</p><pre><code>&lt;div style=&quot;margin-top:10px;&quot;&gt;    &lt;span class=&quot;post-time&quot;&gt;      &lt;span class=&quot;post-meta-item-icon&quot;&gt;        &lt;i class=&quot;fa fa-keyboard-o&quot;&gt;&lt;/i&gt;        &lt;span class=&quot;post-meta-item-text&quot;&gt;  字数统计: &lt;/span&gt;        &lt;span class=&quot;post-count&quot;&gt;&lt;%= wordcount(post.content) %&gt;字&lt;/span&gt;      &lt;/span&gt;    &lt;/span&gt;    &amp;nbsp; | &amp;nbsp;    &lt;span class=&quot;post-time&quot;&gt;      &lt;span class=&quot;post-meta-item-icon&quot;&gt;        &lt;i class=&quot;fa fa-hourglass-half&quot;&gt;&lt;/i&gt;        &lt;span class=&quot;post-meta-item-text&quot;&gt;  阅读时长: &lt;/span&gt;        &lt;span class=&quot;post-count&quot;&gt;&lt;%= min2read(post.content) %&gt;分&lt;/span&gt;      &lt;/span&gt;    &lt;/span&gt;&lt;/div&gt;</code></pre><p>然后在 \themes\hexo-theme-spfk\layout_partial\article.ejs 中适当位置添加以下代码：<br>添加前：</p><pre><code>&lt;% if (post.link || post.title){ %&gt;  &lt;header class=&quot;article-header&quot;&gt;    &lt;%- partial(&apos;post/title&apos;, {class_name: &apos;article-title&apos;}) %&gt;  &lt;/header&gt;</code></pre><p>添加后：</p><pre><code>&lt;% if (post.link || post.title){ %&gt;  &lt;header class=&quot;article-header&quot;&gt;    &lt;%- partial(&apos;post/title&apos;, {class_name: &apos;article-title&apos;}) %&gt;  &lt;% if(theme.word_count &amp;&amp; !post.no_word_count){ %&gt;    &lt;%- partial(&apos;post/word&apos;) %&gt;    &lt;% } %&gt;  &lt;/header&gt;</code></pre><p>最后在主题目录下的 _config.yml 添加以下配置</p><pre><code>word_count: true</code></pre><p>另外：要在博客底部显示所有文章的总字数，可以点击此处，根据你博客底部文件的类型选择相应的代码放在适当的位置即可，前提是要安装好 hexo-wordcount 插件，例如我使用 spfk 主题，在 \themes\material-x\layout_partial 目录下的 footer.ejs 文件中添加如下代码：</p><pre><code>&lt;i class=&quot;fas fa-chart-area&quot;&gt;&lt;/i&gt;&lt;span class=&quot;post-count&quot;&gt;字数统计：&lt;%= totalcount(site) %&gt;&lt;/span&gt;</code></pre><p>添加前的位置：</p><pre><code>&lt;div class=&quot;outer&quot;&gt;    &lt;div id=&quot;footer-info&quot;&gt;        &lt;div class=&quot;footer-left&quot;&gt;            &amp;copy; &lt;%= date(new Date(), &apos;YYYY&apos;) %&gt; &lt;%= config.author || config.title %&gt;        &lt;/div&gt;        &lt;div class=&quot;footer-right&quot;&gt;            &lt;a href=&quot;http://hexo.io/&quot; target=&quot;_blank&quot;&gt;Hexo&lt;/a&gt;  Theme &lt;a href=&quot;https://github.com/luuman/hexo-theme-spfk&quot; target=&quot;_blank&quot;&gt;spfk&lt;/a&gt; by luuman        &lt;/div&gt;    &lt;/div&gt;</code></pre><p>添加后的位置：</p><pre><code>&lt;div class=&quot;outer&quot;&gt;    &lt;div id=&quot;footer-info&quot;&gt;        &lt;div class=&quot;footer-left&quot;&gt;            &amp;copy; &lt;%= date(new Date(), &apos;YYYY&apos;) %&gt; &lt;%= config.author || config.title %&gt;        &lt;/div&gt;        &lt;i class=&quot;fas fa-chart-area&quot;&gt;&lt;/i&gt;            &lt;span class=&quot;post-count&quot;&gt;总字数：&lt;%= totalcount(site) %&gt;&lt;/span&gt;        &lt;div class=&quot;footer-right&quot;&gt;            &lt;a href=&quot;http://hexo.io/&quot; target=&quot;_blank&quot;&gt;Hexo&lt;/a&gt;  Theme &lt;a href=&quot;https://github.com/luuman/hexo-theme-spfk&quot; target=&quot;_blank&quot;&gt;spfk&lt;/a&gt; by luuman        &lt;/div&gt;    &lt;/div&gt;</code></pre><h1 id="添加网站运行时间"><a href="#添加网站运行时间" class="headerlink" title="添加网站运行时间"></a>添加网站运行时间</h1><p>一个比较好的小功能，可以看见自己的博客运行多久了，时间一天天的增加，成就感也会一天天增加的<br>在 \themes\hexo-theme-spfk\layout_partial\footer.ejs 文件下添加以下代码：</p><pre><code>&lt;span id=&quot;timeDate&quot;&gt;载入天数...&lt;/span&gt;&lt;span id=&quot;times&quot;&gt;载入时分秒...&lt;/span&gt;&lt;script&gt;    var now = new Date();    function createtime() {        var grt= new Date(&quot;16/11/2017 21:14:20&quot;);//在此处修改你的建站时间，格式：月/日/年 时:分:秒        now.setTime(now.getTime()+250);        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);        if(String(hnum).length ==1 ){hnum = &quot;0&quot; + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = &quot;0&quot; + mnum;}        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = &quot;0&quot; + snum;}        document.getElementById(&quot;timeDate&quot;).innerHTML = &quot;本站已安全运行 &quot;+dnum+&quot; 天 &quot;;        document.getElementById(&quot;times&quot;).innerHTML = hnum + &quot; 小时 &quot; + mnum + &quot; 分 &quot; + snum + &quot; 秒&quot;;    }setInterval(&quot;createtime()&quot;,250);&lt;/script&gt;</code></pre><h1 id="访问量统计"><a href="#访问量统计" class="headerlink" title="访问量统计"></a>访问量统计</h1><p>使用不蒜子提供的服务，因为其域名更改，所以把原有的：</p><pre><code>&lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</code></pre><p>域名改一下即可：</p><pre><code>&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</code></pre><h1 id="安装脚本（必选）"><a href="#安装脚本（必选）" class="headerlink" title="安装脚本（必选）"></a>安装脚本（必选）</h1><p>要使用不蒜子必须在页面中引入busuanzi.js，目前最新版如下。</p><pre><code>&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</code></pre><p>不蒜子可以给任何类型的个人站点使用，如果是用的hexo，打开themes/主题/layout/_partial/footer.ejs添加上述脚本即可，当然你也可以添加到 header 中。</p><h1 id="安装标签（可选）"><a href="#安装标签（可选）" class="headerlink" title="安装标签（可选）"></a>安装标签（可选）</h1><p>只需要复制相应的html标签到网站要显示访问量的位置即可。可以随意更改不蒜子标签为自己喜欢的显示效果，内容参考第三部分扩展开发。根据要显示内容的不同，这分几种情况。</p><h2 id="显示站点总访问量"><a href="#显示站点总访问量" class="headerlink" title="显示站点总访问量"></a>显示站点总访问量</h2><p>要显示站点总访问量，复制以下代码添加到你需要显示的位置。有两种算法可选：</p><p>算法a：pv的方式，单个用户连续点击n篇文章，记录n次访问量。</p><pre><code>&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;    本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt;</code></pre><p>算法b：uv的方式，单个用户连续点击n篇文章，只记录1次访客数。</p><pre><code>&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;  本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次&lt;/span&gt;</code></pre><p>如果你是用的hexo，打开themes/主题/layout/_partial/footer.ejs添加即可。</p><h1 id="显示单页面访问量"><a href="#显示单页面访问量" class="headerlink" title="显示单页面访问量"></a>显示单页面访问量</h1><p>要显示每篇文章的访问量，复制以下代码添加到需要显示的位置。</p><p>算法：pv的方式，单个用户点击1篇文章，本篇文章记录1次阅读量。</p><pre><code>&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt;  本文总阅读量&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt;</code></pre><p>代码中文字是可以修改的，只要保留id正确即可。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="https://cniter.github.io/posts/b1e9411b.html" target="_blank" rel="noopener">https://cniter.github.io/posts/b1e9411b.html</a><br>【2】<a href="https://blog.csdn.net/qq_36759224/article/details/85420403" target="_blank" rel="noopener">https://blog.csdn.net/qq_36759224/article/details/85420403</a><br>【3】<a href="https://zhuanlan.zhihu.com/p/69213954" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/69213954</a><br>【4】<a href="https://www.itrhx.com/2018/08/27/A04-Hexo-blog-topic-personalization/" target="_blank" rel="noopener">https://www.itrhx.com/2018/08/27/A04-Hexo-blog-topic-personalization/</a><br>【5】<a href="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md" target="_blank" rel="noopener">https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md</a><br>【6】<a href="http://ibruce.info/2015/04/04/busuanzi/" target="_blank" rel="noopener">http://ibruce.info/2015/04/04/busuanzi/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hexo的spfk主题修改&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Effctive-Java阅读笔记VII</title>
    <link href="http://yoursite.com/2020/01/15/Effctive-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0VII/"/>
    <id>http://yoursite.com/2020/01/15/Effctive-Java阅读笔记VII/</id>
    <published>2020-01-15T02:48:12.000Z</published>
    <updated>2020-01-15T03:19:40.001Z</updated>
    
    <content type="html"><![CDATA[<p>第三章阅读：Methods Common to All Objects<br>13.谨慎地重写 clone 方法</p><a id="more"></a><h1 id="谨慎地重写-clone-方法"><a href="#谨慎地重写-clone-方法" class="headerlink" title="谨慎地重写 clone 方法"></a>谨慎地重写 clone 方法</h1><p>TODO：前面这几段没有读懂，留待看过20/65条后再回头来读。</p><p>Cloneable 接口的目的是作为一个 mixin 接口 （详见第 20 条），公布这样的类允许克隆。不幸的是，它没有达到这个目的。它的主要缺点是缺少 clone 方法，而 Object 的 clone 方法是受保护的。你不能，不借助反射 （详见第 65 条），仅仅因为它实现了 Cloneable 接口，就调用对象上的 clone 方法。即使是反射调用也可能失败，因为不能保证对象具有可访问的 clone 方法。尽管存在许多缺陷，该机制在合理的范围内使用，所以理解它是值得的。这个条目告诉你如何实现一个行为良好的 clone 方法，在适当的时候讨论这个方法，并提出替代方案。</p><p>　　既然 Cloneable 接口不包含任何方法，那它用来做什么？ 它决定了 Object 的受保护的 clone 方法实现的行为：如果一个类实现了 Cloneable 接口，那么 Object 的 clone 方法将返回该对象的逐个属性（field-by-field）拷贝；否则会抛出 CloneNotSupportedException 异常。这是一个非常反常的接口使用，而不应该被效仿。 通常情况下，实现一个接口用来表示可以为客户做什么。但对于 Cloneable 接口，它会修改父类上受保护方法的行为。</p><p>　　虽然规范并没有说明，但在实践中，实现 Cloneable 接口的类希望提供一个正常运行的公共 clone 方法。为了实现这一目标，该类及其所有父类必须遵循一个复杂的、不可执行的、稀疏的文档协议。由此产生的机制是脆弱的、危险的和不受语言影响的（extralinguistic）：它创建对象而不需要调用构造方法。</p><p>　　clone 方法的通用规范很薄弱的。 以下内容是从 Object 规范中复制出来的：</p><p>　　创建并返回此对象的副本。 「复制（copy）」的确切含义可能取决于对象的类。 一般意图是，对于任何对象 x，表达式 x.clone() != x 返回 true，并且 x.clone().getClass() == x.getClass() 也返回 true，但它们不是绝对的要求，但通常情况下，x.clone().equals(x) 返回 true，当然这个要求也不是绝对的。</p><p>　　根据约定，这个方法返回的对象应该通过调用 super.clone 方法获得的。 如果一个类和它的所有父类（Object 除外）都遵守这个约定，情况就是如此，x.clone().getClass() == x.getClass()。</p><p>　　根据约定，返回的对象应该独立于被克隆的对象。 为了实现这种独立性，在返回对象之前，可能需要修改由 super.clone 返回的对象的一个或多个属性。</p><p>　　这种机制与构造方法链（chaining）很相似，只是它没有被强制执行；如果一个类的 clone 方法返回一个通过调用构造方法获得而不是通过调用 super.clone 的实例，那么编译器不会抱怨，但是如果一个类的子类调用了 super.clone，那么返回的对象包含错误的类，从而阻止子类 clone 方法正常执行。如果一个类重写的 clone 方法是有 final 修饰的，那么这个约定可以被安全地忽略，因为子类不需要担心。但是，如果一个 final 类有一个不调用 super.clone 的 clone 方法，那么这个类没有理由实现 Cloneable 接口，因为它不依赖于 Object 的 clone 实现的行为。</p><p>　　假设你希望在一个类中实现 Cloneable 接口，它的父类提供了一个行为良好的 clone 方法。首先调用 super.clone。 得到的对象将是原始的完全功能的复制品。 在你的类中声明的任何属性将具有与原始属性相同的值。 如果每个属性包含原始值或对不可变对象的引用，则返回的对象可能正是你所需要的，在这种情况下，不需要进一步的处理。 例如，对于条目 11 中的 PhoneNumber 类，情况就是这样，但是请注意，不可变类永远不应该提供 clone 方法，因为这只会浪费复制。 有了这个警告，以下是 PhoneNumber 类的 clone 方法：</p><pre><code>// Clone method for class with no references to mutable state@Override public PhoneNumber clone() {    try {        return (PhoneNumber) super.clone();    } catch (CloneNotSupportedException e) {        throw new AssertionError();  // Can&apos;t happen    }}</code></pre><p>为了使这个方法起作用，PhoneNumber 的类声明必须被修改，以表明它实现了 Cloneable 接口。 虽然 Object 类的 clone 方法返回 Object 类，但是这个 clone 方法返回 PhoneNumber 类。 这样做是合法和可取的，<strong><em>因为 Java 支持协变返回类型。 换句话说，重写方法的返回类型可以是重写方法的返回类型的子类。</em></strong> 这消除了在客户端转换的需要。 在返回之前，我们必须将 Object 的 super.clone 的结果强制转换为 PhoneNumber，但保证强制转换成功。</p><p>　　super.clone 的调用包含在一个 try-catch 块中。 这是因为 Object 声明了它的 clone 方法来抛出 CloneNotSupportedException 异常，这是一个检查时异常。 由于 PhoneNumber 实现了 Cloneable 接口，所以我们知道调用 super.clone 会成功。 这里引用的需要表明 CloneNotSupportedException 应该是未被检查的（详见第 71条）。</p><p>　　如果对象包含引用可变对象的属性，则前面显示的简单 clone 实现可能是灾难性的。 例如，考虑条目 7 中的 Stack 类：</p><pre><code>public class Stack {    private Object[] elements;    private int size = 0;    private static final int DEFAULT_INITIAL_CAPACITY = 16;    public Stack() {        this.elements = new Object[DEFAULT_INITIAL_CAPACITY];    }    public void push(Object e) {        ensureCapacity();        elements[size++] = e;    }    public Object pop() {        if (size == 0)            throw new EmptyStackException();        Object result = elements[--size];        elements[size] = null; // Eliminate obsolete reference        return result;    }    // Ensure space for at least one more element.    private void ensureCapacity() {        if (elements.length == size)            elements = Arrays.copyOf(elements, 2 * size + 1);    }}</code></pre><p>假设你想让这个类可以克隆。 如果 clone 方法仅返回 super.clone() 调用的对象，那么生成的 Stack 实例在其 size 属性中具有正确的值，但 elements 属性引用与原始 Stack 实例相同的数组。 修改原始实例将破坏克隆中的不变量，反之亦然。 你会很快发现你的程序产生了无意义的结果，或者抛出 NullPointerException 异常。</p><p>　　这种情况永远不会发生，因为调用 Stack 类中的唯一构造方法。 实际上，clone 方法作为另一种构造方法; 必须确保它不会损坏原始对象，并且可以在克隆上正确建立不变量。 为了使 Stack 上的 clone 方法正常工作，它必须复制 stack 对象的内部。 最简单的方法是对元素数组递归调用 clone 方法：</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="http://sjsdfg.gitee.io/effective-java-3rd-chinese/#/notes/13.%20%E8%B0%A8%E6%85%8E%E5%9C%B0%E9%87%8D%E5%86%99%20clone%20%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">http://sjsdfg.gitee.io/effective-java-3rd-chinese/#/notes/13.%20%E8%B0%A8%E6%85%8E%E5%9C%B0%E9%87%8D%E5%86%99%20clone%20%E6%96%B9%E6%B3%95</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第三章阅读：Methods Common to All Objects&lt;br&gt;13.谨慎地重写 clone 方法&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Effctive-Java阅读笔记VI</title>
    <link href="http://yoursite.com/2020/01/14/Effctive-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0VI/"/>
    <id>http://yoursite.com/2020/01/14/Effctive-Java阅读笔记VI/</id>
    <published>2020-01-14T06:56:12.000Z</published>
    <updated>2020-01-15T02:48:53.520Z</updated>
    
    <content type="html"><![CDATA[<p>第三章阅读：Methods Common to All Objects<br>11.重写 equals 方法时同时也要重写 hashcode 方法<br>12.始终重写 toString 方法</p><a id="more"></a><h1 id="重写-equals-方法时同时也要重写-hashcode-方法"><a href="#重写-equals-方法时同时也要重写-hashcode-方法" class="headerlink" title="重写 equals 方法时同时也要重写 hashcode 方法"></a>重写 equals 方法时同时也要重写 hashcode 方法</h1><p>在每个类中，在重写 equals 方法的时侯，一定要重写 hashcode 方法。 如果不这样做，你的类违反了 hashCode 的通用约定，这会阻止它在 HashMap 和 HashSet 这样的集合中正常工作。根据 Object 规范，以下时具体约定。</p><p>1.当在一个应用程序执行过程中，如果在 equals 方法比较中没有修改任何信息，在一个对象上重复调用 hashCode 方法时，它必须始终返回相同的值。从一个应用程序到另一个应用程序的每一次执行返回的值可以是不一致的。<br>2.如果两个对象根据 equals(Object) 方法比较是相等的，那么在两个对象上调用 hashCode 就必须产生的结果是相同的整数。<br>3.如果两个对象根据 equals(Object) 方法比较并不相等，则不要求在每个对象上调用 hashCode 都必须产生不同的结果。 但是，程序员应该意识到，为不相等的对象生成不同的结果可能会提高散列表（hash tables）的性能。<br>　　当无法重写 hashCode 时，所违反第二个关键条款是：相等的对象必须具有相等的哈希码（ hash codes）。 根据类的 equals 方法，两个不同的实例可能在逻辑上是相同的，但是对于 Object 类的 hashCode 方法，它们只是两个没有什么共同之处的对象。因此， Object 类的 hashCode 方法返回两个看似随机的数字，而不是按约定要求的两个相等的数字。</p><p>举例说明，假设你使用条目 10 中的 PhoneNumber 类的实例做为 HashMap 的键（key）：</p><pre><code>Map&lt;PhoneNumber, String&gt; m = new HashMap&lt;&gt;();m.put(new PhoneNumber(707, 867, 5309), &quot;Jenny&quot;);</code></pre><p>你可能期望 m.get(new PhoneNumber(707, 867, 5309)) 方法返回 Jenny 字符串，但实际上，返回了 null。注意，这里涉及到两个 PhoneNumber 实例：一个实例插入到 HashMap 中，另一个作为判断相等的实例用来检索。PhoneNumber 类没有重写 hashCode 方法导致两个相等的实例返回了不同的哈希码，违反了 hashCode 约定。put 方法把 PhoneNumber 实例保存在了一个哈希桶（ hash bucket）中，但 get 方法却是从不同的哈希桶中去查找，即使恰好两个实例放在同一个哈希桶中，get 方法几乎肯定也会返回 null。因为 HashMap 做了优化，缓存了与每一项（entry）相关的哈希码，如果哈希码不匹配，则不会检查对象是否相等了。</p><p>　　解决这个问题很简单，只需要为 PhoneNumber 类重写一个合适的 hashCode 方法。hashCode 方法是什么样的？写一个不规范的方法的是很简单的。以下示例，虽然永远是合法的，但绝对不能这样使用：</p><pre><code>// The worst possible legal hashCode implementation - never use!@Override public int hashCode() { return 42; }</code></pre><p>这是合法的，因为它确保了相等的对象具有相同的哈希码。这很糟糕，因为它确保了每个对象都有相同的哈希码。因此，每个对象哈希到同一个桶中，哈希表退化为链表。应该在线性时间内运行的程序，运行时间变成了平方级别。对于数据很大的哈希表而言，会影响到能够正常工作。</p><p>　　一个好的 hash 方法趋向于为不相等的实例生成不相等的哈希码。这也正是 hashCode 约定中第三条的表达。理想情况下，hash 方法为集合中不相等的实例均匀地分配 int 范围内的哈希码。实现这种理想情况可能是困难的。 幸运的是，要获得一个合理的近似的方式并不难。 以下是一个简单的配方：</p><p>1.声明一个 int 类型的变量 result，并将其初始化为对象中第一个重要属性 c 的哈希码，如下面步骤 2.a 中所计算的那样。（回顾条目 10，重要的属性是影响比较相等的领域。）</p><p>2.对于对象中剩余的重要属性 f，请执行以下操作：<br>a. 比较属性 f 与属性 c 的 int 类型的哈希码：</p><pre><code>-- i. 如果这个属性是基本类型的，使用 Type.hashCode(f) 方法计算，其中 Type 类是对应属性 f 基本类型的包装类。-- ii. 如果该属性是一个对象引用，并且该类的 equals 方法通过递归调用 equals 来比较该属性，并递归地调用 hashCode 方法。 如果需要更复杂的比较，则计算此字段的“范式（“canonical representation）”，并在范式上调用 hashCode。 如果该字段的值为空，则使用 0（也可以使用其他常数，但通常来使用 0 表示）。 -- iii. 如果属性 f 是一个数组，把它看作每个重要的元素都是一个独立的属性。 也就是说，通过递归地应用这些规则计算每个重要元素的哈希码，并且将每个步骤 2.b 的值合并。 如果数组没有重要的元素，则使用一个常量，最好不要为 0。如果所有元素都很重要，则使用 Arrays.hashCode 方法。</code></pre><p>b. 将步骤 2.a 中属性 c 计算出的哈希码合并为如下结果：result = 31 * result + c;</p><p>3.返回 result 值。</p><p>当你写完 hashCode 方法后，问自己是否相等的实例有相同的哈希码。 编写单元测试来验证你的直觉（除非你使用 AutoValue 框架来生成你的 equals 和 hashCode 方法，在这种情况下，你可以放心地忽略这些测试）。 如果相同的实例有不相等的哈希码，找出原因并解决问题。</p><p>　　可以从哈希码计算中排除派生属性（derived fields）。换句话说，如果一个属性的值可以根据参与计算的其他属性值计算出来，那么可以忽略这样的属性。您必须排除在 equals 比较中没有使用的任何属性，否则可能会违反 hashCode 约定的第二条。</p><p>　　步骤 2.b 中的乘法计算结果取决于属性的顺序，如果类中具有多个相似属性，则产生更好的散列函数。 例如，如果乘法计算从一个 String 散列函数中被省略，则所有的字符将具有相同的散列码。 之所以选择 31，因为它是一个奇数的素数。 如果它是偶数，并且乘法溢出，信息将会丢失，因为乘以 2 相当于移位。 使用素数的好处不太明显，但习惯上都是这么做的。 31 的一个很好的特性，是在一些体系结构中乘法可以被替换为移位和减法以获得更好的性能：31 * i ==（i &lt;&lt; 5） - i。 现代 JVM 可以自动进行这种优化。</p><p>　　让我们把上述办法应用到 PhoneNumber 类中：</p><pre><code>// Typical hashCode method@Overridepublic int hashCode() {    int result = Short.hashCode(areaCode);    result = 31 * result + Short.hashCode(prefix);    result = 31 * result + Short.hashCode(lineNum);    return result;}</code></pre><p>因为这个方法返回一个简单的确定性计算的结果，它的唯一的输入是 PhoneNumber 实例中的三个重要的属性，所以显然相等的 PhoneNumber 实例具有相同的哈希码。 实际上，这个方法是 PhoneNumber 的一个非常好的 hashCode 实现，与 Java 平台类库中的实现一样。 它很简单，速度相当快，并且合理地将不相同的电话号码分散到不同的哈希桶中。</p><p>　　虽然在这个项目的方法产生相当好的哈希函数，但并不是最先进的。 它们的质量与 Java 平台类库的值类型中找到的哈希函数相当，对于大多数用途来说都是足够的。 如果真的需要哈希函数而不太可能产生碰撞，请参阅 Guava 框架的的com.google.common.hash.Hashing [Guava] 方法。</p><p>　　Objects 类有一个静态方法，它接受任意数量的对象并为它们返回一个哈希码。 这个名为 hash 的方法可以让你编写一行 hashCode 方法，其质量与根据这个项目中的上面编写的方法相当。 不幸的是，它们的运行速度更慢，因为它们需要创建数组以传递可变数量的参数，以及如果任何参数是基本类型，则进行装箱和取消装箱。 这种哈希函数的风格建议仅在性能不重要的情况下使用。 以下是使用这种技术编写的 PhoneNumber 的哈希函数：</p><pre><code>// One-line hashCode method - mediocre performance@Overridepublic int hashCode() {   return Objects.hash(lineNum, prefix, areaCode);}</code></pre><p>如果一个类是不可变的，并且计算哈希码的代价很大，那么可以考虑在对象中缓存哈希码，而不是在每次请求时重新计算哈希码。 如果你认为这种类型的大多数对象将被用作哈希键，那么应该在创建实例时计算哈希码。 否则，可以选择在首次调用 hashCode 时延迟初始化（lazily initialize）哈希码。 需要注意确保类在存在延迟初始化属性的情况下保持线程安全（项目 83）。 PhoneNumber 类不适合这种情况，但只是为了展示它是如何完成的。 请注意，属性 hashCode 的初始值（在本例中为 0）不应该是通常创建的实例的哈希码：</p><pre><code>// hashCode method with lazily initialized cached hash codeprivate int hashCode; // Automatically initialized to 0@Overridepublic int hashCode() {    int result = hashCode;    if (result == 0) {        result = Short.hashCode(areaCode);        result = 31 * result + Short.hashCode(prefix);        result = 31 * result + Short.hashCode(lineNum);        hashCode = result;    }    return result;}</code></pre><p>不要试图从哈希码计算中排除重要的属性来提高性能。 由此产生的哈希函数可能运行得更快，但其质量较差可能会降低哈希表的性能，使其无法使用。 具体来说，哈希函数可能会遇到大量不同的实例，这些实例主要在你忽略的区域中有所不同。 如果发生这种情况，哈希函数将把所有这些实例映射到少许哈希码上，而应该以线性时间运行的程序将会运行平方级的时间。</p><p>　　这不仅仅是一个理论问题。 在 Java 2 之前，String 类哈希函数在整个字符串中最多使用 16 个字符，从第一个字符开始，在整个字符串中均匀地选取。 对于大量的带有层次名称的集合（如 URL），此功能正好显示了前面描述的病态行为。</p><p>　　不要为 hashCode 返回的值提供详细的规范，因此客户端不能合理地依赖它； 你可以改变它的灵活性。 Java 类库中的许多类（例如 String 和 Integer）都将 hashCode 方法返回的确切值指定为实例值的函数。 这不是一个好主意，而是一个我们不得不忍受的错误：它妨碍了在未来版本中改进哈希函数的能力。 如果未指定细节并在散列函数中发现缺陷，或者发现了更好的哈希函数，则可以在后续版本中对其进行更改。</p><p>　　总之，每次重写 equals 方法时都必须重写 hashCode 方法，否则程序将无法正常运行。你的 hashCode 方法必须遵从 Object 类指定的常规约定，并且必须执行合理的工作，将不相等的哈希码分配给不相等的实例。如果使用第 51 页的配方，这很容易实现。如条目 10 所述，AutoValue 框架为手动编写 equals 和 hashCode 方法提供了一个很好的选择，IDE 也提供了一些这样的功能。</p><h1 id="始终重写-toString-方法"><a href="#始终重写-toString-方法" class="headerlink" title="始终重写 toString 方法"></a>始终重写 toString 方法</h1><p>虽然 Object 类提供了 toString 方法的实现，但它返回的字符串通常不是你的类的用户想要看到的。 它由类名后跟一个「at」符号（@）和哈希码的无符号十六进制表示组成，例如 PhoneNumber@163b91。 toString 的通用约定要求，返回的字符串应该是「一个简洁但内容丰富的表示，对人们来说是很容易阅读的」。虽然可以认为 PhoneNumber@163b91 简洁易读，但相比于 707-867-5309，但并不是很丰富 。 toString 通用约定「建议所有的子类重写这个方法」。好的建议，的确如此！</p><p>　　虽然它并不像遵守 equals 和 hashCode 约定那样重要 (条目 10 和 11)，但是提供一个良好的 toString 实现使你的类更易于使用，并对使用此类的系统更易于调试。当对象被传递到 println、printf、字符串连接操作符或断言，或者由调试器打印时，toString 方法会自动被调用。即使你从不调用对象上的 toString，其他人也可以。例如，对对象有引用的组件可能包含在日志错误消息中对象的字符串表示。如果未能重写 toString，则消息可能是无用的。</p><p>　　如果为 PhoneNumber 提供了一个很好的 toString 方法，那么生成一个有用的诊断消息就像下面这样简单：</p><pre><code>System.out.println(&quot;Failed to connect to &quot; + phoneNumber);</code></pre><p>程序员将以这种方式生成诊断消息，不管你是否重写 toString，但是除非你这样做，否则这些消息将不会有用。 提供一个很好的 toString 方法的好处不仅包括类的实例，同样有益于包含实例引用的对象，特别是集合。 打印 map 对象时你会看到哪一个，{Jenny=PhoneNumber@163b91} 还是 {Jenny=707-867-5309}?</p><p>　　实际上，toString 方法应该返回对象中包含的所有需要关注的信息，如电话号码示例中所示。 如果对象很大或者包含不利于字符串表示的状态，这是不切实际的。 在这种情况下，toString 应该返回一个摘要，如 Manhattan residential phone directory (1487536 listings) 或线程[main，5，main]。 理想情况下，字符串应该是不言自明的（线程示例并没有遵守这点）。 如果未能将所有对象的值得关注的信息包含在字符串表示中，则会导致一个特别烦人的处罚：测试失败报告如下所示：</p><pre><code>Assertion failure: expected {abc, 123}, but was {abc, 123}.</code></pre><p>实现 toString 方法时，必须做出的一个重要决定是：在文档中指定返回值的格式。 建议你对值类进行此操作，例如电话号码或矩阵类。 指定格式的好处是它可以作为标准的，明确的，可读的对象表示。 这种表示形式可以用于输入、输出以及持久化可读性的数据对象，如 CSV 文件。 如果指定了格式，通常提供一个匹配的静态工厂或构造方法，是个好主意，所以程序员可以轻松地在对象和字符串表示之间来回转换。 Java 平台类库中的许多值类都采用了这种方法，包括 BigInteger，BigDecimal 和大部分基本类型包装类。</p><p>　　指定 toString 返回值的格式的缺点是，假设你的类被广泛使用，一旦指定了格式，就会终身使用。程序员将编写代码来解析表达式，生成它，并将其嵌入到持久数据中。如果在将来的版本中更改了格式的表示，那么会破坏他们的代码和数据，并且还会抱怨。但通过选择不指定格式，就可以保留在后续版本中添加信息或改进格式的灵活性。</p><p>　　无论是否决定指定格式，你都应该清楚地在文档中表明你的意图。如果指定了格式，则应该这样做。例如，这里有一个 toString 方法，该方法在条目 11 中使用 PhoneNumber 类：</p><pre><code>/** * Returns the string representation of this phone number. * The string consists of twelve characters whose format is * &quot;XXX-YYY-ZZZZ&quot;, where XXX is the area code, YYY is the * prefix, and ZZZZ is the line number. Each of the capital * letters represents a single decimal digit. * * If any of the three parts of this phone number is too small * to fill up its field, the field is padded with leading zeros. * For example, if the value of the line number is 123, the last * four characters of the string representation will be &quot;0123&quot;. */@Overridepublic String toString() {    return String.format(&quot;%03d-%03d-%04d&quot;,            areaCode, prefix, lineNum);}</code></pre><p>如果你决定不指定格式，那么文档注释应该是这样的：</p><pre><code>/** * Returns a brief description of this potion. The exact details * of the representation are unspecified and subject to change, * but the following may be regarded as typical: * * &quot;[Potion #9: type=love, smell=turpentine, look=india ink]&quot; */@Overridepublic String toString() { ... }</code></pre><p>在阅读了这条注释之后，那些生成依赖于格式细节的代码或持久化数据的程序员，在这种格式发生改变的时候，只能怪他们自己。</p><p>　　无论是否指定格式，都可以通过编程方式访问 toString 返回的值中包含的信息。 例如，PhoneNumber 类应该包含 areaCode, prefix, lineNum 这三个属性。 如果不这样做，就会强迫程序员需要这些信息来解析字符串。 除了降低性能和程序员做不必要的工作之外，这个过程很容易出错，如果改变格式就会中断，并导致脆弱的系统。 由于未能提供访问器，即使已指定格式可能会更改，也可以将字符串格式转换为事实上的 API。</p><p>　　在静态工具类（详见第 4 条）中编写 toString 方法是没有意义的。 你也不应该在大多数枚举类型（条目 34）中写一个 toString 方法，因为 Java 为你提供了一个非常好的方法。 但是，你应该在任何抽象类中定义 toString 方法，该类的子类共享一个公共字符串表示形式。 例如，大多数集合实现上的 toString 方法都是从抽象集合类继承的。</p><p>　　Google 的开放源代码 AutoValue 工具在条目 10 中讨论过，它为你生成一个 toString 方法，就像大多数 IDE 工具一样。 这些方法非常适合告诉你每个属性的内容，但并不是专门针对类的含义。 因此，例如，为我们的 PhoneNumber 类使用自动生成的 toString 方法是不合适的（因为电话号码具有标准的字符串表示形式），但是对于我们的 Potion 类来说，这是完全可以接受的。 也就是说，自动生成的 toString 方法比从 Object 继承的方法要好得多，它不会告诉你对象的值。</p><p>　　回顾一下，除非父类已经这样做了，否则在每个实例化的类中重写 Object 的 toString 实现。 它使得类更加舒适地使用和协助调试。 toString 方法应该以一种美观的格式返回对象的简明有用的描述。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="http://sjsdfg.gitee.io/effective-java-3rd-chinese/#/notes/11.%20%E9%87%8D%E5%86%99equals%E6%96%B9%E6%B3%95%E6%97%B6%E5%90%8C%E6%97%B6%E4%B9%9F%E8%A6%81%E9%87%8D%E5%86%99hashcode%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">http://sjsdfg.gitee.io/effective-java-3rd-chinese/#/notes/11.%20%E9%87%8D%E5%86%99equals%E6%96%B9%E6%B3%95%E6%97%B6%E5%90%8C%E6%97%B6%E4%B9%9F%E8%A6%81%E9%87%8D%E5%86%99hashcode%E6%96%B9%E6%B3%95</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第三章阅读：Methods Common to All Objects&lt;br&gt;11.重写 equals 方法时同时也要重写 hashcode 方法&lt;br&gt;12.始终重写 toString 方法&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Git学习笔记III</title>
    <link href="http://yoursite.com/2020/01/13/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0III/"/>
    <id>http://yoursite.com/2020/01/13/Git学习笔记III/</id>
    <published>2020-01-13T10:12:12.000Z</published>
    <updated>2020-01-13T10:25:57.647Z</updated>
    
    <content type="html"><![CDATA[<p>使用Git进行工程开发时需要的常见规范，常见的Git命令， Git 客户端SourceTree简介</p><a id="more"></a><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在团队开发中，遵循一个合理、清晰的Git使用流程，是非常重要的。否则，每个人都提交一堆杂乱无章的commit，项目很快就会变得难以协调和维护。</p><h1 id="Git的特点"><a href="#Git的特点" class="headerlink" title="Git的特点"></a>Git的特点</h1><p>Git有很多优点，其中很显著的一点，就是版本的分支（branch）和合并（merge）十分方便，但如果管理不善，分支太多会导致杂乱不堪。</p><p>Vincent Driessen提出了一个分支管理的策略，我觉得非常值得借鉴。它可以使得版本库的演进保持简洁，主干清晰，各个分支各司其职、井井有条。</p><h1 id="Git分支管理策略"><a href="#Git分支管理策略" class="headerlink" title="Git分支管理策略"></a>Git分支管理策略</h1><p>主分支：应该有且只有一个主分支，所有提供给用户使用的正式上线版本都是从该主分支上发布。</p><p>开发分支：日常开发任务在develop分支上进行。<br>如果想要对外发布，就需要提交merge request，申请从develop分支merge到master中进行合并。</p><p>临时性分支：除了发布和开发，我们还需要一些临时性分支，用于 功能分支（feature）、预发布功能（release）分支、修正bug（fixbug）分支等，以及敏捷开发中的Sprint分支，在使用完成后，都需要将其快速删除，使得代码库的分支始终只会有 develop 和 master 分支。</p><h1 id="当前功能分支命名规范"><a href="#当前功能分支命名规范" class="headerlink" title="当前功能分支命名规范"></a>当前功能分支命名规范</h1><p>功能分支（feature，命名规范 feature-XXX）<br>Sprint分支（命名规范 sprint-XXX），在Sprint结束之后，合并至develop并进行预发布；<br>预发布功能分支（release）：在正式发布之前，我们需要一个预发布版本用来做测试，可以考虑将测试Lain环境中的分支都指向release分支而非develop；<br>修正bug（fixbug）分支：修补bug分支是从Master分支上面分出来的。修补结束以后，再合并进Master和Develop分支。它的命名，可以采用fixbug-XXX的形式。<br>根据JIRA问题创建出来的分支（jira-XXX）：当存在JIRA问题，并以此作为修改代码的依据时，可以使用这种方式的分支命名。</p><h1 id="Git-Commit信息的编写"><a href="#Git-Commit信息的编写" class="headerlink" title="Git Commit信息的编写"></a>Git Commit信息的编写</h1><p>如果有对应JIRA问题，编写格式可以直接以JIRA问题为准（这样可以在IDEA中查看代码时能够快速链接到该问题的描述）</p><pre><code>Git JIRA 提交信息JIRA-56http://jira/XXX</code></pre><p>如果没有JIRA问题，首先尝试在JIRA系统上建立问题并按照第一条原则。如果确实没有必要，则需要在提交时指定问题类型，基本的模板为：</p><pre><code>Git 普通问题提交信息&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;typefeat：新功能（feature）fix：修补bugdoc：文档（documentation）style： 代码风格或格式（不影响代码运行的变动）refactor：重构（即不是新增功能，也不是修改bug的代码变动）test：增加测试build: 构建过程或辅助工具的变动chore：其它类型提交,无关src目录以及test目scope用于说明此次提交影响的范围subject  commit 目的的简短描述。以动词开头，使用第一人称现在时，比如change，而不是changed或changes第一个字母小写结尾不加句号（。）</code></pre><h1 id="Git-标准流程"><a href="#Git-标准流程" class="headerlink" title="Git 标准流程"></a>Git 标准流程</h1><p>Git分支管理流程遵循以下几点：</p><p>developer没有任何权限能直接将codepush到develop、release和master分支。<br>developer开发feature时先建立issue之后再从develop创建相应的feature分支。<br>feature开发完毕后提交测试，测试可对此feature分支需要按照之前设计的case进行测试，并将bug录入到JIRA中。<br>上线日前1天从develop分支创建release分支命名规则遵守：release_yyyy/MM/dd<br>与产品沟通最后确认上线内容，并于涉及到的项目组沟通确认上线日配合验证测试。<br>将所有需要上线的feature分支提交merge request到release分支此时由中级或高级developer进行code review。<br>代码合并后测试进行主干的测试。确保上线前一天封版（理论上上线当天不进行代码改动）。<br>上线当上午发送上线通知邮件。</p><h1 id="代码提交规范："><a href="#代码提交规范：" class="headerlink" title="代码提交规范："></a>代码提交规范：</h1><p>首先master 拉取分支—–&gt;建立开发分支——&gt;开发完成-→合并develop 分支—-&gt;提交测试—–&gt;测试完成—-&gt;开发分支合并到master分支</p><h2 id="流程阻塞型功能提测"><a href="#流程阻塞型功能提测" class="headerlink" title="流程阻塞型功能提测"></a>流程阻塞型功能提测</h2><p>如果为后端必须零流量进行线上的回归，再开权限。</p><h1 id="提交测试："><a href="#提交测试：" class="headerlink" title="提交测试："></a>提交测试：</h1><p>项目开发完毕后，发邮件提测，提测内容如下：</p><p>背景：提测项目的背景和目的<br>修改点：代码变动和参数参数变动，以及配置文件有哪些变动<br>单元测试的覆盖率报表地址<br>有代码变动，可将git的diff结果页面的链接附上（是否建立代码的卡关流程，测试看完后，高工review确认合主分支）<br>测试或验证功能点：本次测试的重点check点，标明和强调（例如功能、兼容性、参数、代码逻辑，防止漏侧改动点）</p><h2 id="后端提测"><a href="#后端提测" class="headerlink" title="后端提测:"></a>后端提测:</h2><p>(1).需要指明哪些接口，接口的请求(新接口、老接口、内部接口)的必要参数和接口响应结果的重要业务字段，另外这些字段的重要逻辑需要指明<br>(2).接口的功能是什么<br>(3).测试的功能点是什么，需要测试做什么<br>前端和安卓测试：<br>(1).交互逻辑有哪些修改,交互的条件有哪些<br>(2).新增UI页面、前端效果有哪些<br>(3).交互完成的功能主要是什么<br>(4).主要测试的功能点是什么<br>测试范围：哪个端（pc\移动\h5）<br>自测范围和自测机型：自测功能点要详细说明（自测中验证了什么）</p><p>附上各个应用中git基本操作流程<br>个人可以根据需要，选择适合自己的工具（建议从原理入手，选择命令行）</p><h1 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h1><p>查看当前分支信息</p><pre><code>git branch -a  （-a 表示列出所有的本地分支以及远程分支）git branch -d xxx (删除合并过的分支xxx)git branch -D xxx (强制删除分支xxx，及时xxx未被合并过)</code></pre><p>切换分支</p><pre><code>git checkout xxx (切换至存在的分支)git checkout -b yyy (以当前分支为基础，新建分支yyy，并切换至分支yyy)</code></pre><p>更改工作区内容至暂存区</p><pre><code>git add . (添加所有文件至暂存区)git add  source/to/file (添加指定文件至暂存区)git rm source/to/file (删除工作区和暂存区的指定文件)git mv source/to/file destination/to/file (移动工作区和暂存区的指定文件)</code></pre><p>提交暂存区内容至本地分支</p><pre><code>git commit -m &quot;&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&quot;</code></pre><p>同步本地分支至远程分支</p><pre><code>git push origin branch</code></pre><p>拉取远程代码至本地</p><pre><code>git fetchgit rebase master</code></pre><h1 id="SourceTree"><a href="#SourceTree" class="headerlink" title="SourceTree"></a>SourceTree</h1><pre><code>SourceTree 是 Windows 和Mac OS X 下的 Git 客户端，下载地址：https://www.sourcetreeapp.com/</code></pre><h2 id="提交代码-（git-commit-amp-push）"><a href="#提交代码-（git-commit-amp-push）" class="headerlink" title="提交代码 （git commit &amp; push）"></a>提交代码 （git commit &amp; push）</h2><p>1.提交代码前应仔细看代码变更，不提交的改动可以选择暂存或舍弃。</p><p>2.选择要提交的文件后，会显示在已暂存文件列表中。</p><p>3.填写提交信息。</p><p>4.提交（勾选立即推送可立即推送到远端）</p><h2 id="本地合并分支（git-merge）"><a href="#本地合并分支（git-merge）" class="headerlink" title="本地合并分支（git merge）"></a>本地合并分支（git merge）</h2><p>提交代码后，如果有冲突无法在远端解决，可以在本地合并，解决冲突。</p><p>假设将 feature-test 合并到 master 上，先切换到 master 分支，再右键选择合并 feature-test 到 master。</p><h2 id="贮藏-（git-stash）"><a href="#贮藏-（git-stash）" class="headerlink" title="贮藏 （git stash）"></a>贮藏 （git stash）</h2><p>贮藏是一项十分有用的功能。当你处在开发阶段，有代码没提交，却需要切换分支或临时解决其他问题时，贮藏是最好的解决办法。</p><p>贮藏可以将当前改动暂时存起来，在左侧已贮藏列表显示已储存的代码。</p><p>在解决完临时问题后，通过应用贮藏将代码变更应用到当前分支。</p><p>SourceTree 的基本操作介绍如上，更多详细操作可以参考以下文档：</p><p>官方文档：<a href="https://confluence.atlassian.com/get-started-with-sourcetree" target="_blank" rel="noopener">https://confluence.atlassian.com/get-started-with-sourcetree</a></p><p>SoureTree使用方法：<a href="https://www.jianshu.com/p/6d2717c2a3e1" target="_blank" rel="noopener">https://www.jianshu.com/p/6d2717c2a3e1</a></p><p>提交merge request之后，如果source branch没有其他用处，可在merge完直接删除掉</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Git进行工程开发时需要的常见规范，常见的Git命令， Git 客户端SourceTree简介&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Effctive-Java阅读笔记V</title>
    <link href="http://yoursite.com/2020/01/06/Effctive-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0V/"/>
    <id>http://yoursite.com/2020/01/06/Effctive-Java阅读笔记V/</id>
    <published>2020-01-06T01:46:12.000Z</published>
    <updated>2020-01-14T06:55:57.501Z</updated>
    
    <content type="html"><![CDATA[<p>第三章阅读：Methods Common to All Objects<br>09.使用 try-with-resources 语句替代 try-finally 语句<br>10.重写 equals 方法时遵守通用约定</p><a id="more"></a><h1 id="使用-try-with-resources-语句替代-try-finally-语句"><a href="#使用-try-with-resources-语句替代-try-finally-语句" class="headerlink" title="使用 try-with-resources 语句替代 try-finally 语句"></a>使用 try-with-resources 语句替代 try-finally 语句</h1><p>从以往来看，try-finally 语句是保证资源正确关闭的最佳方式，即使是在程序抛出异常或返回的情况下：</p><pre><code>// try-finally - No longer the best way to close resources!static String firstLineOfFile(String path) throws IOException {    BufferedReader br = new BufferedReader(new FileReader(path));    try {        return br.readLine();    } finally {        br.close();    }}</code></pre><p>这可能看起来并不坏，但是当添加第二个资源时，情况会变得更糟：</p><pre><code>// try-finally is ugly when used with more than one resource!static void copy(String src, String dst) throws IOException {    InputStream in = new FileInputStream(src);    try {        OutputStream out = new FileOutputStream(dst);        try {            byte[] buf = new byte[BUFFER_SIZE];            int n;            while ((n = in.read(buf)) &gt;= 0)                out.write(buf, 0, n);        } finally {            out.close();        }    } finally {        in.close();    }}</code></pre><p>即使是用 try-finally 语句关闭资源的正确代码，如前面两个代码示例所示，也有一个微妙的缺陷。 try-with-resources 块和 finally 块中的代码都可以抛出异常。 例如，在前面的 firstLineOfFile 方法中，由于底层物理设备发生故障，对 readLine 方法的调用可能会引发异常，并且由于相同的原因，调用 close 方法可能会失败。 在这种情况下，第二个异常完全冲掉了第一个异常。 在异常堆栈跟踪中没有第一个异常的记录，这可能使实际系统中的调试非常复杂——通常这是你想要诊断问题的第一个异常。 虽然可以编写代码来抑制第二个异常，但是实际上没有人这样做，因为它太冗长了。</p><p>　　当 Java 7 引入了 try-with-resources 语句时，所有这些问题一下子都得到了解决。要使用这个构造，资源必须实现 AutoCloseable 接口，该接口由一个返回为 void 的 close 组成。Java 类库和第三方类库中的许多类和接口现在都实现或继承了 AutoCloseable 接口。如果你编写的类表示必须关闭的资源，那么这个类也应该实现 AutoCloseable 接口。</p><p>　　以下是我们的第一个使用 try-with-resources 的示例：</p><pre><code>// try-with-resources - the the best way to close resources!static String firstLineOfFile(String path) throws IOException {    try (BufferedReader br = new BufferedReader(new FileReader(path))) {       return br.readLine();    }}</code></pre><p>　以下是我们的第二个使用 try-with-resources 的示例：</p><pre><code>// try-with-resources on multiple resources - short and sweetstatic void copy(String src, String dst) throws IOException {    try (InputStream   in = new FileInputStream(src);         OutputStream out = new FileOutputStream(dst)) {        byte[] buf = new byte[BUFFER_SIZE];        int n;        while ((n = in.read(buf)) &gt;= 0)            out.write(buf, 0, n);    }}</code></pre><p>不仅 try-with-resources 版本比原始版本更精简，更好的可读性，而且它们提供了更好的诊断。 考虑 firstLineOfFile 方法。 如果调用 readLine 和（不可见）close 方法都抛出异常，则后一个异常将被抑制（suppressed），而不是前者。 事实上，为了保留你真正想看到的异常，可能会抑制多个异常。 这些抑制的异常没有被抛弃， 而是打印在堆栈跟踪中，并标注为被抑制了。 你也可以使用 getSuppressed 方法以编程方式访问它们，该方法在 Java 7 中已添加到的 Throwable 中。</p><p>　　可以在 try-with-resources 语句中添加 catch 子句，就像在常规的 try-finally 语句中一样。这允许你处理异常，而不会在另一层嵌套中污染代码。作为一个稍微有些做作的例子，这里有一个版本的 firstLineOfFile 方法，它不会抛出异常，但是如果它不能打开或读取文件，则返回默认值：</p><pre><code>// try-with-resources with a catch clausestatic String firstLineOfFile(String path, String defaultVal) {    try (BufferedReader br = new BufferedReader(           new FileReader(path))) {        return br.readLine();    } catch (IOException e) {        return defaultVal;    }}</code></pre><p>结论很明确：在处理必须关闭的资源时，使用 try-with-resources 语句替代 try-finally 语句。 生成的代码更简洁，更清晰，并且生成的异常更有用。 try-with-resources 语句在编写必须关闭资源的代码时会更容易，也不会出错，而使用 try-finally 语句实际上是不可能的。</p><h1 id="重写-equals-方法时遵守通用约定"><a href="#重写-equals-方法时遵守通用约定" class="headerlink" title="重写 equals 方法时遵守通用约定"></a>重写 equals 方法时遵守通用约定</h1><p>写在前面的读后感：这一节十分冗长，作者举例说明了尽量不要重写equals方法，如果一定要重写，那么要按照约定遵循自反性，对称性，传递性，一致性和非空性。</p><p>　虽然 Object 是一个具体的类，但它主要是为继承而设计的。它的所有非 final 方法（equals、hashCode、toString、clone 和 finalize）都有清晰的通用约定（ general contracts），因为它们被设计为被子类重写。任何类要重写这些方法时，都有义务去遵从它们的通用约定；如果不这样做，将会阻止其他依赖于约定的类 (例如 HashMap 和 HashSet) 与此类一起正常工作。</p><p>重写 equals 方法看起来很简单，但是有很多方式会导致重写出错，其结果可能是可怕的。避免此问题的最简单方法是不覆盖 equals 方法，在这种情况下，类的每个实例只与自身相等。如果满足以下任一下条件，则说明是正确的做法：</p><p>每个类的实例都是固有唯一的。 对于像 Thread 这样代表活动实体而不是值的类来说，这是正确的。 Object 提供的 equals 实现对这些类完全是正确的行为。</p><p>类不需要提供一个「逻辑相等（logical equality）」的测试功能。例如 java.util.regex.Pattern 可以重写 equals 方法检查两个是否代表完全相同的正则表达式 Pattern 实例，但是设计者并不认为客户需要或希望使用此功能。在这种情况下，从 Object 继承的 equals 实现是最合适的。</p><p>父类已经重写了 equals 方法，则父类行为完全适合于该子类。例如，大多数 Set 从 AbstractSet 继承了 equals 实现、List 从 AbstractList 继承了 equals 实现，Map 从 AbstractMap 的 Map 继承了 equals 实现。</p><p>类是私有的或包级私有的，可以确定它的 equals 方法永远不会被调用。如果你非常厌恶风险，可以重写 equals 方法，以确保不会被意外调用：</p><pre><code>@Overridepublic boolean equals(Object o) {    throw new AssertionError(); // Method is never called}</code></pre><p>什么时候需要重写 equals 方法呢？如果一个类包含一个逻辑相等（logical equality）的概念，此概念有别于对象标识（object identity），而且父类还没有重写过 equals 方法。这通常用在值类（value classes）的情况。值类只是一个表示值的类，例如 Integer 或 String 类。程序员使用 equals 方法比较值对象的引用，期望发现它们在逻辑上是否相等，而不是引用相同的对象。重写 equals 方法不仅可以满足程序员的期望，它还支持重写过 equals 的实例作为 Map 的键（key），或者 Set 里的元素，以满足预期和期望的行为。</p><p>　　一种不需要 equals 方法重写的值类是使用实例控制（instance control）（详见第 1 条）的类，以确保每个值至多存在一个对象。 枚举类型（详见第 34 条）属于这个类别。 对于这些类，逻辑相等与对象标识是一样的，所以 Object 的 equals 方法作用逻辑 equals 方法。</p><p>　　当你重写 equals 方法时，必须遵守它的通用约定。Object 的规范如下： equals 方法实现了一个等价关系（equivalence relation）。它有以下这些属性:</p><p><strong><em>自反性</em></strong>： 对于任何非空引用 x，x.equals(x) 必须返回 true。<br><strong><em>对称性</em></strong>： 对于任何非空引用 x 和 y，如果且仅当 y.equals(x) 返回 true 时 x.equals(y) 必须返回 true。<br><strong><em>传递性</em></strong>： 对于任何非空引用 x、y、z，如果 x.equals(y) 返回 true，y.equals(z) 返回 true，则 x.equals(z) 必须返回 true。<br><strong><em>一致性</em></strong>： 对于任何非空引用 x 和 y，如果在 equals 比较中使用的信息没有修改，则 x.equals(y) 的多次调用必须始终返回 true 或始终返回 false。<br><strong><em>非空性</em></strong>：<br>对于任何非空引用 x，x.equals(null) 必须返回 false。</p><p>　　除非你喜欢数学，否则这看起来有点吓人，但不要忽略它！如果一旦违反了它，很可能会发现你的程序运行异常或崩溃，并且很难确定失败的根源。套用约翰·多恩（John Donne）的说法，没有哪个类是孤立存在的。一个类的实例常常被传递给另一个类的实例。许多类，包括所有的集合类，都依赖于传递给它们遵守 equals 约定的对象。</p><p>　　既然已经意识到违反 equals 约定的危险，让我们详细地讨论一下这个约定。好消息是，表面上看，这并不是很复杂。一旦你理解了，就不难遵守这一约定。</p><p>　　那么什么是等价关系？ 笼统地说，它是一个运算符，它将一组元素划分为彼此元素相等的子集。 这些子集被称为等价类（equivalence classes）。 为了使 equals 方法有用，每个等价类中的所有元素必须从用户的角度来说是可以互换（interchangeable）的。 现在让我们依次看下这个五个要求：</p><p>　　自反性（Reflexivity）——第一个要求只是说一个对象必须与自身相等。 很难想象无意中违反了这个规定。 如果你违反了它，然后把类的实例添加到一个集合中，那么 contains 方法可能会说集合中没有包含刚添加的实例。</p><p>　　对称性（Symmetry）——第二个要求是，任何两个对象必须在是否相等的问题上达成一致。与第一个要求不同的是，我们不难想象在无意中违反了这一要求。例如，考虑下面的类，它实现了不区分大小写的字符串。字符串被 toString 保存，但在 equals 比较中被忽略：</p><pre><code>import java.util.Objects;public final class CaseInsensitiveString {    private final String s;    public CaseInsensitiveString(String s){        this.s = Objects.requireNonNull(s);    }    // Broken - violates symmetry!    @Override    public boolean equals(Object o){        if(o instanceof CaseInsensitiveString){            return s.equalsIgnoreCase(                    ((CaseInsensitiveString)o).s);        }        if(o instanceof String){// One-way interoperability!            return s.equalsIgnoreCase((String)o);        }        return false;    }}</code></pre><p>上面CaseInsensitiveString（大小写不敏感）类中的 equals 试图与正常的字符串进行操作，假设我们有一个不区分大小写的字符串和一个正常的字符串：</p><pre><code>CaseInsensitiveString cis = new CaseInsensitiveString(&quot;Polish&quot;);String s = &quot;polish&quot;;System.out.println(cis.equals(s)); // trueSystem.out.println(s.equals(cis)); // false</code></pre><p>正如所料，cis.equals(s) 返回 true。 问题是，尽管 CaseInsensitiveString 类中的 equals 方法知道正常字符串，但 String 类中的 equals 方法却忽略了不区分大小写的字符串。 因此，s.equals(cis) 返回 false，明显违反对称性。 假设把一个不区分大小写的字符串放入一个集合中：</p><pre><code>List&lt;CaseInsensitiveString&gt; list = new ArrayList&lt;&gt;();list.add(cis);</code></pre><p>list.contains(s) 返回了什么？谁知道呢？在当前的 OpenJDK 实现中，它会返回 false，但这只是一个实现构件。在另一个实现中，它可以很容易地返回 true 或抛出运行时异常。一旦违反了 equals 约定，就不知道其他对象在面对你的对象时会如何表现了。</p><p>　　要消除这个问题，只需删除 equals 方法中与 String 类相互操作的恶意尝试。这样做之后，可以将该方法重构为单个返回语句:</p><pre><code>@Overridepublic boolean equals(Object o) {    return o instanceof CaseInsensitiveString &amp;&amp;            ((CaseInsensitiveString) o).s.equalsIgnoreCase(s);}</code></pre><p>传递性（Transitivity）—— equals 约定的第三个要求是，如果第一个对象等于第二个对象，第二个对象等于第三个对象，那么第一个对象必须等于第三个对象。同样，也不难想象，无意中违反了这一要求。考虑子类的情况， 将新值组件（value component）添加到其父类中。换句话说，子类添加了一个信息，它影响了 equals 方法比较。让我们从一个简单不可变的二维整数类型 Point 类开始：</p><pre><code>public class Point {    private final int x;    private final int y;    public Point(int x, int y) {        this.x = x;        this.y = y;    }    @Override    public boolean equals(Object o) {        if (!(o instanceof Point))            return false;        Point p = (Point) o;        return p.x == x &amp;&amp; p.y == y;    }    ...  // Remainder omitted}</code></pre><p>假设想继承这个类，将表示颜色的 Color 类添加到 Point 类中：</p><pre><code>public class ColorPoint extends Point {    private final Color color;    public ColorPoint(int x, int y, Color color) {        super(x, y);        this.color = color;    }    ...  // Remainder omitted}</code></pre><p>equals 方法应该是什么样子？如果完全忽略，则实现是从 Point 类上继承的，颜色信息在 equals 方法比较中被忽略。虽然这并不违反 equals 约定，但这显然是不可接受的。假设你写了一个 equals 方法，它只在它的参数是另一个具有相同位置和颜色的 ColorPoint 实例时返回 true：</p><pre><code>// Broken - violates symmetry!@Overridepublic boolean equals(Object o) {    if (!(o instanceof ColorPoint))        return false;    return super.equals(o) &amp;&amp; ((ColorPoint) o).color == color;}</code></pre><p>当你比较 Point 对象和 ColorPoint 对象时，可以会得到不同的结果，反之亦然。前者的比较忽略了颜色属性，而后者的比较会一直返回 false，因为参数的类型是错误的。为了让问题更加具体，我们创建一个 Point 对象和 ColorPoint 对象：</p><pre><code>Point p = new Point(1, 2);ColorPoint cp = new ColorPoint(1, 2, Color.RED);</code></pre><p>　　p.equals(cp) 返回 true，但是 cp.equals(p) 返回 false。你可能想使用 ColorPoint.equals 通过混合比较的方式来解决这个问题。</p><pre><code>@Overridepublic boolean equals(Object o) {if (!(o instanceof Point))    return false;// If o is a normal Point, do a color-blind comparisonif (!(o instanceof ColorPoint))    return o.equals(this);// o is a ColorPoint; do a full comparisonreturn super.equals(o) &amp;&amp; ((ColorPoint) o).color == color;}</code></pre><p>这种方法确实提供了对称性，但是丧失了传递性：</p><pre><code>ColorPoint p1 = new ColorPoint(1, 2, Color.RED);Point p2 = new Point(1, 2);ColorPoint p3 = new ColorPoint(1, 2, Color.BLUE);</code></pre><p>现在，p1.equals(p2) 和 p2.equals(p3) 返回了 true，但是 p1.equals(p3) 却返回了 false，很明显违背了传递性的要求。前两个比较都是不考虑颜色信息的，而第三个比较时却包含颜色信息。</p><p>　　此外，这种方法可能导致无限递归：假设有两个 Point 的子类，比如 ColorPoint 和 SmellPoint，每个都有这种 equals 方法。 然后调用 myColorPoint.equals(mySmellPoint) 将抛出一个 StackOverflowError 异常。</p><p>　　那么解决方案是什么？ 事实证明，这是面向对象语言中关于等价关系的一个基本问题。 除非您愿意放弃面向对象抽象的好处，否则无法继承可实例化的类，并在保留 equals 约定的同时添加一个值组件。</p><p>　　你可能听说过，可以继承一个可实例化的类并添加一个值组件，同时通过在 equals 方法中使用一个 getClass 测试代替 instanceof 测试来保留 equals 约定：</p><pre><code>@Overridepublic boolean equals(Object o) {    if (o == null || o.getClass() != getClass())        return false;    Point p = (Point) o;    return p.x == x &amp;&amp; p.y == y;}</code></pre><p>　只有当对象具有相同的实现类时，才会产生相同的效果。这看起来可能不是那么糟糕，但是结果是不可接受的:一个 Point 类子类的实例仍然是一个 Point 的实例，它仍然需要作为一个 Point 来运行，但是如果你采用这个方法，就会失败！假设我们要写一个方法来判断一个 Point 对象是否在 unitCircle 集合中。我们可以这样做：</p><pre><code>private static final Set&lt;Point&gt; unitCircle = Set.of(        new Point( 1,  0), new Point( 0,  1),        new Point(-1,  0), new Point( 0, -1));public static boolean onUnitCircle(Point p) {    return unitCircle.contains(p);}</code></pre><p>　虽然这可能不是实现功能的最快方法，但它可以正常工作。假设以一种不添加值组件的简单方式继承 Point 类，比如让它的构造方法跟踪记录创建了多少实例：</p><pre><code>public class CounterPoint extends Point {    private static final AtomicInteger counter =            new AtomicInteger();    public CounterPoint(int x, int y) {        super(x, y);        counter.incrementAndGet();    }    public static int numberCreated() {        return counter.get();    }}</code></pre><p>里氏替代原则（Liskov substitution principle）指出，任何类型的重要属性都应该适用于所有的子类型，因此任何为这种类型编写的方法都应该在其子类上同样适用。 这是我们之前声明的一个正式陈述，即 Point 的子类（如 CounterPoint）仍然是一个 Point，必须作为一个 Point 类来看待。 但是，假设我们将一个 CounterPoint 对象传递给 onUnitCircle 方法。 如果 Point 类使用基于 getClass 的 equals 方法，则无论 CounterPoint 实例的 x 和 y 坐标如何，onUnitCircle 方法都将返回 false。 这是因为大多数集合（包括 onUnitCircle 方法使用的 HashSet）都使用 equals 方法来测试是否包含元素，并且 CounterPoint 实例并不等于任何 Point 实例。 但是，如果在 Point 上使用了适当的基于 instanceof 的 equals 方法，则在使用 CounterPoint 实例呈现时，同样的 onUnitCircle 方法可以正常工作。</p><p>　　虽然没有令人满意的方法来继承一个可实例化的类并添加一个值组件，但是有一个很好的变通方法：按照条目 18 的建议，“优先使用组合而不是继承”。取代继承 Point 类的 ColorPoint 类，可以在 ColorPoint 类中定义一个私有 Point 属性，和一个公共的视图（view）（详见第 6 条）方法，用来返回具有相同位置的 ColorPoint 对象。</p><pre><code>// Adds a value component without violating the equals contractpublic class ColorPoint {    private final Point point;    private final Color color;    public ColorPoint(int x, int y, Color color) {        point = new Point(x, y);        this.color = Objects.requireNonNull(color);    }    /**     * Returns the point-view of this color point.     */    public Point asPoint() {        return point;    }    @Override    public boolean equals(Object o) {        if (!(o instanceof ColorPoint))            return false;        ColorPoint cp = (ColorPoint) o;        return cp.point.equals(point) &amp;&amp; cp.color.equals(color);    }    ...    // Remainder omitted}</code></pre><p>Java 平台类库中有一些类可以继承可实例化的类并添加一个值组件。 例如，java.sql.Timestamp 继承了 java.util.Date 并添加了一个 nanoseconds 字段。 Timestamp 的等价 equals 确实违反了对称性，并且如果 Timestamp 和 Date 对象在同一个集合中使用，或者以其他方式混合使用，则可能导致不稳定的行为。 Timestamp 类有一个免责声明，告诫程序员不要混用 Timestamp 和 Date。 虽然只要将它们分开使用就不会遇到麻烦，但没有什么可以阻止你将它们混合在一起，并且由此产生的错误可能很难调试。 Timestamp 类的这种行为是一个错误，不应该被仿效。</p><p>你可以将值组件添加到抽象类的子类中，而不会违反 equals 约定。这对于通过遵循第 23 个条目中“优先考虑类层级（class hierarchies）来代替标记类（tagged classes）”中的建议而获得的类层级，是非常重要的。例如，可以有一个没有值组件的抽象类 Shape，子类 Circle 有一个 radius 属性，另一个子类 Rectangle 包含 length 和 width 属性 。 只要不直接创建父类实例，就不会出现前面所示的问题。</p><p>　　一致性（Consistent）——equals 约定的第四个要求是，如果两个对象是相等的，除非一个（或两个）对象被修改了， 那么它们必须始终保持相等。 换句话说，可变对象可以在不同时期可以与不同的对象相等，而不可变对象则不会。 当你写一个类时，要认真思考它是否应该设计为不可变的（详见第 17 条）。 如果你认为应该这样做，那么确保你的 equals 方法强制执行这样的限制：相等的对象永远相等，不相等的对象永远都不会相等。</p><p>　　不管一个类是不是不可变的，都不要写一个依赖于不可靠资源的 equals 方法。 如果违反这一禁令，满足一致性要求是非常困难的。 例如，java.net.URL 类中的 equals 方法依赖于与 URL 关联的主机的 IP 地址的比较。 将主机名转换为 IP 地址可能需要访问网络，并且不能保证随着时间的推移会产生相同的结果。 这可能会导致 URL 类的 equals 方法违反 equals 约定，并在实践中造成问题。 URL 类的 equals 方法的行为是一个很大的错误，不应该被效仿。 不幸的是，由于兼容性的要求，它不能改变。 为了避免这种问题，equals 方法应该只对内存驻留对象执行确定性计算。</p><p>　　非空性（Non-nullity）——最后 equals 约定的要求没有官方的名称，所以我冒昧地称之为“非空性”。意思是说说所有的对象都必须不等于 null。虽然很难想象在调用 o.equals(null) 的响应中意外地返回 true，但不难想象不小心抛出 NullPointerException 异常的情况。通用的约定禁止抛出这样的异常。许多类中的 equals 方法都会明确阻止对象为 null 的情况：</p><pre><code>@Overridepublic boolean equals(Object o) {    if (o == null)        return false;    ...}</code></pre><p>　这个判断是不必要的。 为了测试它的参数是否相等，equals 方法必须首先将其参数转换为合适类型，以便调用访问器或允许访问的属性。 在执行类型转换之前，该方法必须使用 instanceof 运算符来检查其参数是否是正确的类型：</p><pre><code>@Overridepublic boolean equals(Object o) {    if (!(o instanceof MyType))        return false;    MyType mt = (MyType) o;    ...}</code></pre><p>如果此类型检查漏掉，并且 equals 方法传递了错误类型的参数，那么 equals 方法将抛出 ClassCastException 异常，这违反了 equals 约定。 但是，如果第一个操作数为 null，则指定 instanceof 运算符返回 false，而不管第二个操作数中出现何种类型[JLS，15.20.2]。 因此，如果传入 null，类型检查将返回 false，因此不需要 明确的 null 检查。</p><p>划重点：<br>　　<strong>* 综合起来，以下是编写高质量 equals 方法的配方（recipe）：*</strong></p><p>1.使用 == 运算符检查参数是否为该对象的引用。如果是，返回 true。这只是一种性能优化，但是如果这种比较可能很昂贵的话，那就值得去做。</p><p>2.使用 instanceof 运算符来检查参数是否具有正确的类型。 如果不是，则返回 false。 通常，正确的类型是 equals 方法所在的那个类。 有时候，改类实现了一些接口。 如果类实现了一个接口，该接口可以改进 equals 约定以允许实现接口的类进行比较，那么使用接口。 集合接口（如 Set，List，Map 和 Map.Entry）具有此特性。</p><p>3.参数转换为正确的类型。因为转换操作在 instanceof 中已经处理过，所以它肯定会成功。</p><p>4.对于类中的每个「重要」的属性，请检查该参数属性是否与该对象对应的属性相匹配。如果所有这些测试成功，返回 true，否则返回 false。如果步骤 2 中的类型是一个接口，那么必须通过接口方法访问参数的属性;如果类型是类，则可以直接访问属性，这取决于属性的访问权限。</p><p>　　对于类型为非 float 或 double 的基本类型，使用 == 运算符进行比较；对于对象引用属性，递归地调用 equals 方法；对于 float 基本类型的属性，使用静态 Float.compare(float, float) 方法；对于 double 基本类型的属性，使用 Double.compare(double, double) 方法。由于存在 Float.NaN，-0.0f 和类似的 double 类型的值，所以需要对 float 和 double 属性进行特殊的处理；有关详细信息，请参阅 JLS 15.21.1 或 Float.equals 方法的详细文档。 虽然你可以使用静态方法 Float.equals 和 Double.equals 方法对 float 和 double 基本类型的属性进行比较，这会导致每次比较时发生自动装箱，引发非常差的性能。 对于数组属性，将这些准则应用于每个元素。 如果数组属性中的每个元素都很重要，请使用其中一个重载的 Arrays.equals 方法。</p><p>　　某些对象引用的属性可能合法地包含 null。 为避免出现 NullPointerException 异常，请使用静态方法 Objects.equals(Object, Object) 检查这些属性是否相等。</p><p>　　对于一些类，例如上的 CaseInsensitiveString 类，属性比较相对于简单的相等性测试要复杂得多。在这种情况下，你想要保存属性的一个规范形式（canonical form），这样 equals 方法就可以基于这个规范形式去做开销很小的精确比较，来取代开销很大的非标准比较。这种方式其实最适合不可变类（详见第 17 条）。一旦对象发生改变，一定要确保把对应的规范形式更新到最新。</p><p>　　equals 方法的性能可能受到属性比较顺序的影响。 为了获得最佳性能，你应该首先比较最可能不同的属性，开销比较小的属性，或者最好是两者都满足（derived fields）。 你不要比较不属于对象逻辑状态的属性，例如用于同步操作的 lock 属性。 不需要比较可以从“重要属性”计算出来的派生属性，但是这样做可以提高 equals 方法的性能。 如果派生属性相当于对整个对象的摘要描述，比较这个属性将节省在比较失败时再去比较实际数据的开销。 例如，假设有一个 Polygon 类，并缓存该区域。 如果两个多边形的面积不相等，则不必费心比较它们的边和顶点。</p><p>　　当你完成编写完 equals 方法时，问你自己三个问题：它是对称的吗?它是传递吗?它是一致的吗?除此而外，编写单元测试加以排查，除非使用 AutoValue 框架（第 49 页）来生成 equals 方法，在这种情况下可以安全地省略测试。如果持有的属性失败，找出原因，并相应地修改 equals 方法。当然，equals 方法也必须满足其他两个属性 (自反性和非空性)，但这两个属性通常都会满足。</p><p>　　在下面这个简单的 PhoneNumber 类中展示了根据之前的配方构建的 equals 方法：</p><pre><code>public final class PhoneNumber {    private final short areaCode, prefix, lineNum;    public PhoneNumber(int areaCode, int prefix, int lineNum) {        this.areaCode = rangeCheck(areaCode, 999, &quot;area code&quot;);        this.prefix = rangeCheck(prefix, 999, &quot;prefix&quot;);        this.lineNum = rangeCheck(lineNum, 9999, &quot;line num&quot;);    }    private static short rangeCheck(int val, int max, String arg) {        if (val &lt; 0 || val &gt; max)            throw new IllegalArgumentException(arg + &quot;: &quot; + val);        return (short) val;    }    @Override    public boolean equals(Object o) {        if (o == this)            return true;        if (!(o instanceof PhoneNumber))            return false;        PhoneNumber pn = (PhoneNumber) o;        return pn.lineNum == lineNum &amp;&amp; pn.prefix == prefix                &amp;&amp; pn.areaCode == areaCode;    }    ... // Remainder omitted}</code></pre><p>以下是一些最后提醒：</p><p>当重写 equals 方法时，同时也要重写 hashCode 方法（详见第 11 条）。<br>不要让 equals 方法试图太聪明。 如果只是简单地测试用于相等的属性，那么要遵守 equals 约定并不困难。如果你在寻找相等方面过于激进，那么很容易陷入麻烦。一般来说，考虑到任何形式的别名通常是一个坏主意。例如，File 类不应该试图将引用的符号链接等同于同一文件对象。幸好 File 类并没这么做。<br>在 equal 时方法声明中，不要将参数 Object 替换成其他类型。 对于程序员来说，编写一个看起来像这样的 equals 方法并不少见，然后花上几个小时苦苦思索为什么它不能正常工作：</p><pre><code>// Broken - parameter type must be Object!public boolean equals(MyClass o) {       …}</code></pre><p>　问题在于这个方法并没有重写 Object.equals 方法，它的参数是 Object 类型的，这样写只是重载了 equals 方法（详见第 52 条）。 即使除了正常的方法之外，提供这种“强类型”的 equals 方法也是不可接受的，因为它可能会导致子类中的 Override 注解产生误报，提供不安全的错觉。 在这里，使用 Override 注解会阻止你犯这个错误 （详见第 40 条）。这个 equals 方法不会编译，错误消息会告诉你到底错在哪里：</p><p>编写和测试 equals（和 hashCode）方法很繁琐，生的代码也很普通。替代手动编写和测试这些方法的优雅的手段是，使用谷歌 AutoValue 开源框架，该框架自动为你生成这些方法，只需在类上添加一个注解即可。在大多数情况下，AutoValue 框架生成的方法与你自己编写的方法本质上是相同的。</p><p>　　很多 IDE（例如 Eclipse，NetBeans，IntelliJ IDEA 等）也有生成 equals 和 hashCode 方法的功能，但是生成的源代码比使用 AutoValue 框架的代码更冗长、可读性更差，不会自动跟踪类中的更改，因此需要进行测试。这就是说，使用 IDE 工具生成 equals(和 hashCode) 方法通常比手动编写它们更可取，因为 IDE 工具不会犯粗心大意的错误，而人类则会。</p><p>　　总之，除非必须：在很多情况下，不要重写 equals 方法，从 Object 继承的实现完全是你想要的。 如果你确实重写了 equals 方法，那么一定要比较这个类的所有重要属性，并且以保护前面 equals 约定里五个规定的方式去比较。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="http://sjsdfg.gitee.io/effective-java-3rd-chinese/#/notes/10.%20%E9%87%8D%E5%86%99equals%E6%96%B9%E6%B3%95%E6%97%B6%E9%81%B5%E5%AE%88%E9%80%9A%E7%94%A8%E7%BA%A6%E5%AE%9A" target="_blank" rel="noopener">http://sjsdfg.gitee.io/effective-java-3rd-chinese/#/notes/10.%20%E9%87%8D%E5%86%99equals%E6%96%B9%E6%B3%95%E6%97%B6%E9%81%B5%E5%AE%88%E9%80%9A%E7%94%A8%E7%BA%A6%E5%AE%9A</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第三章阅读：Methods Common to All Objects&lt;br&gt;09.使用 try-with-resources 语句替代 try-finally 语句&lt;br&gt;10.重写 equals 方法时遵守通用约定&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Hexo标签与md文件冲突问题解决</title>
    <link href="http://yoursite.com/2020/01/03/Hexo%E6%A0%87%E7%AD%BE%E4%B8%8Emd%E6%96%87%E4%BB%B6%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>http://yoursite.com/2020/01/03/Hexo标签与md文件冲突问题解决/</id>
    <published>2020-01-03T10:23:12.000Z</published>
    <updated>2020-01-15T07:19:44.739Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo标签与md文件冲突问题解决</p><a id="more"></a><p>今天使用 Github+Hexo 搭建的博客写文章时遇到一个 Bug，查阅资料解决之后，发现很多人都遇到过由于 nunjucks 模板标签导致 MD 文件解析报错的问题，于是记录一下这个问题的解决方法。</p><h1 id="报错及原因"><a href="#报错及原因" class="headerlink" title="报错及原因"></a>报错及原因</h1><p>  今天使用 hexo generate 生成文章时，出现了如下报错：</p><pre><code>INFO  Start processingFATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlTemplate render error: (unknown path) [Line 17, Column 30]  unexpected token: }}    at Object._prettifyError</code></pre><p>出现上述情况的原因是 Markdown 文件中内容含有的双大括号 标签与 nunjucks 模板引擎的标签发生了冲突。双大括号等这些标签都是模板引擎的占位标签，如果 MarkDown 文件中包含这些标签，且不被 ``` 代码块包裹，那么解析时就会把 MD 文件中的标签动态解析了，于是导致 MD 文件解析时报错。</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><h2 id="修改-Markdown-文件"><a href="#修改-Markdown-文件" class="headerlink" title="修改 Markdown 文件"></a>修改 Markdown 文件</h2><p>将含有双大括号的内容首尾添加如下标签进行处理：</p><pre><code>{% raw %}    {{ 双大括号内包裹的内容 }}    {% endraw %}</code></pre><p>用这个标签虽然可以解决问题，但之后再遇到类似的情况每次都需要对 MarkDown 文件进行修改。下面介绍一种更便捷的方法。</p><h2 id="修改-nunjucks-模块源代码"><a href="#修改-nunjucks-模块源代码" class="headerlink" title="修改 nunjucks 模块源代码"></a>修改 nunjucks 模块源代码</h2><p>我们还可以直接在 nunjucks 模块上修改源代码，更改有冲突的渲染标签。<br>首先打开这个文件，路径如下：<br>    node_modules/nunjucks/src/lexer.js<br>找到下述两行代码：</p><pre><code>var VARIABLE_START = &apos;{{';    var VARIABLE_END = '}}&apos;;</code></pre><p>将其修改为：</p><pre><code>var VARIABLE_START = &apos;{$&apos;;var VARIABLE_END = &apos;$}&apos;;</code></pre><p>将有冲突的模板引擎的占位符更改为其他字符，进行模板解析时就不会与 MarkDown 的内容发生冲突了，且这种方法对所有 MarkDown 文件都是有效的，一劳永逸。<br>类似的，如果出现类似符号的解析错误时，也可以根据情况将其更改为其他占位符（自定义）。</p><h2 id="搜索、RSS-插件同步修改"><a href="#搜索、RSS-插件同步修改" class="headerlink" title="搜索、RSS 插件同步修改"></a>搜索、RSS 插件同步修改</h2><p>若博客使用 hexo-generator-search 或 hexo-generator-feed 等其他依赖于 nunjucks 模板的插件，那么这些插件的模板处理标签也需要进行同步修改。以搜索插件为例，打开如下路径的文件：<br>node_modules/hexo-generator-search/templates/search.xml<br>根据之前修改的 nunjucks 的内容，将此文件的  也更改为 {$ 和 $} 即可。</p><h1 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h1><p>如果在项目下执行 npm install 更新 nunjucks 模板时，那么之前更改的内容会被还原，需要重新对有冲突的符号进行更改。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>【1】<a href="https://www.jianshu.com/p/6032a1a2dc25" target="_blank" rel="noopener">https://www.jianshu.com/p/6032a1a2dc25</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hexo标签与md文件冲突问题解决&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Java编程思想-第二十三章阅读笔记</title>
    <link href="http://yoursite.com/2020/01/03/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%89%E7%AB%A0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/01/03/Java编程思想-第二十三章阅读笔记/</id>
    <published>2020-01-03T08:12:12.000Z</published>
    <updated>2020-01-03T07:51:20.308Z</updated>
    
    <content type="html"><![CDATA[<p>第二十三章 注解</p><a id="more"></a><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://lingcoder.github.io/OnJava8/#/book/23-Annotations?id=%e5%9f%ba%e6%9c%ac%e8%af%ad%e6%b3%95" target="_blank" rel="noopener">https://lingcoder.github.io/OnJava8/#/book/23-Annotations?id=%e5%9f%ba%e6%9c%ac%e8%af%ad%e6%b3%95</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二十三章 注解&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java开发中的易错点</title>
    <link href="http://yoursite.com/2020/01/03/Java%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E6%98%93%E9%94%99%E7%82%B9/"/>
    <id>http://yoursite.com/2020/01/03/Java开发中的易错点/</id>
    <published>2020-01-03T08:11:12.000Z</published>
    <updated>2020-01-15T07:23:28.776Z</updated>
    
    <content type="html"><![CDATA[<p>Java开发中的易错点</p><a id="more"></a><h1 id="避免非空判断仅判断是否为empty"><a href="#避免非空判断仅判断是否为empty" class="headerlink" title="避免非空判断仅判断是否为empty"></a>避免非空判断仅判断是否为empty</h1><p>反例：</p><pre><code>public  static  void  main(String[] args){    Map data=new HashMap();    data=null;    if(data.isEmpty()){        return;    }}</code></pre><p>只判断data是否为isEmpty，但当数据为null时会报空指针异常</p><pre><code>Exception in thread &quot;main&quot; java.lang.NullPointerException    at Application.main(Application.java:454)</code></pre><h1 id="log抛出要有详情和具体说明"><a href="#log抛出要有详情和具体说明" class="headerlink" title="log抛出要有详情和具体说明"></a>log抛出要有详情和具体说明</h1><p>反例：</p><pre><code>try {  param = JSONObject.parseObject(methodParam,method.getParameterTypes()[0]);} catch (Exception e){  throw new ParamException(e.getMessage());}</code></pre><p>信息需要详细具体，参见<br>正例：</p><pre><code>try {  ...} catch (IOException e){  logger.error(&quot;....Failed&quot;,e);  return null;}</code></pre><h1 id="配置文件尽量在配置文件定义，代码中不要配置"><a href="#配置文件尽量在配置文件定义，代码中不要配置" class="headerlink" title="配置文件尽量在配置文件定义，代码中不要配置"></a>配置文件尽量在配置文件定义，代码中不要配置</h1><p>反例：</p><p>  String ip=”127.0.0.1”;<br>  Socket socket=new Socket(ip,6667);</p><p>正例：</p><p>  String ip= System.getProperty(“myapplication.ip”);<br>  Socket socket=new Socket(ip,6667);</p><h1 id="精度转换"><a href="#精度转换" class="headerlink" title="精度转换"></a>精度转换</h1><p>BigDecimal转double，需先转换为string再 BigDecimal（String s），再使用BigDecimal.valueOf()方法，避免精度丢失</p><p>BigDecimal(double val)构造，用double当参数来构造一个BigDecimal对象。<br>但是BigDecimal(0.1)实际上等于0.1000000000000000055511151231257827021181583404541015625，因为准确的来说0.1本身不能算是一个double（其实0.1不能代表任何一个定长二进制分数）。</p><p>BigDecimal(String val)构造是靠谱的，BigDecimal(“0.1”)就是等于0.1，推荐大家用这个构造。</p><p>如果非要用一个double变量来构造一个BigDecimal，请使用静态方法valueOf(double)，这个方法跟new Decimal(Double.toString(double))效果是一样的。</p><pre><code>public static void doubleToBigDecimal(){    float f=0.1f;    BigDecimal decimal1=new BigDecimal(f);    System.out.println(decimal1);    double d=0.1;    BigDecimal decimal2=new BigDecimal(d);    System.out.println(decimal2);    BigDecimal decimal3=new BigDecimal(Double.toString(d));    System.out.println(decimal3);    BigDecimal decimal4=BigDecimal.valueOf(d);    System.out.println(decimal4);}</code></pre><p>输出结果：</p><pre><code>0.1000000014901161193847656250.10000000000000000555111512312578270211815834045410156250.10.1</code></pre><h1 id="Map、Set、list初始化"><a href="#Map、Set、list初始化" class="headerlink" title="Map、Set、list初始化"></a>Map、Set、list初始化</h1><pre><code>Map source = new HashMap(){{ // Noncompliant        put("firstName", "John");        put("lastName", "Smith");    }};</code></pre><p>上述方式潜在问题：</p><p>看起来优雅了不少，一步到位。问题来了，这里的双大括号到底什么意思，什么用法呢？<br>双大括号,用来初始化，使代码简洁易读。<br>第一层括弧实际是定义了一个匿名内部类 (Anonymous Inner Class)，第二层括弧实际上是一个实例初始化块 (instance initializer block)，这个块在内部匿名类构造时被执行。</p><p>1.此种方式是匿名内部类的声明方式，所以引用中持有着外部类的引用。所以当时串行化这个集合时外部类也会被不知不觉的串行化，当外部类没有实现serialize接口时，就会报错。</p><p>2.上例中，其实是声明了一个继承自HashMap的子类。然而有些串行化方法，例如要通过Gson串行化为json，或者要串行化为xml时，类库中提供的方式，是无法串行化Hashset或者HashMap的子类的，从而导致串行化失败。<br>解决办法：重新初始化为一个HashMap对象：<br>new HashMap(map);<br>这样就可以正常初始化了。</p><pre><code>Map source = new HashMap() // compliantsource.put(&quot;firstName&quot;, &quot;John&quot;);source.put(&quot;lastName&quot;, &quot;Smith&quot;);</code></pre><h1 id="null值时刻注意非空判断"><a href="#null值时刻注意非空判断" class="headerlink" title="null值时刻注意非空判断"></a>null值时刻注意非空判断</h1><p>反例：</p><pre><code>TreeMap&lt;String,String&gt; paramTreeMap=convertMapToTreeMap(paramMap);try{  .....} catch (Exception e){  throw new FailException(&quot; .... param=&quot;+ paramMap.toString() e);}</code></pre><p>paramMap.toString()这里没有考虑为null的情况</p><h1 id="文件数据流、zip流、字节流等一定要谨记在finally关闭数据流"><a href="#文件数据流、zip流、字节流等一定要谨记在finally关闭数据流" class="headerlink" title="文件数据流、zip流、字节流等一定要谨记在finally关闭数据流"></a>文件数据流、zip流、字节流等一定要谨记在finally关闭数据流</h1><p>反例1:</p><pre><code>private void readFile() throw IOException{  Path path=Paths.get(this.fileName);  BufferedReader reader=Files.newBufferedReader(path,this.charset);  reader.close();   //Noncompliant}</code></pre><p>反例2:</p><pre><code>private void doSomething(){  OutputStream stream=null;  try {    for(String property:propertyList){      stream = new FileOutputStream(&quot;file.txt&quot;); //Noncompliant      // ...    }  } catch (Exception e){    //...  } finally{    stream.close(); //Multiple streams were opened. Only the last is closed.  }}</code></pre><h1 id="返回值尽量不要进行复杂的条件判断，条件和结果尽量清楚明了"><a href="#返回值尽量不要进行复杂的条件判断，条件和结果尽量清楚明了" class="headerlink" title="返回值尽量不要进行复杂的条件判断，条件和结果尽量清楚明了"></a>返回值尽量不要进行复杂的条件判断，条件和结果尽量清楚明了</h1><h1 id="把数组转成ArrayList"><a href="#把数组转成ArrayList" class="headerlink" title="把数组转成ArrayList"></a>把数组转成ArrayList</h1><p>为了将数组转换为ArrayList，开发者经常会这样做：</p><pre><code>List list = Arrays.asList(arr);</code></pre><p>使用Arrays.asList()方法可以得到一个ArrayList，但是得到这个ArrayList其实是定义在Arrays类中的一个私有的静态内部类。这个类虽然和java.util.ArrayList同名，但是并不是同一个类。java.util.Arrays.ArrayList类中实现了set(), get(), contains()等方法，但是并没有定义向其中增加元素的方法。也就是说通过Arrays.asList()得到的ArrayList的大小是固定的。</p><p>如果在开发过程中，想得到一个真正的ArrayList对象（java.util.ArrayList的实例），可以通过以下方式：</p><pre><code>ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(Arrays.asList(arr));</code></pre><p>java.util.ArrayList中包含一个可以接受集合类型参数的构造函数。因为java.util.Arrays.ArrayList这个内部类继承了AbstractList类，所以，该类也是Collection的子类。</p><h1 id="判断一个数组是否包含某个值"><a href="#判断一个数组是否包含某个值" class="headerlink" title="判断一个数组是否包含某个值"></a>判断一个数组是否包含某个值</h1><p>在判断一个数组中是否包含某个值的时候，开发者经常这样做：</p><pre><code>Set&lt;String&gt; set = new HashSet&lt;String&gt;(Arrays.asList(arr));return set.contains(targetValue);</code></pre><p>在《在Java中如何高效的判断数组中是否包含某个元素》[2]中深入分析过,以上方式虽然可以实现功能，但是效率却比较低。因为将数组压入Collection类型中，首先要将数组元素遍历一遍，然后再使用集合类做其他操作。<br>在判断一个数组是否包含某个值的时候，推荐使用for循环遍历的形式或者使用Apache Commons类库中提供的ArrayUtils类的contains方法。</p><h1 id="在循环中删除列表中的元素"><a href="#在循环中删除列表中的元素" class="headerlink" title="在循环中删除列表中的元素"></a>在循环中删除列表中的元素</h1><p>在讨论这个问题之前，先考虑以下代码的输出结果：</p><pre><code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;));for(int i=0;i&lt;list.size();i++){list.remove(i);}System.out.println(list);</code></pre><p>输出结果：</p><pre><code>[b,d]</code></pre><p>以上代码的目的是想遍历删除list中所有元素，但是结果却没有成功。原因是忽略了一个关键的问题：当一个元素被删除时，列表的大小缩小并且下标也会随之变化，所以当你想要在一个循环中用下标删除多个元素的时候，它并不会正常的生效。</p><p>也有些人知道以上代码的问题就由于数组下标变换引起的。所以，他们想到使用增强for循环的形式：</p><pre><code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;));for(String s:list){    if(s.equals(&quot;a&quot;)){        list.remove(s);    }}</code></pre><p>但是，很不幸的是，以上代码会抛出ConcurrentModificationException，有趣的是，如果在remove操作后增加一个break，代码就不会报错：</p><pre><code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;));for(String s:list){    if(s.equals(&quot;a&quot;)){        list.remove(s);        break;    }}</code></pre><p>在《Java中的fail-fast机制》[3]一文中，深入分析了几种在遍历数组的同时删除其中元素的方法以及各种方法存在的问题。其中就介绍了上面的代码出错的原因。<br>迭代器（Iterator）是工作在一个独立的线程中，并且拥有一个 mutex 锁。 迭代器被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，这个索引表的内容不会同步改变，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则 迭代器会马上抛出java.util.ConcurrentModificationException 异常。</p><p>所以，正确的在遍历过程中删除元素的方法应该是使用Iterator：</p><pre><code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;));Iterator&lt;String&gt; iter = list.iterator();while (iter.hasNext()) {    String s = iter.next();    if (s.equals(&quot;a&quot;)) {        iter.remove();    }}</code></pre><p>next()方法必须在调用remove()方法之前调用。如果在循环过程中先调用remove()，再调用next()，就会导致异常ConcurrentModificationException。原因如上。</p><h1 id="HashTable-和-HashMap-的选择"><a href="#HashTable-和-HashMap-的选择" class="headerlink" title="HashTable 和 HashMap 的选择"></a>HashTable 和 HashMap 的选择</h1><p>了解算法的人可能对HashTable比较熟悉，因为他是一个数据结构的名字。但在Java里边，用HashMap来表示这样的数据结构。Hashtable和 HashMap的一个关键性的不同是，HashTable是同步的，而HashMap不是。所以通常不需要HashTable，HashMap用的更多。<br>《HashMap完全解读》[4]、《Java中常见亲属比较》[5]等文章中介绍了他们的区别和如何选择。</p><h1 id="使用原始集合类型"><a href="#使用原始集合类型" class="headerlink" title="使用原始集合类型"></a>使用原始集合类型</h1><p>在Java里边，原始类型和无界通配符类型很容易混合在一起。以Set为例，Set是一个原始类型，而Set&lt; ? &gt;是一个无界通配符类型。 （可以把原始类型理解为没有使用泛型约束的类型）</p><p>考虑下面使用原始类型List作为参数的代码：</p><pre><code>public static void add(List list, Object o){    list.add(o);}public static void main(String[] args){    List&lt;String&gt; list = new ArrayList&lt;String&gt;();    add(list, 10);    String s = list.get(0);}</code></pre><p>上面的代码将会抛出异常：</p><pre><code>java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</code></pre><p>使用原始集合类型是很危险的，因为原始集合类型跳过了泛型类型检查，是不安全的。Set、Set&lt; ? &gt;和Set&lt; Object &gt;之间有很大差别。关于泛型，可以参考下列文章：《Java基础知识——泛型》[12]</p><h1 id="访问级别"><a href="#访问级别" class="headerlink" title="访问级别"></a>访问级别</h1><p>程序员们经常使用public作为类中的字段的修饰符，因为这样可以很简单的通过引用得到值，但这并不是好的设计，按照经验，分配给成员变量的访问级别应该尽可能的低。参考《Java中的四种访问级别》[13]</p><h1 id="ArrayList与LinkedList的选择"><a href="#ArrayList与LinkedList的选择" class="headerlink" title="ArrayList与LinkedList的选择"></a>ArrayList与LinkedList的选择</h1><p>当程序员们不知道ArrayList与LinkedList的区别时，他们经常使用ArrayList，因为它看起来比较熟悉。然而，它们之前有巨大的性能差别。在《ArrayList vs LinkedList vs Vector 区别》[8]、《Java中常见亲属比较》[9]等文章中介绍过，简而言之，如果有大量的增加删除操作并且没有很多的随机访问元素的操作，应该首先LinkedList。（LinkedList更适合从中间插入或者删除（链表的特性））</p><h1 id="可变与不可变"><a href="#可变与不可变" class="headerlink" title="可变与不可变"></a>可变与不可变</h1><p>在《为什么Java要把字符串设计成不可变的》[10]一文中介绍过，不可变对象有许多的优点，比如简单，安全等等。同时，也有人提出疑问：既然不可变有这么多好处，为什么不把所有类都搞成不可变的呢？</p><p>通常情况下，可变对象可以用来避免产生过多的中间对象。一个经典的实例就是连接大量的字符串，如果使用不可变的字符串，将会产生大量的需要进行垃圾回收的对象。这会浪费CPU大量的时间，使用可变对象才是正确的方案(比如StringBuilder)。</p><pre><code>String result=&quot;&quot;;for(String s: arr){    result = result + s;}</code></pre><p>StackOverflow[11]中也有关于这个的讨论。</p><h1 id="””还是构造函数"><a href="#””还是构造函数" class="headerlink" title="””还是构造函数"></a>””还是构造函数</h1><p>关于这个问题，也是程序员经常出现困惑的地方，在《该如何创建字符串，使用” “还是构造函数？》[12]中也介绍过。<br>如果你只需要创建一个字符串，你可以使用双引号的方式，如果你需要在堆中创建一个新的对象，你可以选择构造函数的方式。<br>在String d = new String(“abcd”)时，因为字面值“abcd”已经是字符串类型，那么使用构造函数方式只会创建一个额外没有用处的对象。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="https://www.hollischuang.com/archives/1360" target="_blank" rel="noopener">https://www.hollischuang.com/archives/1360</a><br>【2】<a href="http://www.hollischuang.com/archives/1269" target="_blank" rel="noopener">http://www.hollischuang.com/archives/1269</a><br>【3】<a href="http://www.hollischuang.com/archives/33" target="_blank" rel="noopener">http://www.hollischuang.com/archives/33</a><br>【4】<a href="http://www.hollischuang.com/archives/82" target="_blank" rel="noopener">http://www.hollischuang.com/archives/82</a><br>【5】<a href="http://www.hollischuang.com/archives/442" target="_blank" rel="noopener">http://www.hollischuang.com/archives/442</a><br>【6】<a href="http://www.hollischuang.com/archives/1182" target="_blank" rel="noopener">http://www.hollischuang.com/archives/1182</a><br>【7】<a href="http://www.hollischuang.com/archives/1182" target="_blank" rel="noopener">http://www.hollischuang.com/archives/1182</a><br>【8】<a href="http://www.hollischuang.com/archives/1349" target="_blank" rel="noopener">http://www.hollischuang.com/archives/1349</a><br>【9】<a href="http://www.hollischuang.com/archives/442" target="_blank" rel="noopener">http://www.hollischuang.com/archives/442</a><br>【10】<a href="http://www.hollischuang.com/archives/1246" target="_blank" rel="noopener">http://www.hollischuang.com/archives/1246</a><br>【11】<a href="https://stackoverflow.com/questions/23616211/why-we-need-mutable-classes" target="_blank" rel="noopener">https://stackoverflow.com/questions/23616211/why-we-need-mutable-classes</a><br>【12】<a href="http://www.hollischuang.com/archives/1249" target="_blank" rel="noopener">http://www.hollischuang.com/archives/1249</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java开发中的易错点&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>设计模式学习笔记IV</title>
    <link href="http://yoursite.com/2020/01/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0IV/"/>
    <id>http://yoursite.com/2020/01/03/设计模式学习笔记IV/</id>
    <published>2020-01-03T07:55:12.000Z</published>
    <updated>2020-01-03T07:50:34.899Z</updated>
    
    <content type="html"><![CDATA[<p>建造者（Builder）模式：<br>经典Builder模式；<br>变种Builder模式；</p><a id="more"></a><p>建造者模式是日常开发中比较常见的设计模式，它的主要作用就是将复杂事物创建的过程抽象出来，该抽象的不同实现方式不同，创建出的对象也不同。通俗的讲，创建一个对象一般都会有一个固定的步骤，这个固定的步骤我们把它抽象出来，每个抽象步骤都会有不同的实现方式，不同的实现方式创建出的对象也将不同。举个常见的例子，想必大家都买过电脑，电脑的生产或者组装其实就是属于建造者模式，我们知道，电脑的生产都需要安装CPU、内存条、硬盘等元器件。我们可以把这个安装步骤抽象出来，至于到底装哪种CPU，比如i5还是i7就是对该抽象安装步骤的具体实现。</p><p>建造者模式分为两种，一种为经典建造者模式，另一种为变种建造者模式。我们来挨个看下：</p><h1 id="经典Builder模式"><a href="#经典Builder模式" class="headerlink" title="经典Builder模式"></a>经典Builder模式</h1><p>经典Buider模式中有四个角色：</p><p>要建造的产品Product – 组装的电脑<br>抽象的Builder – 装CPU、内存条、硬盘等抽象的步骤<br>Builder的具体实现ConcreteBuilder – 对上述抽象步骤的实现，比如装i5CPU、8G内存条、1T硬盘<br>使用者Director – 电脑装机人员<br>接下来我们来看下用代码如何实现上述组装电脑的过程：</p><h2 id="首先我们先来创建一个Computer类："><a href="#首先我们先来创建一个Computer类：" class="headerlink" title="首先我们先来创建一个Computer类："></a>首先我们先来创建一个Computer类：</h2><pre><code>public class Computer {    /*CPU*/    private String CPU;    /*内存*/    private String memory;    /*硬盘*/    private String hardDisk;    /*键盘*/    private String keyboard;    /*鼠标*/    private String mouse;    public String getCPU() {        return CPU;    }    public void setCPU(String CPU) {        this.CPU = CPU;    }    public String getMemory() {        return memory;    }    public void setMemory(String memory) {        this.memory = memory;    }    public String getHardDisk() {        return hardDisk;    }    public void setHardDisk(String hardDisk) {        this.hardDisk = hardDisk;    }    public String getKeyboard() {        return keyboard;    }    public void setKeyboard(String keyboard) {        this.keyboard = keyboard;    }    public String getMouse() {        return mouse;    }    public void setMouse(String mouse) {        this.mouse = mouse;    }    @Override    public String toString() {        return &quot;Computer{&quot; +                &quot;CPU=&apos;&quot; + CPU + &apos;\&apos;&apos; +                &quot;, memory=&apos;&quot; + memory + &apos;\&apos;&apos; +                &quot;, hardDisk=&apos;&quot; + hardDisk + &apos;\&apos;&apos; +                &quot;, keyboard=&apos;&quot; + keyboard + &apos;\&apos;&apos; +                &quot;, mouse=&apos;&quot; + mouse + &apos;\&apos;&apos; +                &apos;}&apos;;    }}</code></pre><p>很简单，可以看到这个Computer类中有五个基本属性CPU、内存条、硬盘、键盘和鼠标，然后还有一个toString方法，用于之后方便打印信息用。</p><h2 id="接下来我们来创建一个抽象的电脑组装过程的Builder类："><a href="#接下来我们来创建一个抽象的电脑组装过程的Builder类：" class="headerlink" title="接下来我们来创建一个抽象的电脑组装过程的Builder类："></a>接下来我们来创建一个抽象的电脑组装过程的Builder类：</h2><pre><code>public interface ComputerConfigBuilder {    void setCPU();    void setMemery();    void setHardDisk();    void setKeyboard();    void setMouse();    Computer getComputer();}</code></pre><p>电脑组装一般都需要安装CPU、内存条、硬盘、键盘鼠标等，我们把这一安装过程给抽象出来，也就是这里的ComputerConfigBuilder ，至于具体安装什么需要其实现类来实现，另外其中还定义了一个获取Conputer的方法。</p><h2 id="创建具体的实现类"><a href="#创建具体的实现类" class="headerlink" title="创建具体的实现类"></a>创建具体的实现类</h2><p>好了，有了抽象的组装过程，接下来我们就需要创建具体的实现类。我们知道电脑一般都有低配版和高配版，不同配置，组装成的电脑自然就不一样。接下我们首先来创建一个低配版的套餐LowConfigBuilder ，让其实现ComputerConfigBuilder：</p><pre><code>public class LowConfigBuilder implements ComputerConfigBuilder {    private Computer mComputer;    public LowConfigBuilder(){        this.mComputer = new Computer();    }    @Override    public void setCPU() {        mComputer.setCPU(&quot;i5&quot;);    }    @Override    public void setMemery() {        mComputer.setMemory(&quot;8G&quot;);    }    @Override    public void setHardDisk() {        mComputer.setHardDisk(&quot;500G&quot;);    }    @Override    public void setKeyboard() {        mComputer.setKeyboard(&quot;薄膜键盘&quot;);    }    @Override    public void setMouse() {        mComputer.setMouse(&quot;有线鼠标&quot;);    }    @Override    public Computer getComputer() {        return mComputer;    }}</code></pre><p>可以看到这个低配版的配置为：i5的CPU、8G内存、500G硬盘、薄膜键盘和有线鼠标。</p><p>接着我们再创建一个高配版的套餐：</p><pre><code>public class HighConfigBuider implements ComputerConfigBuilder {    private Computer mComputer;    public HighConfigBuider(){        this.mComputer = new Computer();    }    @Override    public void setCPU() {        mComputer.setCPU(&quot;i7&quot;);    }    @Override    public void setMemery() {        mComputer.setMemory(&quot;16G&quot;);    }    @Override    public void setHardDisk() {        mComputer.setHardDisk(&quot;1T&quot;);    }    @Override    public void setKeyboard() {        mComputer.setKeyboard(&quot;机械键盘&quot;);    }    @Override    public void setMouse() {        mComputer.setMouse(&quot;无线鼠标&quot;);    }    @Override    public Computer getComputer() {        return mComputer;    }}</code></pre><p>可以看到这个高配版的配置为：i7的CPU、16G内存、1T硬盘、机械键盘和无线鼠标。</p><h2 id="上面我们已经定义好了两种配置方案，接下我们还需要一名装机人员Director："><a href="#上面我们已经定义好了两种配置方案，接下我们还需要一名装机人员Director：" class="headerlink" title="上面我们已经定义好了两种配置方案，接下我们还需要一名装机人员Director："></a>上面我们已经定义好了两种配置方案，接下我们还需要一名装机人员Director：</h2><pre><code>public class Director {    private ComputerConfigBuilder mBuilder;    public void setBuilder(ComputerConfigBuilder builder){        this.mBuilder = builder;    }    public void createComputer(){        mBuilder.setCPU();        mBuilder.setMemery();        mBuilder.setHardDisk();        mBuilder.setKeyboard();        mBuilder.setMouse();    }    public Computer getComputer(){        return mBuilder.getComputer();    }}</code></pre><p>我们需要通过setBuilder来告诉他电脑需要什么配置，然后就可以通过createComputer来一步步组装电脑，组装完之后就可以调用getComputer方法来获取我们需要的电脑啦。</p><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>接下来我们就来创建一台电脑试下，首先我们先创建一个<br>低配版的：</p><pre><code>Director director = new Director();//创建装机人员director.setBuilder(new LowConfigBuilder()); //告诉装机人员电脑配置，这里为低配版director.createComputer(); //装机人员开始组装Computer computer = director.getComputer(); //从装机人员获取组装好的电脑System.out.print(&quot;电脑配置：&quot; + computer.toString());  //查看电脑配置--------------------------------------输出结果：电脑配置：Computer{CPU=&apos;i5&apos;, memory=&apos;8G&apos;, hardDisk=&apos;500G&apos;, keyboard=&apos;薄膜键盘&apos;, mouse=&apos;有线鼠标&apos;}--------------------------------------</code></pre><h1 id="变种Builder模式"><a href="#变种Builder模式" class="headerlink" title="变种Builder模式"></a>变种Builder模式</h1><p>需要创建一个不可变的Person对象，这个Person可以拥有以下几个属性：名字、性别、年龄、职业、车、鞋子、衣服、钱、房子。其中名字和性别是必须有的。</p><p>我们首先想到的是给出以下的一个符合要求的Person类</p><pre><code>public class Person {    /*名字（必须）*/    private final String name;    /*性别（必须）*/    private final String gender;    /*年龄（非必须）*/    private final String age;    /*鞋子（非必须）*/    private final String shoes;    /*衣服（非必须）*/    private final String clothes;    /*钱（非必须）*/    private final String money;    /*房子（非必须）*/    private final String house;    /*汽车（非必须）*/    private final String car;    /*职业（非必须）*/    private final String career;    public Person(String name,String gender,String age,String shoes,String clothes,String money,String house,String car,String career){        this.name = name;        this.gender = gender;        this.age = age;        this.shoes = shoes;        this.clothes = clothes;        this.money = money;        this.house = house;        this.car = car;        this.career = career;    }    public Person(String name, String gender){        this(name,gender,null,null,null,null,null,null,null);    }}</code></pre><p>由于要创建出的Person对象是不可变的，所以将类中的属性都声明为final的，然后定义了一个参数为所有属性的构造方法，又因为name和gender为必须项，所以为了调用者方便又单独定义了一个参数为name和gender的构造方法。这样Person类就好了，但这样存在一个问题，就是如果需要传入非必须属性的时候，这个构造方法调用起来不是很方便，因为这个构造方法参数太多了，很容易传错。所以我们改用set方法设置：</p><pre><code>public class Person {    /*名字（必须）*/    private String name;    /*性别（必须）*/    private String gender;    /*年龄（非必须）*/    private String age;    /*鞋子（非必须）*/    private String shoes;    /*衣服（非必须）*/    private String clothes;    /*钱（非必须）*/    private String money;    /*房子（非必须）*/    private String house;    /*汽车（非必须）*/    private String car;    /*职业（非必须）*/    private String career;    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public String getGender() {        return gender;    }    public void setGender(String gender) {        this.gender = gender;    }    public String getAge() {        return age;    }    public void setAge(String age) {        this.age = age;    }    public String getShoes() {        return shoes;    }    public void setShoes(String shoes) {        this.shoes = shoes;    }    ......}</code></pre><p>如果要创建对象的话只用如下操作就行了：</p><pre><code>Person person = new Person();person.setName(&quot;张三&quot;);person.setAge(&quot;22&quot;);person.setGender(&quot;男&quot;);person.setCareer(&quot;程序员&quot;);......</code></pre><p>这样看上去比较清晰了，只要创建一个对象，想要赋什么值set上去就可以了，不过你细细看了下，还是发现了不少的问题的，首先用这个set方法，违背了刚开始这个对象不可变的需求，其次用这种set方法一条一条赋值，很可能会得到一个不完整的Person对象，因为当建完了Person对象，可能出于各方面的原因有些信息忘记set了，那么得到的Person对象就不是预期的对象。这时我们只能用下面这种变种的Builder模式：</p><pre><code>public class Person {    /*名字（必须）*/    private final String name;    /*性别（必须）*/    private final String gender;    /*年龄（非必须）*/    private final String age;    /*鞋子（非必须）*/    private final String shoes;    /*衣服（非必须）*/    private final String clothes;    /*钱（非必须）*/    private final String money;    /*房子（非必须）*/    private final String house;    /*汽车（非必须）*/    private final String car;    /*职业（非必须）*/    private final String career;    private Person(Builder builder) {        this.name = builder.name;        this.gender = builder.gender;        this.age = builder.age;        this.shoes = builder.shoes;        this.clothes = builder.clothes;        this.money = builder.money;        this.house = builder.house;        this.car = builder.car;        this.career = builder.career;    }    public static class Builder {        private final String name;        private final String gender;        private String age;        private String shoes;        private String clothes;        private String money;        private String house;        private String car;        private String career;        public Builder(String name,String gender) {            this.name = name;            this.gender = gender;        }        public Builder age(String age) {            this.age = age;            return this;        }        public Builder car(String car) {            this.car = car;            return this;        }        public Builder shoes(String shoes) {            this.shoes = shoes;            return this;        }        public Builder clothes(String clothes) {            this.clothes = clothes;            return this;        }        public Builder money(String money) {            this.money = money;            return this;        }        public Builder house(String house) {            this.house = house;            return this;        }        public Builder career(String career) {            this.career = career;            return this;        }        public Person build(){            return new Person(this);        }    }</code></pre><p>由于这个Person对象是不可变的，所以毫无疑问我们给他的所有属性都加了final修饰，当然如果没有不可变的需求也是可以不加的，然后在Person类中定义一个内部类Builder，这个Builder内部类中的属性要和Person中的相同，并且必须有的属性要用final修饰，防止这些属性没有被赋值，其他非必须的属性不能用final，因为如果加了final，就必须对其进行初始化，这样这些非必须的属性又变成必须的。然后内部类中定义了一个构造方法，传入必须有的属性。其他非必须的属性都通过方法设置，每个方法都返回Builder对象自身。最后定义了一个build方法，将Builder对象传入Person的私有构造方法，最终返回一个对象。</p><p>接下来我们来看下Person的创建：</p><pre><code>Person person = new Person.Builder(&quot;张三&quot;,&quot;男&quot;)        .age(&quot;12&quot;)        .money(&quot;1000000&quot;)        .car(&quot;宝马&quot;)        .build();</code></pre><p>非必须的属性可以根据需要任意设置，非常灵活，而且这样先设置属性再创建对象，最终获取的对象一定是你预期的完整对象，不会像用之前set的方法创建的对象可能还没有设置完全。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="https://www.jianshu.com/p/afe090b2e19c" target="_blank" rel="noopener">https://www.jianshu.com/p/afe090b2e19c</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;建造者（Builder）模式：&lt;br&gt;经典Builder模式；&lt;br&gt;变种Builder模式；&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Design Pattern，Java" scheme="http://yoursite.com/tags/Design-Pattern%EF%BC%8CJava/"/>
    
  </entry>
  
  <entry>
    <title>数据库学习笔记VI</title>
    <link href="http://yoursite.com/2020/01/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0VII/"/>
    <id>http://yoursite.com/2020/01/03/数据库学习笔记VII/</id>
    <published>2020-01-03T03:12:12.000Z</published>
    <updated>2020-01-06T01:30:00.687Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL建表,LIMIT,OFFSET的用法,Rank函数的用法   </p><a id="more"></a><h1 id="MySQL建表"><a href="#MySQL建表" class="headerlink" title="MySQL建表"></a>MySQL建表</h1><p>下面是通用的SQL语法用来创建MySQL表：</p><pre><code>CREATE TABLE table_name (column_name column_type);</code></pre><p>现在，我们将在 test 数据库中创建以下表。</p><pre><code>create table tutorials_tbl(   tutorial_id INT NOT NULL AUTO_INCREMENT,   tutorial_title VARCHAR(100) NOT NULL,   tutorial_author VARCHAR(40) NOT NULL,   submission_date DATE,   PRIMARY KEY ( tutorial_id ));</code></pre><p>在这里，一些数据项需要解释：<br>字段使用NOT NULL属性，是因为我们不希望这个字段的值为NULL。 因此，如果用户将尝试创建具有NULL值的记录，那么MySQL会产生错误。</p><p>字段的AUTO_INCREMENT属性告诉MySQL自动增加id字段下一个可用编号。</p><h1 id="LIMIT-OFFSET"><a href="#LIMIT-OFFSET" class="headerlink" title="LIMIT,OFFSET"></a>LIMIT,OFFSET</h1><pre><code>SELECT column_name FROM table_name LIMIT 4 OFFSET 3;</code></pre><p>LIMIT 4 OFFSET 3指示MySQL等DBMS返回从第3行（从0行计数）起的4行数据。第一个数字是检索的行数，第二个数字是指从哪儿开始。</p><p>MySQL和MariaDB支持简化版的LIMIT 4 OFFSET 3语句，即LIMIT 3,4。使用这个语法，之前的值对应OFFSET之后的值对应LIMIT 。</p><p> limit10000,20的意思扫描满足条件的10020行，扔掉前面的10000行，返回最后的20行.</p><p>参考练习题：<a href="https://leetcode.com/problems/nth-highest-salary" target="_blank" rel="noopener">https://leetcode.com/problems/nth-highest-salary</a></p><h1 id="mysql变量的种类"><a href="#mysql变量的种类" class="headerlink" title="mysql变量的种类"></a>mysql变量的种类</h1><p>用户变量：以”@”开始，形式为”@变量名”。用户变量跟mysql客户端是绑定的，设置的变量，只对当前用户使用的客户端生效<br>全局变量：定义时，以如下两种形式出现，set GLOBAL 变量名  或者  set @@global.变量名，对所有客户端生效。只有具有super权限才可以设置全局变量<br>会话变量：只对连接的客户端有效。<br>局部变量：作用范围在begin到end语句块之间。在该语句块里设置的变量。declare语句专门用于定义局部变量。set语句是设置不同类型的变量，包括会话变量和全局变量<br>通俗理解术语之间的区别：</p><p>用户定义的变量就叫用户变量。这样理解的话，会话变量和全局变量都可以是用户定义的变量。只是他们是对当前客户端生效还是对所有客户端生效的区别了。所以，用户变量包括了会话变量和全局变量</p><p>局部变量与用户变量的区分在于:<br>1.用户变量是以”@”开头的。局部变量没有这个符号。<br>2.定义变量不同。用户变量使用set语句，局部变量使用declare语句定义<br>3.作用范围。局部变量只在begin-end语句块之间有效。在begin-end语句块运行完之后，局部变量就消失了。</p><p>所以，最后它们之间的层次关系是：变量包括局部变量和用户变量。用户变量包括会话变量和全局变量。</p><h1 id="mysql-declare定义变量"><a href="#mysql-declare定义变量" class="headerlink" title="mysql declare定义变量"></a>mysql declare定义变量</h1><p>mysql declare用于定义变量，在存储过程和函数中通过declare定义变量在BEGIN…END中，且在语句之前。并且可以通过重复定义多个变量</p><p>declare变量的作用范围同编程里面类似，在这里一般是在对应的begin和end之间。在end之后这个变量就没有作用了，不能使用了。这个同编程一样。</p><p>注意：declare定义的变量名不能带‘@’符号，mysql在这点做的确实不够直观，往往变量名会被错成参数或者字段名。</p><p>mysql存储过程中使用declare定义变量，实例如下：</p><p> DROP PROCEDURE IF EXISTS insert_ten_rows $$<br> CREATE PROCEDURE insert_ten_rows ()<br>     BEGIN<br>         DECLARE crs INT DEFAULT 0;</p><pre><code>    WHILE crs &lt; 10 DO        INSERT INTO `continent`(`name`) VALUES (&apos;cont&apos;+crs);        SET crs = crs + 1;    END WHILE;END $$</code></pre><p> DELIMITER ;</p><h1 id="mysql-SET定义变量"><a href="#mysql-SET定义变量" class="headerlink" title="mysql SET定义变量"></a>mysql SET定义变量</h1><p>mysql set也可以用来定于变量，定义变量的形式是以”@”开始，如：”@变量名”。</p><p>mysql SET定义变量实例：</p><p>   mysql&gt; SET @t1=0, @t2=1, @t3=2;</p><p>   mysql&gt; select @t1;<br>   +——+<br>   | @t1  |<br>   +——+<br>   | 0    |<br>   +——+</p><p>   mysql&gt; select @t2;<br>   +——+<br>   | @t2  |<br>   +——+<br>   | 1    |<br>   +——+</p><p>   mysql&gt; select @t3;<br>   +——+<br>   | @t3  |<br>   +——+<br>   | 2    |<br>   +——+</p><p>   mysql&gt;</p><p>复杂一点的实例：</p><p>   mysql&gt; SET @t1=0, @t2=1, @t3=2;</p><p>   mysql&gt; SELECT @t1:=(@t2:=1)+@t3:=4,@t1,@t2,@t3;<br>   +———————-+——+——+——+<br>   | @t1:=(@t2:=1)+@t3:=4 | @t1  | @t2  | @t3  |<br>   +———————-+——+——+——+<br>   |                    5 | 5    | 1    | 4    |<br>   +———————-+——+——+——+</p><h1 id="mysql-declare和set定义变量的区别"><a href="#mysql-declare和set定义变量的区别" class="headerlink" title="mysql declare和set定义变量的区别"></a>mysql declare和set定义变量的区别</h1><p>mysql declare和set定义变量，除了一个不加@和一个加@这个区别之外，还有以下区别：</p><p> declare用来定义局部变量</p><p> @用来定义会话变量</p><p> declare变量的作用范围同编程里面类似，在这里一般是在对应的begin和end之间。在end之后这个变量就没有作用了，不能使用了。这个同编程一样。</p><p> 另外有种变量叫做会话变量(session variable)，也叫做用户定义的变量(user defined variable)。这种变量要在变量名称前面加上“@”符号，叫做会话变量，代表整个会话过程他都是有作用的，这个有点类似于全局变量一样。这种变量用途比较广，因为只要在一个会话内(就是某个应用的一个连接过程中)，这个变量可以在被调用的存储过程或者代码之间共享数据。</p><h1 id="rank函数"><a href="#rank函数" class="headerlink" title="rank函数"></a>rank函数</h1><p>用于返回结果集的分区内每行的排名， 行的排名是相关行之前的排名数加一。简单来说rank函数就是对查询出来的记录进行排名，与row_number函数不同的是，rank函数考虑到了over子句中排序字段值相同的情况，如果使用rank函数来生成序号，over子句中排序字段值相同的序号是一样的，后面字段值不相同的序号将跳过相同的排名号排下一个，也就是相关行之前的排名数加一，可以理解为根据当前的记录数生成序号，后面的记录依此类推。</p><p>select RANK() OVER(order by column_name) as rank,* from table_name</p><p>#参考资料<br>【1】 <a href="https://tech.meituan.com/2014/06/30/mysql-index.html" target="_blank" rel="noopener">https://tech.meituan.com/2014/06/30/mysql-index.html</a><br>【2】 <a href="https://blog.csdn.net/qq_37923253/article/details/79688313" target="_blank" rel="noopener">https://blog.csdn.net/qq_37923253/article/details/79688313</a><br>【3】 <a href="http://www.manongjc.com/article/1441.html" target="_blank" rel="noopener">http://www.manongjc.com/article/1441.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL建表,LIMIT,OFFSET的用法,Rank函数的用法   &lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Java开发规范</title>
    <link href="http://yoursite.com/2020/01/02/Java%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    <id>http://yoursite.com/2020/01/02/Java开发规范/</id>
    <published>2020-01-02T07:06:12.000Z</published>
    <updated>2020-01-02T14:16:09.502Z</updated>
    
    <content type="html"><![CDATA[<p>常见的开发规范</p><a id="more"></a><h1 id="编程规约"><a href="#编程规约" class="headerlink" title="编程规约"></a>编程规约</h1><h2 id="【强制】-代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。"><a href="#【强制】-代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。" class="headerlink" title="【强制】 代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。"></a>【强制】 代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。</h2><p>反例： <em>name / __name / $Object / name</em> / name$ / Object$</p><h2 id="【强制】-代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。"><a href="#【强制】-代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。" class="headerlink" title="【强制】 代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。"></a>【强制】 代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。</h2><p>说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式<br>也要避免采用。</p><p>反例： DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3<br>正例： alibaba / taobao / youku / hangzhou 等国际通用的名称，可视同英文。</p><h2 id="【强制】类名使用-UpperCamelCase-风格，必须遵从驼峰形式，但以下情形例外：（领域模型的相关命名）DO-BO-DTO-VO-等。"><a href="#【强制】类名使用-UpperCamelCase-风格，必须遵从驼峰形式，但以下情形例外：（领域模型的相关命名）DO-BO-DTO-VO-等。" class="headerlink" title="【强制】类名使用 UpperCamelCase 风格，必须遵从驼峰形式，但以下情形例外：（领域模型的相关命名）DO / BO / DTO / VO 等。"></a>【强制】类名使用 UpperCamelCase 风格，必须遵从驼峰形式，但以下情形例外：（领域模型的相关命名）DO / BO / DTO / VO 等。</h2><p>正例：MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion<br>反例：macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion</p><h2 id="【强制】方法名、参数名、成员变量、局部变量都统一使用-lowerCamelCase-风格，必须遵从驼峰形式。"><a href="#【强制】方法名、参数名、成员变量、局部变量都统一使用-lowerCamelCase-风格，必须遵从驼峰形式。" class="headerlink" title="【强制】方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。"></a>【强制】方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。</h2><p>正例： localValue / getHttpMessage() / inputUserId</p><h2 id="【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。"><a href="#【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。" class="headerlink" title="【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。"></a>【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。</h2><p>正例： MAX_STOCK_COUNT<br>反例： MAX_COUNT</p><h2 id="【强制】抽象类命名使用-Abstract-或-Base-开头；异常类命名使用-Exception-结尾；测试类命名以它要测试的类的名称开始，以-Test-结尾。"><a href="#【强制】抽象类命名使用-Abstract-或-Base-开头；异常类命名使用-Exception-结尾；测试类命名以它要测试的类的名称开始，以-Test-结尾。" class="headerlink" title="【强制】抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾。"></a>【强制】抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾。</h2><h2 id="【强制】中括号是数组类型的一部分，数组定义如下：String-args"><a href="#【强制】中括号是数组类型的一部分，数组定义如下：String-args" class="headerlink" title="【强制】中括号是数组类型的一部分，数组定义如下：String[] args;"></a>【强制】中括号是数组类型的一部分，数组定义如下：String[] args;</h2><p>反例：请勿使用 String args[]的方式来定义。</p><h2 id="【强制】POJO-类中布尔类型的变量，都不要加-is，否则部分框架解析会引起序列化错误。"><a href="#【强制】POJO-类中布尔类型的变量，都不要加-is，否则部分框架解析会引起序列化错误。" class="headerlink" title="【强制】POJO 类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。"></a>【强制】POJO 类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。</h2><p>反例：定义为基本数据类型 boolean isSuccess；的属性，它的方法也是 isSuccess()，RPC<br>框架在反向解析的时候，“以为”对应的属性名称是 success，导致属性获取不到，进而抛出异<br>常。</p><h2 id="【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。"><a href="#【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。" class="headerlink" title="【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。"></a>【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。</h2><p>正例： 应用工具类包名为 com.alibaba.open.util、类名为 MessageUtils（此规则参考<br>spring 的框架结构）</p><h2 id="【强制】杜绝完全不规范的缩写，避免望文不知义。"><a href="#【强制】杜绝完全不规范的缩写，避免望文不知义。" class="headerlink" title="【强制】杜绝完全不规范的缩写，避免望文不知义。"></a>【强制】杜绝完全不规范的缩写，避免望文不知义。</h2><p>反例： AbstractClass“缩写”命名成 AbsClass；condition“缩写”命名成 condi，此类<br>随意缩写严重降低了代码的可阅读性。</p><h2 id="【推荐】如果使用到了设计模式，建议在类名中体现出具体模式。"><a href="#【推荐】如果使用到了设计模式，建议在类名中体现出具体模式。" class="headerlink" title="【推荐】如果使用到了设计模式，建议在类名中体现出具体模式。"></a>【推荐】如果使用到了设计模式，建议在类名中体现出具体模式。</h2><p>说明：将设计模式体现在名字中，有利于阅读者快速理解架构设计思想。<br>正例：public class OrderFactory;<br>public class LoginProxy;<br>public class ResourceObserver;</p><h2 id="【推荐】接口类中的方法和属性不要加任何修饰符号（public-也不要加），保持代码的简洁性，并加上有效的-Javadoc-注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。"><a href="#【推荐】接口类中的方法和属性不要加任何修饰符号（public-也不要加），保持代码的简洁性，并加上有效的-Javadoc-注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。" class="headerlink" title="【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。"></a>【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。</h2><p>正例：接口方法签名：void f();<br>接口基础常量表示：String COMPANY = “alibaba”;<br>反例：接口方法定义：public abstract void f();<br>说明：JDK8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默<br>认实现。</p><h2 id="接口和实现类的命名有两套规则："><a href="#接口和实现类的命名有两套规则：" class="headerlink" title="接口和实现类的命名有两套规则："></a>接口和实现类的命名有两套规则：</h2><h3 id="【强制】对于-Service-和-DAO-类，基于-SOA-的理念，暴露出来的服务一定是接口，内部的实现类用-Impl-的后缀与接口区别。"><a href="#【强制】对于-Service-和-DAO-类，基于-SOA-的理念，暴露出来的服务一定是接口，内部的实现类用-Impl-的后缀与接口区别。" class="headerlink" title="【强制】对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部的实现类用 Impl 的后缀与接口区别。"></a>【强制】对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部的实现类用 Impl 的后缀与接口区别。</h3><p>正例：CacheServiceImpl 实现 CacheService 接口。</p><h3 id="【推荐】如果是形容能力的接口名称，取对应的形容词做接口名（通常是–able-的形式）。"><a href="#【推荐】如果是形容能力的接口名称，取对应的形容词做接口名（通常是–able-的形式）。" class="headerlink" title="【推荐】如果是形容能力的接口名称，取对应的形容词做接口名（通常是–able 的形式）。"></a>【推荐】如果是形容能力的接口名称，取对应的形容词做接口名（通常是–able 的形式）。</h3><p>正例：AbstractTranslator 实现 Translatable。</p><h2 id="【参考】枚举类名建议带上-Enum-后缀，枚举成员名称需要全大写，单词间用下划线隔开。"><a href="#【参考】枚举类名建议带上-Enum-后缀，枚举成员名称需要全大写，单词间用下划线隔开。" class="headerlink" title="【参考】枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。"></a>【参考】枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。</h2><p>说明：枚举其实就是特殊的常量类，且构造方法被默认强制是私有。<br>正例：枚举名字：DealStatusEnum，成员名称：SUCCESS / UNKOWN_REASON。</p><p>##【参考】各层命名规约：</p><h3 id="Service-DAO-层方法命名规约"><a href="#Service-DAO-层方法命名规约" class="headerlink" title="Service/DAO 层方法命名规约"></a>Service/DAO 层方法命名规约</h3><p>1） 获取单个对象的方法用 get 做前缀。<br>2） 获取多个对象的方法用 list 做前缀。<br>3） 获取统计值的方法用 count 做前缀。<br>4） 插入的方法用 save（推荐）或 insert 做前缀。<br>5） 删除的方法用 remove（推荐）或 delete 做前缀。<br>6） 修改的方法用 update 做前缀。</p><h3 id="领域模型命名规约"><a href="#领域模型命名规约" class="headerlink" title="领域模型命名规约"></a>领域模型命名规约</h3><p>1） 数据对象：xxxDO，xxx 即为数据表名。<br>2） 数据传输对象：xxxDTO，xxx 为业务领域相关的名称。<br>3） 展示对象：xxxVO，xxx 一般为网页名称。<br>4） POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO</p><h1 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h1><h2 id="【强制】不允许出现任何魔法值（即未经定义的常量）直接出现在代码中。"><a href="#【强制】不允许出现任何魔法值（即未经定义的常量）直接出现在代码中。" class="headerlink" title="【强制】不允许出现任何魔法值（即未经定义的常量）直接出现在代码中。"></a>【强制】不允许出现任何魔法值（即未经定义的常量）直接出现在代码中。</h2><p>反例： String key=”Id#taobao_”+tradeId；<br>cache.put(key, value);</p><h2 id="【强制】long-或者-Long-初始赋值时，必须使用大写的-L，不能是小写的-l，小写容易跟数字1-混淆，造成误解。"><a href="#【强制】long-或者-Long-初始赋值时，必须使用大写的-L，不能是小写的-l，小写容易跟数字1-混淆，造成误解。" class="headerlink" title="【强制】long 或者 Long 初始赋值时，必须使用大写的 L，不能是小写的 l，小写容易跟数字1 混淆，造成误解。"></a>【强制】long 或者 Long 初始赋值时，必须使用大写的 L，不能是小写的 l，小写容易跟数字1 混淆，造成误解。</h2><p>说明：Long a = 2l; 写的是数字的 21，还是 Long 型的 2?</p><h2 id="【推荐】不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。"><a href="#【推荐】不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。" class="headerlink" title="【推荐】不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。"></a>【推荐】不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。</h2><p>如：缓存相关的常量放在类：CacheConsts 下；系统配置相关的常量放在类：ConfigConsts 下。<br>说明：大而全的常量类，非得使用查找功能才能定位到修改的常量，不利于理解和维护。</p><h2 id="【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。"><a href="#【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。" class="headerlink" title="【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。"></a>【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。</h2><p>1） 跨应用共享常量：放置在二方库中，通常是 client.jar 中的 constant 目录下。<br>2） 应用内共享常量：放置在一方库的 modules 中的 constant 目录下。<br>反例：易懂变量也要统一定义成应用内共享常量，两位攻城师在两个类中分别定义了表示“是”的变量：<br>类 A 中：public static final String YES = “yes”; 类 B 中：public static final String YES = “y”; A.YES.equals(B.YES)，预期是 true，但实际返回为 false，导致产生线上问题。<br>3） 子工程内部共享常量：即在当前子工程的 constant 目录下。<br>4） 包内共享常量：即在当前包下单独的 constant 目录下。<br>5） 类内共享常量：直接在类内部 private static final 定义。</p><h2 id="【推荐】如果变量值仅在一个范围内变化用-Enum-类。如果还带有名称之外的延伸属性，必须使用-Enum-类"><a href="#【推荐】如果变量值仅在一个范围内变化用-Enum-类。如果还带有名称之外的延伸属性，必须使用-Enum-类" class="headerlink" title="【推荐】如果变量值仅在一个范围内变化用 Enum 类。如果还带有名称之外的延伸属性，必须使用 Enum 类"></a>【推荐】如果变量值仅在一个范围内变化用 Enum 类。如果还带有名称之外的延伸属性，必须使用 Enum 类</h2><p>下面正例中的数字就是延伸信息，表示星期几。<br>正例：</p><pre><code>public Enum{  MONDAY(1), TUESDAY(2), WEDNESDAY(3), THURSDAY(4), FRIDAY(5),SATURDAY(6),SUNDAY(7);}</code></pre><h1 id="格式规约"><a href="#格式规约" class="headerlink" title="格式规约"></a>格式规约</h1><h2 id="【强制】大括号的使用约定。"><a href="#【强制】大括号的使用约定。" class="headerlink" title="【强制】大括号的使用约定。"></a>【强制】大括号的使用约定。</h2><p>如果是大括号内为空，则简洁地写成{}即可，不需要换行；<br>如果是非空代码块则：<br>1） 左大括号前不换行。<br>2） 左大括号后换行。<br>3） 右大括号前换行。<br>4） 右大括号后还有 else 等代码则不换行；表示终止右大括号后必须换行。</p><h2 id="【强制】-左括号和后一个字符之间不出现空格；同样，右括号和前一个字符之间也不出现空"><a href="#【强制】-左括号和后一个字符之间不出现空格；同样，右括号和前一个字符之间也不出现空" class="headerlink" title="【强制】 左括号和后一个字符之间不出现空格；同样，右括号和前一个字符之间也不出现空"></a>【强制】 左括号和后一个字符之间不出现空格；同样，右括号和前一个字符之间也不出现空</h2><p>格。详见第 5 条下方正例ᨀ示。</p><h2 id="【强制】if-for-while-switch-do-等保留字与左右括号之间都必须加空格。"><a href="#【强制】if-for-while-switch-do-等保留字与左右括号之间都必须加空格。" class="headerlink" title="【强制】if/for/while/switch/do 等保留字与左右括号之间都必须加空格。"></a>【强制】if/for/while/switch/do 等保留字与左右括号之间都必须加空格。</h2><h2 id="【强制】任何运算符左右必须加一个空格。"><a href="#【强制】任何运算符左右必须加一个空格。" class="headerlink" title="【强制】任何运算符左右必须加一个空格。"></a>【强制】任何运算符左右必须加一个空格。</h2><p>说明：运算符包括赋值运算符=、逻辑运算符&amp;&amp;、加减乘除符号、三目运行符等。</p><h2 id="【强制】缩进采用-4-个空格，禁止使用-tab-字符。"><a href="#【强制】缩进采用-4-个空格，禁止使用-tab-字符。" class="headerlink" title="【强制】缩进采用 4 个空格，禁止使用 tab 字符。"></a>【强制】缩进采用 4 个空格，禁止使用 tab 字符。</h2><p>说明：如果使用 tab 缩进，必须设置 1 个 tab 为 4 个空格。IDEA 设置 tab 为 4 个空格时，<br>请勿勾选 Use tab character；而在 eclipse 中，必须勾选 insert spaces for tabs。<br>正例： （涉及 1-5 点）<br>    public static void main(String args[]) {<br>        // 缩进 4 个空格<br>        String say = “hello”;<br>        // 运算符的左右必须有一个空格<br>        int flag = 0;<br>        // 关键词 if 与括号之间必须有一个空格，括号内的 f 与左括号，0 与右括号不需要空格<br>        if (flag == 0) {<br>        System.out.println(say);<br>        }<br>        // 左大括号前加空格且不换行；左大括号后换行<br>        if (flag == 1) {<br>        System.out.println(“world”);<br>        // 右大括号前换行，右大括号后有 else，不用换行<br>        } else {<br>        System.out.println(“ok”);<br>        // 在右大括号后直接结束，则必须换行<br>        }<br>    }</p><h2 id="【强制】单行字符数限制不超过-120-个，超出需要换行，换行时遵循如下原则："><a href="#【强制】单行字符数限制不超过-120-个，超出需要换行，换行时遵循如下原则：" class="headerlink" title="【强制】单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则："></a>【强制】单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则：</h2><p>1） 第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。<br>2） 运算符与下文一起换行。<br>3） 方法调用的点符号与下文一起换行。<br>4） 在多个参数超长，逗号后进行换行。<br>5） 在括号前不要换行，见反例。<br>正例：<br>    StringBuffer sb = new StringBuffer();<br>    //超过 120 个字符的情况下，换行缩进 4 个空格，并且方法前的点符号一起换行<br>    sb.append(“zi”).append(“xin”)…<br>    .append(“huang”)…<br>    .append(“huang”)…<br>    .append(“huang”);<br>反例：<br>    StringBuffer sb = new StringBuffer();<br>    //超过 120 个字符的情况下，不要在括号前换行<br>    sb.append(“zi”).append(“xin”)…append<br>    (“huang”);<br>    //参数很多的方法调用可能超过 120 个字符，不要在逗号前换行<br>    method(args1, args2, args3, …<br>    , argsX);</p><h2 id="【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。"><a href="#【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。" class="headerlink" title="【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。"></a>【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。</h2><p>正例：下例中实参的”a”,后边必须要有一个空格。<br>method(“a”, “b”, “c”);</p><h2 id="【强制】IDE-的-text-file-encoding-设置为-UTF-8-IDE-中文件的换行符使用-Unix-格式，不要使用-windows-格式。"><a href="#【强制】IDE-的-text-file-encoding-设置为-UTF-8-IDE-中文件的换行符使用-Unix-格式，不要使用-windows-格式。" class="headerlink" title="【强制】IDE 的 text file encoding 设置为 UTF-8; IDE 中文件的换行符使用 Unix 格式，不要使用 windows 格式。"></a>【强制】IDE 的 text file encoding 设置为 UTF-8; IDE 中文件的换行符使用 Unix 格式，不要使用 windows 格式。</h2><h2 id="【推荐】没有必要增加若干空格来使某一行的字符与上一行的相应字符对齐。"><a href="#【推荐】没有必要增加若干空格来使某一行的字符与上一行的相应字符对齐。" class="headerlink" title="【推荐】没有必要增加若干空格来使某一行的字符与上一行的相应字符对齐。"></a>【推荐】没有必要增加若干空格来使某一行的字符与上一行的相应字符对齐。</h2><p>正例：<br>    int a = 3;<br>    long b = 4L;<br>    float c = 5F;<br>    StringBuffer sb = new StringBuffer();<br>说明：增加 sb 这个变量，如果需要对齐，则给 a、b、c 都要增加几个空格，在变量比较多的<br>情况下，是一种累赘的事情。</p><h2 id="【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义"><a href="#【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义" class="headerlink" title="【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义"></a>【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义</h2><p>之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。<br>说明：没有必要插入多行空格进行隔开。</p><h1 id="OOP-规约"><a href="#OOP-规约" class="headerlink" title="OOP 规约"></a>OOP 规约</h1><h2 id="【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。"><a href="#【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。" class="headerlink" title="【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。"></a>【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。</h2><h2 id="【强制】所有的覆写方法，必须加-Override-注解。"><a href="#【强制】所有的覆写方法，必须加-Override-注解。" class="headerlink" title="【强制】所有的覆写方法，必须加@Override 注解。"></a>【强制】所有的覆写方法，必须加@Override 注解。</h2><p>反例：getObject()与 get0bject()的问题。一个是字母的 O，一个是数字的 0，加@Override<br>可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错。</p><h2 id="【强制】相同参数类型，相同业务含义，才可以使用-Java-的可变参数，避免使用-Object。"><a href="#【强制】相同参数类型，相同业务含义，才可以使用-Java-的可变参数，避免使用-Object。" class="headerlink" title="【强制】相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object。"></a>【强制】相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object。</h2><p>说明：可变参数必须放置在参数列表的最后。（提倡同学们尽量不用可变参数编程）<br>正例：public User getUsers(String type, Integer… ids)</p><h2 id="【强制】对外暴露的接口签名，原则上不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加-Deprecated-注解，并清晰地说明采用的新接口或者新服务是什么。"><a href="#【强制】对外暴露的接口签名，原则上不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加-Deprecated-注解，并清晰地说明采用的新接口或者新服务是什么。" class="headerlink" title="【强制】对外暴露的接口签名，原则上不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加@Deprecated 注解，并清晰地说明采用的新接口或者新服务是什么。"></a>【强制】对外暴露的接口签名，原则上不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加@Deprecated 注解，并清晰地说明采用的新接口或者新服务是什么。</h2><h2 id="【强制】不能使用过时的类或方法。"><a href="#【强制】不能使用过时的类或方法。" class="headerlink" title="【强制】不能使用过时的类或方法。"></a>【强制】不能使用过时的类或方法。</h2><p>说明：java.net.URLDecoder 中的方法 decode(String encodeStr) 这个方法已经过时，应该使用双参数 decode(String source, String encode)。接口提供方既然明确是过时接口，<br>那么有义务同时ᨀ供新的接口；作为调用方来说，有义务去考证过时方法的新实现是什么。</p><h2 id="【强制】Object-的-equals-方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。"><a href="#【强制】Object-的-equals-方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。" class="headerlink" title="【强制】Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。"></a>【强制】Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。</h2><p>正例： “test”.equals(object);<br>反例： object.equals(“test”);<br>说明：推荐使用 java.util.Objects#equals （JDK7 引入的工具类）</p><h2 id="【强制】所有的相同类型的包装类对象之间值的比较，全部使用-equals-方法比较。"><a href="#【强制】所有的相同类型的包装类对象之间值的比较，全部使用-equals-方法比较。" class="headerlink" title="【强制】所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较。"></a>【强制】所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较。</h2><p><strong><em>说明：对于 Integer var=?在-128 至 127 之间的赋值，Integer 对象是在IntegerCache.cache 产生，会复用已有对象，这个区间内的 Integer 值可以直接使用==进行<br>判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，<br>推荐使用 equals 方法进行判断。</em></strong></p><h2 id="【强制】关于基本数据类型与包装数据类型的使用标准如下："><a href="#【强制】关于基本数据类型与包装数据类型的使用标准如下：" class="headerlink" title="【强制】关于基本数据类型与包装数据类型的使用标准如下："></a>【强制】关于基本数据类型与包装数据类型的使用标准如下：</h2><p>1） 所有的 POJO 类属性必须使用包装数据类型。<br>2） RPC 方法的返回值和参数必须使用包装数据类型。<br>3） 所有的局部变量【推荐】使用基本数据类型。<br>说明：POJO 类属性没有初值是ᨀ醒使用者在需要使用时，必须自己显式地进行赋值，任何<br>NPE 问题，或者入库检查，都由使用者来保证。<br>正例：数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。<br>反例：比如显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 RPC 服务，调用<br>不成功时，返回的是默认值，页面显示：0%，这是不合理的，应该显示成中划线-。所以包装<br>数据类型的 null 值，能够表示额外的信息，如：远程调用失败，异常退出。</p><h2 id="【强制】定义-DO-DTO-VO-等-POJO-类时，不要设定任何属性默认值。"><a href="#【强制】定义-DO-DTO-VO-等-POJO-类时，不要设定任何属性默认值。" class="headerlink" title="【强制】定义 DO/DTO/VO 等 POJO 类时，不要设定任何属性默认值。"></a>【强制】定义 DO/DTO/VO 等 POJO 类时，不要设定任何属性默认值。</h2><p>反例：POJO 类的 gmtCreate 默认值为 new Date();但是这个属性在数据ᨀ取时并没有置入具<br>体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。</p><h2 id="【强制】序列化类新增属性时，请不要修改-serialVersionUID-字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改-serialVersionUID-值。"><a href="#【强制】序列化类新增属性时，请不要修改-serialVersionUID-字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改-serialVersionUID-值。" class="headerlink" title="【强制】序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值。"></a>【强制】序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值。</h2><p>说明：注意 serialVersionUID 不一致会抛出序列化运行时异常。</p><h2 id="【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在-init-方法中。"><a href="#【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在-init-方法中。" class="headerlink" title="【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。"></a>【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。</h2><h2 id="【强制】POJO-类必须写-toString-方法。"><a href="#【强制】POJO-类必须写-toString-方法。" class="headerlink" title="【强制】POJO 类必须写 toString 方法。"></a>【强制】POJO 类必须写 toString 方法。</h2><p>使用 IDE 的中工具：source&gt; generate toString时，如果继承了另一个 POJO 类，注意在前面加一下 super.toString。<br>说明：在方法执行抛出异常时，可以直接调用 POJO 的 toString()方法打印其属性值，便于排<br>查问题。</p><h2 id="【推荐】使用索引访问用-String-的-split-方法得到的数组时，需做最后一个分隔符后有无-内容的检查，否则会有抛-IndexOutOfBoundsException-的风险。"><a href="#【推荐】使用索引访问用-String-的-split-方法得到的数组时，需做最后一个分隔符后有无-内容的检查，否则会有抛-IndexOutOfBoundsException-的风险。" class="headerlink" title="【推荐】使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无 内容的检查，否则会有抛 IndexOutOfBoundsException 的风险。"></a>【推荐】使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无 内容的检查，否则会有抛 IndexOutOfBoundsException 的风险。</h2><p>说明：<br>    String str = “a,b,c,,”;<br>    String[] ary = str.split(“,”);<br>    //预期大于 3，结果是 3<br>    System.out.println(ary.length);</p><h2 id="【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读。"><a href="#【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读。" class="headerlink" title="【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读。"></a>【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读。</h2><h2 id="【推荐】-类内方法定义顺序依次是：公有方法或保护方法-gt-私有方法-gt-getter-setter"><a href="#【推荐】-类内方法定义顺序依次是：公有方法或保护方法-gt-私有方法-gt-getter-setter" class="headerlink" title="【推荐】 类内方法定义顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter/setter"></a>【推荐】 类内方法定义顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter/setter</h2><p>方法。<br>说明：公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类<br>关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个<br>黑盒实现；因为方法信息价值较低，所有 Service 和 DAO 的 getter/setter 方法放在类体最<br>后。</p><h2 id="【推荐】setter-方法中，参数名称与类成员变量名称一致，this-成员名-参数名。在getter-setter-方法中，尽量不要增加业务逻辑，增加排查问题的难度。"><a href="#【推荐】setter-方法中，参数名称与类成员变量名称一致，this-成员名-参数名。在getter-setter-方法中，尽量不要增加业务逻辑，增加排查问题的难度。" class="headerlink" title="【推荐】setter 方法中，参数名称与类成员变量名称一致，this.成员名=参数名。在getter/setter 方法中，尽量不要增加业务逻辑，增加排查问题的难度。"></a>【推荐】setter 方法中，参数名称与类成员变量名称一致，this.成员名=参数名。在getter/setter 方法中，尽量不要增加业务逻辑，增加排查问题的难度。</h2><p>反例：<br>  public Integer getData(){<br>    if(true) {<br>    return data + 100;<br>    } else {<br>    return data - 100;<br>    }<br>  }</p><h2 id="【推荐】循环体内，字符串的联接方式，使用-StringBuilder-的-append-方法进行扩展。"><a href="#【推荐】循环体内，字符串的联接方式，使用-StringBuilder-的-append-方法进行扩展。" class="headerlink" title="【推荐】循环体内，字符串的联接方式，使用 StringBuilder 的 append 方法进行扩展。"></a>【推荐】循环体内，字符串的联接方式，使用 StringBuilder 的 append 方法进行扩展。</h2><p>反例：<br>  String str = “start”;<br>    for(int i=0; i&lt;100; i++){<br>      str = str + “hello”;<br>  }<br>说明：反编译出的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象，然后进行<br>append 操作，最后通过 toString 方法返回 String 对象，造成内存资源浪费。</p><h2 id="【推荐】final-可提高程序响应效率，声明成-final-的情况："><a href="#【推荐】final-可提高程序响应效率，声明成-final-的情况：" class="headerlink" title="【推荐】final 可提高程序响应效率，声明成 final 的情况："></a>【推荐】final 可提高程序响应效率，声明成 final 的情况：</h2><p>1） 不需要重新赋值的变量，包括类属性、局部变量。<br>2） 对象参数前加 final，表示不允许修改引用的指向。<br>3） 类方法确定不允许被重写。</p><h2 id="【推荐】慎用-Object-的-clone-方法来拷贝对象。"><a href="#【推荐】慎用-Object-的-clone-方法来拷贝对象。" class="headerlink" title="【推荐】慎用 Object 的 clone 方法来拷贝对象。"></a>【推荐】慎用 Object 的 clone 方法来拷贝对象。</h2><p>说明：对象的 clone 方法默认是浅拷贝，若想实现深拷贝需要重写 clone 方法实现属性对象的拷贝。</p><h2 id="【推荐】类成员与方法访问控制从严："><a href="#【推荐】类成员与方法访问控制从严：" class="headerlink" title="【推荐】类成员与方法访问控制从严："></a>【推荐】类成员与方法访问控制从严：</h2><p>1） 如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 private。<br>2） 工具类不允许有 public 或 default 构造方法。<br>3） 类非 static 成员变量并且与子类共享，必须是 protected。<br>4） 类非 static 成员变量并且仅在本类使用，必须是 private。<br>5） 类 static 成员变量如果仅在本类使用，必须是 private。<br>6） 若是 static 成员变量，必须考虑是否为 final。<br>7） 类成员方法只供类内部调用，必须是 private。<br>8） 类成员方法只对继承类公开，那么限制为 protected。<br>说明：任何类、方法、参数、变量，严控访问范围。过宽泛的访问范围，不利于模块解耦。思考：如果是一个 private 的方法，想删除就删除，可是一个 public 的 Service 方法，或者一<br>个 public 的成员变量，删除一下，不得手心冒点汗吗？变量像自己的小孩，尽量在自己的视线内，变量作用域太大，如果无限制的到处跑，那么你会担心的。</p><h1 id="集合处理"><a href="#集合处理" class="headerlink" title="集合处理"></a>集合处理</h1><h2 id="【强制】关于-hashCode-和-equals-的处理，遵循如下规则："><a href="#【强制】关于-hashCode-和-equals-的处理，遵循如下规则：" class="headerlink" title="【强制】关于 hashCode 和 equals 的处理，遵循如下规则："></a>【强制】关于 hashCode 和 equals 的处理，遵循如下规则：</h2><p>1） 只要重写 equals，就必须重写 hashCode。<br>2） 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的<br>对象必须重写这两个方法。<br>3） 如果自定义对象做为 Map 的键，那么必须重写 hashCode 和 equals。<br>正例：String 重写了 hashCode 和 equals 方法，所以我们可以非常愉快地使用 String 对象<br>作为 key 来使用。</p><h2 id="【强制】ArrayList的subList结果不可强转成ArrayList，否则会抛出ClassCastException"><a href="#【强制】ArrayList的subList结果不可强转成ArrayList，否则会抛出ClassCastException" class="headerlink" title="【强制】ArrayList的subList结果不可强转成ArrayList，否则会抛出ClassCastException"></a>【强制】ArrayList的subList结果不可强转成ArrayList，否则会抛出ClassCastException</h2><p>异常：java.util.RandomAccessSubList cannot be cast to java.util.ArrayList ;<br>说明：subList 返回的是 ArrayList 的内部类 SubList，并不是 ArrayList ，而是<br>ArrayList 的一个视图，对于 SubList 子列表的所有操作最终会反映到原列表上。</p><h2 id="【强制】-在-subList-场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增"><a href="#【强制】-在-subList-场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增" class="headerlink" title="【强制】 在 subList 场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增"></a>【强制】 在 subList 场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增</h2><p>加、删除均产生 ConcurrentModificationException 异常。<br>##【强制】使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全<br>一样的数组，大小就是 list.size()。<br>反例：直接使用 toArray 无参方法存在问题，此方法返回值只能是 Object[]类，若强转其它<br>类型数组将出现 ClassCastException 错误。<br>正例：<br>    List<string> list = new ArrayList<string>(2);<br>    list.add(“guan”);<br>    list.add(“bao”);<br>    String[] array = new String[list.size()];<br>    array = list.toArray(array);<br>说明：使用 toArray 带参方法，入参分配的数组空间不够大时，toArray 方法内部将重新分配<br>内存空间，并返回新数组地址；如果数组元素大于实际所需，下标为[ list.size() ]的数组<br>元素将被置为 null，其它数组元素保持原值，因此最好将方法入参数组大小定义与集合元素<br>个数一致。</string></string></p><h2 id="【强制】使用工具类-Arrays-asList-把数组转换成集合时，不能使用其修改集合相关的方法，它的-add-remove-clear-方法会抛出-UnsupportedOperationException-异常。"><a href="#【强制】使用工具类-Arrays-asList-把数组转换成集合时，不能使用其修改集合相关的方法，它的-add-remove-clear-方法会抛出-UnsupportedOperationException-异常。" class="headerlink" title="【强制】使用工具类 Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。"></a>【强制】使用工具类 Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。</h2><p>说明：asList 的返回对象是一个 Arrays 内部类，并没有实现集合的修改方法。Arrays.asList<br>体现的是适配器模式，只是转换接口，后台的数据仍是数组。<br>    String[] str = new String[] { “a”, “b” };<br>    List list = Arrays.asList(str);<br>第一种情况：list.add(“c”); 运行时异常。<br>第二种情况：str[0]= “gujin”; 那么 list.get(0)也会随之修改。</p><h2 id="【强制】泛型通配符-lt-extends-T-gt-来接收返回的数据，此写法的泛型集合不能使用-add-方法。"><a href="#【强制】泛型通配符-lt-extends-T-gt-来接收返回的数据，此写法的泛型集合不能使用-add-方法。" class="headerlink" title="【强制】泛型通配符&lt;? extends T&gt;来接收返回的数据，此写法的泛型集合不能使用 add 方法。"></a>【强制】泛型通配符&lt;? extends T&gt;来接收返回的数据，此写法的泛型集合不能使用 add 方法。</h2><p>说明：苹果装箱后返回一个&lt;? extends Fruits&gt;对象，此对象就不能往里加任何水果，包括苹果。</p><h2 id="【强制】不要在-foreach-循环里进行元素的-remove-add-操作。remove-元素请使用-Iterator"><a href="#【强制】不要在-foreach-循环里进行元素的-remove-add-操作。remove-元素请使用-Iterator" class="headerlink" title="【强制】不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator"></a>【强制】不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator</h2><p>方式，如果并发操作，需要对 Iterator 对象加锁。<br>反例：<br>    List<string> a = new ArrayList<string>();<br>        a.add(“1”);<br>        a.add(“2”);<br>        for (String temp : a) {<br>        if(“1”.equals(temp)){<br>        a.remove(temp);<br>        }<br>    }<br>说明：以上代码的执行结果肯定会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的<br>结果吗？<br>正例：<br>    Iterator<string> it = a.iterator();<br>        while(it.hasNext()){<br>        String temp = it.next();<br>        if(删除元素的条件){<br>        it.remove();<br>        }<br>    }<br>##【强制】在 JDK7 版本以上，Comparator 要满足自反性，传递性，对称性，不然 Arrays.sort，Collections.sort 会报 IllegalArgumentException 异常。<br>说明：<br>1） 自反性：x，y 的比较结果和 y，x 的比较结果相反。<br>2） 传递性：x&gt;y,y&gt;z,则 x&gt;z。 3） 对称性：x=y,则 x,z 比较结果和 y，z 比较结果相同。<br>反例：下例中没有处理相等的情况，实际使用中可能会出现异常：<br>    new Comparator<student>() {<br>        @Override<br>        public int compare(Student o1, Student o2) {<br>        return o1.getId() &gt; o2.getId() ? 1 : -1;<br>        }<br>    }</student></string></string></string></p><h2 id="【推荐】集合初始化时，尽量指定集合初始值大小。"><a href="#【推荐】集合初始化时，尽量指定集合初始值大小。" class="headerlink" title="【推荐】集合初始化时，尽量指定集合初始值大小。"></a>【推荐】集合初始化时，尽量指定集合初始值大小。</h2><p>说明：ArrayList 尽量使用 ArrayList(int initialCapacity) 初始化。</p><h2 id="【推荐】使用-entrySet-遍历-Map-类集合-KV，而不是-keySet-方式进行遍历。"><a href="#【推荐】使用-entrySet-遍历-Map-类集合-KV，而不是-keySet-方式进行遍历。" class="headerlink" title="【推荐】使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。"></a>【推荐】使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。</h2><p>说明：keySet 其实是遍历了 2 次，一次是转为 Iterator 对象，另一次是从 hashMap 中取出<br>key 所对应的 value。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中，效<br>率更高。如果是 JDK8，使用 Map.foreach 方法。<br>正例：values()返回的是 V 值集合，是一个 list 集合对象；keySet()返回的是 K 值集合，是<br>一个 Set 集合对象；entrySet()返回的是 K-V 值组合集合。<br>##【推荐】高度注意 Map 类集合 K/V 能不能存储 null 值的情况，如下表格：<br>集合类     Key           Value        Super      说明<br>Hashtable 不允许为 null 不允许为 null Dictionary 线程安全<br>ConcurrentHashMap 不允许为 null 不允许为 null AbstractMap 分段锁技术<br>TreeMap 不允许为 null 允许为 null AbstractMap 线程不安全<br>HashMap 允许为 null 允许为 null AbstractMap 线程不安全<br>反例： 由于 HashMap 的干扰，很多人认为 ConcurrentHashMap 是可以置入 null 值，注意存储<br>null 值时会抛出 NPE 异常。</p><h2 id="【参考】合理利用好集合的有序性-sort-和稳定性-order-，避免集合的无序性-unsort-和不稳定性-unorder-带来的负面影响。"><a href="#【参考】合理利用好集合的有序性-sort-和稳定性-order-，避免集合的无序性-unsort-和不稳定性-unorder-带来的负面影响。" class="headerlink" title="【参考】合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳定性(unorder)带来的负面影响。"></a>【参考】合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳定性(unorder)带来的负面影响。</h2><p>说明：稳定性指集合每次遍历的元素次序是一定的。有序性是指遍历的结果是按某种比较规则<br>依次排列的。如：ArrayList 是 order/unsort；HashMap 是 unorder/unsort；TreeSet 是<br>order/sort。</p><h2 id="【参考】利用-Set-元素唯一的特性，可以快速对一个集合进行去重操作，避免使用-List-的contains-方法进行遍历、对比、去重操作。"><a href="#【参考】利用-Set-元素唯一的特性，可以快速对一个集合进行去重操作，避免使用-List-的contains-方法进行遍历、对比、去重操作。" class="headerlink" title="【参考】利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的contains 方法进行遍历、对比、去重操作。"></a>【参考】利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的contains 方法进行遍历、对比、去重操作。</h2><h1 id="并发处理"><a href="#并发处理" class="headerlink" title="并发处理"></a>并发处理</h1><h2 id="【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。"><a href="#【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。" class="headerlink" title="【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。"></a>【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。</h2><p>说明：资源驱动类、工具类、单例工厂类都需要注意。</p><h2 id="【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。"><a href="#【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。" class="headerlink" title="【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。"></a>【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。</h2><p>正例：<br>    public class TimerTaskThread extends Thread {<br>        public TimerTaskThread(){<br>        super.setName(“TimerTaskThread”); …<br>    }</p><h2 id="【强制】线程资源必须通过线程池ᨀ供，不允许在应用中自行显式创建线程。"><a href="#【强制】线程资源必须通过线程池ᨀ供，不允许在应用中自行显式创建线程。" class="headerlink" title="【强制】线程资源必须通过线程池ᨀ供，不允许在应用中自行显式创建线程。"></a>【强制】线程资源必须通过线程池ᨀ供，不允许在应用中自行显式创建线程。</h2><p>说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资<br>源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者<br>“过度切换”的问题。</p><h2 id="【强制】线程池不允许使用-Executors-去创建，而是通过-ThreadPoolExecutor-的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。"><a href="#【强制】线程池不允许使用-Executors-去创建，而是通过-ThreadPoolExecutor-的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。" class="headerlink" title="【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。"></a>【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</h2><p>说明：Executors 返回的线程池对象的弊端如下： 1）FixedThreadPool 和 SingleThreadPool:<br>允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。 2）CachedThreadPool 和 ScheduledThreadPool:<br>允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</p><h2 id="【强制】SimpleDateFormat-是线程不安全的类，一般不要定义为-static-变量，如果定义为static，必须加锁，或者使用-DateUtils-工具类。"><a href="#【强制】SimpleDateFormat-是线程不安全的类，一般不要定义为-static-变量，如果定义为static，必须加锁，或者使用-DateUtils-工具类。" class="headerlink" title="【强制】SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为static，必须加锁，或者使用 DateUtils 工具类。"></a>【强制】SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为static，必须加锁，或者使用 DateUtils 工具类。</h2><p>正例：注意线程安全，使用 DateUtils。亦推荐如下处理：<br>    private static final ThreadLocal<dateformat> df = new ThreadLocal<dateformat>() {<br>        @Override<br>        protected DateFormat initialValue() {<br>        return new SimpleDateFormat(“yyyy-MM-dd”);<br>        }<br>    };<br>说明：如果是 JDK8 的应用，可以使用 Instant 代替 Date，LocalDateTime 代替 Calendar，<br>DateTimeFormatter代替Simpledateformatter，官方给出的解释：simple beautiful strong<br>immutable thread-safe。</dateformat></dateformat></p><h2 id="【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。"><a href="#【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。" class="headerlink" title="【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。"></a>【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。</h2><h2 id="【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。"><a href="#【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。" class="headerlink" title="【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。"></a>【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。</h2><p>说明：线程一需要对表 A、B、C 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序<br>也必须是 A、B、C，否则可能出现死锁。</p><h2 id="【强制】并发修改同一记录时，避免更新丢失，要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用-version-作为更新依据。"><a href="#【强制】并发修改同一记录时，避免更新丢失，要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用-version-作为更新依据。" class="headerlink" title="【强制】并发修改同一记录时，避免更新丢失，要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。"></a>【强制】并发修改同一记录时，避免更新丢失，要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。</h2><p>说明：如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次<br>数不得小于 3 次。</p><h2 id="【强制】多线程并行处理定时任务时，Timer-运行多个-TimeTask-时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用-ScheduledExecutorService-则没有这个问题。"><a href="#【强制】多线程并行处理定时任务时，Timer-运行多个-TimeTask-时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用-ScheduledExecutorService-则没有这个问题。" class="headerlink" title="【强制】多线程并行处理定时任务时，Timer 运行多个 TimeTask 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题。"></a>【强制】多线程并行处理定时任务时，Timer 运行多个 TimeTask 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题。</h2><h2 id="【推荐】使用-CountDownLatch-进行异步转同步操作，每个线程退出前必须调用-countDown方法，线程执行代码注意-catch-异常，确保-countDown-方法可以执行，避免主线程无法执行至-countDown-方法，直到超时才返回结果。"><a href="#【推荐】使用-CountDownLatch-进行异步转同步操作，每个线程退出前必须调用-countDown方法，线程执行代码注意-catch-异常，确保-countDown-方法可以执行，避免主线程无法执行至-countDown-方法，直到超时才返回结果。" class="headerlink" title="【推荐】使用 CountDownLatch 进行异步转同步操作，每个线程退出前必须调用 countDown方法，线程执行代码注意 catch 异常，确保 countDown 方法可以执行，避免主线程无法执行至 countDown 方法，直到超时才返回结果。"></a>【推荐】使用 CountDownLatch 进行异步转同步操作，每个线程退出前必须调用 countDown方法，线程执行代码注意 catch 异常，确保 countDown 方法可以执行，避免主线程无法执行至 countDown 方法，直到超时才返回结果。</h2><p>说明：注意，子线程抛出异常堆栈，不能在主线程 try-catch 到。</p><h2 id="【推荐】避免-Random-实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed-导致的性能下降。"><a href="#【推荐】避免-Random-实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed-导致的性能下降。" class="headerlink" title="【推荐】避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed 导致的性能下降。"></a>【推荐】避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed 导致的性能下降。</h2><p>说明：Random 实例包括 java.util.Random 的实例或者 Math.random()实例。<br>正例：在 JDK7 之后，可以直接使用 API ThreadLocalRandom，在 JDK7 之前，可以做到每个<br>线程一个实例。</p><h2 id="【推荐】通过双重检查锁（double-checked-locking）（在并发场景）实现延迟初始化的优化问题隐患-可参考-The-“Double-Checked-Locking-is-Broken”-Declaration-推荐问题解决方案中较为简单一种（适用于-JDK5-及以上版本），将目标属性声明为-volatile-型。"><a href="#【推荐】通过双重检查锁（double-checked-locking）（在并发场景）实现延迟初始化的优化问题隐患-可参考-The-“Double-Checked-Locking-is-Broken”-Declaration-推荐问题解决方案中较为简单一种（适用于-JDK5-及以上版本），将目标属性声明为-volatile-型。" class="headerlink" title="【推荐】通过双重检查锁（double-checked locking）（在并发场景）实现延迟初始化的优化问题隐患(可参考 The “Double-Checked Locking is Broken” Declaration),推荐问题解决方案中较为简单一种（适用于 JDK5 及以上版本），将目标属性声明为 volatile 型。"></a>【推荐】通过双重检查锁（double-checked locking）（在并发场景）实现延迟初始化的优化问题隐患(可参考 The “Double-Checked Locking is Broken” Declaration),推荐问题解决方案中较为简单一种（适用于 JDK5 及以上版本），将目标属性声明为 volatile 型。</h2><p>反例：<br>    class Foo {<br>        private Helper helper = null;<br>        public Helper getHelper() {<br>            if (helper == null) synchronized(this) {<br>            if (helper == null)<br>            helper = new Helper();<br>            }<br>            return helper;<br>        }<br>        // other functions and members…<br>    }</p><h2 id="【参考】volatile-解决多线程内存不可见问题。"><a href="#【参考】volatile-解决多线程内存不可见问题。" class="headerlink" title="【参考】volatile 解决多线程内存不可见问题。"></a>【参考】volatile 解决多线程内存不可见问题。</h2><p>对于一写多读，是可以解决变量同步问题，<br>但是如果多写，同样无法解决线程安全问题。如果是 count++操作，使用如下类实现：<br>AtomicInteger count = new AtomicInteger(); count.addAndGet(1); 如果是 JDK8，推<br>荐使用 LongAdder 对象，比 AtomicLong 性能更好（减少乐观锁的重试次数）。</p><h2 id="【参考】-HashMap-在容量不够进行-resize-时由于高并发可能出现死链，导致-CPU-飙升，在开发过程中注意规避此风险。"><a href="#【参考】-HashMap-在容量不够进行-resize-时由于高并发可能出现死链，导致-CPU-飙升，在开发过程中注意规避此风险。" class="headerlink" title="【参考】 HashMap 在容量不够进行 resize 时由于高并发可能出现死链，导致 CPU 飙升，在开发过程中注意规避此风险。"></a>【参考】 HashMap 在容量不够进行 resize 时由于高并发可能出现死链，导致 CPU 飙升，在开发过程中注意规避此风险。</h2><h2 id="【参考】ThreadLocal-无法解决共享对象的更新问题，ThreadLocal-对象建议使用-static修饰。"><a href="#【参考】ThreadLocal-无法解决共享对象的更新问题，ThreadLocal-对象建议使用-static修饰。" class="headerlink" title="【参考】ThreadLocal 无法解决共享对象的更新问题，ThreadLocal 对象建议使用 static修饰。"></a>【参考】ThreadLocal 无法解决共享对象的更新问题，ThreadLocal 对象建议使用 static修饰。</h2><p>这个变量是针对一个线程内所有操作共有的，所以设置为静态变量，所有此类实例共享<br>此静态变量 ，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只<br>要是这个线程内定义的)都可以操控这个变量。</p><h1 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h1><h2 id="【强制】在一个-switch-块内，每个-case-要么通过-break-return-等来终止，要么注释说明程序将继续执行到哪一个-case-为止；"><a href="#【强制】在一个-switch-块内，每个-case-要么通过-break-return-等来终止，要么注释说明程序将继续执行到哪一个-case-为止；" class="headerlink" title="【强制】在一个 switch 块内，每个 case 要么通过 break/return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止；"></a>【强制】在一个 switch 块内，每个 case 要么通过 break/return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止；</h2><p>在一个 switch 块内，都必须包含一个 default 语句并且<br>放在最后，即使它什么代码也没有。</p><h2 id="【强制】在-if-else-for-while-do-语句中必须使用大括号，即使只有一行代码，"><a href="#【强制】在-if-else-for-while-do-语句中必须使用大括号，即使只有一行代码，" class="headerlink" title="【强制】在 if/else/for/while/do 语句中必须使用大括号，即使只有一行代码，"></a>【强制】在 if/else/for/while/do 语句中必须使用大括号，即使只有一行代码，</h2><p>避免使用下面的形式：if (condition) statements;</p><h2 id="【推荐】推荐尽量少用-else，-if-else-的方式可以改写成："><a href="#【推荐】推荐尽量少用-else，-if-else-的方式可以改写成：" class="headerlink" title="【推荐】推荐尽量少用 else， if-else 的方式可以改写成："></a>【推荐】推荐尽量少用 else， if-else 的方式可以改写成：</h2><pre><code>if(condition){    ...    return obj;}// 接着写 else 的业务逻辑代码;</code></pre><p>说明：如果非得使用 if()…else if()…else…方式表达逻辑，<strong><em>【强制】请勿超过 3 层，<br>超过请使用状态设计模式。</em></strong><br>正例：逻辑上超过 3 层的 if-else 代码可以使用卫语句，或者状态模式来实现。</p><h2 id="【推荐】除常用方法（如-getXxx-isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。"><a href="#【推荐】除常用方法（如-getXxx-isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。" class="headerlink" title="【推荐】除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。"></a>【推荐】除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。</h2><p>说明：很多 if 语句内的逻辑相当复杂，阅读者需要分析条件表达式的最终结果，才能明确什么<br>样的条件执行什么样的语句，那么，如果阅读者分析逻辑表达式错误呢？<br>正例：<br>    //伪代码如下<br>    boolean existed = (file.open(fileName, “w”) != null) &amp;&amp; (…) || (…);<br>        if (existed) {<br>        …<br>    }<br>反例：<br>    if ((file.open(fileName, “w”) != null) &amp;&amp; (…) || (…)) {<br>    …<br>    }</p><h2 id="【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理"><a href="#【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理" class="headerlink" title="【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理"></a>【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理</h2><p>如定义对象、变量、获取数据库连接，进行不必要的 try-catch 操作（这个 try-catch 是否可以移至循环体外）。</p><h2 id="【推荐】接口入参保护，这种场景常见的是用于做批量操作的接口。"><a href="#【推荐】接口入参保护，这种场景常见的是用于做批量操作的接口。" class="headerlink" title="【推荐】接口入参保护，这种场景常见的是用于做批量操作的接口。"></a>【推荐】接口入参保护，这种场景常见的是用于做批量操作的接口。</h2><h2 id="【参考】方法中需要进行参数校验的场景："><a href="#【参考】方法中需要进行参数校验的场景：" class="headerlink" title="【参考】方法中需要进行参数校验的场景："></a>【参考】方法中需要进行参数校验的场景：</h2><p>1） 调用频次低的方法。<br>2） 执行时间开销很大的方法，参数校验时间几乎可以忽略不计，但如果因为参数错误导致<br>中间执行回退，或者错误，那得不偿失。<br>3） 需要极高稳定性和可用性的方法。<br>4） 对外提供的开放接口，不管是 RPC/API/HTTP 接口。<br>5） 敏感权限入口。</p><h2 id="【参考】方法中不需要参数校验的场景："><a href="#【参考】方法中不需要参数校验的场景：" class="headerlink" title="【参考】方法中不需要参数校验的场景："></a>【参考】方法中不需要参数校验的场景：</h2><p>1） 极有可能被循环调用的方法，不建议对参数进行校验。但在方法说明里必须注明外部参<br>数检查。<br>2） 底层的方法调用频度都比较高，一般不校验。毕竟是像纯净水过滤的最后一道，参数错<br>误不太可能到底层才会暴露问题。一般 DAO 层与 Service 层都在同一个应用中，部署在同一<br>台服务器中，所以 DAO 的参数校验，可以省略。<br>3） 被声明成 private 只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参<br>数已经做过检查或者肯定不会有问题，此时可以不校验参数。</p><h1 id="注释规约"><a href="#注释规约" class="headerlink" title="注释规约"></a>注释规约</h1><h2 id="【强制】类、类属性、类方法的注释必须使用-Javadoc-规范，使用-内容-格式，不得使用-xxx-方式。"><a href="#【强制】类、类属性、类方法的注释必须使用-Javadoc-规范，使用-内容-格式，不得使用-xxx-方式。" class="headerlink" title="【强制】类、类属性、类方法的注释必须使用 Javadoc 规范，使用 /** 内容 * / 格式，不得使用//xxx 方式。"></a>【强制】类、类属性、类方法的注释必须使用 Javadoc 规范，使用 /** 内容 * / 格式，不得使用//xxx 方式。</h2><p>说明：在 IDE 编辑窗口中，Javadoc 方式会提示相关注释，生成 Javadoc 可以正确输出相应注<br>释；在 IDE 中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高<br>阅读效率。</p><h2 id="【强制】所有的抽象方法（包括接口中的方法）必须要用-Javadoc-注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。"><a href="#【强制】所有的抽象方法（包括接口中的方法）必须要用-Javadoc-注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。" class="headerlink" title="【强制】所有的抽象方法（包括接口中的方法）必须要用 Javadoc 注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。"></a>【强制】所有的抽象方法（包括接口中的方法）必须要用 Javadoc 注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。</h2><p>说明：对子类的实现要求，或者调用注意事项，请一并说明。</p><h2 id="【强制】所有的类都必须添加创建者信息。"><a href="#【强制】所有的类都必须添加创建者信息。" class="headerlink" title="【强制】所有的类都必须添加创建者信息。"></a>【强制】所有的类都必须添加创建者信息。</h2><h2 id="【强制】方法内部单行注释，在被注释语句上方另起一行，使用-注释。方法内部多行注释"><a href="#【强制】方法内部单行注释，在被注释语句上方另起一行，使用-注释。方法内部多行注释" class="headerlink" title="【强制】方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释"></a>【强制】方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释</h2><p>使用/* */注释，注意与代码对齐。</p><h2 id="【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。"><a href="#【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。" class="headerlink" title="【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。"></a>【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。</h2><h2 id="【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。"><a href="#【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。" class="headerlink" title="【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。"></a>【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。</h2><p>反例：“TCP 连接超时”解释成“传输控制协议连接超时”，理解反而费脑筋。</p><h2 id="【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。"><a href="#【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。" class="headerlink" title="【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。"></a>【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。</h2><p>说明：代码与注释更新不同步，就像路网与导航软件更新不同步一样，如果导航软件严重滞后，<br>就失去了导航的意义。</p><h2 id="【参考】注释掉的代码尽量要配合说明，而不是简单的注释掉。"><a href="#【参考】注释掉的代码尽量要配合说明，而不是简单的注释掉。" class="headerlink" title="【参考】注释掉的代码尽量要配合说明，而不是简单的注释掉。"></a>【参考】注释掉的代码尽量要配合说明，而不是简单的注释掉。</h2><p>说明：代码被注释掉有两种可能性：1）后续会恢复此段代码逻辑。2）永久不用。前者如果没<br>有备注信息，难以知晓注释动机。后者建议直接删掉（代码仓库保存了历史代码）。</p><h2 id="【参考】对于注释的要求："><a href="#【参考】对于注释的要求：" class="headerlink" title="【参考】对于注释的要求："></a>【参考】对于注释的要求：</h2><p>第一、能够准确反应设计思想和代码逻辑；<br>第二、能够阐述业务含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同<br>天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看<br>的，使其能够快速接替自己的工作。</p><h2 id="【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。"><a href="#【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。" class="headerlink" title="【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。"></a>【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。</h2><p>（这条对我来说要注意，因为我总倾向于把注释写的很详细，有时出现过度注释）<br>避免出现注释的一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。<br>反例：<br>    // put elephant into fridge<br>    put(elephant, fridge);</p><p>方法名 put，加上两个有意义的变量名 elephant 和 fridge，已经说明了这是在干什么，语<br>义清晰的代码不需要额外的注释。</p><h2 id="【参考】特殊注释标记，请注明标记人与标记时间。"><a href="#【参考】特殊注释标记，请注明标记人与标记时间。" class="headerlink" title="【参考】特殊注释标记，请注明标记人与标记时间。"></a>【参考】特殊注释标记，请注明标记人与标记时间。</h2><p>注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。<br>1） 待办事宜（TODO）:（ 标记人，标记时间，[预计处理时间]）<br>表示需要实现，但目前还未实现的功能。这实际上是一个 Javadoc 的标签，目前的 Javadoc<br>还没有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个 Javadoc 标签）。<br>2） 错误，不能工作（FIXME）:（标记人，标记时间，[预计处理时间]）<br>在注释中用 FIXME 标记某代码是错误的，而且不能工作，需要及时纠正的情况。</p><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><h2 id="【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。"><a href="#【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。" class="headerlink" title="【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。"></a>【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。</h2><p>说明：不要在方法体内定义：Pattern pattern = Pattern.compile(规则);</p><h2 id="【强制】velocity-调用-POJO-类的属性时，建议直接使用属性名取值即可，"><a href="#【强制】velocity-调用-POJO-类的属性时，建议直接使用属性名取值即可，" class="headerlink" title="【强制】velocity 调用 POJO 类的属性时，建议直接使用属性名取值即可，"></a>【强制】velocity 调用 POJO 类的属性时，建议直接使用属性名取值即可，</h2><p>模板引擎会自动按规范调用 POJO 的 getXxx()，如果是 boolean 基本数据类型变量（boolean 命名不需要加 is前缀），会自动调用 isXxx()方法。<br>说明：注意如果是 Boolean 包装类对象，优先调用 getXxx()的方法。</p><h2 id="【强制】后台输送给页面的变量必须加-var-——中间的感叹号。"><a href="#【强制】后台输送给页面的变量必须加-var-——中间的感叹号。" class="headerlink" title="【强制】后台输送给页面的变量必须加$!{var}——中间的感叹号。"></a>【强制】后台输送给页面的变量必须加$!{var}——中间的感叹号。</h2><p>说明：如果 var=null 或者不存在，那么${var}会直接显示在页面上。</p><h2 id="【强制】注意-Math-random-这个方法返回是-double-类型，"><a href="#【强制】注意-Math-random-这个方法返回是-double-类型，" class="headerlink" title="【强制】注意 Math.random() 这个方法返回是 double 类型，"></a>【强制】注意 Math.random() 这个方法返回是 double 类型，</h2><p>注意取值的范围 0≤x&lt;1（能够取到零值，注意除零异常），如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后<br>取整，直接使用 Random 对象的 nextInt 或者 nextLong 方法。</p><h2 id="【强制】获取当前毫秒数-System-currentTimeMillis-而不是-new-Date-getTime"><a href="#【强制】获取当前毫秒数-System-currentTimeMillis-而不是-new-Date-getTime" class="headerlink" title="【强制】获取当前毫秒数 System.currentTimeMillis(); 而不是 new Date().getTime();"></a>【强制】获取当前毫秒数 System.currentTimeMillis(); 而不是 new Date().getTime();</h2><p>说明：如果想获取更加精确的纳秒级时间值，用 System.nanoTime()。在 JDK8 中，针对统计时间等场景，推荐使用 Instant 类。</p><h2 id="【推荐】尽量不要在-vm-中加入变量声明、逻辑运算符，更不要在-vm-模板中加入任何复杂的逻辑。"><a href="#【推荐】尽量不要在-vm-中加入变量声明、逻辑运算符，更不要在-vm-模板中加入任何复杂的逻辑。" class="headerlink" title="【推荐】尽量不要在 vm 中加入变量声明、逻辑运算符，更不要在 vm 模板中加入任何复杂的逻辑。"></a>【推荐】尽量不要在 vm 中加入变量声明、逻辑运算符，更不要在 vm 模板中加入任何复杂的逻辑。</h2><h2 id="【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。"><a href="#【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。" class="headerlink" title="【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。"></a>【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。</h2><h2 id="【推荐】对于“明确停止使用的代码和配置”，如方法、变量、类、配置文件、动态配置属性等要坚决从程序中清理出去，避免造成过多垃圾。"><a href="#【推荐】对于“明确停止使用的代码和配置”，如方法、变量、类、配置文件、动态配置属性等要坚决从程序中清理出去，避免造成过多垃圾。" class="headerlink" title="【推荐】对于“明确停止使用的代码和配置”，如方法、变量、类、配置文件、动态配置属性等要坚决从程序中清理出去，避免造成过多垃圾。"></a>【推荐】对于“明确停止使用的代码和配置”，如方法、变量、类、配置文件、动态配置属性等要坚决从程序中清理出去，避免造成过多垃圾。</h2><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://kangroo.gitee.io/ajcg/#/?id=%e5%89%8d%e8%a8%80" target="_blank" rel="noopener">https://kangroo.gitee.io/ajcg/#/?id=%e5%89%8d%e8%a8%80</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常见的开发规范&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Effctive-Java阅读笔记III</title>
    <link href="http://yoursite.com/2019/12/31/Effctive-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0III/"/>
    <id>http://yoursite.com/2019/12/31/Effctive-Java阅读笔记III/</id>
    <published>2019-12-31T07:06:12.000Z</published>
    <updated>2020-01-03T06:44:27.745Z</updated>
    
    <content type="html"><![CDATA[<p>第二章阅读：创建和销毁对象<br>05.依赖注入优于硬连接资源（hardwiring resources）<br>06.避免创建不必要的对象</p><a id="more"></a><h1 id="依赖注入优于硬连接资源（hardwiring-resources）"><a href="#依赖注入优于硬连接资源（hardwiring-resources）" class="headerlink" title="依赖注入优于硬连接资源（hardwiring resources）"></a>依赖注入优于硬连接资源（hardwiring resources）</h1><p>　许多类依赖于一个或多个底层资源。例如，拼写检查器依赖于字典。将此类类实现为静态工具类并不少见 （详见第 4 条）:</p><pre><code>// Inappropriate use of static utility - inflexible &amp; untestable!public class SpellChecker {    private static final Lexicon dictionary = ...;    private SpellChecker() {} // Noninstantiable    public static boolean isValid(String word) { ... }    public static List&lt;String&gt; suggestions(String typo) { ... }}</code></pre><p>同样地，将它们实现为单例的做法也并不少见（详见第 3 条）：</p><pre><code>// Inappropriate use of singleton - inflexible &amp; untestable!public class SpellChecker {    private final Lexicon dictionary = ...;    private SpellChecker(...) {}    public static INSTANCE = new SpellChecker(...);    public boolean isValid(String word) { ... }    public List&lt;String&gt; suggestions(String typo) { ... }}</code></pre><p>这两种方法都不令人满意，因为他们都是假设只有一本字典可用。实际上，每种语言都有自己的字典，特殊的字典被用于特殊的词汇表。另外，可能还需要用特殊的词典进行测试。想当然地认为一本字典就足够了，这是一厢情愿的想法。</p><p>　　可以通过使 dictionary 属性设置为非final，final关键字修饰的成员变量是常量，修饰的类不能被继承。修饰的成员方法是不能被子类重写的。并添加一个方法来更改现有拼写检查器中的字典，从而让SpellChecker 支持多个字典，但是这样的设置显得非常笨拙、容易出错、并且无法并行工作。静态工具类和单例类不适合与需要引用底层资源的类。</p><p>　　这里所需要的是能够支持类的多个实例 （在我们的示例中是指 SpellChecker），每个实例都使用客户端所期望的资源（在我们的例子中是 dictionary）。满足这一需求的简单模式是，在创建新实例时将资源传递到构造器中。 这是依赖项注入（dependency injection）的一种形式：字典是拼写检查器的一个依赖项，当它创建时被注入到拼写检查器中。</p><pre><code>// Dependency injection provides flexibility and testabilitypublic class SpellChecker {    private final Lexicon dictionary;    public SpellChecker(Lexicon dictionary) {        this.dictionary = Objects.requireNonNull(dictionary);    }    public boolean isValid(String word) { ... }    public List&lt;String&gt; suggestions(String typo) { ... }}</code></pre><p>　　依赖注入模式非常简单，许多程序员使用它多年而不知道它有一个名字。 虽然我们的拼写检查器的例子只有一个资源（字典），但是依赖项注入可以使用任意数量的资源和任意依赖图。 它保持了不变性（详见第 17 条），因此多个客户端可以共享依赖对象（假设客户需要相同的底层资源）。 依赖注入同样适用于构造器、静态工厂（详见第 1 条）和 builder 模式（详见第 2 条）。</p><p>　　该模式的一个有用的变体是将资源工厂传递给构造器。 工厂是可以重复调用以创建类型实例的对象。 这种工厂体现了工厂方法模式（Factory Method pattern）[Gamma95]。 Java 8 中引入的 Supplier<t> 接口非常适合代表工厂。 在输入上采用 Supplier<t> 的方法通常应该使用有界的通配符类型（bounded wildcard type）（详见第 31 条）约束工厂的类型参数，以便客户端能够传入一个工厂，来创建指定类型的任意子类型。例如，下面是一个生产马赛克的方法，它利用客户端提供的工厂来生产每一片马赛克：</t></t></p><pre><code>Mosaic create(Supplier&lt;? extends Tile&gt; tileFactory) { ... }</code></pre><p>　　尽管依赖注入极大地提高了灵活性和可测试性，但它可能使大型项目变得混乱，这些项目通常包含数千个依赖项。使用依赖注入框架（如 Dagger [Dagger]、Guice [Guice] 或 Spring [Spring]）可以消除这些混乱。这些框架的使用超出了本书的范围，但是请注意，为手动依赖注入而设计的 API 非常适合这些框架的使用。</p><p>　　总而言之，不要用单例和静态工具类来实现依赖一个或多个底层资源的类，且该资源的行为会影响到该类的行为；也不要直接用这个类来创建这些资源。而应该将这些资源或者工厂传给构造器（或者静态工厂，或者构建器），通过它们来创建类。这个实践就被称作依赖注人，它极大地提升了类的灵活性、可重用性和可测试性。</p><h1 id="避免创建不必要的对象"><a href="#避免创建不必要的对象" class="headerlink" title="避免创建不必要的对象"></a>避免创建不必要的对象</h1><p>　通过使用静态工厂方法（详见第 1 条）和构造器，可以避免创建不需要的对象。例如，工厂方法 Boolean.valueOf(String) 比构造方法 Boolean(String) 更可取，后者在 Java 9 中被弃用。构造方法每次调用时都必须创建一个新对象，而工厂方法永远不需要这样做，在实践中也不需要。除了重用不可变对象，如果知道它们不会被修改，还可以重用可变对象。<br>一些对象的创建比其他对象的创建要昂贵得多。 如果要重复使用这样一个「昂贵的对象」，建议将其缓存起来以便重复使用。 不幸的是，当创建这样一个对象时并不总是很直观明显的。 假设你想写一个方法来确定一个字符串是否是一个有效的罗马数字。 以下是使用正则表达式完成此操作时最简单方法：</p><pre><code>// Performance can be greatly improved!static boolean isRomanNumeral(String s) {    return s.matches(&quot;^(?=.)M*(C[MD]|D?C{0,3})&quot;            + &quot;(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$&quot;);}</code></pre><p>这个实现的问题在于它依赖于 String.matches 方法。 虽然 String.matches 是检查字符串是否与正则表达式匹配的最简单方法，但它不适合在性能临界的情况下重复使用。 问题是它在内部为正则表达式创建一个 Pattern 实例，并且只使用它一次，之后它就有资格进行垃圾收集。 创建 Pattern 实例是昂贵的，因为它需要将正则表达式编译成有限状态机（finite state machine）。</p><p>　　为了提高性能，作为类初始化的一部分，将正则表达式显式编译为一个 Pattern 实例（不可变），缓存它，并在 isRomanNumeral 方法的每个调用中重复使用相同的实例：</p><pre><code>// Reusing expensive object for improved performancepublic class RomanNumerals {    private static final Pattern ROMAN = Pattern.compile(            &quot;^(?=.)M*(C[MD]|D?C{0,3})&quot;            + &quot;(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$&quot;);    static boolean isRomanNumeral(String s) {        return ROMAN.matcher(s).matches();    }}</code></pre><p>如果经常调用，isRomanNumeral 的改进版本的性能会显著提升。</p><p>　　如果包含 isRomanNumeral 方法的改进版本的类被初始化，但该方法从未被调用，则 ROMAN 属性则没必要初始化。 在第一次调用 isRomanNumeral 方法时，可以通过延迟初始化（ lazily initializing）属性（详见第 83 条）来排除初始化，但一般不建议这样做。 延迟初始化常常会导致实现复杂化，而性能没有可衡量的改进（详见第 67 条）。</p><p>　　当一个对象是不可变的时，很明显它可以被安全地重用，但是在其他情况下，它远没有那么明显，甚至是违反直觉的。考虑适配器（adapters）的情况[Gamma95]，也称为视图（views）。一个适配器是一个对象，它委托一个支持对象（backing object），提供一个可替代的接口。由于适配器没有超出其支持对象的状态，因此不需要为给定对象创建多个给定适配器的实例。</p><p>例如，Map 接口的 keySet 方法返回 Map 对象的 Set 视图，包含 Map 中的所有 key。 天真地说，似乎每次调用 keySet 都必须创建一个新的 Set 实例，但是对给定 Map 对象的 keySet 的每次调用都返回相同的 Set 实例。 尽管返回的 Set 实例通常是可变的，但是所有返回的对象在功能上都是相同的：当其中一个返回的对象发生变化时，所有其他对象也都变化，因为它们全部由相同的 Map 实例支持。 虽然创建 keySet 视图对象的多个实例基本上是无害的，但这是没有必要的，也没有任何好处。</p><p>　　另一种创建不必要的对象的方法是自动装箱（auto boxing），它允许程序员混用基本类型和包装的基本类型，根据需要自动装箱和拆箱。 自动装箱模糊不清，但不会消除基本类型和装箱基本类型之间的区别。 有微妙的语义区别和不那么细微的性能差异（详见第 61 条）。 考虑下面的方法，它计算所有正整数的总和。 要做到这一点，程序必须使用 long 类型，因为 int 类型不足以保存所有正整数的总和：</p><pre><code>// Hideously slow! Can you spot the object creation?private static long sum() {    Long sum = 0L;    for (long i = 0; i &lt;= Integer.MAX_VALUE; i++)        sum += i;    return sum;}</code></pre><p>这个程序的结果是正确的，但由于写错了一个字符，运行的结果要比实际慢很多。变量 sum 被声明成了 Long 而不是 long，这意味着程序构造了大约 231 不必要的 Long 实例（大约每次往 Long 类型的 sum 变量中增加一个 long 类型构造的实例），把 sum 变量的类型由 Long 改为 long。这个教训很明显：优先使用基本类型而不是装箱的基本类型，也要注意无意识的自动装箱。</p><p>　　这个条目不应该被误解为暗示对象创建是昂贵的，应该避免创建对象。 相反，使用构造方法创建和回收小的对象是非常廉价，构造方法只会做很少的显示工作，尤其是在现代 JVM 实现上。 创建额外的对象以增强程序的清晰度，简单性或功能性通常是件好事。</p><p>　　相反，除非池中的对象非常重量级，否则通过维护自己的对象池来避免对象创建是一个坏主意。对象池的典型例子就是数据库连接。建立连接的成本非常高，因此重用这些对象是有意义的。但是，一般来说，维护自己的对象池会使代码混乱，增加内存占用，并损害性能。现代 JVM 实现具有高度优化的垃圾收集器，它们在轻量级对象上轻松胜过此类对象池。</p><p>　　这个条目的对应点是针对条目 50 的防御性复制（defensive copying）。 目前的条目说：「当你应该重用一个现有的对象时，不要创建一个新的对象」，而条目 50 说：「不要重复使用现有的对象，当你应该创建一个新的对象时。」请注意，重用防御性复制所要求的对象所付出的代价，要远远大于不必要地创建重复的对象。 未能在需要的情况下防御性复制会导致潜在的错误和安全漏洞；而不必要地创建对象只会影响程序的风格和性能。</p><p>#参考资料<br>[1] <a href="https://sjsdfg.github.io/effective-java-3rd-chinese/#/notes/05.%20%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E4%BC%98%E4%BA%8E%E7%A1%AC%E8%BF%9E%E6%8E%A5%E8%B5%84%E6%BA%90(hardwiring%20resources)" target="_blank" rel="noopener">https://sjsdfg.github.io/effective-java-3rd-chinese/#/notes/05.%20%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E4%BC%98%E4%BA%8E%E7%A1%AC%E8%BF%9E%E6%8E%A5%E8%B5%84%E6%BA%90(hardwiring%20resources)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二章阅读：创建和销毁对象&lt;br&gt;05.依赖注入优于硬连接资源（hardwiring resources）&lt;br&gt;06.避免创建不必要的对象&lt;/p&gt;
    
    </summary>
    
      <category term="2019年12月" scheme="http://yoursite.com/categories/2019%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Effctive-Java阅读笔记IV</title>
    <link href="http://yoursite.com/2019/12/31/Effctive-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0IV/"/>
    <id>http://yoursite.com/2019/12/31/Effctive-Java阅读笔记IV/</id>
    <published>2019-12-31T07:06:12.000Z</published>
    <updated>2020-01-06T01:44:52.445Z</updated>
    
    <content type="html"><![CDATA[<p>第二章阅读：创建和销毁对象<br>07.消除过期的对象引用<br>08.避免使用 Finalizer 和 Cleaner 机制</p><a id="more"></a><h1 id="消除过期的对象引用"><a href="#消除过期的对象引用" class="headerlink" title="消除过期的对象引用"></a>消除过期的对象引用</h1><p>如果你从使用手动内存管理的语言（如 C 或 C++）切换到像 Java 这样的带有垃圾收集机制的语言，那么作为程序员的工作就会变得容易多了，因为你的对象在使用完毕以后就自动回收了。当你第一次体验它的时候，它就像魔法一样。这很容易让人觉得你不需要考虑内存管理，但这并不完全正确。</p><pre><code>// Can you spot the &quot;memory leak&quot;?public class Stack {    private Object[] elements;    private int size = 0;    private static final int DEFAULT_INITIAL_CAPACITY = 16;    public Stack() {        elements = new Object[DEFAULT_INITIAL_CAPACITY];    }    public void push(Object e) {        ensureCapacity();        elements[size++] = e;    }    public Object pop() {        if (size == 0)            throw new EmptyStackException();        return elements[--size];    }    /**     * Ensure space for at least one more element, roughly     * doubling the capacity each time the array needs to grow.     ** /    private void ensureCapacity() {        if (elements.length == size)            elements = Arrays.copyOf(elements, 2 * size + 1);    }}</code></pre><p>这个程序没有什么明显的错误（但是对于泛型版本，请参阅条目 29）。 你可以对它进行详尽的测试，它都会成功地通过每一项测试，但有一个潜在的问题。 笼统地说，程序有一个「内存泄漏」，由于垃圾回收器的活动的增加，或内存占用的增加，静默地表现为性能下降。 在极端的情况下，这样的内存泄漏可能会导致磁盘分页（disk paging），甚至导致内存溢出（OutOfMemoryError）的失败，但是这样的故障相对较少。</p><p>　　那么哪里发生了内存泄漏？ 如果一个栈增长后收缩，那么从栈弹出的对象不会被垃圾收集，即使使用栈的程序不再引用这些对象。 这是因为栈维护对这些对象的过期引用（obsolete references）。 过期引用简单来说就是永远不会解除的引用。 在这种情况下，元素数组「活动部分（active portion）」之外的任何引用都是过期的。 活动部分是由索引下标小于 size 的元素组成。</p><p>　　垃圾收集语言中的内存泄漏（更适当地称为无意的对象保留 unintentional object retentions）是隐蔽的。 如果无意中保留了对象引用，那么不仅这个对象排除在垃圾回收之外，而且该对象引用的任何对象也是如此。 即使只有少数对象引用被无意地保留下来，也可以阻止垃圾回收机制对许多对象的回收，这对性能产生很大的影响。</p><p>　　这类问题的解决方法很简单：一旦对象引用过期，将它们设置为 null。 在我们的 Stack 类的情景下，只要从栈中弹出，元素的引用就设置为过期。 pop 方法的修正版本如下所示：</p><pre><code>public Object pop() {    if (size == 0)        throw new EmptyStackException();    Object result = elements[--size];    elements[size] = null; // Eliminate obsolete reference    return result;}</code></pre><p>取消过期引用的另一个好处是，如果它们随后被错误地引用，程序立即抛出 NullPointerException 异常，而不是悄悄地做继续做错误的事情。尽可能快地发现程序中的错误是有好处的。</p><p>　　当程序员第一次被这个问题困扰时，他们可能会在程序结束后立即清空所有对象引用。这既不是必要的，也不是可取的；它不必要地搞乱了程序。清空对象引用应该是例外而不是规范。消除过期引用的最好方法是让包含引用的变量超出范围。如果在最近的作用域范围内定义每个变量 （详见第 57 条），这种自然就会出现这种情况。</p><p>　　那么什么时候应该清空一个引用呢？Stack 类的哪个方面使它容易受到内存泄漏的影响？简单地说，它管理自己的内存。存储池（storage pool）由 elements 数组的元素组成（对象引用单元，而不是对象本身）。数组中活动部分的元素 (如前面定义的) 被分配，其余的元素都是空闲的。垃圾收集器没有办法知道这些；对于垃圾收集器来说，elements 数组中的所有对象引用都同样有效。只有程序员知道数组的非活动部分不重要。程序员可以向垃圾收集器传达这样一个事实，一旦数组中的元素变成非活动的一部分，就可以手动清空这些元素的引用。</p><p>　　一般来说，当一个类自己管理内存时，程序员应该警惕内存泄漏问题。 每当一个元素被释放时，元素中包含的任何对象引用都应该被清除。</p><p>　　另一个常见的内存泄漏来源是缓存。 一旦将对象引用放入缓存中，很容易忘记它的存在，并且在它变得无关紧要之后，仍然保留在缓存中。对于这个问题有几种解决方案。如果你正好想实现了一个缓存：只要在缓存之外存在对某个项（entry）的键（key）引用，那么这项就是明确有关联的，就可以用 WeakHashMap 来表示缓存；这些项在过期之后自动删除。记住，只有当缓存中某个项的生命周期是由外部引用到键（key）而不是值（value）决定时，WeakHashMap 才有用。</p><p>　　更常见的情况是，缓存项有用的生命周期不太明确，随着时间的推移一些项变得越来越没有价值。在这种情况下，缓存应该偶尔清理掉已经废弃的项。这可以通过一个后台线程 (也许是 ScheduledThreadPoolExecutor) 或将新的项添加到缓存时顺便清理。LinkedHashMap 类使用它的 removeEldestEntry 方法实现了后一种方案。对于更复杂的缓存，可能直接需要使用 java.lang.ref。</p><p>　　第三个常见的内存泄漏来源是监听器和其他回调。如果你实现了一个 API，其客户端注册回调，但是没有显式地撤销注册回调，除非采取一些操作，否则它们将会累积。确保回调是垃圾收集的一种方法是只存储弱引用（weak references），例如，仅将它们保存在 WeakHashMap 的键（key）中。</p><p>　　因为内存泄漏通常不会表现为明显的故障，所以它们可能会在系统中保持多年。 通常仅在仔细的代码检查或借助堆分析器（heap profiler）的调试工具才会被发现。 因此，学习如何预见这些问题，并防止这些问题发生，是非常值得的。</p><h1 id="避免使用-Finalizer-和-Cleaner-机制"><a href="#避免使用-Finalizer-和-Cleaner-机制" class="headerlink" title="避免使用 Finalizer 和 Cleaner 机制"></a>避免使用 Finalizer 和 Cleaner 机制</h1><p>Finalizer 机制是不可预知的，往往是危险的，而且通常是不必要的。 它们的使用会导致不稳定的行为，糟糕的性能和移植性问题。 Finalizer 机制有一些特殊的用途，我们稍后会在这个条目中介绍，但是通常应该避免它们。 从 Java 9 开始，Finalizer 机制已被弃用，但仍被 Java 类库所使用。 Java 9 中 Cleaner 机制代替了 Finalizer 机制。 Cleaner 机制不如 Finalizer 机制那样危险，但仍然是不可预测，运行缓慢并且通常是不必要的。</p><p>　　提醒 C++程序员不要把 Java 中的 Finalizer 或 Cleaner 机制当成的 C++ 析构函数的等价物。 在 C++ 中，析构函数是回收对象相关资源的正常方式，是与构造方法相对应的。 在 Java 中，当一个对象变得不可达时，垃圾收集器回收与对象相关联的存储空间，不需要开发人员做额外的工作。 C++ 析构函数也被用来回收其他非内存资源。 在 Java 中，try-with-resources 或 try-finally 块用于此目的（详见第 9 条）。</p><p>　　Finalizer 和 Cleaner 机制的一个缺点是不能保证他们能够及时执行[JLS，12.6]。 在一个对象变得无法访问时，到 Finalizer 和 Cleaner 机制开始运行时，这期间的时间是任意长的。 这意味着你永远不应该 Finalizer 和 Cleaner 机制做任何时间敏感（time-critical）的事情。 例如，依赖于 Finalizer 和 Cleaner 机制来关闭文件是严重的错误，因为打开的文件描述符是有限的资源。 如果由于系统迟迟没有运行 Finalizer 和 Cleaner 机制而导致许多文件被打开，程序可能会失败，因为它不能再打开文件了。</p><p>　　及时执行 Finalizer 和 Cleaner 机制是垃圾收集算法的一个功能，这种算法在不同的实现中有很大的不同。程序的行为依赖于 Finalizer 和 Cleaner 机制的及时执行，其行为也可能大不不同。 这样的程序完全可以在你测试的 JVM 上完美运行，然而在你最重要的客户的机器上可能运行就会失败。</p><p>　　延迟终结（finalization）不只是一个理论问题。为一个类提供一个 Finalizer 机制可以任意拖延它的实例的回收。一位同事调试了一个长时间运行的 GUI 应用程序，这个应用程序正在被一个 OutOfMemoryError 错误神秘地死掉。分析显示，在它死亡的时候，应用程序的 Finalizer 机制队列上有成千上万的图形对象正在等待被终结和回收。不幸的是，Finalizer 机制线程的运行优先级低于其他应用程序线程，所以对象被回收的速度低于进入队列的速度。语言规范并不保证哪个线程执行 Finalizer 机制，因此除了避免使用 Finalizer 机制之外，没有轻便的方法来防止这类问题。在这方面， Cleaner 机制比 Finalizer 机制要好一些，因为 Java 类的创建者可以控制自己 cleaner 机制的线程，但 cleaner 机制仍然在后台运行，在垃圾回收器的控制下运行，但不能保证及时清理。</p><p>　　Java 规范不能保证 Finalizer 和 Cleaner 机制能及时运行；它甚至不能能保证它们是否会运行。当一个程序结束后，一些不可达对象上的 Finalizer 和 Cleaner 机制仍然没有运行。因此，不应该依赖于 Finalizer 和 Cleaner 机制来更新持久化状态。例如，依赖于 Finalizer 和 Cleaner 机制来释放对共享资源（如数据库）的持久锁，这是一个使整个分布式系统陷入停滞的好方法。</p><p>　　不要相信 System.gc 和 System.runFinalization 方法。 他们可能会增加 Finalizer 和 Cleaner 机制被执行的几率，但不能保证一定会执行。 曾经声称做出这种保证的两个方法：System.runFinalizersOnExit 和它的孪生兄弟 Runtime.runFinalizersOnExit，包含致命的缺陷，并已被弃用了几十年[ThreadStop]。</p><p>　　Finalizer 机制的另一个问题是在执行 Finalizer 机制过程中，未捕获的异常会被忽略，并且该对象的 Finalizer 机制也会终止 [JLS, 12.6]。未捕获的异常会使其他对象陷入一种损坏的状态（corrupt state）。如果另一个线程试图使用这样一个损坏的对象，可能会导致任意不确定的行为。通常情况下，未捕获的异常将终止线程并打印堆栈跟踪（ stacktrace），但如果发生在 Finalizer 机制中，则不会发出警告。Cleaner 机制没有这个问题，因为使用 Cleaner 机制的类库可以控制其线程。</p><p>　　使用 finalizer 和 cleaner 机制会导致严重的性能损失。 在我的机器上，创建一个简单的 AutoCloseable 对象，使用 try-with-resources 关闭它，并让垃圾回收器回收它的时间大约是 12 纳秒。 使用 finalizer 机制，而时间增加到 550 纳秒。 换句话说，使用 finalizer 机制创建和销毁对象的速度要慢 50 倍。 这主要是因为 finalizer 机制会阻碍有效的垃圾收集。 如果使用它们来清理类的所有实例（在我的机器上的每个实例大约是 500 纳秒），那么 cleaner 机制的速度与 finalizer 机制的速度相当，但是如果仅将它们用作安全网（safety net），则 cleaner 机制要快得多，如下所述。 在这种环境下，创建，清理和销毁一个对象在我的机器上需要大约 66 纳秒，这意味着如果你不使用安全网的话，需要支付 5 倍（而不是 50 倍）的保险。</p><p>　　finalizer 机制有一个严重的安全问题：它们会打开你的类来进行 finalizer 机制攻击。finalizer 机制攻击的想法很简单：如果一个异常是从构造方法或它的序列化中抛出的——readObject 和 readResolve 方法 （第 12 章）——恶意子类的 finalizer 机制可以运行在本应该「中途夭折（died on the vine）」的部分构造对象上。finalizer 机制可以在静态字属性记录对对象的引用，防止其被垃圾收集。一旦记录了有缺陷的对象，就可以简单地调用该对象上的任意方法，而这些方法本来就不应该允许存在。从构造方法中抛出异常应该足以防止对象出现；而在 finalizer 机制存在下，则不是。这样的攻击会带来可怕的后果。Final 类不受 finalizer 机制攻击的影响，因为没有人可以编写一个 final 类的恶意子类。为了保护非 final 类不受 finalizer 机制攻击，编写一个 final 的 finalize 方法，它什么都不做。</p><p>　　那么，你应该怎样做呢？为对象封装需要结束的资源（如文件或线程），而不是为该类编写 Finalizer 和 Cleaner 机制？让你的类实现 AutoCloseable 接口即可，并要求客户在在不再需要时调用每个实例 close 方法，通常使用 try-with-resources 确保终止，即使面对有异常抛出情况（详见第 9 条）。一个值得一提的细节是实例必须跟踪是否已经关闭：close 方法必须记录在对象里不再有效的属性，其他方法必须检查该属性，如果在对象关闭后调用它们，则抛出 IllegalStateException 异常。</p><p>　　那么，Finalizer 和 Cleaner 机制有什么好处呢？它们可能有两个合法用途。一个是作为一个安全网（safety net），以防资源的拥有者忽略了它的 close 方法。虽然不能保证 Finalizer 和 Cleaner 机制会迅速运行 (或者根本就没有运行)，最好是把资源释放晚点出来，也要好过客户端没有这样做。如果你正在考虑编写这样的安全网 Finalizer 机制，请仔细考虑一下这样保护是否值得付出对应的代价。一些 Java 库类，如 FileInputStream、FileOutputStream、ThreadPoolExecutor 和 java.sql.Connection，都有作为安全网的 Finalizer 机制。</p><p>　　第二种合理使用 Cleaner 机制的方法与本地对等类（native peers）有关。本地对等类是一个由普通对象委托的本地 (非 Java) 对象。由于本地对等类不是普通的 Java 对象，所以垃圾收集器并不知道它，当它的 Java 对等对象被回收时，本地对等类也不会回收。假设性能是可以接受的，并且本地对等类没有关键的资源，那么 Finalizer 和 Cleaner 机制可能是这项任务的合适的工具。但如果性能是不可接受的，或者本地对等类持有必须迅速回收的资源，那么类应该有一个 close 方法，正如前面所述。</p><p>　　Cleaner 机制使用起来有点棘手。下面是演示该功能的一个简单的 Room 类。假设 Room 对象必须在被回收前清理干净。Room 类实现 AutoCloseable 接口；它的自动清理安全网使用的是一个 Cleaner 机制，这仅仅是一个实现细节。与 Finalizer 机制不同，Cleaner 机制不污染一个类的公共 API：</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://sjsdfg.github.io/effective-java-3rd-chinese/#/notes/08.%20%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8Finalizer%E5%92%8CCleaner%E6%9C%BA%E5%88%B6" target="_blank" rel="noopener">https://sjsdfg.github.io/effective-java-3rd-chinese/#/notes/08.%20%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8Finalizer%E5%92%8CCleaner%E6%9C%BA%E5%88%B6</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二章阅读：创建和销毁对象&lt;br&gt;07.消除过期的对象引用&lt;br&gt;08.避免使用 Finalizer 和 Cleaner 机制&lt;/p&gt;
    
    </summary>
    
      <category term="2019年12月" scheme="http://yoursite.com/categories/2019%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Effctive-Java阅读笔记II</title>
    <link href="http://yoursite.com/2019/12/31/Effctive-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0II/"/>
    <id>http://yoursite.com/2019/12/31/Effctive-Java阅读笔记II/</id>
    <published>2019-12-31T03:30:12.000Z</published>
    <updated>2020-01-03T06:44:32.400Z</updated>
    
    <content type="html"><![CDATA[<p>第二章阅读：创建和销毁对象<br>03.使用私有构造方法或枚类实现 Singleton 属性<br>04.使用私有构造器执行非实例化<br>（这两部分理解有困难，需要再查阅相关资料）</p><a id="more"></a><h1 id="使用私有构造方法或枚类实现-Singleton-属性"><a href="#使用私有构造方法或枚类实现-Singleton-属性" class="headerlink" title="使用私有构造方法或枚类实现 Singleton 属性"></a>使用私有构造方法或枚类实现 Singleton 属性</h1><p>单例是一个仅实例化一次的类，详细描述参见笔记：《设计模式面试高频题》。单例对象通常表示无状态对象，如函数 (条目 24) 或一个本质上唯一的系统组件。让一个类成为单例会使测试它的客户变得困难，因为除非实现一个作为它类型的接口，否则不可能用一个模拟实现替代单例。</p><p>　有两种常见的方法来实现单例。两者都基于保持构造方法私有和导出公共静态成员以提供对唯一实例的访问。在第一种方法中，成员是 final 修饰的属性：</p><pre><code>// Singleton with public final fieldpublic class Elvis {    public static final Elvis INSTANCE = new Elvis();    private Elvis() { ... }    public void leaveTheBuilding() { ... }}</code></pre><p>私有构造方法只调用一次，来初始化公共静态 final Elvis.INSTANCE 属性。缺少一个公共的或受保护的构造方法，保证了全局的唯一性：一旦 Elvis 类被初始化，一个 Elvis 的实例就会存在——不多也不少。客户端所做的任何事情都不能改变这一点，但需要注意的是：特权客户端可以使用 AccessibleObject.setAccessible 方法，以反射方式调用私有构造方法（详见第 65 条）。如果需要防御此攻击，请修改构造函数，使其在请求创建第二个实例时抛出异常。<br>　在第二个实现单例的方法中，公共成员是一个静态的工厂方法：</p><pre><code>// Singleton with static factorypublic class Elvis {    private static final Elvis INSTANCE = new Elvis();    private Elvis() { ... }    public static Elvis getInstance() { return INSTANCE; }    public void leaveTheBuilding() { ... }}</code></pre><p>所有对 Elvis.getInstance 的调用都返回相同的对象引用，并且不会创建其他的 Elvis 实例（与前面提到的警告相同）。</p><p>　　公共属性方法的主要优点是 API 明确表示该类是一个单例：公共静态属性是 final 的，所以它总是包含相同的对象引用。 第二个好处是它更简单。</p><p>　　静态工厂方法的优势之一在于，它提供了灵活性：在不改变其 API 的前提下，我们可以改变该类是否应该为单例的想法。工厂方法返回该类的唯一实例，但是，它很容易被修改，比如，改为每个调用该方法的线程返回一个唯一的实例。 第二个好处是，如果你的应用程序需要它，可以编写一个泛型单例工厂（generic singleton factory ）（详见第30 条）。 使用静态工厂的最后一个优点是，可以通过方法引用（method reference）作为提供者，例如 Elvis::instance 等同于 Supplier<elvis>。 除非满足以上任意一种优势，否则还是优先考虑公有域（public-field）的方法。</elvis></p><p>　　为了将上述方法中实现的单例类变成是可序列化的 （第 12 章），仅仅将 implements Serializable 添加到声明中是不够的。为了保证单例模式不被破坏，必须声明所有的实例字段为 transient，并提供一个 readResolve 方法（详见第 89 条）。否则，每当序列化的实例被反序列化时，就会创建一个新的实例，在我们的例子中，导致出现新的 Elvis 实例。为了防止这种情况发生，将如下的 readResolve 方法添加到 Elvis 类：</p><pre><code>// readResolve method to preserve singleton propertyprivate Object readResolve() {     // Return the one true Elvis and let the garbage collector     // take care of the Elvis impersonator.    return INSTANCE;}</code></pre><p>实现一个单例的第三种方法是声明单一元素的枚举类：</p><pre><code>// Enum singleton - the preferred approachpublic enum Elvis {    INSTANCE;    public void leaveTheBuilding() { ... }}</code></pre><p>　这种方式类似于公共属性方法，但更简洁，无偿地提供了序列化机制，并提供了防止多个实例化的坚固保证，即使是在复杂的序列化或反射攻击的情况下。这种方法可能感觉有点不自然，但是 单一元素枚举类通常是实现单例的最佳方式。注意，如果单例必须继承 Enum 以外的父类 (尽管可以声明一个 Enum 来实现接口)，那么就不能使用这种方法。</p><h1 id="使用私有构造器执行非实例化"><a href="#使用私有构造器执行非实例化" class="headerlink" title="使用私有构造器执行非实例化"></a>使用私有构造器执行非实例化</h1><p>试图通过创建抽象类来强制执行非实例化是行不通的。 该类可以被子类化，并且子类可以被实例化。此外，它误导用户认为该类是为继承而设计的（详见第 19 条）。不过，有一个简单的方法来确保非实例化。只有当类不包含显式构造器时，才会生成一个默认构造器，因此可以通过包含一个私有构造器来实现类的非实例化：</p><pre><code>// Noninstantiable utility classpublic class UtilityClass {    // Suppress default constructor for noninstantiability    private UtilityClass() {        throw new AssertionError();    }    ... // Remainder omitted}</code></pre><p>因为显式构造器是私有的，所以不可以在类的外部访问它。AssertionError 异常不是严格要求的，但是它可以避免不小心在类的内部调用构造器。它保证类在任何情况下都不会被实例化。这个习惯用法有点违反直觉，好像构造器就是设计成不能调用的一样。因此，如前面所示，添加注释是种明智的做法。</p><p>　　这种习惯有一个副作用，就是使得一个类不能子类化。所有的构造器都必须显式或隐式地调用父类构造器，而在这群情况下子类则没有可访问的父类构造器来调用。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二章阅读：创建和销毁对象&lt;br&gt;03.使用私有构造方法或枚类实现 Singleton 属性&lt;br&gt;04.使用私有构造器执行非实例化&lt;br&gt;（这两部分理解有困难，需要再查阅相关资料）&lt;/p&gt;
    
    </summary>
    
      <category term="2019年12月" scheme="http://yoursite.com/categories/2019%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>设计模式学习笔记III</title>
    <link href="http://yoursite.com/2019/12/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0III/"/>
    <id>http://yoursite.com/2019/12/30/设计模式学习笔记III/</id>
    <published>2019-12-30T08:55:12.000Z</published>
    <updated>2019-12-30T10:12:54.670Z</updated>
    
    <content type="html"><![CDATA[<p>静态静态工厂方法</p><a id="more"></a><h1 id="序：什么是静态工厂方法"><a href="#序：什么是静态工厂方法" class="headerlink" title="序：什么是静态工厂方法"></a>序：什么是静态工厂方法</h1><p>在 Java 中，获得一个类实例最简单的方法就是使用 new 关键字，通过构造函数来实现对象的创建。<br>就像这样：</p><pre><code>Fragment fragment = new MyFragment();// orDate date = new Date();</code></pre><p>不过在实际的开发中，我们经常还会见到另外一种获取类实例的方法：</p><pre><code>Fragment fragment = MyFragment.newIntance();// orCalendar calendar = Calendar.getInstance();// orInteger number = Integer.valueOf(&quot;3&quot;);</code></pre><p> <strong><em>像这样的：不通过 new，而是用一个静态方法来对外提供自身实例的方法，即为我们所说的静态工厂方法(Static factory method)。</em></strong></p><h2 id="知识点：new-究竟做了什么"><a href="#知识点：new-究竟做了什么" class="headerlink" title="知识点：new 究竟做了什么?"></a>知识点：new 究竟做了什么?</h2><p>简单来说：当我们使用 new 来构造一个新的类实例时，其实是告诉了 JVM 我需要一个新的实例。JVM 就会自动在内存中开辟一片空间，然后调用构造函数来初始化成员变量，最终把引用返回给调用方。</p><h1 id="Effective-Java"><a href="#Effective-Java" class="headerlink" title="Effective Java"></a>Effective Java</h1><p>在关于 Java 中书籍中，《Effective Java》绝对是最负盛名几本的之一，在此书中，作者总结了几十条改善 Java 程序设计的金玉良言。其中开篇第一条就是『考虑使用静态工厂方法代替构造器』，关于其原因，作者总结了几条，我们先来逐个看一下。</p><h2 id="静态工厂方法与构造器不同的第一优势在于，它们有名字"><a href="#静态工厂方法与构造器不同的第一优势在于，它们有名字" class="headerlink" title="静态工厂方法与构造器不同的第一优势在于，它们有名字"></a>静态工厂方法与构造器不同的第一优势在于，它们有名字</h2><p>由于语言的特性，Java 的构造函数都是跟类名一样的。这导致的一个问题是构造函数的名称不够灵活，经常不能准确地描述返回值，在有多个重载的构造函数时尤甚，如果参数类型、数目又比较相似的话，那更是很容易出错。</p><p>比如，如下的一段代码 ：</p><pre><code>Date date0 = new Date();Date date1 = new Date(0L);Date date2 = new Date(&quot;0&quot;);Date date3 = new Date(1,2,1);Date date4 = new Date(1,2,1,1,1);Date date5 = new Date(1,2,1,1,1,1);</code></pre><p>Date 类有很多重载函数，对于开发者来说，假如不是特别熟悉的话，恐怕是需要犹豫一下，才能找到合适的构造函数的。而对于其他的代码阅读者来说，估计更是需要查看文档，才能明白每个参数的含义了。</p><p>（当然，Date 类在目前的 Java 版本中，只保留了一个无参和一个有参的构造函数，其他的都已经标记为 @Deprecated 了）</p><p>而如果使用静态工厂方法，就可以给方法起更多有意义的名字，比如前面的 valueOf、newInstance、getInstance 等，对于代码的编写和阅读都能够更清晰。</p><h2 id="第二个优势，不用每次被调用时都创建新对象"><a href="#第二个优势，不用每次被调用时都创建新对象" class="headerlink" title="第二个优势，不用每次被调用时都创建新对象"></a>第二个优势，不用每次被调用时都创建新对象</h2><p>这个很容易理解了，有时候外部调用者只需要拿到一个实例，而不关心是否是新的实例；又或者我们想对外提供一个单例时如果使用工厂方法，就可以很容易的在内部控制，防止创建不必要的对象，减少开销。</p><p>在实际的场景中，单例的写法也大都是用静态工厂方法来实现的。</p><p>如果你想对单例有更多了解，可以看一下这里：☞《Hi，我们再来聊一聊Java的单例吧》[2]</p><h2 id="第三个优势，可以返回原返回类型的子类"><a href="#第三个优势，可以返回原返回类型的子类" class="headerlink" title="第三个优势，可以返回原返回类型的子类"></a>第三个优势，可以返回原返回类型的子类</h2><p>这条不用多说，设计模式中的基本的原则之一——『里氏替换』原则，就是说子类应该能替换父类。<br>显然，构造方法只能返回确切的自身类型，而静态工厂方法则能够更加灵活，可以根据需要方便地返回任何它的子类型的实例。</p><pre><code>Class Person {    public static Person getInstance(){        return new Person();        // 这里可以改为 return new Player() / Cooker()    }}Class Player extends Person{}Class Cooker extends Person{}</code></pre><p>比如上面这段代码，Person 类的静态工厂方法可以返回 Person 的实例，也可以根据需要返回它的子类 Player 或者 Cooker。（当然，这只是为了演示，在实际的项目中，一个类是不应该依赖于它的子类的。但如果这里的 getInstance () 方法位于其他的类中，就更具有的实际操作意义了）</p><h2 id="静态工厂的第四个优点是返回对象的类可以根据输入参数的不同而不同"><a href="#静态工厂的第四个优点是返回对象的类可以根据输入参数的不同而不同" class="headerlink" title="静态工厂的第四个优点是返回对象的类可以根据输入参数的不同而不同"></a>静态工厂的第四个优点是返回对象的类可以根据输入参数的不同而不同</h2><p>EnumSet 类（详见第 36 条）没有公共构造方法，只有静态工厂。 在 OpenJDK 实现中，它们根据底层枚举类型的大小返回两个子类中的一个的实例：大多数枚举类型具有 64 个或更少的元素，静态工厂将返回一个 RegularEnumSet 实例， 底层是long 类型；如果枚举类型具有六十五个或更多元素，则工厂将返回一个 JumboEnumSet 实例，底层是long 类型的数组。</p><pre><code>/**     * Creates an empty enum set with the specified element type.     *     * @param &lt;E&gt; The class of the elements in the set     * @param elementType the class object of the element type for this enum     *     set     * @return An empty enum set of the specified type.     * @throws NullPointerException if &lt;tt&gt;elementType&lt;/tt&gt; is null     ** /    public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; noneOf(Class&lt;E&gt; elementType) {        Enum&lt;?&gt;[] universe = getUniverse(elementType);        if (universe == null)            throw new ClassCastException(elementType + &quot; not an enum&quot;);        if (universe.length &lt;= 64)            return new RegularEnumSet&lt;&gt;(elementType, universe);        else            return new JumboEnumSet&lt;&gt;(elementType, universe);    }</code></pre><p>　　这两个实现类的存在对于客户端而言是不可见的。 如果 RegularEnumSet 对于小的枚举类型不再具有性能优势，则可以在未来版本中将其淘汰，且不会产生任何不良影响。 同样，如果可以证明添加 EnumSet 的更多的实现可以提高性能，那么在未来的版本可能就会这样做。 客户既不知道也不关心他们从工厂返回的对象的类别; 他们只需要知道它是 EnumSet 的子类。</p><h2 id="第五个优势是，在编写包含该方法的类时，返回的对象的类不需要存在。"><a href="#第五个优势是，在编写包含该方法的类时，返回的对象的类不需要存在。" class="headerlink" title="第五个优势是，在编写包含该方法的类时，返回的对象的类不需要存在。"></a>第五个优势是，在编写包含该方法的类时，返回的对象的类不需要存在。</h2><p>这种灵活的静态工厂方法构成了服务提供者框架的基础，比如 Java 数据库连接 AP（JDBC）。服务提供者框架是提供者实现服务的系统，并且系统使得实现对客户端可用，从而将客户端从实现中分离出来。</p><p>书中这段读起来比较晦涩，对服务提供者框架在参考资料[3]中有解释，<br>　　<br><img src="assets/markdown-img-paste-20191230175836971.png" alt></p><p>服务提供者框架中有三个基本组：服务接口，它表示实现；提供者注册 API，提供者用来注册实现；以及服务访问 API，客户端使用该 API 获取服务的实例。服务访问 API 允许客户指定选择实现的标准。在缺少这样的标准的情况下，API 返回一个默认实现的实例，或者允许客户通过所有可用的实现进行遍历。服务访问 API 是灵活的静态工厂，它构成了服务提供者框架的基础。</p><p>  Class.forName(“com.mysql.jdbc.Driver”);</p><p>这样一个语句会实例化一个Driver类（提供服务者实现类），并将这个类的实例注册到DriverManager（服务提供者注册类）。</p><p>  DriverManager.getConnection(“jdbc:mysql://…”,”…”,”…”);<br>这里通过建立连接的URL等信息来获取数据库连接。DriverManager通过传进来的url信息判断出你是要获取那个服务提供者提供的服务。因为前面已经将提供服务者实现类注册到DriverManager了，DriverManager获取到这个服务提供者实现类对象之后，通过调用它的getService（mysql里面是connect方法）方法获取到服务具体实现类对象，返回的却是java.sql.Connection接口对象（因为服务具体实现类实现了Connection接口），这样把服务具体实现类对象隐藏了。提供了很好的扩展性。</p><p>　　服务提供者框架的一个可选的第四个组件是一个服务提供者接口，它描述了一个生成服务接口实例的工厂对象。在没有服务提供者接口的情况下，必须对实现进行反射实例化（详见第 65 条）。在 JDBC 的情况下，Connection 扮演服务接口的一部分，DriverManager.registerDriver 提供程序注册 API、DriverManager.getConnection 是服务访问 API，Driver 是服务提供者接口。</p><p>服务提供者框架模式有许多变种。 例如，服务访问 API 可以向客户端返回比提供者提供的更丰富的服务接口。 这是桥接模式。 依赖注入框架（详见第 5 条）可以被看作是强大的服务提供者。 从 Java 6 开始，平台包含一个通用的服务提供者框架 java.util.ServiceLoader，所以你不需要，一般也不应该自己编写（详见第 59 条）。 JDBC 不使用 ServiceLoader，因为前者早于后者。</p><h2 id="另一个优势，在创建带泛型的实例时，能使代码变得简洁"><a href="#另一个优势，在创建带泛型的实例时，能使代码变得简洁" class="headerlink" title="另一个优势，在创建带泛型的实例时，能使代码变得简洁"></a>另一个优势，在创建带泛型的实例时，能使代码变得简洁</h2><p>这条主要是针对带泛型类的繁琐声明而说的，需要重复书写两次泛型参数：</p><p>Map&lt;String,Date&gt; map = new HashMap&lt;String,Date&gt;();<br>不过自从 java7 开始，这种方式已经被优化过了 —— 对于一个已知类型的变量进行赋值时，由于泛型参数是可以被推导出，所以可以在创建实例时省略掉泛型参数。</p><p>Map&lt;String,Date&gt; map = new HashMap&lt;&gt;();</p><h1 id="除此之外"><a href="#除此之外" class="headerlink" title="除此之外"></a>除此之外</h1><p>以上是《Effective Java》中总结的几条应该使用静态工厂方法代替构造器的原因，除了上面总结的几条之外，静态工厂方法实际上还有更多的优势。</p><h2 id="可以有多个参数相同但名称不同的工厂方法"><a href="#可以有多个参数相同但名称不同的工厂方法" class="headerlink" title="可以有多个参数相同但名称不同的工厂方法"></a>可以有多个参数相同但名称不同的工厂方法</h2><p>构造函数虽然也可以有多个，但是由于函数名已经被固定，所以就要求参数必须有差异时（类型、数量或者顺序）才能够重载了。<br>举例来说：</p><pre><code>class Child{    int age = 10;    int weight = 30;    public Child(int age, int weight) {        this.age = age;        this.weight = weight;    }    public Child(int age) {        this.age = age;    }}</code></pre><p>Child 类有 age 和 weight 两个属性，如代码所示，它已经有了两个构造函数：Child(int age, int weight) 和 Child(int age)，这时候如果我们想再添加一个指定 wegiht 但不关心 age 的构造函数，一般是这样：</p><pre><code>public Child( int weight) {    this.weight = weight;}</code></pre><p>但要把这个构造函数添加到 Child 类中，我们都知道是行不通的，因为 java 的函数签名是忽略参数名称的，所以 Child(int age) 跟 Child(int weight) 会冲突。</p><p>这时候，静态工厂方法就可以登场了。</p><pre><code>class Child{    int age = 10;    int weight = 30;    public static Child newChild(int age, int weight) {        Child child = new Child();        child.weight = weight;        child.age = age;        return child;    }    public static Child newChildWithWeight(int weight) {        Child child = new Child();        child.weight = weight;        return child;    }    public static Child newChildWithAge(int age) {        Child child = new Child();        child.age = age;        return child;    }}</code></pre><p>其中的 newChildWithWeight 和 newChildWithAge，就是两个参数类型相同的的方法，但是作用不同，如此，就能够满足上面所说的类似Child(int age) 跟 Child(int weight)同时存在的需求。<br>（另外，这两个函数名字也是自描述的，相对于一成不变的构造函数更能表达自身的含义，这也是上面所说的第一条优势 —— 『它们有名字』）</p><h2 id="可以减少对外暴露的属性"><a href="#可以减少对外暴露的属性" class="headerlink" title="可以减少对外暴露的属性"></a>可以减少对外暴露的属性</h2><p>软件开发中有一条很重要的经验：对外暴露的属性越多，调用者就越容易出错。所以对于类的提供者，一般来说，应该努力减少对外暴露属性，从而降低调用者出错的机会。</p><p>考虑一下有如下一个 Player 类：</p><pre><code>// Player : Version 1class Player {    public static final int TYPE_RUNNER = 1;    public static final int TYPE_SWIMMER = 2;    public static final int TYPE_RACER = 3;    protected int type;    public Player(int type) {        this.type = type;    }}</code></pre><p>Player 对外提供了一个构造方法，让使用者传入一个 type 来表示类型。那么这个类期望的调用方式就是这样的：</p><pre><code>Player player1 = new Player(Player.TYPE_RUNNER);Player player2 = new Player(Player.TYPE_SWEIMMER);</code></pre><p>但是，我们知道，提供者是无法控制调用方的行为的，实际中调用方式可能是这样的：</p><pre><code>Player player3 = new Player(0);Player player4 = new Player(-1);Player player5 = new Player(10086);</code></pre><p>提供者期望的构造函数传入的值是事先定义好的几个常量之一，但如果不是，就很容易导致程序错误。</p><p>—— 要避免这种错误，使用枚举来代替常量值是常见的方法之一，当然如果不想用枚举的话，使用我们今天所说的主角静态工厂方法也是一个很好的办法。</p><p>插一句：<br>实际上，使用枚举也有一些缺点，比如增大了调用方的成本；如果枚举类成员增加，会导致一些需要完备覆盖所有枚举的调用场景出错等。<br>如果把以上需求用静态工厂方法来实现，代码大致是这样的：</p><pre><code>// Player : Version 2class Player {    public static final int TYPE_RUNNER = 1;    public static final int TYPE_SWIMMER = 2;    public static final int TYPE_RACER = 3;    int type;    private Player(int type) {        this.type = type;    }    public static Player newRunner() {        return new Player(TYPE_RUNNER);    }    public static Player newSwimmer() {        return new Player(TYPE_SWIMMER);    }    public static Player newRacer() {        return new Player(TYPE_RACER);    }}</code></pre><p>注意其中的构造方法被声明为了 private，这样可以防止它被外部调用，于是调用方在使用 Player 实例的时候，基本上就必须通过 newRunner、newSwimmer、newRacer 这几个静态工厂方法来创建，调用方无须知道也无须指定 type 值 —— 这样就能把 type 的赋值的范围控制住，防止前面所说的异常值的情况。</p><p>插一句：<br>严谨一些的话，通过反射仍能够绕过静态工厂方法直接调用构造函数，甚至直接修改一个已创建的 Player 实例的 type 值，但本文暂时不讨论这种非常规情况。</p><h2 id="多了一层控制，方便统一修改"><a href="#多了一层控制，方便统一修改" class="headerlink" title="多了一层控制，方便统一修改"></a>多了一层控制，方便统一修改</h2><p>我们在开发中一定遇到过很多次这样的场景：在写一个界面时，服务端的数据还没准备好，这时候我们经常就需要自己在客户端编写一个测试的数据，来进行界面的测试，像这样：</p><pre><code>// 创建一个测试数据User tester = new User();tester.setName(&quot;隔壁老王&quot;);tester.setAge(25);tester.setDescription(&quot;我住隔壁我姓王！&quot;);// use testerbindUI(tester);……</code></pre><p>要写一连串的测试代码，如果需要测试的界面有多个，那么这一连串的代码可能还会被复制多次到项目的多个位置。</p><p>这种写法的缺点呢，首先是代码臃肿、混乱；其次是万一上线的时候漏掉了某一处，忘记修改，那就可以说是灾难了……</p><p>但是如果你像我一样，习惯了用静态工厂方法代替构造器的话，则会很自然地这么写，先在 User 中定义一个 newTestInstance 方法：</p><pre><code>static class User{    String name ;    int age ;    String description;    public static User newTestInstance() {        User tester = new User();        tester.setName(&quot;隔壁老王&quot;);        tester.setAge(25);        tester.setDescription(&quot;我住隔壁我姓王！&quot;);        return tester;    }}</code></pre><p>然后调用的地方就可以这样写了：</p><pre><code>// 创建一个测试数据User tester = User.newTestInstance();// use testerbindUI(tester);</code></pre><p>是不是瞬间就觉得优雅了很多？！</p><p>而且不只是代码简洁优雅，由于所有测试实例的创建都是在这一个地方，所以在需要正式数据的时候，也只需把这个方法随意删除或者修改一下，所有调用者都会编译不通过，彻底杜绝了由于疏忽导致线上还有测试代码的情况。</p><h1 id="缺点：没有公共或受保护构造方法的类不能被子类化"><a href="#缺点：没有公共或受保护构造方法的类不能被子类化" class="headerlink" title="缺点：没有公共或受保护构造方法的类不能被子类化"></a>缺点：没有公共或受保护构造方法的类不能被子类化</h1><p>例如，要想将 Collections 框架中任何遍历的实现类进行子类化，是不可能的。但是这样也会因祸得福，因为它鼓励程序员使用组合（composition）而不是继承（详见第 18 条），并且是不可变类型锁需要的（详见第 17 条）。</p><h1 id="静态工厂方法的第二个缺点是，程序员很难找到它们"><a href="#静态工厂方法的第二个缺点是，程序员很难找到它们" class="headerlink" title="静态工厂方法的第二个缺点是，程序员很难找到它们"></a>静态工厂方法的第二个缺点是，程序员很难找到它们</h1><p>它们不像构造方法那样在 API 文档中明确的标注出来。因此，对于提供了静态方法而不是构造器的类来说，想要查明如何实例化一个类是十分困难的。</p><p>通过关注类或者接口的文档中静态方法，并且遵守标准的命名习惯，也可以弥补这一劣势。下面是一些静态工厂方法的常用名称。以下清单这是列出了其中的一小部分：</p><p>from —— 类型转换方法，它接受单个参数并返回此类型的相应实例，例如：</p><pre><code>Date d = Date.from(instant);</code></pre><p>of —— 聚合方法，接受多个参数并返回该类型的实例，并把他们合并在一起，例如：</p><pre><code>Set faceCards = EnumSet.of(JACK, QUEEN, KING);</code></pre><p>valueOf —— from 和 to 更为详细的替代 方式，例如：</p><pre><code>BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);</code></pre><p>instance 或 getinstance —— 返回一个由其参数 (如果有的话) 描述的实例，但不能说它具有相同的值，例如：</p><pre><code>StackWalker luke = StackWalker.getInstance(options);</code></pre><p>create 或 newInstance —— 与 instance 或 getInstance 类似，除此之外该方法保证每次调用返回一个新的实例，例如：</p><pre><code>Object newArray = Array.newInstance(classObject, arrayLen);</code></pre><p>getType —— 与 getInstance 类似，但是在工厂方法处于不同的类中的时候使用。getType 中的 Type 是工厂方法返回的对象类型，例如：</p><pre><code>FileStore fs = Files.getFileStore(path);</code></pre><p>newType —— 与 newInstance 类似，但是在工厂方法处于不同的类中的时候使用。newType中的 Type 是工厂方法返回的对象类型，例如：</p><pre><code>BufferedReader br = Files.newBufferedReader(path);</code></pre><p>type —— getType 和 newType 简洁的替代方式，例如：</p><pre><code>List litany = Collections.list(legacyLitany);</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>静态工厂方法和公共构造方法都有它们的用途，并且了解它们的相对优点是值得的。通常，静态工厂更可取，因此避免在没有考虑静态工厂的情况下直接选择使用公共构造方法</p><p>总体来说，『考虑使用静态工厂方法代替构造器』这点，除了有名字、可以用子类等这些语法层面上的优势之外，更多的是在工程学上的意义，它实质上的最主要作用是：能够增大类的提供者对自己所提供的类的控制力。</p><p>作为一个开发者，当我们作为调用方，使用别人提供的类时，如果要使用 new 关键字来为其创建一个类实例，如果对类不是特别熟悉，那么一定是要特别慎重的 —— new 实在是太好用了，以致于它经常被滥用，随时随地的 new 是有很大风险的，除了可能导致性能、内存方面的问题外，也经常会使得代码结构变得混乱。</p><p>而当我们在作为类的提供方时，无法控制调用者的具体行为，但是我们可以尝试使用一些方法来增大自己对类的控制力，减少调用方犯错误的机会，这也是对代码更负责的具体体现。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】 <a href="https://www.diycode.cc/topics/1027" target="_blank" rel="noopener">https://www.diycode.cc/topics/1027</a><br>【2】 <a href="https://www.jianshu.com/p/eb30a388c5fc" target="_blank" rel="noopener">https://www.jianshu.com/p/eb30a388c5fc</a><br>【3】 <a href="https://juejin.im/post/5d6a0652f265da03df5f285d" target="_blank" rel="noopener">https://juejin.im/post/5d6a0652f265da03df5f285d</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;静态静态工厂方法&lt;/p&gt;
    
    </summary>
    
      <category term="2019年12月" scheme="http://yoursite.com/categories/2019%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Design Pattern，Java" scheme="http://yoursite.com/tags/Design-Pattern%EF%BC%8CJava/"/>
    
  </entry>
  
  <entry>
    <title>Effctive-Java阅读笔记I</title>
    <link href="http://yoursite.com/2019/12/30/Effctive-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0I/"/>
    <id>http://yoursite.com/2019/12/30/Effctive-Java阅读笔记I/</id>
    <published>2019-12-30T08:30:12.000Z</published>
    <updated>2020-01-03T07:13:27.873Z</updated>
    
    <content type="html"><![CDATA[<p>第二章阅读：创建和销毁对象：<br>01.考虑使用静态工厂方法替代构造方法<br>02.当构造方法参数过多时使用 builder 模式</p><a id="more"></a><h1 id="考虑使用静态工厂方法替代构造方法"><a href="#考虑使用静态工厂方法替代构造方法" class="headerlink" title="考虑使用静态工厂方法替代构造方法"></a>考虑使用静态工厂方法替代构造方法</h1><p>此处详见设计模式学习笔记III-静态工厂方法。</p><h1 id="当构造方法参数过多时使用-builder-模式"><a href="#当构造方法参数过多时使用-builder-模式" class="headerlink" title="当构造方法参数过多时使用 builder 模式"></a>当构造方法参数过多时使用 builder 模式</h1><p>静态工厂和构造方法都有一个限制：它们不能很好地扩展到很多可选参数的情景。传统上，程序员使用了可伸缩（telescoping constructor）构造方法模式。<br>在这种模式中，首先提供一个只有必需参数的构造方法，接着提供增加了一个可选参数的构造函数，然后提供增加了两个可选参数的构造函数，等等，最终在构造函数中包含所有必需和可选参数。以下就是它在实践中的样子。为了简便起见，只显示了四个可选属性：</p><pre><code>// Telescoping constructor pattern - does not scale well!public class NutritionFacts {    private final int servingSize;  // (mL)            required    private final int servings;     // (per container) required    private final int calories;     // (per serving)   optional    private final int fat;          // (g/serving)     optional    private final int sodium;       // (mg/serving)    optional    private final int carbohydrate; // (g/serving)     optional    public NutritionFacts(int servingSize, int servings) {        this(servingSize, servings, 0);    }    public NutritionFacts(int servingSize, int servings,            int calories) {        this(servingSize, servings, calories, 0);    }    public NutritionFacts(int servingSize, int servings,            int calories, int fat) {        this(servingSize, servings, calories, fat, 0);    }    public NutritionFacts(int servingSize, int servings,            int calories, int fat, int sodium) {        this(servingSize, servings, calories, fat, sodium, 0);    }    public NutritionFacts(int servingSize, int servings,           int calories, int fat, int sodium, int carbohydrate) {        this.servingSize  = servingSize;        this.servings     = servings;        this.calories     = calories;        this.fat          = fat;        this.sodium       = sodium;        this.carbohydrate = carbohydrate;    }}</code></pre><p>当想要创建一个实例时，可以使用包含所有要设置的参数的最短参数列表的构造方法：</p><pre><code>NutritionFacts cocaCola = new NutritionFacts(240, 8, 100, 0, 35, 27);</code></pre><p>通常情况下，这个构造方法的调用需要许多你不想设置的参数，但是你不得不为它们传递一个值。 在这种情况下，我们为 fat 属性传递了 0 值。「只有」六个参数可能看起来并不那么糟糕，但随着参数数量的增加，它很快就会失控。</p><p>　　简而言之，可伸缩构造方法模式是有效的，但是当有很多参数时，很难编写客户端代码，而且很难读懂它。</p><p>当在构造方法中遇到许多可选参数时，另一种选择是 JavaBeans 模式，在这种模式中，调用一个无参的构造方法来创建对象，然后调用 setter 方法来设置每个必需的参数和可选参数：</p><pre><code>// JavaBeans Pattern - allows inconsistency, mandates mutabilitypublic class NutritionFacts {// Parameters initialized to default values (if any)private int servingSize  = -1; // Required; no default valueprivate int servings     = -1; // Required; no default valueprivate int calories     = 0;private int fat          = 0;private int sodium       = 0;private int carbohydrate = 0;public NutritionFacts() { }// Setterspublic void setServingSize(int val)  { servingSize = val; }public void setServings(int val)    { servings = val; }public void setCalories(int val)    { calories = val; }public void setFat(int val)         { fat = val; }public void setSodium(int val)      { sodium = val; }public void setCarbohydrate(int val) { carbohydrate = val; }}</code></pre><p>这种模式没有伸缩构造方法模式的缺点。有点冗长，但创建实例很容易，并且易于阅读所生成的代码:</p><pre><code>NutritionFacts cocaCola = new NutritionFacts();cocaCola.setServingSize(240);cocaCola.setServings(8);cocaCola.setCalories(100);cocaCola.setSodium(35);cocaCola.setCarbohydrate(27);</code></pre><p>JavaBeans 模式本身有严重的缺陷。由于构造方法被分割成了多次调用，所以在构造过程中 JavaBean 可能处于不一致的状态。该类没有通过检查构造参数参数的有效性来强制一致性的选项。在不一致的状态下尝试使用对象可能会导致一些错误，这些错误与平常代码的BUG很是不同，因此很难调试。一个相关的缺点是，JavaBeans 模式排除了让类不可变的可能性（详见第 17 条），并且需要程序员增加工作以确保线程安全。</p><p>　　通过在对象构建完成时手动「冻结」对象，并且不允许它在解冻之前使用，可以减少这些缺点，但是这种变体在实践中很难使用并且很少使用。 而且，在运行时会导致错误，因为编译器无法确保程序员会在使用对象之前调用 freeze 方法。</p><p>　　幸运的是，还有第三种选择，它结合了可伸缩构造方法模式的安全性和 JavaBean 模式的可读性。 它是 Builder 模式（建造者模式）的一种形式。客户端不直接构造所需的对象，而是调用一个包含所有必需参数的构造方法 (或静态工厂)得到获得一个 builder 对象。以下是它在实践中的示例：</p><pre><code>// Builder Patternpublic class NutritionFacts {    private final int servingSize;    private final int servings;    private final int calories;    private final int fat;    private final int sodium;    private final int carbohydrate;    public static class Builder {        // Required parameters        private final int servingSize;        private final int servings;        // Optional parameters - initialized to default values        private int calories      = 0;        private int fat           = 0;        private int sodium        = 0;        private int carbohydrate  = 0;        public Builder(int servingSize, int servings) {            this.servingSize = servingSize;            this.servings    = servings;        }        public Builder calories(int val) {            calories = val;                  return this;        }        public Builder fat(int val) {           fat = val;                      return this;        }        public Builder sodium(int val) {           sodium = val;                   return this;        }        public Builder carbohydrate(int val) {           carbohydrate = val;             return this;        }        public NutritionFacts build() {            return new NutritionFacts(this);        }    }    private NutritionFacts(Builder builder) {        servingSize  = builder.servingSize;        servings     = builder.servings;        calories     = builder.calories;        fat          = builder.fat;        sodium       = builder.sodium;        carbohydrate = builder.carbohydrate;    }}</code></pre><p>然后，客户端调用 builder 对象的与 setter 相似方法来设置你想设置的可选参数。最后，客户端调用builder对象的一个无参的 build 方法来生成对象，该对象通常是不可变的。Builder 通常是它所构建的类的一个静态成员类（详见第 24 条）。<br>　　NutritionFacts 类是不可变的，所有的参数默认值都在一个地方。builder 的 setter 方法返回 builder 本身，这样就可以进行链式调用，从而生成一个流畅的 API。下面是客户端代码的示例：</p><pre><code>NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8).calories(100).sodium(35).carbohydrate(27).build();</code></pre><p>为了简洁起见，省略了有效性检查。 要尽快检测无效参数，检查 builder 的构造方法和方法中的参数有效性。 在 build 方法调用的构造方法中检查包含多个参数的不变性。为了确保这些不变性不受攻击，在从 builder 复制参数后对对象属性进行检查（详见第 50 条）。 如果检查失败，则抛出 IllegalArgumentException 异常（详见第 72 条），其详细消息指示哪些参数无效（详见第 75 条）。</p><p>Builder 模式非常适合类层次结构。 使用平行层次的 builder，每个builder嵌套在相应的类中。 抽象类有抽象的 builder；具体的类有具体的 builder。 例如，考虑代表各种比萨饼的根层次结构的抽象类：</p><pre><code>// Builder pattern for class hierarchiesimport java.util.EnumSet;import java.util.Objects;import java.util.Set;public abstract class Pizza {  //配料枚举：火腿，蘑菇，洋葱，辣椒，香肠    public enum Topping {HAM, MUSHROOM, ONION, PEPPER, SAUSAGE}    final Set&lt;Topping&gt; toppings;    abstract static class Builder&lt;T extends Builder&lt;T&gt;&gt; {        EnumSet&lt;Topping&gt; toppings = EnumSet.noneOf(Topping.class);        public T addTopping(Topping topping) {            toppings.add(Objects.requireNonNull(topping));            return self();        }        abstract Pizza build();        // Subclasses must override this method to return &quot;this&quot;        protected abstract T self();    }    Pizza(Builder&lt;?&gt; builder) {        toppings = builder.toppings.clone(); // See Item 50    }}</code></pre><p>请注意，Pizza.Builder 是一个带有递归类型参数（ recursive type parameter）（详见第 30 条）的泛型类型。 这与抽象的 self 方法一起，允许方法链在子类中正常工作，而不需要强制转换。 Java 缺乏自我类型的这种变通解决方法被称为模拟自我类型（simulated self-type）。</p><p>　　这里有两个具体的 Pizza 的子类，其中一个代表标准的纽约风格的披萨，另一个是半圆形烤乳酪馅饼。前者有一个所需的尺寸参数，而后者则允许指定酱汁是否应该在里面或在外面：</p><pre><code>import java.util.Objects;public class NyPizza extends Pizza {    public enum Size { SMALL, MEDIUM, LARGE }    private final Size size;    public static class Builder extends Pizza.Builder&lt;Builder&gt; {        private final Size size;        public Builder(Size size) {            this.size = Objects.requireNonNull(size);        }        @Override public NyPizza build() {            return new NyPizza(this);        }        @Override protected Builder self() {            return this;        }    }    private NyPizza(Builder builder) {        super(builder);        size = builder.size;    }}public class Calzone extends Pizza {    private final boolean sauceInside; //内部的酱料    public static class Builder extends Pizza.Builder&lt;Builder&gt; {        private boolean sauceInside = false; // Default        public Builder sauceInside() {            sauceInside = true;            return this;        }        @Override public Calzone build() {            return new Calzone(this);        }        @Override protected Builder self() {            return this;        }    }    private Calzone(Builder builder) {        super(builder);        sauceInside = builder.sauceInside;    }}</code></pre><p>请注意，每个子类 builder 中的 build 方法被声明为返回正确的子类：NyPizza.Builder 的 build 方法返回 NyPizza，而 Calzone.Builder 中的 build 方法返回 Calzone。 这种技术，其一个子类的方法被声明为返回在超类中声明的返回类型的子类型，称为协变返回类型（covariant return typing）。 它允许客户端使用这些 builder，而不需要强制转换。</p><p>　　这些「分层 builder（hierarchical builders）」的客户端代码基本上与简单的 NutritionFacts builder 的代码相同。为了简洁起见，下面显示的示例客户端代码假设枚举常量的静态导入：</p><pre><code>NyPizza pizza = new NyPizza.Builder(SMALL)        .addTopping(SAUSAGE).addTopping(ONION).build();Calzone calzone = new Calzone.Builder()        .addTopping(HAM).sauceInside().build();</code></pre><p>builder 对构造方法的一个微小的优势是，builder 可以有多个可变参数，因为每个参数都是在它自己的方法中指定的。或者，builder 可以将传递给多个调用的参数聚合到单个属性中，如前面的 addTopping 方法所演示的那样。</p><p>　　Builder 模式非常灵活。 单个 builder 可以重复使用来构建多个对象。 builder 的参数可以在构建方法的调用之间进行调整，以改变创建的对象。 builder 可以在创建对象时自动填充一些属性，例如每次创建对象时增加的序列号。</p><p>　　Builder 模式也有缺点。为了创建对象，首先必须创建它的 builder。虽然创建这个 builder 的成本在实践中不太可能被注意到，但在看中性能的场合下这可能就是一个问题。而且，builder 模式比伸缩构造方法模式更冗长，因此只有在有足够的参数时才值得使用它，比如四个或更多。但是请记住，你可能在以后会想要添加更多的参数。但是，如果你一开始是使用的构造方法或静态工厂，当类演化到参数数量失控的时候再转到Builder模式，过时的构造方法或静态工厂就会面临尴尬的处境。因此，通常最好从一开始就创建一个 builder。</p><p>　　总而言之，当设计类的构造方法或静态工厂的参数超过几个时，Builder 模式是一个不错的选择，特别是如果许多参数是可选的或相同类型的。builder模式客户端代码比使用伸缩构造方法（telescoping constructors）更容易读写，并且builder模式比 JavaBeans 更安全。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="https://sjsdfg.github.io/effective-java-3rd-chinese/#/" target="_blank" rel="noopener">https://sjsdfg.github.io/effective-java-3rd-chinese/#/</a><br>【2】<a href="https://lingcoder.github.io/OnJava8/#/" target="_blank" rel="noopener">https://lingcoder.github.io/OnJava8/#/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二章阅读：创建和销毁对象：&lt;br&gt;01.考虑使用静态工厂方法替代构造方法&lt;br&gt;02.当构造方法参数过多时使用 builder 模式&lt;/p&gt;
    
    </summary>
    
      <category term="2019年12月" scheme="http://yoursite.com/categories/2019%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Scala学习笔记V</title>
    <link href="http://yoursite.com/2019/12/27/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0V/"/>
    <id>http://yoursite.com/2019/12/27/Scala学习笔记V/</id>
    <published>2019-12-27T06:08:12.000Z</published>
    <updated>2019-12-27T06:29:21.578Z</updated>
    
    <content type="html"><![CDATA[<p>scala中下划线_的用途</p><a id="more"></a><h1 id="初始化。"><a href="#初始化。" class="headerlink" title="初始化。"></a>初始化。</h1><pre><code>object Sample { var name:String=_ def main (args: Array[String]){ name=&quot;hello world&quot;  println(name) }</code></pre><p>在这里，name也可以声明为null，例：var name:String=null。这里的下划线和null的作用是一样的。</p><h1 id="引入时"><a href="#引入时" class="headerlink" title="引入时"></a>引入时</h1><pre><code>import math._object Sample {   def main (args: Array[String]){    println(BigInt(123))   }}</code></pre><p>这里的math._就相当于Java中的math.*; 即“引用包中的所有内容”。</p><h1 id="集合中使用。（最典型，最常用）"><a href="#集合中使用。（最典型，最常用）" class="headerlink" title="集合中使用。（最典型，最常用）"></a>集合中使用。（最典型，最常用）</h1><pre><code> object Sample {   def main (args: Array[String]){    val newArry= (1 to 10).map(_*2)   println(newArry)   }}</code></pre><p>这里的下划线代表了集合中的“某（this）”一个元素。这个用法很常见，在foreach等语句中也可以使用。</p><h1 id="模式匹配。"><a href="#模式匹配。" class="headerlink" title="模式匹配。"></a>模式匹配。</h1><pre><code> object Sample {   def main (args: Array[String]){     val value=&quot;a&quot;  val result=  value match{       case &quot;a&quot; =&gt; 1       case &quot;b&quot; =&gt; 2       case _ =&gt;&quot;result&quot;     }     println(result)   }}</code></pre><p>在这里的下划线相当于“others”的意思，就像Java  switch语句中的“default”。</p><p>还有一种写法，是被Some“包”起来的，说明Some里面是有值的，而不是None。<br>    object Sample {<br>      def main (args: Array[String]){<br>        val value=Some(“a”)<br>        val result=  value match{<br>          case Some(_) =&gt; 1<br>          case _ =&gt;”result”<br>        }<br>        println(result)<br>      }</p><p>还有一种表示队列</p><pre><code>object Sample {  def main (args: Array[String]){    val value=1 to 5    val result=  value match{      case Seq(_,_*) =&gt; 1      case _ =&gt;&quot;result&quot;    }    println(result)  }}</code></pre><h1 id="函数中使用。"><a href="#函数中使用。" class="headerlink" title="函数中使用。"></a>函数中使用。</h1><pre><code>object Sample {   def main (args: Array[String]){    val set=setFunction(3.0,_:Double)     println(set(7.1))   }  def setFunction(parm1:Double,parm2:Double): Double = parm1+parm2}</code></pre><p>这是Scala特有的“偏函数”用法。</p><h1 id="元组Tuple。（如果这也算是的话）"><a href="#元组Tuple。（如果这也算是的话）" class="headerlink" title="元组Tuple。（如果这也算是的话）"></a>元组Tuple。（如果这也算是的话）</h1><pre><code>object Sample {   def main (args: Array[String])={     val value=(1,2)     print(value._1)   }}</code></pre><h1 id="传参。"><a href="#传参。" class="headerlink" title="传参。"></a>传参。</h1><pre><code>object Sample {   def main (args: Array[String])={    val result=sum(1 to 5:_*)     println(result)   }  def sum(parms:Int*)={    var result=0    for(parm &lt;- parms)result+=parm    result  }}</code></pre><p>当函数接收的参数不定长的时候，假如你想输入一个队列，可以在一个队列后加入“:_*”，因此，这里的“1 to 5”也可以改写为：“Seq(1,2,3,4,5)”。这算是一个小的用法吧</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://blog.csdn.net/i6448038/article/details/50017427" target="_blank" rel="noopener">https://blog.csdn.net/i6448038/article/details/50017427</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;scala中下划线_的用途&lt;/p&gt;
    
    </summary>
    
      <category term="2019年12月" scheme="http://yoursite.com/categories/2019%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记XII</title>
    <link href="http://yoursite.com/2019/12/24/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0XII/"/>
    <id>http://yoursite.com/2019/12/24/Java学习笔记XII/</id>
    <published>2019-12-24T03:21:12.000Z</published>
    <updated>2019-12-25T08:52:45.588Z</updated>
    
    <content type="html"><![CDATA[<p>使用Java批量转换文件夹中的文件编码格式，删除文件中的代码</p><a id="more"></a><p>用Java将某个文件夹中UTF-8格式的文件批量转换为GBK格式的文件，代码如下：</p><p>   private static String sourcePath = “/Users/liyiye/Documents/课程代码”;// 文件夹源路径<br>   private static String destPath = “/Users/liyiye/Documents/ANSI格式课程代码”;<br>   private static void utf8ToANSI(){<br>       try {<br>           File sourceDirectory = new File(sourcePath);<br>           File destDirectory = new File(destPath);<br>           if (!sourceDirectory.isDirectory()) {<br>               return;<br>           }<br>           // 获取文件夹中的所有.cpp文件，包括所有子级文件夹中的文件<br>           Collection<file> files = FileUtils.listFiles(sourceDirectory, new String[] { “cpp”, “CPP” }, true);<br>           for (File file : files) {<br>               String absolutePath = file.getAbsolutePath();<br>               String newDir = absolutePath.replace(sourceDirectory.getName(), destDirectory.getName());<br>               // 把单个文件从utf-8编码转化到gbk编码，生成新文件，可以自动创建父级目录<br>               FileUtils.writeLines(new File(newDir), “GBK”, FileUtils.readLines(file, “UTF-8”));<br>           }<br>           // 删除源目录,子文件都删除<br>           // FileUtils.deleteQuietly(sourceDirectory);<br>           // 把生成文件目录重命名成源目录名<br>           destDirectory.renameTo(new File(sourceDirectory.getAbsolutePath()));<br>           System.out.println(“success”);<br>       } catch (IOException e) {<br>           e.printStackTrace();<br>       }<br>   }</file></p><p>批量删除代码中的注释</p><pre><code>private static int count = 0;/** * 删除文件中的各种注释，包含//、/* * /等 * * @param charset *            文件编码 * @param file *            文件 */public static void clearComment(File file, String charset) {    try {        // 递归处理文件夹        if (!file.exists()) {            return;        }        if (file.isDirectory()) {            File[] files = file.listFiles();            for (File f : files) {                clearComment(f, charset); // 递归调用            }            return;        } else if (!file.getName().endsWith(&quot;.cpp&quot;)) {            // 非java文件直接返回            return;        }        System.out.println(&quot;-----开始处理文件：&quot; + file.getAbsolutePath());        // 根据对应的编码格式读取        BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(file), charset));        StringBuffer content = new StringBuffer();        String tmp = null;        while ((tmp = reader.readLine()) != null) {            content.append(tmp);            content.append(&quot;\n&quot;);        }        reader.close();        String target = content.toString();        // String s =        // target.replaceAll(&quot;\\/\\/[^\\n]*|\\/\\*([^\\*^\\/]*|[\\*^\\/*]*|[^\\**\\/]*)*\\*\\/&quot;,        // &quot;&quot;); //本段正则摘自网上，有一种情况无法满足（/* ...**/），略作修改        String s = target.replaceAll(&quot;\\/\\/[^\\n]*|\\/\\*([^\\*^\\/]*|[\\*^\\/*]*|[^\\**\\/]*)*\\*+\\/&quot;, &quot;&quot;);        // System.out.println(s);        // 使用对应的编码格式输出        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), charset));        out.write(s);        out.flush();        out.close();        count++;        System.out.println(&quot;-----文件处理完成---&quot; + count);    } catch (Exception e) {        e.printStackTrace();    }}public static void clearComment(String filePath, String charset) {    clearComment(new File(filePath), charset);}public static void clearComment(String filePath) {    clearComment(new File(filePath), &quot;GBK&quot;);}public static void clearComment(File file) {    clearComment(file, &quot;GBK&quot;);}public  static   void  main(String[] args){    clearComment(destPath);}</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="https://blog.csdn.net/qq1032355091/article/details/51803496" target="_blank" rel="noopener">https://blog.csdn.net/qq1032355091/article/details/51803496</a><br>【2】<a href="https://www.cnblogs.com/hfultrastrong/p/7689630.html" target="_blank" rel="noopener">https://www.cnblogs.com/hfultrastrong/p/7689630.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Java批量转换文件夹中的文件编码格式，删除文件中的代码&lt;/p&gt;
    
    </summary>
    
      <category term="2019年12月" scheme="http://yoursite.com/categories/2019%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记XIII</title>
    <link href="http://yoursite.com/2019/12/24/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0XIII/"/>
    <id>http://yoursite.com/2019/12/24/Java学习笔记XIII/</id>
    <published>2019-12-24T03:21:12.000Z</published>
    <updated>2020-01-13T10:51:29.576Z</updated>
    
    <content type="html"><![CDATA[<p>Java中Calendar，LocalDateTime的用法和区别</p><a id="more"></a><p>例如使用LocalDateTime：</p><pre><code>private static void localDateTimeTest() throws ModuleBusinessException{    LocalDateTime currentTime=LocalDateTime.now();    LocalDateTime suspendLoanTime=LocalDateTime.of(2020,1,23,10,0,0);    LocalDateTime recoverLoanTime=LocalDateTime.of(2020,1,31,9,59,59);    System.out.println(currentTime);    System.out.println(suspendLoanTime);    System.out.println(recoverLoanTime);    if(currentTime.isAfter(suspendLoanTime) &amp;&amp; currentTime.isBefore(recoverLoanTime)){        throw new ModuleBusinessException(&quot;尊敬的用户您好，1月23日10:00-1月31日9:59暂停XX，1月31日10:00恢复XX，届时会短信通知到您，需要您再次来到APP继续XX&quot;);    }}</code></pre><p>而使用Calendar时有个容易被坑的地方，calendar.set()中月份字段从0开始：</p><pre><code>private static void dateTimeTest() throws ModuleBusinessException {    Calendar calendar=Calendar.getInstance();    Date currentTime=calendar.getTime();    calendar.set(2020,0,23,10,0,0);//（月份字段从0开始）    Date suspendLoanTime=calendar.getTime();    calendar.set(2020,0,31,9,59,59);//（月份字段从0开始）    Date recoverLoanTime=calendar.getTime();    System.out.println(currentTime);    System.out.println(suspendLoanTime);    System.out.println(recoverLoanTime);    if(!currentTime.after(suspendLoanTime) || !currentTime.before(recoverLoanTime)){        throw new ModuleBusinessException(&quot;尊敬的用户您好，1月23日10:00-1月31日9:59暂停XX，1月31日10:00恢复XX，届时会短信通知到您，需要您再次来到APP继续XX&quot;);    }}</code></pre><h1 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h1><p>【1】</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java中Calendar，LocalDateTime的用法和区别&lt;/p&gt;
    
    </summary>
    
      <category term="2019年12月" scheme="http://yoursite.com/categories/2019%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Scala学习笔记IV</title>
    <link href="http://yoursite.com/2019/12/23/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0IV/"/>
    <id>http://yoursite.com/2019/12/23/Scala学习笔记IV/</id>
    <published>2019-12-23T10:08:12.000Z</published>
    <updated>2019-12-23T10:19:25.471Z</updated>
    
    <content type="html"><![CDATA[<p>数据库连接和事务处理</p><a id="more"></a><h1 id="Session-管理"><a href="#Session-管理" class="headerlink" title="Session 管理"></a>Session 管理</h1><p>现在有了一个数据库对象可以打开一个数据库（Slick 函数库封装了一个 Session 对象）</p><p>Database 的 withSession 方法，创建一个 Session 对象，它可以传递给一个函数，函数返回时自动关闭这个 Session 对象，如果你使用连接池，关闭 Session 对象，自动将连接退回连接池。</p><pre><code>val query = for (c &lt;- coffees) yield c.nameval result = db.withSession {    session =&gt;    query.list()( session )}</code></pre><p>可以看到，我们可以在 withSession 之外定义查询，只有在实际执行查询时才需要一个 Session 对象，要注意的是 Session 的缺省模式为自动提交（auto-commit )模式。每个数据库指令（比如 insert )都自动提交给数据库。 如果需要将几个指令作为一个整体，那么就需要使用事务处理（Transaction） 上面的例子，我们在执行查询时，明确指明了 session 对象，你可以使用隐含对象来避免这种情况，比如：</p><pre><code>val query = for (c &lt;- coffees) yield c.nameval result = db.withSession {    implicit session =&gt;    query.list // &lt;- takes session implicitly}// query.list // &lt;- would not compile, no implicit value of type Session</code></pre><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="http://wiki.jikexueyuan.com/project/slick-guide/database-and-transaction-processing.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/slick-guide/database-and-transaction-processing.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据库连接和事务处理&lt;/p&gt;
    
    </summary>
    
      <category term="2019年12月" scheme="http://yoursite.com/categories/2019%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
</feed>
