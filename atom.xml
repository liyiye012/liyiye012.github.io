<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-18T03:22:30.118Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot学习笔记I</title>
    <link href="http://yoursite.com/2019/07/17/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0I/"/>
    <id>http://yoursite.com/2019/07/17/SpringBoot学习笔记I/</id>
    <published>2019-07-17T07:30:12.000Z</published>
    <updated>2019-07-18T03:22:30.118Z</updated>
    
    <content type="html"><![CDATA[<p>总结整理在学习SpringBoot的过程中遇到的问题和解决方案。</p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>忙忙碌碌的暑假结束了，虽然可以算得上十分充实，不过在学习新知识提高自己这一方面却做的并不尽如人意，之前制定的学习计划大都被其它各种计划所取代，从屈指可数的博客更新就能看出来。<br>随着步入职场，自我学习变得更加重要，之前这段时间的状态不能再继续下去。综上所述，我要继续开始更新博客了。</p><h1 id="SrpingBoot简介"><a href="#SrpingBoot简介" class="headerlink" title="SrpingBoot简介"></a>SrpingBoot简介</h1><p>#</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结整理在学习SpringBoot的过程中遇到的问题和解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年7月" scheme="http://yoursite.com/categories/2019%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>NOIP普及组</title>
    <link href="http://yoursite.com/2019/07/17/NOIP%E6%99%AE%E5%8F%8A%E7%BB%84/"/>
    <id>http://yoursite.com/2019/07/17/NOIP普及组/</id>
    <published>2019-07-17T04:30:12.000Z</published>
    <updated>2019-07-18T03:37:32.613Z</updated>
    
    <content type="html"><![CDATA[<p>介绍NOIP考察形式和考察知识点，制定相应学习计划。</p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍NOIP考察形式和考察知识点，制定相应学习计划。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年7月18日" scheme="http://yoursite.com/categories/2019%E5%B9%B47%E6%9C%8818%E6%97%A5/"/>
    
    
      <category term="NOIP" scheme="http://yoursite.com/tags/NOIP/"/>
    
  </entry>
  
  <entry>
    <title>Linux配置问题小结</title>
    <link href="http://yoursite.com/2019/06/03/Linux%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2019/06/03/Linux配置问题小结/</id>
    <published>2019-06-03T04:47:45.000Z</published>
    <updated>2019-07-17T03:53:33.993Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux配置问题小结"><a href="#Linux配置问题小结" class="headerlink" title="Linux配置问题小结"></a>Linux配置问题小结</h1><p>记录Linux配置问题的解决方案，在Ubuntu 18.04中安装terminator 并在右键菜单中添加open in termintor;解决了搜狗输入法在Ubuntu 18.04 中无法安装和安装后无法使用的问题;解决了Linux下无线网卡rtl8821CE/rtl8723ce驱动无法驱动的问题。</p><a id="more"></a><h2 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h2><ol><li>Ubuntu 18.04 安装terminator 并在右键菜单中添加open in termintor</li><li>解决了搜狗输入法在Ubuntu 18.04 中无法安装和安装后无法使用的问题</li><li>解决了Linux下无线网卡rtl8821CE/rtl8723ce驱动无法驱动的问题。</li></ol><h2 id="Terminator安装和右键菜单添加解决方案"><a href="#Terminator安装和右键菜单添加解决方案" class="headerlink" title="Terminator安装和右键菜单添加解决方案"></a>Terminator安装和右键菜单添加解决方案</h2><p>  题外话，安利下terminator，是Linux环境下一款非常赞的命令行管理工具，前段时间微软宣布推出名为Windows Terminal的新款命令行工具，在个人看来也是姗姗来迟的将terminator能实现的功能在windows中实现了。</p><p>  安装terminator</p><pre><code>sudo apt install terminator</code></pre><p>  网上大多用dconf系统配置编辑器将terminator设为默认，但在我的系统中这样在文件位置中右键打开时还是只能打开默认的终端，用起来很不方便，直到找到了这种方法（<a href="https://blog.csdn.net/bestBT/article/details/81221378）。" target="_blank" rel="noopener">https://blog.csdn.net/bestBT/article/details/81221378）。</a><br>  安装Nautilus-actions</p><pre><code>sudo add-apt-repository ppa:daniel-marynicz/filemanager-actionssudo apt-get install filemanager-actions-nautilus-extension</code></pre><p>使用fma-config-tool 来配置。<br>1.新建动作，在action（动作）界面中勾选第二项Display item in location context menu。在Context label中输入想写的名字“在Terminator中打开”。<br>2.在Command（命令）界面中输入路径/usr/bin/terminator，参数中输入–working-directory=%d/%b。<br>3.这样操作完在terminator中打开还在右键的二级菜单中，所以点右上角齿轮标志（编辑您的首选项），在运行时首选项-》Nautilus菜单布局中取消勾选Create a root “FileManager-Actions” menu，这样就可以愉快的使用Terminator了。</p><h2 id="搜狗拼音输入法安装问题解决方案"><a href="#搜狗拼音输入法安装问题解决方案" class="headerlink" title="搜狗拼音输入法安装问题解决方案"></a>搜狗拼音输入法安装问题解决方案</h2><p>一开始嫌麻烦所以用Linux自带的Ibus系统下的输入法，但各种问题实在忍不了，所以还是装了搜狗拼音法，中间遇到几个问题只找到这个靠谱的解决方法（<a href="https://ywnz.com/linuxjc/1476.html）。" target="_blank" rel="noopener">https://ywnz.com/linuxjc/1476.html）。</a></p><p>在根据指导方法安装搜狗拼音输入法后，会遇到很多依赖问题，一路折腾后会发现搜狗拼音依赖的fcitx-libs-qt这个包在ubuntu18.04的源里面是不存在的。替代品似乎是libfcitx-qt0，但也很难搞。</p><h3 id="下载旧版"><a href="#下载旧版" class="headerlink" title="下载旧版"></a>下载旧版</h3><p>搜狗官方的最新版（sogoupinyin_2.2.0.0102_amd64.deb）是不能用的，原因不作深究。需要下载一个旧版本（sogoupinyin_2.1.0.0086_amd64.deb）。<br>将该deb包放置于一个空目录。</p><h3 id="创建软件包目录"><a href="#创建软件包目录" class="headerlink" title="创建软件包目录"></a>创建软件包目录</h3><pre><code>mkdir -p extract/DEBIAN</code></pre><h3 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h3><pre><code>dpkg-deb -x sogoupinyin_2.1.0.0086_amd64.deb extract/dpkg-deb -e sogoupinyin_2.1.0.0086_amd64.deb extract/DEBIAN</code></pre><h3 id="修改control文件"><a href="#修改control文件" class="headerlink" title="修改control文件"></a>修改control文件</h3><p>用任意文本编辑器打开extract/DEBIAN/control 找到Depends行，删除fcitx-libs和fcitx-libs-qt，保存退出。<br>其中要找的Depends行长这个样子</p><pre><code>Depends: fcitx (&gt;= 1:4.2.8.3-3~), fcitx-frontend-gtk2, fcitx-frontend-gtk3, fcitx-frontend-qt4, fcitx-module-kimpanel, im-config, libopencc2 | libopencc1, lsb-release, unzip, x11-utils, libc6 (&gt;= 2.8), libgcc1 (&gt;= 1:4.1.1), libgdk-pixbuf2.0-0 (&gt;= 2.22.0), libglib2.0-0 (&gt;= 2.16.0), libidn11 (&gt;= 1.13), libnotify4 (&gt;= 0.7.0), libqt4-dbus (&gt;= 4:4.8.0), libqt4-declarative (&gt;= 4:4.8.0), libqt4-network (&gt;= 4:4.8.0), libqtcore4 (&gt;= 4:4.8.0), libqtgui4 (&gt;= 4:4.8.0), libstdc++6 (&gt;= 4.6), libx11-6, zlib1g (&gt;= 1:1.2.0)</code></pre><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><pre><code>mkdir builddpkg-deb -b extract/ build/</code></pre><p>执行完毕build目录下会生成一个新的deb包。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>先彻底卸载掉搜狗输入法，并删除以下配置文件：</p><p>.sogouinput</p><p>.config/fcitx</p><p>.config/sogou-qimpanel</p><p>.config/SogouPY</p><p>.config/SogouPY.users</p><p>.config/fcitx-qimpanel</p><p>然后安装我们重新打包的输入法即可。重启之后，搜狗输入法恢复正常。<br>最后要记得在设置-》区域和语言-》管理已安装的语言-》语言支持-》语言-》键盘输入法系统中选择Fcitx系统，因为搜狗输入法等都是在Fcitx系统框架下的。</p><h2 id="LINUX下无线网卡rtl8821CE-rtl8723de驱动无法驱动解决办法"><a href="#LINUX下无线网卡rtl8821CE-rtl8723de驱动无法驱动解决办法" class="headerlink" title="LINUX下无线网卡rtl8821CE/rtl8723de驱动无法驱动解决办法"></a>LINUX下无线网卡rtl8821CE/rtl8723de驱动无法驱动解决办法</h2><h3 id="1-确保linux内核版本大于-4-14"><a href="#1-确保linux内核版本大于-4-14" class="headerlink" title="1. 确保linux内核版本大于 4.14"></a>1. 确保linux内核版本大于 4.14</h3><p>  如何查看linux 内核版本 ：终端 uname -sr</p><p>  如果内核版本低于 4.14：升级linux内核 ubuntu可以参照 <a href="https://www.linuxidc.com/Linux/2017-03/141940.html" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2017-03/141940.html</a></p><p>  升级完记得重启</p><h3 id="2-下载linux中8821CE-rtl8723de的驱动源码"><a href="#2-下载linux中8821CE-rtl8723de的驱动源码" class="headerlink" title="2. 下载linux中8821CE/rtl8723de的驱动源码"></a>2. 下载linux中8821CE/rtl8723de的驱动源码</h3><p>git原地址（rtl8821CE）：<a href="https://github.com/endlessm/linux/tree/master/drivers/net/wireless/rtl8821ce" target="_blank" rel="noopener">https://github.com/endlessm/linux/tree/master/drivers/net/wireless/rtl8821ce</a></p><p>git原地址（rtl8723de）：<a href="https://github.com/endlessm/linux/tree/master/drivers/net/wireless/rtl8723de" target="_blank" rel="noopener">https://github.com/endlessm/linux/tree/master/drivers/net/wireless/rtl8723de</a></p><p>或者本地下载 <a href="https://free-1253146430.cos.ap-shanghai.myqcloud.com/rtl8821ce.zip" target="_blank" rel="noopener">https://free-1253146430.cos.ap-shanghai.myqcloud.com/rtl8821ce.zip</a></p><p>（rtl8723de 的话 自己 去git上下吧）</p><h3 id="3-编译驱动"><a href="#3-编译驱动" class="headerlink" title="3.编译驱动"></a>3.编译驱动</h3><p>  <strong><em>解压rtl8821ce.zip</em></strong></p><p>  <strong><em>修改文件Makefile</em></strong></p><pre><code>export TopDIR ?= $(srctree)/drivers/net/wireless/rtl8821ce</code></pre><p>从这行 “export TopDIR ?= 后面改成当前目录 例如我的：</p><pre><code>export TopDIR ?= /home/horsun/Downloads/rtl8821ce</code></pre><p><strong><em>保存修改</em></strong></p><p>  分别进行：</p><pre><code>makesudo make installsudo modprobe -a 8821ce</code></pre><p>遇到问题</p><pre><code>modprobe: ERROR: could not insert &apos;8812au&apos;: Exec format error</code></pre><p><strong><em>执行</em></strong></p><pre><code>make cleanmakesudo make installsudo modprobe 8812au</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux配置问题小结&quot;&gt;&lt;a href=&quot;#Linux配置问题小结&quot; class=&quot;headerlink&quot; title=&quot;Linux配置问题小结&quot;&gt;&lt;/a&gt;Linux配置问题小结&lt;/h1&gt;&lt;p&gt;记录Linux配置问题的解决方案，在Ubuntu 18.04中安装terminator 并在右键菜单中添加open in termintor;解决了搜狗输入法在Ubuntu 18.04 中无法安装和安装后无法使用的问题;解决了Linux下无线网卡rtl8821CE/rtl8723ce驱动无法驱动的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年6月" scheme="http://yoursite.com/categories/2019%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>操作系统基础概念I</title>
    <link href="http://yoursite.com/2019/06/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5I/"/>
    <id>http://yoursite.com/2019/06/02/操作系统基础概念I/</id>
    <published>2019-06-02T02:42:12.000Z</published>
    <updated>2019-07-17T03:53:33.996Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统基础概念I"><a href="#操作系统基础概念I" class="headerlink" title="操作系统基础概念I"></a>操作系统基础概念I</h1><p>总结操作系统基础概念</p><a id="more"></a><h2 id="（一）请分别简单说一说进程和线程以及它们的区别。"><a href="#（一）请分别简单说一说进程和线程以及它们的区别。" class="headerlink" title="（一）请分别简单说一说进程和线程以及它们的区别。"></a>（一）请分别简单说一说进程和线程以及它们的区别。</h2><h3 id="1-进程是资源分配的基本单位"><a href="#1-进程是资源分配的基本单位" class="headerlink" title="1.进程是资源分配的基本单位"></a>1.进程是资源分配的基本单位</h3><p>进程是具有一定功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源调度和分配的基本单位。</p><h3 id="2-线程是独立调度的基本单位"><a href="#2-线程是独立调度的基本单位" class="headerlink" title="2.线程是独立调度的基本单位"></a>2.线程是独立调度的基本单位</h3><p>线程是进程的实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。<br>一个进程可以有多个线程，多个线程也可以并发执行</p><h3 id="3-区别"><a href="#3-区别" class="headerlink" title="3.区别"></a>3.区别</h3><h4 id="I-拥有资源"><a href="#I-拥有资源" class="headerlink" title="I 拥有资源"></a>I 拥有资源</h4><p>进程是资源分配的基本单位，而线程不拥有资源，线程可以访问隶属雨进程的资源</p><h4 id="II-调度"><a href="#II-调度" class="headerlink" title="II 调度"></a>II 调度</h4><p>线程是独立调度的基本单位，在同一进程中，线程切换不会引起进程切换。从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</p><h4 id="III-系统开销"><a href="#III-系统开销" class="headerlink" title="III 系统开销"></a>III 系统开销</h4><p>在创建或撤销进程时，系统都要为之分配或者回收资源（内存空间，I/O设备），开销远大于创建或者撤销线程的开销。在进行进程切换时，涉及当前执行进程CPU环境的保存及新调度进程CPU环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</p><h4 id="IV-通信方面"><a href="#IV-通信方面" class="headerlink" title="IV 通信方面"></a>IV 通信方面</h4><p>线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助IPC。</p><p>如果你对进程或者线程不太熟悉，建议阅读：<a href="https://link.zhihu.com/?target=http%3A//www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="noopener">进程与线程的一个简单解释</a></p><h2 id="（二）线程同步的方式有哪些？"><a href="#（二）线程同步的方式有哪些？" class="headerlink" title="（二）线程同步的方式有哪些？"></a>（二）线程同步的方式有哪些？</h2><h3 id="互斥量："><a href="#互斥量：" class="headerlink" title="互斥量："></a>互斥量：</h3><p>采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。</p><h3 id="信号量："><a href="#信号量：" class="headerlink" title="信号量："></a>信号量：</h3><p>它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</p><h3 id="事件（信号）："><a href="#事件（信号）：" class="headerlink" title="事件（信号）："></a>事件（信号）：</h3><p>通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</p><p>如果你对线程同步IPC的方式不太熟悉，建议阅读：<a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/lebronjames/archive/2010/08/11/1797702.html" target="_blank" rel="noopener">线程同步的几种方式</a></p><h2 id="（三）进程的通信方式有哪些？"><a href="#（三）进程的通信方式有哪些？" class="headerlink" title="（三）进程的通信方式有哪些？"></a>（三）进程的通信方式有哪些？</h2><p>主要分为：管道（普通管道PIPE 、流管道（s_pipe）、命名管道（name_pipe））、系统IPC（包括消息队列、信号量、共享存储）、套接字（SOCKET）</p><h3 id="1-管道"><a href="#1-管道" class="headerlink" title="1.管道"></a>1.管道</h3><p><strong><em>普通管道PIPE</em></strong></p><p>管道是通过调用匹配pipe函数创建的，fd[0]用于读，fd[1]用于写。</p><pre><code>#include&lt;unistd.h&gt;int pipe(int fd[2]);</code></pre><p>管道具有以下限制：</p><p>  （1）只支持半双工通信（单向交替传输）</p><p>  （2）只能在父子进程中使用（只能在具有亲缘关系的进程间流动，进程的亲缘关系通常是父子进程）</p><p><strong><em>命名管道FIFO</em></strong></p><p>  也是半双工的通信方式，它去除了管道只能在父子进程中使用的限制，允许无亲缘关系的进程间进行通信</p><pre><code>#include&lt;sys/stat.h&gt;int mkfifo(const char *path, mode_t mode);int mkfifoat(int fd,const char *path,mode_t mode);</code></pre><p>FIFO常用于客户-服务器应用程序中，FIFO用作汇聚点，在客户进程和服务器进程之间传递数据。</p><h3 id="2-系统IPC"><a href="#2-系统IPC" class="headerlink" title="2.系统IPC"></a>2.系统IPC</h3><p><strong><em>消息队列</em></strong></p><p>是消息的链表，存放在内核中并由消息队列标识符标识。<br>相比于FIFO，消息队列有以下优点：</p><p>  （1）消息队列能够独立于读写进程的存在，从而避免了FIFO中同步管道的打开和关闭时可能产生的困难。</p><p>  （2）避免了FIFO的同步阻塞问题，不需要进程自己提供同步方法。</p><p>  （3）读进程可以根据消息类型有选择地接受消息，而不像FIFO那样只能默认地接收。</p><p><strong><em>信号量</em></strong></p><p>是一个计数器,用于为多个进程提供共享对象的访问。</p><p><strong><em>信号</em></strong></p><p>是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p><p><strong><em>共享内存</em></strong></p><p>允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种IPC。</p><p>需要使用信号量用来同步对共享存储的访问。</p><p>多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外XSL共享内存不是使用文件，而是使用内存的匿名段。</p><h3 id="3-套接字"><a href="#3-套接字" class="headerlink" title="3.套接字"></a>3.套接字</h3><p>与其它通信机制不同的是，它可用于不同机器间的进程通信。</p><p>如果你对进程的通信方式不太熟悉，建议阅读： <a href="https://blog.csdn.net/yufaw/article/details/7409596" target="_blank" rel="noopener">进程间的几种通信方式</a></p><h2 id="（四）什么是缓冲区溢出？有什么危害？其原因是什么？"><a href="#（四）什么是缓冲区溢出？有什么危害？其原因是什么？" class="headerlink" title="（四）什么是缓冲区溢出？有什么危害？其原因是什么？"></a>（四）什么是缓冲区溢出？有什么危害？其原因是什么？</h2><p>缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。</p><p>危害有以下两点：</p><p>程序崩溃，导致拒绝额服务<br>跳转并且执行一段恶意代码<br>造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入。</p><p>如果你想深入了解缓冲区溢出，推荐阅读：<a href="http://www.cnblogs.com/fanzhidongyzby/archive/2013/08/10/3250405.html" target="_blank" rel="noopener">缓冲区溢出攻击</a></p><h2 id="（五）什么是死锁？死锁产生的条件？"><a href="#（五）什么是死锁？死锁产生的条件？" class="headerlink" title="（五）什么是死锁？死锁产生的条件？"></a>（五）什么是死锁？死锁产生的条件？</h2><p>在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。</p><p>通俗的讲就是两个或多个进程无限期的阻塞、相互等待的一种状态。</p><p><strong><em>死锁产生的四个条件</em></strong>（有一个条件不成立，则不会产生死锁）</p><p><strong><em>互斥</em></strong>：一个资源一次只能被一个进程使用,每个资源要么已经分配给了一个进程，要么就是可用的。</p><p><strong><em>请求与保持</em></strong>(也叫作占有和等待)：一个进程因请求资源而阻塞时，对已获得资源保持不放</p><p><strong><em>不可剥夺</em></strong>（不可抢占）：进程获得的资源，在未完全使用完之前，不能强行剥夺，其只能被占有它的资源显式地释放。</p><p><strong><em>循环等待</em></strong>（环路等待）：若干进程之间形成一种头尾相接的环形等待资源关系</p><p><strong><em>四种解锁方法</em></strong></p><p><strong><em>鸵鸟策略</em></strong>假装问题根本没发生，因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。<br>当发生死锁时不会对用户造成多大的影响，或发生概率很低时可采用鸵鸟策略。<br>Unix，Linux和Windows等多数操作系统处理死锁的方法就是忽略它。</p><p><strong><em>死锁检测与死锁恢复</em></strong><br><img src="lock.png" alt=""></p><p><strong><em>死锁预防</em></strong></p><p><strong><em>死锁避免</em></strong></p><p>如果对死锁还不是太熟悉，建议阅读：<a href="http://www.cnblogs.com/Jessy/p/3540724.html" target="_blank" rel="noopener">死锁产生的原因和解锁的方法</a></p><h2 id="（六）进程有哪几种状态？"><a href="#（六）进程有哪几种状态？" class="headerlink" title="（六）进程有哪几种状态？"></a>（六）进程有哪几种状态？</h2><p>就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源<br>运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数<br>阻塞状态： 进程等待某种条件，在条件满足之前无法执行<br>如果你对进程的几种状态以及中间的装换不太了解，建议阅读：<a href="http://www.cnblogs.com/Jessy/p/3540724.html" target="_blank" rel="noopener">进程的三种状态及转换</a></p><h2 id="（七）分页和分段有什么区别？"><a href="#（七）分页和分段有什么区别？" class="headerlink" title="（七）分页和分段有什么区别？"></a>（七）分页和分段有什么区别？</h2><p>段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 ；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的。<br>段的大小不固定，有它所完成的功能决定；页大大小固定，由系统决定<br>段向用户提供二维地址空间；页向用户提供的是一维地址空间<br>段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。<br>如果你对分页和分段还不太了解，建议阅读：<a href="https://blog.csdn.net/wangrunmin/article/details/7967293" target="_blank" rel="noopener">分段和分页</a></p><h2 id="（八）-操作系统中进程调度策略有哪几种？"><a href="#（八）-操作系统中进程调度策略有哪几种？" class="headerlink" title="（八） 操作系统中进程调度策略有哪几种？"></a>（八） 操作系统中进程调度策略有哪几种？</h2><p>FCFS(先来先服务)，优先级，时间片轮转，多级反馈</p><p>如果你想深入的了解这几种调度策略，推荐阅读：<a href="https://blog.csdn.net/luyafei_89430/article/details/12971171" target="_blank" rel="noopener">几个常用的操作系统进程调度算法</a></p><h2 id="（九）说一说进程同步有哪几种机制。"><a href="#（九）说一说进程同步有哪几种机制。" class="headerlink" title="（九）说一说进程同步有哪几种机制。"></a>（九）说一说进程同步有哪几种机制。</h2><p>原子操作、信号量机制、自旋锁管程、会合、分布式系统</p><p>如果你想深入的了解这几种机制，推荐阅读： <a href="http://www.cnblogs.com/sonic4x/archive/2011/07/05/2098036.html" target="_blank" rel="noopener">进程同步的几种机制</a></p><h2 id="（十）说一说死锁的处理基本策略和常用方法。"><a href="#（十）说一说死锁的处理基本策略和常用方法。" class="headerlink" title="（十）说一说死锁的处理基本策略和常用方法。"></a>（十）说一说死锁的处理基本策略和常用方法。</h2><p>解决死锁的基本方法如下：</p><p>预防死锁、避免死锁、检测死锁、解除死锁</p><p>解决四多的常用策略如下：</p><p>鸵鸟策略、预防策略、避免策略、检测与解除死锁<br>如果你对死锁的处理策略不是太熟悉，推荐阅读：<a href="https://blog.csdn.net/bxyill/article/details/8237339" target="_blank" rel="noopener">产生死锁的原因和必要条件+解决死锁的基本方法</a></p><h2 id="（十一）进程通信和进程同步的区别"><a href="#（十一）进程通信和进程同步的区别" class="headerlink" title="（十一）进程通信和进程同步的区别"></a>（十一）进程通信和进程同步的区别</h2><p>进程通信是一种手段，是在进程间传输信息<br>进程同步是一种目的，是控制多个进程按照一定的顺序执行<br>为了达到进程同步的目的，需要让进程进行通信，传输进程同步所需的信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统基础概念I&quot;&gt;&lt;a href=&quot;#操作系统基础概念I&quot; class=&quot;headerlink&quot; title=&quot;操作系统基础概念I&quot;&gt;&lt;/a&gt;操作系统基础概念I&lt;/h1&gt;&lt;p&gt;总结操作系统基础概念&lt;/p&gt;
    
    </summary>
    
      <category term="2019年6月" scheme="http://yoursite.com/categories/2019%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Operating System" scheme="http://yoursite.com/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客多终端更新问题</title>
    <link href="http://yoursite.com/2019/05/28/Hexo%E5%8D%9A%E5%AE%A2%E5%A4%9A%E7%BB%88%E7%AB%AF%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/05/28/Hexo博客多终端更新问题/</id>
    <published>2019-05-28T11:19:45.000Z</published>
    <updated>2019-07-17T03:53:33.992Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo博客多终端更新问题"><a href="#Hexo博客多终端更新问题" class="headerlink" title="Hexo博客多终端更新问题"></a>Hexo博客多终端更新问题</h1><p>记录Hexo博客多终端备份更新问题的解决方案</p><a id="more"></a><h2 id="问题介绍"><a href="#问题介绍" class="headerlink" title="问题介绍"></a>问题介绍</h2><p>很多人会把Hexo生成出来的静态网站放到GitHub Pages来进行托管。一般发布Hexo博客的流程是，首先在本地搭建Hexo的环境，编写新文章，然后利用hexo deploy来发布到Git。那么对于本地的Hexo的原始文件怎么管理呢？如果换电脑了怎么办？如果没有对原始文件进行备份，突然有一天你的本地环境挂了导致源文件丢失，那就很悲催了。可以用Dropbox或者其他方案来对源文件进行备份，但是每次更新完博客，需要备份好源文件，然后执行hexo deploy进行发布，非常麻烦。这就是写博客常遇到的多终端备份和更新问题。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>目前找到的解决方法有两种：</p><h3 id="1-持续集成"><a href="#1-持续集成" class="headerlink" title="1.持续集成"></a>1.持续集成</h3><p>用两个GitHub Repo，一个Repo放Hexo的源文件（这里称之为Source Repo），另一个Repo放Hexo生成出来的静态网站（这里称之为Content Repo），然后使用AppVeyor做持续集成。每当需要更新博客，只需要更新Source Repo，AppVeyor会自动生成静态网站并push到Content Repo，一气呵成，版本控制完全由GitHub完成，也不需要手动deploy。参见（<a href="https://formulahendry.github.io/2016/12/04/hexo-ci/）。" target="_blank" rel="noopener">https://formulahendry.github.io/2016/12/04/hexo-ci/）。</a><br>但是这种方法比较麻烦，AppVeyor的注册和使用都很不顺畅。所以我推荐下面的方法。</p><h3 id="2-git分支进行多终端工作"><a href="#2-git分支进行多终端工作" class="headerlink" title="2.git分支进行多终端工作"></a>2.git分支进行多终端工作</h3><p>这种方法是利用git的分支进行多终端工作，可以参见（<a href="http://fangzh.top）" target="_blank" rel="noopener">http://fangzh.top）</a><br>每次打开不一样的电脑，只需要进行简单的配置和在github上把文件同步下来，可以无缝操作。而且这种方法对新手比较友好。</p><h3 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h3><p>由于hexo d上传部署到github的其实是hexo编译后的文件，是用来生成网页的，不包含源文件。也就是上传的是在本地目录里自动生成的.deploy_git里面。其他文件 ，包括我们写在source 里面的，和配置文件，主题文件，都没有上传到github<br>所以可以利用git的分支管理，将源文件上传到github的另一个分支即可。</p><h3 id="上传分支"><a href="#上传分支" class="headerlink" title="上传分支"></a>上传分支</h3><p>首先，先在github上新建一个hexo分支，然后在这个仓库的settings中，选择默认分支为hexo分支（这样每次同步的时候就不用指定分支，比较方便）。<br>然后在本地的任意目录下，打开git bash，</p><pre><code>git clone git@github.com:liyiye012/liyiye012.github.io.git</code></pre><p>将其克隆到本地，因为默认分支已经设成了hexo，所以clone时只clone了hexo。接下来在克隆到本地的liyiye012.github.io中，把除了.git 文件夹外的所有文件都删掉 把之前我们写的博客源文件全部复制过来，除了.deploy_git。<br>这里应该说一句，复制过来的源文件应该有一个.gitignore，用来忽略一些不需要的文件，如果没有的话，自己新建一个，在里面写上如下，表示这些类型文件不需要git：.DS_Store</p><pre><code>Thumbs.dbdb.json*.lognode_modules/public/.deploy*/</code></pre><p>注意，如果之前克隆过theme中的主题文件，那么应该把主题文件中的.git文件夹删掉，因为git不能嵌套上传，最好是显示隐藏文件，检查一下有没有，否则上传的时候会出错，导致你的主题文件无法上传，这样你的配置在别的电脑上就用不了了。而后</p><pre><code>git add .git commit –m &quot;add branch&quot;git push</code></pre><p>这样就上传完了，可以去github上看一看hexo分支有没有上传上去，其中node_modules、public、db.json已经被忽略掉了，没有关系，不需要上传的，因为在别的电脑上需要重新输入命令安装 。</p><p>这样就上传完了。</p><h3 id="更换电脑操作"><a href="#更换电脑操作" class="headerlink" title="更换电脑操作"></a>更换电脑操作</h3><p>跟之前的环境搭建一样，安装git</p><pre><code>sudo apt-get install git</code></pre><p>设置git全局邮箱和用户名</p><pre><code>git config --global user.name &quot;yourgithubname&quot;git config --global user.email &quot;yourgithubemail&quot;</code></pre><p>设置ssh key</p><pre><code>ssh-keygen -t rsa -C &quot;youremail&quot;#生成后填到github和coding上（有coding平台的话）#验证是否成功ssh -T git@github.comssh -T git@git.coding.net #(有coding平台的话)</code></pre><p>安装nodejs</p><pre><code>sudo apt-get install nodejssudo apt-get install npm</code></pre><p>安装hexo  </p><pre><code>sudo npm install hexo-cli -g</code></pre><p>但是已经不需要初始化了，直接在任意文件夹下，git clone git@………………<br>然后进入克隆到的文件夹：cd xxx.github.io</p><pre><code>npm installnpm install hexo-deployer-git --save</code></pre><p>生成，部署：</p><pre><code>hexo ghexo d</code></pre><p>然后就可以愉快的开始写新博客了</p><pre><code>hexo new newpage</code></pre><p>Tips:不要忘了，每次写完最好都把源文件上传一下</p><pre><code>git add .git commit –m &quot;xxxx&quot;git push</code></pre><p>如果是在已经编辑过的电脑上，已经有clone文件夹了，那么，每次只要和远端同步一下就行了</p><pre><code>git pull</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Hexo博客多终端更新问题&quot;&gt;&lt;a href=&quot;#Hexo博客多终端更新问题&quot; class=&quot;headerlink&quot; title=&quot;Hexo博客多终端更新问题&quot;&gt;&lt;/a&gt;Hexo博客多终端更新问题&lt;/h1&gt;&lt;p&gt;记录Hexo博客多终端备份更新问题的解决方案&lt;/p&gt;
    
    </summary>
    
      <category term="2019年5月" scheme="http://yoursite.com/categories/2019%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow入门-Mnist手写数字识别</title>
    <link href="http://yoursite.com/2018/11/22/TensorFlow%E5%85%A5%E9%97%A8-Mnist%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/"/>
    <id>http://yoursite.com/2018/11/22/TensorFlow入门-Mnist手写数字识别/</id>
    <published>2018-11-22T08:30:34.000Z</published>
    <updated>2019-07-17T03:53:33.994Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TensorFlow入门-Mnist手写数字识别"><a href="#TensorFlow入门-Mnist手写数字识别" class="headerlink" title="TensorFlow入门-Mnist手写数字识别"></a>TensorFlow入门-Mnist手写数字识别</h1><p>记录一下Mnist手写数字识别的练习过程，网上已经有很多类似的教程比如(<a href="https://blog.csdn.net/simple_the_best/article/details/75267863，https://blog.csdn.net/cqrtxwd/article/details/79028264），" target="_blank" rel="noopener">https://blog.csdn.net/simple_the_best/article/details/75267863，https://blog.csdn.net/cqrtxwd/article/details/79028264），</a> 但会有些许问题，所以做修改后整理一下<br>当然最好的入门教程还是TensorFlow中文社区（<a href="http://www.tensorfly.cn" target="_blank" rel="noopener">www.tensorfly.cn</a>)</p><a id="more"></a><h2 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h2><p> 可在<a href="http://yann.lecun.com/exdb/mnist/下载mnist数据集，包含" target="_blank" rel="noopener">http://yann.lecun.com/exdb/mnist/下载mnist数据集，包含</a></p><pre><code>Training set images: train-images-idx3-ubyte.gz (9.9 MB, 解压后 47 MB, 包含 60,000 个样本)Training set labels: train-labels-idx1-ubyte.gz (29 KB, 解压后 60 KB, 包含 60,000 个标签)Test set images: t10k-images-idx3-ubyte.gz (1.6 MB, 解压后 7.8 MB, 包含 10,000 个样本)Test set labels: t10k-labels-idx1-ubyte.gz (5KB, 解压后 10 KB, 包含 10,000 个标签）</code></pre><p>MNIST 数据集来自美国国家标准与技术研究所, National Institute of Standards and Technology (NIST). 训练集 (training set) 由来自 250 个不同人手写的数字构成, 其中 50% 是高中学生, 50% 来自人口普查局 (the Census Bureau) 的工作人员. 测试集(test set) 也是同样比例的手写数字数据.<br>图片是以字节的形式进行存储, 我们需要把它们读取到 NumPy array 中, 以便训练和测试算法,载入数据</p><pre><code>import tensorflow as tffrom tensorflow.examples.tutorials.mnist import input_datamnist=input_data.read_data_sets(&quot;MNIST_data/&quot;,one_hot=True)import osimport structimport numpy as npdef load_mnist(path,kind=&apos;train&apos;):    labels_path=os.path.join(path,&apos;%s-labels-idx1-ubyte&apos;%kind)    images_path=os.path.join(path,&apos;%s-images-idx3-ubyte&apos;%kind)    with open(labels_path,&apos;rb&apos;) as lbpath:         magic,n=struct.unpack(&apos;&gt;II&apos;,lbpath.read(8))        labels=np.fromfile(lbpath,dtype=np.uint8)    with open(images_path,&apos;rb&apos;) as imgpath:        magic,num,rows,cols=struct.unpack(&apos;IIII&apos;,imgpath.read(16))        images=np.fromfile(imgpath,dtype=np.uint8).reshape(len(labels),784)    return images,labels</code></pre><p>load_mnist 函数返回两个数组, 第一个是一个 n x m 维的NumPy array(images), 这里的 n 是样本数(行数), m 是特征数(列数). 训练数据集包含 60,000 个样本, 测试数据集包含 10,000 样本. 在 MNIST 数据集中的每张图片由 28 x 28 个像素点构成, 每个像素点用一个灰度值表示. 在这里, 我们将 28 x 28 的像素展开为一个一维的行向量, 这些行向量就是图片数组里的行(每行 784 个值, 或者说每行就是代表了一张图片). load_mnist 函数返回的第二个数组(labels) 包含了相应的目标变量, 也就是手写数字的类标签(整数 0-9).这里对图片的读取方式做一些解释：</p><pre><code>magic, n = struct.unpack(&apos;&gt;II&apos;, lbpath.read(8))labels = np.fromfile(lbpath, dtype=np.uint8)</code></pre><p>看一下 MNIST 网站上对数据集的介绍:</p><pre><code>TRAINING SET LABEL FILE (train-labels-idx1-ubyte):[offset] [type]          [value]          [description] 0000     32 bit integer  0x00000801(2049) magic number (MSB first) 0004     32 bit integer  60000            number of items 0008     unsigned byte   ??               label 0009     unsigned byte   ??               label ........ xxxx     unsigned byte   ??               labelThe labels values are 0 to 9.</code></pre><p>我们首先读入 magic number, 它是一个文件协议的描述, 也是在我们调用 fromfile 方法将字节读入 NumPy array 之前在文件缓冲中的 item 数(n). 作为参数值传入 struct.unpack 的 &gt;II 有两个部分:</p><blockquote><p>: 这是指大端(用来定义字节是如何存储的); 如果你还不知道什么是大端和小端, Endianness 是一个非常好的解释. (关于大小端, 更多内容可见&lt;&lt;深入理解计算机系统 – 2.1 节信息存储&gt;&gt;)<br>I: 这是指一个无符号整数.</p></blockquote><p>通过执行下面的代码, 我们将会从刚刚解压 MNIST 数据集后的 mnist 目录下加载 60,000 个训练样本和 10,000 个测试样本.</p><h2 id="数据预览"><a href="#数据预览" class="headerlink" title="数据预览"></a>数据预览</h2><p>此时要将文件解压后放在MNIST_data文件夹下，可视化处理. 从 feature matrix 中将 784-像素值 的向量 reshape 为之前的 28*28 的形状, 然后通过 matplotlib 的 imshow 函数进行绘制:</p><pre><code>import matplotlib.pyplot as pltX_train,y_train=load_mnist(&quot;MNIST_data/&quot;,kind=&apos;train&apos;)fig, ax = plt.subplots(    nrows=2,    ncols=5,    sharex=True,    sharey=True, )ax = ax.flatten()for i in range(10):    img = X_train[y_train == i][0].reshape(28, 28)    ax[i].imshow(img, cmap=&apos;Greys&apos;, interpolation=&apos;nearest&apos;)ax[0].set_xticks([])ax[0].set_yticks([])#plt.tight_layout()plt.show()</code></pre><p>可以看到一个 2*5 的图片, 里面分别是 0-9 单个数字的图片.还可以绘制某一数字的多个样本图片, 来看一下这些手写样本到底有多不同:</p><pre><code>fig,ax=plt.subplots(    nrows=5,    ncols=5,    sharex=True,    sharey=True,)ax=ax.flatten()for i in range(25):    img=X_train[y_train==7][i].reshape(28,28)    ax[i].imshow(img,cmap=&apos;Greys&apos;,interpolation=&apos;nearest&apos;)ax[0].set_xticks([])ax[0].set_yticks([])plt.show()</code></pre><p>我们也可以选择将 MNIST 图片数据和标签保存为 CSV 文件, 这样就可以在不支持特殊的字节格式的程序中打开数据集. 但是, 有一点要说明, CSV 的文件格式将会占用更多的磁盘空间, 如下所示:</p><pre><code>train_img.csv: 109.5 MBtrain_labels.csv: 120 KBtest_img.csv: 18.3 MBtest_labels: 20 KB</code></pre><p>如果我们打算保存这些 CSV 文件, 在将 MNIST 数据集加载入 NumPy array 以后, 我们应该执行下列代码:</p><pre><code>np.savetxt(&apos;train_img.csv&apos;, X_train,           fmt=&apos;%i&apos;, delimiter=&apos;,&apos;)np.savetxt(&apos;train_labels.csv&apos;, y_train,           fmt=&apos;%i&apos;, delimiter=&apos;,&apos;)np.savetxt(&apos;test_img.csv&apos;, X_test,           fmt=&apos;%i&apos;, delimiter=&apos;,&apos;)np.savetxt(&apos;test_labels.csv&apos;, y_test,           fmt=&apos;%i&apos;, delimiter=&apos;,&apos;)</code></pre><p>一旦将数据集保存为 CSV 文件, 我们也可以用 NumPy 的 genfromtxt 函数重新将它们加载入程序中:</p><pre><code>X_train = np.genfromtxt(&apos;train_img.csv&apos;,                        dtype=int, delimiter=&apos;,&apos;)y_train = np.genfromtxt(&apos;train_labels.csv&apos;,                        dtype=int, delimiter=&apos;,&apos;)X_test = np.genfromtxt(&apos;test_img.csv&apos;,                       dtype=int, delimiter=&apos;,&apos;)y_test = np.genfromtxt(&apos;test_labels.csv&apos;,                       dtype=int, delimiter=&apos;,&apos;)</code></pre><p>不过, 从 CSV 文件中加载 MNIST 数据将会显著发给更长的时间, 因此如果可能的话, 还是建议维持数据集原有的字节格式.</p><h2 id="神经网络结构"><a href="#神经网络结构" class="headerlink" title="神经网络结构"></a>神经网络结构</h2><p>流程分为三步：<br>1.构建卷积神经网络结构<br>2.构建loss function，配置寻优器<br>3.训练，测试<br>在源码中使用了两个卷积层+池化层，最后接上两个全连接层。<br>第一层卷积使用了32个3x3x1的卷积核，步长为1，边界处理方式为“SAME”（卷积的输入和输出保持相同尺寸），激活函数为ReLu，后接一个2x2的池化层，方式为最大化池化；<br>第二层卷积使用50个3x3x32的卷积核，步长为1，边界处理方式为“SAME”，激活函数为ReLu，后接一个2x2的池化层，方式为最大化池化；<br>第一层全连接层：使用1024个神经元，激活函数为ReLu。<br>第二层全连接层：使用10个神经元，激活函数为Softmax,用于输出结果</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><pre><code>import tensorflow as tffrom tensorflow.examples.tutorials.mnist import input_data#读取数据mnist=input_data.read_data_sets(&apos;MNIST_data/&apos;,one_hot=True)sess=tf.InteractiveSession()#构建卷积神经网络结构#自定义卷积函数def conv2d(x,w):    return tf.nn.conv2d(x,w,strides=[1,1,1,1],padding=&apos;SAME&apos;)#自定义池化函数def max_pool_2x2(x):    return tf.nn.max_pool(x,ksize=[1,2,2,1],strides=[1,2,2,1],padding=&apos;SAME&apos;)#设置占位符，尺寸为样本输入和输出的尺寸x=tf.placeholder(tf.float32,[None,784])y_=tf.placeholder(tf.float32,[None,10])x_img=tf.reshape(x,[-1,28,28,1])#设置第一个卷积层和池化层w_conv1=tf.Variable(tf.truncated_normal([3,3,1,32],stddev=0.1))b_conv1=tf.Variable(tf.constant(0.1,shape=[32]))h_conv1=tf.nn.relu(conv2d(x_img,w_conv1)+b_conv1)h_pool1=max_pool_2x2(h_conv1)#设置第二个卷积层和池化层w_conv2=tf.Variable(tf.truncated_normal([3,3,32,50],stddev=0.1))b_conv2=tf.Variable(tf.constant(0.1,shape=[50]))h_conv2=tf.nn.relu(conv2d(h_pool1,w_conv2)+b_conv2)h_pool2=max_pool_2x2(h_conv2)#设置第一个全连接层w_fc1=tf.Variable(tf.truncated_normal([7*7*50,1024],stddev=0.1))b_fc1=tf.Variable(tf.constant(0.1,shape=[1024]))h_pool2_flat=tf.reshape(h_pool2,[-1,7*7*50])h_fc1=tf.nn.relu(tf.matmul(h_pool2_flat,w_fc1)+b_fc1)#dropout(随机权重失活)keep_prob=tf.placeholder(tf.float32)h_fc1_drop=tf.nn.dropout(h_fc1,keep_prob)#设置第二个全连接层w_fc2=tf.Variable(tf.truncated_normal([1024,10]))b_fc2=tf.Variable(tf.constant(0.1,shape=[10]))y_out=tf.nn.softmax(tf.matmul(h_fc1_drop,w_fc2)+b_fc2)#建立loss function,为交叉熵loss=tf.reduce_mean(-tf.reduce_sum(y_*tf.log(y_out),reduction_indices=[1]))#配置Adam优化器，学习速率为1e-4train_step=tf.train.AdamOptimizer(1e-4).minimize(loss)#建立正确率计算表达式correct_prediction=tf.equal(tf.argmax(y_out,1),tf.argmax(y_,1))accuracy=tf.reduce_mean(tf.cast(correct_prediction,tf.float32))#训练tf.global_variables_initializer().run()for i in range(20000):    batch = mnist.train.next_batch(50)    if i%100==0:        train_accuracy=accuracy.eval(feed_dict={x:batch[0],y_:batch[1],keep_prob:1})        print(&quot;ste %d,train_accuracy=%g&quot; %(i,train_accuracy))    train_step.run(feed_dict={x:batch[0],y_:batch[1],keep_prob:0.5})#训练后用测试集进行测试，输出最终结果print(&quot;test_accuracy= %h&quot; %accuracy.eval(feed_dict={x:mnist.test.images,y_:mnist.test.labels,keep_prob:1}))</code></pre><h2 id="代码详解："><a href="#代码详解：" class="headerlink" title="代码详解："></a>代码详解：</h2><pre><code>#自定义卷积函数def conv2d(x,w):    return tf.nn.conv2d(x,w,strides=[1,1,1,1],padding=&apos;SAME&apos;)#自定义池化函数def max_pool_2x2(x):    return tf.nn.max_pool(x,ksize=[1,2,2,1],strides=[1,2,2,1],padding=&apos;SAME&apos;)</code></pre><p>卷积步长为1，如果要改为步长为2则strides=[1,2,2,1],对于二维图来说只有中间两个是有效的，使用‘SAME’的padding方法（即输出与输入保持相同尺寸，边界处少一两个像素则自动补上）；池化层的设置也类似，池化尺寸为2x2</p><pre><code>#设置占位符，尺寸为样本输入和输出的尺寸x=tf.placeholder(tf.float32,[None,784])y_=tf.placeholder(tf.float32,[None,10])x_img=tf.reshape(x,[-1,28,28,1])</code></pre><p>设置输入输出的占位符，占位符是向一个会话中喂数据的入口，因为在TensorFlow的使用中通过构建计算图来设计网络，而网络的运行计算则在会话中启动，这个过程我们无法直接介入，需要通过placeholder来对一个会话进行数据输入。<br>占位符设置好之后将x变形为28x28是矩阵形式（tf.reshape()函数)</p><pre><code>#设置第一个卷积层和池化层w_conv1=tf.Variable(tf.truncated_normal([3,3,1,32],stddev=0.1))b_conv1=tf.Variable(tf.constant(0.1,shape=[32]))h_conv1=tf.nn.relu(conv2d(x_img,w_conv1)+b_conv1)h_pool1=max_pool_2x2(h_conv1)#设置第二个卷积层和池化层w_conv2=tf.Variable(tf.truncated_normal([3,3,32,50],stddev=0.1))b_conv2=tf.Variable(tf.constant(0.1,shape=[50]))h_conv2=tf.nn.relu(conv2d(h_pool1,w_conv2)+b_conv2)h_pool2=max_pool_2x2(h_conv2)</code></pre><p>第一层卷积使用3x3x1的卷积核，一共有32个卷积核，权值使用方差为0.1的截断正态分布（最大值不超过方差两倍的分布）来初始化，偏置的初值设定为常数0.1。<br>第二层卷积核第一层类似，卷积核尺寸为3x3x32（32是通道数，因为上一层使用32个卷积核，所以这一层的通道数就变成了32），这一层一共使用了50个卷积核，其他设置与上一层相同。<br>每一层卷积完之后接上一个2x2的最大化池化操作</p><pre><code>#设置第一个全连接层w_fc1=tf.Variable(tf.truncated_normal([7*7*50,1024],stddev=0.1))b_fc1=tf.Variable(tf.constant(0.1,shape=[1024]))h_pool2_flat=tf.reshape(h_pool2,[-1,7*7*50])h_fc1=tf.nn.relu(tf.matmul(h_pool2_flat,w_fc1)+b_fc1)#dropout(随机权重失活)keep_prob=tf.placeholder(tf.float32)h_fc1_drop=tf.nn.dropout(h_fc1,keep_prob)#设置第二个全连接层w_fc2=tf.Variable(tf.truncated_normal([1024,10]))b_fc2=tf.Variable(tf.constant(0.1,shape=[10]))y_out=tf.nn.softmax(tf.matmul(h_fc1_drop,w_fc2)+b_fc2)</code></pre><p>卷积层之后就是两个全连接层，第一个全连接层有1024个神经元，现将卷积层得到的2x2输出展开成一长条，使用ReLu激活函数得到输出，输出为1024维。</p><p>Dropout：在这一层使用权值随机失活，对一些神经元突触连接进行强制的置零，这个trick可以防止神经网络过拟合。这里的dropout的保留比例是0.5，即随机的保留一半权值，删除另一半。dropout比例通过placeholder来设置，因为训练过程中需要dropout，但是在最后的测试过程中，我们有希望使用全部的权值，随意dropout的比例要能够改变，这里使用placeholder。</p><p>第二个全连接层有10个神经元，分别对应0-9这19个数字，和之前每层不同，这里使用的激活函数是softmax，softmax是以指数函数作为核函数的归一化操作，与一般归一化操作不同的是，指数函数能够放大一个分布内各个数值的差异，两级分布现象会更明显。</p><pre><code>#建立loss function,为交叉熵loss=tf.reduce_mean(-tf.reduce_sum(y_*tf.log(y_out),reduction_indices=[1]))#配置Adam优化器，学习速率为1e-4train_step=tf.train.AdamOptimizer(1e-4).minimize(loss)#建立正确率计算表达式correct_prediction=tf.equal(tf.argmax(y_out,1),tf.argmax(y_,1))accuracy=tf.reduce_mean(tf.cast(correct_prediction,tf.float32))</code></pre><p>建立loss function很重要，这里使用交叉熵作为loss，交叉熵用来衡量两个分布的相似程度。两个分布越接近，则交叉熵越小。<br>使用Adam优化器来最小化loss，配置学习速率为1e-4，然后建立正确率的计算表达式，tf.argmax(y_,1)函数用来返回其中最大的值的下标，tf.equal用来计算两个值是否相等，tf.cast()函数用来实现数据类型转换，tf.reduce_mean()用来求平均（得到正确率）</p><pre><code>#训练tf.global_variables_initializer().run()for i in range(20000):    batch = mnist.train.next_batch(50)    if i%100==0:        train_accuracy=accuracy.eval(feed_dict={x:batch[0],y_:batch[1],keep_prob:1})        print(&quot;ste %d,train_accuracy=%g&quot; %(i,train_accuracy))    train_step.run(feed_dict={x:batch[0],y_:batch[1],keep_prob:0.5})</code></pre><p>对网络进行训练，首先使用<code>tf.global_variables_initializer().run()</code>初始化所有数据，从mnist训练数据集中集中一次取50个样本作为一组训练，共进行20000组训练，每100次就输出一次该组数据上的正确率，进行训练计算的方式是<code>train_step.run(feed_dict={x:batch[0],y_:batch[1],keep_prob:0.5})</code><br>,通过feed_dict来对会话输送训练数据（以及其他一些想在计算过程中实时调整的参数，比如dropout比例）<br>这段代码中可以看到，训练时dropout的保留比例是0.5，测试时的保留比例是1.</p><pre><code>#训练后用测试集进行测试，输出最终结果print(&quot;test_accuracy= %h&quot; %accuracy.eval(feed_dict={x:mnist.test.images,y_:mnist.test.labels,keep_prob:1}))</code></pre><p>最后输入测试集进行测试验证</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;TensorFlow入门-Mnist手写数字识别&quot;&gt;&lt;a href=&quot;#TensorFlow入门-Mnist手写数字识别&quot; class=&quot;headerlink&quot; title=&quot;TensorFlow入门-Mnist手写数字识别&quot;&gt;&lt;/a&gt;TensorFlow入门-Mnist手写数字识别&lt;/h1&gt;&lt;p&gt;记录一下Mnist手写数字识别的练习过程，网上已经有很多类似的教程比如(&lt;a href=&quot;https://blog.csdn.net/simple_the_best/article/details/75267863，https://blog.csdn.net/cqrtxwd/article/details/79028264），&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/simple_the_best/article/details/75267863，https://blog.csdn.net/cqrtxwd/article/details/79028264），&lt;/a&gt; 但会有些许问题，所以做修改后整理一下&lt;br&gt;当然最好的入门教程还是TensorFlow中文社区（&lt;a href=&quot;http://www.tensorfly.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.tensorfly.cn&lt;/a&gt;)&lt;/p&gt;
    
    </summary>
    
      <category term="2018年11月" scheme="http://yoursite.com/categories/2018%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="TensorFlow" scheme="http://yoursite.com/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>235.Lowest Common Ancestor of a Binary Search Tree 二叉搜索树的最近公共祖先</title>
    <link href="http://yoursite.com/2018/10/30/235.Lowest%20Common%20Ancestor%20of%20a%20Binary%20Search%20Tree%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <id>http://yoursite.com/2018/10/30/235.Lowest Common Ancestor of a Binary Search Tree 二叉搜索树的最近公共祖先/</id>
    <published>2018-10-30T02:13:20.000Z</published>
    <updated>2019-07-17T03:53:33.979Z</updated>
    
    <content type="html"><![CDATA[<h1 id="235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree-二叉搜索树的最近公共祖先"><a href="#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree-二叉搜索树的最近公共祖先" class="headerlink" title="235.Lowest Common Ancestor of a Binary Search Tree 二叉搜索树的最近公共祖先"></a>235.Lowest Common Ancestor of a Binary Search Tree 二叉搜索树的最近公共祖先</h1><a id="more"></a><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p><pre><code>     _______6______    /              \ ___2__          ___8__/      \        /      \0      _4       7       9      /  \      3   5</code></pre><p>示例 1:</p><pre><code>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。</code></pre><p>示例 2:</p><pre><code>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4输出: 2解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。说明:所有节点的值都是唯一的。p、q 为不同节点且均存在于给定的二叉搜索树中。</code></pre><h2 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h2><pre><code>/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {        if(root.val&gt;p.val &amp;&amp; root.val&gt;q.val){            return lowestCommonAncestor(root.left,p,q);        }        else if(root.val&lt;p.val &amp;&amp; root.val&lt;q.val){            return lowestCommonAncestor(root.right,p,q);        }else return root;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree-二叉搜索树的最近公共祖先&quot;&gt;&lt;a href=&quot;#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree-二叉搜索树的最近公共祖先&quot; class=&quot;headerlink&quot; title=&quot;235.Lowest Common Ancestor of a Binary Search Tree 二叉搜索树的最近公共祖先&quot;&gt;&lt;/a&gt;235.Lowest Common Ancestor of a Binary Search Tree 二叉搜索树的最近公共祖先&lt;/h1&gt;
    
    </summary>
    
      <category term="2018年10月" scheme="http://yoursite.com/categories/2018%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>Permutations全排列问题总结</title>
    <link href="http://yoursite.com/2018/10/11/Permutations%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/10/11/Permutations全排列问题总结/</id>
    <published>2018-10-11T02:33:14.000Z</published>
    <updated>2019-07-17T03:53:33.993Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Permutations全排列问题总结"><a href="#Permutations全排列问题总结" class="headerlink" title="Permutations全排列问题总结"></a>Permutations全排列问题总结</h1><p>总结几个常见的全排列问题<br>46.Permutations 全排列<br>47.PermutationsII 全排列II<br>31.Next Permutations 下一个排列<br>60.Permutation Sequence 第k个排列<br>266.Palindrome Permutation 回文排列<br>267.Palindrome PermutationII 回文排列II</p><a id="more"></a><h2 id="46-Permutations-全排列"><a href="#46-Permutations-全排列" class="headerlink" title="46.Permutations 全排列"></a>46.Permutations 全排列</h2><p>给定一个没有重复数字的序列，返回其所有可能的全排列。</p><p>示例:</p><pre><code>输入: [1,2,3]输出:[  [1,2,3],  [1,3,2],  [2,1,3],  [2,3,1],  [3,1,2],  [3,2,1]]</code></pre><h3 id="回溯思路"><a href="#回溯思路" class="headerlink" title="回溯思路"></a>回溯思路</h3><p>回溯的写法，每次交换nums里面的两个数字，经过回溯可以生成所有的排列情况</p><pre><code>class Solution {public:    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) {        vector&lt;vector&lt;int&gt;&gt; result;        permuteRecursive(nums,0,result);        return result;    }    void output(vector&lt;vector&lt;int&gt;&gt; result){        cout&lt;&lt;&quot;start to print&quot;&lt;&lt;endl;        for(int i=0;i&lt;result.size();i++){            for(int j=0;j&lt;result[i].size();j++){                cout&lt;&lt;result[i][j];            }cout&lt;&lt;endl;        }        cout&lt;&lt;&quot;end to print&quot;&lt;&lt;endl;    }    void permuteRecursive(vector&lt;int&gt; &amp;num,int begin,vector&lt;vector&lt;int&gt;&gt; &amp;result){        // cout&lt;&lt;&quot;begin=&quot;&lt;&lt;begin&lt;&lt;endl;        // cout&lt;&lt;&quot;   num=&quot;;        // for(int i=0;i&lt;num.size();i++) cout&lt;&lt;num[i]&lt;&lt;&quot; &quot;;        // cout&lt;&lt;endl;        // output(result);        if(begin&gt;=num.size()){            result.push_back(num);            return ;        }        for(int i=begin;i&lt;num.size();i++){            swap(num[begin],num[i]);            permuteRecursive(num,begin+1,result);            swap(num[begin],num[i]);        }    }};</code></pre><h3 id="DFS思路"><a href="#DFS思路" class="headerlink" title="DFS思路"></a>DFS思路</h3><p>这种方法是CareerCup书上的方法，也挺不错的，这道题是思想是这样的：</p><p>当n=1时，数组中只有一个数a1，其全排列只有一种，即为a1</p><p>当n=2时，数组中此时有a1a2，其全排列有两种，a1a2和a2a1，那么此时我们考虑和上面那种情况的关系，我们发现，其实就是在a1的前后两个位置分别加入了a2</p><p>当n=3时，数组中有a1a2a3，此时全排列有六种，分别为a1a2a3, a1a3a2, a2a1a3, a2a3a1, a3a1a2, 和 a3a2a1。那么根据上面的结论，实际上是在a1a2和a2a1的基础上在不同的位置上加入a3而得到的。</p><p>_ a1 _ a2 _ : a3a1a2, a1a3a2, a1a2a3</p><p>_ a2 _ a1 _ : a3a2a1, a2a3a1, a2a1a3</p><pre><code>class Solution {public:vector&lt;vector&lt;int&gt; &gt; permute(vector&lt;int&gt; &amp;num) {    vector&lt;vector&lt;int&gt; &gt; ans;    dfs(num, ans);    return ans;}void dfs(vector&lt;int&gt; &amp;num, vector&lt;vector&lt;int&gt;&gt; &amp;ans) {    if (num.size() == 1) {        vector&lt;int&gt; tmp(num.begin(), num.end());        ans.push_back(tmp);        return;    }    vector&lt;vector&lt;int&gt; &gt; ans1;    vector&lt;int&gt; num1(num.begin()+1, num.end());    dfs(num1, ans);    for(int i = 0; i &lt; ans.size(); ++i) {        for(int j = 0; j &lt;= ans[i].size(); ++j) {            vector&lt;int&gt; tmp = ans[i];            tmp.insert(tmp.begin()+j, num[0]);            ans1.push_back(tmp);        }    }    ans = ans1;}};</code></pre><h2 id="47-PermutationsII-全排列II"><a href="#47-PermutationsII-全排列II" class="headerlink" title="47.PermutationsII 全排列II"></a>47.PermutationsII 全排列II</h2><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p><p>示例:</p><pre><code>输入: [1,1,2]输出:[  [1,1,2],  [1,2,1],  [2,1,1]]</code></pre><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>  这里我们先考虑一下，它与上题唯一的不同在于：在DFS函数中，做循环遍历时，如果与当前元素相同的一个元素已经被取用过，则要跳过所有值相同的元素。<br>  举个例子：对于序列&lt;1,1,2,3&gt;。在DFS首遍历时，1 作为首元素被加到list中，并进行后续元素的添加；那么，当DFS跑完第一个分支，遍历到1 (第二个)时，这个1 不再作为首元素添加到list中，因为1 作为首元素的情况已经在第一个分支中考虑过了。<br>  为了实现这一剪枝思路，有了如下的解题算法。</p><p>解题算法：</p><p>  1. 先对给定的序列nums进行排序，使得大小相同的元素排在一起。<br>  2. 新建一个used数组，大小与nums相同，用来标记在本次DFS读取中，位置i的元素是否已经被添加到list中了。<br>  3. 根据思路可知，我们选择跳过一个数，当且仅当这个数与前一个数相等，并且前一个数未被添加到list中。 </p><pre><code>class Solution {public:    void recursion(vector&lt;int&gt; num, int i, int j, vector&lt;vector&lt;int&gt; &gt; &amp;res) {        if (i == j-1) {            res.push_back(num);            return;        }        for (int k = i; k &lt; j; k++) {            if (i != k &amp;&amp; num[i] == num[k]) continue;            swap(num[i], num[k]);            recursion(num, i+1, j, res);        }    }    vector&lt;vector&lt;int&gt; &gt; permuteUnique(vector&lt;int&gt; &amp;num) {        sort(num.begin(), num.end());        vector&lt;vector&lt;int&gt; &gt;res;        recursion(num, 0, num.size(), res);        return res;    }};</code></pre><h2 id="31-Next-Permutations-下一个排列"><a href="#31-Next-Permutations-下一个排列" class="headerlink" title="31.Next Permutations 下一个排列"></a>31.Next Permutations 下一个排列</h2><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须原地修改，只允许使用额外常数空间。</p><p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。</p><pre><code>1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1</code></pre><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>  这里，先考虑一个序列的最大最小情况。当一个序列为非递减序列时，它必然是该组数的最小的排列数；同理，当一个序列为非递增序列时，它必然是该组数的最大的排列数。  </p><p>  由此，我们可以知道，本题的关键即是求出数组末尾的最长的非递增子序列。<br>  不妨假设在数组nums中，nums[k+1]…nums[n]均满足前一个元素大于等于后一个元素，即这一子序列非递增。<br>  那么，我们要做的，就是把nums[k]与其后序列中稍大于nums[k]的数交换，接着再逆序nums[k+1]…nums[n]即可。 </p><pre><code>class Solution {public:    void nextPermutation(vector&lt;int&gt;&amp; nums) {        int n = nums.size(), k, l;        for (k = n - 2; k &gt;= 0; k--) {            if (nums[k] &lt; nums[k + 1]) {                break;            }        }        if (k &lt; 0) {            reverse(nums.begin(), nums.end());        } else {            for (l = n - 1; l &gt; k; l--) {                if (nums[l] &gt; nums[k]) {                    break;                }            }             swap(nums[k], nums[l]);            reverse(nums.begin() + k + 1, nums.end());        }    }}; </code></pre><h2 id="60-Permutation-Sequence-第k个排列"><a href="#60-Permutation-Sequence-第k个排列" class="headerlink" title="60.Permutation Sequence 第k个排列"></a>60.Permutation Sequence 第k个排列</h2><p>给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。</p><p>按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：</p><pre><code>&quot;123&quot;&quot;132&quot;&quot;213&quot;&quot;231&quot;&quot;312&quot;&quot;321&quot;</code></pre><p>给定 n 和 k，返回第 k 个排列。</p><p>说明：</p><pre><code>给定 n 的范围是 [1, 9]。给定 k 的范围是[1,  n!]。</code></pre><p>示例 1:</p><pre><code>输入: n = 3, k = 3输出: &quot;213&quot;</code></pre><p>示例 2:</p><pre><code>输入: n = 4, k = 9输出: &quot;2314&quot;</code></pre><h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>  这里我们先考虑一个特殊情况，当n=4时，序列为[1,2,3,4]，有以下几种情况：<br>  “1+(2,3,4)的全排列”<br>  “2+(1,3,4)的全排列”<br>  “3+(1,2,4)的全排列”<br>  “4+(1,2,3)的全排列”<br>  我们已经知道，对于n个数的全排列，有n!种情况。所以，3个数的全排列就有6种情况。<br>  <br>  如果我们这里给定的k为14，那么它将会出现在：<br>    “3+(1,2,4)的全排列”<br>  这一情况中。</p><p>  我们可以程式化地得到这个结果：取k=13(从0开始计数)，(n-1)!=3!=6，k/(n-1)!=2，而3在有序序列[1,2,3,4]中的索引就是2。<br>  同理，我们继续计算，新的k=13%6=1，新的n=3，那么1/(n-1)!=2/2=0。在序列[1,2,4]中，索引0的数是1。那么，此时的字符串为”31”。<br>  继续迭代，新的k=1%2=1，新的n=2，那么k/(n-1)!=1/1=1。在序列[2,4]中，索引为1的数是4。那么，此时的字符串为”314”。最后在串尾添上仅剩的2，可以得到字符串”3142”。<br>  经过验算，此串确实是序列[1,2,3,4]的全排列数中第14大的序列。</p><p>解题算法：</p><p>  1. 创建一个长度为n 的数组array，存放对应下标n的阶乘值。<br>  2. 再新建一个长度为n 的数组nums，初始值为nums[i]=i+1，用来存放待选的字符序列。<br>  3. 将得到的k减1后，开始迭代。迭代的规则是：迭代n次，每次选nums数组中下标为k/(n-1)!的数放在字符串的末尾，新的k=k%(n-1)!，新的n=n-1。<br>  4. 最后，返回得到的字符串。 </p><pre><code>class Solution {public:    string getPermutation(int n, int k) {        // initialize a dictionary that stores 1, 2, ..., n. This string will store the permutation.        string dict(n, 0);        iota(dict.begin(), dict.end(), &apos;1&apos;);        // build up a look-up table, which stores (n-1)!, (n-2)!, ..., 1!, 0!        vector&lt;int&gt; fract(n, 1);        for (int idx = n - 3; idx &gt;= 0; --idx) {            fract[idx] = fract[idx + 1] * (n - 1 - idx);        }        // let k be zero base        --k;        // the main part.        string ret(n, 0);        for (int idx = 0; idx &lt; n; ++idx) {            int select = k / fract[idx];            k %= fract[idx];            ret[idx] = dict[select];            dict.erase(next(dict.begin(), select)); // note that it is an O(n) operation        }        return ret;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Permutations全排列问题总结&quot;&gt;&lt;a href=&quot;#Permutations全排列问题总结&quot; class=&quot;headerlink&quot; title=&quot;Permutations全排列问题总结&quot;&gt;&lt;/a&gt;Permutations全排列问题总结&lt;/h1&gt;&lt;p&gt;总结几个常见的全排列问题&lt;br&gt;46.Permutations 全排列&lt;br&gt;47.PermutationsII 全排列II&lt;br&gt;31.Next Permutations 下一个排列&lt;br&gt;60.Permutation Sequence 第k个排列&lt;br&gt;266.Palindrome Permutation 回文排列&lt;br&gt;267.Palindrome PermutationII 回文排列II&lt;/p&gt;
    
    </summary>
    
      <category term="2018年10月" scheme="http://yoursite.com/categories/2018%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>84.Largest Rectangle in Histogram柱状图中最大的矩形</title>
    <link href="http://yoursite.com/2018/10/09/84.Largest%20Rectangle%20in%20Histogram%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/"/>
    <id>http://yoursite.com/2018/10/09/84.Largest Rectangle in Histogram柱状图中最大的矩形/</id>
    <published>2018-10-09T02:06:44.000Z</published>
    <updated>2019-07-17T03:53:33.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="84-Largest-Rectangle-in-Histogram柱状图中最大的矩形"><a href="#84-Largest-Rectangle-in-Histogram柱状图中最大的矩形" class="headerlink" title="84.Largest Rectangle in Histogram柱状图中最大的矩形"></a>84.Largest Rectangle in Histogram柱状图中最大的矩形</h1><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><a id="more"></a><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p>柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。</p><p>阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。</p><p>示例:</p><pre><code>输入: [2,1,5,6,2,3]输出: 10</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>分析寻找的过程，如果要在O(n)的时间内找到最大的面积，则需要记录下来每个高度为N的矩形，其长度最大可以达到多少。这样就分为两种情况，如图中描述的，首先是高度N越来越大，其次是高度N越来越小。</p><p>1.在高度N越来越大时，其上一个数字构成的高度的矩形的最大长度则增加1，例如，2 3，高度为3时，则高度为2的矩形的长度就加1. 2.在高度N越来越小时，其上一个数字构成的高度的矩形的最大长度就不变，例如 4 3，高度为4时，其构成的矩形长度为1，到了3，矩形长度没有递增，而4之前的数字3构成的矩形的长度也加1。</p><p>可以使用一个stack来存储矩形的高度和长度，其中长度会动态的变化。当遇到一个数字大于栈顶数字的时候就压入栈，小于栈顶的数字就弹出栈，在这个动态过程中，更新最大的矩形面积。</p><pre><code>class Solution {public:    int largestRectangleArea(vector&lt;int&gt;&amp; heights) {        heights.push_back(0);        int len=heights.size();        stack&lt;int&gt; stk;        int i=0,maxarea=0;        while(i&lt;len){            if(stk.empty() || heights[i]&gt;=heights[stk.top()]) {                stk.push(i);                i++;            }            else{                int h=stk.top();                stk.pop();                maxarea=max(maxarea,heights[h]*(stk.empty()? i: i-stk.top()-1));            }        }        return maxarea;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;84-Largest-Rectangle-in-Histogram柱状图中最大的矩形&quot;&gt;&lt;a href=&quot;#84-Largest-Rectangle-in-Histogram柱状图中最大的矩形&quot; class=&quot;headerlink&quot; title=&quot;84.Largest Rectangle in Histogram柱状图中最大的矩形&quot;&gt;&lt;/a&gt;84.Largest Rectangle in Histogram柱状图中最大的矩形&lt;/h1&gt;&lt;p&gt;给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年10月" scheme="http://yoursite.com/categories/2018%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>52. N-QueensNII皇后II</title>
    <link href="http://yoursite.com/2018/10/05/52.%20N-QueensIIN%E7%9A%87%E5%90%8EII/"/>
    <id>http://yoursite.com/2018/10/05/52. N-QueensIIN皇后II/</id>
    <published>2018-10-05T11:55:26.000Z</published>
    <updated>2019-07-17T03:53:33.982Z</updated>
    
    <content type="html"><![CDATA[<h1 id="52-N-QueensNII皇后II"><a href="#52-N-QueensNII皇后II" class="headerlink" title="52. N-QueensNII皇后II"></a>52. N-QueensNII皇后II</h1><p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><a id="more"></a><p>给定一个整数 n，返回 n 皇后不同的解决方案的数量。</p><p>示例:</p><p>输入: 4<br>输出: 2<br>解释: 4 皇后问题存在如下两个不同的解法。<br>[<br> [“.Q..”,  // 解法 1<br>  “…Q”,<br>  “Q…”,<br>  “..Q.”],</p><p> [“..Q.”,  // 解法 2<br>  “Q…”,<br>  “…Q”,<br>  “.Q..”]<br>]</p><h2 id="思路-DFS"><a href="#思路-DFS" class="headerlink" title="思路 DFS"></a>思路 DFS</h2><pre><code>def totalNQueens(self, n):    self.res = 0    self.dfs([-1]*n, 0)    return self.resdef dfs(self, nums, index):    if index == len(nums):        self.res += 1        return     for i in xrange(len(nums)):        nums[index] = i        if self.valid(nums, index):            self.dfs(nums, index+1)def valid(self, nums, n):    for i in xrange(n):        if nums[i] == nums[n] or abs(nums[n]-nums[i]) == n-i:            return False    return True</code></pre><h2 id="C-版"><a href="#C-版" class="headerlink" title="C++版"></a>C++版</h2><pre><code>int totalNQueens(int n) {    vector&lt;bool&gt; col(n, true);    vector&lt;bool&gt; anti(2*n-1, true);    vector&lt;bool&gt; main(2*n-1, true);    vector&lt;int&gt; row(n, 0);    int count = 0;    dfs(0, row, col, main, anti, count);    return count;}void dfs(int i, vector&lt;int&gt; &amp;row, vector&lt;bool&gt; &amp;col, vector&lt;bool&gt;&amp; main, vector&lt;bool&gt; &amp;anti, int &amp;count) {        if (i == row.size()) {            count++;            return;        }       for (int j = 0; j &lt; col.size(); j++) {         if (col[j] &amp;&amp; main[i+j] &amp;&amp; anti[i+col.size()-1-j]) {             row[i] = j;              col[j] = main[i+j] = anti[i+col.size()-1-j] = false;             dfs(i+1, row, col, main, anti, count);             col[j] = main[i+j] = anti[i+col.size()-1-j] = true;      }    }</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;52-N-QueensNII皇后II&quot;&gt;&lt;a href=&quot;#52-N-QueensNII皇后II&quot; class=&quot;headerlink&quot; title=&quot;52. N-QueensNII皇后II&quot;&gt;&lt;/a&gt;52. N-QueensNII皇后II&lt;/h1&gt;&lt;p&gt;n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年10月" scheme="http://yoursite.com/categories/2018%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>51. N-QueensN皇后</title>
    <link href="http://yoursite.com/2018/10/05/51.%20N-QueensN%E7%9A%87%E5%90%8E/"/>
    <id>http://yoursite.com/2018/10/05/51. N-QueensN皇后/</id>
    <published>2018-10-05T11:19:45.000Z</published>
    <updated>2019-07-17T03:53:33.982Z</updated>
    
    <content type="html"><![CDATA[<h1 id="51-N-QueensN皇后"><a href="#51-N-QueensN皇后" class="headerlink" title="51. N-QueensN皇后"></a>51. N-QueensN皇后</h1><p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><a id="more"></a><p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p><p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><p>示例:</p><pre><code>输入: 4输出: [ [&quot;.Q..&quot;,  // 解法 1  &quot;...Q&quot;,  &quot;Q...&quot;,  &quot;..Q.&quot;], [&quot;..Q.&quot;,  // 解法 2  &quot;Q...&quot;,  &quot;...Q&quot;,  &quot;.Q..&quot;]]解释: 4 皇后问题存在两个不同的解法。</code></pre><h2 id="思路1-递归"><a href="#思路1-递归" class="headerlink" title="思路1 递归"></a>思路1 递归</h2><p>尝试每个可能存在皇后的位置</p><pre><code>class Solution {private:    vector&lt;vector&lt;string&gt;&gt; res;public:    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) {       vector&lt;string&gt; cur(n,string(n,&apos;.&apos;));        helper(cur,0);        return res;    }    void helper(vector&lt;string&gt; &amp;cur,int row){        if(row==cur.size()){            res.push_back(cur);            return;        }        for(int col=0;col&lt;cur.size();col++)            if(isValid(cur,row,col)){                cur[row][col]=&apos;Q&apos;;                helper(cur,row+1);                cur[row][col]=&apos;.&apos;;            }    }    bool isValid(vector&lt;string&gt; &amp;cur,int row,int col){        for(int i=0;i&lt;row;i++)            if(cur[i][col] == &apos;Q&apos;) return false;        for(int i=row-1,j=col-1;i&gt;=0 &amp;&amp; j&gt;=0;i--,j--)            if(cur[i][j]==&apos;Q&apos;) return false;        for(int i=row-1,j=col+1;i&gt;=0 &amp;&amp; j&lt;cur.size();i--,j++)            if(cur[i][j]==&apos;Q&apos;) return false;        return true;    }};</code></pre><h2 id="思路2：DFS"><a href="#思路2：DFS" class="headerlink" title="思路2：DFS"></a>思路2：DFS</h2><p>queen用来记录皇后的横纵坐标位置，xy_dif用来记录横纵坐标之差，xy_sum用来记录横纵坐标之和，p + q == x + y 时在同一条对角线上， p - q == x - y时在同一条反对角线上</p><pre><code>def solveNQueens(self, n):    def DFS(queens, xy_dif, xy_sum):        p = len(queens)        if p==n:            result.append(queens)             return None        for q in range(n):            if q not in queens and p-q not in xy_dif and p+q not in xy_sum:                 DFS(queens+[q], xy_dif+[p-q], xy_sum+[p+q])      result = [] #全局变量    DFS([],[],[])    return [ [&quot;.&quot;*i + &quot;Q&quot; + &quot;.&quot;*(n-i-1) for i in sol] for sol in result]</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;51-N-QueensN皇后&quot;&gt;&lt;a href=&quot;#51-N-QueensN皇后&quot; class=&quot;headerlink&quot; title=&quot;51. N-QueensN皇后&quot;&gt;&lt;/a&gt;51. N-QueensN皇后&lt;/h1&gt;&lt;p&gt;n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年10月" scheme="http://yoursite.com/categories/2018%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>51. N-QueensN皇后</title>
    <link href="http://yoursite.com/2018/10/05/510.%20N-QueensN%E7%9A%87%E5%90%8E/"/>
    <id>http://yoursite.com/2018/10/05/510. N-QueensN皇后/</id>
    <published>2018-10-05T11:19:45.000Z</published>
    <updated>2019-07-17T03:53:33.982Z</updated>
    
    <content type="html"><![CDATA[<h1 id="51-N-QueensN皇后"><a href="#51-N-QueensN皇后" class="headerlink" title="51. N-QueensN皇后"></a>51. N-QueensN皇后</h1><p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><a id="more"></a><p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p><p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><p>示例:</p><pre><code>输入: 4输出: [ [&quot;.Q..&quot;,  // 解法 1  &quot;...Q&quot;,  &quot;Q...&quot;,  &quot;..Q.&quot;], [&quot;..Q.&quot;,  // 解法 2  &quot;Q...&quot;,  &quot;...Q&quot;,  &quot;.Q..&quot;]]解释: 4 皇后问题存在两个不同的解法。</code></pre><h2 id="思路1-递归"><a href="#思路1-递归" class="headerlink" title="思路1 递归"></a>思路1 递归</h2><p>尝试每个可能存在皇后的位置</p><pre><code>class Solution {private:    vector&lt;vector&lt;string&gt;&gt; res;public:    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) {       vector&lt;string&gt; cur(n,string(n,&apos;.&apos;));        helper(cur,0);        return res;    }    void helper(vector&lt;string&gt; &amp;cur,int row){        if(row==cur.size()){            res.push_back(cur);            return;        }        for(int col=0;col&lt;cur.size();col++)            if(isValid(cur,row,col)){                cur[row][col]=&apos;Q&apos;;                helper(cur,row+1);                cur[row][col]=&apos;.&apos;;            }    }    bool isValid(vector&lt;string&gt; &amp;cur,int row,int col){        for(int i=0;i&lt;row;i++)            if(cur[i][col] == &apos;Q&apos;) return false;        for(int i=row-1,j=col-1;i&gt;=0 &amp;&amp; j&gt;=0;i--,j--)            if(cur[i][j]==&apos;Q&apos;) return false;        for(int i=row-1,j=col+1;i&gt;=0 &amp;&amp; j&lt;cur.size();i--,j++)            if(cur[i][j]==&apos;Q&apos;) return false;        return true;    }};</code></pre><h2 id="思路2：DFS"><a href="#思路2：DFS" class="headerlink" title="思路2：DFS"></a>思路2：DFS</h2><p>queen用来记录皇后的横纵坐标位置，xy_dif用来记录横纵坐标之差，xy_sum用来记录横纵坐标之和，p + q == x + y 时在同一条对角线上， p - q == x - y时在同一条反对角线上</p><pre><code>def solveNQueens(self, n):    def DFS(queens, xy_dif, xy_sum):        p = len(queens)        if p==n:            result.append(queens)             return None        for q in range(n):            if q not in queens and p-q not in xy_dif and p+q not in xy_sum:                 DFS(queens+[q], xy_dif+[p-q], xy_sum+[p+q])      result = [] #全局变量    DFS([],[],[])    return [ [&quot;.&quot;*i + &quot;Q&quot; + &quot;.&quot;*(n-i-1) for i in sol] for sol in result]</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;51-N-QueensN皇后&quot;&gt;&lt;a href=&quot;#51-N-QueensN皇后&quot; class=&quot;headerlink&quot; title=&quot;51. N-QueensN皇后&quot;&gt;&lt;/a&gt;51. N-QueensN皇后&lt;/h1&gt;&lt;p&gt;n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年10月" scheme="http://yoursite.com/categories/2018%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>117.Populating Next Right Pointers in Each NodeII填充同一层的兄弟节点II</title>
    <link href="http://yoursite.com/2018/10/04/117.Populating%20Next%20Right%20Pointers%20in%20Each%20NodeII%E5%A1%AB%E5%85%85%E5%90%8C%E4%B8%80%E5%B1%82%E7%9A%84%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9II/"/>
    <id>http://yoursite.com/2018/10/04/117.Populating Next Right Pointers in Each NodeII填充同一层的兄弟节点II/</id>
    <published>2018-10-04T11:14:32.000Z</published>
    <updated>2019-07-17T03:53:33.977Z</updated>
    
    <content type="html"><![CDATA[<h1 id="117-Populating-Next-Right-Pointers-in-Each-NodeII填充同一层的兄弟节点II"><a href="#117-Populating-Next-Right-Pointers-in-Each-NodeII填充同一层的兄弟节点II" class="headerlink" title="117.Populating Next Right Pointers in Each NodeII填充同一层的兄弟节点II"></a>117.Populating Next Right Pointers in Each NodeII填充同一层的兄弟节点II</h1><p>给定一个二叉树</p><pre><code>struct TreeLinkNode {  TreeLinkNode *left;  TreeLinkNode *right;  TreeLinkNode *next;}</code></pre><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><a id="more"></a><p>说明:</p><p>你只能使用额外常数空间。<br>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。<br>示例:</p><p>给定二叉树，</p><pre><code>     1   /  \  2    3 / \    \4   5    7</code></pre><p>调用你的函数后，该二叉树变为：</p><pre><code>     1 -&gt; NULL   /  \  2 -&gt; 3 -&gt; NULL / \    \4-&gt; 5 -&gt; 7 -&gt; NULL</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用三个指针，head指向下一层的第一个结点，prev指向下一层的当前结点，cur指向当前层的当前结点，分层遍历，再按照当前结点是否有左结点和右结点分情况讨论，以当前结点有左结点为例，如果prev为空，说明当前层尚未被遍历过，因此初始化head，若非空说明已经被遍历过，上一个被遍历过的结点是prev，因此将prev的next指向当前结点左结点，然后推进一步，将prev置为cur-&gt;left</p><pre><code>/** * Definition for binary tree with next pointer. * struct TreeLinkNode { *  int val; *  TreeLinkNode *left, *right, *next; *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {} * }; */class Solution {public:    void connect(TreeLinkNode *root) {        TreeLinkNode *head = NULL; //head of the next level        TreeLinkNode *prev = NULL; //the leading node on the next level        TreeLinkNode *cur = root;  //current node of current level        while (cur != NULL) {            while (cur != NULL) { //iterate on the current level                //left child                if (cur-&gt;left != NULL) {                    if (prev != NULL) {                        prev-&gt;next = cur-&gt;left;                    } else {                        head = cur-&gt;left;                    }                    prev = cur-&gt;left;                }                //right child                if (cur-&gt;right != NULL) {                    if (prev != NULL) {                        prev-&gt;next = cur-&gt;right;                    } else {                        head = cur-&gt;right;                    }                    prev = cur-&gt;right;                }                //move to next node                cur = cur-&gt;next;            }            //move to next level            cur = head;            head = NULL;            prev = NULL;        }    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;117-Populating-Next-Right-Pointers-in-Each-NodeII填充同一层的兄弟节点II&quot;&gt;&lt;a href=&quot;#117-Populating-Next-Right-Pointers-in-Each-NodeII填充同一层的兄弟节点II&quot; class=&quot;headerlink&quot; title=&quot;117.Populating Next Right Pointers in Each NodeII填充同一层的兄弟节点II&quot;&gt;&lt;/a&gt;117.Populating Next Right Pointers in Each NodeII填充同一层的兄弟节点II&lt;/h1&gt;&lt;p&gt;给定一个二叉树&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct TreeLinkNode {
  TreeLinkNode *left;
  TreeLinkNode *right;
  TreeLinkNode *next;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。&lt;/p&gt;
&lt;p&gt;初始状态下，所有 next 指针都被设置为 NULL。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年10月" scheme="http://yoursite.com/categories/2018%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>102.Binary Tree Level Order Traversal二叉树的层次遍历</title>
    <link href="http://yoursite.com/2018/10/04/102.Binary%20Tree%20Level%20Order%20Traversal%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%20/"/>
    <id>http://yoursite.com/2018/10/04/102.Binary Tree Level Order Traversal二叉树的层次遍历 /</id>
    <published>2018-10-04T11:14:32.000Z</published>
    <updated>2019-07-17T03:53:33.976Z</updated>
    
    <content type="html"><![CDATA[<h1 id="102-Binary-Tree-Level-Order-Traversal二叉树的层次遍历"><a href="#102-Binary-Tree-Level-Order-Traversal二叉树的层次遍历" class="headerlink" title="102.Binary Tree Level Order Traversal二叉树的层次遍历"></a>102.Binary Tree Level Order Traversal二叉树的层次遍历</h1><p>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。</p><a id="more"></a><p>例如:</p><pre><code>给定二叉树: [3,9,20,null,null,15,7],    3   / \  9  20    /  \   15   7</code></pre><p>返回其层次遍历结果：</p><pre><code>[  [3],  [9,20],  [15,7]]</code></pre><h2 id="思路1-递归"><a href="#思路1-递归" class="headerlink" title="思路1:递归"></a>思路1:递归</h2><pre><code>/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {        vector&lt;vector&lt;int&gt;&gt; res;        leveltravel(res,0,root);        return res;    }    void leveltravel(vector&lt;vector&lt;int&gt;&gt; &amp;res,int depth,TreeNode * root){         if(!root) return ;        vector&lt;int&gt; temp;        if(res.size()==depth) res.push_back(temp);        res[depth].push_back(root-&gt;val);        leveltravel(res,depth+1,root-&gt;left);        leveltravel(res,depth+1,root-&gt;right);        return;    }};</code></pre><h2 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h2><p>在做的过程中注意队列的大小会随时变化，因此需要将q.size()保存为一个变量</p><pre><code>/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {        queue&lt;TreeNode *&gt; q;        vector&lt;vector&lt;int&gt;&gt; res;        if(root) {            q.push(root);        }        while(!q.empty()){         vector&lt;int&gt; temp;           int len=q.size();         for(int i=0;i&lt;len;i++){            TreeNode *cur;            cur=q.front();            temp.push_back(cur-&gt;val);            q.pop();             //cout&lt;&lt;&quot;i=&quot;&lt;&lt;i&lt;&lt;&quot;   cur-&gt;val=&quot;&lt;&lt;cur-&gt;val&lt;&lt;endl;            if(cur-&gt;left) q.push(cur-&gt;left);            if(cur-&gt;right) q.push(cur-&gt;right);            }            //cout&lt;&lt;&quot;  *********&quot;&lt;&lt;endl;            res.push_back(temp);        }    return res;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;102-Binary-Tree-Level-Order-Traversal二叉树的层次遍历&quot;&gt;&lt;a href=&quot;#102-Binary-Tree-Level-Order-Traversal二叉树的层次遍历&quot; class=&quot;headerlink&quot; title=&quot;102.Binary Tree Level Order Traversal二叉树的层次遍历&quot;&gt;&lt;/a&gt;102.Binary Tree Level Order Traversal二叉树的层次遍历&lt;/h1&gt;&lt;p&gt;给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年10月" scheme="http://yoursite.com/categories/2018%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Breadth-first Search" scheme="http://yoursite.com/tags/Breadth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>199.Binary Tree Right Side View二叉树的右视图</title>
    <link href="http://yoursite.com/2018/10/04/199.Binary%20Tree%20Right%20Side%20View%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/"/>
    <id>http://yoursite.com/2018/10/04/199.Binary Tree Right Side View二叉树的右视图/</id>
    <published>2018-10-04T11:14:32.000Z</published>
    <updated>2019-07-17T03:53:33.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="199-Binary-Tree-Right-Side-View二叉树的右视图"><a href="#199-Binary-Tree-Right-Side-View二叉树的右视图" class="headerlink" title="199.Binary Tree Right Side View二叉树的右视图"></a>199.Binary Tree Right Side View二叉树的右视图</h1><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><a id="more"></a><p>示例:</p><pre><code>输入: [1,2,3,null,5,null,4]输出: [1, 3, 4]解释:   1            &lt;--- /   \2     3         &lt;--- \     \  5     4       &lt;---</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用队列层次遍历二叉树，存储每层最右边的结点</p><pre><code>/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public:    vector&lt;int&gt; rightSideView(TreeNode* root) {        vector&lt;int&gt; res;        queue&lt;TreeNode*&gt; q;        if(root) q.push(root);        while(!q.empty()){            int len=q.size();            for(int i=0;i&lt;len;i++){                TreeNode *cur=q.front();                q.pop();                if(i==len-1)res.push_back(cur-&gt;val);                if(cur-&gt;left) q.push(cur-&gt;left);                if(cur-&gt;right) q.push(cur-&gt;right);            }        }        return res;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;199-Binary-Tree-Right-Side-View二叉树的右视图&quot;&gt;&lt;a href=&quot;#199-Binary-Tree-Right-Side-View二叉树的右视图&quot; class=&quot;headerlink&quot; title=&quot;199.Binary Tree Right Side View二叉树的右视图&quot;&gt;&lt;/a&gt;199.Binary Tree Right Side View二叉树的右视图&lt;/h1&gt;&lt;p&gt;给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年10月" scheme="http://yoursite.com/categories/2018%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
      <category term="Breadth-first Search" scheme="http://yoursite.com/tags/Breadth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>545.Boundary of Binary Tree 二叉树的边界</title>
    <link href="http://yoursite.com/2018/10/04/545.Boundary%20of%20Binary%20Tree%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BE%B9%E7%95%8C/"/>
    <id>http://yoursite.com/2018/10/04/545.Boundary of Binary Tree 二叉树的边界/</id>
    <published>2018-10-04T11:14:32.000Z</published>
    <updated>2019-07-17T03:53:33.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="545-Boundary-of-Binary-Tree-二叉树的边界"><a href="#545-Boundary-of-Binary-Tree-二叉树的边界" class="headerlink" title="545.Boundary of Binary Tree 二叉树的边界"></a>545.Boundary of Binary Tree 二叉树的边界</h1><p>Given a binary tree, return the values of its boundary in anti-clockwise direction starting from root. Boundary includes left boundary, leaves, and right boundary in order without duplicate nodes.</p><p>Left boundary is defined as the path from root to the left-most node. Right boundary is defined as the path from root to the right-most node. If the root doesn’t have left subtree or right subtree, then the root itself is left boundary or right boundary. Note this definition only applies to the input binary tree, and not applies to any subtrees.</p><p>The left-most node is defined as a leaf node you could reach when you always firstly travel to the left subtree if exists. If not, travel to the right subtree. Repeat until you reach a leaf node.</p><p>The right-most node is also defined by the same way with left and right exchanged.</p><a id="more"></a><p>Example 1</p><pre><code>Input:  1   \    2   / \  3   4Ouput:[1, 3, 4, 2]</code></pre><p>Explanation:<br>The root doesn’t have left subtree, so the root itself is left boundary.<br>The leaves are node 3 and 4.<br>The right boundary are node 1,2,4. Note the anti-clockwise direction means you should output reversed right boundary.<br>So order them in anti-clockwise without duplicates and we have [1,3,4,2].</p><p>Example 2</p><pre><code>Input:    ____1_____   /          \  2            3 / \          / 4   5        6      / \      / \  7   8    9  10  Ouput:[1,2,4,7,8,9,10,6,3]</code></pre><p>Explanation:<br>The left boundary are node 1,2,4. (4 is the left-most node according to definition)<br>The leaves are node 4,7,8,9,10.<br>The right boundary are node 1,3,6,10. (10 is the right-most node).<br>So order them in anti-clockwise without duplicate nodes we have [1,2,4,7,8,9,10,6,3].</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题给了我们一棵二叉树，让我们以逆时针的顺序来输出树的边界，按顺序分别为左边界，叶结点和右边界。题目中给的例子也能让我们很清晰的明白哪些算是边界上的结点。那么最直接的方法就是分别按顺序求出左边界结点，叶结点，和右边界结点。那么如何求的，对于树的操作肯定是用递归最简洁啊，所以我们可以写分别三个递归函数来分别求左边界结点，叶结点，和右边界结点。首先我们先要处理根结点的情况，当根结点没有左右子结点时，其也是一个叶结点，那么我们一开始就将其加入结果res中，那么再计算叶结点的时候又会再加入一次，这样不对。所以我们判断如果根结点至少有一个子结点，我们才提前将其加入结果res中。然后再来看求左边界结点的函数，如果当前结点不存在，或者没有子结点，我们直接返回。否则就把当前结点值加入结果res中，然后看如果左子结点存在，就对其调用递归函数，反之如果左子结点不存在，那么对右子结点调用递归函数。而对于求右边界结点的函数就反过来了，如果右子结点存在，就对其调用递归函数，反之如果右子结点不存在，就对左子结点调用递归函数，注意在调用递归函数之后才将结点值加入结果res，因为我们是需要按逆时针的顺序输出。最后就来看求叶结点的函数，没什么可说的，就是看没有子结点存在了就加入结果res，然后对左右子结点分别调用递归即可，参见代码如下：</p><p>解法一：</p><pre><code>class Solution {public:    vector&lt;int&gt; boundaryOfBinaryTree(TreeNode* root) {        if (!root) return {};        vector&lt;int&gt; res;        if (root-&gt;left || root-&gt;right) res.push_back(root-&gt;val);        leftBoundary(root-&gt;left, res);        leaves(root, res);        rightBoundary(root-&gt;right, res);        return res;    }    void leftBoundary(TreeNode* node, vector&lt;int&gt;&amp; res) {        if (!node || (!node-&gt;left &amp;&amp; !node-&gt;right)) return;        res.push_back(node-&gt;val);        if (!node-&gt;left) leftBoundary(node-&gt;right, res);        else leftBoundary(node-&gt;left, res);    }    void rightBoundary(TreeNode* node, vector&lt;int&gt;&amp; res) {        if (!node || (!node-&gt;left &amp;&amp; !node-&gt;right)) return;        if (!node-&gt;right) rightBoundary(node-&gt;left, res);        else rightBoundary(node-&gt;right, res);        res.push_back(node-&gt;val);    }    void leaves(TreeNode* node, vector&lt;int&gt;&amp; res) {        if (!node) return;        if (!node-&gt;left &amp;&amp; !node-&gt;right) {            res.push_back(node-&gt;val);        }        leaves(node-&gt;left, res);        leaves(node-&gt;right, res);    }};</code></pre><p>下面这种方法把上面三种不同的递归揉合到了一个递归中，并用bool型变量来标记当前是求左边界结点还是求右边界结点，同时还有加入叶结点到结果res中的功能。如果左边界标记为true，那么将结点值加入结果res中，下面就是调用对左右结点调用递归函数了。根据上面的解题思路我们知道，如果是求左边界结点，优先调用左子结点，当左子结点不存在时再调右子结点，而对于求右边界结点，优先调用右子结点，当右子结点不存在时再调用左子结点。综上考虑，在对左子结点调用递归函数时，左边界标识设为leftbd &amp;&amp; node-&gt;left，而对右子结点调用递归的左边界标识设为leftbd &amp;&amp; !node-&gt;left，这样左子结点存在就会被优先调用。而右边界结点的情况就正好相反，调用左子结点的右边界标识为rightbd &amp;&amp; !node-&gt;right, 调用右子结点的右边界标识为 rightbd &amp;&amp; node-&gt;right，这样就保证了右子结点存在就会被优先调用，参见代码如下：</p><p>解法二：</p><pre><code>class Solution {public:    vector&lt;int&gt; boundaryOfBinaryTree(TreeNode* root) {        if (!root) return {};        vector&lt;int&gt; res{root-&gt;val};        helper(root-&gt;left, true, false, res);        helper(root-&gt;right, false, true, res);        return res;    }    void helper(TreeNode* node, bool leftbd, bool rightbd, vector&lt;int&gt;&amp; res) {        if (!node) return;        if (!node-&gt;left &amp;&amp; !node-&gt;right) {            res.push_back(node-&gt;val);            return;        }        if (leftbd) res.push_back(node-&gt;val);        helper(node-&gt;left, leftbd &amp;&amp; node-&gt;left, rightbd &amp;&amp; !node-&gt;right, res);        helper(node-&gt;right, leftbd &amp;&amp; !node-&gt;left, rightbd &amp;&amp; node-&gt;right, res);        if (rightbd) res.push_back(node-&gt;val);    }};</code></pre><p>下面这种解法实际上时解法一的迭代形式，整体思路基本一样，只是没有再用递归的写法，而是均采用while的迭代写法，注意在求右边界结点时迭代写法很难直接写出逆时针的顺序，我们可以先反过来保存，最后再调个顺序即可，参见代码如下：</p><p>解法三：</p><pre><code>class Solution {public:    vector&lt;int&gt; boundaryOfBinaryTree(TreeNode* root) {        if (!root) return {};        vector&lt;int&gt; res, right;        TreeNode *l = root-&gt;left, *r = root-&gt;right, *p = root;        if (root-&gt;left || root-&gt;right) res.push_back(root-&gt;val);        while (l &amp;&amp; (l-&gt;left || l-&gt;right)) {            res.push_back(l-&gt;val);            if (l-&gt;left) l = l-&gt;left;            else l = l-&gt;right;        }        stack&lt;TreeNode*&gt; st;        while (p || !st.empty()) {            if (p) {                st.push(p);                if (!p-&gt;left &amp;&amp; !p-&gt;right) res.push_back(p-&gt;val);                p = p-&gt;left;            } else {                p = st.top(); st.pop();                p = p-&gt;right;            }        }        while (r &amp;&amp; (r-&gt;left || r-&gt;right)) {            right.push_back(r-&gt;val);            if (r-&gt;right) r = r-&gt;right;            else r = r-&gt;left;        }        res.insert(res.end(), right.rbegin(), right.rend());        return res;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;545-Boundary-of-Binary-Tree-二叉树的边界&quot;&gt;&lt;a href=&quot;#545-Boundary-of-Binary-Tree-二叉树的边界&quot; class=&quot;headerlink&quot; title=&quot;545.Boundary of Binary Tree 二叉树的边界&quot;&gt;&lt;/a&gt;545.Boundary of Binary Tree 二叉树的边界&lt;/h1&gt;&lt;p&gt;Given a binary tree, return the values of its boundary in anti-clockwise direction starting from root. Boundary includes left boundary, leaves, and right boundary in order without duplicate nodes.&lt;/p&gt;
&lt;p&gt;Left boundary is defined as the path from root to the left-most node. Right boundary is defined as the path from root to the right-most node. If the root doesn’t have left subtree or right subtree, then the root itself is left boundary or right boundary. Note this definition only applies to the input binary tree, and not applies to any subtrees.&lt;/p&gt;
&lt;p&gt;The left-most node is defined as a leaf node you could reach when you always firstly travel to the left subtree if exists. If not, travel to the right subtree. Repeat until you reach a leaf node.&lt;/p&gt;
&lt;p&gt;The right-most node is also defined by the same way with left and right exchanged.&lt;/p&gt;
    
    </summary>
    
      <category term="2018年10月" scheme="http://yoursite.com/categories/2018%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>116.Populating Next Right Pointers in Each Node填充同一层的兄弟节点</title>
    <link href="http://yoursite.com/2018/10/04/116.Populating%20Next%20Right%20Pointers%20in%20Each%20Node%E5%A1%AB%E5%85%85%E5%90%8C%E4%B8%80%E5%B1%82%E7%9A%84%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9/"/>
    <id>http://yoursite.com/2018/10/04/116.Populating Next Right Pointers in Each Node填充同一层的兄弟节点/</id>
    <published>2018-10-04T11:13:54.000Z</published>
    <updated>2019-07-17T03:53:33.976Z</updated>
    
    <content type="html"><![CDATA[<h1 id="116-Populating-Next-Right-Pointers-in-Each-Node填充同一层的兄弟节点"><a href="#116-Populating-Next-Right-Pointers-in-Each-Node填充同一层的兄弟节点" class="headerlink" title="116.Populating Next Right Pointers in Each Node填充同一层的兄弟节点"></a>116.Populating Next Right Pointers in Each Node填充同一层的兄弟节点</h1><p>给定一个二叉树</p><pre><code>struct TreeLinkNode {  TreeLinkNode *left;  TreeLinkNode *right;  TreeLinkNode *next;}</code></pre><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><a id="more"></a><p>说明:</p><p>你只能使用额外常数空间。<br>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。<br>你可以假设它是一个完美二叉树（即所有叶子节点都在同一层，每个父节点都有两个子节点）。<br>示例:</p><pre><code>给定完美二叉树，     1   /  \  2    3 / \  / \4  5  6  7</code></pre><p>调用你的函数后，该完美二叉树变为：</p><pre><code>     1 -&gt; NULL   /  \  2 -&gt; 3 -&gt; NULL / \  / \4-&gt;5-&gt;6-&gt;7 -&gt; NULL</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用两个指针pre和cur，其中pre标记每一层的起始节点，cur用来遍历该层的节点</p><pre><code>/** * Definition for binary tree with next pointer. * struct TreeLinkNode { *  int val; *  TreeLinkNode *left, *right, *next; *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {} * }; */class Solution {public:    void connect(TreeLinkNode *root) {        if(!root) return;        TreeLinkNode *pre=root;        TreeLinkNode *cur=NULL;        while(pre-&gt;left){            cur=pre;            while(cur){                cur-&gt;left-&gt;next=cur-&gt;right;                if(cur-&gt;next) cur-&gt;right-&gt;next=cur-&gt;next-&gt;left;                cur=cur-&gt;next;            }            pre=pre-&gt;left;        }    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;116-Populating-Next-Right-Pointers-in-Each-Node填充同一层的兄弟节点&quot;&gt;&lt;a href=&quot;#116-Populating-Next-Right-Pointers-in-Each-Node填充同一层的兄弟节点&quot; class=&quot;headerlink&quot; title=&quot;116.Populating Next Right Pointers in Each Node填充同一层的兄弟节点&quot;&gt;&lt;/a&gt;116.Populating Next Right Pointers in Each Node填充同一层的兄弟节点&lt;/h1&gt;&lt;p&gt;给定一个二叉树&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct TreeLinkNode {
  TreeLinkNode *left;
  TreeLinkNode *right;
  TreeLinkNode *next;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。&lt;/p&gt;
&lt;p&gt;初始状态下，所有 next 指针都被设置为 NULL。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年10月" scheme="http://yoursite.com/categories/2018%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>操作系统面试高频题</title>
    <link href="http://yoursite.com/2018/09/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%A2%98/"/>
    <id>http://yoursite.com/2018/09/21/操作系统面试高频题/</id>
    <published>2018-09-21T09:12:13.000Z</published>
    <updated>2019-07-17T03:53:33.996Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统面试高频题"><a href="#操作系统面试高频题" class="headerlink" title="操作系统面试高频题"></a>操作系统面试高频题</h1><p>整理一下互联网公司操作系统面试高频题</p><a id="more"></a><h2 id="（1）-进程与线程的区别和联系"><a href="#（1）-进程与线程的区别和联系" class="headerlink" title="（1） 进程与线程的区别和联系"></a>（1） 进程与线程的区别和联系</h2><p>进程是具有一定功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源调度和分配的一个独立单位。<br>线程是进程的实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。<br>一个进程可以有多个线程，多个线程也可以并发执行<br>如果你对进程或者线程不太熟悉，建议阅读：<a href="https://link.zhihu.com/?target=http%3A//www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="noopener">进程与线程的一个简单解释</a></p><h2 id="（2）-一个进程可以创建多少线程，和什么有关"><a href="#（2）-一个进程可以创建多少线程，和什么有关" class="headerlink" title="（2） 一个进程可以创建多少线程，和什么有关"></a>（2） 一个进程可以创建多少线程，和什么有关</h2><h2 id="（3）-一个程序从开始运行到结束的完整过程（四个过程）"><a href="#（3）-一个程序从开始运行到结束的完整过程（四个过程）" class="headerlink" title="（3） 一个程序从开始运行到结束的完整过程（四个过程）"></a>（3） 一个程序从开始运行到结束的完整过程（四个过程）</h2><p>源程序到可执行程序的过程。在这个过程中，会发生如下的变化：</p><p>.c文件生成.obj文件的过程，称为编译，.obj文件生成到.exe文件的过程，称为链接。<br>.obj文件就是一个是程序编译生成的二进制文件，当.exe文件生成以后.obj文件就会被删除。<br>事实上，.c文件生成.exe文件的过程总共是经历了预处理，编译，汇编，链接，这四个过程。</p><p>1、预处理<br>为了接下来能够解释的更加清楚，使用linux平台下的gcc编译器解释。<br>先书写一个非常简单的程序来介绍：</p><pre><code>1 #include&lt;stdio.h&gt;2 3 int main()4 {5     printf(&quot;hello&quot;);6 7     return 0;8 }</code></pre><p>直接编译得到：</p><p>第一步发生的是预编译，使用-E指令会使程序只进行到预编译指令。经过预编译指令后的会生成一个.i文件。</p><p>在预编译的过程中，主要处理源代码中的预处理指令，引入头文件，去除注释，处理所有的条件编译指令，宏的替换，添加行号，保留所有的编译器指令。</p><p>当进行预编译以后的文件中将不再存在宏，所有的宏都已经被替代。当想要判断宏是否正确或者头文件包含是否正确时，也可以通过预编译来查看。</p><p>2、编译</p><p>在预处理结束后，进行的是编译。编译过程所进行的是对预处理后的文件进行语法分析，词法分析，语义分析，符号汇总，然后生成汇编代码。</p><p>3、汇编</p><p>汇编过程将汇编代码转成二进制文件，二进制文件就可以让机器来读取。每一条汇编语句都会产生一句机器语言。</p><p>在这里最终会生成一个重定位目标文件 .o文件，类似windows下的.obj文件。这里生成的目标文件里面就是二进制文件。另外，在这里会形成符号表，给这些符号会分配虚拟地址。</p><p>4、链接</p><p>由汇编程序生成的目标文件并不能立即就被执行，其中可能还有许多没有解决的问题。例如，某个源文件中的函数可能引用了另一个源文件中定义的某个符号（如变量或者函数调用等）；在程序中可能调用了某个库文件中的函数等等。所有这些问题，都需要经链接程序的处理方能得以解决。链接程序的主要工作就是将有关的目标文件彼此相连接，也即将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体。</p><p>链接分为静态链接和动态链接：</p><p>静态链接：后缀是.a，主要在编译的时候将库文件里面代码搬迁到可执行的文件中；</p><p>动态链接：后缀是.so,主要在执行的时候需要转换到库文件代码执行；</p><p>两种链接的优缺点：</p><p>（1）静态的链接产生的可执行的文件体积比较的大；而动态链接的可执行文件的体积比较小；</p><p>（2）动态的链接的编译的效率比较的高；</p><p>（3）静态链接的可执行的文件执行的效率高</p><p>（4）静态链接的可执行的文件的“布局”比较好一点；</p><h2 id="（4）-进程通信方法（Linux和windows下），线程通信方法（Linux和windows下）"><a href="#（4）-进程通信方法（Linux和windows下），线程通信方法（Linux和windows下）" class="headerlink" title="（4） 进程通信方法（Linux和windows下），线程通信方法（Linux和windows下）"></a>（4） 进程通信方法（Linux和windows下），线程通信方法（Linux和windows下）</h2><p>主要分为：管道、系统IPC（包括消息队列、信号量、共享存储）、SOCKET</p><p>管道主要分为：普通管道PIPE 、流管道（s_pipe）、命名管道（name_pipe）</p><p>管道是一种半双工的通信方式，数据只能单项流动，并且只能在具有亲缘关系的进程间流动，进程的亲缘关系通常是父子进程<br>命名管道也是半双工的通信方式，它允许无亲缘关系的进程间进行通信<br>信号量是一个计数器，用来控制多个进程对资源的访问，它通常作为一种锁机制。<br>消息队列是消息的链表，存放在内核中并由消息队列标识符标识。<br>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。<br>共享内存就是映射一段能被其它进程访问的内存，这段共享内存由一个进程创建，但是多个进程可以访问。<br>如果你对进程的通信方式不太熟悉，建议阅读： <a href="https://blog.csdn.net/yufaw/article/details/7409596" target="_blank" rel="noopener">进程间的几种通信方式</a></p><h2 id="（5）-进程调度方法详细介绍"><a href="#（5）-进程调度方法详细介绍" class="headerlink" title="（5） 进程调度方法详细介绍"></a>（5） 进程调度方法详细介绍</h2><h2 id="（6）-页面置换方法详细介绍"><a href="#（6）-页面置换方法详细介绍" class="headerlink" title="（6） 页面置换方法详细介绍"></a>（6） 页面置换方法详细介绍</h2><h2 id="（7）-能否实现一个LRU算法"><a href="#（7）-能否实现一个LRU算法" class="headerlink" title="（7） 能否实现一个LRU算法"></a>（7） 能否实现一个LRU算法</h2><h2 id="（8）-死锁的必要条件（怎么检测死锁，解决死锁问题）"><a href="#（8）-死锁的必要条件（怎么检测死锁，解决死锁问题）" class="headerlink" title="（8） 死锁的必要条件（怎么检测死锁，解决死锁问题）"></a>（8） 死锁的必要条件（怎么检测死锁，解决死锁问题）</h2><p>在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲就是两个或多个进程无限期的阻塞、相互等待的一种状态。</p><p>死锁产生的四个条件（有一个条件不成立，则不会产生死锁）</p><p>互斥条件：一个资源一次只能被一个进程使用<br>请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放<br>不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺<br>循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系<br>如果对死锁还不是太熟悉，建议阅读：<a href="http://www.cnblogs.com/Jessy/p/3540724.html" target="_blank" rel="noopener">死锁产生的原因和解锁的方法</a></p><h2 id="（9）-哲学家就餐，银行家，读者写者，生产者消费者（怎么加锁解锁，伪代码）"><a href="#（9）-哲学家就餐，银行家，读者写者，生产者消费者（怎么加锁解锁，伪代码）" class="headerlink" title="（9） 哲学家就餐，银行家，读者写者，生产者消费者（怎么加锁解锁，伪代码）"></a>（9） 哲学家就餐，银行家，读者写者，生产者消费者（怎么加锁解锁，伪代码）</h2><h2 id="（10）-海量数据的bitmap使用原理"><a href="#（10）-海量数据的bitmap使用原理" class="headerlink" title="（10） 海量数据的bitmap使用原理"></a>（10） 海量数据的bitmap使用原理</h2><h2 id="（11）-布隆过滤器原理与优点"><a href="#（11）-布隆过滤器原理与优点" class="headerlink" title="（11） 布隆过滤器原理与优点"></a>（11） 布隆过滤器原理与优点</h2><h2 id="（12）-布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题"><a href="#（12）-布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题" class="headerlink" title="（12） 布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题"></a>（12） 布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题</h2><h2 id="（13）-同步IO和异步IO"><a href="#（13）-同步IO和异步IO" class="headerlink" title="（13） 同步IO和异步IO"></a>（13） 同步IO和异步IO</h2><h2 id="（14）-文件读写使用的系统调用"><a href="#（14）-文件读写使用的系统调用" class="headerlink" title="（14） 文件读写使用的系统调用"></a>（14） 文件读写使用的系统调用</h2><h2 id="（15）-线程池的了解、优点、调度处理方式和保护任务队列的方式"><a href="#（15）-线程池的了解、优点、调度处理方式和保护任务队列的方式" class="headerlink" title="（15） 线程池的了解、优点、调度处理方式和保护任务队列的方式"></a>（15） 线程池的了解、优点、调度处理方式和保护任务队列的方式</h2><h2 id="（16）-怎么回收线程"><a href="#（16）-怎么回收线程" class="headerlink" title="（16） 怎么回收线程"></a>（16） 怎么回收线程</h2><h2 id="（17）-僵尸进程问题"><a href="#（17）-僵尸进程问题" class="headerlink" title="（17） 僵尸进程问题"></a>（17） 僵尸进程问题</h2><h2 id="（18）-多线程同步（尤其是如果项目中用到了多线程，很大可能会结合讨论）"><a href="#（18）-多线程同步（尤其是如果项目中用到了多线程，很大可能会结合讨论）" class="headerlink" title="（18） 多线程同步（尤其是如果项目中用到了多线程，很大可能会结合讨论）"></a>（18） 多线程同步（尤其是如果项目中用到了多线程，很大可能会结合讨论）</h2><h2 id="（19）-memcache了解"><a href="#（19）-memcache了解" class="headerlink" title="（19） memcache了解"></a>（19） memcache了解</h2><h2 id="（20）-异常和中断的区别"><a href="#（20）-异常和中断的区别" class="headerlink" title="（20） 异常和中断的区别"></a>（20） 异常和中断的区别</h2><h2 id="（21）-一般情况下在Linux-windows平台下栈空间的大小"><a href="#（21）-一般情况下在Linux-windows平台下栈空间的大小" class="headerlink" title="（21） 一般情况下在Linux/windows平台下栈空间的大小"></a>（21） 一般情况下在Linux/windows平台下栈空间的大小</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统面试高频题&quot;&gt;&lt;a href=&quot;#操作系统面试高频题&quot; class=&quot;headerlink&quot; title=&quot;操作系统面试高频题&quot;&gt;&lt;/a&gt;操作系统面试高频题&lt;/h1&gt;&lt;p&gt;整理一下互联网公司操作系统面试高频题&lt;/p&gt;
    
    </summary>
    
      <category term="2018年9月" scheme="http://yoursite.com/categories/2018%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Operating System" scheme="http://yoursite.com/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>数据库面试高频题</title>
    <link href="http://yoursite.com/2018/09/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%A2%98/"/>
    <id>http://yoursite.com/2018/09/21/数据库面试高频题/</id>
    <published>2018-09-21T09:12:13.000Z</published>
    <updated>2019-07-17T03:53:33.997Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库面试高频题"><a href="#数据库面试高频题" class="headerlink" title="数据库面试高频题"></a>数据库面试高频题</h1><p>整理一下互联网公司数据库面试高频题</p><a id="more"></a><h2 id="（1）-关系型和非关系型数据库的区别（各自优点）"><a href="#（1）-关系型和非关系型数据库的区别（各自优点）" class="headerlink" title="（1） 关系型和非关系型数据库的区别（各自优点）"></a>（1） 关系型和非关系型数据库的区别（各自优点）</h2><p>关系数据库，是建立在关系模型基础上的数据库，关系模型由关系数据结构、关系操作集合、关系完整性约束三部分组成。<br>简单说，关系型数据库是由多张能互相联接的二维行列表格组成的数据库。<br><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1fw5t2txi6oj30z10extdp.jpg" alt="image"></p><h2 id="（2）-常用SQL语句（DDL-DML-DCL-TCL）"><a href="#（2）-常用SQL语句（DDL-DML-DCL-TCL）" class="headerlink" title="（2） 常用SQL语句（DDL,DML,DCL,TCL）"></a>（2） 常用SQL语句（DDL,DML,DCL,TCL）</h2><h2 id="（3）-数据库中join的类型与区别（inner-join-outer-join-cross-join-natural-join-self-join），注意适用场景和sql语句的编写"><a href="#（3）-数据库中join的类型与区别（inner-join-outer-join-cross-join-natural-join-self-join），注意适用场景和sql语句的编写" class="headerlink" title="（3） 数据库中join的类型与区别（inner join, outer join, cross join, natural join, self join），注意适用场景和sql语句的编写"></a>（3） 数据库中join的类型与区别（inner join, outer join, cross join, natural join, self join），注意适用场景和sql语句的编写</h2><h2 id="（4）-数据库的索引类型-数据库索引的作用"><a href="#（4）-数据库的索引类型-数据库索引的作用" class="headerlink" title="（4） 数据库的索引类型,数据库索引的作用"></a>（4） 数据库的索引类型,数据库索引的作用</h2><p>MySQL数据库几个基本的索引类型：普通索引、唯一索引、主键索引、全文索引</p><p>1)    数据库索引好比是一本书前面的目录，能加快数据库的查询速度。索引是对数据库表中一个或多个列（例如，employee 表的姓氏 (lname) 列）的值进行排序的结构。如果想按特定职员的姓来查找他或她，则与在表中搜索所有的行相比，索引有助于更快地获取信息。<br>2)    优点<br>大大加快数据的检索速度; 创建唯一性索引，保证数据库表中每一行数据的唯一性；加速表和表之间的连接; 在使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间。<br>3)    缺点<br>索引需要占用数据表以外的物理存储空间；创建索引和维护索引要花费一定的时间；当对表进行更新操作时，索引需要被重建，这样降低了数据的维护速度。<br>4)    类型<br><strong>唯一索引</strong>——UNIQUE，例如：create unique index stusno on student（sno）；表明此索引的每一个索引值只对应唯一的数据记录，对于单列惟一性索引，这保证单列不包含重复的值。对于多列惟一性索引，保证多个值的组合不重复。<br><strong><br>主键索引</strong>——primary key，数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。   在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。 </p><p><strong>聚集索引</strong>（也叫聚簇索引）——cluster，在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引，如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。</p><p>5)    实现方式<br>B+树、散列索引、位图索引</p><p>索引加快数据库的检索速度<br>索引降低了插入、删除、修改等维护任务的速度<br>唯一索引可以确保每一行数据的唯一性<br>通过使用索引，可以在查询的过程中使用优化隐藏器，提高 系统的性能<br>索引需要占物理和数据空间<br>如果你对索引还不太熟悉，建议阅读：<a href="https://kb.cnblogs.com/page/45712/" target="_blank" rel="noopener">漫谈数据库索引</a></p><h2 id="（5）-聚集索引和非聚集索引的区别（叶节点存储内容）"><a href="#（5）-聚集索引和非聚集索引的区别（叶节点存储内容）" class="headerlink" title="（5） 聚集索引和非聚集索引的区别（叶节点存储内容）"></a>（5） 聚集索引和非聚集索引的区别（叶节点存储内容）</h2><p>1)    聚集索引表示表中存储的数据按照索引的顺序存储，检索效率比非聚集索引高，但对数据更新影响较大。非聚集索引表示数据存储在一个地方，索引存储在另一个地方，索引带有指针指向数据的存储位置，非聚集索引检索效率比聚集索引低，但对数据更新影响较小。<br>2)    聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个。聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续</p><h2 id="（6）-唯一性索引和主码索引的区别"><a href="#（6）-唯一性索引和主码索引的区别" class="headerlink" title="（6） 唯一性索引和主码索引的区别"></a>（6） 唯一性索引和主码索引的区别</h2><h2 id="（7）-索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）"><a href="#（7）-索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）" class="headerlink" title="（7） 索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）"></a>（7） 索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）</h2><p>通常,通过索引查询数据比全表扫描要快.但是我们也必须注意到它的代价.</p><p>索引需要空间来存储,也需要定期维护, 每当有记录在表中增减或索引列被修改时,索引本身也会被修改. 这意味着每条记录的INSERT,DELETE,UPDATE将为此多付出4,5 次的磁盘I/O. 因为索引需要额外的存储空间和处理,那些不必要的索引反而会使查询反应时间变慢.使用索引查询不一定能提高查询性能,索引范围查询(INDEX RANGE SCAN)适用于两种情况:</p><p>基于一个范围的检索,一般查询返回结果集小于表中记录数的30%<br>基于非唯一性索引的检索</p><h2 id="（8）-索引的底层实现（B-树，为何不采用红黑树，B树）"><a href="#（8）-索引的底层实现（B-树，为何不采用红黑树，B树）" class="headerlink" title="（8） 索引的底层实现（B+树，为何不采用红黑树，B树）"></a>（8） 索引的底层实现（B+树，为何不采用红黑树，B树）</h2><p>B-Tree和B+Tree</p><p>目前大部分数据库系统及文件系统都采用B-Tree和B+Tree作为索引结构。</p><p>索引<br>索引的目的：提高查询效率<br>原理：通过不断的缩小想要获得数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是我们总是通过同一种查找方式来锁定数据。<br>数据结构：B+树</p><h2 id="（9）-B树和B-树具体实现"><a href="#（9）-B树和B-树具体实现" class="headerlink" title="（9） B树和B+树具体实现"></a>（9） B树和B+树具体实现</h2><p>B 树可以看作是对2-3查找树的一种扩展，即他允许每个节点有M-1个子节点。</p><p>根节点至少有两个子节点<br>每个节点有M-1个key，并且以升序排列<br>位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间<br>其它节点至少有M/2个子节点<br>下图是一个M=4 阶的B树:</p><p>B+树是对B树的一种变形树，它与B树的差异在于：</p><p>有k个子结点的结点必然有k个关键码；<br>非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。<br>树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。<br>如下图，是一个B+树:</p><h2 id="（10）-索引最左前缀问题"><a href="#（10）-索引最左前缀问题" class="headerlink" title="（10） 索引最左前缀问题"></a>（10） 索引最左前缀问题</h2><h2 id="（11）-Mysql的优化（高频，索引优化，性能优化）"><a href="#（11）-Mysql的优化（高频，索引优化，性能优化）" class="headerlink" title="（11） Mysql的优化（高频，索引优化，性能优化）"></a>（11） Mysql的优化（高频，索引优化，性能优化）</h2><h2 id="（12）-数据库引擎介绍，innodb和myisam的特点与区别"><a href="#（12）-数据库引擎介绍，innodb和myisam的特点与区别" class="headerlink" title="（12） 数据库引擎介绍，innodb和myisam的特点与区别"></a>（12） 数据库引擎介绍，innodb和myisam的特点与区别</h2><h2 id="（13）-数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）"><a href="#（13）-数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）" class="headerlink" title="（13） 数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）"></a>（13） 数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）</h2><h2 id="（14）-数据库隔离性设置不同会出现的问题（脏读、不可重复读、丢失修改、幻读）"><a href="#（14）-数据库隔离性设置不同会出现的问题（脏读、不可重复读、丢失修改、幻读）" class="headerlink" title="（14） 数据库隔离性设置不同会出现的问题（脏读、不可重复读、丢失修改、幻读）"></a>（14） 数据库隔离性设置不同会出现的问题（脏读、不可重复读、丢失修改、幻读）</h2><h2 id="（15）-数据库的隔离级别，mysql和Oracle的隔离级别分别是什么"><a href="#（15）-数据库的隔离级别，mysql和Oracle的隔离级别分别是什么" class="headerlink" title="（15） 数据库的隔离级别，mysql和Oracle的隔离级别分别是什么"></a>（15） 数据库的隔离级别，mysql和Oracle的隔离级别分别是什么</h2><h2 id="（16）-数据库连接池的作用"><a href="#（16）-数据库连接池的作用" class="headerlink" title="（16） 数据库连接池的作用"></a>（16） 数据库连接池的作用</h2><h2 id="（17）-Mysql的表空间方式，各自特点"><a href="#（17）-Mysql的表空间方式，各自特点" class="headerlink" title="（17） Mysql的表空间方式，各自特点"></a>（17） Mysql的表空间方式，各自特点</h2><h2 id="（18）-分布式事务"><a href="#（18）-分布式事务" class="headerlink" title="（18） 分布式事务"></a>（18） 分布式事务</h2><p>本地事务数据库断电的这种情况，它是怎么保证数据一致性的呢？我们使用SQL Server来举例，我们知道我们在使用 SQL Server 数据库是由两个文件组成的，一个数据库文件和一个日志文件，通常情况下，日志文件都要比数据库文件大很多。数据库进行任何写入操作的时候都是要先写日志的，同样的道理，我们在执行事务的时候数据库首先会记录下这个事务的redo操作日志，然后才开始真正操作数据库，在操作之前首先会把日志文件写入磁盘，那么当突然断电的时候，即使操作没有完成，在重新启动数据库时候，数据库会根据当前数据的情况进行undo回滚或者是redo前滚，这样就保证了数据的强一致性。</p><h2 id="（19）-数据库的范式"><a href="#（19）-数据库的范式" class="headerlink" title="（19） 数据库的范式"></a>（19） 数据库的范式</h2><p>1)    第一范式，数据库表中的字段都是单一属性的，不可再分；每一个属性都是原子项，不可分割；如果实体中的某个属性有多个值时，必须拆分为不同的属性 通俗解释。1NF是关系模式应具备的最起码的条件，如果数据库设计不能满足第一范式，就不称为关系型数据库。也就是说，只要是关系型数据库，就一定满足第一范式。</p><p>2)    第二范式，数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖，即符合第二范式；如果一个表中某一个字段A的值是由另外一个字段或一组字段B的值来确定的，就称为A函数依赖于B；当某张表中的非主键信息不是由整个主键函数来决定时，即存在依赖于该表中不是主键的部分或者依赖于主键一部分的部分时，通常会违反2NF。</p><p>3)    第三范式，在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合3NF；第三范式规则查找以消除没有直接依赖于第一范式和第二范式形成的表的主键的属性。我们为没有与表的主键关联的所有信息建立了一张新表。每张新表保存了来自源表的信息和它们所依赖的主键；如果某一属性依赖于其他非主键属性，而其他非主键属性又依赖于主键，那么这个属性就是间接依赖于主键，这被称作传递依赖于主属性。 通俗理解：一张表最多只存2层同类型信息 。</p><h2 id="（20）-数据的锁的种类，加锁的方式"><a href="#（20）-数据的锁的种类，加锁的方式" class="headerlink" title="（20） 数据的锁的种类，加锁的方式"></a>（20） 数据的锁的种类，加锁的方式</h2><h2 id="（21）-视图的作用与使用方法（如何删除等）"><a href="#（21）-视图的作用与使用方法（如何删除等）" class="headerlink" title="（21） 视图的作用与使用方法（如何删除等）"></a>（21） 视图的作用与使用方法（如何删除等）</h2><h2 id="（22）-分库分表，主从复制，读写分离。（我不会，也没碰到过）"><a href="#（22）-分库分表，主从复制，读写分离。（我不会，也没碰到过）" class="headerlink" title="（22） 分库分表，主从复制，读写分离。（我不会，也没碰到过）"></a>（22） 分库分表，主从复制，读写分离。（我不会，也没碰到过）</h2><h2 id="（23）-项目中哪里用到了数据库，怎么用的"><a href="#（23）-项目中哪里用到了数据库，怎么用的" class="headerlink" title="（23） 项目中哪里用到了数据库，怎么用的"></a>（23） 项目中哪里用到了数据库，怎么用的</h2><h2 id="（24）-事务是什么"><a href="#（24）-事务是什么" class="headerlink" title="（24） 事务是什么"></a>（24） 事务是什么</h2><p>1)    事务（txn）是一系列在共享数据库上执行的行为，以达到更高层次更复杂逻辑的功能。事务是DBMS中最基础的单位，事务不可分割。</p><p>2)    ACID，是指在可靠数据库管理系统（DBMS）中，事务(transaction)所应该具有的四个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。</p><p>3)    原子性是指事务是一个不可再分割的工作单位，事务中的操作要么都发生，要么都不发生。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p><p>4)    一致性是指事务使得系统从一个一致的状态转换到另一个一致状态。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。</p><p>5)    多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。这指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。</p><p>6)    持久性，意味着在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。即使出现了任何事故比如断电等，事务一旦提交，则持久化保存在数据库中。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据库面试高频题&quot;&gt;&lt;a href=&quot;#数据库面试高频题&quot; class=&quot;headerlink&quot; title=&quot;数据库面试高频题&quot;&gt;&lt;/a&gt;数据库面试高频题&lt;/h1&gt;&lt;p&gt;整理一下互联网公司数据库面试高频题&lt;/p&gt;
    
    </summary>
    
      <category term="2018年9月" scheme="http://yoursite.com/categories/2018%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Database" scheme="http://yoursite.com/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>C++面试高频题</title>
    <link href="http://yoursite.com/2018/09/21/C++%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%A2%98/"/>
    <id>http://yoursite.com/2018/09/21/C++面试高频题/</id>
    <published>2018-09-21T09:12:13.000Z</published>
    <updated>2019-07-17T03:53:33.991Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-面试高频题"><a href="#C-面试高频题" class="headerlink" title="C++面试高频题"></a>C++面试高频题</h1><p>整理一下互联网公司语言基础（C++）面试高频题</p><a id="more"></a><p>##（1） 指针和引用的区别</p><h3 id="联系"><a href="#联系" class="headerlink" title="联系:"></a>联系:</h3><h4 id="a"><a href="#a" class="headerlink" title="a."></a>a.</h4><p>指针和引用本质上都是地址的概念,引用在内部其实是用const指针来实现的.</p><h4 id="b"><a href="#b" class="headerlink" title="b."></a>b.</h4><p>给函数传递参数的时候,一级指针和引用作为函数参数的时候可以达到相同的效果.</p><h4 id="c"><a href="#c" class="headerlink" title="c."></a>c.</h4><p>指针的大部分效果都可以通过引用来实现。</p><h4 id="d"><a href="#d" class="headerlink" title="d."></a>d.</h4><p>二级指针作为参数的时候就是希望在函数的内部修改指针的指向.这个时候利用指针的引用可以达到同样的效果.</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别:"></a>区别:</h3><h4 id="a-1"><a href="#a-1" class="headerlink" title="a."></a>a.</h4><p>定义引用的时候必须初始化,定义指针的时候可以不初始化.</p><h4 id="b-1"><a href="#b-1" class="headerlink" title="b."></a>b.</h4><p>引用不能引用空,但是指针可以指向空.</p><h4 id="c-1"><a href="#c-1" class="headerlink" title="c."></a>c.</h4><p>引用的关系一旦确定,就无法改变;引用永远指向的是用来对它初始化的对象;而非常属性的指针是可以改变指向的.</p><h4 id="d-1"><a href="#d-1" class="headerlink" title="d."></a>d.</h4><p>指针是一个实体变量,在32位操作系统上面都是4个字节.而引用只是一个别名,其大小和其应用的对象的类型有关系.</p><h4 id="e"><a href="#e" class="headerlink" title="e."></a>e.</h4><p>有指向指针的指针,但是没有引用引用的引用;因为引用一旦建立,它就表示初始化它的对象.</p><h4 id="f"><a href="#f" class="headerlink" title="f."></a>f.</h4><p>有引用指针的引用,但是没有指向引用的指针；</p><h4 id="g"><a href="#g" class="headerlink" title="g."></a>g.</h4><p>有指针数组,但是没有引用数组,但是有数组的引用.</p><h3 id="参考答案2："><a href="#参考答案2：" class="headerlink" title="参考答案2："></a>参考答案2：</h3><h4 id="1"><a href="#1" class="headerlink" title="1)"></a>1)</h4><p>指针是一个实体，需要分配内存空间。引用只是变量的别名，不需要分配内存空间。</p><h4 id="2"><a href="#2" class="headerlink" title="2)"></a>2)</h4><p>引用在定义的时候必须进行初始化，并且不能够改变。指针在定义的时候不一定要初始化，并且指向的空间可变。（注：不能有引用的值不能为NULL）</p><h4 id="3"><a href="#3" class="headerlink" title="3)"></a>3)</h4><p>有多级指针，但是没有多级引用，只能有一级引用。</p><h4 id="4"><a href="#4" class="headerlink" title="4)"></a>4)</h4><p>指针和引用的自增运算结果不一样。（指针是指向下一个空间，引用时引用的变量值加1）</p><h4 id="5"><a href="#5" class="headerlink" title="5)"></a>5)</h4><p>sizeof 引用得到的是所指向的变量（对象）的大小，而sizeof 指针得到的是指针本身的大小。</p><h4 id="6"><a href="#6" class="headerlink" title="6)"></a>6)</h4><p>引用访问一个变量是直接访问，而指针访问一个变量是间接访问。</p><h4 id="7"><a href="#7" class="headerlink" title="7)"></a>7)</h4><p>使用指针前最好做类型检查，防止野指针的出现；</p><h4 id="8"><a href="#8" class="headerlink" title="8)"></a>8)</h4><p>引用底层是通过指针实现的；</p><h4 id="9"><a href="#9" class="headerlink" title="9)"></a>9)</h4><p>作为参数时也不同，传指针的实质是传值，传递的值是指针的地址；传引用的实质是传地址，传递的是变量的地址。</p><p>下面是一段代码非常的全面:</p><pre><code>#include &lt;iostream&gt;using namespace std;void foo(int a[3])/*这个地方传递的是数组的首地址*/{     cout &lt;&lt; sizeof(a)/sizeof(a[0]) &lt;&lt; endl;}void bar(int (&amp;a)[3])/*这里传参的时候就是数组的整体*/{     cout &lt;&lt; sizeof(a)/sizeof(a[0]) &lt;&lt; endl;}int main(void){     int a;     int* p = &amp;a;     int** pp = &amp;p;/*存在指向指针的指针*/     int&amp; r  = a;     int&amp;&amp; rr = r;/*error没有引用引用的引用*/     int*&amp;  rp = p; /*有引用指针的引用(指针引用)*/     int&amp;* pr = &amp;r; /*没有指向引用的指针(引用指针)*/     int x, y, z;     int* pa[] = {&amp;x,&amp;y,&amp;z};/*指针数组*/     int&amp; ra[] = {x,y,z};/*引用数组是不存在的因为引用不是一个实体*/     int arr[3] = {0};     int (&amp;ar)[3] = arr;/*数组引用(先近后远,先右后左)*/     foo(arr);/*这里传递的是数组的第一个元素的首地址*/     cout &lt;&lt; sizeof(arr)/sizeof(arr[0]) &lt;&lt; endl;     /*这里的数组名代表的是真个数组*/     int (*parr)[3] = &amp;arr;/*对数组名取地址得到的是一个数组指针                             这个时候arr代表的是数组的整体;*/     bar(arr);/*这里传递的就是数组的整体*/     return 0;}</code></pre><p>##（2） 堆和栈的区别</p><h4 id="a-管理方式不同"><a href="#a-管理方式不同" class="headerlink" title="a.管理方式不同:"></a>a.管理方式不同:</h4><p>栈是由编译器自动分配和释放,使用方便;而对于堆来说,分配和释放都必须由程序员来手动完成,不易管理,容易造成内存泄漏和内存碎片.</p><h4 id="b-可用内存空间不同"><a href="#b-可用内存空间不同" class="headerlink" title="b.可用内存空间不同:"></a>b.可用内存空间不同:</h4><p>对于栈来说,它可用的内存空间比较小;而对于堆来说它可以使用的空间比栈要大的多.</p><h4 id="c-能否产生碎片不同"><a href="#c-能否产生碎片不同" class="headerlink" title="c.能否产生碎片不同:"></a>c.能否产生碎片不同:</h4><p>由于栈采用的是后进先出的机制,所以栈空间没有内存碎片的产生;而对于堆来说,由于频繁的使用new/delete势必会造成内存空间分配的不连续,从而造成大量的碎片,使程序的效率降低.</p><h4 id="d-生长方向不同"><a href="#d-生长方向不同" class="headerlink" title="d.生长方向不同:"></a>d.生长方向不同:</h4><p>对于堆来说,它一般是向上的;即是向着地址增加的方向增长;对于栈来说,它一般是向下的,即向着地址减小的方向增长.</p><h4 id="e-分配的方式不同"><a href="#e-分配的方式不同" class="headerlink" title="e.分配的方式不同:"></a>e.分配的方式不同:</h4><p>对于堆来说,它只能是动态分配的;而对于栈来说,它分为静态分配和动态分配;静态分配由编译器来进行管理,而动态分配的栈和堆也是不一样的,动态分配的栈由编译器进行释放,无需我们程序员来释放.</p><h4 id="f-分配的效率不同"><a href="#f-分配的效率不同" class="headerlink" title="f.分配的效率不同:"></a>f.分配的效率不同:</h4><p>栈是机器系统提供的数据结构,计算机会在底层对栈提供支持:为栈分配专门的寄存器.压栈和出栈都由专门的指令进行.因此它的效率会很高;而堆则是由c/c++库函数实现的,机制是非常的负责的;例如要分配一块内存的时候,库函数会利用特定的算法在堆内存中搜索可用大小的内存空间;如果没有足够大的内存空间,就会调用系统功能去增加数据段的内存空间.这样才能得到足够大的可用的内存空间,因此堆内存的分配的效率比栈要低得多. </p><p>##（3） new和delete是如何实现的，new 与 malloc的异同处</p><h4 id="a-运算符和库函数的区别"><a href="#a-运算符和库函数的区别" class="headerlink" title="a.运算符和库函数的区别"></a>a.运算符和库函数的区别</h4><p>new/delete是运算符,只能在C++中使用,它可以重载;mallloc/free是C的标准库函数,在C/C++中都可以使用.</p><h4 id="b-2"><a href="#b-2" class="headerlink" title="b."></a>b.</h4><p>对于非内部的数据类型的对象而言,光用malloc/free是无法满足动态对象的要求的.对象在创建的时候需要执行构造函数,对象在消亡之前需要执行析构函数.而molloc/free是库函数而不是运算符,不在编译器的控制范围之内,编译器不能将执行构造函数和析构函数的任务强加给malloc/free.因此C++需要一个能够完成动态分配内存和初始化的new,以及一个能够完成清理和释放内存的运算符delete.</p><h4 id="c-2"><a href="#c-2" class="headerlink" title="c."></a>c.</h4><p>new的返回值是指定类型的指针,可以自动的计算所需要分配的内存大小.而malloc的返回值是一个void类型的指针,我们在使用的时候要进行强制类型转换,并且分配的大小也要程序员手动的计算.</p><h4 id="d-2"><a href="#d-2" class="headerlink" title="d."></a>d.</h4><p>new/delete完全覆盖了malloc/free的功能,只所以还要保留malloc/free,是因为我们的C++程序有时要调用用C编写的而C中又没有new/delete,只能使用malloc/free.</p><p>##（4） C和C++的区别</p><p>C/C++的联系：</p><p>C++是C的超集，兼容大部分C的语法的结构；<br>联系嘛我只能想到这个，毕竟cplusplus嘛！<br>C/C++区别：</p><p>第一点就应该想到C是面向过程的语言，而C++是面向对象的语言</p><p>C和C++动态管理内存的方法不一样，C是使用malloc/free函数，而C++除此之外还有new/delete关键字；（关于malooc/free与new/delete的不同又可以说一大堆，最后的扩展_1部分列出十大区别）；</p><p>接下来就不得不谈到C中的struct和C++的类，C++的类是C所没有的，但是C中的struct是可以在C++中正常使用的，并且C++对struct进行了进一步的扩展，使struct在C++中可以和class一样当做类使用，而唯一和class不同的地方在于struct的成员默认访问修饰符是public,而class默认的是private;</p><p>C++支持函数重载，而C不支持函数重载，而C++支持重载的依仗就在于C++的名字修饰与C不同，例如在C++中函数int fun(int ,int)经过名字修饰之后变为 _fun_int_int ,而C是<br>_fun，一般是这样的，所以C++才会支持不同的参数调用不同的函数；</p><p>C++中有引用，而C没有；这样就不得不提一下引用和指针的区别;</p><p>当然还有C++全部变量的默认链接属性是外链接，而C是内连接；</p><p>C 中用const修饰的变量不可以用在定义数组时的大小，但是C++用const修饰的变量可以（如果不进行&amp;,解引用的操作的话，是存放在符号表的，不开辟内存）；</p><p>当然还有局部变量的声明规则不同，多态，C++特有输入输出流之类的，很多，下面就不再列出来了； </p><p>##（5） C++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）</p><p>通常，我们聊到Java，第一印象“面向对象”，“没有指针，编写效率高，执行效率较低”。更深入、专业一点就谈论 “java内存自动回收(GC垃圾回收机制)，多线程编程”。<strong><br>java的三大特性是封装、继承和多态。</strong></p><p>总结如下：</p><p>1、 JAVA的应用在高层，C++在中间件和底层</p><p>2、 JAVA离不开业务逻辑，而C++可以离开业务为JAVA们服务</p><p>3、 java语言给开发人员提供了更为简洁的语法；取消了指针带来更高的代码质量；完全面向对象，独特的运行机制是其具有天然的可移植性。</p><p>4、 java 是运行在JVM上的，之所以说它的可移植性强，是因为jvm可以安装到任何的系统</p><p>5、 c++不是不能在其他系统运行，而是c++在不同的系统上运行，需要不同的编码（这一点不如java，只编写一次代码，到处运行）。java程序一般都是生成字节码，在JVM里面运行得到结果。</p><p>6、 java 在web 应用上具有c++ 无可比拟的优势</p><p>7、 java在桌面程序上不如c++实用，C++可以直接编译成exe文件，指针是c++的优势，可以直接对内存的操作，但同时具有危险性 。（操作内存的确是一项非常危险的事情，一旦指针指向的位置发生错误，或者误删除了内存中某个地址单元存放的重要数据，后果是可想而知的）。</p><p>8、 垃圾回收机制的区别。c++用析构函数回收垃圾，java自动回收（GC算法）,写C和C++程序时一定要注意内存的申请和释放。</p><p>9、 java 丰富的插件是java 发展如此迅速的原因<br>10、 java 很大的沿袭了c++的一些实用结构<br>11、 对于底层程序的编程以及控制方面的编程，c++很灵活，因为有句柄的存在。</p><p>Java并不仅仅是C++语言的一个变种，它们在某些本质问题上有根本的不同：</p><p>(1)Java比C++程序可靠性更高。有人曾估计每50行C++程序中至少有一个BUG。姑且不去讨论这个数字是否夸张，但是任何一个C++程序员都不得不承认C++语言在提供强大的功能的同时也提高了程序含BUG的可能性。Java语言通过改变语言的特性大大提高了程序的可靠性。</p><p>(2)Java语言不需要程序对内存进行分配和回收。Java丢弃了C++ 中很少使用的、很难理解的、令人迷惑的那些特性，如操作符重载、多继承、自动的强制类型转换。特别地，Java语言不使用指针，并提供了自动的废料收集，在Java语言中，内存的分配和回收都是自动进行的，程序员无须考虑内存碎片的问题。</p><p>(3)Java语言中没有指针的概念，引入了真正的数组。不同于C++中利用指针实现的“伪数组”，Java引入了真正的数组，同时将容易造成麻烦的指针从语言中去掉，这将有利于防止在c++程序中常见的因为数组操作越界等指针操作而对系统数据进行非法读写带来的不安全问题。</p><p>(4)Java用接口(Interface)技术取代C++程序中的多继承性。接口与多继承有同样的功能，但是省却了多继承在实现和维护上的复杂性。</p><h2 id="（6）-Struct和class的联系和区别"><a href="#（6）-Struct和class的联系和区别" class="headerlink" title="（6） Struct和class的联系和区别"></a>（6） Struct和class的联系和区别</h2><h3 id="联系-1"><a href="#联系-1" class="headerlink" title="联系"></a>联系</h3><p>1，定义和使用非常相似<br>2，两者都是container类型，这表示它们可以包含其他数据类型作为成员。</p><p>3，两者都拥有成员，包括：构造函数、方法、属性、字段、常量、枚举类型、事件、以及事件处理函数。</p><p>4，两者的成员都有其各自的存取范围。例如，可以将某一个成员声明为Public，而将另一个成员声明为Private。</p><p>5，两者都可以实现接口。</p><p>6，两者都可以公开一个默认属性，然而前提是这个属性至少要取得一个自变量。</p><p>7，两者都可以声明和触发事件，而且两者都可以声明委托（Delegate）。</p><h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><p>1，结构是实值类型（Value Types），而类则是引用类型（Reference Types）。</p><p>2，结构使用栈存储（Stack Allocation），而类使用堆存储（Heap Allocation）。</p><p>3，所有结构成员默认都是Public，而类的变量和常量数则默认位Private，不过其他类成员默认都是Public。</p><p>4，结构成员不能被声明位Protected，而类成员可以。</p><p>5，结构变量声明不能指定初始值、使用New关键字货对数组进行初始化，但是类变量声明可以。</p><p>6，结构不能声明默认的构造函数，也就是不拥有参数的非共享构造函数，但是类则无此限制。</p><p>7，二者都可以拥有共享构造函数，结构的共享构造函数不能带有参数，但是类的共享构造函数则可以带或者不带参数。</p><p>8，结构不允许声明析构函数（Destructor），类则无此限制。</p><p>9，结构的实例（Instance）声明，不允许对包含的变量进行初始化设定，类则可以在声明类的实例时，同时进行变量初始化。</p><p>10，结构是隐式继承自ValueType类，而且不能继承任何其他类型，类则可以继续自ValueType以外的任何类。</p><p>11，结构是无法被继承的，类则可以。</p><p>12，结构永远不会终止，因此CLR不会在任何结构上调用Finalize方法。类则是由内存回收进程加以终止，当内存回收进程检测到没有任何作用的类时，它就会调用类的Finalize方法。</p><p>13，结构不需要构造函数，类则需要构造函数。</p><p>14，结构只能在一种情况下使用非共享构造函数，那就是非共享构造函数会接受参数。但是类则无此限制，它可以使用带参数或不带参数的非共享构造函数。</p><p>14，每一个结构都具有无参数的隐含公共构造函数，此构造函数会将结构的所有成员初始化为其默认值。不需要重新定义这个行为。</p><p>在“实例和变量”层面上，由于结构是数值类型的，因此每一个结构变量会永远的绑定到结构实例上。然而类是引用类型的，而且对象变量可引用不同的类实例，在此方面的区别，会对使用将结构和类造成如下的影响：</p><p>15，结构变量会隐式的使用结构的无参数构造函数来初始化成员，这就意味语句 Struct S = new Struct（）。</p><p>16，当您将一个结构变量赋值给另一个，或者将结构实例传递到程序变量时，所有变量成员的值会复制到新的结构中。当您将一个对象变量赋值给另一个，或者将对象变量传递给程序时，则只是复制指针。</p><p>17，您可以将Null值赋值给结构变量，但是该实例会一直与该变量保持关联。虽然变量成员会因此赋值而重新初始化，但是您还是可以调用变量的方法并访问其数据成员。相反的，如果您将对象变量设定为Null，您就会中断它与任何类型实例的关联，而且除非您再将另一个实例赋值给它，否则无法通过变量访问任何成员。</p><p>18，您可以在不同时间将不同的类的实例赋值给同一个对象变量，而且在同一时间可有好几个对象变量引用相同的类实例，如果您对类成员值做了改变，则其他指向相同实例的对象变量也会发生改变。然而，结构成员则会封装在他们自己的实例中，变更结构成员值并不会对其他任何结构变量的成员造成影响，甚至也不会影响相同结构声明的其他实例。</p><p>19，两个结构必须以成员对成员的比较方式来执行相等比较。两个对象变量可以使用Equals方法来加以比较。Equals会判断两个变量是否指向相同的实例。</p><h2 id="（7）-define-和const的区别（编译阶段、安全性、内存占用等）"><a href="#（7）-define-和const的区别（编译阶段、安全性、内存占用等）" class="headerlink" title="（7） define 和const的区别（编译阶段、安全性、内存占用等）"></a>（7） define 和const的区别（编译阶段、安全性、内存占用等）</h2><h3 id="1-编译器处理方式不同。"><a href="#1-编译器处理方式不同。" class="headerlink" title="(1) 编译器处理方式不同。"></a>(1) 编译器处理方式不同。</h3><p>define宏是在预处理阶段展开，生命周期止于编译期。只是一个常数、一个命令中的参数，没有实际的存在。#define常量存在于程序的代码段。const常量是编译运行阶段使用，const常量存在于程序的数据段.</p><h3 id="2-类型和安全检查不同。"><a href="#2-类型和安全检查不同。" class="headerlink" title="(2)类型和安全检查不同。"></a>(2)类型和安全检查不同。</h3><p>define宏没有类型，不做任何类型检查，仅仅是展开。const常量有具体的类型，在编译阶段会执行类型检查。</p><h3 id="3-存储方式不同。"><a href="#3-存储方式不同。" class="headerlink" title="(3)存储方式不同。"></a>(3)存储方式不同。</h3><p>define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。const常量会在内存中分配(可以是堆中也可以是栈中)</p><h2 id="（8）-在C-中const和static的用法（定义，用途）"><a href="#（8）-在C-中const和static的用法（定义，用途）" class="headerlink" title="（8） 在C++中const和static的用法（定义，用途）"></a>（8） 在C++中const和static的用法（定义，用途）</h2><h3 id="static关键字至少有下列n个作用："><a href="#static关键字至少有下列n个作用：" class="headerlink" title="static关键字至少有下列n个作用："></a>static关键字至少有下列n个作用：</h3><h4 id="（1）"><a href="#（1）" class="headerlink" title="（1）"></a>（1）</h4><p>函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；</p><h4 id="（2）"><a href="#（2）" class="headerlink" title="（2）"></a>（2）</h4><p>在模块内的static全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；</p><h4 id="（3）"><a href="#（3）" class="headerlink" title="（3）"></a>（3）</h4><p>在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；</p><h4 id="（4）"><a href="#（4）" class="headerlink" title="（4）"></a>（4）</h4><p>在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；</p><h4 id="（5）"><a href="#（5）" class="headerlink" title="（5）"></a>（5）</h4><p>在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。</p><h3 id="const关键字至少有下列n个作用："><a href="#const关键字至少有下列n个作用：" class="headerlink" title="const关键字至少有下列n个作用："></a>const关键字至少有下列n个作用：</h3><h4 id="（1）-1"><a href="#（1）-1" class="headerlink" title="（1）"></a>（1）</h4><p>欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；</p><h4 id="（2）-1"><a href="#（2）-1" class="headerlink" title="（2）"></a>（2）</h4><p>对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；</p><h4 id="（3）-1"><a href="#（3）-1" class="headerlink" title="（3）"></a>（3）</h4><p>在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；</p><h4 id="（4）-1"><a href="#（4）-1" class="headerlink" title="（4）"></a>（4）</h4><p>对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量；</p><h4 id="（5）-1"><a href="#（5）-1" class="headerlink" title="（5）"></a>（5）</h4><p>对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。例如：<br>const classA operator<em>(const classA&amp; a1,const classA&amp; a2);<br>　　operator</em>的返回结果必须是一个const对象。如果不是，这样的变态代码也不会编译出错：</p><p>classA a, b, c;<br>(a <em> b) = c; // 对a</em>b的结果赋值<br>　　操作(a * b) = c显然不符合编程者的初衷，也没有任何意义。</p><h2 id="（9）-const和static在类中使用的注意事项（定义、初始化和使用）"><a href="#（9）-const和static在类中使用的注意事项（定义、初始化和使用）" class="headerlink" title="（9） const和static在类中使用的注意事项（定义、初始化和使用）"></a>（9） const和static在类中使用的注意事项（定义、初始化和使用）</h2><h2 id="（10）-C-中的const类成员函数（用法和意义）"><a href="#（10）-C-中的const类成员函数（用法和意义）" class="headerlink" title="（10） C++中的const类成员函数（用法和意义）"></a>（10） C++中的const类成员函数（用法和意义）</h2><p>常量成员函数声明：如：int get() const;</p><h3 id="规则："><a href="#规则：" class="headerlink" title="规则："></a>规则：</h3><p>1.常量成员函数不修改对象。<br>2.常量成员函数在定义和声明中都应加const限定<br>3.非常量成员函数不能被常量成员函数调用，但构造函数和析构函数除外。<br>4.常量（const对象）对象只能调用常量成员函数。（const对象的数据成员在对象寿命周期内不能改变，因此其只能调用常量成员函数）。</p><h3 id="意义："><a href="#意义：" class="headerlink" title="意义："></a>意义：</h3><p>1.使成员函数的意义更加清楚，将成员函数分修改对象和不修改对象两类。<br>2.增加程序的健壮性，常量成员函数企图修改数据成员或调用非常量成员函数，编译器会指出错误。</p><h3 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h3><p>对于X类型的非常量成员函数而言，其this指针的类型是 X <em> const，该指针自身是常量；但是对于X类型的常量成员函数而言，其this指针的类型是const X </em> const，是一个常量指针。</p><h2 id="（11）-计算下面几个类的大小："><a href="#（11）-计算下面几个类的大小：" class="headerlink" title="（11） 计算下面几个类的大小："></a>（11） 计算下面几个类的大小：</h2><pre><code>class A {};: sizeof(A) = 1;class A { virtual Fun(){} };: sizeof(A) = 4(32位机器)/8(64位机器);class A { static int a; };: sizeof(A) = 1;class A { int a; };: sizeof(A) = 4;class A { static int a; int b; };: sizeof(A) = 4;</code></pre><p>（12） 给一个代码，求输出结果</p><pre><code>class A{public:A(int x){}}</code></pre><p>问：A a = 1;是否正确, 如果正确, 那么它调用了哪些函数？<br>这类题目更常见的是在基类和子类有不同实现方法。（虚函数相关，栗子很多，不多说了）</p><h2 id="（13）-C-的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等"><a href="#（13）-C-的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等" class="headerlink" title="（13） C++的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等"></a>（13） C++的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等</h2><h2 id="（14）-STL源码中的hash表的实现"><a href="#（14）-STL源码中的hash表的实现" class="headerlink" title="（14） STL源码中的hash表的实现"></a>（14） STL源码中的hash表的实现</h2><p><a href="https://blog.csdn.net/c602273091/article/details/54798805" target="_blank" rel="noopener">https://blog.csdn.net/c602273091/article/details/54798805</a><br>哈希表（Hash table，也叫散列表）， 是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p><p>哈希表hash table(key，value) 的做法其实很简单，就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。</p><p>而当使用哈希表进行查询的时候，就是再次使用哈希函数将key转换为对应的数组下标，并定位到该空间获取value，如此一来，就可以充分利用到数组的定位性能进行数据定位。</p><p>哈希表最大的优点，就是把数据的存储和查找消耗的时间大大降低，几乎可以看成是常数时间；而代价仅仅是消耗比较多的内存。然而在当前可利用内存越来越多的情况下，用空间换时间的做法是值得的。另外，编码比较容易也是它的特点之一。 哈希表又叫做散列表，分为“开散列” 和“闭散列”。</p><p>我们使用一个下标范围比较大的数组来存储元素。可以设计一个函数（哈希函数， 也叫做散列函数），使得每个元素的关键字都与一个函数值（即数组下标）相对应，于是用这个数组单元来存储这个元素；也可以简单的理解为，按照关键字为每一 个元素“分类”，然后将这个元素存储在相应“类”所对应的地方。</p><p>但是，不能够保证每个元素的关键字与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了“冲突”，换句话说，就是把不同的元素分在了相同的“类”之中。后面我们将看到一种解决“冲突”的简便做法。 总的来说，“直接定址”与“解决冲突”是哈希表的两大特点。</p><p>哈希函数构造<br>就是映射函数构造，看某个元素具体属于哪一个类别。<br>除余法： 选择一个适当的正整数 p ，令 h(k ) = k mod p ，这里， p 如果选取的是比较大的素数，效果比较好。而且此法非常容易实现，因此是最常用的方法。最直观的一种，上图使用的就是这种散列法，公式：<br>index = value % 16<br>学过汇编的都知道，求模数其实是通过一个除法运算得到的，所以叫“除法散列法”。</p><p>平方散列法<br>求index是非常频繁的操作，而乘法的运算要比除法来得省时（对现在的CPU来说，估计我们感觉不出来），所以我们考虑把除法换成乘法和一个位移操作。公式：<br>index = (value * value) &gt;&gt; 28 （ 右移，除以2^28。记法：左移变大，是乘。右移变小，是除）</p><p>数字选择法： 如果关键字的位数比较多，超过长整型范围而无法直接运算，可以选择其中数字分布比较均匀的若干位，所组成的新的值作为关键字或者直接作为函数值。</p><p>斐波那契（Fibonacci）散列法：平方散列法的缺点是显而易见的，所以我们能不能找出一个理想的乘数，而不是拿value本身当作乘数呢？答案是肯定的。<br>1，对于16位整数而言，这个乘数是40503<br>2，对于32位整数而言，这个乘数是2654435769<br>3，对于64位整数而言，这个乘数是11400714819323198485<br>这几个“理想乘数”是如何得出来的呢？这跟一个法则有关，叫黄金分割法则，而描述黄金分割法则的最经典表达式无疑就是著名的斐波那契数列，即如此形式的序列：0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233,377, 610， 987, 1597, 2584, 4181, 6765, 10946，…。另外，斐波那契数列的值和太阳系八大行星的轨道半径的比例出奇吻合。<br>对我们常见的32位整数而言，公式：<br>index = (value * 2654435769) &gt;&gt; 28</p><p>冲突处理<br>线性重新散列技术易于实现且可以较好的达到目的。令数组元素个数为 S ，则当 h(k) 已经存储了元素的时候，依次探查 (h(k)+i) mod S , i=1,2,3…… ，直到找到空的存储单元为止（或者从头到尾扫描一圈仍未发现空单元，这就是哈希表已经满了，发生了错误。当然这是可以通过扩大数组范围避免的）。</p><h2 id="（15）-STL中unordered-map和map的区别"><a href="#（15）-STL中unordered-map和map的区别" class="headerlink" title="（15） STL中unordered_map和map的区别"></a>（15） STL中unordered_map和map的区别</h2><h3 id="内部实现机理"><a href="#内部实现机理" class="headerlink" title="内部实现机理"></a>内部实现机理</h3><h4 id="map："><a href="#map：" class="headerlink" title="map："></a>map：</h4><p>map内部实现了一个红黑树，该结构具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素，因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行这样的操作，故红黑树的效率决定了map的效率。</p><h4 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map:"></a>unordered_map:</h4><p>unordered_map内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的</p><h3 id="优缺点以及适用处"><a href="#优缺点以及适用处" class="headerlink" title="优缺点以及适用处"></a>优缺点以及适用处</h3><h4 id="map-优点："><a href="#map-优点：" class="headerlink" title="map 优点："></a>map 优点：</h4><p>有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作<br>红黑树，内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高</p><h4 id="map-缺点："><a href="#map-缺点：" class="headerlink" title="map 缺点："></a>map 缺点：</h4><p>空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点，孩子节点以及红/黑性质，使得每一个节点都占用大量的空间<br>适用处，对于那些有顺序要求的问题，用map会更高效一些</p><h4 id="unordered-map-优点："><a href="#unordered-map-优点：" class="headerlink" title="unordered_map 优点："></a>unordered_map 优点：</h4><p>因为内部实现了哈希表，因此其查找速度非常的快</p><h4 id="unordered-map-缺点："><a href="#unordered-map-缺点：" class="headerlink" title="unordered_map 缺点："></a>unordered_map 缺点：</h4><p>哈希表的建立比较耗费时间<br>适用处，对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map</p><h2 id="（16）-STL中vector的实现"><a href="#（16）-STL中vector的实现" class="headerlink" title="（16） STL中vector的实现"></a>（16） STL中vector的实现</h2><h3 id="一、vector的定义"><a href="#一、vector的定义" class="headerlink" title="一、vector的定义"></a>一、vector的定义</h3><pre><code>template&lt;class _Ty,class _Ax&gt;class vector:public _Vector_val&lt;_Ty,_Ax&gt;{public:    /******/protected:    pointer _Myfirst;//pointer to beginning of array    pointer _Mylast;//pointer to current end of sequence    pointer _Myend;//pointer to end of array};</code></pre><p>示意图如下：<br><img src="http://ww1.sinaimg.cn/large/0071ouepgy1fv5pefakcgj30as088my3.jpg" alt="image"></p><p>两个关键大小：<br>大小：size=_Mylast - _Myfirst；<br>容量：capacity=_Myend - _Myfirst；<br>分别对应于resize()、reserve()两个函数。<br>size表示vector中已有元素的个数，容量表示vector最多可存储的元素的个数；为了降低二次分配时的成本，vector实际配置的大小可能比客户需求的更大一些，以备将来扩充，这就是容量的概念。即capacity&gt;=size，当等于时，容器此时已满，若再要加入新的元素时，就要重新进行内存分配，整个vector的数据都要移动到新内存。二次分配成本较高，在实际操作时，应尽量预留一定空间，避免二次分配。</p><h3 id="二、构造与析构"><a href="#二、构造与析构" class="headerlink" title="二、构造与析构"></a>二、构造与析构</h3><h3 id="1、构造"><a href="#1、构造" class="headerlink" title="1、构造"></a>1、构造</h3><p>vector的构造函数主要有以下几种：</p><pre><code>vector(): _Mybase(){    //construct empty vector    _Buy(0);}explicit vector(size_type _Count): _Mybase(){    //construct from _Count * _Ty()    _Construct_n(_Count, _Ty());}vector(size_type _Count,const _Ty&amp; _Val): _Mybase(){    //construct from _Count * _Val    _Construct_n(_Count,_Val);}vector(const _Myt&amp; _Right) : _Mybase(_Right._Alval){    //construct by copying _Right    if(_Buy(_Right.size()))        _Mylast=_Ucopy(_Right.begin(),_Right.end(),_Myfirst);}</code></pre><p>vector优异性能的秘诀之一，就是配置比其所容纳的元素所需更多的内存，一般在使用vector之前，就先预留足够空间，以避免二次分配，这样可以使vector的性能达到最佳。因此元素个数_Count是个远比元素值 _Val重要的参数，因此当构造一个vector时，首要参数一定是元素个数。<br>由上各构造函数可知，基本上所有构造函数都是基于_Construct _n() 的</p><pre><code>bool _Buy(size_type _Capacity){    //allocate array with _Capacity elements    _Myfirst=0,_Mylast=0,_Myend=0;    if(_Capacity==0)// _Count为0时直接返回        return (false);    else{        //nonempty array,allocate storage        _Myfirst=this-&gt;_Alval.allocate(_Capacity);//分配内存，并更新成员变量        _Mylast=_Myfirst;        _Myend=_Myfirst+_Capacity;    }    return (true);}void _Construct_n(size_type _Count,const _Ty&amp; _Val){    //构造含有_Count个值为_Val的元素的容器    if(_Buy(_Count))        _Mylast= _Ufill(_Myfirst,_Count,_Val);}</code></pre><h3 id="2、析构"><a href="#2、析构" class="headerlink" title="2、析构"></a>2、析构</h3><p>vector的析构函数很简单，就是先销毁所有已存在的元素，然后释放所有内存</p><pre><code>void _Tidy()    {   // free all storage    if (_Myfirst != 0)        {   // something to free, destroy and deallocate it        _Destroy(_Myfirst, _Mylast);        this-&gt;_Alval.deallocate(_Myfirst, _Myend - _Myfirst);        }    _Myfirst = 0, _Mylast = 0, _Myend = 0;    }</code></pre><h3 id="三、插入和删除元素"><a href="#三、插入和删除元素" class="headerlink" title="三、插入和删除元素"></a>三、插入和删除元素</h3><p>vector的插入和删除元素是通过push_ back () 、 pop_back()两个接口来实现的，他们的内部实现也非常简单</p><pre><code>void push_back(const _Ty&amp; _Val)    {   // insert element at end    if (size() &lt; capacity())        _Mylast = _Ufill(_Mylast, 1, _Val);    else        insert(end(), _Val);    //空间不足时，就会触发内存的二次分配    }void pop_back()    {   // erase element at end    if (!empty())        {   // erase last element        _Destroy(_Mylast - 1, _Mylast);        --_Mylast;        }    }</code></pre><p>当没有备用空间时候，push_back将调用insert进行扩容。将内存扩充原来2倍，然后将原数据复制过来，然后释放掉原数据，最后调整三个迭代器的数值_Myfirst,_Mylast,_Myend。所以扩容之后，指向原vector的迭代器会失效，必须重新调用成员函数获取才可以，所以使用迭代器最好时时刻刻重新获取，否则可能引发错误。</p><pre><code>template &lt;class T, class Alloc&gt;void vector&lt;T, Alloc&gt;::insert(iterator position, const T&amp; x) {  if (_Mylast != _Myend) {//还有备用空间    construct(_Mylast, *(_Mylast - 1));//    ++_Mylast;    T x_copy = x;    copy_backward(position, _Mylast - 2, _Mylast - 1);    *position = x_copy;//调整迭代器指向  }  else {//没有备用空间    const size_type old_size = size();    const size_type len = old_size != 0 ? 2 * old_size : 1;    /*        如果原大小为0，则为1，否则扩大为2倍。        */    iterator new_start = data_allocator::allocate(len);//分配,并返回首部迭代器    iterator new_finish = new_start;    __STL_TRY {      new_finish = uninitialized_copy(_Myfirst, position, new_start);//将原来数据拷贝到new_start，并返回尾部迭代器      construct(new_finish, x);//在尾部构造新元素      ++new_finish;//新的尾部加1      new_finish = uninitialized_copy(position, _Mylast, new_finish);//这句话没有任何用。    }    destroy(begin(), end());//析构    deallocate();//释放原来vector内存空间    //迭代器调整    _Myfirst = new_start;    _Mylast = new_finish;    _Myend = new_start + len;  }}</code></pre><h3 id="四、其他接口"><a href="#四、其他接口" class="headerlink" title="四、其他接口"></a>四、其他接口</h3><h3 id="1、reserve-操作"><a href="#1、reserve-操作" class="headerlink" title="1、reserve()操作"></a>1、reserve()操作</h3><p>之前提到过reserve（Count） 函数主要是预留Count大小的空间，对应的是容器的容量，目的是保证（_Myend - _Myfirst）&gt;=Count。只有当空间不足时，才会操作，即重新分配一块内存，将原有元素拷贝到新内存，并销毁原有内存</p><pre><code>void reserve(size_type _Count)    {   // determine new minimum length of allocated storage    if (capacity() &lt; _Count)        {   // not enough room, reallocate        pointer _Ptr = this-&gt;_Alval.allocate(_Count);        _Umove(begin(), end(), _Ptr);        size_type _Size = size();        if (_Myfirst != 0)            {   // destroy and deallocate old array            _Destroy(_Myfirst, _Mylast);            this-&gt;_Alval.deallocate(_Myfirst, _Myend - _Myfirst);            }        _Myend = _Ptr + _Count;        _Mylast = _Ptr + _Size;        _Myfirst = _Ptr;        }    }</code></pre><h3 id="2、resize-操作"><a href="#2、resize-操作" class="headerlink" title="2、resize()操作"></a>2、resize()操作</h3><p>resize（Count） 函数主要是用于改变size的，也就是改变vector的大小，最终改变的是（_Mylast - _Myfirst）的值，当size &lt; Count时,就插入元素，当size &gt;Count时，就擦除元素。</p><pre><code>void resize(size_type _Newsize, _Ty _Val)    {   // determine new length, padding with _Val elements as needed    if (size() &lt; _Newsize)        _Insert_n(end(), _Newsize - size(), _Val);    else if (_Newsize &lt; size())        erase(begin() + _Newsize, end());    }</code></pre><h3 id="3、-Insert-n-操作"><a href="#3、-Insert-n-操作" class="headerlink" title="3、_Insert_n()操作"></a>3、_Insert_n()操作</h3><p>resize()操作和insert()操作都会利用到_Insert_n()这个函数，这个函数非常重要，也比其他函数稍微复杂一点<br>虽然_Insert_n(_where, _Count, _Val ) 函数比较长，但是操作都非常简单，主要可以分为以下几种情况：</p><p>1、_Count == 0，不需要插入，直接返回</p><p>2、max_size() - size() &lt; _Count，超过系统设置的最大容量，会溢出，造成Xlen（）异常</p><p>3、_Capacity &lt; size() + _Count，vector的容量不足以插入Count个元素，需要进行二次分配，扩大vector的容量。 在VS下，vector容量会扩大50%，即 _Capacity = _Capacity + _Capacity / 2;<br>若仍不足，则 _Capacity = size() + _Count;</p><pre><code>else if (_Capacity &lt; size() + _Count)       {   // not enough room, reallocate       _Capacity = max_size() - _Capacity / 2 &lt; _Capacity           ? 0 : _Capacity + _Capacity / 2;    // try to grow by 50%       if (_Capacity &lt; size() + _Count)           _Capacity = size() + _Count;       pointer _Newvec = this-&gt;_Alval.allocate(_Capacity);       pointer _Ptr = _Newvec;       _Ptr = _Umove(_Myfirst, _VEC_ITER_BASE(_Where),_Newvec);    // copy prefix       _Ptr = _Ufill(_Ptr, _Count, _Val);  // add new stuff       _Umove(_VEC_ITER_BASE(_Where), _Mylast, _Ptr);  // copy suffix       //内存释放与变量更新       }</code></pre><p>这种情况下，数据从原始容器移动到新分配内存时是从前到后移动的<br>这里写图片描述<br><img src="http://ww1.sinaimg.cn/large/0071ouepgy1fv5tyr1p07j30h20by41b.jpg" alt="image"><br>4、空间足够，且被插入元素的位置比较靠近_Mylast,即已有元素的尾部</p><p>这种情况下不需要再次进行内存分配，且数据是从后往前操作的。首先是将where~last向后移动，为待插入数据预留Count大小的空间，然后从_Mylast处开始填充，然后将从where处开始填充剩余元素</p><pre><code>else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) &lt; _Count)        {   // new stuff spills off end        _Umove(_VEC_ITER_BASE(_Where), _Mylast,            _VEC_ITER_BASE(_Where) + _Count);   // copy suffix        _Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),            _Val);  // insert new stuff off end        _Mylast += _Count;        std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,            _Val);  // insert up to old end        }</code></pre><p>5、空间足够，但插入的位置比较靠前<br>            {   // new stuff can all be assigned<br>            _Ty _Tmp = _Val;    // in case _Val is in sequence</p><pre><code>pointer _Oldend = _Mylast;_Mylast = _Umove(_Oldend - _Count, _Oldend,    _Mylast);   // copy suffix_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,    _Oldend);   // copy holestd::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,    _Tmp);  // insert into hole}</code></pre><h3 id="4、erase-操作"><a href="#4、erase-操作" class="headerlink" title="4、erase()操作"></a>4、erase()操作</h3><pre><code>iterator erase(const_iterator _First_arg,    const_iterator _Last_arg)    {   // erase [_First, _Last)    iterator _First = _Make_iter(_First_arg);    iterator _Last = _Make_iter(_Last_arg);    if (_First != _Last)        {   // worth doing, copy down over hole        pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,            _VEC_ITER_BASE(_First));        _Destroy(_Ptr, _Mylast);        _Mylast = _Ptr;        }    return (_First);    }</code></pre><p>主要操作就是将后半部分的有效元素向前拷贝，并将后面空间的无效元素析构，并更新_Mylast变量<br>这里写图片描述<br><img src="http://ww1.sinaimg.cn/large/0071ouepgy1fv5ua8ciphj30i90ahgns.jpg" alt="image"></p><h3 id="5、assign-操作"><a href="#5、assign-操作" class="headerlink" title="5、assign()操作"></a>5、assign()操作</h3><p>assign()操作最终都会调用到下面的函数，主要操作是首先擦除容器中已有的全部元素，在从头开始插入Count个Val元素</p><pre><code>void _Assign_n(size_type _Count, const _Ty&amp; _Val)    {   // assign _Count * _Val    _Ty _Tmp = _Val;    // in case _Val is in sequence    erase(begin(), end());    insert(begin(), _Count, _Tmp);    }</code></pre><h2 id="（17）-vector使用的注意点及其原因，频繁对vector调用push-back-对性能的影响和原因。"><a href="#（17）-vector使用的注意点及其原因，频繁对vector调用push-back-对性能的影响和原因。" class="headerlink" title="（17） vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。"></a>（17） vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。</h2><p>vector使用注意事项：</p><p>（1）max_size函数返回的是vector中的内存分配器allocator能够分配的最大内存空间，即vector所能管控的最大序列长度，注意和capacity的区别。</p><p>（2）resize重新调整大小，既可以减小也可以增加size（数组的有效长度），但是内存并不一定减小。</p><p>（3）insert是在所指的元素之前进行插入，erase返回的迭代器指向被最后删除的元素的下一个元素。</p><p>（4）注意插入和删除元素后迭代器失效的问题。</p><p>（5）当预先知道所需的存储空间时，可以使用reserve预先分配内存。</p><p>（6）vector对象作为一个高效的栈使用时，应该让容器保持一定的预留存储空间，频繁的重新分配内存会影响栈的性能，可以使用reserve预分配内存，使用push_back、pop_back和back插入、删除和读取最后一个元素。</p><p>（7）clear只是保证了析构所有的元素，即size()=0，但并不保证释放所有的存储空间，即capacity不一定等于0，可以使用如下方式释放所有内存：</p><pre><code>vec.swap(vector&lt;T&gt;());</code></pre><p>在原来空间不够存储新值时，每次调用push_back方法都会重新分配新的空间以满足新数据的添加操作。</p><p>如果在程序中频繁进行这种操作，还是比较消耗性能的。</p><h2 id="（18）-C-中的重载和重写的区别："><a href="#（18）-C-中的重载和重写的区别：" class="headerlink" title="（18） C++中的重载和重写的区别："></a>（18） C++中的重载和重写的区别：</h2><p><a href="https://blog.csdn.net/zx3517288/article/details/48976097" target="_blank" rel="noopener">https://blog.csdn.net/zx3517288/article/details/48976097</a><br>重载：是指同一可访问区内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。</p><p>示例：</p><pre><code>class A{public:  void test(int i);  void test(double i);//overload  void test(int i, double j);//overload  void test(double i, int j);//overload  int test(int i);         //错误，非重载。注意重载不关心函数返回类型。};</code></pre><p>重写(覆盖)：是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。</p><p>示例：</p><pre><code>#include&lt;iostream&gt;using namespace std;class Base{public:    virtual void fun(int i){ cout &lt;&lt; &quot;Base::fun(int) : &quot; &lt;&lt; i &lt;&lt; endl;}};class Derived : public Base{public:    virtual void fun(int i){ cout &lt;&lt; &quot;Derived::fun(int) : &quot; &lt;&lt; i &lt;&lt; endl;}};int main(){    Base b;    Base * pb = new Derived();    pb-&gt;fun(3);//Derived::fun(int)    system(&quot;pause&quot;);    return 0;</code></pre><p>重载和重写的区别：</p><p>（1）范围区别：重写和被重写的函数在不同的类中，重载和被重载的函数在同一类中。</p><p>（2）参数区别：重写与被重写的函数参数列表一定相同，重载和被重载的函数参数列表一定不同。</p><p>（3）virtual的区别：重写的基类必须要有virtual修饰，重载函数和被重载函数可以被virtual修饰，也可以没有。</p><p>隐藏和重写，重载的区别：</p><p>（1）与重载范围不同：隐藏函数和被隐藏函数在不同类中。</p><p>（2）参数的区别：隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定同；当参数不同时，无论基类中的函数是否被virtual修饰，基类函数都是被隐藏，而不是被重写。<br>示例</p><h2 id="（19）-C-内存管理（热门问题）"><a href="#（19）-C-内存管理（热门问题）" class="headerlink" title="（19） C ++内存管理（热门问题）"></a>（19） C ++内存管理（热门问题）</h2><p>内存分配方式<br>（1）从静态存储区域分配。内存在程序编译的时候就已经分配好了（已经编址）这些内存在程序的整个运行期间都存在，如全局变量，static变量<br>（2）在堆栈上分配。在函数执行期间，函数内局部变量（包括形参）的存储单元都创建在堆栈上，函数结束时这些存储单元都会自动释放（堆栈清退）。堆栈内存分配运算内置于处理器的指令集中，效率很高，并且一般不存在失败的危险，但是分配的内存容量有限，可能出现堆栈溢出。<br>（3）从堆或者自由存储空间上分配，亦称动态内存分配。程序在运行期间用malloc()或new申请任意数量的内存，程序猿自己掌握释放内存的恰当时机（使用free()或delete)动态内存的生存期由程序猿决定，使用非常灵活，但也最容易产生问题。<br>一般的原则是：如果使用堆栈存储和静态存储就能满足应用要求，就不要使用动态存储。因为在堆栈上动态分配内存需要很可观的额外开销：<br>应用程序将调用操作系统中内存管理模块的堆管理器，搜索其中是否有符合要求的连续字节内存块。特别是在经过多次动态分配后，对会出现大量的闲散内存碎片，此时需要首先将碎片合并，然后才能分配成功，在这种情况下动态分配需要很长时间<br>如果动态分配失败，需要检查返回值或者捕获异常，这也需要额外开销。<br>动态创建的对象可能被删除多次，甚至在删除后还会继续使用，或者根本就不会被删除，于是出现运行时错误或程序“吃”内存的对象<br>常见的内存错误及其对策<br>内存分配未成功，却使用了它<br>内存分配成功，但是尚未初始化就使用它<br>内存分配成功并且已经初始化，但操作越过了内存的边界<br>忘记了释放内存或者只释放了部分内存，因此造成内存泄漏。（含有这种错误的函数每调用一次就丢失一块内存）比如无意中修改了指向动态数组的指针，致使释放出错，或者使用了错误的动态数组释放语法。<br>（5）释放了内存却还在继续使用它。<br>程序中的对象调用关系过于复杂，实在难以搞清楚某个对象（重新设计数据结构，从根本上解决对象管理的混乱局面）<br>函数的return语句写错了，注意不要返回指向“栈内存”的指针或者引用，因为该内存在函数结束时被自动释放<br>使用free（）或delete释放了内存后，没有将指针设置为NULL，产生野指针<br>多次释放同一块内存<br>用malloc或new申请内存之后，应该立即检查指针值是否为NULL或者进行异常处理，以防止使用值为NULL的指针<br>不要忘记初始化指针，数组和动态内存，防止将未初始化的内存作为右值使用<br>避免数组或指针的下标越界，特别要当心的是++或者–操作<br>用free或者delete释放了内存之后，立即将指针设置为NULL，防止产生野指针</p><h3 id="1-一般一个c-c-程序编译的时候内存布局如下-地址从低到高的顺序"><a href="#1-一般一个c-c-程序编译的时候内存布局如下-地址从低到高的顺序" class="headerlink" title="(1)一般一个c/c++程序编译的时候内存布局如下(地址从低到高的顺序)"></a>(1)一般一个c/c++程序编译的时候内存布局如下(地址从低到高的顺序)</h3><h4 id="a-代码区"><a href="#a-代码区" class="headerlink" title="a.代码区:"></a>a.代码区:</h4><p>存放程序的二进制代码.</p><h4 id="b-常量区"><a href="#b-常量区" class="headerlink" title="b.常量区:"></a>b.常量区:</h4><p>这个区和代码区的距离很近,主要存放一些非局部常量值和字符串字面值,一般不允许修改,程序结束由系统释放;具有常属性并且初始化的全局和静态变量也放在这个区.</p><h4 id="c-数据区"><a href="#c-数据区" class="headerlink" title="c.数据区:"></a>c.数据区:</h4><p>赋过初值的且不具有常属性的静态和全局变量在数据区.它和BSS段统称为静态区;程序结束后由系统释放;</p><h4 id="d-BSS段"><a href="#d-BSS段" class="headerlink" title="d.BSS段:"></a>d.BSS段:</h4><p>没有初始化的静态和全局变量;进程一旦被加载这个区所有的数据都被清0;</p><h4 id="e-堆区"><a href="#e-堆区" class="headerlink" title="e.堆区:"></a>e.堆区:</h4><p>   动态分配的内存;由程序员分配和释放,程序结束的时候如果没有释放,则由OS回收;</p><h4 id="f-栈区"><a href="#f-栈区" class="headerlink" title="f.栈区:"></a>f.栈区:</h4><p>   由编译器自动分配和释放,不使用的时候会自动的释放.主要用来存放非静态的局部变量,函数的参数和返回值, 临时变量等.</p><h4 id="g-命令行参数和环境变量区"><a href="#g-命令行参数和环境变量区" class="headerlink" title="g.命令行参数和环境变量区;"></a>g.命令行参数和环境变量区;</h4><p>下面是对应一段经典的代码:</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;  //unix下的头文件const int const_global = 10; //常全局变量int init_global = 10;        //初始化的全局变量int uninit_global;           //未初始化的全局变量int main(int argc,char * argv[]){    const static int const_static = 10;//常属性的静态变量，不可以被赋值，初始化    static int init_static = 10;    //初始化静态变量    static int uninit_static;       //未初始化静态变量    const int const_local = 10;    // 常属性的局部变量    int  prev_local = 1;//前局部变量    int  next_local = 5;//后局部变量    int* prev_heap = malloc(sizeof(int));//前面分配的堆变量    int* next_heap = malloc(sizeof(int));//后面分配的堆变量    const char* literal = &quot;literal&quot;;      //字符串字面值，字面值常量    extern char** environ;               // 环境变量    printf(&quot;----地址最高断命令行参数和环境变量-------\n&quot;);    printf(&quot;        环境变量:%p\n&quot;,environ);    printf(&quot;      命令行参数:%p\n&quot;,argv);    printf(&quot;---------------栈区-----------------------\n&quot;);    printf(&quot;      常局部变量:%p\n&quot;,&amp;const_local);    printf(&quot;      前局部变量:%p\n&quot;,&amp;prev_local);    printf(&quot;      后局部变量:%p\n&quot;,&amp;next_local);    printf(&quot;--------------------堆--------------------\n&quot;);    printf(&quot;        前堆变量:%p\n&quot;,prev_heap);    printf(&quot;        后堆变量:%p\n&quot;,next_heap);    printf(&quot;--------------------BSS--------------------\n&quot;);    printf(&quot;未初始化全局变量:%p\n&quot;,&amp;uninit_global);    printf(&quot;未初始化静态变量:%p\n&quot;,&amp;uninit_static);    printf(&quot;----------------数据------------------------\n&quot;);    printf(&quot;  初始化全局变量:%p\n&quot;,&amp;init_static);    printf(&quot;  初始化全局变量:%p\n&quot;,&amp;init_global);    printf(&quot;----------------代码区----------------------\n&quot;);    printf(&quot;     常静态变量:%p\n&quot;,&amp;const_static);    printf(&quot;     字面值常量:%p\n&quot;,&amp;literal);    printf(&quot;     常全局变量:%p\n&quot;,&amp;const_global);    printf(&quot;           函数:%p\n&quot;,main);    return 0;}</code></pre><h3 id="2-从上面可以看出c-c-的内存分配方式主要有三种"><a href="#2-从上面可以看出c-c-的内存分配方式主要有三种" class="headerlink" title="(2)从上面可以看出c/c++的内存分配方式主要有三种"></a>(2)从上面可以看出c/c++的内存分配方式主要有三种</h3><h4 id="a-从静态存储区域分配"><a href="#a-从静态存储区域分配" class="headerlink" title="a.从静态存储区域分配:"></a>a.从静态存储区域分配:</h4><p>   内存在程序编译时已经分配好,这块内存在程序的整个运行期间都存在.速度快,不容易出错.因为由系统会善后.</p><h4 id="b-在栈上分配内存"><a href="#b-在栈上分配内存" class="headerlink" title="b.在栈上分配内存:"></a>b.在栈上分配内存:</h4><p>   在执行函数的时候,函数内非静态局部变量的存储单元都是在栈上创建,函数执行结束的时候这些存储单元自动被释放.栈内存分配内置于处理器的指令集中,效率很高但是分配的内容有限.</p><h4 id="c-从堆中分配内存"><a href="#c-从堆中分配内存" class="headerlink" title="c.从堆中分配内存:"></a>c.从堆中分配内存:</h4><p>即是动态分配内存.程序在运行的时候使用malloc/new申请任意大小的内存,程序员自己负责在何时用free/delete释放内存.动态内存的生存期由程序员决定,使用非常的灵活.如果在堆上分配了内存,就有责任去回收它,否则运行程序会出现内存泄漏,另外频繁的分配和释放不同大小的堆空间将会产生堆内碎片.不易管理;</p><h2 id="（20）-介绍面向对象的三大特性，并且举例说明每一个。"><a href="#（20）-介绍面向对象的三大特性，并且举例说明每一个。" class="headerlink" title="（20） 介绍面向对象的三大特性，并且举例说明每一个。"></a>（20） 介绍面向对象的三大特性，并且举例说明每一个。</h2><h3 id="1-封装"><a href="#1-封装" class="headerlink" title="(1)封装:"></a>(1)封装:</h3><p>将客观事物封装成抽象的类,并且设计者可以对类的成员进行访问控制权限控制. 这样一方面可以做到数据的隐藏,保护数据安全;另一方面,封装可以修改类的内部实现而不用修改调用了该类的用户的代码.同时封装还有利于代码的 方便复用；</p><h3 id="2-继承"><a href="#2-继承" class="headerlink" title="(2)继承:"></a>(2)继承:</h3><h4 id="a-2"><a href="#a-2" class="headerlink" title="a."></a>a.</h4><p>继承具有这样一种功能,它可以使用现有类的所有功能；并且可以在不重新编写原有类的情况下对类的功能进行扩展.继承的过程是一般到特殊的过程,即是它们是is-a的关系;基类或父类是一般,而子类或派生类是基类的特殊表现;要实现继承可以通过继承和组合来实现;</p><h4 id="b-3"><a href="#b-3" class="headerlink" title="b."></a>b.</h4><p>广义上的继承分成三大类:实现继承:使用基类的属性和方法而无需额外编码的能力;接口继承:接口继承是指仅使用基类的属性和方法的名称,而具体的实现子类必须自己完成的能力;可视继承:子窗体(类)使用父窗体(类)的外观和实现代码的能力;</p><h3 id="3-多态"><a href="#3-多态" class="headerlink" title="(3)多态:"></a>(3)多态:</h3><h4 id="a-3"><a href="#a-3" class="headerlink" title="a."></a>a.</h4><p>多态的实现分成两种,一种是编译时的多态,主要是通过函数重载和运算符重</p><p>另外一种是运行时多态,主要是通过函数覆盖来实现的,它需要满足3个条件:基类函数必须是虚函数,并且基类的指针或引用指向子类的时候,当子类中对原有的虚函数进行重新定义之后形成一个更加严格的重载版本的时候,就会形成多态;它是通过动态联编实现的;</p><h4 id="b-4"><a href="#b-4" class="headerlink" title="b."></a>b.</h4><p>运行时的多态可以让基类的指针或引用指向不同的对象的时候表现出来不同的特性;</p><h2 id="（21）-多态的实现（和下个问题一起回答）"><a href="#（21）-多态的实现（和下个问题一起回答）" class="headerlink" title="（21） 多态的实现（和下个问题一起回答）"></a>（21） 多态的实现（和下个问题一起回答）</h2><p> 首先，什么是多态，什么又是虚函数呢？先来看看维基百科对多态的解释：</p><p>“多态（英语：polymorphism），是指计算机程序运行时，相同的消息可能会送给多个不同的类别之对象，而系统可依据对象所属类别，引发对应类别的方法，而有不同的行为。简单来说，所谓多态意指相同的消息给予不同的对象会引发不同的动作称之。”其实更简单地来说，就是“在用父类指针调用函数时，实际调用的是指针指向的实际类型（子类）的成员函数”。多态性使得程序调用的函数是在运行时动态确定的，而不是在编译时静态确定的。而虚函数则是加了virtual修饰词的类的成员函数。</p><h3 id="c-的多态性就是通过晚绑定技术来实现的。"><a href="#c-的多态性就是通过晚绑定技术来实现的。" class="headerlink" title="c++的多态性就是通过晚绑定技术来实现的。"></a>c++的多态性就是通过晚绑定技术来实现的。</h3><p>　　c++的多态性用一句话概括就是:在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数，如果对象类型是派生类，就调用派生类的函数，如果对象类型是基类，就调用基类的函数。</p><h2 id="（22）-C-虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）"><a href="#（22）-C-虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）" class="headerlink" title="（22） C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）"></a>（22） C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）</h2><p>每一个拥有virtual function的类实例化对象时，都会额外申请一块内存存储虚函数表存储所有虚函数地址，并在对象某个位置存储一个vptr指针指向该表起始地址。这个指针具体放在什么位置，虚函数表怎么组织，怎么索引各个虚函数，这些都是编译器在编译期间决定的，在不同编译环境下不见得相同。</p><p>虚函数在c++中的实现机制就是用虚表和虚指针，但是具体是怎样的呢？从more effecive c++其中一篇文章里面可以知道：是每个类用了一个虚表，每个类的对象用了一个虚指针。</p><pre><code>class A{public:    virtual void f();    virtual void g();private:    int a};class B : public A{public:    void g();private:    int b;};//A，B的实现省略</code></pre><p>因为A有virtual void f（），和g（），所以编译器为A类准备了一个虚表vtableA，内容如下：</p><pre><code>A::f 的地址A::g 的地址</code></pre><p>B因为继承了A，所以编译器也为B准备了一个虚表vtableB，内容如下：</p><pre><code>A::f 的地址B::g 的地址</code></pre><p>注意：因为B::ｇ是重写了的，所以B的虚表的g放的是B::g的入口地址，但是f是从上面的A继承下来的，所以f的地址是A::f的入口地址。</p><p>然后某处有语句 B bB;的时候，编译器分配空间时，除了A的int a，B的成员int b；以外，还分配了一个虚指针vptr，指向B的虚表vtableB，bB的布局如下：</p><pre><code>vptr ： 指向B的虚表vtableBint a： 继承A的成员int b： B成员</code></pre><p>当如下语句的时候：</p><pre><code>A *pa = &amp;bB;</code></pre><p>pa的结构就是A的布局（就是说用pa只能访问的到bB对象的前两项，访问不到第三项int b）</p><p>那么pa-&gt;g()中，编译器知道的是，g是一个声明为virtual的成员函数，而且其入口地址放在表格（无论是vtalbeA表还是vtalbeB表）的第2项，那么编译器编译这条语句的时候就如是转换：</p><pre><code>call *(pa-&gt;vptr)[1]（C语言的数组索引从0开始）。</code></pre><p>这一项放的是B：：g()的入口地址，则就实现了多态。（注意bB的vptr指向的是B的虚表vtableB）</p><p>另外要注意的是，如上的实现并不是唯一的，C++标准只要求用这种机制实现多态，至于虚指针vptr到底放在一个对象布局的哪里，标准没有要求，每个编译器自己决定。以上的结果是根据g++ 4.3.4经过反汇编分析出来的。</p><h2 id="（23）-实现编译器处理虚函数表应该如何处理"><a href="#（23）-实现编译器处理虚函数表应该如何处理" class="headerlink" title="（23） 实现编译器处理虚函数表应该如何处理"></a>（23） 实现编译器处理虚函数表应该如何处理</h2><h2 id="（24）-析构函数一般写成虚函数的原因"><a href="#（24）-析构函数一般写成虚函数的原因" class="headerlink" title="（24） 析构函数一般写成虚函数的原因"></a>（24） 析构函数一般写成虚函数的原因</h2><p><strong>构造函数不能是虚函数，析构函数可以是虚函数且推荐最好设置为虚函数。</strong>下面我们来看看为什么。</p><p>那么为什么析构函数推荐最好设置为虚函数呢？当我们delete(a)的时候，如果析构函数不是虚函数，那么调用的将会是基类base的析构函数。而当继承的时候，通常派生类会在基类的基础上定义自己的成员，此时我们当时是希望可以调用派生类的析构函数对新定义的成员也进行析构啦。</p><p>所以，析构函数推荐最好设置为虚函数是为了当用一个基类的指针删除一个派生类的对象时，派生类的析构函数会被调用。<br>当然，并不是要把所有类的析构函数都写成虚函数。因为当类里面有虚函数的时候，编译器会给类添加一个虚函数表，里面来存放虚函数指针，这样就会增加类的存储空间。所以，只有当一个类被用来作为基类的时候，才把析构函数写成虚函数。</p><h2 id="（25）-构造函数为什么一般不定义为虚函数"><a href="#（25）-构造函数为什么一般不定义为虚函数" class="headerlink" title="（25） 构造函数为什么一般不定义为虚函数"></a>（25） 构造函数为什么一般不定义为虚函数</h2><p>首先，我们已经知道虚函数的实现则是通过对象内存中的虚函数表指针vptr来实现的。而构造函数是用来实例化一个对象的，通俗来讲就是为对象内存中的值做初始化操作。那么在构造函数完成之前，vptr是没有值的，也就无法通过vptr找到作为虚函数的构造函数所在的代码区，所以构造函数只能作为普通函数存放在类所指定的代码区中。</p><p>子类构造时各个初始化步骤的调用顺序<br>构造顺序：</p><pre><code>1．构造子类构造函数的参数2．子类调用基类构造函数3．基类设置vptr4．基类初始化列表内容进行构造5.基类函数体调用6.子类设置vptr7.子类初始化列表内容进行构造8.子类构造函数体调用（注意一点，初始化列表内的数据不按书写顺序，而是按类内部的定义顺序）析构的顺序恰好相反，所以也不要在析构函数中调用虚函数，那样也是没有意义的。</code></pre><h2 id="（26）-构造函数或者析构函数中调用虚函数会怎样"><a href="#（26）-构造函数或者析构函数中调用虚函数会怎样" class="headerlink" title="（26） 构造函数或者析构函数中调用虚函数会怎样"></a>（26） 构造函数或者析构函数中调用虚函数会怎样</h2><p>对于构造函数和析构函数与虚函数的关系我们也可以从另一方面来理解。通常是如例子中base *a=new(A)这样创建一个对象时调用构造函数，此时我们是在new函数中直接指定类名字的，当然会直接调用对应类的构造函数，不会出现基类类型实际指向子类的情况出现。而调用析构函数通常是针对对象的操作，如delete(a)，此时我们当然希望可以调用到a实际指向的类型（类A）的析构函数，故需要设置为虚函数。</p><pre><code>class ClxBase{public:    ClxBase() {};    virtual ~ClxBase() {};    virtual void DoSomething() { cout &lt;&lt; &quot;Do something in class ClxBase!&quot; &lt;&lt; endl; };};class ClxDerived : public ClxBase{public:    ClxDerived() {};    ~ClxDerived() { cout &lt;&lt; &quot;Output from the destructor of class ClxDerived!&quot; &lt;&lt; endl; };     void DoSomething() { cout &lt;&lt; &quot;Do something in class ClxDerived!&quot; &lt;&lt; endl; };};ClxBase *pTest = new ClxDerived;pTest-&gt;DoSomething();delete pTest;</code></pre><p> 输出结果是：</p><pre><code>Do something in class ClxDerived!Output from the destructor of class ClxDerived!</code></pre><p>而如果去掉基类中析构函数的virtual关键字输出则变成</p><pre><code>Do something in class ClxDerived!Output from the destructor of class ClxDerived!</code></pre><p>也就是说，类ClxDerived的析构函数根本没有被调用！一般情况下类的析构函数里面都是释放内存资源，而析构函数不被调用的话就会造成内存泄漏。我想所有的C++程序员都知道这样的危险性。当然，如果在析构函数中做了其他工作的话，那你的所有努力也都是白费力气。</p><h2 id="（27）-纯虚函数"><a href="#（27）-纯虚函数" class="headerlink" title="（27） 纯虚函数"></a>（27） 纯虚函数</h2><p><strong>C++纯虚函数</strong></p><h3 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h3><p>　纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”</p><pre><code>　virtual void funtion1()=0</code></pre><h3 id="二、引入原因"><a href="#二、引入原因" class="headerlink" title="二、引入原因"></a>二、引入原因</h3><p>1、为了方便使用多态特性<br>我们常常需要在基类中定义虚拟函数。</p><p>2、在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。</p><p>为了解决上述问题，引入了纯虚函数的概念，<strong>将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;）</strong>，则编译器要求在派生类中必须予以重写以实现多态性。<strong>同时含有纯虚拟函数的类称为抽象类，它不能生成对象。</strong>这样就很好地解决了上述两个问题。<br>声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。<br>纯虚函数最显著的特征是：它们必须在继承类中重新声明函数（不要后面的＝0，否则该派生类也不能实例化），而且它们在抽象类中往往没有定义。<br>定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。</p><p>纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。</p><h3 id="抽象类的介绍"><a href="#抽象类的介绍" class="headerlink" title="抽象类的介绍"></a>抽象类的介绍</h3><p>抽象类是一种特殊的类，它是为了抽象和设计的目的为建立的，它处于继承层次结构的较上层。<br>（1）抽象类的定义：  称带有纯虚函数的类为抽象类。</p><p>（2）抽象类的作用：<br>抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。所以派生类实际上刻画了一组子类的操作接口的通用语义，这些语义也传给子类，子类可以具体实现这些语义，也可以再将这些语义传给自己的子类。</p><p>（3）使用抽象类时注意：<br>•   抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。<br>•   抽象类是不能定义对象的。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>1、<strong>纯虚函数声明如下： virtual void funtion1()=0;</strong> 纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。</p><p>2、虚函数声明如下：virtual ReturnType FunctionName(Parameter)；虚函数必须实现，如果不实现，编译器将报错，错误提示为：<br>error LNK<em>**</em>: unresolved external symbol “public: virtual void __thiscall ClassName::virtualFunctionName(void)”</p><p>3、对于虚函数来说，父类和子类都有各自的版本。由多态方式调用的时候动态绑定。</p><p>4、实现了纯虚函数的子类，该纯虚函数在子类中就编程了虚函数，子类的子类即孙子类可以覆盖该虚函数，由多态方式调用的时候动态绑定。</p><p>5、虚函数是C++中用于实现多态(polymorphism)的机制。核心理念就是通过基类访问派生类定义的函数。</p><p>6、在有动态分配堆上内存的时候，析构函数必须是虚函数，但没有必要是纯虚的。</p><p>7、友元不是成员函数，只有成员函数才可以是虚拟的，因此友元不能是虚拟函数。但可以通过让友元函数调用虚拟成员函数来解决友元的虚拟问题。</p><p>8、析构函数应当是虚函数，将调用相应对象类型的析构函数，因此，如果指针指向的是子类对象，将调用子类的析构函数，然后自动调用基类的析构函数。</p><p>有纯虚函数的类是抽象类，不能生成对象，只能派生。他派生的类的纯虚函数没有被改写，那么，它的派生类还是个抽象类。<br>定义纯虚函数就是为了让基类不可实例化化<br>因为实例化这样的抽象数据结构本身并没有意义。<br>或者给出实现也没有意义</p><p>实际上我个人认为纯虚函数的引入，是出于两个目的<br>1、为了安全，因为避免任何需要明确但是因为不小心而导致的未知的结果，提醒子类去做应做的实现。<br>2、为了效率，不是程序执行的效率，而是为了编码的效率。</p><h2 id="（28）-静态绑定和动态绑定的介绍"><a href="#（28）-静态绑定和动态绑定的介绍" class="headerlink" title="（28） 静态绑定和动态绑定的介绍"></a>（28） 静态绑定和动态绑定的介绍</h2><p>静态绑定：编译时绑定，通过对象调用<br>动态绑定：运行时绑定，通过地址实现</p><p>只有采用“指针-&gt;函数()”或“引用变量.函数()”的方式调用C++类中的虚函数才会执行动态绑定。对于C++中的非虚函数，因为其不具备动态绑定的特征，所以不管采用什么样的方式调用，都不会执行动态绑定。<br>即所谓动态绑定，就是基类的指针或引用有可能指向不同的派生类对象，对于非虚函数，执行时实际调用该函数的对象类型即为该指针或引用的静态类型（基类类型）；而对于虚函数，执行时实际调用该函数的对象类型为该指针或引用所指对象的实际类型</p><h2 id="（29）-引用是否能实现动态绑定，为什么引用可以实现"><a href="#（29）-引用是否能实现动态绑定，为什么引用可以实现" class="headerlink" title="（29） 引用是否能实现动态绑定，为什么引用可以实现"></a>（29） 引用是否能实现动态绑定，为什么引用可以实现</h2><p>可以实现，因为对象的类型是确定的，在编译期就确定了<br>指针或引用是在运行期根据他们绑定的具体对象确定。<br>引用和指针的静态类型和动态类型可以不一样。</p><p>静态类型：变量声明时的类型或表达式生成的类型。编译时已经知道。</p><p>动态类型：变量或表达式表示的内存的对象的类型。</p><h2 id="（30）-深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）"><a href="#（30）-深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）" class="headerlink" title="（30） 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）"></a>（30） 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）</h2><p>深浅拷贝的区别：<br>    浅拷贝是将原始对象中的数据型字段拷贝到新对象中去，将引用型字段的“引用”复制到新对象中去，不把“引用的对象”复制进去，所以原始对象和新对象引用同一对象，新对象中的引用型字段发生变化会导致原始对象中的对应字段也发生变化。<br>    深拷贝是在引用方面不同，深拷贝就是创建一个新的和原始字段的内容相同的字段，是两个一样大的数据段，所以两者的引用是不同的，之后的新对象中的引用型字段发生改变，不会引起原始对象中的字段发生改变。<br>C++类在定义时，系统会提供一个默认的拷贝构造函数，这个函数属于迁拷贝，当使用该类定义对象时赋值，如：类 A = B，就要用到它。一般来说系统提供的默认拷贝函数是不能满足需求的，我们一般要自己编写拷贝构造函数。而拷贝构造函数的定义方法如下：</p><pre><code>class 类名{    类名(const 类名 &amp;对象名);    // 函数定义}</code></pre><p>2<br>拷贝构造函数分为浅拷贝和深拷贝两种，浅拷贝和深拷贝主要区别就是复制指针时是否重新创建内存空间。</p><p>如果没有没有创建内存只赋值地址为浅拷贝，创建新内存把值全部拷贝一份就是深拷贝。</p><p>浅拷贝在类里面有指针成员的情况下只会复制指针的地址，会导致两个成员指针指向同一块内存，这样在要是分别delete释放时就会出现问题，因此需要用深拷贝。先看看下面的例子：</p><p>3<br>例子中建立了两个猫对象，b创建时调用拷贝构造函数拷贝了名字，然后a被delete掉，再调用b的Say()方法。如果使用默认的浅拷贝拷贝构造函数将会无法输出正确的名字，所以需要定义自己的拷贝构造函数。另外值得一提的是拷贝构造函数不是赋值运算符=号，如果对象已经创建在用=号复制，需要重载=号运算符函数。</p><p><a href="https://blog.csdn.net/qq_27011361/article/details/79518057" target="_blank" rel="noopener">https://blog.csdn.net/qq_27011361/article/details/79518057</a></p><h2 id="（31）-对象复用的了解，零拷贝的了解"><a href="#（31）-对象复用的了解，零拷贝的了解" class="headerlink" title="（31） 对象复用的了解，零拷贝的了解"></a>（31） 对象复用的了解，零拷贝的了解</h2><p>对象池：对象池通过对象复用的方式来避免重复创建对象，它会事先创建一定数量的对象放到池中，当用户需要创建对象的时候，直接从对象池中获取即可，用完对象之后再放回到对象池中，以便复用。</p><p>适用性：类的实例可重用。类的实例化过程开销较大。类的实例化的频率较高。</p><p>零拷贝：emplace_back</p><h2 id="（32）-介绍C-所有的构造函数"><a href="#（32）-介绍C-所有的构造函数" class="headerlink" title="（32） 介绍C++所有的构造函数"></a>（32） 介绍C++所有的构造函数</h2><h3 id="一、-构造函数是干什么的"><a href="#一、-构造函数是干什么的" class="headerlink" title="一、 构造函数是干什么的"></a>一、 构造函数是干什么的</h3><pre><code>/*   类对象被创建时，编译系统对象分配内存空间，并自动调用该构造函数-&gt;由构造函数完成成员的初始化工作     eg: Counter c1;     编译系统为对象c1的每个数据成员(m_value)分配内存空间，并调用构造函数Counter( )自动地初始化对象，初始化之后c1的m_value值设置为0     故：构造函数的作用：初始化对象的数据成员。*/      class Counter       {      public:       // 类Counter的构造函数，以类名作为函数名，无返回类型      Counter(){       m_value = 0;      }      private:      int m_value;  // 类私有的数据成员      }</code></pre><h3 id="二、-构造函数的种类"><a href="#二、-构造函数的种类" class="headerlink" title="二、 构造函数的种类"></a>二、 构造函数的种类</h3><pre><code>#include &lt;iostream&gt;using namespace std;class Complex{private :    double m_real;    double m_imag;public://*无参数构造函数// 如果创建一个类你没有写任何构造函数,则系统会自动生成默认的无参构造函数，函数为空，什么都不做// 只要你写了一个下面的某一种构造函数，系统就不会再自动生成这样一个默认的构造函数，如果希望有一个这样的无参构造函数，则需要自己显示地写出来    Complex(void)    {   m_real = 0.0;        m_imag = 0.0;    }//*一般构造函数（也称重载构造函数）//一般构造函数可以有各种参数形式,一个类可以有多个一般构造函数，前提是参数的个数或者类型不同（基于c++的重载函数原理）//例如：你还可以写一个 Complex(int num)的构造函数出来，创建对象时根据传入的参数不同调用不同的构造函数    Complex(double real, double imag)    {   m_real = real;        m_imag = imag;    }//*复制构造函数（也称为拷贝构造函数）//复制构造函数参数为类对象本身的引用，用于根据一个已存在的对象复制出一个新的该类的对象，一般在函数中会将已存在对象的数据成员的值复制一份到新创建的对象中//若没有显示的写复制构造函数，则系统会默认创建一个复制构造函数，但当类中有指针成员时，由系统默认创建该复制构造函数会存在风险，具体原因在有关 “浅拷贝”、“深拷贝”的文章中论述    Complex(const Complex &amp; c)    {   // 将对象c中的数据成员值复制过来        m_real = c.m_real;        m_imag = c.m_imag;    }//*类型转换构造函数，根据一个指定的类型的对象创建一个本类的对象，需要注意的一点是，这个其实就是一般的构造函数，但是对于出现这种单参数的构造函数，C++会默认将参数对应的类型转换为该类类型，//有时候这种隐私的转换是我们所不想要的，所以需要使用explicit来限制这种转换。//例如：下面将根据一个double类型的对象创建了一个Complex对象    Complex(double r)    {   m_real = r;        m_imag = 0.0;    }// 等号运算符重载（也叫赋值构造函数）// 注意，这个类似复制构造函数，将=右边的本类对象的值复制给等号左边的对象，它不属于构造函数，等号左右两边的对象必须已经被创建。// 若没有显示的写 =运算符重载，则系统也会创建一个默认的=运算符重载，只做一些基本的拷贝工作    Complex &amp;operator=(const Complex &amp;rhs )    {   // 首先检测等号右边的是否就是左边的对象本身，若是本对象本身,则直接返回        if ( this == &amp;rhs )        {   return *this;        }        // 复制等号右边的成员到左边的对象中        this-&gt;m_real = rhs.m_real;        this-&gt;m_imag = rhs.m_imag;        // 把等号左边的对象再次传出,目的是为了支持连等 eg:a=b=c 系统首先运行 b=c 然后运行 a=(b=c的返回值,这里应该是复制c值后的b对象)        return *this;    }};</code></pre><h3 id="三、使用上面定义的类对象来说明各个构造函数的用法："><a href="#三、使用上面定义的类对象来说明各个构造函数的用法：" class="headerlink" title="三、使用上面定义的类对象来说明各个构造函数的用法："></a>三、使用上面定义的类对象来说明各个构造函数的用法：</h3><pre><code>int main(){       // 调用了无参构造函数，数据成员初值被赋值为0.0    Complex c1,c2;    // 调用一般构造函数，数据成员初值分别被赋为指定值    Complex c3(1.0,2.5);    // 当然，也可以使用下面的形式    // Complex c3 = Complex(1.0,2.5);    //  把c3的数据成员的值赋值给事先被创建的对象c1    //  由于c1已经事先被创建，故此处不会调用任何构造函数    //  只会调用 = 号运算符重载函数    c1 = c3;      //  调用类型转换构造函数    //  系统首先调用类型转换构造函数，将5.2创建为一个本类的临时对象，然后调用等号运算符重载，将该临时对象赋值给c2    c2 = 5.2;      // 调用拷贝构造函数( 有下面两种调用方式)    Complex c5(c3);    Complex c4 = c3;    // 注意和 =运算符重载的区分,这里等号左边的对象不是事先已经创建，故需要调用拷贝构造函数，参数为c2    // 这一点特别重要，这儿是初始化，不是赋值。    // 其实这儿就涉及了C++中的两种初始化的方式：复制初始化和赋值初始化。    // 其中c5采用的是复制初始化，而c4采用的是赋值初始化，这两种方式都是要调用拷贝构造函数的。}</code></pre><h2 id="（33）-什么情况下会调用拷贝构造函数（三种情况）"><a href="#（33）-什么情况下会调用拷贝构造函数（三种情况）" class="headerlink" title="（33） 什么情况下会调用拷贝构造函数（三种情况）"></a>（33） 什么情况下会调用拷贝构造函数（三种情况）</h2><p>（1）用类的一个对象去初始化另一个对象时</p><p>（2）当函数的形参是类的对象时（也就是值传递时），如果是引用传递则不会调用</p><p>（3）当函数的返回值是类的对象或引用时</p><p>简单示例：</p><pre><code>#include &lt;iostream&gt;  using namespace std;  class A  {  private:      int a;  public:      A(int i){a=i;}  //内联的构造函数      A(A &amp;aa);      int geta(){return a;}  };  A::A(A &amp;aa)     //拷贝构造函数  {      a=aa.a;      cout&lt;&lt;&quot;拷贝构造函数执行！&quot;&lt;&lt;endl;  }  int get_a(A aa)     //参数是对象，是值传递，会调用拷贝构造函数  {      return aa.geta();  }  int get_a_1(A &amp;aa)  //如果参数是引用类型，本身就是引用传递，所以不会调用拷贝构造函数  {      return aa.geta();  }  A get_A()       //返回值是对象类型，会调用拷贝构造函数。会调用拷贝构造函数，因为函数体内生成的对象aa是临时的，离开这个函数就消失了。所有会调用拷贝构造函数复制一份。  {      A aa(1);      return aa;  }  A&amp; get_A_1()    //会调用拷贝构造函数，因为函数体内生成的对象aa是临时的，离开这个函数就消失了。所有会调用拷贝构造函数复制一份。  {      A aa(1);      return aa;  }  int _tmain(int argc, _TCHAR* argv[])  {      A a1(1);      A b1(a1);           //用a1初始化b1，调用拷贝构造函数      A c1=a1;            //用a1初始化c1，调用拷贝构造函数      int i=get_a(a1);        //函数形参是类的对象，调用拷贝构造函数      int j=get_a_1(a1);      //函数形参类型是引用，不调用拷贝构造函数      A d1=get_A();       //调用拷贝构造函数      A e1=get_A_1();     //调用拷贝构造函数      return 0;  }  </code></pre><h2 id="（34）-结构体内存对齐方式和为什么要进行内存对齐？"><a href="#（34）-结构体内存对齐方式和为什么要进行内存对齐？" class="headerlink" title="（34） 结构体内存对齐方式和为什么要进行内存对齐？"></a>（34） 结构体内存对齐方式和为什么要进行内存对齐？</h2><p>１:数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小（只要该成员有子成员，比如说是数组，结构体等）的整数倍开始(比如int在32位机为４字节,则要从４的整数倍地址开始存储。</p><p>２:结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部最大元素大小的整数倍地址开始存储.(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储.)</p><p>３:收尾工作:结构体的总大小,也就是sizeof的结果,.必须是其内部最大成员的整数倍.不足的要补齐.</p><p>4:在代码前加一句#pragma pack(1),告诉编译器,所有的对齐都按照1的整数倍对齐,换句话说就是没有对齐规则.如果#pragma pack (n)中指定的n大于结构体中最大成员的size，则其不起作用，结构体仍然按照size最大的成员进行对界</p><p>struct结构体变量大小等于结构体中的各个成员变量所占内存大小总和，union共用体变量大小等于共用体结构中占用内存最大的成员的内存大小。</p><p>首先先明白概念：<br>数据类型，指固定内存大小的别名，如int类型为4个字节内存。<br>变量，一段连续存储空间的别名。这段连续存储空间的大小，即变量的大小，由定义该变量的数据类型决定，即该数据类型代表的固定内存大小。数据类型，是变量的模板。</p><h2 id="（35）-内存泄露的定义，如何检测与避免？"><a href="#（35）-内存泄露的定义，如何检测与避免？" class="headerlink" title="（35） 内存泄露的定义，如何检测与避免？"></a>（35） 内存泄露的定义，如何检测与避免？</h2><p>申请的堆没有被释放，该内存不能在被利用。</p><h2 id="（36）-手写实现智能指针类（34-37我没遇见过）"><a href="#（36）-手写实现智能指针类（34-37我没遇见过）" class="headerlink" title="（36） 手写实现智能指针类（34-37我没遇见过）"></a>（36） 手写实现智能指针类（34-37我没遇见过）</h2><h2 id="（37）-调试程序的方法"><a href="#（37）-调试程序的方法" class="headerlink" title="（37） 调试程序的方法"></a>（37） 调试程序的方法</h2><h2 id="（38）-遇到coredump要怎么调试"><a href="#（38）-遇到coredump要怎么调试" class="headerlink" title="（38） 遇到coredump要怎么调试"></a>（38） 遇到coredump要怎么调试</h2><h2 id="（39）-内存检查工具的了解"><a href="#（39）-内存检查工具的了解" class="headerlink" title="（39） 内存检查工具的了解"></a>（39） 内存检查工具的了解</h2><h2 id="（40）-模板的用法与适用场景"><a href="#（40）-模板的用法与适用场景" class="headerlink" title="（40） 模板的用法与适用场景"></a>（40） 模板的用法与适用场景</h2><h3 id="（1）函数模板"><a href="#（1）函数模板" class="headerlink" title="（1）函数模板"></a>（1）函数模板</h3><p>函数模板能够用来创建一个通用的函数。以支持多种不同的形參。避免重载函数的函数体反复设计。</p><p>它的最大特点是把函数使用的数据类型作为參数。</p><p>函数模板的声明形式为：</p><pre><code>template&lt;typename（或class) T&gt;&lt;返回类型&gt;&lt;函数名&gt;(參数表){    函数体}</code></pre><p>当中，template是定义模板函数的关键字；template后面的尖括号不能省略；typename（或class)是声明数据类型參数标识符的关键字。用以说明它后面的标识符是数据类型标识符。这样，在以后定义的这个函数中，凡希望依据实參数据类型来确定数据类型的变量，都能够用数据类型參数标识符来说明，从而使这个变量能够适应不同的数据类型。</p><p>比如：</p><pre><code>template&lt;typename（或class) T&gt;T fuc(T x, T y){    T x;    //……}</code></pre><p>函数模板仅仅是声明了一个函数的描写叙述即模板。不是一个能够直接运行的函数，仅仅有依据实际情况用实參的数据类型取代类型參数标识符之后，才干产生真正的函数。</p><h3 id="（2）模板函数："><a href="#（2）模板函数：" class="headerlink" title="（2）模板函数："></a>（2）模板函数：</h3><p>模板函数的生成就是将函数模板的类型形參实例化的过程。</p><p>比如：</p><pre><code>double d;    int a;    fuc(d,a);</code></pre><p>则系统将用实參d的数据类型double去取代函数模板中的T生成函数：</p><pre><code>double fuc(double x,int y){    double x;    //……}</code></pre><h2 id="（41）-成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？"><a href="#（41）-成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？" class="headerlink" title="（41） 成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？"></a>（41） 成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？</h2><p>概念：以一个冒号开始，接着是以逗号分隔的数据成员列表，每个数据成员后面跟一个放在括号中的初始化式，对成员进行初始化。</p><p>效率：构造函数之前执行默认初始化。而成员初始化列表，可以立即初始化，所以更快些。</p><p>成员是const对象和引用必须初始化。</p><h2 id="（42）-用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）"><a href="#（42）-用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）" class="headerlink" title="（42） 用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）"></a>（42） 用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）</h2><p>C++11：C++11包括大量的新特性：包括lambda表达式，类型推导关键字auto、decltype，和模板的大量改进。</p><h3 id="新的关键字"><a href="#新的关键字" class="headerlink" title="新的关键字"></a>新的关键字</h3><h4 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h4><p>C++11中引入auto第一种作用是为了自动类型推导</p><p>auto的自动类型推导，用于从初始化表达式中推断出变量的数据类型。通过auto的自动类型推导，可以大大简化我们的编程工作</p><p>auto实际上实在编译时对变量进行了类型推导，所以不会对程序的运行效率造成不良影响</p><p>另外，似乎auto并不会影响编译速度，因为编译时本来也要右侧推导然后判断与左侧是否匹配。</p><pre><code>auto a; // 错误，auto是通过初始化表达式进行类型推导，如果没有初始化表达式，就无法确定a的类型  auto i = 1;  auto d = 1.0;  auto str = &quot;Hello World&quot;;  auto ch = &apos;A&apos;;  auto func = less&lt;int&gt;();  vector&lt;int&gt; iv;  auto ite = iv.begin();  auto p = new foo() // 对自定义类型进行类型推导 </code></pre><p>auto不光有以上的应用，它在模板中也是大显身手，比如下例这个加工产品的例子中，如果不使用auto就必须声明Product这一模板参数：</p><pre><code>template &lt;typename Product, typename Creator&gt;  void processProduct(const Creator&amp; creator) {      Product* val = creator.makeObject();      // do somthing with val  }         </code></pre><p>如果使用auto，则可以这样写：</p><pre><code>template &lt;typename Creator&gt;  void processProduct(const Creator&amp; creator) {      auto val = creator.makeObject();      // do somthing with val  } </code></pre><p>抛弃了麻烦的模板参数，整个代码变得更加正解了。</p><h4 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h4><p>decltype实际上有点像auto的反函数，auto可以让你声明一个变量，而decltype则可以从一个变量或表达式中得到类型，有实例如下：</p><pre><code>int x = 3;  decltype(x) y = x; </code></pre><p>有人会问，decltype的实用之处在哪里呢，我们接着上边的例子继续说下去，如果上文中的加工产品的例子中我们想把产品作为返回值该怎么办呢？我们可以这样写：</p><pre><code>template &lt;typename Creator&gt;  auto processProduct(const Creator&amp; creator) -&gt; decltype(creator.makeObject()) {      auto val = creator.makeObject();      // do somthing with val  } nullptr</code></pre><p>nullptr是为了解决原来C++中NULL的二义性问题而引进的一种新的类型，因为NULL实际上代表的是0，</p><pre><code>void F(int a){      cout&lt;&lt;a&lt;&lt;endl;  }  void F(int *p){      assert(p != NULL);      cout&lt;&lt; p &lt;&lt;endl;  }  int main(){      int *p = nullptr;      int *q = NULL;      bool equal = ( p == q ); // equal的值为true，说明p和q都是空指针      int a = nullptr; // 编译失败，nullptr不能转型为int      F(0); // 在C++98中编译失败，有二义性；在C++11中调用F（int）      F(nullptr);      return 0;  } </code></pre><h3 id="序列for循环"><a href="#序列for循环" class="headerlink" title="序列for循环"></a>序列for循环</h3><p>在C++中for循环可以使用类似java的简化的for循环，可以用于遍历数组，容器，string以及由begin和end函数定义的序列（即有Iterator），示例代码如下：</p><pre><code>map&lt;string, int&gt; m{{"a", 1}, {"b", 2}, {"c", 3}};  for (auto p : m){      cout&lt;&lt;p.first&lt;&lt;&quot; : &quot;&lt;&lt;p.second&lt;&lt;endl;  } </code></pre><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>lambda表达式类似Javascript中的闭包，它可以用于创建并定义匿名的函数对象，以简化编程工作。Lambda的语法如下：</p><pre><code>[函数对象参数]（操作符重载函数参数）-&gt;返回值类型{函数体}vector&lt;int&gt; iv{5, 4, 3, 2, 1};  int a = 2, b = 1;  for_each(iv.begin(), iv.end(), [b](int &amp;x){cout&lt;&lt;(x + b)&lt;&lt;endl;}); // (1)  for_each(iv.begin(), iv.end(), [=](int &amp;x){x *= (a + b);});     // (2)  for_each(iv.begin(), iv.end(), [=](int &amp;x)-&gt;int{return x * (a + b);});// (3) </code></pre><p>[]内的参数指的是Lambda表达式可以取得的全局变量。(1)函数中的b就是指函数可以得到在Lambda表达式外的全局变量，如果在[]中传入=的话，即是可以取得所有的外部变量，如（2）和（3）Lambda表达式<br>()内的参数是每次调用函数时传入的参数。<br>-&gt;后加上的是Lambda表达式返回值的类型，如（3）中返回了一个int类型的变量</p><h3 id="变长参数的模板"><a href="#变长参数的模板" class="headerlink" title="变长参数的模板"></a>变长参数的模板</h3><p>我们在C++中都用过pair，pair可以使用make_pair构造，构造一个包含两种不同类型的数据的容器。比如，如下代码：</p><pre><code>auto p = make_pair(1, &quot;C++ 11&quot;); 由于在C++11中引入了变长参数模板，所以发明了新的数据类型：tuple，tuple是一个N元组，可以传入1个， 2个甚至多个不同类型的数据auto t1 = make_tuple(1, 2.0, &quot;C++ 11&quot;);  auto t2 = make_tuple(1, 2.0, &quot;C++ 11&quot;, {1, 0, 2}); </code></pre><p>这样就避免了从前的pair中嵌套pair的丑陋做法，使得代码更加整洁</p><p>另一个经常见到的例子是Print函数，在C语言中printf可以传入多个参数，在C++11中，我们可以用变长参数模板实现更简洁的Print</p><pre><code>template&lt;typename head, typename... tail&gt;  void Print(Head head, typename... tail) {      cout&lt;&lt; head &lt;&lt;endl;      Print(tail...);  } </code></pre><p>Print中可以传入多个不同种类的参数，如下：</p><p>Print(1, 1.0, “C++11”); </p><h3 id="更加优雅的初始化方法"><a href="#更加优雅的初始化方法" class="headerlink" title="更加优雅的初始化方法"></a>更加优雅的初始化方法</h3><p>在引入C++11之前，只有数组能使用初始化列表，其他容器想要使用初始化列表，只能用以下方法：</p><pre><code>int arr[3] = {1, 2, 3}  vector&lt;int&gt; v(arr, arr + 3); </code></pre><p>在C++11中，我们可以使用以下语法来进行替换：</p><pre><code>int arr[3]{1, 2, 3};  vector&lt;int&gt; iv{1, 2, 3};  map&lt;int, string&gt;{{1, "a"}, {2, "b"}};  string str{&quot;Hello World&quot;}; </code></pre><h3 id="C-14：C-14的主要特性可以分为三个领域：Lambda函数、constexpr和类型推导。"><a href="#C-14：C-14的主要特性可以分为三个领域：Lambda函数、constexpr和类型推导。" class="headerlink" title="C++14：C++14的主要特性可以分为三个领域：Lambda函数、constexpr和类型推导。"></a>C++14：C++14的主要特性可以分为三个领域：Lambda函数、constexpr和类型推导。</h3><h3 id="Lambda函数"><a href="#Lambda函数" class="headerlink" title="Lambda函数"></a>Lambda函数</h3><p>C++14的泛型Lambda使编写如下语句成为可能：</p><pre><code>auto lambda = [](auto x, auto y) {return x + y;};</code></pre><p>而另一方面，C++11要求Lambda参数使用具体的类型声明，比如：</p><pre><code>auto lambda = [](int x, int y) {return x + y;};</code></pre><p>此外，新标准中的std::move函数可用于捕获Lambda表达式中的变量，这是通过移动对象而非复制或引用对象实现的：</p><pre><code>std::unique_ptr ptr(new int(10));auto lambda = [value = std::move(ptr)] {return *value;};</code></pre><h3 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h3><p>在C++11中，使用constexpr声明的函数可以在编译时执行，生成一个值，用在需要常量表达式的地方，比如作为初始化模板的整形参数。C++11的constexpr函数只能包含一个表达式，C++14放松了这些限制，支持诸如if 和switch等条件语句，支持循环，其中包括基于区间（range）的for 循环。</p><h3 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h3><p>C++11仅支持Lambda函数的类型推导，C++14对其加以扩展，支持所有函数的返回类型推导：</p><pre><code>auto DeducedReturnTypeFunction();</code></pre><p>因为C++14是强类型语言，有些限制需要考虑：</p><p>如果一个函数的实现中有多个返回语句，这些语句一定要推导出同样的类型。<br>返回类型推导可以用在前向声明中，但是在使用它们之前，翻译单元中必须能够得到函数定义。<br>返回类型推导可以用在递归函数中，但是递归调用必须以至少一个返回语句作为先导，以便编译器推导出返回类型。<br>C++14带来的另一个类型推导方面的改进是decltype(auto)语法，它支持使用与auto同样的机制计算给定表达式的类型。auto和 decltype在C++11中就已经出现了，但是它们在推导类型时使用了不同的机制，这可能会产生不同的结果。</p><p>C++14中的其他改变包括可以声明变量模板，支持使用0b或0B前缀来声明二进制字面常量。InfoQ已经介绍过C++14中可能破坏C++11程序的其他小型修改。</p><h2 id="（43）-C-的调用惯例（简单一点C-函数调用的压栈过程）"><a href="#（43）-C-的调用惯例（简单一点C-函数调用的压栈过程）" class="headerlink" title="（43） C++的调用惯例（简单一点C++函数调用的压栈过程）"></a>（43） C++的调用惯例（简单一点C++函数调用的压栈过程）</h2><h2 id="（44）-C-的四种强制转换"><a href="#（44）-C-的四种强制转换" class="headerlink" title="（44） C++的四种强制转换"></a>（44） C++的四种强制转换</h2><p>C语言中的强制类型转换可以随意的转换我们想要的类型了,格式如下</p><pre><code>(类型) 变量名;</code></pre><p>为什么c++还要引入新的4种类型转换呢?</p><p>  这是因为新的类型转换控制符可以很好的控制类型转换的过程,允许控制各种类型不同的转换.</p><p>  还有一点好处是C++的类型转换控制符能告诉程序员或读者我们这个转换的目的是什么,我们<br> 只要看一下代码的类型转换控制符,就能明白我们想要达到什么样的目的.</p><h3 id="1-static-cast-lt-T-gt-content-静态转换-在编译期间处理"><a href="#1-static-cast-lt-T-gt-content-静态转换-在编译期间处理" class="headerlink" title="1)static_cast &lt;T*&gt; (content)  静态转换.在编译期间处理"></a>1)static_cast &lt;T*&gt; (content)  静态转换.在编译期间处理</h3><p>   它主要用于C++中内置的基本数据类型之间的转换.但是没有运行时类型的检测来保证转换的安全性.</p><p>   为什么需要static_cast类型的转换?</p><h4 id="a-用于基类和子类之间的指针或引用的转换。"><a href="#a-用于基类和子类之间的指针或引用的转换。" class="headerlink" title="a.用于基类和子类之间的指针或引用的转换。"></a>a.用于基类和子类之间的指针或引用的转换。</h4><p>这种转换把子类的指针或引用转换为基类表示是安全的;进行下行转换,把基类的指针或引用转换为子类表示时,由于没有进行动态类型检测,所以是不安全的;</p><h4 id="b-把void类型的指针转换成目标类型的指针-不安全"><a href="#b-把void类型的指针转换成目标类型的指针-不安全" class="headerlink" title="b.把void类型的指针转换成目标类型的指针(不安全)."></a>b.把void类型的指针转换成目标类型的指针(不安全).</h4><h4 id="c-用于内置的基本的数据类型之间的转换"><a href="#c-用于内置的基本的数据类型之间的转换" class="headerlink" title="c.用于内置的基本的数据类型之间的转换."></a>c.用于内置的基本的数据类型之间的转换.</h4><h4 id="d-把任何类型的表达式转换成void类型的"><a href="#d-把任何类型的表达式转换成void类型的" class="headerlink" title="d.把任何类型的表达式转换成void类型的."></a>d.把任何类型的表达式转换成void类型的.</h4><p>   注意:static_cast不会转换掉content的const,volatile,__unaligned属性</p><h3 id="2-static-const-lt-T-gt-content-去常转换-编译时执行"><a href="#2-static-const-lt-T-gt-content-去常转换-编译时执行" class="headerlink" title="2)static_const&lt;T*&gt;(content):去常转换;编译时执行;"></a>2)static_const&lt;T*&gt;(content):去常转换;编译时执行;</h3><p>  它主要作用同一个类型之间的去常和添加常属性之间的转换.不能用做不同的类型之间的转换.</p><p>  它可以把一个不是常属性的转换成常属性的,同时它也可以对一个本是常属性的类型进行去常.</p><h3 id="3-dynamic-cast-lt-T-gt-content-动态类型转换-也是向下安全转型-是在运行的时候执行"><a href="#3-dynamic-cast-lt-T-gt-content-动态类型转换-也是向下安全转型-是在运行的时候执行" class="headerlink" title="3)dynamic_cast&lt;T*&gt;(content) 动态类型转换;也是向下安全转型;是在运行的时候执行;"></a>3)dynamic_cast&lt;T*&gt;(content) 动态类型转换;也是向下安全转型;是在运行的时候执行;</h3><p>   通常用于基类和派生类之间的转换.转换时会进行类型安全检查。</p><h4 id="a-4"><a href="#a-4" class="headerlink" title="a."></a>a.</h4><p>不能用于内置的基本数据类型之间的转换.</p><h4 id="b-5"><a href="#b-5" class="headerlink" title="b."></a>b.</h4><p>dynamic_cast转换成功的话返回的是类的指针或引用,失败返回null;</p><h4 id="c-3"><a href="#c-3" class="headerlink" title="c."></a>c.</h4><p>dynamic_cast进行的转换的时候基类中一定要有虚函数,因为只有类中有了虚函数, 才说明它希望让基类指针或引用指向其派生类对象的情况,这样才有意义.这是由于运行时类型检查需要运行时类型的信息,而这些信息存储在虚函数表中.</p><h4 id="d-3"><a href="#d-3" class="headerlink" title="d."></a>d.</h4><p>在类的转换时,在类层次间进行转换的时候,dynamic_cast和static_cast进行上行转换的时候效果是一样的；但是在进行下行转换的时候,dynamic_cast会进行类型检查所以它更安全.它可以让指向基类的指针转换为指向其子类的指针或是其兄弟类的指针;</p><h3 id="4-reinterpret-cast-lt-T-gt-content-重解释类型转换"><a href="#4-reinterpret-cast-lt-T-gt-content-重解释类型转换" class="headerlink" title="4)reinterpret_cast&lt;T*&gt;(content)重解释类型转换;"></a>4)reinterpret_cast&lt;T*&gt;(content)重解释类型转换;</h3><p>   它有着和C风格强制类型转换同样的功能;它可以转化任何的内置数据类型为其他的类型, 同时它也可以把任何类型的指针转化为其他的类型;它的机理是对二进制数据进行重新的的解释,不会改变原来的格式,而static_cast会改变原来的格式;</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;C-面试高频题&quot;&gt;&lt;a href=&quot;#C-面试高频题&quot; class=&quot;headerlink&quot; title=&quot;C++面试高频题&quot;&gt;&lt;/a&gt;C++面试高频题&lt;/h1&gt;&lt;p&gt;整理一下互联网公司语言基础（C++）面试高频题&lt;/p&gt;
    
    </summary>
    
      <category term="2018年9月" scheme="http://yoursite.com/categories/2018%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
</feed>
