<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-02T14:38:21.897Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>238. 除自身以外数组的乘积</title>
    <link href="http://yoursite.com/2020/07/02/238.%20%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF/"/>
    <id>http://yoursite.com/2020/07/02/238. 除自身以外数组的乘积/</id>
    <published>2020-07-02T14:52:12.000Z</published>
    <updated>2020-07-02T14:38:21.897Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。</p><a id="more"></a><p>示例:</p><pre><code>输入: [1,2,3,4]输出: [24,12,8,6]提示：题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。</code></pre><p>进阶：</p><p>你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）</p><h3 id="📺视频题解"><a href="#📺视频题解" class="headerlink" title="📺视频题解"></a>📺视频题解</h3><p> <a href="5f8f385b-1288-4c91-8a65-e7490a96764c">238.除自身以外数组的乘积.mp4</a></p><h3 id="📖文字题解"><a href="#📖文字题解" class="headerlink" title="📖文字题解"></a>📖文字题解</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>这似乎是一个简单的问题，可以在线性时间和空间内解决。先计算给定数组所有元素的乘积，然后对数组中的每个元素 <em>x</em>，将总的乘积除以 <em>x</em> 来求得除自身值的以外数组的乘积。</p><p>然而这样的解决方法有一个问题，就是如果输入数组中出现 0，那么这个方法就失效了。而且在问题中说明了不允许使用除法运算。这增加了这个问题的难度。</p><h4 id="方法一：左右乘积列表"><a href="#方法一：左右乘积列表" class="headerlink" title="方法一：左右乘积列表"></a>方法一：左右乘积列表</h4><p><strong>思路</strong></p><p>我们不必将所有数字的乘积除以给定索引处的数字得到相应的答案，而是利用索引左侧所有数字的乘积和右侧所有数字的乘积（即前缀与后缀）相乘得到答案。</p><p>对于给定索引 <em>i</em>，我们将使用它左边所有数字的乘积乘以右边所有数字的乘积。下面让我们更加具体的描述这个算法。</p><p><strong>算法</strong></p><ol><li>初始化两个空数组 <code>L</code> 和 <code>R</code>。对于给定索引 <code>i</code>，<code>L[i]</code> 代表的是 <code>i</code> 左侧所有数字的乘积，<code>R[i]</code> 代表的是 <code>i</code> 右侧所有数字的乘积。</li><li>我们需要用两个循环来填充 <code>L</code> 和 <code>R</code> 数组的值。对于数组 <code>L</code>，<code>L[0]</code> 应该是 <code>1</code>，因为第一个元素的左边没有元素。对于其他元素：<code>L[i] = L[i-1] * nums[i-1]</code>。</li><li>同理，对于数组 <code>R</code>，<code>R[length-1]</code> 应为 <code>1</code>。<code>length</code> 指的是输入数组的大小。其他元素：<code>R[i] = R[i+1] * nums[i+1]</code>。</li><li>当 <code>R</code> 和 <code>L</code> 数组填充完成，我们只需要在输入数组上迭代，且索引 <code>i</code> 处的值为：<code>L[i] * R[i]</code>。</li></ol><p>让我们用以下图片看看算法是如何工作的：</p><p>  <a href="https://assets.leetcode-cn.com/solution-static/238/1.PNG" target="_blank" rel="noopener">fig1</a>  <a href="https://assets.leetcode-cn.com/solution-static/238/2.PNG" target="_blank" rel="noopener">fig2</a>  <a href="https://assets.leetcode-cn.com/solution-static/238/3.PNG" target="_blank" rel="noopener">fig3</a>  <a href="https://assets.leetcode-cn.com/solution-static/238/4.PNG" target="_blank" rel="noopener">fig4</a>  <a href="https://assets.leetcode-cn.com/solution-static/238/5.PNG" target="_blank" rel="noopener">fig5</a>  <a href="https://assets.leetcode-cn.com/solution-static/238/6.PNG" target="_blank" rel="noopener">fig6</a>  <a href="https://assets.leetcode-cn.com/solution-static/238/7.PNG" target="_blank" rel="noopener">fig7</a>  <a href="https://assets.leetcode-cn.com/solution-static/238/8.PNG" target="_blank" rel="noopener">fig8</a>  <a href="https://assets.leetcode-cn.com/solution-static/238/9.PNG" target="_blank" rel="noopener">fig9</a>  <a href="https://assets.leetcode-cn.com/solution-static/238/10.PNG" target="_blank" rel="noopener">fig10</a> </p><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; productExceptSelf(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// L 和 R 分别表示左右两侧的乘积列表</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; L(length, <span class="number">0</span>), R(length, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; answer(length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// L[i] 为索引 i 左侧所有元素的乘积</span></span><br><span class="line">        <span class="comment">// 对于索引为 '0' 的元素，因为左侧没有元素，所以 L[0] = 1</span></span><br><span class="line">        L[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            L[i] = nums[i - <span class="number">1</span>] * L[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// R[i] 为索引 i 右侧所有元素的乘积</span></span><br><span class="line">        <span class="comment">// 对于索引为 'length-1' 的元素，因为右侧没有元素，所以 R[length-1] = 1</span></span><br><span class="line">        R[length - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            R[i] = nums[i + <span class="number">1</span>] * R[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于索引 i，除 nums[i] 之外其余各元素的乘积就是左侧所有元素的乘积乘以右侧所有元素的乘积</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            answer[i] = L[i] * R[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        length = len(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># L 和 R 分别表示左右两侧的乘积列表</span></span><br><span class="line">        L, R, answer = [<span class="number">0</span>]*length, [<span class="number">0</span>]*length, [<span class="number">0</span>]*length</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># L[i] 为索引 i 左侧所有元素的乘积</span></span><br><span class="line">        <span class="comment"># 对于索引为 '0' 的元素，因为左侧没有元素，所以 L[0] = 1</span></span><br><span class="line">        L[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, length):</span><br><span class="line">            L[i] = nums[i - <span class="number">1</span>] * L[i - <span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># R[i] 为索引 i 右侧所有元素的乘积</span></span><br><span class="line">        <span class="comment"># 对于索引为 'length-1' 的元素，因为右侧没有元素，所以 R[length-1] = 1</span></span><br><span class="line">        R[length - <span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(length - <span class="number">1</span>)):</span><br><span class="line">            R[i] = nums[i + <span class="number">1</span>] * R[i + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对于索引 i，除 nums[i] 之外其余各元素的乘积就是左侧所有元素的乘积乘以右侧所有元素的乘积</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">            answer[i] = L[i] * R[i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// L 和 R 分别表示左右两侧的乘积列表</span></span><br><span class="line">        <span class="keyword">int</span>[] L = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">int</span>[] R = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// L[i] 为索引 i 左侧所有元素的乘积</span></span><br><span class="line">        <span class="comment">// 对于索引为 '0' 的元素，因为左侧没有元素，所以 L[0] = 1</span></span><br><span class="line">        L[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            L[i] = nums[i - <span class="number">1</span>] * L[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// R[i] 为索引 i 右侧所有元素的乘积</span></span><br><span class="line">        <span class="comment">// 对于索引为 'length-1' 的元素，因为右侧没有元素，所以 R[length-1] = 1</span></span><br><span class="line">        R[length - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            R[i] = nums[i + <span class="number">1</span>] * R[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于索引 i，除 nums[i] 之外其余各元素的乘积就是左侧所有元素的乘积乘以右侧所有元素的乘积</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            answer[i] = L[i] * R[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">productExceptSelf</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    length := <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// L 和 R 分别表示左右两侧的乘积列表</span></span><br><span class="line">    L, R, answer := <span class="built_in">make</span>([]<span class="keyword">int</span>, length), <span class="built_in">make</span>([]<span class="keyword">int</span>, length), <span class="built_in">make</span>([]<span class="keyword">int</span>, length)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// L[i] 为索引 i 左侧所有元素的乘积</span></span><br><span class="line">    <span class="comment">// 对于索引为 '0' 的元素，因为左侧没有元素，所以 L[0] = 1</span></span><br><span class="line">    L[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; length; i++ &#123;</span><br><span class="line">        L[i] = nums[i<span class="number">-1</span>] * L[i<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R[i] 为索引 i 右侧所有元素的乘积</span></span><br><span class="line">    <span class="comment">// 对于索引为 'length-1' 的元素，因为右侧没有元素，所以 R[length-1] = 1</span></span><br><span class="line">    R[length<span class="number">-1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        R[i] = nums[i+<span class="number">1</span>] * R[i+<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对于索引 i，除 nums[i] 之外其余各元素的乘积就是左侧所有元素的乘积乘以右侧所有元素的乘积</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line">        answer[i] = L[i] * R[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><figcaption><span>[sol1-TypeScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> productExceptSelf = <span class="function"><span class="keyword">function</span>(<span class="params">nums: <span class="built_in">number</span>[]</span>): <span class="title">number</span>[] </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> length = nums.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// L 和 R 分别表示左右两侧的乘积列表</span></span><br><span class="line">    <span class="keyword">const</span> L = <span class="keyword">new</span> <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt;(length);</span><br><span class="line">    <span class="keyword">const</span> R = <span class="keyword">new</span> <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt;(length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> answer = <span class="keyword">new</span> <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt;(length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// L[i] 为索引 i 左侧所有元素的乘积</span></span><br><span class="line">    <span class="comment">// 对于索引为 '0' 的元素，因为左侧没有元素，所以 L[0] = 1</span></span><br><span class="line">    L[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">        L[i] = nums[i - <span class="number">1</span>] * L[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R[i] 为索引 i 右侧所有元素的乘积</span></span><br><span class="line">    <span class="comment">// 对于索引为 'length-1' 的元素，因为右侧没有元素，所以 R[length-1] = 1</span></span><br><span class="line">    R[length - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        R[i] = nums[i + <span class="number">1</span>] * R[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于索引 i，除 nums[i] 之外其余各元素的乘积就是左侧所有元素的乘积乘以右侧所有元素的乘积</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        answer[i] = L[i] * R[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(N)*，其中 *N</em> 指的是数组 <code>nums</code> 的大小。预处理 <code>L</code> 和 <code>R</code> 数组以及最后的遍历计算都是 <em>O(N)</em> 的时间复杂度。</li><li>空间复杂度：<em>O(N)*，其中 *N</em> 指的是数组 <code>nums</code> 的大小。使用了 <code>L</code> 和 <code>R</code> 数组去构造答案，<code>L</code> 和 <code>R</code> 数组的长度为数组 <code>nums</code> 的大小。</li></ul><h4 id="方法二：空间复杂度-O-1-的方法"><a href="#方法二：空间复杂度-O-1-的方法" class="headerlink" title="方法二：空间复杂度 O(1) 的方法"></a>方法二：空间复杂度 <em>O(1)</em> 的方法</h4><p><strong>思路</strong></p><p>尽管上面的方法已经能够很好的解决这个问题，但是空间复杂度并不为常数。</p><p>由于输出数组不算在空间复杂度内，那么我们可以将 <code>L</code> 或 <code>R</code> 数组用输出数组来计算。先把输出数组当作 <code>L</code> 数组来计算，然后再动态构造 <code>R</code> 数组得到结果。让我们来看看基于这个思想的算法。</p><p><strong>算法</strong></p><ol><li>初始化 <code>answer</code> 数组，对于给定索引 <code>i</code>，<code>answer[i]</code> 代表的是 <code>i</code> 左侧所有数字的乘积。</li><li>构造方式与之前相同，只是我们试图节省空间，先把 <code>answer</code> 作为方法一的 <code>L</code> 数组。</li><li>这种方法的唯一变化就是我们没有构造 <code>R</code> 数组。而是用一个遍历来跟踪右边元素的乘积。并更新数组 <em>answer[i]=answer[i]<em>R</em>。然后 *R</em> 更新为 <em>R=R<em>nums[i]</em>，其中变量 *R</em> 表示的就是索引右侧数字的乘积。</li></ol><figure class="highlight cpp"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; productExceptSelf(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; answer(length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// answer[i] 表示索引 i 左侧所有元素的乘积</span></span><br><span class="line">        <span class="comment">// 因为索引为 '0' 的元素左侧没有元素， 所以 answer[0] = 1</span></span><br><span class="line">        answer[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            answer[i] = nums[i - <span class="number">1</span>] * answer[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// R 为右侧所有元素的乘积</span></span><br><span class="line">        <span class="comment">// 刚开始右边没有元素，所以 R = 1</span></span><br><span class="line">        <span class="keyword">int</span> R = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R</span></span><br><span class="line">            answer[i] = answer[i] * R;</span><br><span class="line">            <span class="comment">// R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上</span></span><br><span class="line">            R *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        length = len(nums)</span><br><span class="line">        answer = [<span class="number">0</span>]*length</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># answer[i] 表示索引 i 左侧所有元素的乘积</span></span><br><span class="line">        <span class="comment"># 因为索引为 '0' 的元素左侧没有元素， 所以 answer[0] = 1</span></span><br><span class="line">        answer[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, length):</span><br><span class="line">            answer[i] = nums[i - <span class="number">1</span>] * answer[i - <span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># R 为右侧所有元素的乘积</span></span><br><span class="line">        <span class="comment"># 刚开始右边没有元素，所以 R = 1</span></span><br><span class="line">        R = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(length)):</span><br><span class="line">            <span class="comment"># 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R</span></span><br><span class="line">            answer[i] = answer[i] * R</span><br><span class="line">            <span class="comment"># R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上</span></span><br><span class="line">            R *= nums[i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// answer[i] 表示索引 i 左侧所有元素的乘积</span></span><br><span class="line">        <span class="comment">// 因为索引为 '0' 的元素左侧没有元素， 所以 answer[0] = 1</span></span><br><span class="line">        answer[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            answer[i] = nums[i - <span class="number">1</span>] * answer[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// R 为右侧所有元素的乘积</span></span><br><span class="line">        <span class="comment">// 刚开始右边没有元素，所以 R = 1</span></span><br><span class="line">        <span class="keyword">int</span> R = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R</span></span><br><span class="line">            answer[i] = answer[i] * R;</span><br><span class="line">            <span class="comment">// R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上</span></span><br><span class="line">            R *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">productExceptSelf</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    length := <span class="built_in">len</span>(nums)</span><br><span class="line">    answer := <span class="built_in">make</span>([]<span class="keyword">int</span>, length)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// answer[i] 表示索引 i 左侧所有元素的乘积</span></span><br><span class="line">    <span class="comment">// 因为索引为 '0' 的元素左侧没有元素， 所以 answer[0] = 1</span></span><br><span class="line">    answer[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; length; i++ &#123;</span><br><span class="line">        answer[i] = nums[i<span class="number">-1</span>] * answer[i<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R 为右侧所有元素的乘积</span></span><br><span class="line">    <span class="comment">// 刚开始右边没有元素，所以 R = 1</span></span><br><span class="line">    R := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="comment">// 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R</span></span><br><span class="line">        answer[i] = answer[i] * R</span><br><span class="line">        <span class="comment">// R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上</span></span><br><span class="line">        R *= nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><figcaption><span>[sol2-TypeScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> productExceptSelf = <span class="function"><span class="keyword">function</span>(<span class="params">nums: <span class="built_in">number</span>[]</span>): <span class="title">number</span>[] </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> length = nums.length;</span><br><span class="line">    <span class="keyword">const</span> answer = <span class="keyword">new</span> <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt;(length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// answer[i] 表示索引 i 左侧所有元素的乘积</span></span><br><span class="line">    <span class="comment">// 因为索引为 '0' 的元素左侧没有元素， 所以 answer[0] = 1</span></span><br><span class="line">    answer[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">        answer[i] = nums[i - <span class="number">1</span>] * answer[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R 为右侧所有元素的乘积</span></span><br><span class="line">    <span class="comment">// 刚开始右边没有元素，所以 R = 1</span></span><br><span class="line">    <span class="keyword">let</span> R = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R</span></span><br><span class="line">        answer[i] = answer[i] * R;</span><br><span class="line">        <span class="comment">// R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上</span></span><br><span class="line">        R *= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(N)*，其中 *N</em> 指的是数组 <code>nums</code> 的大小。分析与方法一相同。</li><li>空间复杂度：<em>O(1)</em>，输出数组不算进空间复杂度中，因此我们只需要常数的空间存放变量。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你一个长度为 n 的整数数组 nums，其中 n &amp;gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年7月" scheme="http://yoursite.com/categories/2020%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>155. 最小栈</title>
    <link href="http://yoursite.com/2020/07/02/155.%20%20%E6%9C%80%E5%B0%8F%E6%A0%88/"/>
    <id>http://yoursite.com/2020/07/02/155.  最小栈/</id>
    <published>2020-07-02T14:36:12.000Z</published>
    <updated>2020-07-06T01:04:42.706Z</updated>
    
    <content type="html"><![CDATA[<p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p><a id="more"></a><h1 id="题目描述（简单难度）"><a href="#题目描述（简单难度）" class="headerlink" title="题目描述（简单难度）"></a>题目描述（简单难度）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push(x) —— 将元素 x 推入栈中。</span><br><span class="line">pop() —— 删除栈顶的元素。</span><br><span class="line">top() —— 获取栈顶元素。</span><br><span class="line">getMin() —— 检索栈中的最小元素。</span><br></pre></td></tr></table></figure><p>示例:</p><pre><code>输入：[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;][[],[-2],[0],[-3],[],[],[],[]]输出：[null,null,null,null,-3,null,0,-2]解释：MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin();   --&gt; 返回 -3.minStack.pop();minStack.top();      --&gt; 返回 0.minStack.getMin();   --&gt; 返回 -2.</code></pre><p>提示：</p><p>pop、top 和 getMin 操作总是在 非空栈 上调用。</p><p>最初的想法是用两个栈来实现，pop,push和top可用stack自带的pop,push和peek函数来实现，然后每次找最小值时都将一个栈中元素倒豆子一样倒进另一个栈中，此过程中获得最小值，之后再倒回去，但这种方法超时了。</p><h1 id="解法一-1"><a href="#解法一-1" class="headerlink" title="解法一^1"></a>解法一<a href="https://leetcode.wang" target="_blank" rel="noopener">^1</a></h1><p>要实现一个 <code>stack</code>，那么我们还能用 <code>java</code> 自带的 <code>stack</code> 吗？也不用纠结，这道题的关键其实是实现「得到最小值这个功能」，所以为了代码简洁些，我们就直接使用系统自带的 <code>stack</code> 了。</p><p>这道题最直接的解法就是我们可以用两个栈，一个栈去保存正常的入栈出栈的值，另一个栈去存最小值，也就是用栈顶保存当前所有元素的最小值。存最小值的栈的具体操作流程如下：</p><p>将第一个元素入栈。</p><p>新加入的元素如果大于栈顶元素，那么新加入的元素就不处理。</p><p>新加入的元素如果小于等于栈顶元素，那么就将新元素入栈。</p><p>出栈元素不等于栈顶元素，不操作。</p><p>出栈元素等于栈顶元素，那么就将栈顶元素出栈。</p><p>举个例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">入栈 <span class="number">3</span> </span><br><span class="line">|   |    |   |</span><br><span class="line">|   |    |   |</span><br><span class="line">|_3_|    |_3_|</span><br><span class="line">stack  minStack</span><br><span class="line"></span><br><span class="line">入栈 <span class="number">5</span> ， <span class="number">5</span> 大于 minStack 栈顶，不处理</span><br><span class="line">|   |    |   |</span><br><span class="line">| <span class="number">5</span> |    |   |</span><br><span class="line">|_3_|    |_3_|</span><br><span class="line">stack  minStack</span><br><span class="line"></span><br><span class="line">入栈 <span class="number">2</span> ，此时右边的 minStack 栈顶就保存了当前最小值 <span class="number">2</span> </span><br><span class="line">| <span class="number">2</span> |    |   |</span><br><span class="line">| <span class="number">5</span> |    | <span class="number">2</span> |</span><br><span class="line">|_3_|    |_3_|</span><br><span class="line">stack  minStack</span><br><span class="line"></span><br><span class="line">出栈 <span class="number">2</span>，此时右边的 minStack 栈顶就保存了当前最小值 <span class="number">3</span></span><br><span class="line">|   |    |   |</span><br><span class="line">| <span class="number">5</span> |    |   |</span><br><span class="line">|_3_|    |_3_|</span><br><span class="line">stack  minStack</span><br><span class="line"></span><br><span class="line">出栈 <span class="number">5</span>，右边 minStack 不处理</span><br><span class="line">|   |    |   |</span><br><span class="line">|   |    |   |</span><br><span class="line">|_3_|    |_3_|</span><br><span class="line">stack  minStack</span><br><span class="line"></span><br><span class="line">出栈 <span class="number">3</span></span><br><span class="line">|   |    |   |</span><br><span class="line">|   |    |   |</span><br><span class="line">|_ _|    |_ _|</span><br><span class="line">stack  minStack</span><br></pre></td></tr></table></figure><p>代码的话就很好写了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minStack;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line">        <span class="keyword">if</span> (!minStack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> top = minStack.peek();</span><br><span class="line">            <span class="comment">//小于的时候才入栈</span></span><br><span class="line">            <span class="keyword">if</span> (x &lt;= top) &#123;</span><br><span class="line">                minStack.push(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            minStack.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pop = stack.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> top = minStack.peek();</span><br><span class="line">        <span class="comment">//等于的时候再出栈</span></span><br><span class="line">        <span class="comment">//此处不能写作if(minStack.peek() == stack.peek())否则判断不生效</span></span><br><span class="line">        <span class="comment">//因为包装类型间的相等判断应该用equals而非==</span></span><br><span class="line">        <span class="keyword">if</span> (pop == top) &#123;</span><br><span class="line">            minStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我犯了一个错误 </p><p>出栈操作判断时不能写作<code>if(minStack.peek() == stack.peek())</code>否则判断不生效,因为包装类型间的相等判断应该用equals而非==</p><h1 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h1><p>解法一中用了两个栈去实现，那么我们能不能用一个栈去实现呢？</p><p>参考了  <a href="https://leetcode.com/problems/min-stack/discuss/49014/Java-accepted-solution-using-one-stack" target="_blank" rel="noopener">这里</a>。</p><p>解法一中单独用了一个栈去保存所有最小值，那么我们能不能只用一个变量去保存最小值呢？</p><p>再看一下上边的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">入栈 <span class="number">3</span> </span><br><span class="line">|   |   min = <span class="number">3</span></span><br><span class="line">|   |     </span><br><span class="line">|_3_|    </span><br><span class="line">stack   </span><br><span class="line"></span><br><span class="line">入栈 <span class="number">5</span> </span><br><span class="line">|   |   min = <span class="number">3</span></span><br><span class="line">| <span class="number">5</span> |     </span><br><span class="line">|_3_|    </span><br><span class="line">stack  </span><br><span class="line"></span><br><span class="line">入栈 <span class="number">2</span> </span><br><span class="line">| <span class="number">2</span> |   min = <span class="number">2</span>?</span><br><span class="line">| <span class="number">5</span> |     </span><br><span class="line">|_3_|    </span><br><span class="line">stack</span><br></pre></td></tr></table></figure><p>如果只用一个变量就会遇到一个问题，如果把 <code>min</code> 更新为 <code>2</code>，那么之前的最小值 <code>3</code> 就丢失了。</p><p>怎么把 <code>3</code> 保存起来呢？把它在 <code>2</code> 之前压入栈中即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">入栈 <span class="number">2</span> ，同时将之前的 min 值 <span class="number">3</span> 入栈，再把 <span class="number">2</span> 入栈，同时更新 min = <span class="number">2</span></span><br><span class="line">| <span class="number">2</span> |   min = <span class="number">2</span></span><br><span class="line">| <span class="number">3</span> |  </span><br><span class="line">| <span class="number">5</span> |     </span><br><span class="line">|_3_|    </span><br><span class="line">stack  </span><br><span class="line"></span><br><span class="line">入栈 <span class="number">6</span> </span><br><span class="line">| <span class="number">6</span> |  min = <span class="number">2</span></span><br><span class="line">| <span class="number">2</span> |   </span><br><span class="line">| <span class="number">3</span> |  </span><br><span class="line">| <span class="number">5</span> |     </span><br><span class="line">|_3_|    </span><br><span class="line">stack  </span><br><span class="line"></span><br><span class="line">出栈 <span class="number">6</span>     </span><br><span class="line">| <span class="number">2</span> |   min = <span class="number">2</span></span><br><span class="line">| <span class="number">3</span> |  </span><br><span class="line">| <span class="number">5</span> |     </span><br><span class="line">|_3_|    </span><br><span class="line">stack  </span><br><span class="line"></span><br><span class="line">出栈 <span class="number">2</span>     </span><br><span class="line">| <span class="number">2</span> |   min = <span class="number">2</span></span><br><span class="line">| <span class="number">3</span> |  </span><br><span class="line">| <span class="number">5</span> |     </span><br><span class="line">|_3_|    </span><br><span class="line">stack</span><br></pre></td></tr></table></figure><p>上边的最后一个状态，当出栈元素是最小元素我们该如何处理呢？</p><p>我们只需要把 <code>2</code> 出栈，然后再出栈一次，把 <code>3</code> 赋值给 <code>min</code> 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">出栈 <span class="number">2</span>     </span><br><span class="line">|   |  min = <span class="number">3</span>   </span><br><span class="line">| <span class="number">5</span> |   </span><br><span class="line">|_3_|    </span><br><span class="line">stack</span><br></pre></td></tr></table></figure><p>通过上边的方式，我们就只需要一个栈了。当有更小的值来的时候，我们只需要把之前的最小值入栈，当前更小的值再入栈即可。当这个最小值要出栈的时候，下一个值便是之前的最小值了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当前值更小</span></span><br><span class="line">        <span class="keyword">if</span>(x &lt;= min)&#123;   </span><br><span class="line">            <span class="comment">//将之前的最小值保存</span></span><br><span class="line">            stack.push(min);</span><br><span class="line">            <span class="comment">//更新最小值</span></span><br><span class="line">            min=x;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果弹出的值是最小值，那么将下一个元素更新为最小值</span></span><br><span class="line">        <span class="keyword">if</span>(stack.pop() == min) &#123;</span><br><span class="line">            min=stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h1><p>参考 <a href="https://leetcode.com/problems/min-stack/discuss/49031/Share-my-Java-solution-with-ONLY-ONE-stack" target="_blank" rel="noopener">这里</a>，再分享利用一个栈的另一种思路。</p><p>通过解法二的分析，我们关键要解决的问题就是当有新的更小值的时候，之前的最小值该怎么办？</p><p>解法二中通过把之前的最小值入栈解决问题。</p><p>这里的话，用了另一种思路。同样是用一个 <code>min</code> 变量保存最小值。只不过栈里边我们不去保存原来的值，而是去存储入栈的值和最小值的差值。然后得到之前的最小值的话，我们就可以通过 <code>min</code> 值和栈顶元素得到，举个例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">入栈 <span class="number">3</span>，存入 <span class="number">3</span> - <span class="number">3</span> = <span class="number">0</span></span><br><span class="line">|   |   min = <span class="number">3</span></span><br><span class="line">|   |     </span><br><span class="line">|_0_|    </span><br><span class="line">stack   </span><br><span class="line"></span><br><span class="line">入栈 <span class="number">5</span>，存入 <span class="number">5</span> - <span class="number">3</span> = <span class="number">2</span></span><br><span class="line">|   |   min = <span class="number">3</span></span><br><span class="line">| <span class="number">2</span> |     </span><br><span class="line">|_0_|    </span><br><span class="line">stack  </span><br><span class="line"></span><br><span class="line">入栈 <span class="number">2</span>，因为出现了更小的数，所以我们会存入一个负数，这里很关键</span><br><span class="line">也就是存入  <span class="number">2</span> - <span class="number">3</span> = -<span class="number">1</span>, 并且更新 min = <span class="number">2</span> </span><br><span class="line">对于之前的 min 值 <span class="number">3</span>, 我们只需要用更新后的 min - 栈顶元素 -<span class="number">1</span> 就可以得到    </span><br><span class="line">| -<span class="number">1</span>|   min = <span class="number">2</span></span><br><span class="line">| <span class="number">5</span> |     </span><br><span class="line">|_3_|    </span><br><span class="line">stack  </span><br><span class="line"></span><br><span class="line">入栈 <span class="number">6</span>，存入  <span class="number">6</span> - <span class="number">2</span> = <span class="number">4</span></span><br><span class="line">| <span class="number">4</span> |   min = <span class="number">2</span></span><br><span class="line">| -<span class="number">1</span>| </span><br><span class="line">| <span class="number">5</span> |     </span><br><span class="line">|_3_|    </span><br><span class="line">stack  </span><br><span class="line"></span><br><span class="line">出栈，返回的值就是栈顶元素 <span class="number">4</span> 加上 min，就是 <span class="number">6</span></span><br><span class="line">|   |   min = <span class="number">2</span></span><br><span class="line">| -<span class="number">1</span>| </span><br><span class="line">| <span class="number">5</span> |     </span><br><span class="line">|_3_|    </span><br><span class="line">stack  </span><br><span class="line"></span><br><span class="line">出栈，此时栈顶元素是负数，说明之前对 min 值进行了更新。</span><br><span class="line">入栈元素 - min = 栈顶元素，入栈元素其实就是当前的 min 值 <span class="number">2</span></span><br><span class="line">所以更新前的 min 就等于入栈元素 <span class="number">2</span> - 栈顶元素(-<span class="number">1</span>) = <span class="number">3</span></span><br><span class="line">|   | min = <span class="number">3</span></span><br><span class="line">| <span class="number">5</span> |     </span><br><span class="line">|_3_|    </span><br><span class="line">stack</span><br></pre></td></tr></table></figure><p>再理一下上边的思路，我们每次存入的是 <code>原来值 - 当前最小值</code>。</p><p>当原来值大于等于当前最小值的时候，我们存入的肯定就是非负数，所以出栈的时候就是 <code>栈中的值 + 当前最小值</code> 。</p><p>当原来值小于当前最小值的时候，我们存入的肯定就是负值，此时的值我们不入栈，用 <code>min</code> 保存起来，同时将差值入栈。</p><p>当后续如果出栈元素是负数的时候，那么要出栈的元素其实就是 <code>min</code>。此外之前的 <code>min</code> 值，我们可以通过栈顶的值和当前 <code>min</code> 值进行还原，就是用 <code>min</code> 减去栈顶元素即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> min;</span><br><span class="line">Stack&lt;Long&gt; stack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">min = x;</span><br><span class="line">stack.push(x - min);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">stack.push(x - min);</span><br><span class="line"><span class="keyword">if</span> (x &lt; min)&#123;</span><br><span class="line">min = x; <span class="comment">// 更新最小值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (stack.isEmpty())</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> pop = stack.pop();</span><br><span class="line"></span><br><span class="line"><span class="comment">//弹出的是负值，要更新 min</span></span><br><span class="line"><span class="keyword">if</span> (pop &lt; <span class="number">0</span>) &#123;</span><br><span class="line">min = min - pop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> top = stack.peek();</span><br><span class="line"><span class="comment">//负数的话，出栈的值保存在 min 中</span></span><br><span class="line"><span class="keyword">if</span> (top &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>) (min);</span><br><span class="line">        <span class="comment">//出栈元素加上最小值即可</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>) (top + min);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>) min;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上边的解法的一个缺点就是由于我们保存的是差值，所以可能造成溢出，所以我们用了数据范围更大的 <code>long</code> 类型。</p><p>此外相对于解法二，最小值需要更新的时候，我们并没有将之前的最小值存起来，我们每次都是通过当前最小值和栈顶元素推出了之前的最小值，所以会省一些空间。</p><h1 id="解法四"><a href="#解法四" class="headerlink" title="解法四"></a>解法四</h1><p>再分享一个有趣的解法，参考 <a href="https://leetcode.com/problems/min-stack/discuss/49217/6ms-Java-Solution-using-Linked-List.-Clean-self-explanatory-and-efficient." target="_blank" rel="noopener">这里</a> 。</p><p>回到最初的疑虑，我们要不要用 <code>java</code> 提供的 <code>stack</code> 。如果不用的话，可以怎么做的？</p><p>直接用一个链表即可实现栈的基本功能，那么最小值该怎么得到呢？我们可以在 <code>Node</code> 节点中增加一个 <code>min</code> 字段，这样的话每次加入一个节点的时候，我们同时只要确定它的 <code>min</code> 值即可。</p><p>代码很简洁，我直接把代码贴过来吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">int</span> min;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> x, <span class="keyword">int</span> min)&#123;</span><br><span class="line">            <span class="keyword">this</span>.value=x;</span><br><span class="line">            <span class="keyword">this</span>.min=min;</span><br><span class="line">            next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Node head;</span><br><span class="line">    <span class="comment">//每次加入的节点放到头部</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span>==head)&#123;</span><br><span class="line">            head = <span class="keyword">new</span> Node(x,x);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//当前值和之前头结点的最小值较小的做为当前的 min</span></span><br><span class="line">            Node n = <span class="keyword">new</span> Node(x, Math.min(x,head.min));</span><br><span class="line">            n.next=head;</span><br><span class="line">            head=n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head!=<span class="keyword">null</span>)</span><br><span class="line">            head =head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head!=<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head.value;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span>!=head)</span><br><span class="line">            <span class="keyword">return</span> head.min;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然题目比较简单，但解法二和解法三真的让人耳目一新，一个通过存储，一个通过差值解决了「保存之前值」的问题，思路很值得借鉴。解法四更像降维打击一样，回到改底层数据结构，从而更加简洁的解决了问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年7月" scheme="http://yoursite.com/categories/2020%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
      <category term="Design" scheme="http://yoursite.com/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>240. 搜索二维矩阵II</title>
    <link href="http://yoursite.com/2020/06/30/240.%20%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5II/"/>
    <id>http://yoursite.com/2020/06/30/240. 搜索二维矩阵II/</id>
    <published>2020-06-30T14:52:12.000Z</published>
    <updated>2020-06-30T16:10:49.197Z</updated>
    
    <content type="html"><![CDATA[<p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。</p><a id="more"></a><p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：</p><p>每行的元素从左到右升序排列。<br>每列的元素从上到下升序排列。<br>示例:</p><pre><code>现有矩阵 matrix 如下：[  [1,   4,  7, 11, 15],  [2,   5,  8, 12, 19],  [3,   6,  9, 16, 22],  [10, 13, 14, 17, 24],  [18, 21, 23, 26, 30]]给定 target = 5，返回 true。给定 target = 20，返回 false。</code></pre><p>这道题出的不好，因为可以用74.搜索二维矩阵题一样的方法从左下角搜索来解决。</p><h1 id="从左下角开始搜索"><a href="#从左下角开始搜索" class="headerlink" title="从左下角开始搜索"></a>从左下角开始搜索</h1><p>因为矩阵的行和列是排序的（分别从左到右和从上到下），所以在查看任何特定值时，我们可以修剪O(m)或O(n)元素。</p><p>算法：</p><p>首先，我们初始化一个指向矩阵左下角的 (row，col) 指针。然后，直到找到目标并返回 true（或者指针指向矩阵维度之外的 (row，col) 为止，我们执行以下操作：</p><p>如果当前指向的值大于目标值，则可以 “向上” 移动一行。 </p><p>否则，如果当前指向的值小于目标值，则可以移动一列。不难理解为什么这样做永远不会删减正确的答案；因为行是从左到右排序的，所以我们知道当前值右侧的每个值都较大。 </p><p>因此，如果当前值已经大于目标值，我们知道它右边的每个值会比较大。也可以对列进行非常类似的论证，因此这种搜索方式将始终在矩阵中找到目标（如果存在）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean searchMatrix(int[][] matrix, int target) &#123;</span><br><span class="line">//        二维数组为空，要检查三个部分:</span><br><span class="line">//        一是数组首地址是否为空</span><br><span class="line">//        二是是否为&#123;&#125;，也就是array.length==0的情况</span><br><span class="line">//        三是&#123;&#123;&#125;&#125;，这时array.length=1，但是array[0].length==0。满足任意一个条件就可以返回false了。</span><br><span class="line">        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return false;</span><br><span class="line">        int row = matrix.length;</span><br><span class="line">        int col = matrix[0].length;</span><br><span class="line">        int rowindex = row - 1;</span><br><span class="line">        int colindex = 0;</span><br><span class="line"></span><br><span class="line">        while (colindex &lt; col &amp;&amp; rowindex &gt;= 0) &#123;</span><br><span class="line">            if (target == matrix[rowindex][colindex]) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else if (target &gt; matrix[rowindex][colindex]) &#123;</span><br><span class="line">                colindex++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                rowindex--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其它方法见<a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/solution/sou-suo-er-wei-ju-zhen-ii-by-leetcode-2/" target="_blank" rel="noopener">^1</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="Divide and Conquer" scheme="http://yoursite.com/tags/Divide-and-Conquer/"/>
    
  </entry>
  
  <entry>
    <title>74. 搜索二维矩阵</title>
    <link href="http://yoursite.com/2020/06/30/74.%20%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/"/>
    <id>http://yoursite.com/2020/06/30/74. 搜索二维矩阵/</id>
    <published>2020-06-30T14:52:12.000Z</published>
    <updated>2020-06-30T16:11:22.253Z</updated>
    
    <content type="html"><![CDATA[<p>编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。</p><a id="more"></a><p>该矩阵具有如下特性：</p><p>每行中的整数从左到右按升序排列。<br>每行的第一个整数大于前一行的最后一个整数。<br>示例 1:</p><pre><code>输入:matrix = [  [1,   3,  5,  7],  [10, 11, 16, 20],  [23, 30, 34, 50]]</code></pre><p>target = 3<br>输出: true<br>示例 2:</p><pre><code>输入:matrix = [  [1,   3,  5,  7],  [10, 11, 16, 20],  [23, 30, 34, 50]]target = 13输出: false</code></pre><h1 id="从左下角开始搜索"><a href="#从左下角开始搜索" class="headerlink" title="从左下角开始搜索"></a>从左下角开始搜索</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean searchMatrix(int[][] matrix, int target) &#123;</span><br><span class="line">//        二维数组为空，要检查三个部分:</span><br><span class="line">//        一是数组首地址是否为空</span><br><span class="line">//        二是是否为&#123;&#125;，也就是array.length==0的情况</span><br><span class="line">//        三是&#123;&#123;&#125;&#125;，这时array.length=1，但是array[0].length==0。满足任意一个条件就可以返回false了。</span><br><span class="line">        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return false;</span><br><span class="line">        int row = matrix.length;</span><br><span class="line">        int col = matrix[0].length;</span><br><span class="line">        int rowindex = row - 1;</span><br><span class="line">        int colindex = 0;</span><br><span class="line"></span><br><span class="line">        while (colindex &lt; col &amp;&amp; rowindex &gt;= 0) &#123;</span><br><span class="line">            if (target == matrix[rowindex][colindex]) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else if (target &gt; matrix[rowindex][colindex]) &#123;</span><br><span class="line">                colindex++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                rowindex--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法：二分查找"><a href="#方法：二分查找" class="headerlink" title="方法：二分查找"></a>方法：二分查找</h1><p><strong>直觉</strong></p><p>注意到输入的 <code>m x n</code> 矩阵可以视为长度为 <code>m x n</code>的有序数组。</p><p> <a href="https://pic.leetcode-cn.com/d9b47b40a4de17b0c56446b0a4935a5042490ea1d92a6f4c529c2aaa0095c189-287711dcb87bd4d4681fa117f792d1baaaa7ce3e2c65d6a4f6439c0cbbb0345e-image.png" target="_blank" rel="noopener">二分查找</a></p><p>由于该 <em>虚</em> 数组的序号可以由下式方便地转化为原矩阵中的行和列 (<em>我们当然不会真的创建一个新数组</em>) ，该有序数组非常适合二分查找。</p><blockquote><p><code>row = idx // n</code> ， <code>col = idx % n</code>。</p></blockquote><p><strong>算法</strong></p><p>这是一个标准二分查找算法 : </p><ul><li><p>初始化左右序号<br><code>left = 0</code> 和 <code>right = m x n - 1</code>。</p></li><li><p>While <code>left &lt; right</code> :</p><ul><li><p>选取虚数组最中间的序号作为中间序号: <code>pivot_idx = (left + right) / 2</code>。</p></li><li><p>该序号对应于原矩阵中的 <code>row = pivot_idx // n</code>行 <code>col = pivot_idx % n</code> 列, 由此可以拿到中间元素<code>pivot_element</code>。该元素将虚数组分为两部分。</p></li><li><p>比较 <code>pivot_element</code> 与 <code>target</code> 以确定在哪一部分进行进一步查找。</p></li></ul></li></ul><p><strong>实现</strong></p><figure class="highlight java"><figcaption><span>[solution1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分查找</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = m * n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> pivotIdx, pivotElement;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">      pivotIdx = (left + right) / <span class="number">2</span>;</span><br><span class="line">      pivotElement = matrix[pivotIdx / n][pivotIdx % n];</span><br><span class="line">      <span class="keyword">if</span> (target == pivotElement) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; pivotElement) right = pivotIdx - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> left = pivotIdx + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[solution1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span><span class="params">(self, matrix: List[List[int]], target: int)</span> -&gt; bool:</span></span><br><span class="line">        m = len(matrix)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        n = len(matrix[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#二分查找</span></span><br><span class="line">        left, right = <span class="number">0</span>, m * n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">                pivot_idx = (left + right) // <span class="number">2</span></span><br><span class="line">                pivot_element = matrix[pivot_idx // n][pivot_idx % n]</span><br><span class="line">                <span class="keyword">if</span> target == pivot_element:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> target &lt; pivot_element:</span><br><span class="line">                        right = pivot_idx - <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        left = pivot_idx + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>[solution1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分查找</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = m * n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> pivotIdx, pivotElement;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">      pivotIdx = (left + right) / <span class="number">2</span>;</span><br><span class="line">      pivotElement = matrix[pivotIdx / n][pivotIdx % n];</span><br><span class="line">      <span class="keyword">if</span> (target == pivotElement) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; pivotElement) right = pivotIdx - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> left = pivotIdx + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 : 由于是标准的二分查找，时间复杂度为O(log(mn)) 。</li><li>空间复杂度 : <em>O(1)</em>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>334. 递增的三元子序列</title>
    <link href="http://yoursite.com/2020/06/30/334.%E9%80%92%E5%A2%9E%E7%9A%84%E4%B8%89%E5%85%83%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2020/06/30/334.递增的三元子序列/</id>
    <published>2020-06-30T12:52:12.000Z</published>
    <updated>2020-06-30T13:09:57.486Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个未排序的数组，判断这个数组中是否存在长度为 3 的递增子序列。</p><a id="more"></a><p>数学表达式如下:</p><p>如果存在这样的 i, j, k,  且满足 0 ≤ i &lt; j &lt; k ≤ n-1，<br>使得 arr[i] &lt; arr[j] &lt; arr[k] ，返回 true ; 否则返回 false 。<br>说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1) 。</p><p>示例 1:</p><pre><code>输入: [1,2,3,4,5]输出: true</code></pre><p>示例 2:</p><pre><code>输入: [5,4,3,2,1]输出: false</code></pre><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ol><li>第一种方法采用了双指针的思想，针对这个题的三元子序列，如果是四元或更高元则不通用。主要思路是维护当前访问数组的最小值和最小值右侧大于最小值的最小的一个。具体步骤顺序遍历数组，首先确定当前已访问的数组的最小值，即如果小于等于min值的话更新min值，如果大于min，判断是否小于等于max值，如果是，更新max值。如果大于max值，则说明有三元子序列。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">increasingTriplet</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE, max = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num &lt;= min)&#123;</span><br><span class="line">                min = num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num &lt;= max)&#123;</span><br><span class="line">                max = num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>第二种方法是动态规划的思想，主要思路是维护和更新以i为结尾的三元子序列的最长递增长度。转移方程为dp[i] = max{dp[i], dp[j] + 1} (0&lt;=j&lt;i).</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">increasingTriplet</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个未排序的数组，判断这个数组中是否存在长度为 3 的递增子序列。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>350. 两个数组的交集II</title>
    <link href="http://yoursite.com/2020/06/29/350.%20%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86II/"/>
    <id>http://yoursite.com/2020/06/29/350. 两个数组的交集II/</id>
    <published>2020-06-29T15:52:12.000Z</published>
    <updated>2020-06-30T13:09:41.642Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个数组，编写一个函数来计算它们的交集。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: nums1 = [1,2,2,1], nums2 = [2,2]输出: [2,2]</code></pre><p>示例 2:</p><pre><code>输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [4,9]</code></pre><p>说明：</p><pre><code>输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。我们可以不考虑输出结果的顺序。</code></pre><p>进阶:</p><pre><code>如果给定的数组已经排好序呢？你将如何优化你的算法？如果 nums1 的大小比 nums2 小很多，哪种方法更优？如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？</code></pre><h1 id="方法一：哈希映射"><a href="#方法一：哈希映射" class="headerlink" title="方法一：哈希映射"></a>方法一：哈希映射</h1><p>前面的问题 <a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/" target="_blank" rel="noopener">349. 两个数组的交集</a>，我们使用 <code>set</code> 来实现线性时间复杂度。在这里，我们需要使用 <code>HashMap</code> 来跟踪每个数字出现的次数。</p><p>我们先在 <code>HashMap</code> 记录一个数组中的存在的数字和对应出现的次数。然后，我们遍历第二个数组，检查数字在 <code>HashMap</code> 中是否存在，如果存在且计数为正，则将该数字添加到答案并减少 <code>HashMap</code> 中的计数。<br> <a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMzUwLzM1MF9hcHByb2FjaDEtdjIucG5n?x-oss-process=image/format,png" target="_blank" rel="noopener">哈希映射</a><br>检查数组的大小并对较小的数组进行哈希映射是一个小细节，当其中一个数组较大时，会减少内存的使用。</p><p><strong>算法：</strong></p><ul><li>如果 <code>nums1</code> 元素个数大于 <code>nums2</code>，则交换数组元素。</li><li>对于 <code>nums1</code> 的每个元素，添加到 <code>HashMap m</code> 中，如果元素已经存在则增加对应的计数。</li><li>初始化 <code>k = 0</code>，记录当前交集元素个数。</li><li>遍历数组 <code>nums2</code>：<ul><li>检查元素在 <code>m</code> 是否存在，若存在且计数为正：<ul><li>将元素拷贝到 <code>nums1[k]</code>，且 <code>k++</code>。</li><li>减少 <code>m</code> 中对应元素的计数。</li></ul></li></ul></li><li>返回 <code>nums1</code> 前 <code>k</code> 个元素。</li></ul><figure class="highlight c++"><figcaption><span>[solution1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersect(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums1.size() &gt; nums2.size()) &#123;</span><br><span class="line">        <span class="keyword">return</span> intersect(nums2, nums1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n : nums1) &#123;</span><br><span class="line">        ++m[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n : nums2) &#123;</span><br><span class="line">        <span class="keyword">auto</span> it = m.find(n);</span><br><span class="line">        <span class="keyword">if</span> (it != end(m) &amp;&amp; --it-&gt;second &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[k++] = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vector</span>(begin(nums1), begin(nums1) + k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums1.length &gt; nums2.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> intersect(nums2, nums1);</span><br><span class="line">    &#125;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : nums1) &#123;</span><br><span class="line">        m.put(n, m.getOrDefault(n, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : nums2) &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = m.getOrDefault(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[k++] = n;</span><br><span class="line">            m.put(n, cnt - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOfRange(nums1, <span class="number">0</span>, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n+m) 。其中 <em>n</em>，<em>m</em> 分别代表了数组的大小。</li><li>空间复杂度：O(min(n,m)) ，我们对较小的数组进行哈希映射使用的空间。</li></ul><h1 id="方法二：排序"><a href="#方法二：排序" class="headerlink" title="方法二：排序"></a>方法二：排序</h1><p>当输入数据是有序的，推荐使用此方法。在这里，我们对两个数组进行排序，并且使用两个指针在一次扫面找出公共的数字。<br> <a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMzUwLzM1MF9hcHByb2FjaDItdjIucG5n?x-oss-process=image/format,png" target="_blank" rel="noopener">排序</a></p><p><strong>算法：</strong></p><ul><li>对数组 <code>nums1</code> 和 <code>nums2</code> 排序。</li><li>初始化指针 <code>i</code>，<code>j</code> 和 <code>k</code> 为 <code>0</code>。</li><li>指针 <code>i</code> 指向 <code>nums1</code>，指针 <code>j</code> 指向 <code>nums2</code>：<ul><li>如果 <code>nums1[i] &lt; nums2[j]</code>，则 <code>i++</code>。 </li><li>如果 <code>nums1[i] &gt; nums2[j]</code>，则 <code>j++</code>。 </li><li>如果 <code>nums1[i] == nums2[j]</code>，将元素拷贝到 <code>nums1[k]</code>，且 <code>i++</code>，<code>j++</code>，<code>k++</code>。</li></ul></li><li>返回数组 <code>nums1</code> 前 <code>k</code> 个元素。</li></ul><figure class="highlight c++"><figcaption><span>[solution2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersect(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">    sort(begin(nums1), end(nums1));</span><br><span class="line">    sort(begin(nums2), end(nums2));</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; nums1.size() &amp;&amp; j &lt; nums2.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[i] &lt; nums2[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums1[k++] = nums1[i++];</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(begin(nums1), begin(nums1) + k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[solution2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    Arrays.sort(nums1);</span><br><span class="line">    Arrays.sort(nums2);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; nums1.length &amp;&amp; j &lt; nums2.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[i] &lt; nums2[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums1[k++] = nums1[i++];</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOfRange(nums1, <span class="number">0</span>, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="public-static-int-copyOfRange-int-original-int-from-int-to"><a href="#public-static-int-copyOfRange-int-original-int-from-int-to" class="headerlink" title="public static int[] copyOfRange(int[] original, int from, int to)"></a>public static int[] copyOfRange(int[] original, int from, int to)</h2><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(nlogn+mlogm 。其中 <em>n</em>，<em>m</em> 分别代表了数组的大小。我们对数组进行了排序然后进行了线性扫描。</li><li>空间复杂度：<em>O(1)</em>，我们忽略存储答案所使用的空间，因为它对算法本身并不重要。</li></ul><h1 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h1><p><strong>算法：</strong></p><p>这类似于方法 2。我们不使用两个指针进行迭代，而是使用内置函数来查找公共元素。在 C++ 中，我们可以使用 <code>set_intersection</code> 来排序数组（或 <code>multisets</code>）。</p><p>在 Java 中的 <code>retainAll</code> 方法并不关心一个元素在另一个集合中出现的次数。这就有点尴尬了，我一开始想到的就是用内置函数但遇到用例<code>[1,2]，[1,2]</code>就错了，怎么写也没弄出来，所以Java此法暂不可行。</p><figure class="highlight c++"><figcaption><span>[solution3-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersect(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">    sort(begin(nums1), end(nums1));</span><br><span class="line">    sort(begin(nums2), end(nums2));</span><br><span class="line">    nums1.erase(set_intersection(begin(nums1), end(nums1), </span><br><span class="line">        begin(nums2), end(nums2), begin(nums1)), end(nums1));</span><br><span class="line">    <span class="keyword">return</span> nums1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时空复杂度：与方法二相同。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个数组，编写一个函数来计算它们的交集。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>349. 两个数组的交集</title>
    <link href="http://yoursite.com/2020/06/29/349.%20%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/"/>
    <id>http://yoursite.com/2020/06/29/349. 两个数组的交集/</id>
    <published>2020-06-29T12:42:12.000Z</published>
    <updated>2020-06-29T15:51:47.249Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个数组，编写一个函数来计算它们的交集。</p><a id="more"></a><p>示例 1：</p><pre><code>输入：nums1 = [1,2,2,1], nums2 = [2,2]输出：[2]</code></pre><p>示例 2：</p><pre><code>输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出：[9,4]</code></pre><p>说明：</p><pre><code>输出结果中的每个元素一定是唯一的。我们可以不考虑输出结果的顺序。</code></pre><h4 id="方法一：两个set"><a href="#方法一：两个set" class="headerlink" title="方法一：两个set"></a>方法一：两个set</h4><p>最直观的方法是迭代并检查第一个数组 <code>nums1</code> 中的每个值是否也存在于 <code>nums2</code> 中。如果存在，则将值添加到输出。这种方法的时间复杂度为 O(n*m)  ，其中 <code>n</code> 和 <code>m</code> 分别为数组 <code>nums1</code> 和 <code>nums2</code> 的长度。 </p><p>为了在线性时间内解决这个问题，我们使用集合 <code>set</code> 这一数据结构，该结构可以提供平均时间复杂度为 <em>O(1)</em> 的 <code>in/contains</code> 操作（用于测试某一元素是否为该集合的成员）。</p><p>本解法先将两个数组都转换为集合，然后迭代较小的集合，检查其中的每个元素是否同样存在于较大的集合中。平均情况下，这种方法的时间复杂度为 <em>O(n+m)</em> 。 </p><p><strong>实现：</strong></p><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_intersection</span><span class="params">(self, set1, set2)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> [x <span class="keyword">for</span> x <span class="keyword">in</span> set1 <span class="keyword">if</span> x <span class="keyword">in</span> set2]</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersection</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span>  </span><br><span class="line">        set1 = set(nums1)</span><br><span class="line">        set2 = set(nums2)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> len(set1) &lt; len(set2):</span><br><span class="line">            <span class="keyword">return</span> self.set_intersection(set1, set2)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.set_intersection(set2, set1)</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] set_intersection(HashSet&lt;Integer&gt; set1, HashSet&lt;Integer&gt; set2) &#123;</span><br><span class="line">    <span class="keyword">int</span> [] output = <span class="keyword">new</span> <span class="keyword">int</span>[set1.size()];</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Integer s : set1)</span><br><span class="line">      <span class="keyword">if</span> (set2.contains(s)) output[idx++] = s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(output, idx);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    HashSet&lt;Integer&gt; set1 = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Integer n : nums1) set1.add(n);</span><br><span class="line">    HashSet&lt;Integer&gt; set2 = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Integer n : nums2) set2.add(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (set1.size() &lt; set2.size()) <span class="keyword">return</span> set_intersection(set1, set2);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> set_intersection(set2, set1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(m+n)*，其中 <code>n</code> 和 <code>m</code> 是数组的长度。将 <code>nums1</code> 转换为集合需要 *O(n)</em> 的时间，类似地，将 <code>nums2</code> 转换为集合需要 <em>O(m)</em> 的时间。而在平均情况下，集合的 <code>in/contains</code> 操作只需要 <em>O(1)</em> 的时间。 </li><li>空间复杂度：<em>O(m+n)</em>，最坏的情况是数组中的所有元素都不同。 </li></ul><h3 id="Arrays-copyOf"><a href="#Arrays-copyOf" class="headerlink" title="Arrays.copyOf()"></a>Arrays.copyOf()</h3><p>original - 要复制的数组 </p><p>newLength - 要返回的副本的长度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*original - 要复制的数组 </span><br><span class="line">*newLength - 要返回的副本的长度</span><br><span class="line">*/</span><br><span class="line">public static int[] copyOf(int[] original, int newLength) &#123;</span><br><span class="line">        int[] copy = new int[newLength];</span><br><span class="line">        System.arraycopy(original, 0, copy, 0,</span><br><span class="line">                         Math.min(original.length, newLength));</span><br><span class="line">        return copy;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="方法二：内置函数"><a href="#方法二：内置函数" class="headerlink" title="方法二：内置函数"></a>方法二：内置函数</h4><p>如果使用内置函数：那么平均情况下，时间复杂度为 <em>O(n+m)</em> ；而最坏的情况下，时间复杂度是O(n*m)  。</p><p>Python 提供了可用于求交集的 <code>&amp;</code> 运算符，而 Java 提供了 <code>retainAll()</code>  函数。</p><p><strong>实现:</strong></p><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersection</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span>  </span><br><span class="line">        set1 = set(nums1)</span><br><span class="line">        set2 = set(nums2)</span><br><span class="line">        <span class="keyword">return</span> list(set2 &amp; set1)</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    HashSet&lt;Integer&gt; set1 = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Integer n : nums1) set1.add(n);</span><br><span class="line">    HashSet&lt;Integer&gt; set2 = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Integer n : nums2) set2.add(n);</span><br><span class="line"></span><br><span class="line">    set1.retainAll(set2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> [] output = <span class="keyword">new</span> <span class="keyword">int</span>[set1.size()];</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s : set1) output[idx++] = s;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：一般情况下是 <em>O(m+n)</em>，最坏情况下是 O(m*n)</li><li>空间复杂度：最坏的情况是 <em>O(m+n)</em>，数组中的所有元素都不同。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个数组，编写一个函数来计算它们的交集。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>384. 打乱数组</title>
    <link href="http://yoursite.com/2020/06/29/384.%20%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2020/06/29/384. 打乱数组/</id>
    <published>2020-06-29T10:02:12.000Z</published>
    <updated>2020-06-29T12:41:22.009Z</updated>
    
    <content type="html"><![CDATA[<p>打乱一个没有重复元素的数组。</p><a id="more"></a><p>示例:</p><pre><code>// 以数字集合 1, 2 和 3 初始化数组。int[] nums = {1,2,3};Solution solution = new Solution(nums);// 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。solution.shuffle();// 重设数组到它的初始状态[1,2,3]。solution.reset();// 随机返回数组[1,2,3]打乱后的结果。solution.shuffle();</code></pre><h1 id="绪章-1"><a href="#绪章-1" class="headerlink" title="绪章^1"></a>绪章<a href="https://leetcode-cn.com/problems/shuffle-an-array/solution/da-luan-shu-zu-by-leetcode/" target="_blank" rel="noopener">^1</a></h1><p>对于洗牌问题，Fisher-Yates 洗牌算法即是通俗解法，同时也是渐进最优的解法。</p><p>在我们开始之前需要了解一些关于随机化的知识 - 下面介绍的两个方法都假设编程语言中提供的伪随机数生成器是足够随机的。我们给出的示例代码也都采用了最简单的方法来得到伪随机数，但为了让数组的每个排列出现的可能性尽可能相等，还是有一些其他东西需要注意的。例如，一个长度为 <em>n</em> 的数组有 <em>n!</em> 个不同的排列组合。因此，为了能将所有的排列在整数空间编码，我们需要lg(n!) 比特，这是默认的伪随机数不能保证的。</p><h1 id="方法一：-暴力-【通过】"><a href="#方法一：-暴力-【通过】" class="headerlink" title="方法一： 暴力 【通过】"></a>方法一： 暴力 【通过】</h1><p><strong>思路</strong></p><p>假设我们把每个数都放在一个 ”帽子“ 里面，然后我们从帽子里面把它们一个个摸出来，摸出来的数按顺序放入数组，这个数组正好就是我们要的洗牌后的数组。</p><p><strong>算法</strong></p><p>暴力算法简单的来说就是把每个数放在一个 ”帽子“ 里面，每次从 ”帽子“ 里面随机摸一个数出来，直到 “帽子” 为空。下面是具体操作，首先我们把数组 <code>array</code> 复制一份给数组 <code>aux</code>，之后每次随机从 <code>aux</code> 中取一个数，为了防止数被重复取出，每次取完就把这个数从 <code>aux</code> 中移除。<code>重置</code> 的实现方式很简单，只需把 <code>array</code> 恢复称最开始的状态就可以了。 </p><p>这个算法的正确性在于，每次 <code>for</code> 循环中，任何一个元素都会以等可能的概率被选中。为了证明这一点，我们可以算出来，一个特定的元素 <em>e</em> 在第 <em>k</em> 轮被选中的概率为</p><p><em>P</em>(<em>e</em> 在第 <em>k</em> 轮被选中) ·  <em>P</em>(<em>e</em> 在前 <em>k</em> 轮不被选中)。</p><p>假设洗牌的数组有 <em>n</em> 个元素，这个概率公式见<a href="https://leetcode-cn.com/problems/shuffle-an-array/solution/da-luan-shu-zu-by-leetcode/" target="_blank" rel="noopener">^1</a></p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] original;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">getArrayCopy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; asList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            asList.add(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> asList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        array = nums;</span><br><span class="line">        original = nums.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reset() &#123;</span><br><span class="line">        array = original;</span><br><span class="line">        original = original.clone();</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] shuffle() &#123;</span><br><span class="line">        List&lt;Integer&gt; aux = getArrayCopy();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> removeIdx = rand.nextInt(aux.size());</span><br><span class="line">            array[i] = aux.get(removeIdx);</span><br><span class="line">            aux.remove(removeIdx);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度： <em>O(n^2)</em><br>乘方时间复杂度来自于 <code>list.remove</code>（<code>list.pop</code>）。每次操作都是线性时间的，总共发生 <em>n</em> 次。</p></li><li><p>空间复杂度： <em>O(n)</em><br>因为需要实现 <code>重置</code> 方法，需要额外的空间把原始数组另存一份，在重置的时候用来恢复原始状态。</p></li></ul><h4 id="方法二：-Fisher-Yates-洗牌算法-【通过】"><a href="#方法二：-Fisher-Yates-洗牌算法-【通过】" class="headerlink" title="方法二： Fisher-Yates 洗牌算法 【通过】"></a>方法二： Fisher-Yates 洗牌算法 【通过】</h4><p><strong>思路</strong></p><p>我们可以用一个简单的技巧来降低之前算法的时间复杂度和空间复杂度，那就是让数组中的元素互相交换，这样就可以避免掉每次迭代中用于修改列表的时间了。</p><p><strong>算法</strong></p><p>Fisher-Yates 洗牌算法跟暴力算法很像。在每次迭代中，生成一个范围在当前下标到数组末尾元素下标之间的随机整数。接下来，将当前元素和随机选出的下标所指的元素互相交换 - 这一步模拟了每次从 “帽子” 里面摸一个元素的过程，其中选取下标范围的依据在于每个被摸出的元素都不可能再被摸出来了。此外还有一个需要注意的细节，当前元素是可以和它本身互相交换的 - 否则生成最后的排列组合的概率就不对了。为了更清楚地理解这一过程，可以看下面这些动画：</p><p>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates1.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates2.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates3.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates4.png" target="_blank" rel="noopener">1000</a></p><p>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates5.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates6.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates7.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates8.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates9.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates10.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates11.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates12.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates13.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates14.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates15.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates16.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates17.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates18.png" target="_blank" rel="noopener">1000</a> </p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] original;</span><br><span class="line"></span><br><span class="line">    Random rand = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">randRange</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rand.nextInt(max - min) + min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swapAt</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        array = nums;</span><br><span class="line">        original = nums.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reset() &#123;</span><br><span class="line">        array = original;</span><br><span class="line">        original = original.clone();</span><br><span class="line">        <span class="keyword">return</span> original;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] shuffle() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            swapAt(i, randRange(i, array.length));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度 ： <em>O(n)</em><br>Fisher-Yates 洗牌算法时间复杂度是线性的，因为算法中生成随机序列，交换两个元素这两种操作都是常数时间复杂度的。</p></li><li><p>空间复杂度： <em>O(n)</em><br>因为要实现 <code>重置</code> 功能，原始数组必须得保存一份，因此空间复杂度并没有优化。</p></li></ul><h2 id="Random-nextInt-方法，随机产生某个范围内的整数"><a href="#Random-nextInt-方法，随机产生某个范围内的整数" class="headerlink" title="Random.nextInt()方法，随机产生某个范围内的整数"></a>Random.nextInt()方法，随机产生某个范围内的整数</h2><pre><code>int nextInt()            //随机返回一个int型整数int nextInt(int num)         //随机返回一个值在[0,num)的int类型的整数,包括0不包括num</code></pre><p>nextInt能接受一个整数作为它所产生的随机整数的上限,下限为零，若要达到非零下限的效果，必须把上限减去下限的结果传给 nextInt( )，然后把下限加入 nextInt( ) 返回的整数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;打乱一个没有重复元素的数组。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>283. 移动零</title>
    <link href="http://yoursite.com/2020/06/29/283.%20%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
    <id>http://yoursite.com/2020/06/29/283. 移动零/</id>
    <published>2020-06-29T09:49:12.000Z</published>
    <updated>2020-06-29T10:00:39.219Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><a id="more"></a><p>示例:</p><pre><code>输入: [0,1,0,3,12]输出: [1,3,12,0,0]</code></pre><p>说明:</p><p>必须在原数组上操作，不能拷贝额外的数组。<br>尽量减少操作次数。</p><p>我首先想到的解法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void moveZeroes(int[] nums) &#123;</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (nums[i] == 0) &#123;</span><br><span class="line">                swap(nums,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void swap(int[] nums, int zeroindex) &#123;</span><br><span class="line">        int i=zeroindex;</span><br><span class="line">        while (i &lt; nums.length) &#123;</span><br><span class="line">            if (nums[i] == 0) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                nums[zeroindex] = nums[i];</span><br><span class="line">                nums[i]=0;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">解答成功:</span><br><span class="line">执行耗时:5 ms,击败了12.67% 的Java用户</span><br><span class="line">内存消耗:40.4 MB,击败了5.62% 的Java用户</span><br></pre></td></tr></table></figure><p>这种方法效率较低，有没有更高效的方法呢？</p><h1 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h1><ol><li>定义一个非零的指针 <code>j=0</code>，循环遍历数组用指针<code>j</code>记录非零值<code>nums[j] = num[i]</code>;</li><li>判断两个指针<code>i</code>与<code>j</code>是否相等，这里两个指针初始值都为0，<code>j</code>指针只有在非零的情况下会<code>j++</code>；</li><li>因此可以判断<code>j</code>指针对应的值都为非零的数据，且保存原有顺序；</li><li>所以，原有数组继续遍历情况下，<code>nums[i]</code>都为0。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void moveZeroes(int[] nums) &#123;</span><br><span class="line">        int j = 0;</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (nums[i] != 0) &#123;</span><br><span class="line">                nums[j] = nums[i];</span><br><span class="line">                if( i != j)&#123;</span><br><span class="line">                    nums[i] = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">            解答成功:</span><br><span class="line">执行耗时:0 ms,击败了100.00% 的Java用户</span><br><span class="line">内存消耗:39.6 MB,击败了5.62% 的Java用户</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>Java之TreeSet类</title>
    <link href="http://yoursite.com/2020/06/29/Java%E4%B9%8BTreeSet%E7%B1%BB/"/>
    <id>http://yoursite.com/2020/06/29/Java之TreeSet类/</id>
    <published>2020-06-29T08:21:12.000Z</published>
    <updated>2020-06-29T09:09:17.746Z</updated>
    
    <content type="html"><![CDATA[<p>java.util.TreeSet 类实现Set接口。</p><a id="more"></a><p>以下是关于TreeSet的要点<a href="http://gitbook.net/java/util/java_util_treeset.html" target="_blank" rel="noopener">^1</a>：</p><ul><li>TreeSet类保证该映射将在升序键顺序，由TreeMap支持。</li><li>该映射是按照自然排序方法该键类，或在集创建时提供的比较器，这将取决于其构造函数中使用排序。</li><li>顺序必须是总为了使树到功能属性。</li></ul><p>这里仅列出几个常用的方法，更多详见<a href="http://gitbook.net/java/util/java_util_treeset.html" target="_blank" rel="noopener">^1</a></p><h1 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h1><h2 id="E-ceiling-E-e-方法"><a href="#E-ceiling-E-e-方法" class="headerlink" title="E ceiling(E e) 方法"></a>E ceiling(E e) 方法</h2><p>用来返回大于或等于给定的元素的最小元素，如果不存在这样的元素返回null。</p><h2 id="E-floor-E-e-方法"><a href="#E-floor-E-e-方法" class="headerlink" title="E floor(E e) 方法"></a>E floor(E e) 方法</h2><p>此方法返回小于或等于给定的元素的最大元素，如果不存在这样的元素返回null。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java.util.TreeSet 类实现Set接口。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="TreeSet" scheme="http://yoursite.com/tags/TreeSet/"/>
    
  </entry>
  
  <entry>
    <title>220. 存在重复元素III</title>
    <link href="http://yoursite.com/2020/06/29/220.%20%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0III/"/>
    <id>http://yoursite.com/2020/06/29/220. 存在重复元素III/</id>
    <published>2020-06-29T06:59:12.000Z</published>
    <updated>2020-06-29T09:31:29.444Z</updated>
    
    <content type="html"><![CDATA[<p>在整数数组 nums 中，是否存在两个下标 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值小于等于 t ，且满足 i 和 j 的差的绝对值也小于等于 ķ 。</p><a id="more"></a><p>如果存在则返回 true，不存在返回 false。</p><p>示例 1:</p><pre><code>输入: nums = [1,2,3,1], k = 3, t = 0输出: true</code></pre><p>示例 2:</p><pre><code>输入: nums = [1,0,1,1], k = 1, t = 2输出: true</code></pre><p>示例 3:</p><pre><code>输入: nums = [1,5,9,1,5,9], k = 2, t = 3输出: false</code></pre><h1 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h1><p>首先想到用HashSet来解决但超时了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            for (int j = nums[i] - t; j &lt;= nums[i] + t; j++) &#123;</span><br><span class="line">                if (set.contains(j)) &#123;</span><br><span class="line">//                    System.out.println(&quot;i=&quot;+i+&quot;, j=&quot;+j);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">            if (set.size() &gt; k) &#123;</span><br><span class="line">                set.remove(nums[i - k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看一下官方题解<a href="https://leetcode-cn.com/problems/contains-duplicate-iii/solution/cun-zai-zhong-fu-yuan-su-iii-by-leetcode/" target="_blank" rel="noopener">^1</a></p><h1 id="二叉搜索树-【通过】"><a href="#二叉搜索树-【通过】" class="headerlink" title="二叉搜索树 【通过】"></a>二叉搜索树 【通过】</h1><p>总结一下该方法引入自平衡二叉搜索树，来保证能在O(logn) 时间内完成 插入，搜索，删除 操作。减少对滑动窗口中符合条件的元素操作所需的时间。</p><p>下面给出整个算法的伪代码：</p><pre><code>初始化一颗空的二叉搜索树 set对于每个元素xx，遍历整个数组    在 set 上查找大于等于xx的最小的数，如果s - x \leq ts−x≤t则返回 true    在 set 上查找小于等于xx的最大的数，如果x - g \leq tx−g≤t则返回 true    在 set 中插入xx    如果树的大小超过了kk, 则移除最早加入树的那个数。返回 false</code></pre><p>我们把大于等于 <em>x</em> 的最小的数 <em>s</em> 当做 <em>x</em> 在 BST 中的后继节点。同样的，我们能把小于等于 <em>x</em> 最大的数 <em>g</em> 当做 <em>x</em> 在 BST 中的前继节点。<em>s</em> 和 <em>g</em> 这两个数是距离 <em>x</em> 最近的数。因此只需要检查它们和 <em>x</em> 的距离就能知道条件二是否满足了。</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="comment">// Find the successor of current element</span></span><br><span class="line">        Integer s = set.ceiling(nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span> &amp;&amp; s &lt;= nums[i] + t) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find the predecessor of current element</span></span><br><span class="line">        Integer g = set.floor(nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (g != <span class="keyword">null</span> &amp;&amp; nums[i] &lt;= g + t) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        set.add(nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (set.size() &gt; k) &#123;</span><br><span class="line">            set.remove(nums[i - k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-ceiling-E-e-方法-2"><a href="#E-ceiling-E-e-方法-2" class="headerlink" title="E ceiling(E e) 方法^2"></a>E ceiling(E e) 方法<a href="http://gitbook.net/java/util/java_util_treeset.html" target="_blank" rel="noopener">^2</a></h2><p>用来返回大于或等于给定的元素的最小元素，如果不存在这样的元素返回null。</p><h2 id="E-floor-E-e-方法"><a href="#E-floor-E-e-方法" class="headerlink" title="E floor(E e) 方法"></a>E floor(E e) 方法</h2><p>此方法返回小于或等于给定的元素的最大元素，如果不存在这样的元素返回null。</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(n log (min(n,k)))<br>我们需要遍历这个 n 长度的数组。对于每次遍历，在 BST 中 搜索，插入 或者 删除 都需要花费 O(logmin(k, n))的时间。</p><p>空间复杂度：O(min(n,k))<br>空间复杂度由 BST 的大小决定，其大小的上限由 k 和 n 共同决定。</p><h2 id="溢出错误"><a href="#溢出错误" class="headerlink" title="溢出错误"></a>溢出错误</h2><p>当数组中的元素非常大的时候，进行数学运算可能造成溢出。所以可以考虑使用支持大数的数据类型，例如 long。</p><p>C++ 中的 std::set，std::set::upper_bound 和 std::set::lower_bound 分别等价于 Java 中的 TreeSet，TreeSet::ceiling 和 TreeSet::floor。Python 标准库不提供自平衡 BST。</p><p>当测试用例为</p><pre><code>[-2147483648,-2147483647]33</code></pre><p>时会溢出，为了解决这个问题，使用long类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) &#123;</span><br><span class="line">        TreeSet&lt;Long&gt; set = new TreeSet&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            // Find the successor of current element</span><br><span class="line">            Long s = set.ceiling((long) nums[i]);</span><br><span class="line">            if (s != null &amp;&amp; s &lt;= (long) nums[i] + t) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Find the predecessor of current element</span><br><span class="line">            Long g = set.floor((long) nums[i]);</span><br><span class="line">            if (g != null &amp;&amp; g &gt;= (long) nums[i] - t) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            set.add((long) nums[i]);</span><br><span class="line">            if (set.size() &gt; k) &#123;</span><br><span class="line">                set.remove((long) nums[i - k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法三-（桶）-【通过】"><a href="#方法三-（桶）-【通过】" class="headerlink" title="方法三 （桶） 【通过】"></a>方法三 （桶） 【通过】</h1><p><strong>思路</strong></p><p>受 <code>桶排序</code> 的启发，我们可以把 <em>桶</em> 当做窗口来实现一个线性复杂度的解法。</p><p><strong>算法</strong></p><p>桶排序是一种把元素分散到不同桶中的排序算法。接着把每个桶再独立地用不同的排序算法进行排序。桶排序的概览如下所示：</p><p>在上面的例子中，我们有 8 个未排序的整数。我们首先来创建五个桶，这五个桶分别包含 <em>[0,9], [10,19], [20, 29], [30, 39], [40, 49]</em> 这几个区间。这 8 个元素中的任何一个元素都在一个桶里面。对于值为 <em>x</em> 的元素来说，它所属桶的标签为 <em>x/w</em>，在这里我们让 <em>w = 10</em>。对于每个桶我们单独用其他排序算法进行排序，最后按照桶的顺序收集所有的元素就可以得到一个有序的数组了。</p><p>回到这个问题，我们尝试去解决的最大的问题在于：</p><blockquote><ol><li>对于给定的元素 <em>x</em>, 在窗口中是否有存在区间 <em>[x-t, x+t]</em> 内的元素？  </li><li>我们能在常量时间内完成以上判断嘛？</li></ol></blockquote><p>我们不妨把把每个元素当做一个人的生日来考虑一下吧。假设你是班上新来的一位学生，你的生日在 <em>三月</em> 的某一天，你想知道班上是否有人生日跟你生日在 <em>t=30</em> 天以内。在这里我们先假设每个月都是<em>30<em>天，很明显，我们只需要检查所有生日在 *二月</em>，<em>三月</em>，*四月</em> 的同学就可以了。</p><p>之所以能这么做的原因在于，我们知道每个人的生日都属于一个桶，我们把这个桶称作月份！每个桶所包含的区间范围都是 <em>t</em>，这能极大的简化我们的问题。很显然，任何不在同一个桶或相邻桶的两个元素之间的距离一定是大于 <em>t</em> 的。</p><p>我们把上面提到的桶的思想应用到这个问题里面来，我们设计一些桶，让他们分别包含区间 <em>…, [0,t], [t+1, 2t+1], …*。我们把桶来当做窗口，于是每次我们只需要检查 *x</em> 所属的那个桶和相邻桶中的元素就可以了。终于，我们可以在常量时间解决在窗口中搜索的问题了。</p><p>还有一件值得注意的事！</p><p>这个问题和桶排序的不同之处在于每次我们的桶里只需要包含最多一个元素就可以了，因为如果任意一个桶中包含了两个元素，那么这也就是意味着这两个元素是 <em>足够接近的</em> 了，这时候我们就直接得到答案了。因此，我们只需使用一个标签为桶序号的散列表就可以了。 </p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Get the ID of the bucket from element value x and bucket width w</span></span><br><span class="line">    <span class="comment">// In Java, `-3 / 5 = 0` and but we need `-3 / 5 = -1`.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getID</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; <span class="number">0</span> ? (x + <span class="number">1</span>) / w - <span class="number">1</span> : x / w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// Key: ID of the bucket   Value: bucket  value</span></span><br><span class="line">        Map&lt;Long, Long&gt; d = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">long</span> w = (<span class="keyword">long</span>)t + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">long</span> m = getID(nums[i], w);</span><br><span class="line">            <span class="comment">// check if bucket m is empty, each bucket may contain at most one element</span></span><br><span class="line">            <span class="keyword">if</span> (d.containsKey(m))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// check the neighbor buckets for almost duplicate</span></span><br><span class="line">            <span class="keyword">if</span> (d.containsKey(m - <span class="number">1</span>) &amp;&amp; Math.abs(nums[i] - d.get(m - <span class="number">1</span>)) &lt; w)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (d.containsKey(m + <span class="number">1</span>) &amp;&amp; Math.abs(nums[i] - d.get(m + <span class="number">1</span>)) &lt; w)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// now bucket m is empty and no almost duplicate in nei***or buckets</span></span><br><span class="line">            d.put(m, (<span class="keyword">long</span>)nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k) d.remove(getID(nums[i - k], w));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(n)</em></li></ul><p>对于这 <em>n</em> 个元素中的任意一个元素来说，我们最多只需要在散列表中做三次 <code>搜索</code>，一次 <code>插入</code> 和一次 <code>删除</code>。这些操作是常量时间复杂度的。因此，整个算法的时间复杂度为 <em>O(n)</em>。</p><ul><li>空间复杂度：O(min(n,k))<br>需要开辟的额外空间取决了散列表的大小，其大小跟它所包含的元素数量成线性关系。散列表的大小的上限同时由 <em>n</em> 和 <em>k</em> 决定。因此，空间复杂度为O(min(n,k))  。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在整数数组 nums 中，是否存在两个下标 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值小于等于 t ，且满足 i 和 j 的差的绝对值也小于等于 ķ 。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Sort" scheme="http://yoursite.com/tags/Sort/"/>
    
      <category term="Ordered Map" scheme="http://yoursite.com/tags/Ordered-Map/"/>
    
  </entry>
  
  <entry>
    <title>219. 存在重复元素II</title>
    <link href="http://yoursite.com/2020/06/29/219.%20%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II/"/>
    <id>http://yoursite.com/2020/06/29/219. 存在重复元素II/</id>
    <published>2020-06-29T06:33:12.000Z</published>
    <updated>2020-06-29T06:55:28.045Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: nums = [1,2,3,1], k = 3输出: true</code></pre><p>示例 2:</p><pre><code>输入: nums = [1,0,1,1], k = 1输出: true</code></pre><p>示例 3:</p><pre><code>输入: nums = [1,2,3,1,2,3], k = 2输出: false</code></pre><h1 id="解法一：HashMap"><a href="#解法一：HashMap" class="headerlink" title="解法一：HashMap"></a>解法一：HashMap</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean containsNearbyDuplicate(int[] nums, int k) &#123;</span><br><span class="line">        //Key-&gt;nums[i] , Value-&gt;i</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; hashMap=new HashMap&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (hashMap.containsKey(nums[i])) &#123;</span><br><span class="line">                if (Math.abs(i - hashMap.get(nums[i])) &lt;= k) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            hashMap.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法二-（散列表）"><a href="#方法二-（散列表）" class="headerlink" title="方法二 （散列表）"></a>方法二 （散列表）</h1><p><strong>思路</strong></p><p>用散列表来维护这个<em>k</em>大小的滑动窗口。<a href="https://leetcode-cn.com/problems/contains-duplicate-ii/solution/cun-zai-zhong-fu-yuan-su-ii-by-leetcode/" target="_blank" rel="noopener">^1</a></p><p><strong>算法</strong></p><p>在之前的方法中，我们知道了对数时间复杂度的 <code>搜索</code> 操作是不够的。在这个方法里面，我们需要一个支持在常量时间内完成 <code>搜索</code>，<code>删除</code>，<code>插入</code> 操作的数据结构，那就是散列表。这个算法的实现跟方法二几乎是一样的。</p><ul><li>遍历数组，对于每个元素做以下操作：<ul><li>在散列表中搜索当前元素，如果找到了就返回 <code>true</code>。</li><li>在散列表中插入当前元素。</li><li>如果当前散列表的大小超过了 <em>k</em>， 删除散列表中最旧的元素。</li></ul></li><li>返回 <code>false</code>。</li></ul><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(nums[i])) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        set.add(nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (set.size() &gt; k) &#123;</span><br><span class="line">            set.remove(nums[i - k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)</em><br>我们会做 <em>n</em> 次 <code>搜索</code>，<code>删除</code>，<code>插入</code> 操作，每次操作都耗费常数时间。</p></li><li><p>空间复杂度：O(min(n,k)) </p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>217. 存在重复元素</title>
    <link href="http://yoursite.com/2020/06/29/217.%20%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2020/06/29/217. 存在重复元素/</id>
    <published>2020-06-29T06:33:12.000Z</published>
    <updated>2020-06-29T06:41:10.110Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数数组，判断是否存在重复元素。如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。</p><a id="more"></a><h1 id="哈希表解决"><a href="#哈希表解决" class="headerlink" title="哈希表解决"></a>哈希表解决</h1><p>可以用Set或HashMap来解决</p><figure class="highlight java"><figcaption><span>[solution 3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(nums.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x: nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(x)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        set.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多详细分析见<a href="https://leetcode-cn.com/problems/contains-duplicate/solution/cun-zai-zhong-fu-yuan-su-by-leetcode/" target="_blank" rel="noopener">^1</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://leetcode-cn.com/problems/contains-duplicate-ii/" target="_blank" rel="noopener">219 存在重复元素 II</a></li><li><a href="https://leetcode-cn.com/problems/contains-duplicate-iii/" target="_blank" rel="noopener">220 存在重复元素 III</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数数组，判断是否存在重复元素。如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>152. 乘积最大子数组</title>
    <link href="http://yoursite.com/2020/06/29/152.%20%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2020/06/29/152. 乘积最大子数组/</id>
    <published>2020-06-29T06:06:12.000Z</published>
    <updated>2020-06-29T06:23:19.793Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。</code></pre><p>示例 2:</p><pre><code>输入: [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</code></pre><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这道题比较经典，官方解法可以见<a href="https://leetcode-cn.com/problems/maximum-product-subarray/solution/cheng-ji-zui-da-zi-shu-zu-by-leetcode-solution/" target="_blank" rel="noopener">^1</a>,我首先想到用全局变量和局部变量的方法来解决，但是要注意两个测试样例[-2]和[0,2]，需要对全局和局部最大变量做相应处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProduct(int[] nums) &#123;</span><br><span class="line">        int maxpro=nums[0];</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            int localpro=nums[i];</span><br><span class="line">            maxpro = Math.max(maxpro, localpro);</span><br><span class="line">            for (int j = i+1; j &lt; nums.length; j++) &#123;</span><br><span class="line">                localpro *= nums[j];</span><br><span class="line">                maxpro = Math.max(maxpro, localpro);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxpro;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>189. 旋转数组</title>
    <link href="http://yoursite.com/2020/06/29/189.%20%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2020/06/29/189. 旋转数组/</id>
    <published>2020-06-29T06:06:12.000Z</published>
    <updated>2020-06-29T06:23:14.982Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4]</code></pre><p>示例 2:</p><pre><code>输入: [-1,-100,3,99] 和 k = 2输出: [3,99,-1,-100]解释: 向右旋转 1 步: [99,-1,-100,3]向右旋转 2 步: [3,99,-1,-100]</code></pre><p>说明:</p><pre><code>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。要求使用空间复杂度为 O(1) 的 原地 算法。</code></pre><h2 id="方法-1：暴力"><a href="#方法-1：暴力" class="headerlink" title="方法 1：暴力"></a>方法 1：暴力</h2><p>最简单的方法是旋转 k 次，每次将数组旋转 1 个元素。</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp, previous;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            previous = nums[nums.length - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                temp = nums[j];</span><br><span class="line">                nums[j] = previous;</span><br><span class="line">                previous = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(n*k)</em> 。每个元素都被移动 1 步（<em>O(n)</em>） k次（<em>O(k)</em>） 。</li><li>空间复杂度：<em>O(1)</em> 。没有额外空间被使用。</li></ul><h2 id="方法-2：使用额外的数组"><a href="#方法-2：使用额外的数组" class="headerlink" title="方法 2：使用额外的数组"></a>方法 2：使用额外的数组</h2><p><strong>算法</strong></p><p>我们可以用一个额外的数组来将每个元素放到正确的位置上，也就是原本数组里下标为 <em>i</em> 的我们把它放到 <img src="./p___i+k_%%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6_.png" alt="(i+k)\%数组长度 ">  的位置。然后把新的数组拷贝到原数组中。</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            a[(i + k) % nums.length] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度： <em>O(n)</em> 。将数字放到新的数组中需要一遍遍历，另一边来把新数组的元素拷贝回原数组。</li><li>空间复杂度： <em>O(n)</em>。另一个数组需要原数组长度的空间。</li></ul><h2 id="方法-3：使用环状替换"><a href="#方法-3：使用环状替换" class="headerlink" title="方法 3：使用环状替换"></a>方法 3：使用环状替换</h2><p><strong>算法</strong></p><p>如果我们直接把每一个数字放到它最后的位置，但这样的后果是遗失原来的元素。因此，我们需要把被替换的数字保存在变量 <em>temp</em> 里面。然后，我们将被替换数字（<em>temp*）放到它正确的位置，并继续这个过程 *n</em> 次， <em>n</em> 是数组的长度。这是因为我们需要将数组里所有的元素都移动。但是，这种方法可能会有个问题，如果 <img src="./p__n%k==0_.png" alt="n\%k==0 "> ，其中 <img src="./p__k=k%n_.png" alt="k=k\%n ">  （因为如果 <em>k</em> 大于 <em>n</em> ，移动 <em>k</em> 次实际上相当于移动 <img src="./p__k%n_.png" alt="k\%n ">  次）。这种情况下，我们会发现在没有遍历所有数字的情况下回到出发数字。此时，我们应该从下一个数字开始再重复相同的过程。</p><p>现在，我们看看上面方法的证明。假设，数组里我们有 <em>n</em> 个元素并且 <em>k</em> 是要求移动的次数。更进一步，假设 <img src="./p__n%k=0_.png" alt="n\%k=0 ">  。第一轮中，所有移动数字的下标 <em>i</em> 满足 <img src="./p__i%k==0_.png" alt="i\%k==0 ">  。这是因为我们每跳 <em>k</em> 步，我们只会到达相距为 <em>k</em> 个位置下标的数。每一轮，我们都会移动 <img src="./p__frac%7Bn%7D%7Bk%7D_.png" alt="\frac{n}{k} ">  个元素。下一轮中，我们会移动满足 <img src="./p__i%k==1_.png" alt="i\%k==1 ">  的位置的数。这样的轮次会一直持续到我们再次遇到 <img src="./p__i%k==0_.png" alt="i\%k==0 ">  的地方为止，此时 <em>i=k</em> 。此时在正确位置上的数字共有 <img src="./p__k_times_frac%7Bn%7D%7Bk%7D=n_.png" alt="k\times\frac{n}{k}=n ">  个。因此所有数字都在正确位置上。</p><p>让我们看一下接下来的例子，以更好地说明这个过程：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums: [1, 2, 3, 4, 5, 6]</span><br><span class="line">k: 2</span><br></pre></td></tr></table></figure></p><p> <a href="https://pic.leetcode-cn.com/f0493a97cdb7bc46b37306ca14e555451496f9f9c21effcad8517a81a26f30d6-image.png" target="_blank" rel="noopener">例子</a></p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k = k % nums.length;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; count &lt; nums.length; start++) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = start;</span><br><span class="line">            <span class="keyword">int</span> prev = nums[start];</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> next = (current + k) % nums.length;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[next];</span><br><span class="line">                nums[next] = prev;</span><br><span class="line">                prev = temp;</span><br><span class="line">                current = next;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">while</span> (start != current);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(n)</em> 。只遍历了每个元素一次。</li><li>空间复杂度：<em>O(1)</em> 。使用了常数个额外空间。</li></ul><h2 id="方法-4：使用反转"><a href="#方法-4：使用反转" class="headerlink" title="方法 4：使用反转"></a>方法 4：使用反转</h2><p><strong>算法</strong></p><p>这个方法基于这个事实：当我们旋转数组 k 次， <img src="./p__k%n_.png" alt="k\%n ">  个尾部元素会被移动到头部，剩下的元素会被向后移动。</p><p>在这个方法中，我们首先将所有元素反转。然后反转前 k 个元素，再反转后面 <em>n-k</em> 个元素，就能得到想要的结果。</p><p>我用这种方法来解决时遇到数组越界错误，是因为没有把k取模，因为有些情况下k可能大于数组长度。这个易错点需要注意。</p><p>假设 <em>n=7</em> 且 <em>k=3</em> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原始数组                  : 1 2 3 4 5 6 7</span><br><span class="line">反转所有数字后             : 7 6 5 4 3 2 1</span><br><span class="line">反转前 k 个数字后          : 5 6 7 4 3 2 1</span><br><span class="line">反转后 n-k 个数字后        : 5 6 7 1 2 3 4 --&gt; 结果</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k %= nums.length;</span><br><span class="line">        reverse(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, k, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[start];</span><br><span class="line">            nums[start] = nums[end];</span><br><span class="line">            nums[end] = temp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(n)</em> 。 <em>n</em> 个元素被反转了总共 3 次。</li><li>空间复杂度：<em>O(1)</em> 。 没有使用额外的空间。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>63. 不同路径II</title>
    <link href="http://yoursite.com/2020/06/28/63.%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II/"/>
    <id>http://yoursite.com/2020/06/28/63. 不同路径II/</id>
    <published>2020-06-28T12:50:12.000Z</published>
    <updated>2020-06-29T06:22:31.214Z</updated>
    
    <content type="html"><![CDATA[<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><a id="more"></a><p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p><p>说明：m 和 n 的值均不超过 100。</p><p>示例1:</p><pre><code>输入:[  [0,0,0],  [0,1,0],  [0,0,0]]输出: 2解释:3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</code></pre><h2 id="方法-1：动态规划-1"><a href="#方法-1：动态规划-1" class="headerlink" title="方法 1：动态规划^1"></a>方法 1：动态规划<a href="https://leetcode-cn.com/problems/unique-paths-ii/solution/bu-tong-lu-jing-ii-by-leetcode/" target="_blank" rel="noopener">^1</a></h2><p><strong>直觉</strong></p><p>机器人只可以向下和向右移动，因此第一行的格子只能从左边的格子移动到，第一列的格子只能从上方的格子移动到。</p><p>如果格子上有障碍，那么我们不考虑包含这个格子的任何路径。我们从左至右、从上至下的遍历整个数组，那么在到达某个顶点之前我们就已经获得了到达前驱节点的方案数，这就变成了一个<code>动态规划</code>问题。我们只需要一个 <code>obstacleGrid</code> 数组作为 DP 数组。</p><p><code>注意：</code> 根据题目描述，包含障碍物的格点有权值 <code>1</code>，我们依此来判断是否包含在路径中，然后我们可以用这个空间来存储到达这个格点的方案数。</p><p><strong>算法</strong></p><ol><li>如果第一个格点 <code>obstacleGrid[0,0]</code> 是 <code>1</code>，说明有障碍物，那么机器人不能做任何移动，我们返回结果 <code>0</code>。</li><li>否则，如果 <code>obstacleGrid[0,0]</code> 是 <code>0</code>，我们初始化这个值为 <code>1</code> 然后继续算法。</li><li>遍历第一行，如果有一个格点初始值为 <code>1</code> ，说明当前节点有障碍物，没有路径可以通过，设值为 <code>0</code> ；否则设这个值是前一个节点的值 <code>obstacleGrid[i,j] = obstacleGrid[i,j-1]</code>。</li><li>遍历第一列，如果有一个格点初始值为 <code>1</code> ，说明当前节点有障碍物，没有路径可以通过，设值为 <code>0</code> ；否则设这个值是前一个节点的值 <code>obstacleGrid[i,j] = obstacleGrid[i-1,j]</code>。</li><li>现在，从 <code>obstacleGrid[1,1]</code> 开始遍历整个数组，如果某个格点初始不包含任何障碍物，就把值赋为上方和左侧两个格点方案数之和 <code>obstacleGrid[i,j] = obstacleGrid[i-1,j] + obstacleGrid[i,j-1]</code>。</li><li>如果这个点有障碍物，设值为 <code>0</code> ，这可以保证不会对后面的路径产生贡献。</li></ol><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> R = obstacleGrid.length;</span><br><span class="line">        <span class="keyword">int</span> C = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the starting cell has an obstacle, then simply return as there would be</span></span><br><span class="line">        <span class="comment">// no paths to the destination.</span></span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Number of ways of reaching the starting cell = 1.</span></span><br><span class="line">        obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Filling the values for the first column</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; R; i++) &#123;</span><br><span class="line">            obstacleGrid[i][<span class="number">0</span>] = (obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; obstacleGrid[i - <span class="number">1</span>][<span class="number">0</span>] == <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Filling the values for the first row</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; C; i++) &#123;</span><br><span class="line">            obstacleGrid[<span class="number">0</span>][i] = (obstacleGrid[<span class="number">0</span>][i] == <span class="number">0</span> &amp;&amp; obstacleGrid[<span class="number">0</span>][i - <span class="number">1</span>] == <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Starting from cell(1,1) fill up the values</span></span><br><span class="line">        <span class="comment">// No. of ways of reaching cell[i][j] = cell[i - 1][j] + cell[i][j - 1]</span></span><br><span class="line">        <span class="comment">// i.e. From above and left.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; R; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; C; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    obstacleGrid[i][j] = obstacleGrid[i - <span class="number">1</span>][j] + obstacleGrid[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    obstacleGrid[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return value stored in rightmost bottommost cell. That is the destination.</span></span><br><span class="line">        <span class="keyword">return</span> obstacleGrid[R - <span class="number">1</span>][C - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 ： O(M\timesN)   。长方形网格的大小是 M\timesN ，而访问每个格点恰好一次。</li><li>空间复杂度 ： <em>O(1)</em>。我们利用 <code>obstacleGrid</code> 作为 DP 数组，因此不需要额外的空间。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>980. 不同路径 III</title>
    <link href="http://yoursite.com/2020/06/28/980.%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%20III/"/>
    <id>http://yoursite.com/2020/06/28/980. 不同路径 III/</id>
    <published>2020-06-28T12:50:12.000Z</published>
    <updated>2020-06-29T10:06:02.298Z</updated>
    
    <content type="html"><![CDATA[<p>返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目，每一个无障碍方格都要通过一次。</p><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在二维网格 grid 上，有 4 种类型的方格：</p><pre><code>1 表示起始方格。且只有一个起始方格。2 表示结束方格，且只有一个结束方格。0 表示我们可以走过的空方格。-1 表示我们无法跨越的障碍。</code></pre><p>返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目，每一个无障碍方格都要通过一次。</p><p>示例 1：</p><pre><code>输入：[[1,0,0,0],[0,0,0,0],[0,0,2,-1]]输出：2解释：我们有以下两条路径：1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)</code></pre><p>示例 2：</p><pre><code>输入：[[1,0,0,0],[0,0,0,0],[0,0,0,2]]输出：4解释：我们有以下四条路径： 1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)</code></pre><p>示例 3：</p><pre><code>输入：[[0,1],[2,0]]输出：0解释：没有一条路能完全穿过每一个空的方格一次。请注意，起始和结束方格可以位于网格中的任意位置。</code></pre><p>提示：</p><p>1 &lt;= grid.length * grid[0].length &lt;= 20</p><h4 id="方法一：回溯深度优先搜索"><a href="#方法一：回溯深度优先搜索" class="headerlink" title="方法一：回溯深度优先搜索"></a>方法一：回溯深度优先搜索</h4><p><strong>思路与算法</strong><a href="https://leetcode-cn.com/problems/unique-paths-iii/solution/bu-tong-lu-jing-iii-by-leetcode/" target="_blank" rel="noopener">^1</a></p><p>让我们尝试遍历每一个 <code>0</code> 方格，并在走过的方格里留下一个障碍。回溯的时候，我们要删除那些自己留下的障碍。</p><p>介于输入数据的限制，这个方法是可以通过的，因为一个不好的路径很快就会因没有无障碍的方格可以走而被卡住。 </p><figure class="highlight java"><figcaption><span>[2RULHstn-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="keyword">int</span>[][] grid;</span><br><span class="line">    <span class="keyword">int</span> targetR, targetC;</span><br><span class="line">    <span class="keyword">int</span> R, C;</span><br><span class="line">    <span class="keyword">int</span>[] dr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] dc = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsIII</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.grid = grid;</span><br><span class="line">        R = grid.length;</span><br><span class="line">        C = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> todo = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sourceR = <span class="number">0</span>, sourceC = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//获取无障碍方格数量和出发终止位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; c++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] != -<span class="number">1</span>) &#123;</span><br><span class="line">                    todo++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="number">1</span>) &#123;</span><br><span class="line">                    sourceR = r;</span><br><span class="line">                    sourceC = c;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[r][c] == <span class="number">2</span>) &#123;</span><br><span class="line">                    targetR = r;</span><br><span class="line">                    targetC = c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        dfs(sourceR, sourceC, todo);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> todo)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每一个无障碍方格都要通过一次</span></span><br><span class="line">        todo--;</span><br><span class="line">        <span class="keyword">if</span> (todo &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//到达终点</span></span><br><span class="line">        <span class="keyword">if</span> (r == targetR &amp;&amp; c == targetC) &#123;</span><br><span class="line">            <span class="keyword">if</span> (todo == <span class="number">0</span>) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在走过的方格里留下一个障碍</span></span><br><span class="line">        grid[r][c] = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">int</span> nr = r + dr[k];</span><br><span class="line">            <span class="keyword">int</span> nc = c + dc[k];</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> &lt;= nr &amp;&amp; nr &lt; R &amp;&amp; <span class="number">0</span> &lt;= nc &amp;&amp; nc &lt; C) &#123;</span><br><span class="line">                <span class="comment">//尝试遍历每一个 `0` 方格</span></span><br><span class="line">                <span class="keyword">if</span> (grid[nr][nc] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    dfs(nr, nc, todo);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//回溯的时候，我们要删除那些自己留下的障碍。</span></span><br><span class="line">        grid[r][c] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[2RULHstn-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsIII</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        R, C = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">nei</span>***<span class="title">ors</span><span class="params">(r, c)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> nr, nc <span class="keyword">in</span> ((r<span class="number">-1</span>, c), (r, c<span class="number">-1</span>), (r+<span class="number">1</span>, c), (r, c+<span class="number">1</span>)):</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= nr &lt; R <span class="keyword">and</span> <span class="number">0</span> &lt;= nc &lt; C <span class="keyword">and</span> grid[nr][nc] % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">yield</span> nr, nc</span><br><span class="line"></span><br><span class="line">        todo = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> r, row <span class="keyword">in</span> enumerate(grid):</span><br><span class="line">            <span class="keyword">for</span> c, val <span class="keyword">in</span> enumerate(row):</span><br><span class="line">                <span class="keyword">if</span> val != <span class="number">-1</span>: todo += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> val == <span class="number">1</span>: sr, sc = r, c</span><br><span class="line">                <span class="keyword">if</span> val == <span class="number">2</span>: tr, tc = r, c</span><br><span class="line"></span><br><span class="line">        self.ans = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(r, c, todo)</span>:</span></span><br><span class="line">            todo -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> todo &lt; <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> r == tr <span class="keyword">and</span> c == tc:</span><br><span class="line">                <span class="keyword">if</span> todo == <span class="number">0</span>:</span><br><span class="line">                    self.ans += <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            grid[r][c] = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">for</span> nr, nc <span class="keyword">in</span> nei***ors(r, c):</span><br><span class="line">                dfs(nr, nc, todo)</span><br><span class="line">            grid[r][c] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        dfs(sr, sc, todo)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(4^{R<em>C})</em>，其中 *R, C</em> 是这个二维网格行与列的大小。（我们可以找到一个更加精确的界限，但是这个界限已经超越了本文的范围）</p></li><li><p>空间复杂度：<em>O(R</em>C)*。</p></li></ul><hr><h4 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h4><p><strong>思路与算法</strong></p><p>让我们定义 <code>dp(r, c, todo)</code> 为从  <code>(r, c)</code> 开始行走，还没有遍历的无障碍方格集合为 <code>todo</code> 的好路径的数量。</p><p>我们可以使用一个与 <em>方法一</em> 类似的方法，并通过记忆化状态 <code>(r, c, todo)</code> 的答案来避免重复搜索。</p><figure class="highlight java"><figcaption><span>[pRtnUqNa-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="keyword">int</span>[][] grid;</span><br><span class="line">    <span class="keyword">int</span> R, C;</span><br><span class="line">    <span class="keyword">int</span> tr, tc, target;</span><br><span class="line">    <span class="keyword">int</span>[] dr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] dc = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    Integer[][][] memo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsIII</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.grid = grid;</span><br><span class="line">        R = grid.length;</span><br><span class="line">        C = grid[<span class="number">0</span>].length;</span><br><span class="line">        target = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sr = <span class="number">0</span>, sc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; ++r)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                    target |= code(r, c);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="number">1</span>) &#123;</span><br><span class="line">                    sr = r;</span><br><span class="line">                    sc = c;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[r][c] == <span class="number">2</span>) &#123;</span><br><span class="line">                    tr = r;</span><br><span class="line">                    tc = c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        memo = <span class="keyword">new</span> Integer[R][C][<span class="number">1</span> &lt;&lt; R*C];</span><br><span class="line">        <span class="keyword">return</span> dp(sr, sc, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">code</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; (r * C + c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">dp</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> todo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (memo[r][c][todo] != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> memo[r][c][todo];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r == tr &amp;&amp; c == tc) &#123;</span><br><span class="line">            <span class="keyword">return</span> todo == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">            <span class="keyword">int</span> nr = r + dr[k];</span><br><span class="line">            <span class="keyword">int</span> nc = c + dc[k];</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> &lt;= nr &amp;&amp; nr &lt; R &amp;&amp; <span class="number">0</span> &lt;= nc &amp;&amp; nc &lt; C) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((todo &amp; code(nr, nc)) != <span class="number">0</span>)</span><br><span class="line">                    ans += dp(nr, nc, todo ^ code(nr, nc));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memo[r][c][todo] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[pRtnUqNa-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsIII</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        R, C = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">code</span><span class="params">(r, c)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; (r * C + c)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">nei</span>***<span class="title">ors</span><span class="params">(r, c)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> nr, nc <span class="keyword">in</span> ((r<span class="number">-1</span>, c), (r, c<span class="number">-1</span>), (r+<span class="number">1</span>, c), (r, c+<span class="number">1</span>)):</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= nr &lt; R <span class="keyword">and</span> <span class="number">0</span> &lt;= nc &lt; C <span class="keyword">and</span> grid[nr][nc] % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">yield</span> nr, nc</span><br><span class="line"></span><br><span class="line">        target = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> r, row <span class="keyword">in</span> enumerate(grid):</span><br><span class="line">            <span class="keyword">for</span> c, val <span class="keyword">in</span> enumerate(row):</span><br><span class="line">                <span class="keyword">if</span> val % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    target |= code(r, c)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> val == <span class="number">1</span>:</span><br><span class="line">                    sr, sc = r, c</span><br><span class="line">                <span class="keyword">if</span> val == <span class="number">2</span>:</span><br><span class="line">                    tr, tc = r, c</span><br><span class="line"></span><br><span class="line"><span class="meta">        @lru_cache(None)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(r, c, todo)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> r == tr <span class="keyword">and</span> c == tc:</span><br><span class="line">                <span class="keyword">return</span> +(todo == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            ans = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> nr, nc <span class="keyword">in</span> nei***ors(r, c):</span><br><span class="line">                <span class="keyword">if</span> todo &amp; code(nr, nc):</span><br><span class="line">                    ans += dp(nr, nc, todo ^ code(nr, nc))</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp(sr, sc, target)</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(R * C * 2^{R<em>C})</em>，其中 *R, C</em> 是给定二维网格行与列的大小。</li><li>空间复杂度：<em>O(R * C * 2^{R</em>C})*。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目，每一个无障碍方格都要通过一次。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>62. 不同路径</title>
    <link href="http://yoursite.com/2020/06/28/62.%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2020/06/28/62. 不同路径/</id>
    <published>2020-06-28T12:12:12.000Z</published>
    <updated>2020-06-28T14:32:49.381Z</updated>
    
    <content type="html"><![CDATA[<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。问总共有多少条不同的路径？</p><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p><p>示例 1:</p><pre><code>输入: m = 3, n = 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向右 -&gt; 向下2. 向右 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向右</code></pre><p>示例 2:</p><pre><code>输入: m = 7, n = 3输出: 28</code></pre><p>提示：</p><pre><code>1 &lt;= m, n &lt;= 100</code></pre><p>题目数据保证答案小于等于 2 * 10 ^ 9</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="思路一：排列组合"><a href="#思路一：排列组合" class="headerlink" title="思路一：排列组合"></a><strong>思路一：排列组合</strong></h2><p>因为机器到底右下角，向下几步，向右几步都是固定的，</p><p>比如，<code>m=3, n=2</code>，我们只要向下 1 步，向右 2 步就一定能到达终点。</p><p>所以有 <em>C_{m+n-2}^{m-1}</em></p><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> int(math.factorial(m+n<span class="number">-2</span>)/math.factorial(m<span class="number">-1</span>)/math.factorial(n<span class="number">-1</span>))</span><br></pre></td></tr></table></figure><h2 id="思路二：动态规划"><a href="#思路二：动态规划" class="headerlink" title="思路二：动态规划"></a><strong>思路二：动态规划</strong></h2><p>我们令 <code>dp[i][j]</code> 是到达 <code>i, j</code> 最多路径</p><p>动态方程：<code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code></p><p>注意，对于第一行 <code>dp[0][j]</code>，或者第一列 <code>dp[i][0]</code>，由于都是在边界，所以只能为 <code>1</code></p><p>时间复杂度：<em>O(m*n)</em></p><p>空间复杂度：<em>O(m * n)</em></p><h2 id="优化：因为我们每次只需要-dp-i-1-j-dp-i-j-1"><a href="#优化：因为我们每次只需要-dp-i-1-j-dp-i-j-1" class="headerlink" title="优化：因为我们每次只需要 dp[i-1][j],dp[i][j-1]"></a>优化：因为我们每次只需要 <code>dp[i-1][j],dp[i][j-1]</code></h2><p>所以我们只要记录这两个数，直接看代码吧！</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>思路二：</p><figure class="highlight java"><figcaption><span>[1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化1：空间复杂度 <em>O(2n)</em></p><figure class="highlight java"><figcaption><span>[2]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] pre = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] cur = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(pre, <span class="number">1</span>);</span><br><span class="line">        Arrays.fill(cur,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                cur[j] = cur[j-<span class="number">1</span>] + pre[j];</span><br><span class="line">            &#125;</span><br><span class="line">            pre = cur.clone();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre[n-<span class="number">1</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化2：空间复杂度 <em>O(n)</em></p><figure class="highlight java"><figcaption><span>[3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] cur = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(cur,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                cur[j] += cur[j-<span class="number">1</span>] ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。问总共有多少条不同的路径？&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>212. 单词搜索II</title>
    <link href="http://yoursite.com/2020/06/28/212.%20%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2II/"/>
    <id>http://yoursite.com/2020/06/28/212. 单词搜索II/</id>
    <published>2020-06-28T10:12:12.000Z</published>
    <updated>2020-06-28T12:02:17.704Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二维网格board和一个字典中的单词列表 words，找出所有同时在二维网格和字典中出现的单词。</p><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。</p><p>示例:</p><p>输入: </p><pre><code>words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;] and board =[  [&apos;o&apos;,&apos;a&apos;,&apos;a&apos;,&apos;n&apos;],  [&apos;e&apos;,&apos;t&apos;,&apos;a&apos;,&apos;e&apos;],  [&apos;i&apos;,&apos;h&apos;,&apos;k&apos;,&apos;r&apos;],  [&apos;i&apos;,&apos;f&apos;,&apos;l&apos;,&apos;v&apos;]]</code></pre><p>输出:</p><pre><code>[&quot;eat&quot;,&quot;oath&quot;]</code></pre><p>说明:</p><p>你可以假设所有输入都由小写字母 a-z 组成。</p><p>提示:</p><ul><li><p>你需要优化回溯算法以通过更大数据量的测试。你能否早点停止回溯？</p></li><li><p>如果当前单词不存在于所有单词的前缀中，则可以立即停止回溯。什么样的数据结构可以有效地执行这样的操作？散列表是否可行？为什么？ 前缀树如何？如果你想学习如何实现一个基本的前缀树，请先查看这个问题： 实现Trie（前缀树）。</p></li></ul><h4 id="方法一：使用前缀树的回溯"><a href="#方法一：使用前缀树的回溯" class="headerlink" title="方法一：使用前缀树的回溯"></a>方法一：使用前缀树的回溯</h4><p>这个问题实际上是一个简化的纵横填字游戏，在这个游戏中，单词的解已经被嵌入了一些无关字母。我们要做的就是把它们划掉。</p><p>直观地说，为了划掉所有潜在的单词，总体策略是一个接一个地迭代单元格，然后从每个单元格沿着它的四个潜在方向的走，找到匹配的单词。</p><p>当我们在黑板上徘徊时，若我们知道这不会发现新单词时，我们会停止探索。</p><p>有人可能已经猜到了我们用来解决这个问题的方法。是的，它是回溯，这将是解决方案的主干。构造一个回溯的解决方案是相当简单的。</p><p>解决这个问题的关键在于我们如何从字典中找到单词的匹配项。直观地说，可以使用 hashset 数据结构（例如Python 中的 <code>set()</code>）。</p><p>然而，在回溯过程中，人们会更经常地遇到这样的问题：是否存在任何包含特定前缀的单词，而不是是否有一个字符串作为单词存在于字典中。因为如果我们知道给定前缀的字典中不存在任何单词匹配，那么我们就不需要进一步探索某个方向。而这，将大大减少探测空间，从而提高回溯算法的性能。</p><p>能够查找前缀的数据结构叫 Trie，于 hashset 比较。Trie 不仅可以检查一个单词，还可以立即找到共享给定前缀的单词。事实证明，数据结构的选择（Trie 与 hashset）可能以排名前 5% 或后 5% 的解决方案结束。</p><p>这里我们展示了一个由单词列表构建的 Trie 示例。如下图所示，在所表示的节点处，我们将知道字典中至少有两个前缀为 <code>d</code> 的单词。</p><p> <a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl90cmllX2V4YW1wbGUucG5n?x-oss-process=image/format,png" target="_blank" rel="noopener">一个由单词列表构建的 Trie 示例</a></p><p>我们在实现 Trie 数据结构时遇到麻烦。我们可以从<a href="https://leetcode.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">Trie 问题</a>开始作为热身，然后再回来这个问题。</p><p><strong>算法：</strong></p><p>该算法的整个工作流程是直观的，包括在二维网格中的每个单元上循环和从单元开始的递归函数调用。这是算法的框架。</p><ul><li>我们根据字典中的单词构建一个 Trie，稍后将用于匹配过程。</li><li>从每个单元格开始，如果字典中存在以单元格中的字母开头的单词,则我们开始回溯探索（即 <code>backtracking(cell)</code>）。</li><li>在递归函数 <code>backtracking(cell)</code> 调用过程中，我们探索当前单元格周围的相邻单元格（即 <code>neighborCell</code>）以进行下一个递归调用 <code>backtracking(neighborCell)</code>。在每次调用时，我们都会检查到目前为止遍历的字母序列是否与字典中的任何单词匹配，这需要借助于我们在开始时构建的 Trie 数据结构。</li></ul><p>下面是算法的工作原理的。基于上述思想，我们给出了一些示例实现。之后，我们详细介绍了一些可以进一步应用于该算法的优化。</p><p> <a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl90cmllX2FsZ28ucG5n?x-oss-process=image/format,png" target="_blank" rel="noopener">算法的工作原理</a></p><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">  HashMap&lt;Character, TrieNode&gt; children = <span class="keyword">new</span> HashMap&lt;Character, TrieNode&gt;();</span><br><span class="line">  String word = <span class="keyword">null</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span>[][] _board = <span class="keyword">null</span>;</span><br><span class="line">  ArrayList&lt;String&gt; _result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findWords</span><span class="params">(<span class="keyword">char</span>[][] board, String[] words)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 1). Construct the Trie</span></span><br><span class="line">    TrieNode root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">      TrieNode node = root;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (Character letter : word.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.children.containsKey(letter)) &#123;</span><br><span class="line">          node = node.children.get(letter);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          TrieNode newNode = <span class="keyword">new</span> TrieNode();</span><br><span class="line">          node.children.put(letter, newNode);</span><br><span class="line">          node = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      node.word = word;  <span class="comment">// store words in Trie</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._board = board;</span><br><span class="line">    <span class="comment">// Step 2). Backtracking starting for each cell in the board</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; board.length; ++row) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; board[row].length; ++col) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.children.containsKey(board[row][col])) &#123;</span><br><span class="line">          backtracking(row, col, root);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._result;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, TrieNode parent)</span> </span>&#123;</span><br><span class="line">    Character letter = <span class="keyword">this</span>._board[row][col];</span><br><span class="line">    TrieNode currNode = parent.children.get(letter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check if there is any match</span></span><br><span class="line">    <span class="keyword">if</span> (currNode.word != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>._result.add(currNode.word);</span><br><span class="line">      currNode.word = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mark the current letter before the EXPLORATION</span></span><br><span class="line">    <span class="keyword">this</span>._board[row][col] = <span class="string">'#'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// explore neighbor cells in around-clock directions: up, right, down, left</span></span><br><span class="line">    <span class="keyword">int</span>[] rowOffset = &#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] colOffset = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">      <span class="keyword">int</span> newRow = row + rowOffset[i];</span><br><span class="line">      <span class="keyword">int</span> newCol = col + colOffset[i];</span><br><span class="line">      <span class="keyword">if</span> (newRow &lt; <span class="number">0</span> || newRow &gt;= <span class="keyword">this</span>._board.length || newCol &lt; <span class="number">0</span></span><br><span class="line">          || newCol &gt;= <span class="keyword">this</span>._board[<span class="number">0</span>].length) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (currNode.children.containsKey(<span class="keyword">this</span>._board[newRow][newCol])) &#123;</span><br><span class="line">        backtracking(newRow, newCol, currNode);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// End of EXPLORATION, restore the original letter in the board.</span></span><br><span class="line">    <span class="keyword">this</span>._board[row][col] = letter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optimization: incrementally remove the leaf nodes</span></span><br><span class="line">    <span class="keyword">if</span> (currNode.children.isEmpty()) &#123;</span><br><span class="line">      parent.children.remove(letter);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了更好地理解回溯过程，我们将在下面的动画中演示如何在 Trie 中找到 <code>dog</code>。</p><p>  [1](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV8xLnBuZw?x-oss-process=image/format" target="_blank" rel="noopener">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV8xLnBuZw?x-oss-process=image/format</a> png) </p><p>  [2](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV8yLnBuZw?x-oss-process=image/format" target="_blank" rel="noopener">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV8yLnBuZw?x-oss-process=image/format</a> png)  </p><p>  [3](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV8zLnBuZw?x-oss-process=image/format" target="_blank" rel="noopener">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV8zLnBuZw?x-oss-process=image/format</a> png)  </p><p>  [4](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV80LnBuZw?x-oss-process=image/format" target="_blank" rel="noopener">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV80LnBuZw?x-oss-process=image/format</a> png)  </p><p>  [5](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV81LnBuZw?x-oss-process=image/format" target="_blank" rel="noopener">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV81LnBuZw?x-oss-process=image/format</a> png)  </p><p>  [6](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV82LnBuZw?x-oss-process=image/format" target="_blank" rel="noopener">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV82LnBuZw?x-oss-process=image/format</a> png) </p><h2 id="优化："><a href="#优化：" class="headerlink" title="优化："></a><strong>优化</strong>：</h2><p>在上述实现中，除了应用 Trie 数据结构外，我们还应用了一些技巧来进一步加快运行时间。特别是，Python 实现的运行速度可以超过 98% 的提交。我们按其重要性将这些技巧详述如下。</p><ul><li>沿着 Trie 的节点回溯。</li></ul><p>人们可以简单地使用 Trie 作为字典来快速找到单词和前缀的匹配，即在回溯的每一步，我们都从Trie 的根开始。</p><p>然而，更有效的方法是将 Trie 与回溯过程一起遍历，即每一步 <code>backtracking(TrieNode)</code>，<code>TrieNode</code> 的深度对应于我们到目前为止匹配的前缀的长度。这项措施可以将您的解决方案从提交的最低 <em>5%</em> 中脱颖出来。</p><ul><li>在回溯过程中逐渐剪除 Trie 中的节点（剪枝）。</li></ul><p>这个想法的动机是整个算法的时间复杂度取决于 Trie 的大小。对于 Trie 中的叶节点，一旦遍历它（即找到匹配的单词），就不需要再遍历它了。结果，我们可以把它从树上剪下来。</p><p>逐渐地，这些非叶节点可以成为叶节点以后，因为我们修剪他们的孩子叶节点。在极端情况下，一旦我们找到字典中所有单词的匹配项，Trie 就会变成空的。这个剪枝措施可以减少在线测试用例 50% 的运行时间。</p><p> <a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl90cmllX3BydW5lLnBuZw?x-oss-process=image/format,png" target="_blank" rel="noopener">剪枝</a></p><ul><li>从 Trie 中删除匹配的单词。</li></ul><p>在这个问题中，我们被要求返回所有匹配的单词，而不是潜在匹配的数量。因此，一旦到达包含单词匹配的特定 Trie 节点，我们就可以从 Trie 中删除匹配单词。</p><p>作为附带好处，我们不需要检查结果集中是否有任何重复项。因此，我们可以简单地使用一个列表而不是集合来保存结果，这样可以加快解决方案的速度。</p><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>\mathcal{O}(M(4\cdot3^{L-1}))<em>，其中</em>M</em> 是二维网格中的单元格数，<em>L</em> 是单词的最大长度。</p><ul><li>计算回溯算法将执行的确切步数是一个棘手的问题。我们为这个问题的最坏情况提供了该步骤的上限。该算法循环遍历二维网格中的所有单元，因此在复杂度公式中我们有 <em>M</em> 作为因子。然后将其归结为每个启动单元所需的最大步骤数（即 <em>4\cdot3^{L-1}</em>）。</li><li>假设单词的最大长度是 <em>L</em>，从一个单元格开始，最初我们最多可以探索 4 个方向。假设每个方向都是有效的（即最坏情况），在接下来的探索中，我们最多有 3 个相邻的单元（不包括我们来的单元）要探索。因此，在回溯探索期间，我们最多遍历 <em>4\cdot3^{L-1}</em> 个单元格。</li><li>你可能会想最坏的情况是什么样子。这里有一个例子。想象一下，二维网格中的每个单元都包含字母 <code>a</code>，单词词典包含一个单词 <code>[&#39;aaaa&#39;]</code>。这是算法将遇到的最坏的情况之一。</li></ul><p><a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9jb21wbGV4aXR5X2V4YW1wbGUucG5n?x-oss-process=image/format,png" target="_blank" rel="noopener">最坏的情况</a></p></li></ul><p>注意，上述时间复杂性是在 Trie 数据结构一旦构建就不会改变的假设下估计的。如果采用优化策略逐步删除 Trie 中的节点，则可以大大提高时间复杂度，因为一旦匹配词典中的所有单词，即 Trie 变为空，回溯的成本就会降低到零。 </p><ul><li>空间复杂度：<em>\mathcal{O}(N)*，其中 *N</em> 是字典中的字母总数。<ul><li>算法消耗的主要空间是我们构建的 Trie 数据结构。在最坏的情况下，如果单词之间没有前缀重叠，则 Trie 将拥有与所有单词的字母一样多的节点。也可以选择在 Trie 中保留单词的副本。因此，我们可能需要 *2N$ 的空间用于 Trie。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个二维网格board和一个字典中的单词列表 words，找出所有同时在二维网格和字典中出现的单词。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Trie" scheme="http://yoursite.com/tags/Trie/"/>
    
  </entry>
  
  <entry>
    <title>Java编程思想-第二十三章 注解阅读笔记</title>
    <link href="http://yoursite.com/2020/06/28/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%89%E7%AB%A0%20%E6%B3%A8%E8%A7%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/06/28/Java编程思想-第二十三章 注解阅读笔记/</id>
    <published>2020-06-28T02:59:12.000Z</published>
    <updated>2020-06-29T06:23:06.841Z</updated>
    
    <content type="html"><![CDATA[<p>接口和抽象类提供了一种将接口与实现分离的更加结构化的方法。</p><a id="more"></a><p>[TOC]</p><!-- Annotations --><h1 id="第二十三章-注解"><a href="#第二十三章-注解" class="headerlink" title="第二十三章 注解"></a>第二十三章 注解</h1><p>注解（也被称为元数据）为我们在代码中添加信息提供了一种形式化的方式，使我们可以在稍后的某个时刻更容易的使用这些数据。</p><p>注解在一定程度上是把元数据和源代码文件结合在一起的趋势所激发的，而不是保存在外部文档。这同样是对像 C# 语言对于 Java 语言特性压力的一种回应。</p><p>注解是 Java 5 所引入的众多语言变化之一。它们提供了 Java 无法表达的但是你需要完整表述程序所需的信息。因此，注解使得我们可以以编译器验证的格式存储程序的额外信息。注解可以生成描述符文件，甚至是新的类定义，并且有助于减轻编写“样板”代码的负担。通过使用注解，你可以将元数据保存在 Java 源代码中。并拥有如下优势：简单易读的代码，编译器类型检查，使用 annotation API 为自己的注解构造处理工具。即使 Java 定义了一些类型的元数据，但是一般来说注解类型的添加和如何使用完全取决于你。</p><p>注解的语法十分简单，主要是在现有语法中添加 @ 符号。Java 5 引入了前三种定义在 <strong>java.lang</strong> 包中的注解：</p><ul><li><strong>@Override</strong>：表示当前的方法定义将覆盖基类的方法。如果你不小心拼写错误，或者方法签名被错误拼写的时候，编译器就会发出错误提示。</li><li><strong>@Deprecated</strong>：如果使用该注解的元素被调用，编译器就会发出警告信息。</li><li><strong>@SuppressWarnings</strong>：关闭不当的编译器警告信息。</li><li><strong>@SafeVarargs</strong>：在 Java 7 中加入用于禁止对具有泛型varargs参数的方法或构造函数的调用方发出警告。</li><li><strong>@FunctionalInterface</strong>：Java 8 中加入用于表示类型声明为函数式接口</li></ul><p>还有 5 种额外的注解类型用于创造新的注解。你将会在这一章学习它们。</p><p>每当创建涉及重复工作的类或接口时，你通常可以使用注解来自动化和简化流程。例如在 Enterprise JavaBean（EJB）中的许多额外工作就是通过注解来消除的。</p><p>注解的出现可以替代一些现有的系统，例如 XDoclet，它是一种独立的文档化工具，专门设计用来生成注解风格的文档。与之相比，注解是真正语言层级的概念，以前构造出来就享有编译器的类型检查保护。注解在源代码级别保存所有信息而不是通过注释文字，这使得代码更加整洁和便于维护。通过使用拓展的 annotation API 或稍后在本章节可以看到的外部的字节码工具类库，你会拥有对源代码及字节码强大的检查与操作能力。</p><!-- Basic Syntax --><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><!-- Writing Annotation Processors --><p>在下面的例子中，使用 <code>@Test</code> 对 <code>testExecute()</code> 进行注解。该注解本身不做任何事情，但是编译器要保证其类路径上有 <code>@Test</code> 注解的定义。你将在本章看到，我们通过注解创建了一个工具用于运行这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/Testable.java</span></span><br><span class="line"><span class="keyword">package</span> annotations;</span><br><span class="line"><span class="keyword">import</span> onjava.atunit.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Testable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Executing.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testExecute</span><span class="params">()</span> </span>&#123; execute(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被注解标注的方法和其他的方法没有任何区别。在这个例子中，注解 <code>@Test</code> 可以和任何修饰符共同用于方法，诸如 <strong>public</strong>、<strong>static</strong> 或 <strong>void</strong>。从语法的角度上看，注解的使用方式和修饰符的使用方式一致。</p><h3 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h3><p>如下是一个注解的定义。注解的定义看起来很像接口的定义。事实上，它们和其他 Java 接口一样，也会被编译成 class 文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/atunit/Test.java</span></span><br><span class="line"><span class="comment">// The @Test tag</span></span><br><span class="line"><span class="keyword">package</span> onjava.atunit;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test &#123;&#125;</span><br></pre></td></tr></table></figure><p>除了 @ 符号之外， <code>@Test</code> 的定义看起来更像一个空接口。注解的定义也需要一些元注解（meta-annoation），比如 <code>@Target</code> 和 <code>@Retention</code>。<code>@Target</code> 定义你的注解可以应用在哪里（例如是方法还是字段）。<code>@Retention</code> 定义了注解在哪里可用，在源代码中（SOURCE），class文件（CLASS）中或者是在运行时（RUNTIME）。</p><p>注解通常会包含一些表示特定值的元素。当分析处理注解的时候，程序或工具可以利用这些值。注解的元素看起来就像接口的方法，但是可以为其指定默认值。</p><p>不包含任何元素的注解称为标记注解（marker annotation），例如上例中的 <code>@Test</code> 就是标记注解。</p><p>下面是一个简单的注解，我们可以用它来追踪项目中的用例。程序员可以使用该注解来标注满足特定用例的一个方法或者一组方法。于是，项目经理可以通过统计已经实现的用例来掌控项目的进展，而开发者在维护项目时可以轻松的找到用例用于更新，或者他们可以调试系统中业务逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/UseCase.java</span></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> UseCase &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">description</span><span class="params">()</span> <span class="keyword">default</span> "no description"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 <strong>id</strong> 和 <strong>description</strong> 与方法定义类似。由于编译器会对 <strong>id</strong> 进行类型检查，因此将跟踪数据库与用例文档和源代码相关联是可靠的方式。<strong>description</strong> 元素拥有一个 <strong>default</strong> 值，如果在注解某个方法时没有给出 <strong>description</strong> 的值。则该注解的处理器会使用此元素的默认值。</p><p>在下面的类中，有三个方法被注解为用例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/PasswordUtils.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PasswordUtils</span> </span>&#123;</span><br><span class="line">    <span class="meta">@UseCase</span>(id = <span class="number">47</span>, description =</span><br><span class="line">            <span class="string">"Passwords must contain at least one numeric"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validatePassword</span><span class="params">(String passwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (passwd.matches(<span class="string">"\\w*\\d\\w*"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@UseCase</span>(id = <span class="number">48</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">encryptPassword</span><span class="params">(String passwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(passwd)</span><br><span class="line">                .reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@UseCase</span>(id = <span class="number">49</span>, description =</span><br><span class="line">            <span class="string">"New passwords can't equal previously used ones"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkForNewPassword</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            List&lt;String&gt; prevPasswords, String passwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !prevPasswords.contains(passwd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解的元素在使用时表现为 名-值 对的形式，并且需要放置在 <code>@UseCase</code> 声明之后的括号内。在 <code>encryptPassword()</code> 方法的注解中，并没有给出 <strong>description</strong> 的值，所以在 <strong>@interface UseCase</strong> 的注解处理器分析处理这个类的时候会使用该元素的默认值。</p><p>你应该能够想象到如何使用这套工具来“勾勒”出将要建造的系统，然后在建造的过程中逐渐实现系统的各项功能。</p><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>Java 语言中目前有 5 种标准注解（前面介绍过），以及 5 种元注解。元注解用于注解其他的注解</p><table><thead><tr><th>注解</th><th>解释</th></tr></thead><tbody><tr><td>@Target</td><td>表示注解可以用于哪些地方。可能的 <strong>ElementType</strong> 参数包括：<br><strong>CONSTRUCTOR</strong>：构造器的声明<br><strong>FIELD</strong>：字段声明（包括 enum 实例）<br><strong>LOCAL_VARIABLE</strong>：局部变量声明<br><strong>METHOD</strong>：方法声明<br><strong>PACKAGE</strong>：包声明<br><strong>PARAMETER</strong>：参数声明<br><strong>TYPE</strong>：类、接口（包括注解类型）或者 enum 声明</td></tr><tr><td>@Retention</td><td>表示注解信息保存的时长。可选的 <strong>RetentionPolicy</strong> 参数包括：<br><strong>SOURCE</strong>：注解将被编译器丢弃<br><strong>CLASS</strong>：注解在 class 文件中可用，但是会被 VM 丢弃。<br><strong>RUNTIME</strong>：VM 将在运行期也保留注解，因此可以通过反射机制读取注解的信息。</td></tr><tr><td>@Documented</td><td>将此注解保存在 Javadoc 中</td></tr><tr><td>@Inherited</td><td>允许子类继承父类的注解</td></tr><tr><td>@Repeatable</td><td>允许一个注解可以被使用一次或者多次（Java 8）。</td></tr></tbody></table><p>大多数时候，程序员定义自己的注解，并编写自己的处理器来处理他们。</p><h2 id="编写注解处理器"><a href="#编写注解处理器" class="headerlink" title="编写注解处理器"></a>编写注解处理器</h2><p>如果没有用于读取注解的工具，那么注解不会比注释更有用。使用注解中一个很重要的部分就是，创建与使用注解处理器。Java 拓展了反射机制的 API 用于帮助你创造这类工具。同时他还提供了 javac 编译器钩子在编译时使用注解。</p><p>下面是一个非常简单的注解处理器，我们用它来读取被注解的 <strong>PasswordUtils</strong> 类，并且使用反射机制来寻找 <strong>@UseCase</strong> 标记。给定一组 <strong>id</strong> 值，然后列出在 <strong>PasswordUtils</strong> 中找到的用例，以及缺失的用例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/UseCaseTracker.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseCaseTracker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">    trackUseCases(List&lt;Integer&gt; useCases, Class&lt;?&gt; cl) &#123;</span><br><span class="line">        <span class="keyword">for</span>(Method m : cl.getDeclaredMethods()) &#123;</span><br><span class="line">            UseCase uc = m.getAnnotation(UseCase.class);</span><br><span class="line">            <span class="keyword">if</span>(uc != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Found Use Case "</span> +</span><br><span class="line">                        uc.id() + <span class="string">"\n "</span> + uc.description());</span><br><span class="line">                useCases.remove(Integer.valueOf(uc.id()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        useCases.forEach(i -&gt;</span><br><span class="line">                System.out.println(<span class="string">"Missing use case "</span> + i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; useCases = IntStream.range(<span class="number">47</span>, <span class="number">51</span>)</span><br><span class="line">                .boxed().collect(Collectors.toList());</span><br><span class="line">        trackUseCases(useCases, PasswordUtils.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Found Use Case <span class="number">48</span></span><br><span class="line">no description</span><br><span class="line">Found Use Case <span class="number">47</span></span><br><span class="line">Passwords must contain at least one numeric</span><br><span class="line">Found Use Case <span class="number">49</span></span><br><span class="line">New passwords can<span class="string">'t equal previously used ones</span></span><br><span class="line"><span class="string">Missing use case 50</span></span><br></pre></td></tr></table></figure><p>这个程序用了两个反射的方法：<code>getDeclaredMethods()</code>  和 <code>getAnnotation()</code>，它们都属于 <strong>AnnotatedElement</strong> 接口（<strong>Class</strong>，<strong>Method</strong> 与 <strong>Field</strong> 类都实现了该接口）。<code>getAnnotation()</code> 方法返回指定类型的注解对象，在本例中就是 “<strong>UseCase</strong>”。如果被注解的方法上没有该类型的注解，返回值就为 <strong>null</strong>。我们通过调用 <code>id()</code> 和 <code>description()</code> 方法来提取元素值。注意 <code>encryptPassword()</code> 方法在注解的时候没有指定 <strong>description</strong> 的值，因此处理器在处理它对应的注解时，通过 <code>description()</code> 取得的是默认值 “no description”。</p><h3 id="注解元素"><a href="#注解元素" class="headerlink" title="注解元素"></a>注解元素</h3><p>在 <strong>UseCase.java</strong> 中定义的 <strong>@UseCase</strong> 的标签包含 int 元素 <strong>id</strong> 和 String 元素 <strong>description</strong>。注解元素可用的类型如下所示：</p><ul><li>所有基本类型（int、float、boolean等）</li><li>String</li><li>Class</li><li>enum</li><li>Annotation</li><li>以上类型的数组</li></ul><p>如果你使用了其他类型，编译器就会报错。注意，也不允许使用任何包装类型，但是由于自动装箱的存在，这不算是什么限制。注解也可以作为元素的类型。稍后你会看到，注解嵌套是一个非常有用的技巧。</p><h3 id="默认值限制"><a href="#默认值限制" class="headerlink" title="默认值限制"></a>默认值限制</h3><p>编译器对于元素的默认值有些过于挑剔。首先，元素不能有不确定的值。也就是说，元素要么有默认值，要么就在使用注解时提供元素的值。</p><p>这里有另外一个限制：任何非基本类型的元素， 无论是在源代码声明时还是在注解接口中定义默认值时，都不能使用 null 作为其值。这个限制使得处理器很难表现一个元素的存在或者缺失的状态，因为在每个注解的声明中，所有的元素都存在，并且具有相应的值。为了绕开这个约束，可以自定义一些特殊的值，比如空字符串或者负数用于表达某个元素不存在。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/SimulatingNull.java</span></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SimulatingNull &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line">    <span class="function">String <span class="title">description</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个在定义注解的习惯用法。</p><h3 id="生成外部文件"><a href="#生成外部文件" class="headerlink" title="生成外部文件"></a>生成外部文件</h3><p>当有些框架需要一些额外的信息才能与你的源代码协同工作，这种情况下注解就会变得十分有用。像 Enterprise JavaBeans (EJB3 之前)这样的技术，每一个 Bean 都需要需要大量的接口和部署描述文件，而这些就是“样板”文件。Web Service，自定义标签库以及对象/关系映射工具（例如 Toplink 和 Hibernate）通常都需要 XML 描述文件，而这些文件脱离于代码之外。除了定义 Java 类，程序员还必须忍受沉闷，重复的提供某些信息，例如类名和包名等已经在原始类中已经提供的信息。每当你使用外部描述文件时，他就拥有了一个类的两个独立信息源，这经常导致代码的同步问题。同时这也要求了为项目工作的程序员在知道如何编写 Java 程序的同时，也必须知道如何编辑描述文件。</p><p>假设你想提供一些基本的对象/关系映射功能，能够自动生成数据库表。你可以使用 XML 描述文件来指明类的名字、每个成员以及数据库映射的相关信息。但是，通过使用注解，你可以把所有信息都保存在 <strong>JavaBean</strong> 源文件中。为此你需要一些用于定义数据库表名称、数据库列以及将 SQL 类型映射到属性的注解。</p><p>以下是一个注解的定义，它告诉注解处理器应该创建一个数据库表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/database/DBTable.java</span></span><br><span class="line"><span class="keyword">package</span> annotations.database;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE) <span class="comment">// Applies to classes only</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DBTable &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>@Target</code> 注解中指定的每一个 <strong>ElementType</strong> 就是一个约束，它告诉编译器，这个自定义的注解只能用于指定的类型。你可以指定 <strong>enum ElementType</strong> 中的一个值，或者以逗号分割的形式指定多个值。如果想要将注解应用于所有的 <strong>ElementType</strong>，那么可以省去 <code>@Target</code> 注解，但是这并不常见。</p><p>注意 <strong>@DBTable</strong> 中有一个 <code>name()</code> 元素，该注解通过这个元素为处理器创建数据库时提供表的名字。</p><p>如下是修饰字段的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/database/Constraints.java</span></span><br><span class="line"><span class="keyword">package</span> annotations.database;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Constraints &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">primaryKey</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">allowNull</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">unique</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/database/SQLString.java</span></span><br><span class="line"><span class="keyword">package</span> annotations.database;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SQLString &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">Constraints <span class="title">constraints</span><span class="params">()</span> <span class="keyword">default</span> @Constraints</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/database/SQLInteger.java</span></span><br><span class="line"><span class="keyword">package</span> annotations.database;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SQLInteger &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">Constraints <span class="title">constraints</span><span class="params">()</span> <span class="keyword">default</span> @Constraints</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@Constraints</strong> 注解允许处理器提供数据库表的元数据。<strong>@Constraints</strong> 代表了数据库通常提供的约束的一小部分，但是它所要表达的思想已经很清楚了。<code>primaryKey()</code>，<code>allowNull()</code> 和 <code>unique()</code> 元素明显的提供了默认值，从而使得在大多数情况下，该注解的使用者不需要输入太多东西。</p><p>另外两个 <strong>@interface</strong> 定义的是 SQL 类型。如果希望这个框架更有价值的话，我们应该为每个 SQL 类型都定义相应的注解。不过为为示例，两个元素足够了。</p><p>这些 SQL 类型具有 <code>name()</code> 元素和 <code>constraints()</code> 元素。后者利用了嵌套注解的功能，将数据库列的类型约束信息嵌入其中。注意 <code>constraints()</code> 元素的默认值是 <strong>@Constraints</strong>。由于在 <strong>@Constraints</strong> 注解类型之后，没有在括号中指明 <strong>@Constraints</strong> 元素的值，因此，<strong>constraints()</strong> 的默认值为所有元素都为默认值的 <strong>@Constraints</strong> 注解。如果要使得嵌入的  <strong>@Constraints</strong>  注解中的 <code>unique()</code> 元素为 true，并作为 <code>constraints()</code> 元素的默认值，你可以像如下定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/database/Uniqueness.java</span></span><br><span class="line"><span class="comment">// Sample of nested annotations</span></span><br><span class="line"><span class="keyword">package</span> annotations.database;</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Uniqueness &#123;</span><br><span class="line">    <span class="function">Constraints <span class="title">constraints</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="keyword">default</span> @<span class="title">Constraints</span><span class="params">(unique = <span class="keyword">true</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个简单的，使用了如上注解的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/database/Member.java</span></span><br><span class="line"><span class="keyword">package</span> annotations.database;</span><br><span class="line"><span class="meta">@DBTable</span>(name = <span class="string">"MEMBER"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SQLString</span>(<span class="number">30</span>) String firstName;</span><br><span class="line">    <span class="meta">@SQLString</span>(<span class="number">50</span>) String lastName;</span><br><span class="line">    <span class="meta">@SQLInteger</span> Integer age;</span><br><span class="line">    <span class="meta">@SQLString</span>(value = <span class="number">30</span>,</span><br><span class="line">            constraints = <span class="meta">@Constraints</span>(primaryKey = <span class="keyword">true</span>))</span><br><span class="line">    String reference;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> memberCount;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getReference</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> reference; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> firstName; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> lastName; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> reference; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类注解 <strong>@DBTable</strong> 注解给定了元素值 MEMBER，它将会作为标的名字。类的属性 <strong>firstName</strong> 和 <strong>lastName</strong> 都被注解为 <strong>@SQLString</strong> 类型并且给了默认元素值分别为 30 和 50。这些注解都有两个有趣的地方：首先，他们都使用了嵌入的 <strong>@Constraints</strong> 注解的默认值；其次，它们都是用了快捷方式特性。如果你在注解中定义了名为 <strong>value</strong> 的元素，并且在使用该注解时，<strong>value</strong> 为唯一一个需要赋值的元素，你就不需要使用名—值对的语法，你只需要在括号中给出 <strong>value</strong> 元素的值即可。这可以应用于任何合法类型的元素。这也限制了你必须将元素命名为 <strong>value</strong>，不过在上面的例子中，这样的注解语句也更易于理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SQLString</span>(<span class="number">30</span>)</span><br></pre></td></tr></table></figure><p>处理器将在创建表的时候使用该值设置 SQL 列的大小。</p><p>默认值的语法虽然很灵巧，但是它很快就变的复杂起来。以 <strong>reference</strong> 字段的注解为例，上面拥有 <strong>@SQLString</strong> 注解，但是这个字段也将成为表的主键，因此在嵌入的 <strong>@Constraint</strong> 注解中设定 <strong>primaryKey</strong> 元素的值。这时事情就变的复杂了。你不得不为这个嵌入的注解使用很长的键—值对的形式，来指定元素名称和 <strong>@interface</strong> 的名称。同时，由于有特殊命名的 <strong>value</strong> 也不是唯一需要赋值的元素，因此不能再使用快捷方式特性。如你所见，最终结果不算清晰易懂。</p><h3 id="替代方案"><a href="#替代方案" class="headerlink" title="替代方案"></a>替代方案</h3><p>可以使用多种不同的方式来定义自己的注解用于上述任务。例如，你可以使用一个单一的注解类 <strong>@TableColumn</strong>，它拥有一个 <strong>enum</strong> 元素，元素值定义了 <strong>STRING</strong>，<strong>INTEGER</strong>，<strong>FLOAT</strong> 等类型。这消除了每个 SQL 类型都需要定义一个 <strong>@interface</strong> 的负担，不过也使得用额外信息修饰 SQL 类型变的不可能，这些额外的信息例如长度或精度等，都可能是非常有用的。</p><p>你也可以使用一个 <strong>String</strong> 类型的元素来描述实际的 SQL 类型，比如 “VARCHAR(30)” 或者 “INTEGER”。这使得你可以修饰 SQL 类型，但是这也将 Java 类型到 SQL 类型的映射绑在了一起，这不是一个好的设计。你并不想在数据库更改之后重新编译你的代码；如果我们只需要告诉注解处理器，我们正在使用的是什么“口味（favor）”的 SQL，然后注解助力器来为我们处理 SQL 类型的细节，那将是一个优雅的设计。</p><p>第三种可行的方案是一起使用两个注解，<strong>@Constraints</strong> 和相应的 SQL 类型（例如，<strong>@SQLInteger</strong>）去注解同一个字段。这可能会让代码有些混乱，但是编译器允许你对同一个目标使用多个注解。在 Java 8，在使用多个注解的时候，你可以重复使用同一个注解。</p><h3 id="注解不支持继承"><a href="#注解不支持继承" class="headerlink" title="注解不支持继承"></a>注解不支持继承</h3><p>你不能使用 <strong>extends</strong> 关键字来继承 <strong>@interfaces</strong>。这真是一个遗憾，如果可以定义 <strong>@TableColumn</strong> 注解（参考前面的建议），同时嵌套一个 <strong>@SQLType</strong> 类型的注解，将成为一个优雅的设计。按照这种方式，你可以通过继承 <strong>@SQLType</strong> 来创造各种 SQL 类型。例如 <strong>@SQLInteger</strong> 和 <strong>@SQLString</strong>。如果支持继承，就会大大减少打字的工作量并且使得语法更整洁。在 Java 的未来版本中，似乎没有任何关于让注解支持继承的提案，所以在当前情况下，上例中的解决方案可能已经是最佳方案了。</p><h3 id="实现处理器"><a href="#实现处理器" class="headerlink" title="实现处理器"></a>实现处理器</h3><p>下面是一个注解处理器的例子，他将读取一个类文件，检查上面的数据库注解，并生成用于创建数据库的 SQL 命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/database/TableCreator.java</span></span><br><span class="line"><span class="comment">// Reflection-based annotation processor</span></span><br><span class="line"><span class="comment">// &#123;java annotations.database.TableCreator</span></span><br><span class="line"><span class="comment">// annotations.database.Member&#125;</span></span><br><span class="line"><span class="keyword">package</span> annotations.database;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TableCreator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">    main(String[] args) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(</span><br><span class="line">                    <span class="string">"arguments: annotated classes"</span>);</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String className : args) &#123;</span><br><span class="line">            Class&lt;?&gt; cl = Class.forName(className);</span><br><span class="line">            DBTable dbTable = cl.getAnnotation(DBTable.class);</span><br><span class="line">            <span class="keyword">if</span> (dbTable == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(</span><br><span class="line">                        <span class="string">"No DBTable annotations in class "</span> +</span><br><span class="line">                                className);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String tableName = dbTable.name();</span><br><span class="line">            <span class="comment">// If the name is empty, use the Class name:</span></span><br><span class="line">            <span class="keyword">if</span> (tableName.length() &lt; <span class="number">1</span>)</span><br><span class="line">                tableName = cl.getName().toUpperCase();</span><br><span class="line">            List&lt;String&gt; columnDefs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (Field field : cl.getDeclaredFields()) &#123;</span><br><span class="line">                String columnName = <span class="keyword">null</span>;</span><br><span class="line">                Annotation[] anns =</span><br><span class="line">                        field.getDeclaredAnnotations();</span><br><span class="line">                <span class="keyword">if</span> (anns.length &lt; <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// Not a db table column</span></span><br><span class="line">                <span class="keyword">if</span> (anns[<span class="number">0</span>] <span class="keyword">instanceof</span> SQLInteger) &#123;</span><br><span class="line">                    SQLInteger sInt = (SQLInteger) anns[<span class="number">0</span>];</span><br><span class="line">                    <span class="comment">// Use field name if name not specified</span></span><br><span class="line">                    <span class="keyword">if</span> (sInt.name().length() &lt; <span class="number">1</span>)</span><br><span class="line">                        columnName = field.getName().toUpperCase();</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        columnName = sInt.name();</span><br><span class="line">                    columnDefs.add(columnName + <span class="string">" INT"</span> +</span><br><span class="line">                            getConstraints(sInt.constraints()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (anns[<span class="number">0</span>] <span class="keyword">instanceof</span> SQLString) &#123;</span><br><span class="line">                    SQLString sString = (SQLString) anns[<span class="number">0</span>];</span><br><span class="line">                    <span class="comment">// Use field name if name not specified.</span></span><br><span class="line">                    <span class="keyword">if</span> (sString.name().length() &lt; <span class="number">1</span>)</span><br><span class="line">                        columnName = field.getName().toUpperCase();</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        columnName = sString.name();</span><br><span class="line">                    columnDefs.add(columnName + <span class="string">" VARCHAR("</span> +</span><br><span class="line">                            sString.value() + <span class="string">")"</span> +</span><br><span class="line">                            getConstraints(sString.constraints()));</span><br><span class="line">                &#125;</span><br><span class="line">                StringBuilder createCommand = <span class="keyword">new</span> StringBuilder(</span><br><span class="line">                        <span class="string">"CREATE TABLE "</span> + tableName + <span class="string">"("</span>);</span><br><span class="line">                <span class="keyword">for</span> (String columnDef : columnDefs)</span><br><span class="line">                    createCommand.append(</span><br><span class="line">                            <span class="string">"\n "</span> + columnDef + <span class="string">","</span>);</span><br><span class="line">                <span class="comment">// Remove trailing comma</span></span><br><span class="line">                String tableCreate = createCommand.substring(</span><br><span class="line">                        <span class="number">0</span>, createCommand.length() - <span class="number">1</span>) + <span class="string">");"</span>;</span><br><span class="line">                System.out.println(<span class="string">"Table Creation SQL for "</span> +</span><br><span class="line">                        className + <span class="string">" is:\n"</span> + tableCreate);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getConstraints</span><span class="params">(Constraints con)</span> </span>&#123;</span><br><span class="line">        String constraints = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span> (!con.allowNull())</span><br><span class="line">            constraints += <span class="string">" NOT NULL"</span>;</span><br><span class="line">        <span class="keyword">if</span> (con.primaryKey())</span><br><span class="line">            constraints += <span class="string">" PRIMARY KEY"</span>;</span><br><span class="line">        <span class="keyword">if</span> (con.unique())</span><br><span class="line">            constraints += <span class="string">" UNIQUE"</span>;</span><br><span class="line">        <span class="keyword">return</span> constraints;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Table Creation SQL for annotations.database.Member is:</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">MEMBER</span>(</span><br><span class="line">    FIRSTNAME <span class="built_in">VARCHAR</span>(<span class="number">30</span>));</span><br><span class="line">Table Creation SQL for annotations.database.Member is:</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">MEMBER</span>(</span><br><span class="line">    FIRSTNAME <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">    LASTNAME <span class="built_in">VARCHAR</span>(<span class="number">50</span>));</span><br><span class="line">Table Creation SQL for annotations.database.Member is:</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">MEMBER</span>(</span><br><span class="line">    FIRSTNAME <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">    LASTNAME <span class="built_in">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    AGE <span class="built_in">INT</span>);</span><br><span class="line">Table Creation SQL for annotations.database.Member is:</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">MEMBER</span>(</span><br><span class="line">    FIRSTNAME <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">    LASTNAME <span class="built_in">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    AGE <span class="built_in">INT</span>,</span><br><span class="line">    <span class="keyword">REFERENCE</span> <span class="built_in">VARCHAR</span>(<span class="number">30</span>) PRIMARY <span class="keyword">KEY</span>);</span><br></pre></td></tr></table></figure><p>主方法会循环处理命令行传入的每一个类名。每一个类都是用 <code>forName()</code> 方法进行加载，并使用 <code>getAnnotation(DBTable.class)</code> 来检查该类是否带有 <strong>@DBTable</strong> 注解。如果存在，将表名存储起来。然后读取这个类的所有字段，并使用 <code>getDeclaredAnnotations()</code> 进行检查。这个方法返回一个包含特定字段上所有注解的数组。然后使用 <strong>instanceof</strong> 操作符判断这些注解是否是 <strong>@SQLInteger</strong> 或者 <strong>@SQLString</strong> 类型。如果是的话，在对应的处理块中将构造出相应的数据库列的字符串片段。注意，由于注解没有继承机制，如果要获取近似多态的行为，使用 <code>getDeclaredAnnotations()</code> 似乎是唯一的方式。</p><p>嵌套的 <strong>@Constraint</strong> 注解被传递给 <code>getConstraints()</code>方法，并用它来构造一个包含 SQL 约束的 String 对象。</p><p>需要提醒的是，上面演示的技巧对于真实的对象/映射关系而言，是十分幼稚的。使用 <strong>@DBTable</strong> 的注解来获取表的名称，这使得如果要修改表的名字，则迫使你重新编译 Java 代码。这种效果并不理想。现在已经有了很多可用的框架，用于将对象映射到数据库中，并且越来越多的框架开始使用注解了。</p><!-- Using javac to Process Annotations --><h2 id="使用javac处理注解"><a href="#使用javac处理注解" class="headerlink" title="使用javac处理注解"></a>使用javac处理注解</h2><p>通过 <strong>javac</strong>，你可以通过创建编译时（compile-time）注解处理器在 Java 源文件上使用注解，而不是编译之后的 class 文件。但是这里有一个重大限制：你不能通过处理器来改变源代码。唯一影响输出的方式就是创建新的文件。</p><p>如果你的注解处理器创建了新的源文件，在新一轮处理中注解会检查源文件本身。工具在检测一轮之后持续循环，直到不再有新的源文件产生。然后它编译所有的源文件。</p><p>每一个你编写的注解都需要处理器，但是 <strong>javac</strong> 可以非常容易的将多个注解处理器合并在一起。你可以指定多个需要处理的类，并且你可以添加监听器用于监听注解处理完成后接到通知。</p><p>本节中的示例将帮助你开始学习，但如果你必须深入学习，请做好反复学习，大量访问 Google 和StackOverflow 的准备。</p><h3 id="最简单的处理器"><a href="#最简单的处理器" class="headerlink" title="最简单的处理器"></a>最简单的处理器</h3><p>让我们开始定义我们能想到的最简单的处理器，只是为了编译和测试。如下是注解的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/simplest/Simple.java</span></span><br><span class="line"><span class="comment">// A bare-bones annotation</span></span><br><span class="line"><span class="keyword">package</span> annotations.simplest;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD,</span><br><span class="line">        ElementType.CONSTRUCTOR,</span><br><span class="line">        ElementType.ANNOTATION_TYPE,</span><br><span class="line">        ElementType.PACKAGE, ElementType.FIELD,</span><br><span class="line">        ElementType.LOCAL_VARIABLE&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Simple &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> "-<span class="keyword">default</span>-"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@Retention</strong> 的参数现在为 <strong>SOURCE</strong>，这意味着注解不会再存留在编译后的代码。这在编译时处理注解是没有必要的，它只是指出，在这里，<strong>javac</strong> 是唯一有机会处理注解的代理。</p><p><strong>@Target</strong> 声明了几乎所有的目标类型（除了 <strong>PACKAGE</strong>） ，同样是为了演示。下面是一个测试示例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/simplest/SimpleTest.java</span></span><br><span class="line"><span class="comment">// Test the "Simple" annotation</span></span><br><span class="line"><span class="comment">// &#123;java annotations.simplest.SimpleTest&#125;</span></span><br><span class="line"><span class="keyword">package</span> annotations.simplest;</span><br><span class="line"><span class="meta">@Simple</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Simple</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="meta">@Simple</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleTest</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Simple</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SimpleTest.foo()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Simple</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(String s, <span class="keyword">int</span> i, <span class="keyword">float</span> f)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SimpleTest.bar()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Simple</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Simple</span></span><br><span class="line">        SimpleTest st = <span class="keyword">new</span> SimpleTest();</span><br><span class="line">        st.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SimpleTest.foo()</span><br></pre></td></tr></table></figure><p>在这里我们使用 <strong>@Simple</strong> 注解了所有 <strong>@Target</strong> 声明允许的地方。</p><p><strong>SimpleTest.java</strong> 只需要 <strong>Simple.java</strong> 就可以编译成功。当我们编译的时候什么都没有发生。</p><p><strong>javac</strong> 允许 <strong>@Simple</strong> 注解（只要它存在）在我们创建处理器并将其 hook 到编译器之前，不做任何事情。</p><p>如下是一个十分简单的处理器，其所作的事情就是把注解相关的信息打印出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/simplest/SimpleProcessor.java</span></span><br><span class="line"><span class="comment">// A bare-bones annotation processor</span></span><br><span class="line"><span class="keyword">package</span> annotations.simplest;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.processing.*;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.SourceVersion;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="meta">@SupportedAnnotationTypes</span>(</span><br><span class="line">        <span class="string">"annotations.simplest.Simple"</span>)</span><br><span class="line"><span class="meta">@SupportedSourceVersion</span>(SourceVersion.RELEASE_8)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleProcessor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Set&lt;? extends TypeElement&gt; annotations,</span></span></span><br><span class="line"><span class="function"><span class="params">            RoundEnvironment env)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(TypeElement t : annotations)</span><br><span class="line">            System.out.println(t);</span><br><span class="line">        <span class="keyword">for</span>(Element el :</span><br><span class="line">                env.getElementsAnnotatedWith(Simple.class))</span><br><span class="line">            display(el);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Element el)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==== "</span> + el + <span class="string">" ===="</span>);</span><br><span class="line">        System.out.println(el.getKind() +</span><br><span class="line">                <span class="string">" : "</span> + el.getModifiers() +</span><br><span class="line">                <span class="string">" : "</span> + el.getSimpleName() +</span><br><span class="line">                <span class="string">" : "</span> + el.asType());</span><br><span class="line">        <span class="keyword">if</span>(el.getKind().equals(ElementKind.CLASS)) &#123;</span><br><span class="line">            TypeElement te = (TypeElement)el;</span><br><span class="line">            System.out.println(te.getQualifiedName());</span><br><span class="line">            System.out.println(te.getSuperclass());</span><br><span class="line">            System.out.println(te.getEnclosedElements());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(el.getKind().equals(ElementKind.METHOD)) &#123;</span><br><span class="line">            ExecutableElement ex = (ExecutableElement)el;</span><br><span class="line">            System.out.print(ex.getReturnType() + <span class="string">" "</span>);</span><br><span class="line">            System.out.print(ex.getSimpleName() + <span class="string">"("</span>);</span><br><span class="line">            System.out.println(ex.getParameters() + <span class="string">")"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（旧的，失效的）<strong>apt</strong> 版本的处理器需要额外的方法来确定支持哪些注解以及支持的 Java 版本。不过，你现在可以简单的使用 <strong>@SupportedAnnotationTypes</strong> 和 <strong>@SupportedSourceVersion</strong> 注解（这是一个很好的示例关于注解如何简化你的代码）。</p><p>你唯一需要实现的方法就是 <code>process()</code>，这里是所有行为发生的地方。第一个参数告诉你哪个注解是存在的，第二个参数保留了剩余信息。我们所做的事情只是打印了注解（这里只存在一个），可以看 <strong>TypeElement</strong> 文档中的其他行为。通过使用 <code>process()</code> 的第二个操作，我们循环所有被 <strong>@Simple</strong> 注解的元素，并且针对每一个元素调用我们的 <code>display()</code> 方法。所有 <strong>Element</strong> 展示了本身的基本信息；例如，<code>getModifiers()</code> 告诉你它是否为 <strong>public</strong> 和 <strong>static</strong> 的。</p><p><strong>Element</strong> 只能执行那些编译器解析的所有基本对象共有的操作，而类和方法之类的东西有额外的信息需要提取。所以（如果你阅读了正确的文档，但是我没有在任何文档中找到——我不得不通过 StackOverflow 寻找线索）你检查它是哪种 <strong>ElementKind</strong>，然后将其向下转换为更具体的元素类型，注入针对 CLASS 的 TypeElement 和 针对 METHOD 的ExecutableElement。此时，可以为这些元素调用其他方法。</p><p>动态向下转型（在编译期不进行检查）并不像是 Java 的做事方式，这非常不直观这也是为什么我从未想过要这样做事。相反，我花了好几天的时间，试图发现你应该如何访问这些信息，而这些信息至少在某种程度上是用不起作用的恰当方法简单明了的。我还没有遇到任何东西说上面是规范的形式，但在我看来是。</p><p>如果只是通过平常的方式来编译 <strong>SimpleTest.java</strong>，你不会得到任何结果。为了得到注解输出，你必须增加一个 <strong>processor</strong> 标志并且连接注解处理器类</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -processor annotations.simplest.SimpleProcessor SimpleTest.java</span><br></pre></td></tr></table></figure><p>现在编译器有了输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">annotations.simplest.Simple</span><br><span class="line">==== annotations.simplest.SimpleTest ====</span><br><span class="line">CLASS : [public] : SimpleTest : annotations.simplest.SimpleTest</span><br><span class="line">annotations.simplest.SimpleTest</span><br><span class="line">java.lang.Object</span><br><span class="line">i,SimpleTest(),foo(),bar(java.lang.String,int,float),main(java.lang.String[])</span><br><span class="line">==== i ====</span><br><span class="line">FIELD : [] : i : int</span><br><span class="line">==== SimpleTest() ====</span><br><span class="line">CONSTRUCTOR : [public] : &lt;init&gt; : ()void</span><br><span class="line">==== foo() ====</span><br><span class="line">METHOD : [public] : foo : ()void</span><br><span class="line">void foo()</span><br><span class="line">==== bar(java.lang.String,int,float) ====</span><br><span class="line">METHOD : [public] : bar : (java.lang.String,int,float)void</span><br><span class="line">void bar(s,i,f)</span><br><span class="line">==== main(java.lang.String[]) ====</span><br><span class="line">METHOD : [public, static] : main : (java.lang.String[])void</span><br><span class="line">void main(args)</span><br></pre></td></tr></table></figure><p>这给了你一些可以发现的东西，包括参数名和类型、返回值等。</p><h3 id="更复杂的处理器"><a href="#更复杂的处理器" class="headerlink" title="更复杂的处理器"></a>更复杂的处理器</h3><p>当你创建用于 javac 注解处理器时，你不能使用 Java 的反射特性，因为你处理的是源代码，而并非是编译后的 class 文件。各种 mirror[^3 ] 解决这个问题的方法是，通过允许你在未编译的源代码中查看方法、字段和类型。</p><p>如下是一个用于提取类中方法的注解，所以它可以被抽取成为一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/ifx/ExtractInterface.java</span></span><br><span class="line"><span class="comment">// javac-based annotation processing</span></span><br><span class="line"><span class="keyword">package</span> annotations.ifx;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ExtractInterface &#123;</span><br><span class="line">    <span class="function">String <span class="title">interfaceName</span><span class="params">()</span> <span class="keyword">default</span> "-!!-"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>RetentionPolicy</strong> 的值为 <strong>SOURCE</strong>，这是为了在提取类中的接口之后不再将注解信息保留在 class 文件中。接下来的测试类提供了一些公用方法，这些方法可以成为接口的一部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/ifx/Multiplier.java</span></span><br><span class="line"><span class="comment">// javac-based annotation processing</span></span><br><span class="line"><span class="comment">// &#123;java annotations.ifx.Multiplier&#125;</span></span><br><span class="line"><span class="keyword">package</span> annotations.ifx;</span><br><span class="line"><span class="meta">@ExtractInterface</span>(interfaceName=<span class="string">"IMultiplier"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Multiplier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x; i++)</span><br><span class="line">            total = add(total, y);</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fortySeven</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">47</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">timesTen</span><span class="params">(<span class="keyword">double</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arg * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Multiplier m = <span class="keyword">new</span> Multiplier();</span><br><span class="line">        System.out.println(</span><br><span class="line">                <span class="string">"11 * 16 = "</span> + m.multiply(<span class="number">11</span>, <span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span> * <span class="number">16</span> = <span class="number">176</span></span><br></pre></td></tr></table></figure><p><strong>Multiplier</strong> 类（只能处理正整数）拥有一个 <code>multiply()</code> 方法，这个方法会多次调用私有方法 <code>add()</code> 来模拟乘法操作。<code>add()</code> 是私有方法，因此不能成为接口的一部分。其他的方法提供了语法多样性。注解被赋予 <strong>IMultiplier</strong> 的 <strong>InterfaceName</strong> 作为要创建的接口的名称。</p><p>这里有一个编译时处理器用于提取有趣的方法，并创建一个新的 interface 源代码文件（这个源文件将会在下一轮中被自动编译）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/ifx/IfaceExtractorProcessor.java</span></span><br><span class="line"><span class="comment">// javac-based annotation processing</span></span><br><span class="line"><span class="keyword">package</span> annotations.ifx;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.processing.*;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.SourceVersion;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.*;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="meta">@SupportedAnnotationTypes</span>(</span><br><span class="line">        <span class="string">"annotations.ifx.ExtractInterface"</span>)</span><br><span class="line"><span class="meta">@SupportedSourceVersion</span>(SourceVersion.RELEASE_8)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IfaceExtractorProcessor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Element&gt;</span><br><span class="line">            interfaceMethods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Elements elementUtils;</span><br><span class="line">    <span class="keyword">private</span> ProcessingEnvironment processingEnv;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ProcessingEnvironment processingEnv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.processingEnv = processingEnv;</span><br><span class="line">        elementUtils = processingEnv.getElementUtils();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Set&lt;? extends TypeElement&gt; annotations,</span></span></span><br><span class="line"><span class="function"><span class="params">            RoundEnvironment env)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Element elem:env.getElementsAnnotatedWith(</span><br><span class="line">                ExtractInterface.class)) &#123;</span><br><span class="line">            String interfaceName = elem.getAnnotation(</span><br><span class="line">                    ExtractInterface.class).interfaceName();</span><br><span class="line">            <span class="keyword">for</span>(Element enclosed :</span><br><span class="line">                    elem.getEnclosedElements()) &#123;</span><br><span class="line">                <span class="keyword">if</span>(enclosed.getKind()</span><br><span class="line">                        .equals(ElementKind.METHOD) &amp;&amp;</span><br><span class="line">                        enclosed.getModifiers()</span><br><span class="line">                                .contains(Modifier.PUBLIC) &amp;&amp;</span><br><span class="line">                        !enclosed.getModifiers()</span><br><span class="line">                                .contains(Modifier.STATIC)) &#123;</span><br><span class="line">                    interfaceMethods.add(enclosed);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(interfaceMethods.size() &gt; <span class="number">0</span>)</span><br><span class="line">                writeInterfaceFile(interfaceName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span></span><br><span class="line">    writeInterfaceFile(String interfaceName) &#123;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">                Writer writer = processingEnv.getFiler()</span><br><span class="line">                        .createSourceFile(interfaceName)</span><br><span class="line">                        .openWriter()</span><br><span class="line">        ) &#123;</span><br><span class="line">            String packageName = elementUtils</span><br><span class="line">                    .getPackageOf(interfaceMethods</span><br><span class="line">                            .get(<span class="number">0</span>)).toString();</span><br><span class="line">            writer.write(</span><br><span class="line">                    <span class="string">"package "</span> + packageName + <span class="string">";\n"</span>);</span><br><span class="line">            writer.write(<span class="string">"public interface "</span> +</span><br><span class="line">                    interfaceName + <span class="string">" &#123;\n"</span>);</span><br><span class="line">            <span class="keyword">for</span>(Element elem : interfaceMethods) &#123;</span><br><span class="line">                ExecutableElement method =</span><br><span class="line">                        (ExecutableElement)elem;</span><br><span class="line">                String signature = <span class="string">" public "</span>;</span><br><span class="line">                signature += method.getReturnType() + <span class="string">" "</span>;</span><br><span class="line">                signature += method.getSimpleName();</span><br><span class="line">                signature += createArgList(</span><br><span class="line">                        method.getParameters());</span><br><span class="line">                System.out.println(signature);</span><br><span class="line">                writer.write(signature + <span class="string">";\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            writer.write(<span class="string">"&#125;"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">createArgList</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            List&lt;? extends VariableElement&gt; parameters)</span> </span>&#123;</span><br><span class="line">        String args = parameters.stream()</span><br><span class="line">                .map(p -&gt; p.asType() + <span class="string">" "</span> + p.getSimpleName())</span><br><span class="line">                .collect(Collectors.joining(<span class="string">", "</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"("</span> + args + <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Elements</strong> 对象实例 <strong>elementUtils</strong> 是一组静态方法的工具；我们用它来寻找 <strong>writeInterfaceFile()</strong> 中含有的包名。</p><p><code>getEnclosedElements()</code>方法会通过指定的元素生成所有的“闭包”元素。在这里，这个类闭包了它的所有元素。通过使用 <code>getKind()</code> 我们会找到所有的 <strong>public</strong> 和 <strong>static</strong> 方法，并将其添加到 <strong>interfaceMethods</strong> 列表中。接下来 <code>writeInterfaceFile()</code> 使用 <strong>interfaceMethods</strong> 列表里面的值生成新的接口定义。注意，在 <code>writeInterfaceFile()</code> 使用了向下转型到 <strong>ExecutableElement</strong>，这使得我们可以获取所有的方法信息。<strong>createArgList()</strong> 是一个帮助方法，用于生成参数列表。</p><p><strong>Filer</strong>是 <code>getFiler()</code> 生成的，并且是 <strong>PrintWriter</strong> 的一种实例，可以用于创建新文件。我们使用 <strong>Filer</strong> 对象，而不是原生的 <strong>PrintWriter</strong> 原因是，这个对象可以运行 <strong>javac</strong> 追踪你创建的新文件，这使得它可以在新一轮中检查新文件中的注解并编译文件。</p><p>如下是一个命令行，可以在编译的时候使用处理器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -processor annotations.ifx.IfaceExtractorProcessor Multiplier.java</span><br></pre></td></tr></table></figure><p>新生成的 <strong>IMultiplier.java</strong> 的文件，正如你通过查看上面处理器的 <code>println()</code> 语句所猜测的那样，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> annotations.ifx;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMultiplier</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fortySeven</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">timesTen</span><span class="params">(<span class="keyword">double</span> arg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类同样会被 <strong>javac</strong> 编译（在某一轮中），所以你会在同一个目录中看到 <strong>IMultiplier.class</strong> 文件。</p><!-- Annotation-Based Unit Testing --><h2 id="基于注解的单元测试"><a href="#基于注解的单元测试" class="headerlink" title="基于注解的单元测试"></a>基于注解的单元测试</h2><p>单元测试是对类中每个方法提供一个或者多个测试的一种事件，其目的是为了有规律的测试一个类中每个部分是否具备正确的行为。在 Java 中，最著名的单元测试工具就是 <strong>JUnit</strong>。<strong>JUnit</strong> 4 版本已经包含了注解。在注解版本之前的 JUnit 一个最主要的问题是，为了启动和运行 <strong>JUnit</strong> 测试，有大量的“仪式”需要标注。这种负担已经减轻了一些，<strong>但是</strong>注解使得测试更接近“可以工作的最简单的测试系统”。</p><p>在注解版本之前的 JUnit，你必须创建一个单独的文件来保存单元测试。通过注解，我们可以将单元测试集成在需要被测试的类中，从而将单元测试的时间和麻烦降到了最低。这种方式有额外的好处，就是使得测试私有方法和公有方法变的一样容易。</p><p>这个基于注解的测试框架叫做 <strong>@Unit</strong>。其最基本的测试形式，可能也是你使用的最多的一个注解是 <strong>@Test</strong>，我们使用 <strong>@Test</strong> 来标记测试方法。测试方法不带参数，并返回 <strong>boolean</strong> 结果来说明测试方法成功或者失败。你可以任意命名它的测试方法。同时 <strong>@Unit</strong> 测试方法可以是任意你喜欢的访问修饰方法，包括 <strong>private</strong>。</p><p>要使用 <strong>@Unit</strong>，你必须导入 <strong>onjava.atunit</strong> 包，并且使用 <strong>@Unit</strong> 的测试标记为合适的方法和字段打上标签（在接下来的例子中你会学到），然后让你的构建系统对编译后的类运行 <strong>@Unit</strong>，下面是一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/AtUnitExample1.java</span></span><br><span class="line"><span class="comment">// &#123;java onjava.atunit.AtUnit</span></span><br><span class="line"><span class="comment">// build/classes/main/annotations/AtUnitExample1.class&#125;</span></span><br><span class="line"><span class="keyword">package</span> annotations;</span><br><span class="line"><span class="keyword">import</span> onjava.atunit.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtUnitExample1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">methodOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"This is methodOne"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">methodTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is methodTwo"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">methodOneTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> methodOne().equals(<span class="string">"This is methodOne"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">m2</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> methodTwo() == <span class="number">2</span>; &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">m3</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">true</span>; &#125;</span><br><span class="line">    <span class="comment">// Shows output for failure:</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">failureTest</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">false</span>; &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">anotherDisappointment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">annotations.AtUnitExample1</span><br><span class="line">. m3</span><br><span class="line">. methodOneTest</span><br><span class="line">. m2 This is methodTwo</span><br><span class="line">. failureTest (failed)</span><br><span class="line">. anotherDisappointment (failed)</span><br><span class="line">(<span class="number">5</span> tests)</span><br><span class="line">&gt;&gt;&gt; <span class="number">2</span> FAILURES &lt;&lt;&lt;</span><br><span class="line">annotations.AtUnitExample1: failureTest</span><br><span class="line">annotations.AtUnitExample1: anotherDisappointment</span><br></pre></td></tr></table></figure><p>使用 <strong>@Unit</strong> 进行测试的类必须定义在某个包中（即必须包括 <strong>package</strong> 声明）。</p><p><strong>@Test</strong> 注解被置于 <code>methodOneTest()</code>、 <code>m2()</code>、<code>m3()</code>、<code>failureTest()</code> 以及 a<code>notherDisappointment()</code> 方法之前，它们告诉 <strong>@Unit</strong> 方法作为单元测试来运行。同时 <strong>@Test</strong> 确保这些方法没有任何参数并且返回值为 <strong>boolean</strong> 或者 <strong>void</strong>。当你填写单元测试时，唯一需要做的就是决定测试是成功还是失败，（对于返回值为 <strong>boolean</strong> 的方法）应该返回 <strong>ture</strong> 还是 <strong>false</strong>。</p><p>如果你熟悉 <strong>JUnit</strong>，你还将注意到 <strong>@Unit</strong> 输出的信息更多。你会看到现在正在运行的测试的输出更有用，最后它会告诉你导致失败的类和测试。</p><p>你并非必须将测试方法嵌入到原来的类中，有时候这种事情根本做不到。要生产一个非嵌入式的测试，最简单的方式就是继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/AUExternalTest.java</span></span><br><span class="line"><span class="comment">// Creating non-embedded tests</span></span><br><span class="line"><span class="comment">// &#123;java onjava.atunit.AtUnit</span></span><br><span class="line"><span class="comment">// build/classes/main/annotations/AUExternalTest.class&#125;</span></span><br><span class="line"><span class="keyword">package</span> annotations;</span><br><span class="line"><span class="keyword">import</span> onjava.atunit.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AUExternalTest</span> <span class="keyword">extends</span> <span class="title">AtUnitExample1</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">_MethodOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> methodOne().equals(<span class="string">"This is methodOne"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">_MethodTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> methodTwo() == <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">annotations.AUExternalTest</span><br><span class="line">. tMethodOne</span><br><span class="line">. tMethodTwo This is methodTwo</span><br><span class="line">OK (<span class="number">2</span> tests)</span><br></pre></td></tr></table></figure><p>这个示例还表现出灵活命名的价值。在这里，<strong>@Test</strong> 方法被命名为下划线前缀加上要测试的方法名称（我并不认为这是一种理想的命名形式，这只是表现一种可能性罢了）。</p><p>你也可以使用组合来创建非嵌入式的测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/AUComposition.java</span></span><br><span class="line"><span class="comment">// Creating non-embedded tests</span></span><br><span class="line"><span class="comment">// &#123;java onjava.atunit.AtUnit</span></span><br><span class="line"><span class="comment">// build/classes/main/annotations/AUComposition.class&#125;</span></span><br><span class="line"><span class="keyword">package</span> annotations;</span><br><span class="line"><span class="keyword">import</span> onjava.atunit.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AUComposition</span> </span>&#123;</span><br><span class="line">    AtUnitExample1 testObject = <span class="keyword">new</span> AtUnitExample1();</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tMethodOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> testObject.methodOne()</span><br><span class="line">                .equals(<span class="string">"This is methodOne"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tMethodTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> testObject.methodTwo() == <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">annotations.AUComposition</span><br><span class="line">. tMethodTwo This is methodTwo</span><br><span class="line">. tMethodOne</span><br><span class="line">OK (<span class="number">2</span> tests)</span><br></pre></td></tr></table></figure><p>因为在每一个测试里面都会创建 <strong>AUComposition</strong> 对象，所以创建新的成员变量 <strong>testObject</strong> 用于以后的每一个测试方法。</p><p>因为 <strong>@Unit</strong> 中没有 <strong>JUnit</strong> 中特殊的 <strong>assert</strong> 方法，不过另一种形式的 <strong>@Test</strong> 方法仍然允许返回值为 <strong>void</strong>（如果你还想使用 <strong>true</strong> 或者 <strong>false</strong> 的话，也可以使用 <strong>boolean</strong> 作为方法返回值类型）。为了表示测试成功，可以使用 Java 的 <strong>assert</strong> 语句。Java 断言机制需要你在 java 命令行行加上 <strong>-ea</strong> 标志来开启，但是 <strong>@Unit</strong> 已经自动开启了该功能。要表示测试失败的话，你甚至可以使用异常。<strong>@Unit</strong> 的设计目标之一就是尽可能减少添加额外的语法，而 Java 的 <strong>assert</strong> 和异常对于报告错误而言，即已经足够了。一个失败的 <strong>assert</strong> 或者从方法从抛出的异常都被视为测试失败，但是 <strong>@Unit</strong> 不会在这个失败的测试上卡住，它会继续运行，直到所有测试完毕，下面是一个示例程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/AtUnitExample2.java</span></span><br><span class="line"><span class="comment">// Assertions and exceptions can be used in @Tests</span></span><br><span class="line"><span class="comment">// &#123;java onjava.atunit.AtUnit</span></span><br><span class="line"><span class="comment">// build/classes/main/annotations/AtUnitExample2.class&#125;</span></span><br><span class="line"><span class="keyword">package</span> annotations;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> onjava.atunit.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtUnitExample2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">methodOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"This is methodOne"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">methodTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is methodTwo"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">assertExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">methodOne</span><span class="params">()</span>.<span class="title">equals</span><span class="params">(<span class="string">"This is methodOne"</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">assertFailureExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> <span class="number">1</span> == <span class="number">2</span>: <span class="string">"What a surprise!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exceptionExample</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(FileInputStream fis =</span><br><span class="line">                    <span class="keyword">new</span> FileInputStream(<span class="string">"nofile.txt"</span>)) &#123;&#125; <span class="comment">// Throws</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">assertAndReturn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Assertion with message:</span></span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">methodTwo</span><span class="params">()</span> </span>== <span class="number">2</span>: <span class="string">"methodTwo must equal 2"</span>;</span><br><span class="line">        <span class="keyword">return</span> methodOne().equals(<span class="string">"This is methodOne"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">annotations.AtUnitExample2</span><br><span class="line">. exceptionExample java.io.FileNotFoundException:</span><br><span class="line">nofile.txt (The system cannot find the file specified)</span><br><span class="line">(failed)</span><br><span class="line">. assertExample</span><br><span class="line">. assertAndReturn This is methodTwo</span><br><span class="line">. assertFailureExample java.lang.AssertionError: What</span><br><span class="line">a surprise!</span><br><span class="line">(failed)</span><br><span class="line">(<span class="number">4</span> tests)</span><br><span class="line">&gt;&gt;&gt; <span class="number">2</span> FAILURES &lt;&lt;&lt;</span><br><span class="line">annotations.AtUnitExample2: exceptionExample</span><br><span class="line">annotations.AtUnitExample2: assertFailureExample</span><br></pre></td></tr></table></figure><p>如下是一个使用非嵌入式测试的例子，并且使用了断言，它将会对 <strong>java.util.HashSet</strong> 进行一些简单的测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/HashSetTest.java</span></span><br><span class="line"><span class="comment">// &#123;java onjava.atunit.AtUnit</span></span><br><span class="line"><span class="comment">// build/classes/main/annotations/HashSetTest.class&#125;</span></span><br><span class="line"><span class="keyword">package</span> annotations;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> onjava.atunit.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetTest</span> </span>&#123;</span><br><span class="line">    HashSet&lt;String&gt; testObject = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initialization</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> testObject.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">_Contains</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        testObject.add(<span class="string">"one"</span>);</span><br><span class="line">        <span class="keyword">assert</span> testObject.contains(<span class="string">"one"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">_Remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        testObject.add(<span class="string">"one"</span>);</span><br><span class="line">        testObject.remove(<span class="string">"one"</span>);</span><br><span class="line">        <span class="keyword">assert</span> testObject.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用继承的方式可能会更简单，也没有一些其他的约束。</p><p>对每一个单元测试而言，<strong>@Unit</strong> 都会使用默认的无参构造器，为该测试类所属的类创建出一个新的实例。并在此新创建的对象上运行测试，然后丢弃该对象，以免对其他测试产生副作用。如此创建对象导致我们依赖于类的默认构造器。如果你的类没有默认构造器，或者对象需要复杂的构造过程，那么你可以创建一个 <strong>static</strong> 方法专门负责构造对象，然后使用 <strong>@TestObjectCreate</strong> 注解标记该方法，例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/AtUnitExample3.java</span></span><br><span class="line"><span class="comment">// &#123;java onjava.atunit.AtUnit</span></span><br><span class="line"><span class="comment">// build/classes/main/annotations/AtUnitExample3.class&#125;</span></span><br><span class="line"><span class="keyword">package</span> annotations;</span><br><span class="line"><span class="keyword">import</span> onjava.atunit.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtUnitExample3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtUnitExample3</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">this</span>.n = n; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getN</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">methodOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"This is methodOne"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">methodTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is methodTwo"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@TestObjectCreate</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> AtUnitExample3 <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AtUnitExample3(<span class="number">47</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">initialization</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> n == <span class="number">47</span>; &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">methodOneTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> methodOne().equals(<span class="string">"This is methodOne"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">m2</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> methodTwo() == <span class="number">2</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">annotations.AtUnitExample3</span><br><span class="line">. initialization</span><br><span class="line">. m2 This is methodTwo</span><br><span class="line">. methodOneTest</span><br><span class="line">OK (<span class="number">3</span> tests)</span><br></pre></td></tr></table></figure><p><strong>@TestObjectCreate</strong> 修饰的方法必须声明为 <strong>static</strong> ，且必须返回一个你正在测试的类型对象，这一切都由 <strong>@Unit</strong> 负责确保成立。</p><p>有的时候，你需要向单元测试中增加一些字段。这时候可以使用 <strong>@TestProperty</strong> 注解，由它注解的字段表示只在单元测试中使用（因此，在你将产品发布给客户之前，他们应该被删除）。在下面的例子中，一个 <strong>String</strong> 通过 <code>String.split()</code> 方法进行分割，从其中读取一个值，这个值将会被生成测试对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/AtUnitExample4.java</span></span><br><span class="line"><span class="comment">// &#123;java onjava.atunit.AtUnit</span></span><br><span class="line"><span class="comment">// build/classes/main/annotations/AtUnitExample4.class&#125;</span></span><br><span class="line"><span class="comment">// &#123;VisuallyInspectOutput&#125;</span></span><br><span class="line"><span class="keyword">package</span> annotations;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> onjava.atunit.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtUnitExample4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String theory = <span class="string">"All brontosauruses "</span> +</span><br><span class="line">            <span class="string">"are thin at one end, much MUCH thicker in the "</span> +</span><br><span class="line">            <span class="string">"middle, and then thin again at the far end."</span>;</span><br><span class="line">    <span class="keyword">private</span> String word;</span><br><span class="line">    <span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random(); <span class="comment">// Time-based seed</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtUnitExample4</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.word = word;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getWord</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> word; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">scrambleWord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Character&gt; chars = Arrays.asList(</span><br><span class="line">                ConvertTo.boxed(word.toCharArray()));</span><br><span class="line">        Collections.shuffle(chars, rand);</span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch : chars)</span><br><span class="line">            result.append(ch);</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@TestProperty</span></span><br><span class="line">    <span class="keyword">static</span> List&lt;String&gt; input =</span><br><span class="line">            Arrays.asList(theory.split(<span class="string">" "</span>));</span><br><span class="line">    <span class="meta">@TestProperty</span></span><br><span class="line">    <span class="keyword">static</span> Iterator&lt;String&gt; words = input.iterator();</span><br><span class="line">    <span class="meta">@TestObjectCreate</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> AtUnitExample4 <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(words.hasNext())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AtUnitExample4(words.next());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">words</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"'"</span> + getWord() + <span class="string">"'"</span>);</span><br><span class="line">        <span class="keyword">return</span> getWord().equals(<span class="string">"are"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">scramble1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// Use specific seed to get verifiable results:</span></span><br><span class="line">        rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        System.out.println(<span class="string">"'"</span> + getWord() + <span class="string">"'"</span>);</span><br><span class="line">        String scrambled = scrambleWord();</span><br><span class="line">        System.out.println(scrambled);</span><br><span class="line">        <span class="keyword">return</span> scrambled.equals(<span class="string">"lAl"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">scramble2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rand = <span class="keyword">new</span> Random(<span class="number">74</span>);</span><br><span class="line">        System.out.println(<span class="string">"'"</span> + getWord() + <span class="string">"'"</span>);</span><br><span class="line">        String scrambled = scrambleWord();</span><br><span class="line">        System.out.println(scrambled);</span><br><span class="line">        <span class="keyword">return</span> scrambled.equals(<span class="string">"tsaeborornussu"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">annotations.AtUnitExample4</span><br><span class="line">. words <span class="string">'All'</span></span><br><span class="line">(failed)</span><br><span class="line">. scramble1 <span class="string">'brontosauruses'</span></span><br><span class="line">ntsaueorosurbs</span><br><span class="line">(failed)</span><br><span class="line">. scramble2 <span class="string">'are'</span></span><br><span class="line">are</span><br><span class="line">(failed)</span><br><span class="line">(<span class="number">3</span> tests)</span><br><span class="line">&gt;&gt;&gt; <span class="number">3</span> FAILURES &lt;&lt;&lt;</span><br><span class="line">annotations.AtUnitExample4: words</span><br><span class="line">annotations.AtUnitExample4: scramble1</span><br><span class="line">annotations.AtUnitExample4: scramble2</span><br></pre></td></tr></table></figure><p><strong>@TestProperty</strong> 也可以用来标记那些只在测试中使用的方法，但是它们本身不是测试方法。</p><p>如果你的测试对象需要执行某些初始化工作，并且使用完成之后还需要执行清理工作，那么可以选择使用 <strong>static</strong> 的  <strong>@TestObjectCleanup</strong> 方法，当测试对象使用结束之后，该方法会为你执行清理工作。在下面的示例中，<strong>@TestObjectCleanup</strong> 为每一个测试对象都打开了一个文件，因此必须在丢弃测试的时候关闭该文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/AtUnitExample5.java</span></span><br><span class="line"><span class="comment">// &#123;java onjava.atunit.AtUnit</span></span><br><span class="line"><span class="comment">// build/classes/main/annotations/AtUnitExample5.class&#125;</span></span><br><span class="line"><span class="keyword">package</span> annotations;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> onjava.atunit.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtUnitExample5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String text;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtUnitExample5</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.text = text;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> text; &#125;</span><br><span class="line">    <span class="meta">@TestProperty</span></span><br><span class="line">    <span class="keyword">static</span> PrintWriter output;</span><br><span class="line">    <span class="meta">@TestProperty</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> counter;</span><br><span class="line">    <span class="meta">@TestObjectCreate</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> AtUnitExample5 <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String id = Integer.toString(counter++);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            output = <span class="keyword">new</span> PrintWriter(<span class="string">"Test"</span> + id + <span class="string">".txt"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AtUnitExample5(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@TestObjectCleanup</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">(AtUnitExample5 tobj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Running cleanup"</span>);</span><br><span class="line">        output.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        output.print(<span class="string">"test1"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        output.print(<span class="string">"test2"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        output.print(<span class="string">"test3"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">annotations.AtUnitExample5</span><br><span class="line">. test1</span><br><span class="line">Running cleanup</span><br><span class="line">. test3</span><br><span class="line">Running cleanup</span><br><span class="line">. test2</span><br><span class="line">Running cleanup</span><br><span class="line">OK (<span class="number">3</span> tests)</span><br></pre></td></tr></table></figure><p>在输出中我们可以看到，清理方法会在每个测试方法结束之后自动运行。</p><h3 id="在-Unit-中使用泛型"><a href="#在-Unit-中使用泛型" class="headerlink" title="在 @Unit 中使用泛型"></a>在 @Unit 中使用泛型</h3><p>泛型为 <strong>@Unit</strong> 出了一个难题，因为我们不可能“通用测试”。我们必须针对某个特定类型的参数或者参数集才能进行测试。解决方法十分简单，让测试类继承自泛型类的一个特定版本即可：</p><p>下面是一个 <strong>stack</strong> 的简单实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/StackL.java</span></span><br><span class="line"><span class="comment">// A stack built on a LinkedList</span></span><br><span class="line"><span class="keyword">package</span> annotations;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackL</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;T&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T v)</span> </span>&#123; list.addFirst(v); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">top</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> list.getFirst(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> list.removeFirst(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了测试 String 版本，我们直接让测试类继承一个 Stack&lt;String&gt; ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/StackLStringTst.java</span></span><br><span class="line"><span class="comment">// Applying @Unit to generics</span></span><br><span class="line"><span class="comment">// &#123;java onjava.atunit.AtUnit</span></span><br><span class="line"><span class="comment">// build/classes/main/annotations/StackLStringTst.class&#125;</span></span><br><span class="line"><span class="keyword">package</span> annotations;</span><br><span class="line"><span class="keyword">import</span> onjava.atunit.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="class"><span class="title">StackLStringTst</span> <span class="keyword">extends</span> <span class="title">StackL</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tPush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        push(<span class="string">"one"</span>);</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">top</span><span class="params">()</span>.<span class="title">equals</span><span class="params">(<span class="string">"one"</span>)</span></span>;</span><br><span class="line">        push(<span class="string">"two"</span>);</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">top</span><span class="params">()</span>.<span class="title">equals</span><span class="params">(<span class="string">"two"</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tPop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        push(<span class="string">"one"</span>);</span><br><span class="line">        push(<span class="string">"two"</span>);</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">pop</span><span class="params">()</span>.<span class="title">equals</span><span class="params">(<span class="string">"two"</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">pop</span><span class="params">()</span>.<span class="title">equals</span><span class="params">(<span class="string">"one"</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tTop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        push(<span class="string">"A"</span>);</span><br><span class="line">        push(<span class="string">"B"</span>);</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">top</span><span class="params">()</span>.<span class="title">equals</span><span class="params">(<span class="string">"B"</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">top</span><span class="params">()</span>.<span class="title">equals</span><span class="params">(<span class="string">"B"</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">annotations.StackLStringTst</span><br><span class="line">. tTop</span><br><span class="line">. tPush</span><br><span class="line">. tPop</span><br><span class="line">OK (<span class="number">3</span> tests)</span><br></pre></td></tr></table></figure><p>这种方法存在的唯一缺点是，继承使我们失去了访问被测试的类中 <strong>private</strong> 方法的能力。这对你非常重要，那你要么把 private 方法变为 <strong>protected</strong>，要么添加一个非 <strong>private</strong> 的 <strong>@TestProperty</strong> 方法，由它来调用 <strong>private</strong> 方法（稍后我们会看到，<strong>AtUnitRemover</strong> 会删除产品中的 <strong>@TestProperty</strong> 方法）。</p><p><strong>@Unit</strong> 搜索那些包含合适注解的类文件，然后运行 <strong>@Test</strong> 方法。我的主要目标就是让 <strong>@Unit</strong> 测试系统尽可能的透明，使得人们使用它的时候只需要添加 <strong>@Test</strong> 注解，而不需要特殊的编码和知识（现在版本的 <strong>JUnit</strong> 符合这个实践）。不过，如果说编写测试不会遇到任何困难，也不太可能，因此 <strong>@Unit</strong> 会尽量让这些困难变的微不足道，希望通过这种方式，你们会更乐意编写测试。</p><h3 id="实现-Unit"><a href="#实现-Unit" class="headerlink" title="实现 @Unit"></a>实现 @Unit</h3><p>首先我们需要定义所有的注解类型。这些都是简单的标签，并且没有任何字段。@Test 标签在本章开头已经定义过了，这里是其他所需要的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/atunit/TestObjectCreate.java</span></span><br><span class="line"><span class="comment">// The @Unit @TestObjectCreate tag</span></span><br><span class="line"><span class="keyword">package</span> onjava.atunit;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestObjectCreate &#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/atunit/TestObjectCleanup.java</span></span><br><span class="line"><span class="comment">// The @Unit @TestObjectCleanup tag</span></span><br><span class="line"><span class="keyword">package</span> onjava.atunit;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestObjectCleanup &#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/atunit/TestProperty.java</span></span><br><span class="line"><span class="comment">// The @Unit @TestProperty tag</span></span><br><span class="line"><span class="keyword">package</span> onjava.atunit;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="comment">// Both fields and methods can be tagged as properties:</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD, ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestProperty &#123;&#125;</span><br></pre></td></tr></table></figure><p>所有测试的保留属性都为 <strong>RUNTIME</strong>，这是因为 <strong>@Unit</strong> 必须在编译后的代码中发现这些注解。</p><p>要实现系统并运行测试，我们还需要反射机制来提取注解。下面这个程序通过注解中的信息，决定如何构造测试对象，并在测试对象上运行测试。正是由于注解帮助，这个程序才会如此短小而直接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/atunit/AtUnit.java</span></span><br><span class="line"><span class="comment">// An annotation-based unit-test framework</span></span><br><span class="line"><span class="comment">// &#123;java onjava.atunit.AtUnit&#125;</span></span><br><span class="line"><span class="keyword">package</span> onjava.atunit;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtUnit</span> <span class="keyword">implements</span> <span class="title">ProcessFiles</span>.<span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Class&lt;?&gt; testClass;</span><br><span class="line">    <span class="keyword">static</span> List&lt;String&gt; failedTests= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> testsRun = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> failures = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">    main(String[] args) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ClassLoader.getSystemClassLoader()</span><br><span class="line">                .setDefaultAssertionStatus(<span class="keyword">true</span>); <span class="comment">// Enable assert</span></span><br><span class="line">        <span class="keyword">new</span> ProcessFiles(<span class="keyword">new</span> AtUnit(), <span class="string">"class"</span>).start(args);</span><br><span class="line">        <span class="keyword">if</span>(failures == <span class="number">0</span>)</span><br><span class="line">            System.out.println(<span class="string">"OK ("</span> + testsRun + <span class="string">" tests)"</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"("</span> + testsRun + <span class="string">" tests)"</span>);</span><br><span class="line">            System.out.println(</span><br><span class="line">                    <span class="string">"\n&gt;&gt;&gt; "</span> + failures + <span class="string">" FAILURE"</span> +</span><br><span class="line">                            (failures &gt; <span class="number">1</span> ? <span class="string">"S"</span> : <span class="string">""</span>) + <span class="string">" &lt;&lt;&lt;"</span>);</span><br><span class="line">            <span class="keyword">for</span>(String failed : failedTests)</span><br><span class="line">                System.out.println(<span class="string">" "</span> + failed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(File cFile)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String cName = ClassNameFinder.thisClass(</span><br><span class="line">                    Files.readAllBytes(cFile.toPath()));</span><br><span class="line">            <span class="keyword">if</span>(!cName.startsWith(<span class="string">"public:"</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            cName = cName.split(<span class="string">":"</span>)[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(!cName.contains(<span class="string">"."</span>))</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// Ignore unpackaged classes</span></span><br><span class="line">            testClass = Class.forName(cName);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        TestMethods testMethods = <span class="keyword">new</span> TestMethods();</span><br><span class="line">        Method creator = <span class="keyword">null</span>;</span><br><span class="line">        Method cleanup = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(Method m : testClass.getDeclaredMethods()) &#123;</span><br><span class="line">            testMethods.addIfTestMethod(m);</span><br><span class="line">            <span class="keyword">if</span>(creator == <span class="keyword">null</span>)</span><br><span class="line">                creator = checkForCreatorMethod(m);</span><br><span class="line">            <span class="keyword">if</span>(cleanup == <span class="keyword">null</span>)</span><br><span class="line">                cleanup = checkForCleanupMethod(m);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(testMethods.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(creator == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!Modifier.isPublic(testClass</span><br><span class="line">                            .getDeclaredConstructor()</span><br><span class="line">                            .getModifiers())) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"Error: "</span> + testClass +</span><br><span class="line">                                <span class="string">" no-arg constructor must be public"</span>);</span><br><span class="line">                        System.exit(<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span>(NoSuchMethodException e) &#123;</span><br><span class="line"><span class="comment">// Synthesized no-arg constructor; OK</span></span><br><span class="line">                &#125;</span><br><span class="line">            System.out.println(testClass.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Method m : testMethods) &#123;</span><br><span class="line">            System.out.print(<span class="string">" . "</span> + m.getName() + <span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object testObject = createTestObject(creator);</span><br><span class="line">                <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(m.getReturnType().equals(<span class="keyword">boolean</span>.class))</span><br><span class="line">                        success = (Boolean)m.invoke(testObject);</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        m.invoke(testObject);</span><br><span class="line">                        success = <span class="keyword">true</span>; <span class="comment">// If no assert fails</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span>(InvocationTargetException e) &#123;</span><br><span class="line"><span class="comment">// Actual exception is inside e:</span></span><br><span class="line">                    System.out.println(e.getCause());</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(success ? <span class="string">""</span> : <span class="string">"(failed)"</span>);</span><br><span class="line">                testsRun++;</span><br><span class="line">                <span class="keyword">if</span>(!success) &#123;</span><br><span class="line">                    failures++;</span><br><span class="line">                    failedTests.add(testClass.getName() +</span><br><span class="line">                            <span class="string">": "</span> + m.getName());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cleanup != <span class="keyword">null</span>)</span><br><span class="line">                    cleanup.invoke(testObject, testObject);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(IllegalAccessException |</span><br><span class="line">                    IllegalArgumentException |</span><br><span class="line">                    InvocationTargetException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TestMethods</span> <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">Method</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">addIfTestMethod</span><span class="params">(Method m)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(m.getAnnotation(Test.class) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(m.getReturnType().equals(<span class="keyword">boolean</span>.class) ||</span><br><span class="line">                    m.getReturnType().equals(<span class="keyword">void</span>.class)))</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"@Test method"</span> +</span><br><span class="line">                        <span class="string">" must return boolean or void"</span>);</span><br><span class="line">            m.setAccessible(<span class="keyword">true</span>); <span class="comment">// If it's private, etc.</span></span><br><span class="line">            add(m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span></span><br><span class="line">    <span class="function">Method <span class="title">checkForCreatorMethod</span><span class="params">(Method m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m.getAnnotation(TestObjectCreate.class) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(!m.getReturnType().equals(testClass))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"@TestObjectCreate "</span> +</span><br><span class="line">                    <span class="string">"must return instance of Class to be tested"</span>);</span><br><span class="line">        <span class="keyword">if</span>((m.getModifiers() &amp;</span><br><span class="line">                java.lang.reflect.Modifier.STATIC) &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"@TestObjectCreate "</span> +</span><br><span class="line">                    <span class="string">"must be static."</span>);</span><br><span class="line">        m.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span></span><br><span class="line">    <span class="function">Method <span class="title">checkForCleanupMethod</span><span class="params">(Method m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m.getAnnotation(TestObjectCleanup.class) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(!m.getReturnType().equals(<span class="keyword">void</span>.class))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"@TestObjectCleanup "</span> +</span><br><span class="line">                    <span class="string">"must return void"</span>);</span><br><span class="line">        <span class="keyword">if</span>((m.getModifiers() &amp;</span><br><span class="line">                java.lang.reflect.Modifier.STATIC) &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"@TestObjectCleanup "</span> +</span><br><span class="line">                    <span class="string">"must be static."</span>);</span><br><span class="line">        <span class="keyword">if</span>(m.getParameterTypes().length == <span class="number">0</span> ||</span><br><span class="line">                m.getParameterTypes()[<span class="number">0</span>] != testClass)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"@TestObjectCleanup "</span> +</span><br><span class="line">                    <span class="string">"must take an argument of the tested type."</span>);</span><br><span class="line">        m.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object</span><br><span class="line">    createTestObject(Method creator) &#123;</span><br><span class="line">        <span class="keyword">if</span>(creator != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> creator.invoke(testClass);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(IllegalAccessException |</span><br><span class="line">                    IllegalArgumentException |</span><br><span class="line">                    InvocationTargetException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Couldn't run "</span> +</span><br><span class="line">                        <span class="string">"@TestObject (creator) method."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// Use the no-arg constructor:</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> testClass.newInstance();</span><br><span class="line">            &#125; <span class="keyword">catch</span>(InstantiationException |</span><br><span class="line">                    IllegalAccessException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                        <span class="string">"Couldn't create a test object. "</span> +</span><br><span class="line">                                <span class="string">"Try using a @TestObject method."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然它可能是“过早的重构”（因为它只在书中使用过一次），<strong>AtUnit.java</strong> 使用了 <strong>ProcessFiles</strong> 工具逐步判断命令行中的参数，决定它是一个目录还是文件，并采取相应的行为。这可以应用于不同的解决方法，是因为它包含了一个 可用于自定义的 <strong>Strategy</strong> 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/ProcessFiles.java</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessFiles</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(File file)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line">    <span class="keyword">private</span> String ext;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProcessFiles</span><span class="params">(Strategy strategy, String ext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">        <span class="keyword">this</span>.ext = ext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(args.length == <span class="number">0</span>)</span><br><span class="line">                processDirectoryTree(<span class="keyword">new</span> File(<span class="string">"."</span>));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">for</span>(String arg : args) &#123;</span><br><span class="line">                    File fileArg = <span class="keyword">new</span> File(arg);</span><br><span class="line">                    <span class="keyword">if</span>(fileArg.isDirectory())</span><br><span class="line">                        processDirectoryTree(fileArg);</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Allow user to leave off extension:</span></span><br><span class="line">                        <span class="keyword">if</span>(!arg.endsWith(<span class="string">"."</span> + ext))</span><br><span class="line">                            arg += <span class="string">"."</span> + ext;</span><br><span class="line">                        strategy.process(</span><br><span class="line">                                <span class="keyword">new</span> File(arg).getCanonicalFile());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processDirectoryTree</span><span class="params">(File root)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        PathMatcher matcher = FileSystems.getDefault()</span><br><span class="line">                .getPathMatcher(<span class="string">"glob:**/*.&#123;"</span> + ext + <span class="string">"&#125;"</span>);</span><br><span class="line">        Files.walk(root.toPath())</span><br><span class="line">                .filter(matcher::matches)</span><br><span class="line">                .forEach(p -&gt; strategy.process(p.toFile()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AtUnit</strong> 类实现了 <strong>ProcessFiles.Strategy</strong>，其包含了一个 <code>process()</code> 方法。在这种方式下，<strong>AtUnit</strong> 实例可以作为参数传递给 <strong>ProcessFiles</strong> 构造器。第二个构造器的参数告诉 <strong>ProcessFiles</strong> 如寻找所有包含 “class” 拓展名的文件。</p><p>如下是一个简单的使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/DemoProcessFiles.java</span></span><br><span class="line"><span class="keyword">import</span> onjava.ProcessFiles;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoProcessFiles</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ProcessFiles(file -&gt; System.out.println(file),</span><br><span class="line">                <span class="string">"java"</span>).start(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">.\AtUnitExample1.java</span><br><span class="line">.\AtUnitExample2.java</span><br><span class="line">.\AtUnitExample3.java</span><br><span class="line">.\AtUnitExample4.java</span><br><span class="line">.\AtUnitExample5.java</span><br><span class="line">.\AUComposition.java</span><br><span class="line">.\AUExternalTest.java</span><br><span class="line">.\database\Constraints.java</span><br><span class="line">.\database\DBTable.java</span><br><span class="line">.\database\Member.java</span><br><span class="line">.\database\SQLInteger.java</span><br><span class="line">.\database\SQLString.java</span><br><span class="line">.\database\TableCreator.java</span><br><span class="line">.\database\Uniqueness.java</span><br><span class="line">.\DemoProcessFiles.java</span><br><span class="line">.\HashSetTest.java</span><br><span class="line">.\ifx\ExtractInterface.java</span><br><span class="line">.\ifx\IfaceExtractorProcessor.java</span><br><span class="line">.\ifx\Multiplier.java</span><br><span class="line">.\PasswordUtils.java</span><br><span class="line">.\simplest\Simple.java</span><br><span class="line">.\simplest\SimpleProcessor.java</span><br><span class="line">.\simplest\SimpleTest.java</span><br><span class="line">.\SimulatingNull.java</span><br><span class="line">.\StackL.java</span><br><span class="line">.\StackLStringTst.java</span><br><span class="line">.\Testable.java</span><br><span class="line">.\UseCase.java</span><br><span class="line">.\UseCaseTracker.java</span><br></pre></td></tr></table></figure><p>如果没有命令行参数，这个程序会遍历当前的目录树。你还可以提供多个参数，这些参数可以是类文件（带或不带.class扩展名）或目录。</p><p>回到我们对 <strong>AtUnit.java</strong> 的讨论，因为 <strong>@Unit</strong> 会自动找到可测试的类和方法，所以不需要“套件”机制。</p><p><strong>AtUnit.java</strong> 中存在的一个我们必须要解决的问题是，当它发现类文件时，类文件名中的限定类名（包括包）不明显。为了发现这个信息，必须解析类文件 - 这不是微不足道的，但也不是不可能的。 找到 .class 文件时，会打开它并读取其二进制数据并将其传递给 <code>ClassNameFinder.thisClass()</code>。 在这里，我们正在进入“字节码工程”领域，因为我们实际上正在分析类文件的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/atunit/ClassNameFinder.java</span></span><br><span class="line"><span class="comment">// &#123;java onjava.atunit.ClassNameFinder&#125;</span></span><br><span class="line"><span class="keyword">package</span> onjava.atunit;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassNameFinder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">thisClass</span><span class="params">(<span class="keyword">byte</span>[] classBytes)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; offsetTable = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Integer,String&gt; classNameTable = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DataInputStream data = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">                    <span class="keyword">new</span> ByteArrayInputStream(classBytes));</span><br><span class="line">            <span class="keyword">int</span> magic = data.readInt(); <span class="comment">// 0xcafebabe</span></span><br><span class="line">            <span class="keyword">int</span> minorVersion = data.readShort();</span><br><span class="line">            <span class="keyword">int</span> majorVersion = data.readShort();</span><br><span class="line">            <span class="keyword">int</span> constantPoolCount = data.readShort();</span><br><span class="line">            <span class="keyword">int</span>[] constantPool = <span class="keyword">new</span> <span class="keyword">int</span>[constantPoolCount];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; constantPoolCount; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> tag = data.read();</span><br><span class="line">                <span class="comment">// int tableSize;</span></span><br><span class="line">                <span class="keyword">switch</span>(tag) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// UTF</span></span><br><span class="line">                        <span class="keyword">int</span> length = data.readShort();</span><br><span class="line">                        <span class="keyword">char</span>[] bytes = <span class="keyword">new</span> <span class="keyword">char</span>[length];</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; bytes.length; k++)</span><br><span class="line">                            bytes[k] = (<span class="keyword">char</span>)data.read();</span><br><span class="line">                        String className = <span class="keyword">new</span> String(bytes);</span><br><span class="line">                        classNameTable.put(i, className);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">5</span>: <span class="comment">// LONG</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="number">6</span>: <span class="comment">// DOUBLE</span></span><br><span class="line">                        data.readLong(); <span class="comment">// discard 8 bytes</span></span><br><span class="line">                        i++; <span class="comment">// Special skip necessary</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">7</span>: <span class="comment">// CLASS</span></span><br><span class="line">                        <span class="keyword">int</span> offset = data.readShort();</span><br><span class="line">                        offsetTable.put(i, offset);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">8</span>: <span class="comment">// STRING</span></span><br><span class="line">                        data.readShort(); <span class="comment">// discard 2 bytes</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">// INTEGER</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="number">4</span>: <span class="comment">// FLOAT</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="number">9</span>: <span class="comment">// FIELD_REF</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="number">10</span>: <span class="comment">// METHOD_REF</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="number">11</span>: <span class="comment">// INTERFACE_METHOD_REF</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="number">12</span>: <span class="comment">// NAME_AND_TYPE</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="number">18</span>: <span class="comment">// Invoke Dynamic</span></span><br><span class="line">                        data.readInt(); <span class="comment">// discard 4 bytes</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">15</span>: <span class="comment">// Method Handle</span></span><br><span class="line">                        data.readByte();</span><br><span class="line">                        data.readShort();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">16</span>: <span class="comment">// Method Type</span></span><br><span class="line">                        data.readShort();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">throw</span></span><br><span class="line">                                <span class="keyword">new</span> RuntimeException(<span class="string">"Bad tag "</span> + tag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">short</span> accessFlags = data.readShort();</span><br><span class="line">            String access = (accessFlags &amp; <span class="number">0x0001</span>) == <span class="number">0</span> ?</span><br><span class="line">                    <span class="string">"nonpublic:"</span> : <span class="string">"public:"</span>;</span><br><span class="line">            <span class="keyword">int</span> thisClass = data.readShort();</span><br><span class="line">            <span class="keyword">int</span> superClass = data.readShort();</span><br><span class="line">            <span class="keyword">return</span> access + classNameTable.get(</span><br><span class="line">                    offsetTable.get(thisClass)).replace(<span class="string">'/'</span>, <span class="string">'.'</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException | RuntimeException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Demonstration:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        PathMatcher matcher = FileSystems.getDefault()</span><br><span class="line">                .getPathMatcher(<span class="string">"glob:**/*.class"</span>);</span><br><span class="line"><span class="comment">// Walk the entire tree:</span></span><br><span class="line">        Files.walk(Paths.get(<span class="string">"."</span>))</span><br><span class="line">                .filter(matcher::matches)</span><br><span class="line">                .map(p -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> thisClass(Files.readAllBytes(p));</span><br><span class="line">                    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .filter(s -&gt; s.startsWith(<span class="string">"public:"</span>))</span><br><span class="line"><span class="comment">// .filter(s -&gt; s.indexOf('$') &gt;= 0)</span></span><br><span class="line">                .map(s -&gt; s.split(<span class="string">":"</span>)[<span class="number">1</span>])</span><br><span class="line">                .filter(s -&gt; !s.startsWith(<span class="string">"enums."</span>))</span><br><span class="line">                .filter(s -&gt; s.contains(<span class="string">"."</span>))</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">onjava.ArrayShow</span><br><span class="line">onjava.atunit.AtUnit$TestMethods</span><br><span class="line">onjava.atunit.AtUnit</span><br><span class="line">onjava.atunit.ClassNameFinder</span><br><span class="line">onjava.atunit.Test</span><br><span class="line">onjava.atunit.TestObjectCleanup</span><br><span class="line">onjava.atunit.TestObjectCreate</span><br><span class="line">onjava.atunit.TestProperty</span><br><span class="line">onjava.BasicSupplier</span><br><span class="line">onjava.CollectionMethodDifferences</span><br><span class="line">onjava.ConvertTo</span><br><span class="line">onjava.Count$Boolean</span><br><span class="line">onjava.Count$Byte</span><br><span class="line">onjava.Count$Character</span><br><span class="line">onjava.Count$Double</span><br><span class="line">onjava.Count$Float</span><br><span class="line">onjava.Count$Integer</span><br><span class="line">onjava.Count$Long</span><br><span class="line">onjava.Count$Pboolean</span><br><span class="line">onjava.Count$Pbyte</span><br><span class="line">onjava.Count$Pchar</span><br><span class="line">onjava.Count$Pdouble</span><br><span class="line">onjava.Count$Pfloat</span><br><span class="line">onjava.Count$Pint</span><br><span class="line">onjava.Count$Plong</span><br><span class="line">onjava.Count$Pshort</span><br><span class="line">onjava.Count$Short</span><br><span class="line">onjava.Count</span><br><span class="line">onjava.CountingIntegerList</span><br><span class="line">onjava.CountMap</span><br><span class="line">onjava.Countries</span><br><span class="line">onjava.Enums</span><br><span class="line">onjava.FillMap</span><br><span class="line">onjava.HTMLColors</span><br><span class="line">onjava.MouseClick</span><br><span class="line">onjava.Nap</span><br><span class="line">onjava.Null</span><br><span class="line">onjava.Operations</span><br><span class="line">onjava.OSExecute</span><br><span class="line">onjava.OSExecuteException</span><br><span class="line">onjava.Pair</span><br><span class="line">onjava.ProcessFiles$Strategy</span><br><span class="line">onjava.ProcessFiles</span><br><span class="line">onjava.Rand$Boolean</span><br><span class="line">onjava.Rand$Byte</span><br><span class="line">onjava.Rand$Character</span><br><span class="line">onjava.Rand$Double</span><br><span class="line">onjava.Rand$Float</span><br><span class="line">onjava.Rand$Integer</span><br><span class="line">onjava.Rand$Long</span><br><span class="line">onjava.Rand$Pboolean</span><br><span class="line">onjava.Rand$Pbyte</span><br><span class="line">onjava.Rand$Pchar</span><br><span class="line">onjava.Rand$Pdouble</span><br><span class="line">onjava.Rand$Pfloat</span><br><span class="line">onjava.Rand$Pint</span><br><span class="line">onjava.Rand$Plong</span><br><span class="line">onjava.Rand$Pshort</span><br><span class="line">onjava.Rand$Short</span><br><span class="line">onjava.Rand$String</span><br><span class="line">onjava.Rand</span><br><span class="line">onjava.Range</span><br><span class="line">onjava.Repeat</span><br><span class="line">onjava.RmDir</span><br><span class="line">onjava.Sets</span><br><span class="line">onjava.Stack</span><br><span class="line">onjava.Suppliers</span><br><span class="line">onjava.TimedAbort</span><br><span class="line">onjava.Timer</span><br><span class="line">onjava.Tuple</span><br><span class="line">onjava.Tuple2</span><br><span class="line">onjava.Tuple3</span><br><span class="line">onjava.Tuple4</span><br><span class="line">onjava.Tuple5</span><br><span class="line">onjava.TypeCounter</span><br></pre></td></tr></table></figure><p> 虽然无法在这里介绍其中所有的细节，但是每个类文件都必须遵循一定的格式，而我已经尽力用有意义的字段来表示这些从 <strong>ByteArrayInputStream</strong> 中提取出来的数据片段。通过施加在输入流上的读操作，你能看出每个信息片的大小。例如每一个类的头 32 个 bit 总是一个 “神秘数字” <strong>0xcafebabe</strong>，而接下来的两个 <strong>short</strong> 值是版本信息。常量池包含了程序的常量，所以这是一个可变的值。接下来的 <strong>short</strong> 告诉我们这个常量池有多大，然后我们为其创建一个尺寸合适的数组。常量池中的每一个元素，其长度可能是固定式，也可能是可变的值，因此我们必须检查每一个常量的起始标记，然后才能知道该怎么做，这就是 switch 语句的工作。我们并不打算精确的分析类中所有的数据，仅仅是从文件的起始一步一步的走，直到取得我们所需的信息，因此你会发现，在这个过程中我们丢弃了大量的数据。关于类的信息都保存在 <strong>classNameTable</strong> 和 <strong>offsetTable</strong> 中。在读取常量池之后，就找到了 <strong>this_class</strong> 信息，这是 <strong>offsetTable</strong> 的一个坐标，通过它可以找到进入  <strong>classNameTable</strong> 的坐标，然后就可以得到我们所需的类的名字了。</p><p>现在让我们回到 <strong>AtUtil.java</strong> 中，process() 方法中拥有了类的名字，然后检查它是否包含“.”，如果有就表示该类定义于一个包中。没有包的类会被忽略。如果一个类在包中，那么我们就可以使用标准的类加载器通过 <code>Class.forName()</code>  将其加载进来。现在我们可以对这个类进行 <strong>@Unit</strong> 注解的分析工作了。</p><p>我们只需要关注三件事：首先是 <strong>@Test</strong> 方法，它们被保存在 <strong>TestMehtods</strong> 列表中，然后检查其是否具有 @TestObjectCreate 和 <strong>@TestObjectCleanup****</strong> 方法。从代码中可以看到，我们通过调用相应的方法来查询注解从而找到这些方法。</p><p>每找到一个 @Test 方法，就打印出来当前类的名字，于是观察者立刻就可以知道发生了什么。接下来开始执行测试，也就是打印出方法名，然后调用 createTestObject() （如果存在一个加了 @TestObjectCreate 注解的方法），或者调用默认构造器。一旦创建出来测试对象，如果调用其上的测试方法。如果测试的返回值为 boolean，就捕获该结果。如果测试方法没有返回值，那么就没有异常发生，我们就假设测试成功，反之，如果当 assert 失败或者有任何异常抛出的时候，就说明测试失败，这时将异常信息打印出来以显示错误的原因。如果有失败的测试发生，那么还要统计失败的次数，并将失败所属的类和方法加入到 failedTests 中，以便最后报告给用户。</p><!-- Summary --><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>注解是 Java 引入的一项非常受欢迎的补充，它提供了一种结构化，并且具有类型检查能力的新途径，从而使得你能够为代码中加入元数据，而且不会导致代码杂乱并难以阅读。使用注解能够帮助我们避免编写累赘的部署描述性文件，以及其他的生成文件。而 Javadoc 中的 @deprecated 被 @Deprecated 注解所替代的事实也说明，与注释性文字相比，注解绝对更适用于描述类相关的信息。</p><p>Java 提供了很少的内置注解。这意味着如果你在别处找不到可用的类库，那么就只能自己创建新的注解以及相应的处理器。通过将注解处理器链接到 javac，你可以一步完成编译新生成的文件，简化了构造过程。</p><p>API 的提供方和框架将会将注解作为他们工具的一部分。通过 @Unit 系统，我们可以想象，注解会极大的改变我们的 Java 编程体验。</p><!-- 分页 --><div style="page-break-after: always;"></div><p>[^3 ]: The Java designers coyly suggest that a mirror is where you find a reflection.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接口和抽象类提供了一种将接口与实现分离的更加结构化的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
</feed>
