<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-05T03:58:40.518Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据库学习笔记VI</title>
    <link href="http://yoursite.com/2019/11/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0VI/"/>
    <id>http://yoursite.com/2019/11/05/数据库学习笔记VI/</id>
    <published>2019-11-05T03:54:12.000Z</published>
    <updated>2019-11-05T03:58:40.518Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL优化</p><a id="more"></a><p>#参考资料<br>【1】 <a href="https://tech.meituan.com/2014/06/30/mysql-index.html" target="_blank" rel="noopener">https://tech.meituan.com/2014/06/30/mysql-index.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL优化&lt;/p&gt;
    
    </summary>
    
      <category term="2019年11月" scheme="http://yoursite.com/categories/2019%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>设计模式学习笔记II</title>
    <link href="http://yoursite.com/2019/11/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0II/"/>
    <id>http://yoursite.com/2019/11/05/设计模式学习笔记II/</id>
    <published>2019-11-05T03:12:12.000Z</published>
    <updated>2019-11-05T03:51:23.215Z</updated>
    
    <content type="html"><![CDATA[<p>工厂模式</p><a id="more"></a><p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p><p>介绍<br>意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p><p>主要解决：主要解决接口选择的问题。</p><p>何时使用：我们明确地计划不同条件下创建不同实例时。</p><p>如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。</p><p>关键代码：创建过程在其子类执行。</p><p>应用实例： 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。</p><p>优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。</p><p>缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</p><p>使用场景： 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。</p><p>注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</p><p>实现<br>我们将创建一个 Shape 接口和实现 Shape 接口的实体类。下一步是定义工厂类 ShapeFactory。</p><p>FactoryPatternDemo，我们的演示类使用 ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。</p><p>步骤 1<br>创建一个接口:</p><p>Shape.java</p><pre><code>public interface Shape {   void draw();}</code></pre><p>步骤 2<br>创建实现接口的实体类。</p><p>Rectangle.java</p><pre><code>public class Rectangle implements Shape {   @Override   public void draw() {      System.out.println(&quot;Inside Rectangle::draw() method.&quot;);   }}Square.javapublic class Square implements Shape {   @Override   public void draw() {      System.out.println(&quot;Inside Square::draw() method.&quot;);   }}Circle.javapublic class Circle implements Shape {   @Override   public void draw() {      System.out.println(&quot;Inside Circle::draw() method.&quot;);   }}</code></pre><p>步骤 3<br>创建一个工厂，生成基于给定信息的实体类的对象。</p><p>ShapeFactory.java</p><pre><code>public class ShapeFactory {   //使用 getShape 方法获取形状类型的对象   public Shape getShape(String shapeType){      if(shapeType == null){         return null;      }              if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;)){         return new Circle();      } else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;)){         return new Rectangle();      } else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;)){         return new Square();      }      return null;   }}</code></pre><p>步骤 4<br>使用该工厂，通过传递类型信息来获取实体类的对象。</p><p>FactoryPatternDemo.java</p><pre><code>public class FactoryPatternDemo {   public static void main(String[] args) {      ShapeFactory shapeFactory = new ShapeFactory();      //获取 Circle 的对象，并调用它的 draw 方法      Shape shape1 = shapeFactory.getShape(&quot;CIRCLE&quot;);      //调用 Circle 的 draw 方法      shape1.draw();      //获取 Rectangle 的对象，并调用它的 draw 方法      Shape shape2 = shapeFactory.getShape(&quot;RECTANGLE&quot;);      //调用 Rectangle 的 draw 方法      shape2.draw();      //获取 Square 的对象，并调用它的 draw 方法      Shape shape3 = shapeFactory.getShape(&quot;SQUARE&quot;);      //调用 Square 的 draw 方法      shape3.draw();   }}</code></pre><p>步骤 5<br>执行程序，输出结果：</p><pre><code>Inside Circle::draw() method.Inside Rectangle::draw() method.Inside Square::draw() method.</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】 <a href="https://www.runoob.com/design-pattern/factory-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/factory-pattern.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工厂模式&lt;/p&gt;
    
    </summary>
    
      <category term="2019年11月" scheme="http://yoursite.com/categories/2019%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Design Pattern，Java" scheme="http://yoursite.com/tags/Design-Pattern%EF%BC%8CJava/"/>
    
  </entry>
  
  <entry>
    <title>设计模式学习笔记I</title>
    <link href="http://yoursite.com/2019/10/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0I/"/>
    <id>http://yoursite.com/2019/10/17/设计模式学习笔记I/</id>
    <published>2019-10-17T02:56:12.000Z</published>
    <updated>2019-10-17T03:06:59.684Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式学习笔记</p><a id="more"></a><h1 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h1><p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</p><p>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</p><p>我们通过下面的实例来演示装饰器模式的用法。其中，我们将把一个形状装饰上不同的颜色，同时又不改变形状类。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>意图：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p><p>主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。</p><p>何时使用：在不想增加很多子类的情况下扩展类。</p><p>如何解决：将具体功能职责划分，同时继承装饰者模式。</p><p>关键代码： 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。</p><p>应用实例： 1、孙悟空有 72 变，当他变成”庙宇”后，他的根本还是一只猴子，但是他又有了庙宇的功能。 2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。</p><p>优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p><p>缺点：多层装饰比较复杂。</p><p>使用场景： 1、扩展一个类的功能。 2、动态增加功能，动态撤销。</p><p>注意事项：可代替继承。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>我们将创建一个 Shape 接口和实现了 Shape 接口的实体类。然后我们创建一个实现了 Shape 接口的抽象装饰类 ShapeDecorator，并把 Shape 对象作为它的实例变量。</p><p>RedShapeDecorator 是实现了 ShapeDecorator 的实体类。</p><p>DecoratorPatternDemo，我们的演示类使用 RedShapeDecorator 来装饰 Shape 对象。<br><a href="https://www.runoob.com/wp-content/uploads/2014/08/decorator_pattern_uml_diagram.jpg" target="_blank" rel="noopener">https://www.runoob.com/wp-content/uploads/2014/08/decorator_pattern_uml_diagram.jpg</a></p><h2 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h2><p>创建一个接口：</p><p>Shape.java</p><pre><code>public interface Shape {   void draw();}</code></pre><h2 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h2><p>创建实现接口的实体类。</p><p>Rectangle.java</p><pre><code>public class Rectangle implements Shape {   @Override   public void draw() {      System.out.println(&quot;Shape: Rectangle&quot;);   }}</code></pre><p>Circle.java</p><pre><code>public class Circle implements Shape {   @Override   public void draw() {      System.out.println(&quot;Shape: Circle&quot;);   }}</code></pre><h2 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a>步骤 3</h2><p>创建实现了 Shape 接口的抽象装饰类。</p><p>ShapeDecorator.java</p><pre><code>public abstract class ShapeDecorator implements Shape {   protected Shape decoratedShape;   public ShapeDecorator(Shape decoratedShape){      this.decoratedShape = decoratedShape;   }   public void draw(){      decoratedShape.draw();   }  }</code></pre><h2 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤 4"></a>步骤 4</h2><p>创建扩展了 ShapeDecorator 类的实体装饰类。</p><p>RedShapeDecorator.java</p><pre><code>public class RedShapeDecorator extends ShapeDecorator {   public RedShapeDecorator(Shape decoratedShape) {      super(decoratedShape);        }   @Override   public void draw() {      decoratedShape.draw();               setRedBorder(decoratedShape);   }   private void setRedBorder(Shape decoratedShape){      System.out.println(&quot;Border Color: Red&quot;);   }}</code></pre><h2 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤 5"></a>步骤 5</h2><p>使用 RedShapeDecorator 来装饰 Shape 对象。</p><p>DecoratorPatternDemo.java</p><pre><code>public class DecoratorPatternDemo {   public static void main(String[] args) {      Shape circle = new Circle();      ShapeDecorator redCircle = new RedShapeDecorator(new Circle());      ShapeDecorator redRectangle = new RedShapeDecorator(new Rectangle());      //Shape redCircle = new RedShapeDecorator(new Circle());      //Shape redRectangle = new RedShapeDecorator(new Rectangle());      System.out.println(&quot;Circle with normal border&quot;);      circle.draw();      System.out.println(&quot;\nCircle of red border&quot;);      redCircle.draw();      System.out.println(&quot;\nRectangle of red border&quot;);      redRectangle.draw();   }}</code></pre><h2 id="步骤-6"><a href="#步骤-6" class="headerlink" title="步骤 6"></a>步骤 6</h2><p>执行程序，输出结果：</p><pre><code>Circle with normal borderShape: CircleCircle of red borderShape: CircleBorder Color: RedRectangle of red borderShape: RectangleBorder Color: Red</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】 <a href="https://www.runoob.com/design-pattern/decorator-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/decorator-pattern.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计模式学习笔记&lt;/p&gt;
    
    </summary>
    
      <category term="2019年10月" scheme="http://yoursite.com/categories/2019%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Design Pattern，Java" scheme="http://yoursite.com/tags/Design-Pattern%EF%BC%8CJava/"/>
    
  </entry>
  
  <entry>
    <title>Scala学习笔记II</title>
    <link href="http://yoursite.com/2019/09/25/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0II/"/>
    <id>http://yoursite.com/2019/09/25/Scala学习笔记II/</id>
    <published>2019-09-25T07:17:12.000Z</published>
    <updated>2019-09-27T09:36:36.534Z</updated>
    
    <content type="html"><![CDATA[<p>Scala学习：=&gt;语法糖,模式匹配</p><a id="more"></a><h1 id="Scala的“-gt-”符号简介"><a href="#Scala的“-gt-”符号简介" class="headerlink" title="Scala的“=&gt;”符号简介"></a>Scala的“=&gt;”符号简介</h1><p>Scala中的=&gt;符号可以看做是创建函数实例的语法糖。例如：A =&gt; T，A,B =&gt; T表示一个函数的输入参数类型是“A”，“A,B”，返回值类型是T。请看下面这个实例：</p><pre><code>scala&gt; val f: Int =&gt; String = myInt =&gt; &quot;The value of myInt is: &quot; + myInt.toString()f: Int =&gt; String = &lt;function1&gt;scala&gt; println(f(3))The value of myInt is: 3</code></pre><p>另外，() =&gt; T表示函数输入参数为空，而A =&gt; Unit则表示函数没有返回值。</p><pre><code>object HelloScala {  def main(args: Array[String])  {    /**      * 首先定义函数d,参数类型是Int=&gt;Int的函数,返回值根据上下文推算是Int。      * 返回值: 发现没有,返回值是x(2),它调用了传入函数。结果自然就是6了。      */    def d(x: (Int) =&gt; Int) = x(2);    println(d((x: Int) =&gt; x * 3));    // 继续增加难度,设置2个值。仔细看变化,你会明白的    def c(x: (Int, Int) =&gt; Int) = x(2, 3);    println(c((x: Int, y: Int) =&gt; x * y * 3));    // 加深难度,b第一次调用返回函数(y: Int) =&gt; x + y,在一次调用返回结果。    // 相关文章参考快学scala 第十二章 高阶函数 145页    val b = (x: Int) =&gt; (y: Int) =&gt; x + y;    println(b.apply(5).apply(6));  }}</code></pre><h1 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h1><pre><code>object scala {    def main(args: Array[String]):Unit={        println(matchTest(3))    }    def matchTest(x:Int):String =x match{      case 1=&gt;&quot;one&quot;      case 2=&gt;&quot;two&quot;      case _=&gt;&quot;many&quot;    }}</code></pre><p>match 对应 Java 里的 switch，但是写在选择器表达式之后。即： 选择器 match {备选项}。</p><p>match 表达式通过以代码编写的先后次序尝试每个模式来完成计算，只要发现有一个匹配的case，剩下的case不会继续匹配。</p><p>接下来我们来看一个不同数据类型的模式匹配：</p><pre><code>object scala {    def main(args: Array[String]):Unit={      println(matchTest(&quot;two&quot;))      println(matchTest(&quot;test&quot;))      println(matchTest(1))      println(matchTest(6))    }    def matchTest(x:Any) : Any=x match {      case 1=&gt;&quot;one&quot;      case &quot;two&quot;=&gt;2      case y:Int=&gt;&quot;scala.Int&quot;      case _=&gt;&quot;many&quot;    }}</code></pre><p>输出结果为：</p><pre><code>2manyonescala.Int</code></pre><p>实例中第一个 case 对应整型数值 1，第二个 case 对应字符串值 two，第三个 case 对应类型模式，用于判断传入的值是否为整型，相比使用isInstanceOf来判断类型，使用模式匹配更好。第四个 case 表示默认的全匹配备选项，即没有找到其他匹配时的匹配项，类似 switch 中的 default。</p><h2 id="使用样例类"><a href="#使用样例类" class="headerlink" title="使用样例类"></a>使用样例类</h2><p>使用了case关键字的类定义就是就是样例类(case classes)，样例类是种特殊的类，经过优化以用于模式匹配。</p><p>以下是样例类的简单实例:</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】 <a href="https://www.orchome.com/401" target="_blank" rel="noopener">https://www.orchome.com/401</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Scala学习：=&amp;gt;语法糖,模式匹配&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记IX</title>
    <link href="http://yoursite.com/2019/09/20/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0IX/"/>
    <id>http://yoursite.com/2019/09/20/Java学习笔记IX/</id>
    <published>2019-09-20T10:32:12.000Z</published>
    <updated>2019-09-20T10:46:42.351Z</updated>
    
    <content type="html"><![CDATA[<p>Java8 中的新特性：Optional类</p><a id="more"></a><p>看到代码中出现的Optional，所以来研究一下：</p><pre><code>Optional&lt;LoanPostloanInfosEntity&gt; postloanInfo = loanPostloanInfosRepository.getByContractId(contractId);</code></pre><p>  Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</p><p>  Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</p><p>  Optional 类的引入很好的解决空指针异常。</p><h1 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h1><p>  以下是一个 java.util.Optional<t> 类的声明：</t></p><pre><code>public final class Optional&lt;T&gt;extends Object</code></pre><h1 id="Optional实例"><a href="#Optional实例" class="headerlink" title="Optional实例"></a>Optional实例</h1><pre><code>import java.util.Optional;public class Java8Tester {    public static void optionalPrac(){        Integer value1 = null;        Integer value2 = new Integer(10);        // Optional.ofNullable - 允许传递为 null 参数        Optional&lt;Integer&gt; a = Optional.ofNullable(value1);        // Optional.of - 如果传递的参数是 null，抛出异常 NullPointerException        Optional&lt;Integer&gt; b = Optional.of(value2);        System.out.println(sum(a,b));    }    public static Integer sum(Optional&lt;Integer&gt; a, Optional&lt;Integer&gt; b){        // Optional.isPresent - 判断值是否存在        System.out.println(&quot;第一个参数值存在: &quot; + a.isPresent());        System.out.println(&quot;第二个参数值存在: &quot; + b.isPresent());        // Optional.orElse - 如果值存在，返回它，否则返回默认值        Integer value1 = a.orElse(new Integer(0));        //Optional.get - 获取值，值需要存在        Integer value2 = b.get();        return value1 + value2;    }    public static void main(String args[]){        optionalPrac();}</code></pre><p>}</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<br><a href="https://www.runoob.com/java/java8-optional-class.html" target="_blank" rel="noopener">https://www.runoob.com/java/java8-optional-class.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java8 中的新特性：Optional类&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Shell学习笔记I</title>
    <link href="http://yoursite.com/2019/09/16/Shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0I/"/>
    <id>http://yoursite.com/2019/09/16/Shell学习笔记I/</id>
    <published>2019-09-16T10:51:12.000Z</published>
    <updated>2019-09-17T06:20:30.433Z</updated>
    
    <content type="html"><![CDATA[<p>Shell脚本编程，懒虫的最爱。</p><a id="more"></a><p>世界的进步是由一群聪明的懒人推动的，可惜自己不但不聪明，还很懒。每次写完博客总打着熟悉git操作的旗号手动部署，终于洗心革面决定写个脚本来自动部署。</p><pre><code>#!/bin/bashcd /Users/liyiye/yiye-project/liyiye012.github.iogit add .git commit -m &quot;github.io 自动部署&quot;git pushhexo cleanhexo ghexo d</code></pre><p>这里写下Shell脚本学习的过程。</p><h1 id="What-is-Shell-and-Shell-Script"><a href="#What-is-Shell-and-Shell-Script" class="headerlink" title="What is Shell and Shell Script"></a>What is Shell and Shell Script</h1><p>shell是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。Ken Thompson的sh是第一种Unix Shell，Windows Explorer是一个典型的图形界面Shell。</p><p>Shell脚本(Shell script)是一种电脑程序与文本文件，内容由一连串的shell命令组成，经由Unix Shell直译其内容后运作。</p><p>被当成是一种脚本语言来设计，其运作方式与直译语言相当，由Unix shell扮演命令行解释器的角色，在读取shell script之后，依序运行其中的shell命令，之后输出结果。利用Shell script可以进行系统管理，文件操作等。</p><p>业界所说的shell通常都是指shell脚本，但读者朋友要知道，shell和shell script是两个不同的概念。由于习惯的原因，简洁起见，本文出现的“shell编程”都是指shell脚本编程，不是指开发shell自身（如Windows Explorer扩展开发）</p><p>打开文本编辑器，新建一个文本文件，并命名为 test.sh。</p><p>扩展名sh代表 shell，扩展名并不影响脚本执行，见名知意就好，如果用 php 写 shell 脚本，扩展名也可以用php。</p><h2 id="第一个shell脚本-Hello-World"><a href="#第一个shell脚本-Hello-World" class="headerlink" title="第一个shell脚本 Hello World"></a>第一个shell脚本 Hello World</h2><p>在 test.sh 中输入代码：</p><pre><code>#!/bin/bashecho &quot;Hello World !&quot;  #这是一条语句</code></pre><p>第 1 行的#!是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell；后面的/bin/bash就是指明了解释器的具体位置。</p><p>第 2 行的 echo 命令用于向标准输出文件（Standard Output，stdout，一般就是指显示器）输出文本。在.sh文件中使用命令与在终端直接输入命令的效果是一样的。</p><p>第 2 行的#及其后面的内容是注释。Shell 脚本中所有以#开头的都是注释（当然以#!开头的除外）</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>运行Shell脚本有两种方法：</p><h3 id="作为可执行程序"><a href="#作为可执行程序" class="headerlink" title="作为可执行程序"></a>作为可执行程序</h3><pre><code>chmod +x test.sh./test.sh</code></pre><p>注意，一定要写成./test.sh，而不是test.sh，运行其它二进制的程序也一样，直接写test.sh，linux系统会去PATH里寻找有没有叫test.sh的，而只有/bin, /sbin, /usr/bin，/usr/sbin等在PATH里，你的当前目录通常不在PATH里，所以写成test.sh是会找不到命令的，要用./test.sh告诉系统说，就在当前目录找。</p><p>通过这种方式运行bash脚本，第一行一定要写对，好让系统查找到正确的解释器。</p><p>这里的”系统”，其实就是shell这个应用程序（想象一下Windows Explorer），但我故意写成系统，是方便理解，既然这个系统就是指shell，那么一个使用/bin/sh作为解释器的脚本是不是可以省去第一行呢？是的。</p><h3 id="作为解释器参数"><a href="#作为解释器参数" class="headerlink" title="作为解释器参数"></a>作为解释器参数</h3><p>这种运行方式是，直接运行解释器，其参数就是shell脚本的文件名，如：</p><pre><code>/bin/sh test.sh/bin/php test.php</code></pre><p>这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。</p><h2 id="stdin"><a href="#stdin" class="headerlink" title="stdin"></a>stdin</h2><pre><code>#!/bin/bashecho &quot;What is your name?&quot;read PERSONecho &quot;Hello, $PERSON&quot;</code></pre><p>第 3 行中表示从终端读取用户输入的数据，并赋值给 PERSON 变量。read 命令用来从标准输入文件（Standard Input，stdin，一般就是指键盘）读取用户输入的数据。</p><p>第 4 行表示输出变量 PERSON 的内容。注意在变量名前边要加上$，否则变量名会作为字符串的一部分处理。</p><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><pre><code>#!/bin/shcd ~mkdir shell_tutcd shell_tutfor ((i=0; i&lt;10; i++)); do    touch test_$i.txtdone</code></pre><p>示例解释</p><pre><code>第1行：指定脚本解释器，这里是用/bin/sh做解释器的第2行：切换到当前用户的home目录第3行：创建一个目录shell_tut第4行：切换到shell_tut目录第5行：循环条件，一共循环10次第6行：创建一个test_0…9.txt文件第7行：循环体结束</code></pre><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><p>定义变量时，变量名不加美元符号（$），如：</p><pre><code>your_name=&quot;qinjx&quot;</code></pre><p>注意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。</p><p>除了显式地直接赋值，还可以用语句给变量赋值，如：</p><pre><code>for file in `ls /etc`</code></pre><h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><p>使用一个定义过的变量，只要在变量名前面加美元符号即可，如：</p><pre><code>your_name=&quot;qinjx&quot;echo $your_nameecho ${your_name}</code></pre><p>变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：</p><pre><code>for skill in Ada Coffe Action Java; do    echo &quot;I am good at ${skill}Script&quot;done</code></pre><p>如果不给skill变量加花括号，写成echo “I am good at $skillScript”，解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。</p><p>推荐给所有变量加上花括号，这是个好的编程习惯。IntelliJ IDEA编写shell script时，IDE就会提示加花括号。</p><h2 id="重定义变量"><a href="#重定义变量" class="headerlink" title="重定义变量"></a>重定义变量</h2><p>已定义的变量，可以被重新定义，如：</p><pre><code>your_name=&quot;qinjx&quot;echo $your_nameyour_name=&quot;alibaba&quot;echo $your_name</code></pre><p>这样写是合法的，但注意，第二次赋值的时候不能写$your_name=”alibaba”，使用变量的时候才加美元符。</p><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>以“#”开头的行就是注释，会被解释器忽略。</p><p>##多行注释<br>sh里没有多行注释，只能每一行加一个#号。</p><p>如果在开发过程中，遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？每一行加个#符号太费力了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。</p><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>字符串是shell编程中最常用最有用的数据类型，字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟PHP类似。</p><h2 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h2><pre><code>str=&apos;this is a string&apos;</code></pre><h3 id="单引号字符串的限制："><a href="#单引号字符串的限制：" class="headerlink" title="单引号字符串的限制："></a>单引号字符串的限制：</h3><p>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的</p><p>单引号字串中不能出现单引号（对单引号使用转义符后也不行）</p><h2 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h2><pre><code>your_name=&apos;qinjx&apos;str=&quot;Hello, I know your are \&quot;$your_name\&quot;! \n&quot;</code></pre><p>双引号里可以有变量</p><p>双引号里可以出现转义字符</p><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h3><pre><code>your_name=&quot;qinjx&quot;greeting=&quot;hello, &quot;$your_name&quot; !&quot;greeting_1=&quot;hello, ${your_name} !&quot;echo $greeting $greeting_1</code></pre><h3 id="获取字符串长度："><a href="#获取字符串长度：" class="headerlink" title="获取字符串长度："></a>获取字符串长度：</h3><pre><code>string=&quot;abcd&quot;echo ${#string} #输出：4</code></pre><h3 id="提取子字符串"><a href="#提取子字符串" class="headerlink" title="提取子字符串"></a>提取子字符串</h3><pre><code>string=&quot;alibaba is a great company&quot;echo ${string:1:4} #输出：liba</code></pre><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><h1 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h1><h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><p>和Java、PHP等语言不一样，sh的流程控制不可为空，如：</p><pre><code>&lt;?phpif (isset($_GET[&quot;q&quot;])) {    search(q);}else {    //do nothing}</code></pre><p>在sh/bash里可不能这么写，如果else分支没有语句执行，就不要写这个else。</p><p>还要注意，sh里的if [ $foo -eq 0 ]，这个方括号跟Java/PHP里if后面的圆括号大不相同，它是一个可执行程序（和ls, grep一样），想不到吧？在CentOS上，它在/usr/bin目录下：</p><pre><code>ll /usr/bin/[-rwxr-xr-x. 1 root root 33408 6月  22 2012 /usr/bin/[</code></pre><p>正因为方括号在这里是一个可执行程序，方括号后面必须加空格，不能写成if [$foo -eq 0]</p><h2 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><pre><code>if conditionthen    command1    command2    ...    commandNfi</code></pre><p>写成一行（适用于终端命令提示符）：</p><pre><code>if `ps -ef | grep ssh`;  then echo hello; fi</code></pre><p>末尾的fi就是if倒过来拼写，后面还会遇到类似的</p><h3 id="if-else-1"><a href="#if-else-1" class="headerlink" title="if else"></a>if else</h3><pre><code>if conditionthen    command1    command2    ...    commandNelse    commandfi</code></pre><h3 id="if-else-if-else"><a href="#if-else-if-else" class="headerlink" title="if else-if else"></a>if else-if else</h3><pre><code>if condition1then    command1elif condition2    command2else    commandNfi</code></pre><h2 id="for-while"><a href="#for-while" class="headerlink" title="for while"></a>for while</h2><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>在开篇的示例里演示过了：</p><pre><code>for var in item1 item2 ... itemNdo    command1    command2    ...    commandNdone</code></pre><p>写成一行：</p><pre><code>for var in item1 item2 ... itemN; do command1; command2… done;</code></pre><h3 id="C风格的for"><a href="#C风格的for" class="headerlink" title="C风格的for"></a>C风格的for</h3><pre><code>for (( EXP1; EXP2; EXP3 ))do    command1    command2    command3done</code></pre><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><pre><code>while conditiondo    commanddone</code></pre><h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h3><pre><code>while :do    commanddone</code></pre><p>或者</p><pre><code>while truedo    commanddone</code></pre><p>或者</p><pre><code>for (( ; ; ))</code></pre><h3 id="until"><a href="#until" class="headerlink" title="until"></a>until</h3><pre><code>until conditiondo    commanddone</code></pre><h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><pre><code>case &quot;${opt}&quot; in    &quot;Install-Puppet-Server&quot; )        install_master $1        exit    ;;    &quot;Install-Puppet-Client&quot; )        install_client $1        exit    ;;    &quot;Config-Puppet-Server&quot; )        config_puppet_master        exit    ;;    &quot;Config-Puppet-Client&quot; )        config_puppet_client        exit    ;;    &quot;Exit&quot; )        exit    ;;    * ) echo &quot;Bad option, please choose again&quot;esac</code></pre><p>case的语法和C family语言差别很大，它需要一个esac（就是case反过来）作为结束标记，每个case分支用右圆括号，用两个分号表示break</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><p>可以使用source和.关键字，如：</p><pre><code>source ./function.sh. ./function.sh</code></pre><p>在bash里，source和.是等效的，他们都是读入function.sh的内容并执行其内容（类似PHP里的include），为了更好的可移植性，推荐使用第二种写法。</p><p>包含一个文件和执行一个文件一样，也要写这个文件的路径，不能光写文件名，比如上述例子中:</p><p>  . ./function.sh<br>不可以写作：</p><p>  . function.sh<br>如果function.sh是用户传入的参数，如何获得它的绝对路径呢？方法是：</p><pre><code>real_path=`readlink -f $1`#$1是用户输入的参数，如function.sh. $real_path</code></pre><h1 id="用户输入"><a href="#用户输入" class="headerlink" title="用户输入"></a>用户输入</h1><h2 id="执行脚本时传入"><a href="#执行脚本时传入" class="headerlink" title="执行脚本时传入"></a>执行脚本时传入</h2><h2 id="脚本运行中输入"><a href="#脚本运行中输入" class="headerlink" title="脚本运行中输入"></a>脚本运行中输入</h2><h2 id="select菜单"><a href="#select菜单" class="headerlink" title="select菜单"></a>select菜单</h2><h2 id="stdin和stdout"><a href="#stdin和stdout" class="headerlink" title="stdin和stdout"></a>stdin和stdout</h2><h1 id="常用的命令"><a href="#常用的命令" class="headerlink" title="常用的命令"></a>常用的命令</h1><p>sh脚本结合系统命令便有了强大的威力，在字符处理领域，有grep、awk、sed三剑客，grep负责找出特定的行，awk能将行拆分成多个字段，sed则可以实现更新插入删除等写操作。</p><h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p>查看进程列表</p><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>排除grep自身<br>查找与target相邻的结果</p><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><h2 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h2><h1 id="脚本解释器"><a href="#脚本解释器" class="headerlink" title="脚本解释器"></a>脚本解释器</h1><h2 id="sh"><a href="#sh" class="headerlink" title="sh"></a>sh</h2><p>即Bourne shell，POSIX（Portable Operating System Interface）标准的shell解释器，它的二进制文件路径通常是/bin/sh，由Bell Labs开发。</p><p>下面讲的是sh，如果使用其它语言用作shell编程，请参考相应语言的文档。</p><h2 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h2><p>Bash是Bourne shell的替代品，属GNU Project，二进制文件路径通常是/bin/bash。业界通常混用bash、sh、和shell，比如你会经常在招聘运维工程师的文案中见到：熟悉Linux Bash编程，精通Shell编程。</p><p>在CentOS里，/bin/sh是一个指向/bin/bash的符号链接:</p><pre><code>[root@centosraw ~]# ls -l /bin/*sh-rwxr-xr-x. 1 root root 903272 Feb 22 05:09 /bin/bash-rwxr-xr-x. 1 root root 106216 Oct 17  2012 /bin/dashlrwxrwxrwx. 1 root root      4 Mar 22 10:22 /bin/sh -&gt; bash</code></pre><p>但在Mac OS上不是，/bin/sh和/bin/bash是两个不同的文件，尽管它们的大小只相差100字节左右:</p><pre><code>iMac:~ wuxiao$ ls -l /bin/*sh-r-xr-xr-x  1 root  wheel  1371648  6 Nov 16:52 /bin/bash-rwxr-xr-x  2 root  wheel   772992  6 Nov 16:52 /bin/csh-r-xr-xr-x  1 root  wheel  2180736  6 Nov 16:52 /bin/ksh-r-xr-xr-x  1 root  wheel  1371712  6 Nov 16:52 /bin/sh-rwxr-xr-x  2 root  wheel   772992  6 Nov 16:52 /bin/tcsh-rwxr-xr-x  1 root  wheel  1103984  6 Nov 16:52 /bin/zsh</code></pre><h1 id="高级编程语言"><a href="#高级编程语言" class="headerlink" title="高级编程语言"></a>高级编程语言</h1><p>理论上讲，只要一门语言提供了解释器（而不仅是编译器），这门语言就可以胜任脚本编程，常见的解释型语言都是可以用作脚本编程的，如：Perl、Tcl、Python、PHP、Ruby。Perl是最老牌的脚本编程语言了，Python这些年也成了一些linux发行版的预置解释器。</p><p>编译型语言，只要有解释器，也可以用作脚本编程，如C shell是内置的（/bin/csh），Java有第三方解释器Jshell，Ada有收费的解释器AdaScript。</p><h1 id="如何选择shell编程语言"><a href="#如何选择shell编程语言" class="headerlink" title="如何选择shell编程语言"></a>如何选择shell编程语言</h1><h2 id="熟悉-vs-陌生"><a href="#熟悉-vs-陌生" class="headerlink" title="熟悉 vs 陌生"></a>熟悉 vs 陌生</h2><p>如果你已经掌握了一门编程语言（如PHP、Python、Java、JavaScript），建议你就直接使用这门语言编写脚本程序，虽然某些地方会有点啰嗦，但你能利用在这门语言领域里的经验（单元测试、单步调试、IDE、第三方类库）。</p><p>新增的学习成本很小，只要学会怎么使用shell解释器（Jshell、AdaScript）就可以了。</p><h2 id="简单-vs-高级"><a href="#简单-vs-高级" class="headerlink" title="简单 vs 高级"></a>简单 vs 高级</h2><p>如果你觉得自己熟悉的语言（如Java、C）写shell脚本实在太啰嗦，你只是想做一些备份文件、安装软件、下载数据之类的事情，学着使用sh，bash会是一个好主意。</p><p>shell只定义了一个非常简单的编程语言，所以，如果你的脚本程序复杂度较高，或者要操作的数据结构比较复杂，那么还是应该使用Python、Perl这样的脚本语言，或者是你本来就已经很擅长的高级语言。因为sh和bash在这方面很弱，比如说：</p><p><strong><em>它的函数只能返回字串，无法返回数组</em></strong></p><p><strong><em>它不支持面向对象，你无法实现一些优雅的设计模式</em></strong></p><p><strong><em>它是解释型的，一边解释一边执行，连PHP那种预编译都不是，如果你的脚本包含错误(例如调用了不存在的函数)，只要没执行到这一行，就不会报错</em></strong></p><h2 id="环境兼容性"><a href="#环境兼容性" class="headerlink" title="环境兼容性"></a>环境兼容性</h2><p>如果你的脚本是提供给别的用户使用，使用sh或者bash，你的脚本将具有最好的环境兼容性，perl很早就是linux标配了，python这些年也成了一些linux发行版的标配，至于mac os，它默认安装了perl、python、ruby、php、java等主流编程语言。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】 <a href="https://www.runoob.com/w3cnote/shell-quick-start.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/shell-quick-start.html</a></p><p>【2】 <a href="https://github.com/qinjx/30min_guides/blob/master/shell.md" target="_blank" rel="noopener">https://github.com/qinjx/30min_guides/blob/master/shell.md</a></p><p>【3】 <a href="http://c.biancheng.net/view/735.html" target="_blank" rel="noopener">http://c.biancheng.net/view/735.html</a></p><p>【4】 <a href="http://tldp.org/LDP/abs/html/" target="_blank" rel="noopener">http://tldp.org/LDP/abs/html/</a> ，非常详细，非常易读，大量example，既可以当入门教材，也可以当做工具书查阅</p><p>【5】 <a href="http://www.tutorialspoint.com/unix/unix-shell.htm" target="_blank" rel="noopener">http://www.tutorialspoint.com/unix/unix-shell.htm</a></p><p>【6】 <a href="https://bash.cyberciti.biz/guide/Main_Page" target="_blank" rel="noopener">https://bash.cyberciti.biz/guide/Main_Page</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Shell脚本编程，懒虫的最爱。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Shell" scheme="http://yoursite.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Scala学习笔记I</title>
    <link href="http://yoursite.com/2019/09/10/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0I/"/>
    <id>http://yoursite.com/2019/09/10/Scala学习笔记I/</id>
    <published>2019-09-10T03:32:12.000Z</published>
    <updated>2019-09-25T07:17:36.347Z</updated>
    
    <content type="html"><![CDATA[<p>Scala学习：集合，柯里化，implicit关键字</p><a id="more"></a><h1 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h1><h1 id="fold-foldLeft和foldRight区别与联系"><a href="#fold-foldLeft和foldRight区别与联系" class="headerlink" title="fold,foldLeft和foldRight区别与联系"></a>fold,foldLeft和foldRight区别与联系</h1><p>从本质上说，fold函数将一种格式的输入数据转化成另外一种格式返回。</p><pre><code>def fold(){  val a=List(1,2,3,4)  val res=a.fold(0){    (z,i) =&gt; z+i  }  println(res)  //res=10}</code></pre><p>List中的fold方法需要输入两个参数：初始值以及一个函数。输入的函数也需要输入两个参数：累加值和当前item的索引。那么上面的代码片段发生了什么事？</p><p>代码开始运行的时候，初始值0作为第一个参数传进到fold函数中，list中的第一个item作为第二个参数传进fold函数中。</p><p>1、fold函数开始对传进的两个参数进行计算，在本例中，仅仅是做加法计算，然后返回计算的值；</p><p>2、Fold函数然后将上一步返回的值作为输入函数的第一个参数，并且把list中的下一个item作为第二个参数传进继续计算，同样返回计算的值；</p><p>3、第2步将重复计算，直到list中的所有元素都被遍历之后，返回最后的计算值，整个过程结束；</p><p>4、这虽然是一个简单的例子，让我们来看看一些比较有用的东西。早在后面将会介绍foldLeft函数，并解释它和fold之间的区别，目前，你只需要想象foldLeft函数和fold函数运行过程一样。</p><h1 id="Scala-函数柯里化-Currying"><a href="#Scala-函数柯里化-Currying" class="headerlink" title="Scala 函数柯里化(Currying)"></a>Scala 函数柯里化(Currying)</h1><p>柯里化(Currying)指的是将原来接受两个参数的函数变成新的接受一个参数的函数的过程。新的函数返回一个以原有第二个参数为参数的函数。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>首先我们定义一个函数:</p><pre><code>def add(x:Int,y:Int)=x+y</code></pre><p>那么我们应用的时候，应该是这样用：add(1,2)</p><p>现在我们把这个函数变一下形：</p><pre><code>def add(x:Int)(y:Int) = x + y</code></pre><p>那么我们应用的时候，应该是这样用：add(1)(2),最后结果都一样是3，这种方式（过程）就叫柯里化。</p><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>add(1)(2) 实际上是依次调用两个普通函数（非柯里化函数），第一次调用使用一个参数 x，返回一个函数类型的值，第二次使用参数y调用这个函数类型的值。</p><p>实质上最先演变成这样一个方法：</p><pre><code>def add(x:Int)=(y:Int)=&gt;x+y</code></pre><p>那么这个函数是什么意思呢？ 接收一个x为参数，返回一个匿名函数，该匿名函数的定义是：接收一个Int型参数y，函数体为x+y。现在我们来对这个方法进行调用。</p><pre><code>val result = add(1)</code></pre><p>返回一个result，那result的值应该是一个匿名函数：(y:Int)=&gt;1+y</p><p>所以为了得到结果，我们继续调用result。</p><pre><code>val sum = result(2)</code></pre><p>最后打印出来的结果就是3。</p><h1 id="Implicit详解"><a href="#Implicit详解" class="headerlink" title="Implicit详解"></a>Implicit详解</h1><p>在 Scala 中的 implicit 定义指编译器在需要修复类型匹配时可以用来自动插入的定义。比如说，如果 x+y 类型不匹配，那么编译器可能试着使用 convert(x) + y， 其中 convert 由某个 implicit 定义的，这有点类似一个整数和一个浮点数相加，编译器可以自动把整数转换为浮点数。Scala 的 implicit 定义是对这种情况的一个推广，你可以定义一个类型在需要时，如何自动转换成另外一种类型。</p><p>Scala 的 implicit 定义符合下面一些规则：</p><h2 id="标记规则"><a href="#标记规则" class="headerlink" title="标记规则"></a>标记规则</h2><p>只有哪些使用 implicit 关键字的定义才是可以使用的隐式定义。关键字 implicit 用来标记一个隐式定义。编译器才可以选择它作为隐式变化的候选项。你可以使用 implicit 来标记任意变量，函数或是对象。</p><p>例如下面为一个隐式函数定义：</p><pre><code>implicit def intToString(x:Int) : x.toString</code></pre><p>编译器只有在 convert 被标记成 implicit 才会将 x + y 改成convert(x) + y 。当然这是在 x + y 类型不匹配时。</p><h2 id="范围规则"><a href="#范围规则" class="headerlink" title="范围规则"></a>范围规则</h2><p>编译器在选择备选 implicit 定义时，只会选取当前作用域的定义，比如说编译器不会去调用 someVariable.convert。如果你需要使用 someVariable.convert，你必须把 someVarible 引入到当前作用域。也就是说编译器在选择备选 implicit 时，只有当 convert 是当前作用域下单个标志符时才会作为备选 implicit。比如说，对于一个函数库来说，在一个 Preamble 对象中定义一些常用的隐式类型转换非常常见，因此需要使用 Preamble 的代码可以使用 “import Preamble._”  把这些 implicit 定义引入到当前作用域才可以。</p><p>这个规则有一个例外，编译器也会在类的伙伴对象定义中查找所需的 implicit 定义。例如下面的定义：</p><pre><code>object Dollar {    implicit def dollarToEuro(x:Dollar):Euro = ...    ...}class Dollar {   ...}</code></pre><p>如果在 class Dollar 的方法有需要 Euro 类型，但输入数据使用的是 Dollar，编译器会在其伙伴对象 object Dollar 查找所需的隐式类型转换，本例定义一个从 Dollar 到 Euro 的 implicit 定义可以使用。</p><h2 id="一次规则"><a href="#一次规则" class="headerlink" title="一次规则"></a>一次规则</h2><p>编译器在需要使用 implicit 定义时，只会试图转换一次，也就是编译器永远不会把 x + y 改写成 convert1(convert2(x)) + y。</p><h2 id="优先规则"><a href="#优先规则" class="headerlink" title="优先规则"></a>优先规则</h2><p>编译器不会在 x+y 已经是合法的情况下去调用 implicit 规则。</p><h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><p>你可以为 implicit 定义任意的名称。通常情况下你可以任意命名，implicit 的名称只在两种情况下有用：一是你想在一个方法中明确指明，另外一个是想把那一个引入到当前作用域。比如我们定义一个对象，包含两个 implicit定义：</p><pre><code>object MyConversions {    implicit def stringWrapper(s:String):IndexedSeq[Char] = ...    implicit def intToString(x:Int):String = ...}</code></pre><p>在你的应用中，你想使用 stringWrapper 变换，而不想把整数自动转换成字符串，你可以只引入 stringWrapper。</p><pre><code>import  MyConversions.stringWrapper</code></pre><h2 id="编译器使用-implicit-的几种情况"><a href="#编译器使用-implicit-的几种情况" class="headerlink" title="编译器使用 implicit 的几种情况"></a>编译器使用 implicit 的几种情况</h2><p>有三种情况使用 implicit: 一是转换成预期的数据类型，二是转换 selection 的 receiver，三是隐含参数。转换成预期的数据类型比如你有一个方法参数类型是 IndexedSeq[Char]，在你传入 String 时，编译器发现类型不匹配，就检查当前作用域是否有从 String 到 IndexedSeq 隐式转换。</p><p>转换 selection 的 receiver 允许你适应某些方法调用，比如 “abc”.exist ，”abc”类型为 String，本身没有定义 exist 方法，这时编辑器就检查当前作用域内 String 的隐式转换后的类型是否有 exist 方法，发现 stringWrapper 转换后成 IndexedSeq 类型后，可以有 exist 方法，这个和 C# 静态扩展方法功能类似。</p><p>隐含参数有点类似是缺省参数，如果在调用方法时没有提供某个参数，编译器会查找当前作用域是否有符合条件的 implicit 对象作为参数传入（有点类似 dependency injection)。</p><h2 id="implicit-function-隐式函数"><a href="#implicit-function-隐式函数" class="headerlink" title="implicit function 隐式函数"></a>implicit function 隐式函数</h2><h3 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h3><p>第一种implicit的用法，是将其加在function定义的前面，形式为:</p><pre><code>implicit def int2String(someInt: Int): String = {  //...}</code></pre><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>这种用法可以用来进行implicit conversion，隐式转换，也就是说，编译器可以选择在合适的时候调用这些函数来进行一个转换，来保证类型的正确性，比如我可以通过定义一个implicit的转换函数将java的类型转换为scala的类型，这样在需要scala类型但是却使用java类型作为参数的时候，编译器会自动加入这个转换函数.</p><pre><code>object HelloScala {  implicit def conv(a: Int) = {    println(&quot;in conv&quot;)    a.toString  }  def say(b: String) = println(b)  def main(args: Array[String])  {    say(5)  }}//输出结果:// in conv// 5//这说明过程是say(conv(5))//原因是编译器在检查的时候发现需要一个String类型的参数，但是代入的是一个Int，于是//他会在范围内寻找implicit的function，找到了符合这个要求的String =&gt; Int的function，于是调用</code></pre><h2 id="implicit-parameter-amp-implicit-value-隐式参数和隐式值"><a href="#implicit-parameter-amp-implicit-value-隐式参数和隐式值" class="headerlink" title="implicit parameter &amp; implicit value 隐式参数和隐式值"></a>implicit parameter &amp; implicit value 隐式参数和隐式值</h2><h3 id="形式-1"><a href="#形式-1" class="headerlink" title="形式"></a>形式</h3><h3 id="隐式参数"><a href="#隐式参数" class="headerlink" title="隐式参数"></a>隐式参数</h3><p>隐式参数是在函数中，将参数标志出implicit，形式为:</p><pre><code>def func(implicit x: Int)def func2(x: Int)(implicit y: Int)def func3(implicit x: Int, y: Int)</code></pre><p>这三种形式是有区别的，在参数中implicit只能出现一次，而在此之后，所有的参数都会变为implicit。</p><pre><code>func: x是implicit的func2: 只有y是implicit的func3: x和y都是implicit的</code></pre><p>注意避免以下几种错误写法:<br>      //以下三种情况无法编译通过<br>      def err(x: Int, implicit y: Int)<br>      def err(implicit x: Int)(implicit y: Int)<br>      def err(implicit x: Int)(y: Int)<br>这三种情况都是无法编译通过的</p><h2 id="隐式值"><a href="#隐式值" class="headerlink" title="隐式值"></a>隐式值</h2><pre><code>implicit object Testimplicit val x = 5implicit var y</code></pre><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>这种用法的作用主要是两种用法搭配起来来达到一个效果，隐式参数表明这个参数是可以缺少的，也就是说在调用的时候这个参数可以不用出现，那么这个值由什么填充呢？ 那就是用隐式的值了，以下的例子说明了这一点:<br>    object HelloScala {<br>      abstract class Sayable{<br>        def say<br>      }<br>      implicit object hello extends Sayable{<br>        override def say()={<br>          println(“hello”)<br>        }<br>      }<br>      def func(implicit x:Sayable): Unit ={<br>        x.say<br>      }<br>      implicit val impVal=5<br>      def func1(implicit x:Int)={<br>        println(x)<br>      }<br>      def main(args: Array[String])  {<br>        func<br>        func1<br>      }<br>    }</p><p>输出结果为:</p><pre><code>im in hello5</code></pre><p>因为object的类型并不是object的名字，所以使用了一个抽象class来指明type。</p><p>在调用func的时候，没有代入参数，其参数是由编译器检查之后决定的，而这里决定的就是唯一的可能，hello那个object，所以这里的say调用的就是hello object里的say</p><p>在调用func1的时候，同样没有代入参数，需要一个Int作为参数，编译器寻找值的时候寻找到impVal是implicit的值，所以这里选择impVal作为他的值，输出了5</p><h2 id="implicit-class-隐式类"><a href="#implicit-class-隐式类" class="headerlink" title="implicit class 隐式类"></a>implicit class 隐式类</h2><p>这是一个在scala 2.10中新增的用法</p><h3 id="形式-2"><a href="#形式-2" class="headerlink" title="形式"></a>形式</h3><pre><code>implicit class MyClass(x: Int)</code></pre><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><p>这里的作用主要是其主构造函数可以作为隐式转换的参数，相当于其主构造函数可以用来当做一个implicit的function，下面举例说明一下:</p><pre><code>object HelloScala {  implicit class MyName(x: Int) {    println(&quot;im in cons&quot;)    val y = x  }  def say(x: MyName) = {    println(x.y)  }  def main(args: Array[String])  {    say(5)  }}</code></pre><p>输出结果:</p><pre><code>im in cons5</code></pre><p>这里的MyName是一个隐式类，其主构造函数可以用作隐式转换，所以say需要一个MyName类型的参数，但是调用的时候给的是一个Int，这里就会调用MyName的主构造函数转换为一个MyName的对象，然后再println其y的值</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】 <a href="https://www.iteblog.com/archives/1228.html" target="_blank" rel="noopener">https://www.iteblog.com/archives/1228.html</a><br>【2】 <a href="https://www.runoob.com/scala/currying-functions.html" target="_blank" rel="noopener">https://www.runoob.com/scala/currying-functions.html</a><br>【3】 <a href="https://blog.csdn.net/qq_29343201/article/details/58588470" target="_blank" rel="noopener">https://blog.csdn.net/qq_29343201/article/details/58588470</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Scala学习：集合，柯里化，implicit关键字&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记VIII</title>
    <link href="http://yoursite.com/2019/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0VIII/"/>
    <id>http://yoursite.com/2019/09/06/Java学习笔记VIII/</id>
    <published>2019-09-06T10:43:12.000Z</published>
    <updated>2019-09-16T09:04:07.370Z</updated>
    
    <content type="html"><![CDATA[<p>使用Quzrtz 及Cron定时表达式语法解析</p><a id="more"></a><h1 id="Cron表达式范例："><a href="#Cron表达式范例：" class="headerlink" title="Cron表达式范例："></a>Cron表达式范例：</h1><pre><code>*/10 * * * * ?  每隔10秒执行一次0 */1 * * * ?  每隔1分钟执行一次0 0 23 * * ?  每天23点执行一次0 0 1 * * ?  每天凌晨1点执行一次：0 0 1 1 * ?  每月1号凌晨1点执行一次0 0 23 L * ?  每月最后一天23点执行一次0 0 1 ? * L  每周星期天凌晨1点实行一次0 26,29,33 * * * ?  在26分、29分、33分执行一次0 0 0,13,18,21 * * ? 每天的0点、13点、18点、21点都执行一次</code></pre><h1 id="Cron-表达式"><a href="#Cron-表达式" class="headerlink" title="Cron 表达式"></a>Cron 表达式</h1><p>Cron表达式由7个部分组成，各部分用空格隔开，例如0 0 12 ? * WED（每星期三下午12:00 执行）</p><p>Cron表达式的7个部分从左到右代表的含义如下</p><pre><code>Seconds Minutes Hours Day-of-Month Month Day-of-Week Year</code></pre><p>其中Year是可选的</p><h1 id="Cron表达式可选的值"><a href="#Cron表达式可选的值" class="headerlink" title="Cron表达式可选的值"></a>Cron表达式可选的值</h1><pre><code>Seconds秒：数字0－59Minutes分：数字0－59Hours时 ：数字0-23Day-of-Month月中的几号 ：可以用数字1-31 中的任一一个值，但要注意一些特别的月份Month一年中的几月：可以用0-11 或用字符串 “JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV and DEC” 表示Day-of-Week每周：数字1-7（1 ＝ 星期日），或用字符口串“SUN, MON, TUE, WED, THU, FRI and SAT”字段名                 允许的值                        允许的特殊字符  秒                    0-59                            , - * /  分                    0-59                            , - * /  小时                  0-23                            , - * /  日                    1-31                            , - * ? / L W C  月                    1-12 or JAN-DEC                 , - * /  周几                  1-7 or SUN-SAT                   , - * ? / L C #  年 (可选字段)          empty, 1970-2099                 , - * /</code></pre><h1 id="Cron中的符号"><a href="#Cron中的符号" class="headerlink" title="Cron中的符号"></a>Cron中的符号</h1><pre><code>* ：代表整个时间段./ ：表示每多长时间执行一次0/15表示每隔15分钟执行一次,“0”表示为从“0”分开始；3/20表示每隔20分钟执行一次，“3”表示从第3分钟开始执行? ：表示每月的某一天，或第几周的某一天L ：“6L”表示“每月的最后一个星期五”W：表示为最近工作日如“15W”放在每月（day-of-month）字段上表示为“到本月15日最近的工作日”#：是用来指定“的”每月第n个工作日&quot;6#3&quot;或者&quot;FRI#3&quot;:在每周（day-of-week）中表示“每月第三个星期五”问号(?)就是用来对日期和星期字段做互斥的，问号(?)的作用是指明该字段‘没有特定的值’，星号(*)和其它值，比如数字，都是给该字段指明特定的值，而星号(*)代表所有，在天时表示每一天。“?”字符：表示不确定的值“,”字符：指定数个值“-”字符：指定一个值的范围“/”字符：指定一个值的增加幅度。n/m表示从n开始，每次增加m“L”字符：用在日表示一个月中的最后一天，用在周表示该月最后一个星期X“W”字符：指定离给定日期最近的工作日(周一到周五)“#”字符：表示该月第几个周X。6#3表示该月第3个周五</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<br><a href="https://www.jianshu.com/p/f03b1497122a" target="_blank" rel="noopener">https://www.jianshu.com/p/f03b1497122a</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Quzrtz 及Cron定时表达式语法解析&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记VII</title>
    <link href="http://yoursite.com/2019/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0VII/"/>
    <id>http://yoursite.com/2019/09/06/Java学习笔记VII/</id>
    <published>2019-09-06T07:12:12.000Z</published>
    <updated>2019-09-06T07:43:28.956Z</updated>
    
    <content type="html"><![CDATA[<p>Java并发编程中synchronized的概念</p><a id="more"></a><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>synchronized 是 Java 中的关键字，是利用锁的机制来实现同步的。<br>锁机制有如下两种特性：</p><h2 id="互斥性："><a href="#互斥性：" class="headerlink" title="互斥性："></a>互斥性：</h2><p>即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程中的协调机制，这样在同一时间只有一个线程对需同步的代码块(复合操作)进行访问。互斥性我们也往往称为操作的原子性。</p><h2 id="可见性："><a href="#可见性：" class="headerlink" title="可见性："></a>可见性：</h2><p>必须确保在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的（即在获得锁时应获得最新共享变量的值），否则另一个线程可能是在本地缓存的某个副本上继续操作从而引起不一致。</p><h1 id="对象锁和类锁"><a href="#对象锁和类锁" class="headerlink" title="对象锁和类锁"></a>对象锁和类锁</h1><h2 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h2><p>在 Java 中，每个对象都会有一个 monitor 对象，这个对象其实就是 Java 对象的锁，通常会被称为“内置锁”或“对象锁”。类的对象可以有多个，所以每个对象有其独立的对象锁，互不干扰。</p><h2 id="类锁"><a href="#类锁" class="headerlink" title="类锁"></a>类锁</h2><p>在 Java 中，针对每个类也有一个锁，可以称为“类锁”，类锁实际上是通过对象锁实现的，即类的 Class 对象锁。每个类只有一个 Class 对象，所以每个类只有一个类锁。</p><h1 id="synchronized-的用法分类"><a href="#synchronized-的用法分类" class="headerlink" title="synchronized 的用法分类"></a>synchronized 的用法分类</h1><p>synchronized 的用法可以从两个维度上面分类：</p><h2 id="根据修饰对象分类"><a href="#根据修饰对象分类" class="headerlink" title="根据修饰对象分类"></a>根据修饰对象分类</h2><p>synchronized 可以修饰方法和代码块</p><h3 id="修饰代码块"><a href="#修饰代码块" class="headerlink" title="修饰代码块"></a>修饰代码块</h3><pre><code>synchronized(this|object) {}synchronized(类.class) {}</code></pre><h3 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h3><p>修饰非静态方法</p><p>修饰静态方法</p><h2 id="根据获取的锁分类"><a href="#根据获取的锁分类" class="headerlink" title="根据获取的锁分类"></a>根据获取的锁分类</h2><h3 id="获取对象锁"><a href="#获取对象锁" class="headerlink" title="获取对象锁"></a>获取对象锁</h3><pre><code>synchronized(this|object) {}</code></pre><p>修饰非静态方法</p><h3 id="获取类锁"><a href="#获取类锁" class="headerlink" title="获取类锁"></a>获取类锁</h3><pre><code>synchronized(类.class) {}</code></pre><p>修饰静态方法</p><h1 id="synchronized-的用法详解"><a href="#synchronized-的用法详解" class="headerlink" title="synchronized 的用法详解"></a>synchronized 的用法详解</h1><p>这里根据获取的锁分类来分析 synchronized 的用法</p><h2 id="获取对象锁-1"><a href="#获取对象锁-1" class="headerlink" title="获取对象锁"></a>获取对象锁</h2><h3 id="对于同一对象"><a href="#对于同一对象" class="headerlink" title="对于同一对象"></a>对于同一对象</h3><p>同步线程类：</p><pre><code>class SyncThread implements Runnable {    @Override    public void run() {        String threadName = Thread.currentThread().getName();        if (threadName.startsWith(&quot;A&quot;)) {            async();        } else if (threadName.startsWith(&quot;B&quot;)) {            sync1();        } else if (threadName.startsWith(&quot;C&quot;)) {            sync2();        }    }    /**     * 异步方法     */    private void async() {        try {            System.out.println(Thread.currentThread().getName() + &quot;_Async_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            Thread.sleep(2000);            System.out.println(Thread.currentThread().getName() + &quot;_Async_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));        } catch (InterruptedException e) {            e.printStackTrace();        }    }    /**     * 方法中有 synchronized(this|object) {} 同步代码块     */    private void sync1() {        System.out.println(Thread.currentThread().getName() + &quot;_Sync1: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));        synchronized (this) {            try {                System.out.println(Thread.currentThread().getName() + &quot;_Sync1_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));                Thread.sleep(2000);                System.out.println(Thread.currentThread().getName() + &quot;_Sync1_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }    /**     * synchronized 修饰非静态方法     */    private synchronized void sync2() {        System.out.println(Thread.currentThread().getName() + &quot;_Sync2: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));        try {            System.out.println(Thread.currentThread().getName() + &quot;_Sync2_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            Thread.sleep(2000);            System.out.println(Thread.currentThread().getName() + &quot;_Sync2_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><p>测试代码：</p><pre><code>public class SyncTest {    public static void main(String... args) {        SyncThread syncThread = new SyncThread();        Thread A_thread1 = new Thread(syncThread, &quot;A_thread1&quot;);        Thread A_thread2 = new Thread(syncThread, &quot;A_thread2&quot;);        Thread B_thread1 = new Thread(syncThread, &quot;B_thread1&quot;);        Thread B_thread2 = new Thread(syncThread, &quot;B_thread2&quot;);        Thread C_thread1 = new Thread(syncThread, &quot;C_thread1&quot;);        Thread C_thread2 = new Thread(syncThread, &quot;C_thread2&quot;);        A_thread1.start();        A_thread2.start();        B_thread1.start();        B_thread2.start();        C_thread1.start();        C_thread2.start();    }}</code></pre><p>运行结果：</p><pre><code>B_thread2_Sync1: 14:44:20A_thread1_Async_Start: 14:44:20B_thread1_Sync1: 14:44:20C_thread1_Sync2: 14:44:20A_thread2_Async_Start: 14:44:20C_thread1_Sync2_Start: 14:44:20A_thread1_Async_End: 14:44:22A_thread2_Async_End: 14:44:22C_thread1_Sync2_End: 14:44:22B_thread1_Sync1_Start: 14:44:22B_thread1_Sync1_End: 14:44:24B_thread2_Sync1_Start: 14:44:24B_thread2_Sync1_End: 14:44:26C_thread2_Sync2: 14:44:26C_thread2_Sync2_Start: 14:44:26C_thread2_Sync2_End: 14:44:28</code></pre><p>结果分析：</p><p>A 类线程访问方法中没有同步代码块，A 类线程是异步的，所以有线程访问对象的同步代码块时，另外的线程可以访问该对象的非同步代码块：</p><pre><code>A_thread1_Async_Start: 14:44:20A_thread2_Async_Start: 14:44:20A_thread1_Async_End: 14:44:22A_thread2_Async_End: 14:44:22</code></pre><p>B 类线程访问的方法中有同步代码块，B 类线程是同步的，一个线程在访问对象的同步代码块，另一个访问对象的同步代码块的线程会被阻塞：</p><pre><code>B_thread1_Sync1_End: 14:44:24B_thread2_Sync1_Start: 14:44:24B_thread2_Sync1_End: 14:44:26synchronized(this|object) {} 代码块 {} 之外的代码依然是异步的：B_thread2_Sync1: 14:44:20B_thread1_Sync1: 14:44:20</code></pre><p>C 类线程访问的是 synchronized 修饰非静态方法，C 类线程是同步的，一个线程在访问对象的同步代方法，另一个访问对象同步方法的线程会被阻塞：</p><pre><code>C_thread1_Sync2_Start: 14:44:20C_thread1_Sync2_End: 14:44:22C_thread2_Sync2_Start: 14:44:26C_thread2_Sync2_End: 14:44:28</code></pre><p>synchronized 修饰非静态方法，作用范围是整个方法，所以方法中所有的代码都是同步的：</p><pre><code>C_thread1_Sync2: 14:44:20C_thread2_Sync2: 14:44:26</code></pre><p>由结果可知 B 类和 C 类线程顺序执行，类中 synchronized(this|object) {} 代码块和 synchronized 修饰非静态方法获取的锁是同一个锁，即该类的对象的对象锁。所以 B 类线程和 C 类线程也是同步的：</p><pre><code>B_thread1_Sync1_Start: 14:44:22B_thread1_Sync1_End: 14:44:24C_thread1_Sync2_Start: 14:44:20C_thread1_Sync2_End: 14:44:22B_thread2_Sync1_Start: 14:44:24B_thread2_Sync1_End: 14:44:26C_thread2_Sync2_Start: 14:44:26C_thread2_Sync2_End: 14:44:28</code></pre><h3 id="对于不同对象"><a href="#对于不同对象" class="headerlink" title="对于不同对象"></a>对于不同对象</h3><p>修改测试代码为：</p><pre><code>public class SyncTest {    public static void main(String... args) {        Thread A_thread1 = new Thread(new SyncThread(), &quot;A_thread1&quot;);        Thread A_thread2 = new Thread(new SyncThread(), &quot;A_thread2&quot;);        Thread B_thread1 = new Thread(new SyncThread(), &quot;B_thread1&quot;);        Thread B_thread2 = new Thread(new SyncThread(), &quot;B_thread2&quot;);        Thread C_thread1 = new Thread(new SyncThread(), &quot;C_thread1&quot;);        Thread C_thread2 = new Thread(new SyncThread(), &quot;C_thread2&quot;);        A_thread1.start();        A_thread2.start();        B_thread1.start();        B_thread2.start();        C_thread1.start();        C_thread2.start();    }}</code></pre><p>运行结果：</p><pre><code>A_thread2_Async_Start: 15:01:34C_thread2_Sync2: 15:01:34B_thread2_Sync1: 15:01:34C_thread1_Sync2: 15:01:34B_thread2_Sync1_Start: 15:01:34B_thread1_Sync1: 15:01:34C_thread1_Sync2_Start: 15:01:34A_thread1_Async_Start: 15:01:34C_thread2_Sync2_Start: 15:01:34B_thread1_Sync1_Start: 15:01:34C_thread1_Sync2_End: 15:01:36A_thread1_Async_End: 15:01:36C_thread2_Sync2_End: 15:01:36B_thread2_Sync1_End: 15:01:36B_thread1_Sync1_End: 15:01:36A_thread2_Async_End: 15:01:36</code></pre><p>结果分析：</p><p>两个线程访问不同对象的 synchronized(this|object) {} 代码块和 synchronized 修饰非静态方法是异步的，同一个类的不同对象的对象锁互不干扰。</p><h2 id="获取类锁-1"><a href="#获取类锁-1" class="headerlink" title="获取类锁"></a>获取类锁</h2><h3 id="对于同一对象-1"><a href="#对于同一对象-1" class="headerlink" title="对于同一对象"></a>对于同一对象</h3><p>同步线程类：</p><pre><code>class SyncThread implements Runnable {    @Override    public void run() {        String threadName = Thread.currentThread().getName();        if (threadName.startsWith(&quot;A&quot;)) {            async();        } else if (threadName.startsWith(&quot;B&quot;)) {            sync1();        } else if (threadName.startsWith(&quot;C&quot;)) {            sync2();        }    }    /**     * 异步方法     */    private void async() {        try {            System.out.println(Thread.currentThread().getName() + &quot;_Async_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            Thread.sleep(2000);            System.out.println(Thread.currentThread().getName() + &quot;_Async_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));        } catch (InterruptedException e) {            e.printStackTrace();        }    }    /**     * 方法中有 synchronized(类.class) {} 同步代码块     */    private void sync1() {        System.out.println(Thread.currentThread().getName() + &quot;_Sync1: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));        synchronized (SyncThread.class) {            try {                System.out.println(Thread.currentThread().getName() + &quot;_Sync1_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));                Thread.sleep(2000);                System.out.println(Thread.currentThread().getName() + &quot;_Sync1_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }    /**     * synchronized 修饰静态方法     */    private synchronized static void sync2() {        System.out.println(Thread.currentThread().getName() + &quot;_Sync2: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));        try {            System.out.println(Thread.currentThread().getName() + &quot;_Sync2_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            Thread.sleep(2000);            System.out.println(Thread.currentThread().getName() + &quot;_Sync2_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><p>测试代码：</p><pre><code>public class SyncTest {    public static void main(String... args) {        SyncThread syncThread = new SyncThread();        Thread A_thread1 = new Thread(syncThread, &quot;A_thread1&quot;);        Thread A_thread2 = new Thread(syncThread, &quot;A_thread2&quot;);        Thread B_thread1 = new Thread(syncThread, &quot;B_thread1&quot;);        Thread B_thread2 = new Thread(syncThread, &quot;B_thread2&quot;);        Thread C_thread1 = new Thread(syncThread, &quot;C_thread1&quot;);        Thread C_thread2 = new Thread(syncThread, &quot;C_thread2&quot;);        A_thread1.start();        A_thread2.start();        B_thread1.start();        B_thread2.start();        C_thread1.start();        C_thread2.start();    }}</code></pre><p>运行结果：</p><pre><code>B_thread1_Sync1: 15:08:13C_thread1_Sync2: 15:08:13B_thread2_Sync1: 15:08:13A_thread1_Async_Start: 15:08:13C_thread1_Sync2_Start: 15:08:13A_thread2_Async_Start: 15:08:13C_thread1_Sync2_End: 15:08:15A_thread2_Async_End: 15:08:15A_thread1_Async_End: 15:08:15B_thread2_Sync1_Start: 15:08:15B_thread2_Sync1_End: 15:08:17B_thread1_Sync1_Start: 15:08:17B_thread1_Sync1_End: 15:08:19C_thread2_Sync2: 15:08:19C_thread2_Sync2_Start: 15:08:19C_thread2_Sync2_End: 15:08:21</code></pre><p>结果分析：</p><p>由结果可以看出，在同一对象的情况下，synchronized(类.class) {} 代码块或 synchronized 修饰静态方法和 synchronized(this|object) {} 代码块和 synchronized 修饰非静态方法的行为一致。</p><h3 id="对于不同对象-1"><a href="#对于不同对象-1" class="headerlink" title="对于不同对象"></a>对于不同对象</h3><p>修改测试代码为：</p><pre><code>public class SyncTest {    public static void main(String... args) {        Thread A_thread1 = new Thread(new SyncThread(), &quot;A_thread1&quot;);        Thread A_thread2 = new Thread(new SyncThread(), &quot;A_thread2&quot;);        Thread B_thread1 = new Thread(new SyncThread(), &quot;B_thread1&quot;);        Thread B_thread2 = new Thread(new SyncThread(), &quot;B_thread2&quot;);        Thread C_thread1 = new Thread(new SyncThread(), &quot;C_thread1&quot;);        Thread C_thread2 = new Thread(new SyncThread(), &quot;C_thread2&quot;);        A_thread1.start();        A_thread2.start();        B_thread1.start();        B_thread2.start();        C_thread1.start();        C_thread2.start();    }}</code></pre><p>运行结果：</p><pre><code>A_thread2_Async_Start: 15:17:28B_thread2_Sync1: 15:17:28A_thread1_Async_Start: 15:17:28B_thread1_Sync1: 15:17:28C_thread1_Sync2: 15:17:28C_thread1_Sync2_Start: 15:17:28C_thread1_Sync2_End: 15:17:30A_thread2_Async_End: 15:17:30B_thread1_Sync1_Start: 15:17:30A_thread1_Async_End: 15:17:30B_thread1_Sync1_End: 15:17:32B_thread2_Sync1_Start: 15:17:32B_thread2_Sync1_End: 15:17:34C_thread2_Sync2: 15:17:34C_thread2_Sync2_Start: 15:17:34C_thread2_Sync2_End: 15:17:36</code></pre><p>结果分析：</p><p>两个线程访问不同对象的 synchronized(类.class) {} 代码块或 synchronized 修饰静态方法还是同步的，类中 synchronized(类.class) {} 代码块和 synchronized 修饰静态方法获取的锁是类锁。对于同一个类的不同对象的类锁是同一个。</p><h2 id="类中同时有-synchronized-类-class-代码块或-synchronized-修饰静态方法和-synchronized-this-object-代码块和-synchronized-修饰非静态方法时会怎样？"><a href="#类中同时有-synchronized-类-class-代码块或-synchronized-修饰静态方法和-synchronized-this-object-代码块和-synchronized-修饰非静态方法时会怎样？" class="headerlink" title="类中同时有 synchronized(类.class) {} 代码块或 synchronized 修饰静态方法和 synchronized(this|object) {} 代码块和 synchronized 修饰非静态方法时会怎样？"></a>类中同时有 synchronized(类.class) {} 代码块或 synchronized 修饰静态方法和 synchronized(this|object) {} 代码块和 synchronized 修饰非静态方法时会怎样？</h2><p>修改同步线程类：</p><pre><code>class SyncThread implements Runnable {    @Override    public void run() {        String threadName = Thread.currentThread().getName();        if (threadName.startsWith(&quot;A&quot;)) {            async();        } else if (threadName.startsWith(&quot;B&quot;)) {            sync1();        } else if (threadName.startsWith(&quot;C&quot;)) {            sync2();        }    }    /**     * 异步方法     */    private void async() {        try {            System.out.println(Thread.currentThread().getName() + &quot;_Async_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            Thread.sleep(2000);            System.out.println(Thread.currentThread().getName() + &quot;_Async_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));        } catch (InterruptedException e) {            e.printStackTrace();        }    }    /**     * synchronized 修饰非静态方法     */    private synchronized void sync1() {        try {            System.out.println(Thread.currentThread().getName() + &quot;_Sync1_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            Thread.sleep(2000);            System.out.println(Thread.currentThread().getName() + &quot;_Sync1_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));        } catch (InterruptedException e) {            e.printStackTrace();        }    }    /**     * synchronized 修饰静态方法     */    private synchronized static void sync2() {        try {            System.out.println(Thread.currentThread().getName() + &quot;_Sync2_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            Thread.sleep(2000);            System.out.println(Thread.currentThread().getName() + &quot;_Sync2_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><p>修改测试代码：</p><pre><code>public class SyncTest {    public static void main(String... args) {        Thread B_thread1 = new Thread(syncThread, &quot;B_thread1&quot;);        Thread C_thread1 = new Thread(syncThread, &quot;C_thread1&quot;);        B_thread1.start();        C_thread1.start();    }}</code></pre><p>运行结果：</p><pre><code>B_thread1_Sync1_Start: 15:35:21C_thread1_Sync2_Start: 15:35:21B_thread1_Sync1_End: 15:35:23C_thread1_Sync2_End: 15:35:23</code></pre><p>运行结果分析：</p><p>由结果可以看到 B 类线程和 C 类线程是异步的，即 synchronized 修饰静态方法和 synchronized 修饰非静态方法是异步的，对于 synchronized(类.class) {} 代码块和 synchronized(this|object) {} 代码块也是一样的。所以对象锁和类锁是独立的，互不干扰。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>synchronized关键字不能继承。</p><p> 对于父类中的 synchronized 修饰方法，子类在覆盖该方法时，默认情况下不是同步的，必须显示的使用 synchronized 关键字修饰才行。</p><p>在定义接口方法时不能使用synchronized关键字。</p><p>构造方法不能使用synchronized关键字，但可以使用synchronized代码块来进行同步。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】 <a href="https://juejin.im/post/594a24defe88c2006aa01f1c" target="_blank" rel="noopener">https://juejin.im/post/594a24defe88c2006aa01f1c</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java并发编程中synchronized的概念&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记VI</title>
    <link href="http://yoursite.com/2019/09/05/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0VI/"/>
    <id>http://yoursite.com/2019/09/05/Java学习笔记VI/</id>
    <published>2019-09-05T07:12:12.000Z</published>
    <updated>2019-09-05T07:37:21.245Z</updated>
    
    <content type="html"><![CDATA[<p>Java基本数据类型和包装类的区别,不同类型为空的异常判断，集合操作</p><a id="more"></a><p>在实际的工程项目开发中，常遇到对于传入参数的异常处理，对于不同类型的参数需要进行不同的判断，例如有时int，long类型的参数需要判断是否为0，而Integer和Long类型的参数需要判断是否为空。String类型的需要使用StringUtils.isEmpty()</p><h1 id="StringUtils类中isEmpty与isBlank的区别"><a href="#StringUtils类中isEmpty与isBlank的区别" class="headerlink" title="StringUtils类中isEmpty与isBlank的区别"></a>StringUtils类中isEmpty与isBlank的区别</h1><p>org.apache.commons.lang.StringUtils类提供了String的常用操作,最为常用的判空有如下两种isEmpty(String str)和isBlank(String str)。</p><p>StringUtils.isEmpty(String str) 判断某字符串是否为空，为空的标准是 str==null 或 str.length()==0</p><pre><code>System.out.println(StringUtils.isEmpty(null));        //trueSystem.out.println(StringUtils.isEmpty(&quot;&quot;));          //trueSystem.out.println(StringUtils.isEmpty(&quot;   &quot;));       //falseSystem.out.println(StringUtils.isEmpty(&quot;dd&quot;));        //falseStringUtils.isNotEmpty(String str) 等价于 !isEmpty(String str)</code></pre><p>StringUtils.isBlank(String str) 判断某字符串是否为空或长度为0或由空白符(whitespace) 构成</p><pre><code>System.out.println(StringUtils.isBlank(null));        //trueSystem.out.println(StringUtils.isBlank(&quot;&quot;));          //trueSystem.out.println(StringUtils.isBlank(&quot;   &quot;));       //trueSystem.out.println(StringUtils.isBlank(&quot;dd&quot;));        //false    </code></pre><p>StringUtils.isBlank(String str) 等价于 !isBlank(String str)</p><h1 id="集合操作-CollectionUtils"><a href="#集合操作-CollectionUtils" class="headerlink" title="集合操作 CollectionUtils"></a>集合操作 CollectionUtils</h1><p>对于查询到的集合例如：</p><pre><code>List&lt;TblJobsEntity&gt; tblJobsEntityList = tblJobsEntityMapper.selectByExample(tblJobsEntityExample);</code></pre><p>进行判断时，不能使用</p><pre><code>if(tblJobsEntityList.isEmpty())</code></pre><p>因为若查询到的tblJobsEntityList为null，则null.isEmpty()会出现空指针异常，如</p><pre><code>Exception in thread &quot;main&quot; java.lang.NullPointerException</code></pre><p>需要使用CollectionUtils.isEmpty(tblJobsEntityList)来进行判断</p><h2 id="集合判断："><a href="#集合判断：" class="headerlink" title="集合判断："></a>集合判断：</h2><h3 id="判断集合是否为空"><a href="#判断集合是否为空" class="headerlink" title="判断集合是否为空:"></a>判断集合是否为空:</h3><pre><code>CollectionUtils.isEmpty(null): trueCollectionUtils.isEmpty(new ArrayList()): trueCollectionUtils.isEmpty({a,b}): false</code></pre><h3 id="判断集合是否不为空"><a href="#判断集合是否不为空" class="headerlink" title="判断集合是否不为空:"></a>判断集合是否不为空:</h3><pre><code>CollectionUtils.isNotEmpty(null): falseCollectionUtils.isNotEmpty(new ArrayList()): falseCollectionUtils.isNotEmpty({a,b}): true</code></pre><h3 id="2个集合间的操作："><a href="#2个集合间的操作：" class="headerlink" title="2个集合间的操作："></a>2个集合间的操作：</h3><pre><code>集合a: {1,2,3,3,4,5}集合b: {3,4,4,5,6,7}CollectionUtils.union(a, b)(并集): {1,2,3,3,4,4,5,6,7}CollectionUtils.intersection(a, b)(交集): {3,4,5}CollectionUtils.disjunction(a, b)(交集的补集): {1,2,3,4,6,7}CollectionUtils.disjunction(b, a)(交集的补集): {1,2,3,4,6,7}CollectionUtils.subtract(a, b)(A与B的差): {1,2,3}CollectionUtils.subtract(b, a)(B与A的差): {4,6,7}</code></pre><h1 id="Java基本数据类型和包装类的区别"><a href="#Java基本数据类型和包装类的区别" class="headerlink" title="Java基本数据类型和包装类的区别"></a>Java基本数据类型和包装类的区别</h1><p>Java的数据类型分两种：</p><p>基本类型：byte，short，int，long，boolean，float，double，char</p><p>引用类型：所有class和interface类型</p><p>引用类型可以赋值为null，表示空，但基本类型不能赋值为null：</p><pre><code>String s = null;int n = null; // compile error!</code></pre><p>如何把一个基本类型视为对象（引用类型）？</p><h2 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h2><p>比如，想要把int基本类型变成一个引用类型，我们可以定义一个Integer类，它只包含一个实例字段int，这样，Integer类就可以视为int的包装类（Wrapper Class）：</p><pre><code>public class Integer {    private int value;    public Integer(int value) {        this.value = value;    }    public int intValue() {        return this.value;    }}</code></pre><p>定义好了Integer类，我们就可以把int和Integer互相转换：</p><pre><code>Integer n = null;Integer n2 = new Integer(99);int n3 = n2.intValue();</code></pre><p>实际上，因为包装类型非常有用，Java核心库为每种基本类型都提供了对应的包装类型：</p><pre><code>基本类型      对应的引用类型boolean       java.lang.Booleanbyte         java.lang.Byteshort         java.lang.Shortint           java.lang.Integerlong         java.lang.Longfloat         java.lang.Floatdouble       java.lang.Doublechar         java.lang.Character</code></pre><p>我们可以直接使用，并不需要自己去定义：</p><pre><code>// Integer:public class Main {    public static void main(String[] args) {        int i = 100;        // 通过new操作符创建Integer实例(不推荐使用,会有编译警告):        Integer n1 = new Integer(i);        // 通过静态方法valueOf(int)创建Integer实例:        Integer n2 = Integer.valueOf(i);        // 通过静态方法valueOf(String)创建Integer实例:        Integer n3 = Integer.valueOf(&quot;100&quot;);        System.out.println(n3.intValue());    }}</code></pre><h2 id="Auto-Boxing"><a href="#Auto-Boxing" class="headerlink" title="Auto Boxing"></a>Auto Boxing</h2><p>因为int和Integer可以互相转换：</p><pre><code>int i = 100;Integer n = Integer.valueOf(i);int x = n.intValue();</code></pre><p>所以，Java编译器可以帮助我们自动在int和Integer之间转型：</p><pre><code>Integer n = 100; // 编译器自动使用Integer.valueOf(int)int x = n; // 编译器自动使用Integer.intValue()</code></pre><p>这种直接把int变为Integer的赋值写法，称为自动装箱（Auto Boxing），反过来，把Integer变为int的赋值写法，称为自动拆箱（Auto Unboxing）。</p><p>注意：自动装箱和自动拆箱只发生在编译阶段，目的是为了少写代码。</p><p>装箱和拆箱会影响代码的执行效率，因为编译后的class代码是严格区分基本类型和引用类型的。并且，自动拆箱执行时可能会报NullPointerException：</p><pre><code>// NullPointerExceptionpublic class Main {    public static void main(String[] args) {        Integer n = null;        int i = n;    }}</code></pre><h2 id="不变类"><a href="#不变类" class="headerlink" title="不变类"></a>不变类</h2><p>所有的包装类型都是不变类。我们查看Integer的源码可知，它的核心代码如下：</p><pre><code>public final class Integer {    private final int value;}</code></pre><p>因此，一旦创建了Integer对象，该对象就是不变的。</p><p>对两个Integer实例进行比较要特别注意：绝对不能用==比较，因为Integer是引用类型，必须使用equals()比较：</p><pre><code>// == or equals?public class Main {    public static void main(String[] args) {        Integer x = 127;        Integer y = 127;        Integer m = 99999;        Integer n = 99999;        System.out.println(&quot;x == y: &quot; + (x==y)); // true        System.out.println(&quot;m == n: &quot; + (m==n)); // false        System.out.println(&quot;x.equals(y): &quot; + x.equals(y)); // true        System.out.println(&quot;m.equals(n): &quot; + m.equals(n)); // true    }}</code></pre><p>仔细观察结果的童鞋可以发现，==比较，较小的两个相同的Integer返回true，较大的两个相同的Integer返回false，这是因为Integer是不变类，编译器把Integer x = 127;自动变为Integer x = Integer.valueOf(127);</p><p>为了节省内存，Integer.valueOf()对于较小的数，始终返回相同的实例，因此，==比较“恰好”为true，但我们绝不能因为Java标准库的Integer内部有缓存优化就用==比较，必须用equals()方法比较两个Integer。</p><p>按照语义编程，而不是针对特定的底层实现去“优化”。</p><p>因为Integer.valueOf()可能始终返回同一个Integer实例，因此，在我们自己创建Integer的时候，以下两种方法：</p><pre><code>方法1：Integer n = new Integer(100);方法2：Integer n = Integer.valueOf(100);</code></pre><p>方法2更好，因为方法1总是创建新的Integer实例，方法2把内部优化留给Integer的实现者去做，即使在当前版本没有优化，也有可能在下一个版本进行优化。</p><p>我们把能创建“新”对象的静态方法称为静态工厂方法。Integer.valueOf()就是静态工厂方法，它尽可能地返回缓存的实例以节省内存。</p><p> 创建新对象时，优先选用静态工厂方法而不是new操作符。</p><p>如果我们考察Byte.valueOf()方法的源码，可以看到，标准库返回的Byte实例全部是缓存实例，但调用者并不关心静态工厂方法以何种方式创建新实例还是直接返回缓存的实例。</p><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><p>Integer类本身还提供了大量方法，例如，最常用的静态方法parseInt()可以把字符串解析成一个整数：</p><pre><code>int x1 = Integer.parseInt(&quot;100&quot;); // 100int x2 = Integer.parseInt(&quot;100&quot;, 16); // 256,因为按16进制解析</code></pre><p>Integer还可以把整数格式化为指定进制的字符串：</p><pre><code>// Integer:public class Main {    public static void main(String[] args) {        System.out.println(Integer.toString(100)); // &quot;100&quot;,表示为10进制        System.out.println(Integer.toString(100, 36)); // &quot;2s&quot;,表示为36进制        System.out.println(Integer.toHexString(100)); // &quot;64&quot;,表示为16进制        System.out.println(Integer.toOctalString(100)); // &quot;144&quot;,表示为8进制        System.out.println(Integer.toBinaryString(100)); // &quot;1100100&quot;,表示为2进制    }}</code></pre><p>注意：上述方法的输出都是String，在计算机内存中，只用二进制表示，不存在十进制或十六进制的表示方法。int n = 100在内存中总是以4字节的二进制表示：</p><pre><code>┌────────┬────────┬────────┬────────┐│00000000│00000000│00000000│01100100│└────────┴────────┴────────┴────────┘</code></pre><p>我们经常使用的System.out.println(n);是依靠核心库自动把整数格式化为10进制输出并显示在屏幕上，使用Integer.toHexString(n)则通过核心库自动把整数格式化为16进制。</p><p>这里我们注意到程序设计的一个重要原则：数据的存储和显示要分离。</p><p>Java的包装类型还定义了一些有用的静态变量</p><pre><code>// boolean只有两个值true/false，其包装类型只需要引用Boolean提供的静态字段:Boolean t = Boolean.TRUE;Boolean f = Boolean.FALSE;// int可表示的最大/最小值:int max = Integer.MAX_VALUE; // 2147483647int min = Integer.MIN_VALUE; // -2147483648// long类型占用的bit和byte数量:int sizeOfLong = Long.SIZE; // 64 (bits)int bytesOfLong = Long.BYTES; // 8 (bytes)</code></pre><p>最后，所有的整数和浮点数的包装类型都继承自Number，因此，可以非常方便地直接通过包装类型获取各种基本类型：</p><pre><code>// 向上转型为Number:Number num = new Integer(999);// 获取byte, int, long, float, double:byte b = num.byteValue();int n = num.intValue();long ln = num.longValue();float f = num.floatValue();double d = num.doubleValue();</code></pre><h2 id="处理无符号整型"><a href="#处理无符号整型" class="headerlink" title="处理无符号整型"></a>处理无符号整型</h2><p>在Java中，并没有无符号整型（Unsigned）的基本数据类型。byte、short、int和long都是带符号整型，最高位是符号位。而C语言则提供了CPU支持的全部数据类型，包括无符号整型。无符号整型和有符号整型的转换在Java中就需要借助包装类型的静态方法完成。</p><p>例如，byte是有符号整型，范围是-128~+127，但如果把byte看作无符号整型，它的范围就是0~255。我们把一个负的byte按无符号整型转换为int：</p><pre><code>// Bytepublic class Main {    public static void main(String[] args) {        byte x = -1;        byte y = 127;        System.out.println(Byte.toUnsignedInt(x)); // 255        System.out.println(Byte.toUnsignedInt(y)); // 127    }}</code></pre><p>因为byte的-1的二进制表示是11111111，以无符号整型转换后的int就是255。</p><p>类似的，可以把一个short按unsigned转换为int，把一个int按unsigned转换为long。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Java核心库提供的包装类型可以把基本类型包装为class；</p><p>自动装箱和自动拆箱都是在编译期完成的（JDK&gt;=1.5）；</p><p>装箱和拆箱会影响执行效率，且拆箱时可能发生NullPointerException；</p><p>包装类型的比较必须使用equals()；</p><p>整数和浮点数的包装类型都继承自Number；</p><p>包装类型提供了大量实用方法。</p><h2 id="思考：Java中基本数据类型和包装类型有什么区别"><a href="#思考：Java中基本数据类型和包装类型有什么区别" class="headerlink" title="思考：Java中基本数据类型和包装类型有什么区别"></a>思考：Java中基本数据类型和包装类型有什么区别</h2><p>1、包装类是对象，拥有方法和字段，对象的调用都是通过引用对象的地址，基本类型不是</p><p>2、包装类型是引用的传递，基本类型是值的传递</p><p>3、声明方式不同，基本数据类型不需要new关键字，而包装类型需要new在堆内存中进行new来分配内存空间</p><p>4、存储位置不同，基本数据类型直接将值保存在值栈中，而包装类型是把对象放在堆中，然后通过对象的引用来调用他们</p><p>5、<strong><em>初始值不同，eg： int的初始值为 0 、 boolean的初始值为false 而包装类型的初始值为null</em></strong></p><p>6、使用方式不同，基本数据类型直接赋值使用就好 ，而包装类型是在集合如 collection Map时会使用</p><p>7.当需要往ArrayList，HashMap中放东西时，像int，double这种基本类型是放不进去的，因为容器都是装object的，这是就需要这些基本类型的外覆类了，比如</p><pre><code>List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="https://blog.csdn.net/shb_derek1/article/details/9624897" target="_blank" rel="noopener">https://blog.csdn.net/shb_derek1/article/details/9624897</a></p><p>【2】<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260473794166400" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1252599548343744/1260473794166400</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java基本数据类型和包装类的区别,不同类型为空的异常判断，集合操作&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Git学习笔记II</title>
    <link href="http://yoursite.com/2019/09/05/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0II/"/>
    <id>http://yoursite.com/2019/09/05/Git学习笔记II/</id>
    <published>2019-09-05T06:51:12.000Z</published>
    <updated>2019-09-05T07:01:26.944Z</updated>
    
    <content type="html"><![CDATA[<p>Git版本回滚</p><a id="more"></a><p>在当前branch上多次commit代码并且push后，发现不符合要求，需要回滚到特定的版本。步骤如下：</p><p>1、查找commitId</p><p>首先用命令行打开git项目路径，输入git log命令查看commit记录，如下：</p><pre><code>$ git log</code></pre><p>找到commitId是9a0d02d1578ea064479296ad7efa70c5cb1a3717记录，这是执行上面命令后打印出来的信息：</p><pre><code>commit 9a0d02d1578ea064479296ad7efa70c5cb1a3717</code></pre><p>2、找到需要回滚的commit，输入git reset –hard {commitId}，将本地文件回滚：</p><pre><code>$ git reset --hard c503cffa099332911d4fce2fc1399cb4bc3ba9d6HEAD is now at c503cffa0 add a constellation test case</code></pre><p>3、此时本地文件已经回滚到刚刚commit 9a0d02d1578ea064479296ad7efa70c5cb1a3717之后的状态，但是服务器仍然没有改变，需要继续远程回滚：</p><pre><code>$ git push -f</code></pre><p>执行，最终提示一系列内容，远程回滚成功</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】 <a href="https://blog.csdn.net/weixin_38569499/article/details/83017699" target="_blank" rel="noopener">https://blog.csdn.net/weixin_38569499/article/details/83017699</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git版本回滚&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>数据库学习笔记V</title>
    <link href="http://yoursite.com/2019/09/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0V/"/>
    <id>http://yoursite.com/2019/09/05/数据库学习笔记V/</id>
    <published>2019-09-05T02:12:12.000Z</published>
    <updated>2019-12-06T03:48:14.159Z</updated>
    
    <content type="html"><![CDATA[<p>使用ALTER命令修改数据表名或者修改数据表字段</p><a id="more"></a><p>当我们需要修改数据表名或者修改数据表字段时，就需要使用到MySQL ALTER命令。</p><h1 id="创建一张表"><a href="#创建一张表" class="headerlink" title="创建一张表"></a>创建一张表</h1><p>表名为：tablename。</p><pre><code>root@host# mysql -u root -p password;Enter password:*******mysql&gt; use RUNOOB;Database changedmysql&gt; create table tablename    -&gt; (    -&gt; i INT,    -&gt; c CHAR(1)    -&gt; );Query OK, 0 rows affected (0.05 sec)mysql&gt; SHOW COLUMNS FROM tablename;+-------+---------+------+-----+---------+-------+| Field | Type    | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| i     | int(11) | YES  |     | NULL    |       || c     | char(1) | YES  |     | NULL    |       |+-------+---------+------+-----+---------+-------+2 rows in set (0.00 sec)</code></pre><h1 id="删除，添加或修改表字段"><a href="#删除，添加或修改表字段" class="headerlink" title="删除，添加或修改表字段"></a>删除，添加或修改表字段</h1><p>如下命令使用了 ALTER 命令及 DROP 子句来删除以上创建表的 i 字段：</p><pre><code>mysql&gt; ALTER TABLE tablename  DROP i;</code></pre><p>如果数据表中只剩余一个字段则无法使用DROP来删除字段。</p><p>MySQL 中使用 ADD 子句来向数据表中添加列，如下实例在表 tablename 中添加 i 字段，并定义数据类型:</p><pre><code>mysql&gt; ALTER TABLE tablename ADD i INT;</code></pre><p>执行以上命令后，i 字段会自动添加到数据表字段的末尾。</p><pre><code>mysql&gt; SHOW COLUMNS FROM tablename;+-------+---------+------+-----+---------+-------+| Field | Type    | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| c     | char(1) | YES  |     | NULL    |       || i     | int(11) | YES  |     | NULL    |       |+-------+---------+------+-----+---------+-------+2 rows in set (0.00 sec)</code></pre><p>如果你需要指定新增字段的位置，可以使用MySQL提供的关键字 FIRST (设定位第一列)， AFTER 字段名（设定位于某个字段之后）。</p><p>尝试以下 ALTER TABLE 语句, 在执行成功后，使用 SHOW COLUMNS 查看表结构的变化：</p><pre><code>ALTER TABLE tablename DROP i;ALTER TABLE tablename ADD i INT FIRST;ALTER TABLE tablename DROP i;ALTER TABLE tablename ADD i INT AFTER c;</code></pre><p>FIRST 和 AFTER 关键字可用于 ADD 与 MODIFY 子句，所以如果你想重置数据表字段的位置就需要先使用 DROP 删除字段然后使用 ADD 来添加字段并设置位置。</p><p>类似使用到的语句：</p><pre><code>ALTER TABLE tbl_jobs ADD data_send varchar(32)</code></pre><h1 id="修改字段类型及名称"><a href="#修改字段类型及名称" class="headerlink" title="修改字段类型及名称"></a>修改字段类型及名称</h1><p>如果需要修改字段类型及名称, 你可以在ALTER命令中使用 MODIFY 或 CHANGE 子句 。</p><p>例如，把字段 c 的类型从 CHAR(1) 改为 CHAR(10)，可以执行以下命令:</p><pre><code>mysql&gt; ALTER TABLE tablename MODIFY c CHAR(10);</code></pre><p>使用 CHANGE 子句, 语法有很大的不同。 在 CHANGE 关键字之后，紧跟着的是你要修改的字段名，然后指定新字段名及类型。尝试如下实例：</p><pre><code>mysql&gt; ALTER TABLE tablename CHANGE i j BIGINT;mysql&gt; ALTER TABLE tablename CHANGE j j INT;</code></pre><h1 id="ALTER-TABLE-对-Null-值和默认值的影响"><a href="#ALTER-TABLE-对-Null-值和默认值的影响" class="headerlink" title="ALTER TABLE 对 Null 值和默认值的影响"></a>ALTER TABLE 对 Null 值和默认值的影响</h1><p>当你修改字段时，你可以指定是否包含值或者是否设置默认值。</p><p>以下实例，指定字段 j 为 NOT NULL 且默认值为100 。</p><pre><code>mysql&gt; ALTER TABLE tablename    -&gt; MODIFY j BIGINT NOT NULL DEFAULT 100;</code></pre><p>如果你不设置默认值，MySQL会自动设置该字段默认为 NULL。</p><h1 id="修改字段默认值"><a href="#修改字段默认值" class="headerlink" title="修改字段默认值"></a>修改字段默认值</h1><p>你可以使用 ALTER 来修改字段的默认值，尝试以下实例：</p><pre><code>mysql&gt; ALTER TABLE tablename ALTER i SET DEFAULT 1000;mysql&gt; SHOW COLUMNS FROM tablename;+-------+---------+------+-----+---------+-------+| Field | Type    | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| c     | char(1) | YES  |     | NULL    |       || i     | int(11) | YES  |     | 1000    |       |+-------+---------+------+-----+---------+-------+2 rows in set (0.00 sec)</code></pre><p>你也可以使用 ALTER 命令及 DROP子句来删除字段的默认值，如下实例：</p><pre><code>mysql&gt; ALTER TABLE tablename ALTER i DROP DEFAULT;mysql&gt; SHOW COLUMNS FROM tablename;+-------+---------+------+-----+---------+-------+| Field | Type    | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| c     | char(1) | YES  |     | NULL    |       || i     | int(11) | YES  |     | NULL    |       |+-------+---------+------+-----+---------+-------+2 rows in set (0.00 sec)Changing a Table Type:</code></pre><h1 id="修改数据表类型"><a href="#修改数据表类型" class="headerlink" title="修改数据表类型"></a>修改数据表类型</h1><p>可以使用 ALTER 命令及 TYPE 子句来完成。尝试以下实例，我们将表 tablename 的类型修改为 MYISAM ：</p><p>注意：查看数据表类型可以使用 SHOW TABLE STATUS 语句。</p><pre><code>mysql&gt; ALTER TABLE tablename ENGINE = MYISAM;mysql&gt;  SHOW TABLE STATUS LIKE &apos;tablename&apos;\G*************************** 1. row ****************           Name: tablename           Type: MyISAM     Row_format: Fixed           Rows: 0 Avg_row_length: 0    Data_length: 0Max_data_length: 25769803775   Index_length: 1024      Data_free: 0 Auto_increment: NULL    Create_time: 2007-06-03 08:04:36    Update_time: 2007-06-03 08:04:36     Check_time: NULL Create_options:        Comment:1 row in set (0.00 sec)</code></pre><h1 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h1><p>如果需要修改数据表的名称，可以在 ALTER TABLE 语句中使用 RENAME 子句来实现。</p><p>尝试以下实例将数据表 tablename 重命名为 alter_tbl：</p><pre><code>mysql&gt; ALTER TABLE tablename RENAME TO alter_tbl;</code></pre><h1 id="修改unique-key"><a href="#修改unique-key" class="headerlink" title="修改unique-key"></a>修改unique-key</h1><p>mysql可以使用unique key来确保数据的准确性，unique key可以是一个字段，也可以是多个字段，对应已经存在的unique key如何修改呢？分两步来完成，先drop掉，然后在创建。需要注意的是drop时关键字是“index”，而创建时关键词是“unique key”，命令如下：</p><p>alter table table_name drop index <code>uk_name</code>;</p><p>alter table table_name add unique key <code>new_uk_name</code> (<code>col1</code>,<code>col2</code>);<br>注意：如果表中已经存在数据，可能会创建失败，原因是col1, col2无法满足unique。</p><p>例如auth_roles表中原有的<br>    UNIQUE KEY <code>role_unin_name</code> (<code>application_name</code>,<code>department</code>,<code>role_name</code>)</p><p>现在先drop掉</p><pre><code>ALTER TABLE auth_roles DROP index `role_unin_name`</code></pre><p>然后再创建</p><p>  ALTER TABLE auth_roles ADD UNIQUE KEY <code>role_unin_name</code> (<code>application_name</code>,<code>department</code>,<code>role_name</code>,<br>  <code>role_type</code>)<br>其它用过的：</p><p>  ALTER TABLE<br>      <code>reporting</code>.<code>auth_users</code> CHANGE <code>application_name</code> department_name VARCHAR(64)</p><h1 id="修改表的某列为同一值"><a href="#修改表的某列为同一值" class="headerlink" title="修改表的某列为同一值"></a>修改表的某列为同一值</h1><pre><code>update 表名 set 列名=想改的值</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="https://www.runoob.com/mysql/mysql-alter.html" target="_blank" rel="noopener">https://www.runoob.com/mysql/mysql-alter.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用ALTER命令修改数据表名或者修改数据表字段&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Git学习笔记I</title>
    <link href="http://yoursite.com/2019/09/04/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0I/"/>
    <id>http://yoursite.com/2019/09/04/Git学习笔记I/</id>
    <published>2019-09-04T09:08:12.000Z</published>
    <updated>2019-09-05T06:51:17.117Z</updated>
    
    <content type="html"><![CDATA[<p>Git切换新分支，git fetch与git pull的区别，及常用命令集锦</p><a id="more"></a><h1 id="查看本地已有的分支"><a href="#查看本地已有的分支" class="headerlink" title="查看本地已有的分支"></a>查看本地已有的分支</h1><pre><code>git branch</code></pre><h1 id="本地建立新分支并推送到远程仓库"><a href="#本地建立新分支并推送到远程仓库" class="headerlink" title="本地建立新分支并推送到远程仓库"></a>本地建立新分支并推送到远程仓库</h1><h2 id="创建本地分支"><a href="#创建本地分支" class="headerlink" title="创建本地分支"></a>创建本地分支</h2><p>  git checkout -b 新分支名字</p><p>执行该指令后，会在本地创建一个新分支，该分支是从当前分支上建出的，所以所有文件内容都和当前分支一模一样，这是正常的。创建成功后，将自动切换至新分支上。</p><h2 id="推送本地分支到远程仓库"><a href="#推送本地分支到远程仓库" class="headerlink" title="推送本地分支到远程仓库"></a>推送本地分支到远程仓库</h2><p>  git push –sest-upstream origin 分支名字</p><h1 id="将远程git仓库里的指定分支拉取到本地（本地不存在的分支）"><a href="#将远程git仓库里的指定分支拉取到本地（本地不存在的分支）" class="headerlink" title="将远程git仓库里的指定分支拉取到本地（本地不存在的分支）"></a>将远程git仓库里的指定分支拉取到本地（本地不存在的分支）</h1><p>首先更新远程分支列表</p><pre><code>git remote update origin --prune或者git remote update origin -p</code></pre><p>然后将指定分支拉取到本地</p><pre><code>git checkout -b 本地分支名 origin/远程分支名</code></pre><p>这个将会自动创建一个新的本地分支，并与指定的远程分支关联起来。</p><p>如果出现提示：</p><pre><code>fatal: Cannot update paths and switch to branch &apos;dev2&apos; at the same time.Did you intend to checkout &apos;origin/dev2&apos; which can not be resolved as commit?</code></pre><p>表示拉取不成功。我们需要先执行</p><pre><code>git fetch</code></pre><p>然后再执行</p><pre><code>git checkout -b 本地分支名 origin/远程分支名</code></pre><p>即可。</p><h1 id="git-fetch与git-pull的区别"><a href="#git-fetch与git-pull的区别" class="headerlink" title="git fetch与git pull的区别"></a>git fetch与git pull的区别</h1><p>FETCH_HEAD： 是一个版本链接，记录在本地的一个文件中，指向着目前已经从远程仓库取下来的分支的末端版本。</p><p>commit-id：在每次本地工作完成后，都会做一个git commit 操作来保存当前工作到本地的repo， 此时会产生一个commit-id，这是一个能唯一标识一个版本的序列号。 在使用git push后，这个序列号还会同步到远程仓库。</p><p>有了以上的概念再来说说git fetch</p><p>git fetch：这将更新git remote 中所有的远程仓库所包含分支的最新commit-id, 将其记录到.git/FETCH_HEAD文件中</p><p>git fetch更新远程仓库的方式如下：</p><pre><code>git fetch origin master:tmp//在本地新建一个temp分支，并将远程origin仓库的master分支代码下载到本地temp分支git diff tmp//来比较本地代码与刚刚从远程下载下来的代码的区别git merge tmp//合并temp分支到本地的master分支git branch -d temp//如果不想保留temp分支 可以用这步删除</code></pre><h2 id="如果直接使用git-fetch，则步骤如下："><a href="#如果直接使用git-fetch，则步骤如下：" class="headerlink" title="如果直接使用git fetch，则步骤如下："></a>如果直接使用git fetch，则步骤如下：</h2><p>创建并更新本地远程分支。即创建并更新origin/xxx 分支，拉取代码到origin/xxx分支上。</p><p>在FETCH_HEAD中设定当前分支-origin/当前分支对应，如直接到时候git merge就可以将origin/abc合并到abc分支上。</p><h2 id="git-fetch-origin"><a href="#git-fetch-origin" class="headerlink" title="git fetch origin"></a>git fetch origin</h2><p>只是手动指定了要fetch的remote。在不指定分支时通常默认为master</p><h2 id="git-fetch-origin-dev"><a href="#git-fetch-origin-dev" class="headerlink" title="git fetch origin dev"></a>git fetch origin dev</h2><p>指定远程remote和FETCH_HEAD，并且只拉取该分支的提交。</p><h2 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull :"></a>git pull :</h2><p>首先，基于本地的FETCH_HEAD记录，比对本地的FETCH_HEAD记录与远程仓库的版本号，然后git fetch 获得当前指向的远程分支的后续版本的数据，然后再利用git merge将其与本地的当前分支合并。所以可以认为git pull是git fetch和git merge两个步骤的结合。</p><p>git pull的用法如下：</p><pre><code>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;//取回远程主机某个分支的更新，再与本地的指定分支合并。</code></pre><p>因此，与git pull相比git fetch相当于是从远程获取最新版本到本地，但不会自动merge。如果需要有选择的合并git fetch是更好的选择。效果相同时git pull将更为快捷。</p><h1 id="git-命令集锦"><a href="#git-命令集锦" class="headerlink" title="git 命令集锦"></a>git 命令集锦</h1><h2 id="git-设定"><a href="#git-设定" class="headerlink" title="git 设定"></a>git 设定</h2><pre><code>git config --global user.namegit config --global user.emailgit config --global color.ui truegit config --global alias. &lt;命令名称&gt;比如：git config —global alias.st status</code></pre><h2 id="git常用"><a href="#git常用" class="headerlink" title="git常用"></a>git常用</h2><pre><code>git init其反操作：rm -rf .gitgit clonegit statusgit status -s：仅显示已修改的文档名称git status -s -b：显示分支名称git diffgit add .git add -Agit commit -m &quot;message&quot;git commit --amend &quot;message&quot; 修改上一次 commit 內容git pushgit pullgit loggit log --graph 查看分支合并图git log --pretty=onelinegit reflog 查看命令历史rm 删除本地filegit rm 删除版本库file</code></pre><h2 id="git分支操作"><a href="#git分支操作" class="headerlink" title="git分支操作"></a>git分支操作</h2><pre><code>git branchgit branch -r 显示远端分支git branch -a 显示所有分支git branch &lt;分支名称&gt; 建立分支git branch -m &lt;旧分支名称&gt; &lt;新分支名称&gt; 修改分支名字git branch -d &lt;分支名称&gt;git checkoutgit checkout -b &lt;分支名称&gt;：表示 建立並切換 至该分支git merge &lt;分支名称&gt;git reset --merge 放弃merge</code></pre><h2 id="远端操作"><a href="#远端操作" class="headerlink" title="远端操作"></a>远端操作</h2><pre><code>git remote 显示远端数据库列表git remote add &lt;名称&gt; 添加远端数据库git checkout &lt;本地分支名称&gt; origin/&lt;远端分支名称&gt;</code></pre><h2 id="取远端分支建立本地端分支"><a href="#取远端分支建立本地端分支" class="headerlink" title="取远端分支建立本地端分支"></a>取远端分支建立本地端分支</h2><pre><code>git push &lt;分支名称&gt;</code></pre><h2 id="在远端建立分支-上传-或更新-內容至远端分支"><a href="#在远端建立分支-上传-或更新-內容至远端分支" class="headerlink" title="在远端建立分支 / 上传(或更新)內容至远端分支"></a>在远端建立分支 / 上传(或更新)內容至远端分支</h2><pre><code>git fetch &lt;分支名称&gt;</code></pre><h2 id="查看远端数据库分支的修改內容"><a href="#查看远端数据库分支的修改內容" class="headerlink" title="查看远端数据库分支的修改內容"></a>查看远端数据库分支的修改內容</h2><pre><code>git pull &lt;分支名称&gt; 合并(或更新)远端至本地端分支注：pull = fetch + mergegit push :&lt;分支名称&gt; 刪除远端分支git remote set-url &lt;名称&gt; &lt;新连接位址&gt;</code></pre><h2 id="修改远端数据库地址"><a href="#修改远端数据库地址" class="headerlink" title="修改远端数据库地址"></a>修改远端数据库地址</h2><pre><code>git remote rename &lt;旧名称&gt; &lt;新名称&gt;</code></pre><h2 id="修改远端数据库名称"><a href="#修改远端数据库名称" class="headerlink" title="修改远端数据库名称"></a>修改远端数据库名称</h2><h2 id="暂存"><a href="#暂存" class="headerlink" title="暂存"></a>暂存</h2><pre><code>git stash 暂存现在的修改狀況git stash list 列出暂存清单git stash apply 取出上一次暂存git stash pop 取出上一次暂存(该暂存会被移除)git stash@{id} 指定特定暂存git stash clear 清空所有暂存</code></pre><h2 id="操作提交记录"><a href="#操作提交记录" class="headerlink" title="操作提交记录"></a>操作提交记录</h2><pre><code>git commit --amend 修改上一次的commitgit reset HEAD 放弃该修改记录 (reset)git reset --soft HEAD^ 取消上一次 commit，並 保留 修改纪录git reset --hard HEAD^ 取消上一次 commit，並 刪除 修改纪录</code></pre><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】 <a href="https://blog.csdn.net/riddle1981/article/details/74938111" target="_blank" rel="noopener">https://blog.csdn.net/riddle1981/article/details/74938111</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git切换新分支，git fetch与git pull的区别，及常用命令集锦&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>数据库学习笔记IV</title>
    <link href="http://yoursite.com/2019/09/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0IV/"/>
    <id>http://yoursite.com/2019/09/04/数据库学习笔记IV/</id>
    <published>2019-09-04T02:00:12.000Z</published>
    <updated>2019-12-10T09:05:55.303Z</updated>
    
    <content type="html"><![CDATA[<p>SQL插入，多表查询</p><a id="more"></a><h1 id="权限配置"><a href="#权限配置" class="headerlink" title="权限配置"></a>权限配置</h1><p>在reporting数据库中找到auth_users 表，代表的是用户信息，auth_roles代表的是不同的角色信息</p><p>auth_users_roles_rela代表的是不同用户所具有的角色，auth_resources代表资源，其中要添加之前写的inner和core里controller所具有的方法，type为FUNCTION，url就是执行的url，例如/notes/updateNote，level设置为1<br>auth_role_resources_rela是不同角色所具有的资源信息，<br>现在要使用SQL语句添加新的资源，将用户yang.kai</p><h1 id="页面权限配置"><a href="#页面权限配置" class="headerlink" title="页面权限配置"></a>页面权限配置</h1><p>resource_type 为MENU，level=0时为一级菜单，level=1时为二级菜单，现将<a href="http://std-report-fe.laincloud.xyz/#/reportool中的不同级别菜单的http请求url添加到reporting数据库的资源中" target="_blank" rel="noopener">http://std-report-fe.laincloud.xyz/#/reportool中的不同级别菜单的http请求url添加到reporting数据库的资源中</a></p><pre><code>INSERT INTO reporting.auth_resources(resource_name, external_id,resource_type,application_name,resource_url,status,parent_id,level,sort)VALUES(&apos;首页&apos;,-1,&apos;MENU&apos;,&apos;reporting&apos;,&apos;/&apos;,&apos;ACTIVE&apos;,0,0,0),(&apos;报表&apos;,-1,&apos;MENU&apos;,&apos;reporting&apos;,&apos;/report/home&apos;,&apos;ACTIVE&apos;,0,0,0),(&apos;night watcher&apos;,-1,&apos;MENU&apos;,&apos;reporting&apos;,&apos;/night/home&apos;,&apos;ACTIVE&apos;,0,0,0),(&apos;report tool&apos;,-1,&apos;MENU&apos;,&apos;reporting&apos;,&apos;/reportool&apos;,&apos;ACTIVE&apos;,0,0,0),(&apos;短信模板&apos;,-1,&apos;MENU&apos;,&apos;reporting&apos;,&apos;/night/template/sms&apos;,&apos;ACTIVE&apos;,0,1,0),(&apos;邮件模板&apos;,-1,&apos;MENU&apos;,&apos;reporting&apos;,&apos;/night/template/mail&apos;,&apos;ACTIVE&apos;,0,1,0),(&apos;新增模板&apos;,-1,&apos;MENU&apos;,&apos;reporting&apos;,&apos;/night/template/mail&apos;,&apos;ACTIVE&apos;,0,1,0),(&apos;定时任务列表&apos;,-1,&apos;MENU&apos;,&apos;reporting&apos;,&apos;/reportool/jobs&apos;,&apos;ACTIVE&apos;,0,1,0),(&apos;我的笔记&apos;,-1,&apos;MENU&apos;,&apos;reporting&apos;,&apos;/reportool/notes&apos;,&apos;ACTIVE&apos;,0,1,0);</code></pre><p>再次添加一些界面：</p><pre><code>INSERT INTO reporting.auth_resources(resource_name, external_id,resource_type,application_name,resource_url,status,parent_id,level,sort)VALUES(&apos;表结构查询&apos;,-1,&apos;FUNCTION&apos;,&apos;reporting&apos;,&apos;/tool/tables&apos;,&apos;ACTIVE&apos;,0,1,0)INSERT INTO reporting.auth_resources(resource_name, external_id,resource_type,application_name,resource_url,status,parent_id,level,sort)VALUES(&apos;根据当前用户获取所有报表展示树信息&apos;,-1,&apos;FUNCTION&apos;,&apos;reporting&apos;,&apos;/auth/role/getLayout&apos;,&apos;ACTIVE&apos;,0,1,0),(&apos;根据当前用户获取所有功能展示树信息&apos;,-1,&apos;FUNCTION&apos;,&apos;reporting&apos;,&apos;/auth/role/getFunctionLayout&apos;,&apos;ACTIVE&apos;,0,1,0),(&apos;分页查询角色信息&apos;,-1,&apos;FUNCTION&apos;,&apos;reporting&apos;,&apos;/auth/role/queryRolesInfo&apos;,&apos;ACTIVE&apos;,0,1,0),(&apos;分页查询所有操作员信息&apos;,-1,&apos;FUNCTION&apos;,&apos;reporting&apos;,&apos;/auth/user/queryInfo&apos;,&apos;ACTIVE&apos;,0,1,0),(&apos;更新操作员状态（冻结/解冻）&apos;,-1,&apos;FUNCTION&apos;,&apos;reporting&apos;,&apos;/auth/user/updateStatus&apos;,&apos;ACTIVE&apos;,0,1,0)</code></pre><h1 id="INSERT语句"><a href="#INSERT语句" class="headerlink" title="INSERT语句"></a>INSERT语句</h1><p>基本语法是：</p><pre><code>INSERT INTO &lt;表名&gt; (字段1, 字段2, ...) VALUES (值1, 值2, ...);</code></pre><p>例如：<br>    INSERT INTO auth_resources<br>    (resource_name, external_id,resource_type,application_name,resource_url,status,parent_id,level,sort)<br>    VALUES<br>    (‘根据ID删除笔记’,-1,’FUNCTION’,’reporting’,’/notes/deleteNote’,’ACTIVE’,0,1,0)</p><p>还可以同时添加多条数据：</p><pre><code>INSERT INTO &lt;表名&gt; (字段1, 字段2, ...)VALUES (值1, 值2, ...),(值3, 值4, ...),(值5, 值6, ...);</code></pre><p>例如在auth_role_resources_rela中添加不同角色所拥有的资源信息：<br>    INSERT INTO auth_role_resources_rela<br>    (role_id,resource_id,status,created,updated)<br>    VALUES<br>    (3,1,’ACTIVE’,NOW(),NOW()),<br>    (3,2,’ACTIVE’,NOW(),NOW())</p><p>再添加一些权限</p><pre><code>INSERT INTO auth_role_resources_rela(role_id,resource_id,status,created,updated)VALUES(3,246,&apos;ACTIVE&apos;,NOW(),NOW()),(3,247,&apos;ACTIVE&apos;,NOW(),NOW()),(3,248,&apos;ACTIVE&apos;,NOW(),NOW()),(3,249,&apos;ACTIVE&apos;,NOW(),NOW()),(3,250,&apos;ACTIVE&apos;,NOW(),NOW())</code></pre><p>例如在线上生产环境中添加角色权限<br>    INSERT INTO reporting.auth_user_roles_rela<br>    (user_id,role_id,create_user,status,created,updated)<br>    VALUES<br>    (14,1,‘yiyeli@<strong><em>.cn’,’ACTIVE’,NOW(),NOW()),<br>    (14,5,‘yiyeli@</em></strong>.cn’,’ACTIVE’,NOW(),NOW())</p><p>例如添加某个用户具有的角色信息：</p><pre><code>INSERT INTO reporting.auth_user_roles_rela(user_id,role_id,create_user,status,created,updated)VALUES(22,4,&apos;yiyeli@***.cn&apos;,&apos;ACTIVE&apos;,NOW(),NOW()),(22,5,&apos;yiyeli@***.cn&apos;,&apos;ACTIVE&apos;,NOW(),NOW())INSERT INTO reporting.auth_user_roles_rela(user_id,role_id,create_user,status,created,updated)VALUES(41,3,&apos;kaiyang38@***.cn&apos;,&apos;ACTIVE&apos;,NOW(),NOW()),(41,4,&apos;kaiyang38@***.cn&apos;,&apos;ACTIVE&apos;,NOW(),NOW())INSERT INTO reporting.auth_user_roles_rela(user_id,role_id,create_user,status,created,updated)VALUES(41,21,&apos;zhenxinlin2&apos;,&apos;ACTIVE&apos;,NOW(),NOW()),(41,23,&apos;zhenxinlin2&apos;,&apos;ACTIVE&apos;,NOW(),NOW())</code></pre><p>在角色表中添加新的角色</p><pre><code>INSERT INTO reporting.auth_roles(application_name,department,role_name,layout_id,role_type,role_level,resource_level,description,status,created,updated)VALUES(&apos;platform&apos;,&apos;商通贷&apos;,&apos;platform-FUNCTION&apos;,&apos;47&apos;,&apos;FUNCTION&apos;,1,&apos;HIGHT&apos;, &apos;角色树根节点&apos;,&apos;ACTIVE&apos;,NOW(),NOW()),(&apos;reporting&apos;,&apos;商通贷&apos;,&apos;reporting-FUNCTION&apos;,&apos;47&apos;,&apos;FUNCTION&apos;,1,&apos;HIGHT&apos;, &apos;角色树根节点&apos;,&apos;ACTIVE&apos;,NOW(),NOW())</code></pre><h1 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h1><p>auth_users表，代表的是用户信息，auth_roles代表的是不同的角色信息，</p><p>auth_users_roles_rela代表的是不同用户所具有的角色，</p><p>现在要根据用户账号查询某个用户所具有的所有角色id</p><pre><code>SELECT role_idFROM auth_usersINNER JOIN auth_user_roles_relaON auth_users.id=auth_user_roles_rela.user_idWHERE auth_users.account=&apos;kai.yang&apos;</code></pre><p>根据角色id到auth_role_resources_rela中找到该角色所拥有的资源resource_id<br>    SELECT resource_id<br>    FROM auth_role_resources_rela<br>    WHERE role_id=(<br>      SELECT role_id<br>      FROM auth_users<br>      INNER JOIN auth_user_roles_rela<br>      ON auth_users.id=auth_user_roles_rela.user_id<br>      WHERE auth_users.account=’kai.yang’<br>      )</p><p>根据角色id连接查询auth_resources中的资源名称</p><pre><code>SELECT auth_resources.id,resource_name,resource_type,resource_urlFROM auth_resourcesINNER JOIN auth_role_resources_relaON auth_resources.id=auth_role_resources_rela.resource_idWHERE auth_role_resources_rela.role_id=(  SELECT role_id  FROM auth_users  INNER JOIN auth_user_roles_rela  ON auth_users.id=auth_user_roles_rela.user_id  WHERE auth_users.account=&apos;kai.yang&apos;  )</code></pre><h2 id="注意INNER-JOIN查询的写法"><a href="#注意INNER-JOIN查询的写法" class="headerlink" title="注意INNER JOIN查询的写法"></a>注意INNER JOIN查询的写法</h2><pre><code>先确定主表，仍然使用FROM &lt;表1&gt;的语法；再确定需要连接的表，使用INNER JOIN &lt;表2&gt;的语法；然后确定连接条件，使用ON &lt;条件...&gt;，这里的条件是auth_users.id=auth_user_roles_rela.user_id，表示auth_users表的id列与auth_user_roles_rela表的user_id列相同的行需要连接；可选：加上WHERE子句、ORDER BY等子句。使用别名不是必须的，但可以更好地简化查询语句。</code></pre><h2 id="内连接和外连接的区别："><a href="#内连接和外连接的区别：" class="headerlink" title="内连接和外连接的区别："></a>内连接和外连接的区别：</h2><p>假设查询语句是：</p><pre><code>SELECT ... FROM tableA ??? JOIN tableB ON tableA.column1 = tableB.column2;</code></pre><p>我们把tableA看作左表，把tableB看成右表，那么</p><p><strong><em>INNER JOIN是选出两张表都存在的记录</em></strong></p><p><strong><em>LEFT OUTER JOIN是选出左表存在的记录</em></strong></p><p><strong><em>RIGHT OUTER JOIN是选出右表存在的记录</em></strong></p><p><strong><em>FULL OUTER JOIN则是选出左右表都存在的记录</em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SQL插入，多表查询&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>数据库学习笔记III</title>
    <link href="http://yoursite.com/2019/08/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0III/"/>
    <id>http://yoursite.com/2019/08/27/数据库学习笔记III/</id>
    <published>2019-08-27T03:52:12.000Z</published>
    <updated>2019-08-27T07:24:35.636Z</updated>
    
    <content type="html"><![CDATA[<p>重新温习SQL语句中的模糊匹配</p><a id="more"></a><h1 id="模糊匹配"><a href="#模糊匹配" class="headerlink" title="模糊匹配"></a>模糊匹配</h1><p>在进行数据库查询的时候，有完整查询和模糊查询之分。<br>一般模糊查询语句如下：</p><p>  SELECT 字段 FROM 表 WHERE 某字段 Like 条件<br>其中的条件，SQL有四种匹配模式：</p><h2 id=""><a href="#" class="headerlink" title="%"></a>%</h2><p>表示任意0个或多个字符，可匹配任意类型和长度的字符，有些情况下若是中文，请使用两个百分号（%%）表示。</p><p>例如</p><pre><code>SELECT * FROM user WHERE name LIKE &apos;%一%&apos;</code></pre><p>将会把name为“一野”，”李一野”，“一休和尚”等等有”一”的记录都找出来。</p><p>另外如果需要找出name中既有“一”又有”野”的记录，请使用and条件</p><pre><code>SELECT *   FROM user  WHERE name  LIKE &apos;%一%&apos;  AND  name LIKE &apos;%野%&apos;</code></pre><p>而如果使用</p><pre><code>SELECT *  FROM user  WHERE name  LIKE &apos;%一%野%&apos;</code></pre><p>虽然能够搜索出“李一野”，但不能搜索出符合条件的”野一李”。</p><h2 id="-1"><a href="#-1" class="headerlink" title="_"></a>_</h2><p>表示任意单个字符，匹配单个任意字符，它常用来限制表达式的字符长度语句：</p><p>比如</p><pre><code>SELECT *  FROM user  WHERE name  LIKE &apos;_三_&apos;</code></pre><p>只能找出“唐三藏”这样name为三个字且中间一个字是”三”的；</p><p>例如</p><pre><code>SELECT *  FROM user  WHERE name  LIKE &apos;三__&apos;</code></pre><p>只能找出“三国杀”这样name为三个字且第一字为”三”的；</p><h2 id="-2"><a href="#-2" class="headerlink" title="[]"></a>[]</h2><p>表示括号内所列字符中的一个（类似正则表达式）。制定一个字符、字符串或范围，要求所匹配对象为它们中的人一个。</p><p>比如</p><pre><code>SELECT *  FROM user  WHERE name  LIKE &apos;[张王李]三&apos;</code></pre><p>搜索出的是“张三”，“王三”，”李三”，而不是“张王李三”；</p><p>如果[]内有一系列字符（01234，abcd之类)，则可以简写为“0-4”、“a-d”</p><pre><code>SELECT *  FROM user  WHERE name  LIKE &apos;大[a-d]&apos;</code></pre><p>将搜索出“大a”、……、“大d”；</p><h2 id="-3"><a href="#-3" class="headerlink" title="[^]"></a>[^]</h2><p>表示不在括号所列之内的单个字符。其取值和[]相同，但它要求所匹配对象为指定字符以外的任一个字符。</p><p>比如</p><pre><code>SELECT *  FROM user  WHERE name  LIKE &apos;[^张王李]三&apos;</code></pre><p>将找出不姓“张”，“王”，”李”的“赵三”，”孙三”等。</p><pre><code>SELECT *  FROM user  WHERE name  LIKE &apos;大[^a-d]&apos;</code></pre><p>将排除“大a”到“大d”，搜索“大e”、”大f”、……</p><h2 id="查询内容包含通配符时"><a href="#查询内容包含通配符时" class="headerlink" title="查询内容包含通配符时"></a>查询内容包含通配符时</h2><p>由于通配符会使得我们查询特殊字符“%”、”_”、“[”的语句无法正常实现，而把特殊字符用“[]”括起来便可以正常查询。</p><h2 id="多条件模糊查询"><a href="#多条件模糊查询" class="headerlink" title="多条件模糊查询"></a>多条件模糊查询</h2><p>看上去我们可以使用AND连接进行多条件模糊查询</p><pre><code>SELECT * FROM user WHERE name LIKE &apos;%三%&apos; AND phone LIKE ‘%1234%’</code></pre><p>但在实际使用时会发现如果数据库的查询字段不是都有值的情况下无法搜索到，</p><p>例如某记录name为“三国杀” ，phone没有值也不是null，因为电话没有值素以经过and运算后结果为false，没有输出。显然数据库中的对应字段必须有值，否则会漏掉正确的输出结果。</p><p>正确的输入应该为name为“三国杀”，phone为null，这样经过and运算后结果为true，可以输出正确结果</p><p>如何解决数据库中查询字段没有值时的多条件模糊匹配在网上搜了一些解决方法但暂未找到比较易懂但方法，留待后面解决</p><h2 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h2><p>sql语句</p><pre><code>sql=“select * from user where name like ...”</code></pre><p>必须在一行内输入完，而不能用回车符分段，因为vbs多行被认为是多个语句，这是许多初写者常犯的错误。如果你想分多段写，可以用上面的方法在现有变量基础上逐步增加查询语句的各个组成部分并把它存在同一变量内实现。在封闭引号之前或者在打开引号之后你需要增加空格，这样才能保证字符串连接起来的时候没有把几个词凑到了一块。</p><p>最后注意以上查询的LIKE后要加单引号。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="https://www.cnblogs.com/GT_Andy/archive/2009/12/25/1921914.html" target="_blank" rel="noopener">https://www.cnblogs.com/GT_Andy/archive/2009/12/25/1921914.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重新温习SQL语句中的模糊匹配&lt;/p&gt;
    
    </summary>
    
      <category term="2019年8月" scheme="http://yoursite.com/categories/2019%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记IV</title>
    <link href="http://yoursite.com/2019/08/12/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0IV/"/>
    <id>http://yoursite.com/2019/08/12/Java学习笔记IV/</id>
    <published>2019-08-12T06:48:12.000Z</published>
    <updated>2019-08-13T06:12:56.686Z</updated>
    
    <content type="html"><![CDATA[<p>MapReduce思想学习,对Java8中对新特性stream，map和reduce进行学习，Stream API部分主要来自于IBM Developer官网，原文写的非常详尽清晰。</p><a id="more"></a><h1 id="MapReduce思想及Java中的实现"><a href="#MapReduce思想及Java中的实现" class="headerlink" title="MapReduce思想及Java中的实现"></a>MapReduce思想及Java中的实现</h1><p>MapReduce源于Google一篇论文，它充分借鉴了分而治之的思想，将一个数据处理过程拆分为主要的Map(映射)与Reduce(化简)两步。用户不懂分布式计算框架的内部运行机制，只要能用Map和Reduce的思想描述清楚要处理的问题，即编写map()和reduce( )函数，就能轻松地使问题的计算实现分布式，并在Hadoop上运行。MapReduce的编程具有以下特点。</p><h2 id="开发简单"><a href="#开发简单" class="headerlink" title="开发简单:"></a>开发简单:</h2><p>得益于MapReduce的编程模型，用户可以不用考虑进程间通信、套接字编程，无需非常高深的技巧，只需要实现一些非常简单的逻辑，其他的交由MapReduce计算框架去完成，大大简化了分布式程序的编写难度。</p><h2 id="可扩展性强"><a href="#可扩展性强" class="headerlink" title="可扩展性强:"></a>可扩展性强:</h2><p>同HDFS一样，当集群资源不能满足计算需求时，可以通过增加节点的方式达到线性扩展集群的目的。</p><h2 id="容错性强"><a href="#容错性强" class="headerlink" title="容错性强:"></a>容错性强:</h2><p>对于节点故障导致的作业失败，MapReduce计算框架会自动将作业安排到健康节点重新执行，直到任务完成，而这些，对于用户来说都是透明的。</p><h2 id="MapReduce的编程思想"><a href="#MapReduce的编程思想" class="headerlink" title="MapReduce的编程思想"></a>MapReduce的编程思想</h2><p>Map(映射)与Reduce(化简)来源于LISP和其他函数式编程语言中的古老的映射和化简操作，MapReduce操作数据的最小单位是一个键值对。用户在使用MapReduce编程模型的时候，第一步就需要将数据抽象为键值对的形式，接着<strong><em>map函数</em></strong> 会以键值对作为输入，经过map函数的处理，产生一系类新的键值对作为中间结果输出到本地。MapReduce计算框架会自动将这些中间结果数据按照键做聚合处理，并将键相同的数据分发给reduce函数处理(用户可以设置分发规则)。<strong><em>reduce函数</em></strong> 以键和对应的值的集合作为输入，经过reduce函数的处理后，产生了另外一系列键值对作为最终输出。</p><p>如果用表达式表示，其过程如下式所示 :</p><pre><code>{Keyl，Value1}~{Key2, List&lt;Value2&gt;}~{Key3, Value3}</code></pre><p>读者可能觉得上面的描述和表达式非常抽象，那么让我们先来看一个例子。有一篮苹果，一些是红苹果，一些是青苹果，每个苹果有一个唯一编号，要解决的问题是统计该篮苹果的数目、红苹果(深色)的个数和青苹果(浅色)的个数。</p><p><img src="assets/markdown-img-paste-20190806142009358.png" alt="https://img-blog.csdn.net/20170502224501777?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDgwMTQzOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p><p>  假设有A, B, C三个人，A获得第一排苹果，B获得第二排苹果，这时，A和B分别统计自己手上的苹果的个数，然后将结果告知C, C将A, B的结果做一次汇总，得到最后结果。对于这个过程，其实用到了MapReduce的思想。我们可以从下一幅图看出端倪。</p><p><img src="assets/markdown-img-paste-20190806142045676.png" alt="https://img-blog.csdn.net/20170502224831447?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDgwMTQzOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p><p>A的map函数的输入的格式为键值对appleId-count，比女fl “ 11-1”表示appleId为11的苹果个数为1，经过map函数的累和，即将所有appleId的count相加，输出为新的键值对AppleCount-6，此时B也进行同样的操作，由于A和B的map函数输出的键值对的键相同，都为“AppleCount”，所以MapReduce框架会将其都分发到C作为reduce函数的输入，并在reduce函数中完成对键相同的值的累和，并输出最后结果AppleCount-12。如果用表达式表示，即为:</p><pre><code>(appleId, count}一&gt;(AppleCount，List&lt;count&gt;}一&gt;{AppleCount，count}</code></pre><p>在这个例子中，就是用MapReduce的思想来完成苹果计数的问题，细心的读者可能发现，这个例子中reduce函数只执行了一次，是否可以执行多次呢，答案是肯定的，下面来看用MapReduce思想解决对红苹果和青苹果分别计数的问题。</p><p>假设有A, B. C, D四个人，A获得第一排苹果，B获得第二排苹果，A将手上的红苹果给C、青苹果给D、B将手上的红苹果给C、青苹果给D。C, D再统计各自手上的结果，得到最后结果，如下图所示。</p><p><img src="assets/markdown-img-paste-20190806142148349.png" alt="https://img-blog.csdn.net/20170502225302823?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDgwMTQzOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p><p>A的map函数的输入同上次一样，在map函数中，用color和appleId作为新的键值对重新输出，B也做同样的操作。而A, B的map函数的输出的键值对会因为不同的键被分别分发到C和D执行:reduce函数，而真正的计数是由reduce函数完成，并输出最后结果。这里:reduce函数一共执行了两次，第一次是处理键为Red的数据.第二次是处理键为Green的数据。如果用表达式表示，即为:</p><pre><code>{appleId, count}~{color, List&lt;appleId&gt;}~{color, count}</code></pre><p>要理解MapReduce的编程思想，其核心的一点就是将数据用键值对表示。在现实生活中，很多数据要么本身就为键值对的形式，要么可以用键值对这种方式来表示，例如电话号码和通话记录，文件名和文件存储的数据等，键值对并不是高端数据挖掘独有的数据模型，而是存在于我们身边非常普通的模型。</p><p>利用分而治之的思想，可以将很多复杂的数据分析问题转变为一系列MapReduce作业，利用Hadoop的提供MapReduce计算框架，实现分布式计算，这样就能对海量数据进行复杂的数据分析，这也是MapReduce的意义所在。</p><h1 id="Java8-中的Stream"><a href="#Java8-中的Stream" class="headerlink" title="Java8 中的Stream"></a>Java8 中的Stream</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。所以说，Java 8 中首次出现的 java.util.stream 是一个函数式语言+多核时代综合影响的产物。</p><h2 id="什么是聚合操作"><a href="#什么是聚合操作" class="headerlink" title="什么是聚合操作"></a>什么是聚合操作</h2><p>在传统的 J2EE 应用中，Java 代码经常不得不依赖于关系型数据库的聚合操作来完成诸如：</p><p>客户每月平均消费金额</p><p>最昂贵的在售商品</p><p>本周完成的有效订单（排除了无效的）</p><p>取十个数据样本作为首页推荐</p><p>这类的操作。</p><p>但在当今这个数据大爆炸的时代，在数据来源多样化、数据海量化的今天，很多时候不得不脱离 RDBMS，或者以底层返回的数据为基础进行更上层的数据统计。而 Java 的集合 API 中，仅仅有极少量的辅助型方法，更多的时候是程序员需要用 Iterator 来遍历集合，完成相关的聚合应用逻辑。这是一种远不够高效、笨拙的方法。在 Java 7 中，如果要发现 type 为 grocery 的所有交易，然后返回以交易值降序排序好的交易 ID 集合，我们需要这样写：</p><h3 id="Java-7-的排序、取值实现"><a href="#Java-7-的排序、取值实现" class="headerlink" title="Java 7 的排序、取值实现"></a>Java 7 的排序、取值实现</h3><pre><code>List&lt;Transaction&gt; groceryTransactions = new Arraylist&lt;&gt;();for(Transaction t: transactions){ if(t.getType() == Transaction.GROCERY){ groceryTransactions.add(t); }}Collections.sort(groceryTransactions, new Comparator(){ public int compare(Transaction t1, Transaction t2){ return t2.getValue().compareTo(t1.getValue()); }});List&lt;Integer&gt; transactionIds = new ArrayList&lt;&gt;();for(Transaction t: groceryTransactions){ transactionsIds.add(t.getId());}</code></pre><p>而在 Java 8 使用 Stream，代码更加简洁易读；而且使用并发模式，程序执行速度更快。</p><h3 id="Java-8-的排序、取值实现"><a href="#Java-8-的排序、取值实现" class="headerlink" title="Java 8 的排序、取值实现"></a>Java 8 的排序、取值实现</h3><pre><code>List&lt;Integer&gt; transactionsIds = transactions.parallelStream(). filter(t -&gt; t.getType() == Transaction.GROCERY). sorted(comparing(Transaction::getValue).reversed()). map(Transaction::getId). collect(toList());</code></pre><h2 id="Stream总览"><a href="#Stream总览" class="headerlink" title="Stream总览"></a>Stream总览</h2><h3 id="什么是流"><a href="#什么是流" class="headerlink" title="什么是流"></a>什么是流</h3><p>Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。</p><p>Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。</p><p>而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。</p><p>而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。</p><p>Stream 的并行操作依赖于 Java7 中引入的 Fork/Join 框架（JSR166y）来拆分任务和加速处理过程。Java 的并行 API 演变历程基本如下：</p><p>1.0-1.4 中的 java.lang.Thread</p><p>5.0 中的 java.util.concurrent</p><p>6.0 中的 Phasers 等</p><p>7.0 中的 Fork/Join 框架</p><p>8.0 中的 Lambda</p><p>Stream 的另外一大特点是，数据源本身可以是无限的。</p><h3 id="流的构成"><a href="#流的构成" class="headerlink" title="流的构成"></a>流的构成</h3><p>当我们使用一个流的时候，通常包括三个基本步骤：</p><p>获取一个数据源（source）→ 数据转换→执行操作获取想要的结果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道，如下图所示。</p><p><img src="assets/markdown-img-paste-20190806173551210.png" alt="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/img001.png"></p><p>图1:流管道 (Stream Pipeline) 的构成</p><p>有多种方式生成 Stream Source：</p><h4 id="从-Collection-和数组"><a href="#从-Collection-和数组" class="headerlink" title="从 Collection 和数组"></a>从 Collection 和数组</h4><p>Collection.stream()</p><p>Collection.parallelStream()</p><p>Arrays.stream(T array) or Stream.of()</p><h4 id="从-BufferedReader"><a href="#从-BufferedReader" class="headerlink" title="从 BufferedReader"></a>从 BufferedReader</h4><p>java.io.BufferedReader.lines()</p><h4 id="静态工厂"><a href="#静态工厂" class="headerlink" title="静态工厂"></a>静态工厂</h4><p>java.util.stream.IntStream.range()<br>java.nio.file.Files.walk()</p><h4 id="自己构建"><a href="#自己构建" class="headerlink" title="自己构建"></a>自己构建</h4><p>java.util.Spliterator</p><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>Random.ints()</p><p>BitSet.stream()</p><p>Pattern.splitAsStream(java.lang.CharSequence)</p><p>JarFile.stream()</p><h3 id="流的操作类型分为两种："><a href="#流的操作类型分为两种：" class="headerlink" title="流的操作类型分为两种："></a>流的操作类型分为两种：</h3><h4 id="Intermediate："><a href="#Intermediate：" class="headerlink" title="Intermediate："></a>Intermediate：</h4><p>一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。</p><h4 id="Terminal："><a href="#Terminal：" class="headerlink" title="Terminal："></a>Terminal：</h4><p>一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。</p><p>在对于一个 Stream 进行多次转换操作 (Intermediate 操作)，每次都对 Stream 的每个元素进行转换，而且是执行多次，这样时间复杂度就是 N（转换次数）个 for 循环里把所有操作都做掉的总和吗？其实不是这样的，转换操作都是 lazy 的，多个转换操作只会在 Terminal 操作的时候融合起来，一次循环完成。</p><p>我们可以这样简单的理解，Stream 里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在 Terminal 操作的时候循环 Stream 对应的集合，然后对每个元素执行所有的函数。</p><p>还有一种操作被称为 <strong><em>short-circuiting</em></strong>。用以指：</p><p>对于一个 intermediate 操作，如果它接受的是一个无限大（infinite/unbounded）的 Stream，但返回一个有限的新 Stream。</p><p>对于一个 terminal 操作，如果它接受的是一个无限大的 Stream，但能在有限的时间计算出结果。</p><p>当操作一个无限大的 Stream，而又希望在有限时间内完成操作，则在管道内拥有一个 short-circuiting 操作是必要非充分条件。</p><h3 id="一个流操作的示例"><a href="#一个流操作的示例" class="headerlink" title="一个流操作的示例"></a>一个流操作的示例</h3><pre><code>int sum = widgets.stream().filter(w -&gt; w.getColor() == RED) .mapToInt(w -&gt; w.getWeight()) .sum();</code></pre><p>stream() 获取当前小物件的 source，filter 和 mapToInt 为 intermediate 操作，进行数据筛选和转换，最后一个 sum() 为 terminal 操作，对符合条件的全部小物件作重量求和。</p><h2 id="流的使用详解"><a href="#流的使用详解" class="headerlink" title="流的使用详解"></a>流的使用详解</h2><p>简单说，对 Stream 的使用就是实现一个 filter-map-reduce 过程，产生一个最终结果，或者导致一个副作用（side effect）。</p><p>流的构造与转换</p><p>下面提供最常见的几种构造 Stream 的样例。</p><h3 id="构造流的几种常见方法"><a href="#构造流的几种常见方法" class="headerlink" title="构造流的几种常见方法"></a>构造流的几种常见方法</h3><pre><code>// 1. Individual valuesStream stream = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);// 2. ArraysString [] strArray = new String[] {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;};stream = Stream.of(strArray);stream = Arrays.stream(strArray);// 3. CollectionsList&lt;String&gt; list = Arrays.asList(strArray);stream = list.stream();</code></pre><p>需要注意的是，对于基本数值型，目前有三种对应的包装类型 Stream：</p><p>IntStream、LongStream、DoubleStream。</p><p>当然我们也可以用 Stream<integer>、Stream<long> &gt;、Stream<double>，但是 boxing 和 unboxing 会很耗时，所以特别为这三种基本数值型提供了对应的 Stream。</double></long></integer></p><p>Java 8 中还没有提供其它数值型 Stream，因为这将导致扩增的内容较多。而常规的数值型聚合运算可以通过上面三种 Stream 进行。</p><h3 id="数值流的构造"><a href="#数值流的构造" class="headerlink" title="数值流的构造"></a>数值流的构造</h3><pre><code>IntStream.of(new int[]{1, 2, 3}).forEach(System.out::println);IntStream.range(1, 3).forEach(System.out::println);IntStream.rangeClosed(1, 3).forEach(System.out::println);</code></pre><h3 id="流转换为其它数据结构"><a href="#流转换为其它数据结构" class="headerlink" title="流转换为其它数据结构"></a>流转换为其它数据结构</h3><pre><code>// 1. ArrayString[] strArray1 = stream.toArray(String[]::new);// 2. CollectionList&lt;String&gt; list1 = stream.collect(Collectors.toList());List&lt;String&gt; list2 = stream.collect(Collectors.toCollection(ArrayList::new));Set set1 = stream.collect(Collectors.toSet());Stack stack1 = stream.collect(Collectors.toCollection(Stack::new));// 3. StringString str = stream.collect(Collectors.joining()).toString();</code></pre><p>一个 Stream 只可以使用一次，上面的代码为了简洁而重复使用了数次。</p><h2 id="流的操作"><a href="#流的操作" class="headerlink" title="流的操作"></a>流的操作</h2><p>接下来，当把一个数据结构包装成 Stream 后，就要开始对里面的元素进行各类操作了。常见的操作可以归类如下。</p><h3 id="Intermediate：-1"><a href="#Intermediate：-1" class="headerlink" title="Intermediate："></a>Intermediate：</h3><p>map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered</p><h3 id="Terminal：-1"><a href="#Terminal：-1" class="headerlink" title="Terminal："></a>Terminal：</h3><p>forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator</p><h3 id="Short-circuiting："><a href="#Short-circuiting：" class="headerlink" title="Short-circuiting："></a>Short-circuiting：</h3><p>anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit</p><p>我们下面看一下 Stream 的比较典型用法。</p><h2 id="map-flatMap"><a href="#map-flatMap" class="headerlink" title="map/flatMap"></a>map/flatMap</h2><p>我们先来看 map。如果你熟悉 scala 这类函数式语言，对这个方法应该很了解，它的作用就是把 input Stream 的每一个元素，映射成 output Stream 的另外一个元素。</p><h3 id="转换大写"><a href="#转换大写" class="headerlink" title="转换大写"></a>转换大写</h3><pre><code>List&lt;String&gt; output = wordList.stream().map(String::toUpperCase).collect(Collectors.toList());</code></pre><p>这段代码把所有的单词转换为大写。</p><h3 id="平方数"><a href="#平方数" class="headerlink" title="平方数"></a>平方数</h3><pre><code>List&lt;Integer&gt; nums = Arrays.asList(1, 2, 3, 4);List&lt;Integer&gt; squareNums = nums.stream().map(n -&gt; n * n).collect(Collectors.toList());</code></pre><p>  这段代码生成一个整数 list 的平方数 {1, 4, 9, 16}。</p><p>  从上面例子可以看出，map 生成的是个 1:1 映射，每个输入元素，都按照规则转换成为另外一个元素。还有一些场景，是一对多映射关系的，这时需要 flatMap。</p><h3 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h3><pre><code>Stream&lt;List&lt;Integer&gt;&gt; inputStream = Stream.of( Arrays.asList(1), Arrays.asList(2, 3), Arrays.asList(4, 5, 6) );Stream&lt;Integer&gt; outputStream = inputStream.flatMap((childList) -&gt; childList.stream());</code></pre><p>flatMap 把 input Stream 中的层级结构扁平化，就是将最底层元素抽出来放到一起，最终 output 的新 Stream 里面已经没有 List 了，都是直接的数字。</p><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>filter 对原始 Stream 进行某项测试，通过测试的元素被留下来生成一个新 Stream。</p><h3 id="留下偶数"><a href="#留下偶数" class="headerlink" title="留下偶数"></a>留下偶数</h3><pre><code>Integer[] sixNums = {1, 2, 3, 4, 5, 6};Integer[] evens =Stream.of(sixNums).filter(n -&gt; n%2 == 0).toArray(Integer[]::new);</code></pre><p>经过条件“被 2 整除”的 filter，剩下的数字为 {2, 4, 6}。</p><h3 id="把单词挑出来"><a href="#把单词挑出来" class="headerlink" title="把单词挑出来"></a>把单词挑出来</h3><pre><code>List&lt;String&gt; output = reader.lines(). flatMap(line -&gt; Stream.of(line.split(REGEXP))). filter(word -&gt; word.length() &gt; 0). collect(Collectors.toList());</code></pre><p>这段代码首先把每行的单词用 flatMap 整理到新的 Stream，然后保留长度不为 0 的，就是整篇文章中的全部单词了。</p><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><p>forEach 方法接收一个 Lambda 表达式，然后在 Stream 的每一个元素上执行该表达式。</p><h3 id="打印姓名（forEach-和-pre-java8-的对比）"><a href="#打印姓名（forEach-和-pre-java8-的对比）" class="headerlink" title="打印姓名（forEach 和 pre-java8 的对比）"></a>打印姓名（forEach 和 pre-java8 的对比）</h3><pre><code>// Java 8roster.stream() .filter(p -&gt; p.getGender() == Person.Sex.MALE) .forEach(p -&gt; System.out.println(p.getName()));// Pre-Java 8for (Person p : roster) { if (p.getGender() == Person.Sex.MALE) { System.out.println(p.getName()); }}</code></pre><p>对一个人员集合遍历，找出男性并打印姓名。可以看出来，forEach 是为 Lambda 而设计的，保持了最紧凑的风格。而且 Lambda 表达式本身是可以重用的，非常方便。当需要为多核系统优化时，可以 parallelStream().forEach()，只是此时原有元素的次序没法保证，并行的情况下将改变串行时操作的行为，此时 forEach 本身的实现不需要调整，而 Java8 以前的 for 循环 code 可能需要加入额外的多线程逻辑。</p><p>但一般认为，forEach 和常规 for 循环的差异不涉及到性能，它们仅仅是函数式风格与传统 Java 风格的差别。</p><p>另外一点需要注意，forEach 是 terminal 操作，因此它执行后，Stream 的元素就被“消费”掉了，你无法对一个 Stream 进行两次 terminal 运算。下面的代码是错误的：</p><pre><code>stream.forEach(element -&gt; doOneThing(element));stream.forEach(element -&gt; doAnotherThing(element));</code></pre><p>相反，具有相似功能的 intermediate 操作 peek 可以达到上述目的。如下是出现在该 api javadoc 上的一个示例。</p><h3 id="peek-对每个元素执行操作并返回一个新的-Stream"><a href="#peek-对每个元素执行操作并返回一个新的-Stream" class="headerlink" title="peek 对每个元素执行操作并返回一个新的 Stream"></a>peek 对每个元素执行操作并返回一个新的 Stream</h3><pre><code>Stream.of(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;) .filter(e -&gt; e.length() &gt; 3) .peek(e -&gt; System.out.println(&quot;Filtered value: &quot; + e)) .map(String::toUpperCase) .peek(e -&gt; System.out.println(&quot;Mapped value: &quot; + e)) .collect(Collectors.toList());</code></pre><p>forEach 不能修改自己包含的本地变量值，也不能用 break/return 之类的关键字提前结束循环。</p><h2 id="findFirst"><a href="#findFirst" class="headerlink" title="findFirst"></a>findFirst</h2><p>这是一个 termimal 兼 short-circuiting 操作，它总是返回 Stream 的第一个元素，或者空。<br>这里比较重点的是它的返回值类型：Optional。这也是一个模仿 Scala 语言中的概念，作为一个容器，它可能含有某值，或者不包含。使用它的目的是尽可能避免 NullPointerException。</p><h3 id="Optional-的两个用例"><a href="#Optional-的两个用例" class="headerlink" title="Optional 的两个用例"></a>Optional 的两个用例</h3><pre><code>String strA = &quot; abcd &quot;, strB = null;print(strA);print(&quot;&quot;);print(strB);getLength(strA);getLength(&quot;&quot;);getLength(strB);public static void print(String text) { // Java 8 Optional.ofNullable(text).ifPresent(System.out::println); // Pre-Java 8 if (text != null) {   System.out.println(text);  } }public static int getLength(String text) { // Java 8return Optional.ofNullable(text).map(String::length).orElse(-1); // Pre-Java 8// return if (text != null) ? text.length() : -1; };</code></pre><p>在更复杂的 if (xx != null) 的情况中，使用 Optional 代码的可读性更好，而且它提供的是编译时检查，能极大的降低 NPE 这种 Runtime Exception 对程序的影响，或者迫使程序员更早的在编码阶段处理空值问题，而不是留到运行时再发现和调试。</p><p>Stream 中的 findAny、max/min、reduce 等方法等返回 Optional 值。还有例如 IntStream.average() 返回 OptionalDouble 等等。</p><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><p>这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。例如 Stream 的 sum 就相当于</p><pre><code>Integer sum = integers.reduce(0, (a, b) -&gt; a+b);</code></pre><p>或</p><pre><code>Integer sum = integers.reduce(0, Integer::sum);</code></pre><p>也有没有起始值的情况，这时会把 Stream 的前面两个元素组合起来，返回的是 Optional。</p><h3 id="reduce-的用例"><a href="#reduce-的用例" class="headerlink" title="reduce 的用例"></a>reduce 的用例</h3><pre><code>// 字符串连接，concat = &quot;ABCD&quot;String concat = Stream.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;).reduce(&quot;&quot;, String::concat);// 求最小值，minValue = -3.0double minValue = Stream.of(-1.5, 1.0, -3.0, -2.0).reduce(Double.MAX_VALUE, Double::min);// 求和，sumValue = 10, 有起始值int sumValue = Stream.of(1, 2, 3, 4).reduce(0, Integer::sum);// 求和，sumValue = 10, 无起始值sumValue = Stream.of(1, 2, 3, 4).reduce(Integer::sum).get();// 过滤，字符串连接，concat = &quot;ace&quot;concat = Stream.of(&quot;a&quot;, &quot;B&quot;, &quot;c&quot;, &quot;D&quot;, &quot;e&quot;, &quot;F&quot;). filter(x -&gt; x.compareTo(&quot;Z&quot;) &gt; 0). reduce(&quot;&quot;, String::concat);</code></pre><p>上面代码例如第一个示例的 reduce()，第一个参数（空白字符）即为起始值，第二个参数（String::concat）为 BinaryOperator。这类有起始值的 reduce() 都返回具体的对象。而对于第四个示例没有起始值的 reduce()，由于可能没有足够的元素，返回的是 Optional，请留意这个区别。</p><h2 id="limit-skip"><a href="#limit-skip" class="headerlink" title="limit/skip"></a>limit/skip</h2><p>limit 返回 Stream 的前面 n 个元素；skip 则是扔掉前 n 个元素（它是由一个叫 subStream 的方法改名而来）。</p><h3 id="limit-和-skip-对运行次数的影响"><a href="#limit-和-skip-对运行次数的影响" class="headerlink" title="limit 和 skip 对运行次数的影响"></a>limit 和 skip 对运行次数的影响</h3><pre><code>public void testLimitAndSkip() { List&lt;Person&gt; persons = new ArrayList(); for (int i = 1; i &lt;= 10000; i++) { Person person = new Person(i, &quot;name&quot; + i); persons.add(person); }List&lt;String&gt; personList2 = persons.stream().map(Person::getName).limit(10).skip(3).collect(Collectors.toList()); System.out.println(personList2);}private class Person { public int no; private String name; public Person (int no, String name) { this.no = no; this.name = name; } public String getName() { System.out.println(name); return name; }}</code></pre><p>输出结果为：</p><pre><code>name1name2name3name4name5name6name7name8name9name10[name4, name5, name6, name7, name8, name9, name10]</code></pre><p>这是一个有 10，000 个元素的 Stream，但在 short-circuiting 操作 limit 和 skip 的作用下，管道中 map 操作指定的 getName() 方法的执行次数为 limit 所限定的 10 次，而最终返回结果在跳过前 3 个元素后只有后面 7 个返回。</p><p>有一种情况是 limit/skip 无法达到 short-circuiting 目的的，就是把它们放在 Stream 的排序操作后，原因跟 sorted 这个 intermediate 操作有关：此时系统并不知道 Stream 排序后的次序如何，所以 sorted 中的操作看上去就像完全没有被 limit 或者 skip 一样。</p><h3 id="limit-和-skip-对-sorted-后的运行次数无影响"><a href="#limit-和-skip-对-sorted-后的运行次数无影响" class="headerlink" title="limit 和 skip 对 sorted 后的运行次数无影响"></a>limit 和 skip 对 sorted 后的运行次数无影响</h3><pre><code>List&lt;Person&gt; persons = new ArrayList(); for (int i = 1; i &lt;= 5; i++) { Person person = new Person(i, &quot;name&quot; + i); persons.add(person); }List&lt;Person&gt; personList2 = persons.stream().sorted((p1, p2) -&gt;p1.getName().compareTo(p2.getName())).limit(2).collect(Collectors.toList());System.out.println(personList2);</code></pre><p>上面的示例对“peek 对每个元素执行操作并返回一个新的 Stream”做了微调，首先对 5 个元素的 Stream 排序，然后进行 limit 操作。输出结果为：</p><pre><code>name2name1name3name2name4name3name5name4[stream.StreamDW$Person@816f27d, stream.StreamDW$Person@87aac27]</code></pre><p>即虽然最后的返回元素数量是 2，但整个管道中的 sorted 表达式执行次数没有像前面例子相应减少。</p><p>最后有一点需要注意的是，对一个 parallel 的 Steam 管道来说，如果其元素是有序的，那么 limit 操作的成本会比较大，因为它的返回对象必须是前 n 个也有一样次序的元素。取而代之的策略是取消元素间的次序，或者不要用 parallel Stream。</p><h2 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h2><p>对 Stream 的排序通过 sorted 进行，它比数组的排序更强之处在于你可以首先对 Stream 进行各类 map、filter、limit、skip 甚至 distinct 来减少元素数量后，再排序，这能帮助程序明显缩短执行时间。我们对“Optional 的两个用例” 进行优化：</p><h3 id="优化：排序前进行-limit-和-skip"><a href="#优化：排序前进行-limit-和-skip" class="headerlink" title="优化：排序前进行 limit 和 skip"></a>优化：排序前进行 limit 和 skip</h3><pre><code>List&lt;Person&gt; persons = new ArrayList(); for (int i = 1; i &lt;= 5; i++) { Person person = new Person(i, &quot;name&quot; + i); persons.add(person); }List&lt;Person&gt; personList2 = persons.stream().limit(2).sorted((p1, p2) -&gt; p1.getName().compareTo(p2.getName())).collect(Collectors.toList());System.out.println(personList2);</code></pre><p>结果会简单很多：</p><pre><code>name2name1[stream.StreamDW$Person@6ce253f1, stream.StreamDW$Person@53d8d10a]</code></pre><p>当然，这种优化是有 business logic 上的局限性的：即不要求排序后再取值。<br>min/max/distinct</p><p>min 和 max 的功能也可以通过对 Stream 元素先排序，再 findFirst 来实现，但前者的性能会更好，为 O(n)，而 sorted 的成本是 O(n log n)。同时它们作为特殊的 reduce 方法被独立出来也是因为求最大最小值是很常见的操作。</p><h3 id="找出最长一行的长度"><a href="#找出最长一行的长度" class="headerlink" title="找出最长一行的长度"></a>找出最长一行的长度</h3><pre><code>BufferedReader br = new BufferedReader(new FileReader(&quot;c:\\SUService.log&quot;));int longest = br.lines(). mapToInt(String::length). max(). getAsInt();br.close();System.out.println(longest);</code></pre><p>下面的例子则使用 distinct 来找出不重复的单词。</p><h3 id="找出全文的单词，转小写，并排序"><a href="#找出全文的单词，转小写，并排序" class="headerlink" title="找出全文的单词，转小写，并排序"></a>找出全文的单词，转小写，并排序</h3><pre><code>List&lt;String&gt; words = br.lines(). flatMap(line -&gt; Stream.of(line.split(&quot; &quot;))). filter(word -&gt; word.length() &gt; 0). map(String::toLowerCase). distinct(). sorted(). collect(Collectors.toList());br.close();System.out.println(words);</code></pre><h2 id="Match"><a href="#Match" class="headerlink" title="Match"></a>Match</h2><p>Stream 有三个 match 方法，从语义上说：<br>allMatch：Stream 中全部元素符合传入的 predicate，返回 true<br>anyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 true<br>noneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true<br>它们都不是要遍历全部元素才能返回结果。例如 allMatch 只要一个元素不满足条件，就 skip 剩下的所有元素，返回 false。对清单 13 中的 Person 类稍做修改，加入一个 age 属性和 getAge 方法。</p><h3 id="使用-Match"><a href="#使用-Match" class="headerlink" title="使用 Match"></a>使用 Match</h3><pre><code>List&lt;Person&gt; persons = new ArrayList();persons.add(new Person(1, &quot;name&quot; + 1, 10));persons.add(new Person(2, &quot;name&quot; + 2, 21));persons.add(new Person(3, &quot;name&quot; + 3, 34));persons.add(new Person(4, &quot;name&quot; + 4, 6));persons.add(new Person(5, &quot;name&quot; + 5, 55));boolean isAllAdult = persons.stream(). allMatch(p -&gt; p.getAge() &gt; 18);System.out.println(&quot;All are adult? &quot; + isAllAdult);boolean isThereAnyChild = persons.stream(). anyMatch(p -&gt; p.getAge() &lt; 12);System.out.println(&quot;Any child? &quot; + isThereAnyChild);</code></pre><p>输出结果：<br>    1<br>    2<br>    All are adult? false<br>    Any child? true</p><h2 id="进阶：自己生成流"><a href="#进阶：自己生成流" class="headerlink" title="进阶：自己生成流"></a>进阶：自己生成流</h2><h2 id="Stream-generate"><a href="#Stream-generate" class="headerlink" title="Stream.generate"></a>Stream.generate</h2><p>通过实现 Supplier 接口，你可以自己来控制流的生成。这种情形通常用于随机数、常量的 Stream，或者需要前后元素间维持着某种状态信息的 Stream。把 Supplier 实例传递给 Stream.generate() 生成的 Stream，默认是串行（相对 parallel 而言）但无序的（相对 ordered 而言）。由于它是无限的，在管道中，必须利用 limit 之类的操作限制 Stream 大小。</p><h3 id="生成-10-个随机整数"><a href="#生成-10-个随机整数" class="headerlink" title="生成 10 个随机整数"></a>生成 10 个随机整数</h3><pre><code>Random seed = new Random();Supplier&lt;Integer&gt; random = seed::nextInt;Stream.generate(random).limit(10).forEach(System.out::println);//Another wayIntStream.generate(() -&gt; (int) (System.nanoTime() % 100)).limit(10).forEach(System.out::println);</code></pre><p>Stream.generate() 还接受自己实现的 Supplier。例如在构造海量测试数据的时候，用某种自动的规则给每一个变量赋值；或者依据公式计算 Stream 的每个元素值。这些都是维持状态信息的情形。</p><h3 id="自实现-Supplier"><a href="#自实现-Supplier" class="headerlink" title="自实现 Supplier"></a>自实现 Supplier</h3><pre><code>Stream.generate(new PersonSupplier()).limit(10).forEach(p -&gt; System.out.println(p.getName() + &quot;, &quot; + p.getAge()));private class PersonSupplier implements Supplier&lt;Person&gt; { private int index = 0; private Random random = new Random(); @Override public Person get() { return new Person(index++, &quot;StormTestUser&quot; + index, random.nextInt(100)); }}</code></pre><p>输出结果：</p><pre><code>StormTestUser1, 9StormTestUser2, 12StormTestUser3, 88StormTestUser4, 51StormTestUser5, 22StormTestUser6, 28StormTestUser7, 81StormTestUser8, 51StormTestUser9, 4StormTestUser10, 76</code></pre><h2 id="Stream-iterate"><a href="#Stream-iterate" class="headerlink" title="Stream.iterate"></a>Stream.iterate</h2><p>iterate 跟 reduce 操作很像，接受一个种子值，和一个 UnaryOperator（例如 f）。然后种子值成为 Stream 的第一个元素，f(seed) 为第二个，f(f(seed)) 第三个，以此类推。</p><h3 id="生成一个等差数列"><a href="#生成一个等差数列" class="headerlink" title="生成一个等差数列"></a>生成一个等差数列</h3><pre><code>Stream.iterate(0, n -&gt; n + 3).limit(10). forEach(x -&gt; System.out.print(x + &quot; &quot;));.</code></pre><p>输出结果：</p><pre><code>0 3 6 9 12 15 18 21 24 27</code></pre><p>与 Stream.generate 相仿，在 iterate 时候管道必须有 limit 这样的操作来限制 Stream 大小。</p><h2 id="进阶：用-Collectors-来进行-reduction-操作"><a href="#进阶：用-Collectors-来进行-reduction-操作" class="headerlink" title="进阶：用 Collectors 来进行 reduction 操作"></a>进阶：用 Collectors 来进行 reduction 操作</h2><p>java.util.stream.Collectors 类的主要作用就是辅助进行各类有用的 reduction 操作，例如转变输出为 Collection，把 Stream 元素进行归组。<br>groupingBy/partitioningBy</p><h3 id="按照年龄归组"><a href="#按照年龄归组" class="headerlink" title="按照年龄归组"></a>按照年龄归组</h3><pre><code>Map&lt;Integer, List&lt;Person&gt;&gt; personGroups = Stream.generate(new PersonSupplier()). limit(100). collect(Collectors.groupingBy(Person::getAge));Iterator it = personGroups.entrySet().iterator();while (it.hasNext()) { Map.Entry&lt;Integer, List&lt;Person&gt;&gt; persons = (Map.Entry) it.next(); System.out.println(&quot;Age &quot; + persons.getKey() + &quot; = &quot; + persons.getValue().size());}</code></pre><p>上面的 code，首先生成 100 人的信息，然后按照年龄归组，相同年龄的人放到同一个 list 中，可以看到如下的输出：</p><pre><code>Age 0 = 2Age 1 = 2Age 5 = 2Age 8 = 1Age 9 = 1Age 11 = 2……</code></pre><h3 id="按照未成年人和成年人归组"><a href="#按照未成年人和成年人归组" class="headerlink" title="按照未成年人和成年人归组"></a>按照未成年人和成年人归组</h3><pre><code>Map&lt;Boolean, List&lt;Person&gt;&gt; children = Stream.generate(new PersonSupplier()). limit(100). collect(Collectors.partitioningBy(p -&gt; p.getAge() &lt; 18));System.out.println(&quot;Children number: &quot; + children.get(true).size());System.out.println(&quot;Adult number: &quot; + children.get(false).size());</code></pre><p>输出结果：</p><pre><code>Children number: 23Adult number: 77</code></pre><p>在使用条件“年龄小于 18”进行分组后可以看到，不到 18 岁的未成年人是一组，成年人是另外一组。</p><p>partitioningBy 其实是一种特殊的 groupingBy，它依照条件测试的是否两种结果来构造返回的数据结构，get(true) 和 get(false) 能即为全部的元素对象。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>总之，Stream 的特性可以归纳为：</p><p>不是数据结构</p><p>它没有内部存储，它只是用操作管道从 source（数据结构、数组、generator function、IO channel）抓取数据。</p><p>它也绝不修改自己所封装的底层数据结构的数据。例如 Stream 的 filter 操作会产生一个不包含被过滤元素的新 Stream，而不是从 source 删除那些元素。</p><p>所有 Stream 的操作必须以 lambda 表达式为参数</p><p>不支持索引访问</p><p>你可以请求第一个元素，但无法请求第二个，第三个，或最后一个。不过请参阅下一项。</p><p>很容易生成数组或者 List</p><p>惰性化</p><p>很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。<br>Intermediate 操作永远是惰性化的。</p><p>并行能力</p><p>当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的。</p><p>可以是无限的</p><p>集合有固定大小，Stream 则不必。limit(n) 和 findFirst() 这类的 short-circuiting 操作可以对无限的 Stream 进行运算并很快完成。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/index.html</a></p><p>【2】<a href="https://www.ibm.com/developerworks/cn/java/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/</a></p><p>【3】<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html</a></p><p>【4】<a href="https://javarevisited.blogspot.com/2018/07/java-8-tutorials-resources-and-examples-lambda-expression-stream-api-functional-interfaces.html" target="_blank" rel="noopener">https://javarevisited.blogspot.com/2018/07/java-8-tutorials-resources-and-examples-lambda-expression-stream-api-functional-interfaces.html</a></p><p>【5】<a href="http://www.drdobbs.com/jvm/lambdas-and-streams-in-java-8-libraries/240166818" target="_blank" rel="noopener">http://www.drdobbs.com/jvm/lambdas-and-streams-in-java-8-libraries/240166818</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MapReduce思想学习,对Java8中对新特性stream，map和reduce进行学习，Stream API部分主要来自于IBM Developer官网，原文写的非常详尽清晰。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年8月" scheme="http://yoursite.com/categories/2019%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记V</title>
    <link href="http://yoursite.com/2019/08/12/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0V/"/>
    <id>http://yoursite.com/2019/08/12/Java学习笔记V/</id>
    <published>2019-08-12T06:48:12.000Z</published>
    <updated>2019-08-13T06:44:00.146Z</updated>
    
    <content type="html"><![CDATA[<p>学习Guaa中的字符串处理函数Joiner类的用法。</p><a id="more"></a><h1 id="Guava"><a href="#Guava" class="headerlink" title="Guava"></a>Guava</h1><p>Guava 是一个 Google 的基于java1.6的类库集合的扩展项目，Guava工程包含了若干被Google的 Java项目广泛依赖 的核心库，例如：集合 [collections] 、缓存 [caching] 、原生类型支持 [primitives support] 、并发库 [concurrency libraries] 、通用注解 [common annotations] 、字符串处理 [string processing] 、I/O 等等。</p><h1 id="连接器Joiner"><a href="#连接器Joiner" class="headerlink" title="连接器Joiner"></a>连接器Joiner</h1><p>用分隔符把字符串序列连接起来也可能会遇上不必要的麻烦。如果字符串序列中含有null，那连接操作会更难。Fluent风格的Joiner让连接字符串更简单。</p><p>  Joiner joiner = Joiner.on(“; “).skipNulls();<br>  return joiner.join(“Harry”, null, “Ron”, “Hermione”);</p><p>上述代码返回”Harry; Ron; Hermione”。另外，useForNull(String)方法可以给定某个字符串来替换null，而不像skipNulls()方法是直接忽略null。<br> Joiner也可以用来连接对象类型，在这种情况下，它会把对象的toString()值连接起来。</p><pre><code>Joiner.on(&quot;,&quot;).join(Arrays.asList(1, 5, 7)); // returns &quot;1,5,7&quot;</code></pre><p>警告：joiner实例总是不可变的。用来定义joiner目标语义的配置方法总会返回一个新的joiner实例。<br>这使得joiner实例都是线程安全的，你可以将其定义为static final常量。</p><h1 id="传统连接方法"><a href="#传统连接方法" class="headerlink" title="传统连接方法"></a>传统连接方法</h1><p>相比之下传统的以某个分隔符来进行拼接的代码如下：</p><pre><code>public static String concatString(List&lt;String&gt; lists,String delimiter){    StringBuilder builder=new StringBuilder();    for(String s:lists){        if(s!=null){            builder.append(s).append(delimiter);        }    }    builder.setLength(builder.length()-delimiter.length());    return builder.toString();}public  static  void  main(String[] args) {  List&lt;String&gt; list=new ArrayList();  list.add(&quot;Traditional&quot;);  list.add(&quot;delimiter&quot;);  list.add(&quot;codingstyle&quot;);  System.out.println(concatString(list,&quot;-&quot;));}</code></pre><h1 id="MapJoiner"><a href="#MapJoiner" class="headerlink" title="MapJoiner"></a>MapJoiner</h1><p>MapJoiner的用法和Joiner类似,不过MapJoiner主要针对map的字符串拼接例：</p><pre><code>Map&lt;String,String&gt; maps=Maps.newHashMap();maps.put(&quot;MapJoiner&quot;,&quot;1&quot;);maps.put(&quot;String&quot;,&quot;delimiter&quot;);String ss=Joiner.on(&quot;$&quot;).withKeyValueSeparator(&quot;=&quot;).join(maps);System.out.println(ss);</code></pre><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://wizardforcel.gitbooks.io/guava-tutorial/content/1.html" target="_blank" rel="noopener">https://wizardforcel.gitbooks.io/guava-tutorial/content/1.html</a></p><p>【2】<a href="https://blog.csdn.net/u012415194/article/details/84880258" target="_blank" rel="noopener">https://blog.csdn.net/u012415194/article/details/84880258</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习Guaa中的字符串处理函数Joiner类的用法。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年8月" scheme="http://yoursite.com/categories/2019%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记III</title>
    <link href="http://yoursite.com/2019/08/12/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0III/"/>
    <id>http://yoursite.com/2019/08/12/Java学习笔记III/</id>
    <published>2019-08-12T06:45:12.000Z</published>
    <updated>2019-08-13T06:13:13.593Z</updated>
    
    <content type="html"><![CDATA[<p>总结Java8 Lambda表达式，对涉及到到final关键字做了回顾</p><a id="more"></a><h1 id="Java8-Lambda表达式"><a href="#Java8-Lambda表达式" class="headerlink" title="Java8 Lambda表达式"></a>Java8 Lambda表达式</h1><p>Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。<br>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。<br>使用 Lambda 表达式可以使代码变的更加简洁紧凑。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>lambda 表达式的语法格式如下：</p><pre><code>(parameters) -&gt; expression或(parameters) -&gt;{ statements; }</code></pre><p>以下是lambda表达式的重要特征:</p><p>可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。</p><p>可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。</p><p>可选的大括号：如果主体包含了一个语句，就不需要使用大括号。</p><p>可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</p><h2 id="Lambda-表达式实例"><a href="#Lambda-表达式实例" class="headerlink" title="Lambda 表达式实例"></a>Lambda 表达式实例</h2><p>Lambda 表达式的简单例子:</p><pre><code>// 1. 不需要参数,返回值为 5  () -&gt; 5  // 2. 接收一个参数(数字类型),返回其2倍的值  x -&gt; 2 * x  // 3. 接受2个参数(数字),并返回他们的差值  (x, y) -&gt; x – y  // 4. 接收2个int型整数,返回他们的和  (int x, int y) -&gt; x + y  // 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  (String s) -&gt; System.out.print(s)</code></pre><p>在 Java8Tester.java 文件输入以下代码：</p><pre><code>public class Java8Tester {   public static void main(String args[]){      Java8Tester tester = new Java8Tester();      // 类型声明      MathOperation addition = (int a, int b) -&gt; a + b;      // 不用类型声明      MathOperation subtraction = (a, b) -&gt; a - b;      // 大括号中的返回语句      MathOperation multiplication = (int a, int b) -&gt; { return a * b; };      // 没有大括号及返回语句      MathOperation division = (int a, int b) -&gt; a / b;      System.out.println(&quot;10 + 5 = &quot; + tester.operate(10, 5, addition));      System.out.println(&quot;10 - 5 = &quot; + tester.operate(10, 5, subtraction));      System.out.println(&quot;10 x 5 = &quot; + tester.operate(10, 5, multiplication));      System.out.println(&quot;10 / 5 = &quot; + tester.operate(10, 5, division));      // 不用括号      GreetingService greetService1 = message -&gt;      System.out.println(&quot;Hello &quot; + message);      // 用括号      GreetingService greetService2 = (message) -&gt;      System.out.println(&quot;Hello &quot; + message);      greetService1.sayMessage(&quot;Runoob&quot;);      greetService2.sayMessage(&quot;Google&quot;);   }   interface MathOperation {      int operation(int a, int b);   }   interface GreetingService {      void sayMessage(String message);   }   private int operate(int a, int b, MathOperation mathOperation){      return mathOperation.operation(a, b);   }}</code></pre><p>执行以上脚本，输出结果为：</p><pre><code>$ javac Java8Tester.java$ java Java8Tester10 + 5 = 1510 - 5 = 510 x 5 = 5010 / 5 = 2Hello RunoobHello Google</code></pre><p>使用 Lambda 表达式需要注意以下两点：</p><p>Lambda 表达式主要用来定义行内执行的方法类型接口，例如，一个简单方法接口。在上面例子中，我们使用各种类型的Lambda表达式来定义MathOperation接口的方法。然后我们定义了sayMessage的执行。</p><p>Lambda 表达式免去了使用匿名方法的麻烦，并且给予Java简单但是强大的函数化的编程能力。</p><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>lambda 表达式只能引用标记了 final 的外层局部变量，这就是说不能在 lambda 内部修改定义在域外的局部变量，否则会编译错误。<br>在 Java8Tester.java 文件输入以下代码：</p><pre><code>public class Java8Tester {final static String salutation = &quot;Hello! &quot;;public static void main(String args[]){  GreetingService greetService1 = message -&gt;  System.out.println(salutation + message);  greetService1.sayMessage(&quot;Runoob&quot;);}interface GreetingService {  void sayMessage(String message);}}</code></pre><p>执行以上脚本，输出结果为：</p><pre><code>$ javac Java8Tester.java$ java Java8TesterHello! Runoob</code></pre><p>我们也可以直接在 lambda 表达式中访问外层的局部变量：</p><pre><code>public class Java8Tester {    public static void main(String args[]) {        final int num = 1;        Converter&lt;Integer, String&gt; s = (param) -&gt; System.out.println(String.valueOf(param + num));        s.convert(2);  // 输出结果为 3    }    public interface Converter&lt;T1, T2&gt; {        void convert(int i);    }}</code></pre><p>lambda 表达式的局部变量可以不用声明为 final，但是必须不可被后面的代码修改（即隐性的具有 final 的语义）</p><pre><code>int num = 1;  Converter&lt;Integer, String&gt; s = (param) -&gt; System.out.println(String.valueOf(param + num));s.convert(2);num = 5;  //报错信息：Local variable num defined in an enclosing scope must be final or effectively final</code></pre><p>在 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量。</p><pre><code>String first = &quot;&quot;;  Comparator&lt;String&gt; comparator = (first, second) -&gt; Integer.compare(first.length(), second.length());  //编译会出错</code></pre><h1 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h1><p>final是一个关键字，可以用于修饰类，成员变量，成员方法。</p><h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><p>它修饰的类不能被继承。</p><p>它修饰的成员变量是一个常量。</p><p>它修饰的成员方法是不能被子类重写的。</p><p>final修饰的常量定义一般都有书写规范,被final修饰的常量名称,所有字母都大写。</p><p>final修饰成员变量,必须初始化,初始化有两种</p><p>显示初始化；</p><p>构造方法初始化。</p><p>但是不能两个一起初始化</p><h2 id="final和private的区别："><a href="#final和private的区别：" class="headerlink" title="final和private的区别："></a>final和private的区别：</h2><p>final修饰的类可以访问；</p><p>private不可以修饰外部类，但可以修饰内部类（其实把外部类私有化是没有意义的）。</p><p>final修饰的方法不可以被子类重写；</p><p>private修饰的方法表面上看是可以被子类重写的，其实不可以，子类是看不到父类的私有方法的。</p><p>final修饰的变量只能在显示初始化或者构造函数初始化的时候赋值一次，以后不允许更改；</p><p>private修饰的变量，也不允许直接被子类或一个包中的其它类访问或修改，但是他可以通过set和get方法对其改值和取值。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://www.runoob.com/java/java8-lambda-expressions.html" target="_blank" rel="noopener">https://www.runoob.com/java/java8-lambda-expressions.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结Java8 Lambda表达式，对涉及到到final关键字做了回顾&lt;/p&gt;
    
    </summary>
    
      <category term="2019年8月" scheme="http://yoursite.com/categories/2019%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>数据库学习笔记II</title>
    <link href="http://yoursite.com/2019/08/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0II/"/>
    <id>http://yoursite.com/2019/08/09/数据库学习笔记II/</id>
    <published>2019-08-09T07:12:12.000Z</published>
    <updated>2019-08-13T07:20:00.734Z</updated>
    
    <content type="html"><![CDATA[<p>重新温习Mysqlkey 、primary key 、unique key 与index的区别</p><a id="more"></a><h1 id="key与primary-key区别"><a href="#key与primary-key区别" class="headerlink" title="key与primary key区别"></a>key与primary key区别</h1><pre><code>CREATE TABLE wh_logrecord (  logrecord_id int(11) NOT NULL auto_increment,  user_name varchar(100) default NULL,  operation_time datetime default NULL,  logrecord_operation varchar(100) default NULL,  PRIMARY KEY (logrecord_id),  KEY wh_logrecord_user_name (user_name)  )</code></pre><h2 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h2><p>  KEY wh_logrecord_user_name (user_name)</p><p>  本表的user_name字段与wh_logrecord_user_name表user_name字段建立外键</p><p>  括号外是建立外键的对应表，括号内是对应字段</p><p>  类似还有 KEY user(userid)</p><p>  当然，key未必都是外键</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>  Key是索引约束，对表中字段进行约束索引的，都是通过primary foreign unique等创建的。<br>  常见有foreign key，外键关联用的。</p><p>  KEY forum (status,type,displayorder)  # 是多列索引（键）</p><p>  KEY tid (tid)                         # 是单列索引（键）。</p><p>  如建表时： KEY forum (status,type,displayorder)</p><p>  select * from table group by status,type,displayorder 是否就自动用上了此索引，</p><p>  而当 select * from table group by status 此索引有用吗？</p><p>  key的用途：主要是用来加快查询速度的。</p><h1 id="KEY与INDEX区别"><a href="#KEY与INDEX区别" class="headerlink" title="KEY与INDEX区别"></a>KEY与INDEX区别</h1><p>KEY通常是INDEX同义词。</p><p>如果关键字属性PRIMARY KEY在列定义中已给定，则PRIMARY KEY也可以只指定为KEY。这么做的目的是与其它数据库系统兼容。</p><p>PRIMARY KEY是一个唯一KEY，此时，所有的关键字列必须定义为NOT NULL。</p><p>如果这些列没有被明确地定义为NOT NULL，MySQL应隐含地定义这些列。</p><p>一个表只有一个PRIMARY KEY。</p><h2 id="MySQL-中Index-与Key-的区别"><a href="#MySQL-中Index-与Key-的区别" class="headerlink" title="MySQL 中Index 与Key 的区别"></a>MySQL 中Index 与Key 的区别</h2><p>Key即键值，是关系模型理论中的一部份，比如有主键（Primary Key)，外键（Foreign Key）等，用于数据完整性检否与唯一性约束等。</p><p>而Index则处于实现层面，比如可以对表个的任意列建立索引，那么当建立索引的列处于SQL语句中的Where条件中时，就可以得到快速的数据定位，从而快速检索。</p><p>至于Unique Index，则只是属于Index中的一种而已，建立了Unique Index表示此列数据不可重复，猜想MySQL对Unique Index类型的索引可以做进一步特殊优化吧。</p><p>于是乎，在设计表的时候，Key只是要处于模型层面的，而当需要进行查询优化，则对相关列建立索引即可。</p><p>另外，在MySQL中，对于一个Primary Key的列，MySQL已经自动对其建立了Unique Index，无需重复再在上面建立索引了。</p><p>搜索到的一段解释：</p><p>Note that “primary” is called PRIMARY KEY not INDEX.</p><p>KEY is something on the logical level, describes your table and database design (i.e. enforces referential integrity …)</p><p>INDEX is something on the physical level, helps improve access time for table operations.</p><p>Behind every PK there is (usually) unique index created (automatically).</p><h1 id="mysql中UNIQUE-KEY和PRIMARY-KEY有什么区别"><a href="#mysql中UNIQUE-KEY和PRIMARY-KEY有什么区别" class="headerlink" title="mysql中UNIQUE KEY和PRIMARY KEY有什么区别"></a>mysql中UNIQUE KEY和PRIMARY KEY有什么区别</h1><p>1，Primary key的1个或多个列必须为NOT NULL，如果列为NULL，在增加PRIMARY KEY时，列自动更改为NOT NULL。而UNIQUE KEY 对列没有此要求</p><p>2，一个表只能有一个PRIMARY KEY，但可以有多个UNIQUE KEY</p><p>3，主键和唯一键约束是通过参考索引实施的，如果插入的值均为NULL，则根据索引的原理，全NULL值不被记录在索引上，所以插入全NULL值时，可以有重复的，而其他的则不能插入重复值。</p><pre><code>alter table t add constraint uk_t_1 unique (a,b);insert into t (a ,b ) values (null,1);    # 不能重复insert into t (a ,b ) values (null,null); # 可以重复</code></pre><h1 id="使用UNIQUE-KEY"><a href="#使用UNIQUE-KEY" class="headerlink" title="使用UNIQUE KEY"></a>使用UNIQUE KEY</h1><pre><code>CREATE TABLE `secure_vulnerability_warning` (  `id` int(10) NOT NULL auto_increment,  `date` date NOT NULL,  `type` varchar(100) NOT NULL,  `sub_type` varchar(100) NOT NULL,  `domain_name` varchar(128) NOT NULL,  `url` text NOT NULL,  `parameters` text NOT NULL,  `hash` varchar(100) NOT NULL,  `deal` int(1) NOT NULL,  `deal_date` date default NULL,  `remark` text,  `last_push_time` datetime default NULL,  `push_times` int(11) default &apos;1&apos;,  `first_set_ok_time` datetime default NULL,  `last_set_ok_time` datetime default NULL,  PRIMARY KEY  (`id`),  UNIQUE KEY `date` (`date`,`hash`)  ) ENGINE=InnoDB  DEFAULT CHARSET=utf8</code></pre><p>UNIQUE KEY的用途：主要是用来防止数据插入的时候重复的。</p><p>1，创建表时</p><pre><code>CREATE TABLE Persons(  Id_P int NOT NULL,  LastName varchar(255) NOT NULL,  FirstName varchar(255),  Address varchar(255),  City varchar(255),  UNIQUE (Id_P))</code></pre><p>如果需要命名 UNIQUE 约束，以及为多个列定义 UNIQUE 约束，请使用下面的 SQL 语法：</p><pre><code>CREATE TABLE Persons(  Id_P int NOT NULL,  LastName varchar(255) NOT NULL,  FirstName varchar(255),  Address varchar(255),  City varchar(255),  CONSTRAINT uc_PersonID UNIQUE (Id_P,LastName))</code></pre><p>2，当表已被创建时，如需在 “Id_P” 列创建 UNIQUE 约束，请使用下列 SQL：</p><p>ALTER TABLE PersonsADD UNIQUE (Id_P)<br>如需命名 UNIQUE 约束，并定义多个列的 UNIQUE 约束，请使用下面的 SQL 语法：</p><p>ALTER TABLE PersonsADD CONSTRAINT uc_PersonID UNIQUE (Id_P,LastName)</p><p>3，撤销 UNIQUE 约束如需撤销 UNIQUE 约束，请使用下面的 SQL：</p><p>MySQL:ALTER TABLE PersonsDROP INDEX uc_PersonID</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://www.jianshu.com/p/336170f4d649" target="_blank" rel="noopener">https://www.jianshu.com/p/336170f4d649</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重新温习Mysqlkey 、primary key 、unique key 与index的区别&lt;/p&gt;
    
    </summary>
    
      <category term="2019年8月" scheme="http://yoursite.com/categories/2019%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记II</title>
    <link href="http://yoursite.com/2019/08/07/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0II/"/>
    <id>http://yoursite.com/2019/08/07/Java学习笔记II/</id>
    <published>2019-08-07T07:37:12.000Z</published>
    <updated>2019-08-12T06:37:34.791Z</updated>
    
    <content type="html"><![CDATA[<p>重新温习Java中的异常处理</p><a id="more"></a><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>异常是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。</p><p>比如说，你的代码少了一个分号，那么运行出来结果是提示是错误 java.lang.Error；如果你用System.out.println(11/0)，那么你是因为你用0做了除数，会抛出 java.lang.ArithmeticException 的异常。</p><p>异常发生的原因有很多，通常包含以下几大类：</p><p>用户输入了非法数据。</p><p>要打开的文件不存在。</p><p>网络通信时连接中断，或者JVM内存溢出。</p><p>这些异常有的是因为用户错误引起，有的是程序错误引起的，还有其它一些是因为物理错误引起的。</p><p>要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常：</p><p>检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</p><p>运行时异常： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</p><p>错误： 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</p><h2 id="Exception-类的层次"><a href="#Exception-类的层次" class="headerlink" title="Exception 类的层次"></a>Exception 类的层次</h2><p>所有的异常类是从 java.lang.Exception 类继承的子类。</p><p>Exception 类是 Throwable 类的子类。除了Exception类外，Throwable还有一个子类Error 。</p><p>Java 程序通常不捕获错误。错误一般发生在严重故障时，它们在Java程序处理的范畴之外。</p><p>Error 用来指示运行时环境发生的错误。</p><p>例如，JVM 内存溢出。一般地，程序不会从错误中恢复。</p><p>异常类有两个主要的子类：IOException 类和 RuntimeException 类。</p><p><img src="assets/markdown-img-paste-20190807155403573.png" alt="https://www.runoob.com/wp-content/uploads/2013/12/12-130Q1234I6223.jpg"></p><h2 id="Java-内置异常类"><a href="#Java-内置异常类" class="headerlink" title="Java 内置异常类"></a>Java 内置异常类</h2><p>Java 语言定义了一些异常类在 java.lang 标准包中。</p><p>标准运行时异常类的子类是最常见的异常类。由于 java.lang 包是默认加载到所有的 Java 程序的，所以大部分从运行时异常类继承而来的异常都可以直接使用。</p><p>Java 根据各个类库也定义了一些其他的异常，下面的表中列出了 Java 的非检查性异常</p><table><thead><tr><th>异常</th><th>描述</th></tr></thead><tbody><tr><td>ArithmeticException</td><td>当出现异常的运算条件时，抛出此异常。例如，一个整数”除以零”时，抛出此类的一个实例。</td></tr><tr><td>ArrayIndexOutOfBoundsException</td><td>用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。</td></tr><tr><td>ArrayStoreException</td><td>试图将错误类型的对象存储到一个对象数组时抛出的异常。</td></tr><tr><td>ClassCastException</td><td>当试图将对象强制转换为不是实例的子类时，抛出该异常。</td></tr><tr><td>IllegalArgumentException</td><td>抛出的异常表明向方法传递了一个不合法或不正确的参数。</td></tr><tr><td>IllegalMonitorStateException</td><td>抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。</td></tr><tr><td>IllegalStateException</td><td>在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下。</td></tr><tr><td>IllegalThreadStateException</td><td>线程没有处于请求操作所要求的适当状态时抛出的异常。</td></tr><tr><td>IndexOutOfBoundsException</td><td>指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。</td></tr><tr><td>NegativeArraySizeException</td><td>如果应用程序试图创建大小为负的数组，则抛出该异常。</td></tr><tr><td>NullPointerException</td><td>当应用程序试图在需要对象的地方使用 null 时，抛出该异常</td></tr><tr><td>NumberFormatException</td><td>当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</td></tr><tr><td>SecurityException</td><td>由安全管理器抛出的异常，指示存在安全侵犯。</td></tr><tr><td>StringIndexOutOfBoundsException</td><td>此异常由 String 方法抛出，指示索引或者为负，或者超出字符串的大小。</td></tr><tr><td>UnsupportedOperationException</td><td>当不支持请求的操作时，抛出该异常。</td></tr></tbody></table><p>下面的表中列出了 Java 定义在 java.lang 包中的检查性异常类。</p><table><thead><tr><th>异常</th><th>描述</th></tr></thead><tbody><tr><td>ClassNotFoundException</td><td>应用程序试图加载类时，找不到相应的类，抛出该异常。</td></tr><tr><td>CloneNotSupportedException</td><td>当调用 Object 类中的 clone 方法克隆对象，但该对象的类无法实现 Cloneable 接口时，抛出该异常。</td></tr><tr><td>IllegalAccessException</td><td>拒绝访问一个类的时候，抛出该异常。</td></tr><tr><td>InstantiationException</td><td>当试图使用 Class 类中的 newInstance 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常。</td></tr><tr><td>InterruptedException</td><td>一个线程被另一个线程中断，抛出该异常。</td></tr><tr><td>NoSuchFieldException</td><td>请求的变量不存在</td></tr><tr><td>NoSuchMethodException</td><td>请求的方法不存在</td></tr></tbody></table><h2 id="异常方法"><a href="#异常方法" class="headerlink" title="异常方法"></a>异常方法</h2><p>下面的列表是 Throwable 类的主要方法:</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public String getMessage()</td><td>返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。</td></tr><tr><td>public Throwable getCause()</td><td>返回一个Throwable 对象代表异常原因。</td></tr><tr><td>public String toString()</td><td>使用getMessage()的结果返回类的串级名字。</td></tr><tr><td>public void printStackTrace()</td><td>打印toString()结果和栈层次到System.err，即错误输出流。</td></tr><tr><td>public StackTraceElement [] getStackTrace()</td><td>返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。</td></tr><tr><td>public Throwable fillInStackTrace()</td><td>用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中。</td></tr></tbody></table><h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><p>使用 try 和 catch 关键字可以捕获异常。try/catch 代码块放在异常可能发生的地方。</p><p>try/catch代码块中的代码称为保护代码，使用 try/catch 的语法如下：</p><pre><code>try{   // 程序代码}catch(ExceptionName e1){   //Catch 块}</code></pre><p>Catch 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。</p><p>如果发生的异常包含在 catch 块中，异常会被传递到该 catch 块，这和传递一个参数到方法是一样。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>下面的例子中声明有两个元素的一个数组，当代码试图访问数组的第三个元素的时候就会抛出一个异常。</p><p>ExcepTest.java 文件代码：</p><pre><code>// 文件名 : ExcepTest.javaimport java.io.*;public class ExcepTest{   public static void main(String args[]){      try{         int a[] = new int[2];         System.out.println(&quot;Access element three :&quot; + a[3]);      }catch(ArrayIndexOutOfBoundsException e){         System.out.println(&quot;Exception thrown  :&quot; + e);      }      System.out.println(&quot;Out of the block&quot;);   }}</code></pre><p>以上代码编译运行输出结果如下：</p><pre><code>Exception thrown  :java.lang.ArrayIndexOutOfBoundsException: 3Out of the block</code></pre><h3 id="多重捕获块"><a href="#多重捕获块" class="headerlink" title="多重捕获块"></a>多重捕获块</h3><p>一个 try 代码块后面跟随多个 catch 代码块的情况就叫多重捕获。</p><p>多重捕获块的语法如下所示：</p><pre><code>try{   // 程序代码}catch(异常类型1 异常的变量名1){  // 程序代码}catch(异常类型2 异常的变量名2){  // 程序代码}catch(异常类型2 异常的变量名2){  // 程序代码}</code></pre><p>上面的代码段包含了 3 个 catch块。</p><p>可以在 try 语句后面添加任意数量的 catch 块。</p><p>如果保护代码中发生异常，异常被抛给第一个 catch 块。</p><p>如果抛出异常的数据类型与 ExceptionType1 匹配，它在这里就会被捕获。</p><p>如果不匹配，它会被传递给第二个 catch 块。</p><p>如此，直到异常被捕获或者通过所有的 catch 块。</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>该实例展示了怎么使用多重 try/catch。</p><pre><code>try {    file = new FileInputStream(fileName);    x = (byte) file.read();} catch(FileNotFoundException f) { // Not valid!    f.printStackTrace();    return -1;} catch(IOException i) {    i.printStackTrace();    return -1;}</code></pre><h2 id="throws-throw-关键字："><a href="#throws-throw-关键字：" class="headerlink" title="throws/throw 关键字："></a>throws/throw 关键字：</h2><p>如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明。</p><p>throws 关键字放在方法签名的尾部。</p><p>也可以使用 throw 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的。</p><p>下面方法的声明抛出一个 RemoteException 异常：</p><pre><code>import java.io.*;public class className{  public void deposit(double amount) throws RemoteException  {    // Method implementation    throw new RemoteException();  }  //Remainder of class definition}</code></pre><p>一个方法可以声明抛出多个异常，多个异常之间用逗号隔开。</p><p>例如，下面的方法声明抛出 RemoteException 和 InsufficientFundsException：</p><pre><code>import java.io.*;public class className{   public void withdraw(double amount) throws RemoteException,                              InsufficientFundsException   {       // Method implementation   }   //Remainder of class definition}</code></pre><h2 id="finally关键字"><a href="#finally关键字" class="headerlink" title="finally关键字"></a>finally关键字</h2><p>finally 关键字用来创建在 try 代码块后面执行的代码块。</p><p>无论是否发生异常，finally 代码块中的代码总会被执行。</p><p>在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。</p><p>finally 代码块出现在 catch 代码块最后，语法如下：</p><pre><code>try{  // 程序代码}catch(异常类型1 异常的变量名1){  // 程序代码}catch(异常类型2 异常的变量名2){  // 程序代码}finally{  // 程序代码}</code></pre><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>ExcepTest.java 文件代码：</p><pre><code>public class ExcepTest{  public static void main(String args[]){    int a[] = new int[2];    try{       System.out.println(&quot;Access element three :&quot; + a[3]);    }catch(ArrayIndexOutOfBoundsException e){       System.out.println(&quot;Exception thrown  :&quot; + e);    }    finally{       a[0] = 6;       System.out.println(&quot;First element value: &quot; +a[0]);       System.out.println(&quot;The finally statement is executed&quot;);    }  }}</code></pre><p>以上实例编译运行结果如下：</p><pre><code>Exception thrown  :java.lang.ArrayIndexOutOfBoundsException: 3First element value: 6The finally statement is executed</code></pre><p>注意下面事项：</p><p>catch 不能独立于 try 存在。</p><p>在 try/catch 后面添加 finally 块并非强制性要求的。</p><p>try 代码后不能既没 catch 块也没 finally 块。</p><p>try, catch, finally 块之间不能添加任何代码。</p><h2 id="声明自定义异常"><a href="#声明自定义异常" class="headerlink" title="声明自定义异常"></a>声明自定义异常</h2><p>在 Java 中你可以自定义异常。编写自己的异常类时需要记住下面的几点。</p><p>所有异常都必须是 Throwable 的子类。</p><p>如果希望写一个检查性异常类，则需要继承 Exception 类。</p><p>如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。</p><p>可以像下面这样定义自己的异常类：</p><pre><code>class MyException extends Exception{}</code></pre><p>只继承Exception 类来创建的异常类是检查性异常类。</p><p>下面的 InsufficientFundsException 类是用户定义的异常类，它继承自 Exception。</p><p>一个异常类和其它任何类一样，包含有变量和方法。</p><h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><p>以下实例是一个银行账户的模拟，通过银行卡的号码完成识别，可以进行存钱和取钱的操作。</p><p>InsufficientFundsException.java 文件代码：</p><pre><code>// 文件名InsufficientFundsException.javaimport java.io.*;//自定义异常类，继承Exception类public class InsufficientFundsException extends Exception{  //此处的amount用来储存当出现异常（取出钱多于余额时）所缺乏的钱  private double amount;  public InsufficientFundsException(double amount)  {    this.amount = amount;  }  public double getAmount()  {    return amount;  }}</code></pre><p>为了展示如何使用我们自定义的异常类，</p><p>在下面的 CheckingAccount 类中包含一个 withdraw() 方法抛出一个 InsufficientFundsException 异常。</p><p>CheckingAccount.java 文件代码：</p><pre><code>// 文件名称 CheckingAccount.javaimport java.io.*;//此类模拟银行账户public class CheckingAccount{  //balance为余额，number为卡号   private double balance;   private int number;   public CheckingAccount(int number)   {      this.number = number;   }  //方法：存钱   public void deposit(double amount)   {      balance += amount;   }  //方法：取钱   public void withdraw(double amount) throws                              InsufficientFundsException   {      if(amount &lt;= balance)      {         balance -= amount;      }      else      {         double needs = amount - balance;         throw new InsufficientFundsException(needs);      }   }  //方法：返回余额   public double getBalance()   {      return balance;   }  //方法：返回卡号   public int getNumber()   {      return number;   }}</code></pre><p>下面的 BankDemo 程序示范了如何调用 CheckingAccount 类的 deposit() 和 withdraw() 方法。</p><p>BankDemo.java 文件代码：</p><pre><code>//文件名称 BankDemo.javapublic class BankDemo{   public static void main(String [] args)   {      CheckingAccount c = new CheckingAccount(101);      System.out.println(&quot;Depositing $500...&quot;);      c.deposit(500.00);      try      {         System.out.println(&quot;\nWithdrawing $100...&quot;);         c.withdraw(100.00);         System.out.println(&quot;\nWithdrawing $600...&quot;);         c.withdraw(600.00);      }catch(InsufficientFundsException e)      {         System.out.println(&quot;Sorry, but you are short $&quot;                                  + e.getAmount());         e.printStackTrace();      }    }}</code></pre><p>编译上面三个文件，并运行程序 BankDemo，得到结果如下所示：</p><pre><code>Depositing $500...Withdrawing $100...Withdrawing $600...Sorry, but you are short $200.0InsufficientFundsException        at CheckingAccount.withdraw(CheckingAccount.java:25)        at BankDemo.main(BankDemo.java:13)</code></pre><h2 id="通用异常"><a href="#通用异常" class="headerlink" title="通用异常"></a>通用异常</h2><p>在Java中定义了两种类型的异常和错误。</p><h3 id="JVM-Java虚拟机-异常："><a href="#JVM-Java虚拟机-异常：" class="headerlink" title="JVM(Java虚拟机) 异常："></a>JVM(Java虚拟机) 异常：</h3><p>由 JVM 抛出的异常或错误。例如：NullPointerException 类，ArrayIndexOutOfBoundsException 类，ClassCastException 类。</p><h3 id="程序级异常："><a href="#程序级异常：" class="headerlink" title="程序级异常："></a>程序级异常：</h3><p>由程序或者API程序抛出的异常。例如 IllegalArgumentException 类，IllegalStateException 类。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<br><a href="https://www.runoob.com/java/java-exceptions.html" target="_blank" rel="noopener">https://www.runoob.com/java/java-exceptions.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重新温习Java中的异常处理&lt;/p&gt;
    
    </summary>
    
      <category term="2019年8月" scheme="http://yoursite.com/categories/2019%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
</feed>
