<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-12-27T06:29:21.578Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Scala学习笔记V</title>
    <link href="http://yoursite.com/2019/12/27/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0V/"/>
    <id>http://yoursite.com/2019/12/27/Scala学习笔记V/</id>
    <published>2019-12-27T06:08:12.000Z</published>
    <updated>2019-12-27T06:29:21.578Z</updated>
    
    <content type="html"><![CDATA[<p>scala中下划线_的用途</p><a id="more"></a><h1 id="初始化。"><a href="#初始化。" class="headerlink" title="初始化。"></a>初始化。</h1><pre><code>object Sample { var name:String=_ def main (args: Array[String]){ name=&quot;hello world&quot;  println(name) }</code></pre><p>在这里，name也可以声明为null，例：var name:String=null。这里的下划线和null的作用是一样的。</p><h1 id="引入时"><a href="#引入时" class="headerlink" title="引入时"></a>引入时</h1><pre><code>import math._object Sample {   def main (args: Array[String]){    println(BigInt(123))   }}</code></pre><p>这里的math._就相当于Java中的math.*; 即“引用包中的所有内容”。</p><h1 id="集合中使用。（最典型，最常用）"><a href="#集合中使用。（最典型，最常用）" class="headerlink" title="集合中使用。（最典型，最常用）"></a>集合中使用。（最典型，最常用）</h1><pre><code> object Sample {   def main (args: Array[String]){    val newArry= (1 to 10).map(_*2)   println(newArry)   }}</code></pre><p>这里的下划线代表了集合中的“某（this）”一个元素。这个用法很常见，在foreach等语句中也可以使用。</p><h1 id="模式匹配。"><a href="#模式匹配。" class="headerlink" title="模式匹配。"></a>模式匹配。</h1><pre><code> object Sample {   def main (args: Array[String]){     val value=&quot;a&quot;  val result=  value match{       case &quot;a&quot; =&gt; 1       case &quot;b&quot; =&gt; 2       case _ =&gt;&quot;result&quot;     }     println(result)   }}</code></pre><p>在这里的下划线相当于“others”的意思，就像Java  switch语句中的“default”。</p><p>还有一种写法，是被Some“包”起来的，说明Some里面是有值的，而不是None。<br>    object Sample {<br>      def main (args: Array[String]){<br>        val value=Some(“a”)<br>        val result=  value match{<br>          case Some(_) =&gt; 1<br>          case _ =&gt;”result”<br>        }<br>        println(result)<br>      }</p><p>还有一种表示队列</p><pre><code>object Sample {  def main (args: Array[String]){    val value=1 to 5    val result=  value match{      case Seq(_,_*) =&gt; 1      case _ =&gt;&quot;result&quot;    }    println(result)  }}</code></pre><h1 id="函数中使用。"><a href="#函数中使用。" class="headerlink" title="函数中使用。"></a>函数中使用。</h1><pre><code>object Sample {   def main (args: Array[String]){    val set=setFunction(3.0,_:Double)     println(set(7.1))   }  def setFunction(parm1:Double,parm2:Double): Double = parm1+parm2}</code></pre><p>这是Scala特有的“偏函数”用法。</p><h1 id="元组Tuple。（如果这也算是的话）"><a href="#元组Tuple。（如果这也算是的话）" class="headerlink" title="元组Tuple。（如果这也算是的话）"></a>元组Tuple。（如果这也算是的话）</h1><pre><code>object Sample {   def main (args: Array[String])={     val value=(1,2)     print(value._1)   }}</code></pre><h1 id="传参。"><a href="#传参。" class="headerlink" title="传参。"></a>传参。</h1><pre><code>object Sample {   def main (args: Array[String])={    val result=sum(1 to 5:_*)     println(result)   }  def sum(parms:Int*)={    var result=0    for(parm &lt;- parms)result+=parm    result  }}</code></pre><p>当函数接收的参数不定长的时候，假如你想输入一个队列，可以在一个队列后加入“:_*”，因此，这里的“1 to 5”也可以改写为：“Seq(1,2,3,4,5)”。这算是一个小的用法吧</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://blog.csdn.net/i6448038/article/details/50017427" target="_blank" rel="noopener">https://blog.csdn.net/i6448038/article/details/50017427</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;scala中下划线_的用途&lt;/p&gt;
    
    </summary>
    
      <category term="2019年12月" scheme="http://yoursite.com/categories/2019%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记XII</title>
    <link href="http://yoursite.com/2019/12/24/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0XII/"/>
    <id>http://yoursite.com/2019/12/24/Java学习笔记XII/</id>
    <published>2019-12-24T03:21:12.000Z</published>
    <updated>2019-12-25T08:52:45.588Z</updated>
    
    <content type="html"><![CDATA[<p>使用Java批量转换文件夹中的文件编码格式，删除文件中的代码</p><a id="more"></a><p>用Java将某个文件夹中UTF-8格式的文件批量转换为GBK格式的文件，代码如下：</p><p>   private static String sourcePath = “/Users/liyiye/Documents/课程代码”;// 文件夹源路径<br>   private static String destPath = “/Users/liyiye/Documents/ANSI格式课程代码”;<br>   private static void utf8ToANSI(){<br>       try {<br>           File sourceDirectory = new File(sourcePath);<br>           File destDirectory = new File(destPath);<br>           if (!sourceDirectory.isDirectory()) {<br>               return;<br>           }<br>           // 获取文件夹中的所有.cpp文件，包括所有子级文件夹中的文件<br>           Collection<file> files = FileUtils.listFiles(sourceDirectory, new String[] { “cpp”, “CPP” }, true);<br>           for (File file : files) {<br>               String absolutePath = file.getAbsolutePath();<br>               String newDir = absolutePath.replace(sourceDirectory.getName(), destDirectory.getName());<br>               // 把单个文件从utf-8编码转化到gbk编码，生成新文件，可以自动创建父级目录<br>               FileUtils.writeLines(new File(newDir), “GBK”, FileUtils.readLines(file, “UTF-8”));<br>           }<br>           // 删除源目录,子文件都删除<br>           // FileUtils.deleteQuietly(sourceDirectory);<br>           // 把生成文件目录重命名成源目录名<br>           destDirectory.renameTo(new File(sourceDirectory.getAbsolutePath()));<br>           System.out.println(“success”);<br>       } catch (IOException e) {<br>           e.printStackTrace();<br>       }<br>   }</file></p><p>批量删除代码中的注释</p><pre><code>private static int count = 0;/** * 删除文件中的各种注释，包含//、/* * /等 * * @param charset *            文件编码 * @param file *            文件 */public static void clearComment(File file, String charset) {    try {        // 递归处理文件夹        if (!file.exists()) {            return;        }        if (file.isDirectory()) {            File[] files = file.listFiles();            for (File f : files) {                clearComment(f, charset); // 递归调用            }            return;        } else if (!file.getName().endsWith(&quot;.cpp&quot;)) {            // 非java文件直接返回            return;        }        System.out.println(&quot;-----开始处理文件：&quot; + file.getAbsolutePath());        // 根据对应的编码格式读取        BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(file), charset));        StringBuffer content = new StringBuffer();        String tmp = null;        while ((tmp = reader.readLine()) != null) {            content.append(tmp);            content.append(&quot;\n&quot;);        }        reader.close();        String target = content.toString();        // String s =        // target.replaceAll(&quot;\\/\\/[^\\n]*|\\/\\*([^\\*^\\/]*|[\\*^\\/*]*|[^\\**\\/]*)*\\*\\/&quot;,        // &quot;&quot;); //本段正则摘自网上，有一种情况无法满足（/* ...**/），略作修改        String s = target.replaceAll(&quot;\\/\\/[^\\n]*|\\/\\*([^\\*^\\/]*|[\\*^\\/*]*|[^\\**\\/]*)*\\*+\\/&quot;, &quot;&quot;);        // System.out.println(s);        // 使用对应的编码格式输出        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), charset));        out.write(s);        out.flush();        out.close();        count++;        System.out.println(&quot;-----文件处理完成---&quot; + count);    } catch (Exception e) {        e.printStackTrace();    }}public static void clearComment(String filePath, String charset) {    clearComment(new File(filePath), charset);}public static void clearComment(String filePath) {    clearComment(new File(filePath), &quot;GBK&quot;);}public static void clearComment(File file) {    clearComment(file, &quot;GBK&quot;);}public  static   void  main(String[] args){    clearComment(destPath);}</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="https://blog.csdn.net/qq1032355091/article/details/51803496" target="_blank" rel="noopener">https://blog.csdn.net/qq1032355091/article/details/51803496</a><br>【2】<a href="https://www.cnblogs.com/hfultrastrong/p/7689630.html" target="_blank" rel="noopener">https://www.cnblogs.com/hfultrastrong/p/7689630.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Java批量转换文件夹中的文件编码格式，删除文件中的代码&lt;/p&gt;
    
    </summary>
    
      <category term="2019年12月" scheme="http://yoursite.com/categories/2019%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Scala学习笔记IV</title>
    <link href="http://yoursite.com/2019/12/23/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0IV/"/>
    <id>http://yoursite.com/2019/12/23/Scala学习笔记IV/</id>
    <published>2019-12-23T10:08:12.000Z</published>
    <updated>2019-12-23T10:19:25.471Z</updated>
    
    <content type="html"><![CDATA[<p>数据库连接和事务处理</p><a id="more"></a><h1 id="Session-管理"><a href="#Session-管理" class="headerlink" title="Session 管理"></a>Session 管理</h1><p>现在有了一个数据库对象可以打开一个数据库（Slick 函数库封装了一个 Session 对象）</p><p>Database 的 withSession 方法，创建一个 Session 对象，它可以传递给一个函数，函数返回时自动关闭这个 Session 对象，如果你使用连接池，关闭 Session 对象，自动将连接退回连接池。</p><pre><code>val query = for (c &lt;- coffees) yield c.nameval result = db.withSession {    session =&gt;    query.list()( session )}</code></pre><p>可以看到，我们可以在 withSession 之外定义查询，只有在实际执行查询时才需要一个 Session 对象，要注意的是 Session 的缺省模式为自动提交（auto-commit )模式。每个数据库指令（比如 insert )都自动提交给数据库。 如果需要将几个指令作为一个整体，那么就需要使用事务处理（Transaction） 上面的例子，我们在执行查询时，明确指明了 session 对象，你可以使用隐含对象来避免这种情况，比如：</p><pre><code>val query = for (c &lt;- coffees) yield c.nameval result = db.withSession {    implicit session =&gt;    query.list // &lt;- takes session implicitly}// query.list // &lt;- would not compile, no implicit value of type Session</code></pre><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="http://wiki.jikexueyuan.com/project/slick-guide/database-and-transaction-processing.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/slick-guide/database-and-transaction-processing.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据库连接和事务处理&lt;/p&gt;
    
    </summary>
    
      <category term="2019年12月" scheme="http://yoursite.com/categories/2019%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记XI</title>
    <link href="http://yoursite.com/2019/12/23/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0XI/"/>
    <id>http://yoursite.com/2019/12/23/Java学习笔记XI/</id>
    <published>2019-12-23T07:41:12.000Z</published>
    <updated>2019-12-23T08:22:59.724Z</updated>
    
    <content type="html"><![CDATA[<p>Java中静态方法和实例方法的异同</p><a id="more"></a><h1 id="类方法（静态方法）："><a href="#类方法（静态方法）：" class="headerlink" title="类方法（静态方法）："></a>类方法（静态方法）：</h1><p>用static修饰的方法，也称为静态方法，类方法属类本身的方法，不属于类的某一个实例（对象）。类方法中不可直接使用实例变量。其调用方式有三种：可直接调用、类名.方法名、对象名.方法名。</p><p>类方法体有如下限制：</p><p>1.类方法中不能引用对象变量；</p><p>2.类方法中不能调用类的对象方法；</p><p>3.在类方法中不能调使用super，this关键字；</p><p>4.类方法不能被覆盖。</p><h1 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h1><p>指的是不用static关键字修饰的方法。每个实例对象都有自身的实例方法，互相独立，不共享一个。其调用方式只能是对象名.方法名。</p><p>用修饰符static声明的方法为静态方法，不用修饰符static声明的方法为实例方法。</p><p>不管类生成或未生成对象，类的静态方法都可以被使用，使用格式为：类名.静态方法名。静态方法只能使用该静态方法所在类的静态数据成员和静态方法。这是因为使用静态方法时，该静态方法所在类可能还没有对象，即使有对象，由于用类名.静态方法名方式调用静态方法，静态方法没有this指针来存放对象的地址，无法判定应访问哪个对象的数据成员。在类创建对象后，实例方法才能被使用，使用格式为：对象名.实例方法名。实例方法可以使用该方法所在类的所有静态成员和实例成员。 </p><p>1.实例方法中可以引用对象变量，也可以引用类变量；</p><p>2.实例方法中可以调用类方法；</p><p>3.对象方法中可以使用super，this关键字。</p><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>当类的字节码文件被加载到内存时，类的实例方法不会被分配入口地址，当该类创建对象后，类中的实例方法才分配入口地址，从而实例方法可以被类创建的任何对象调用执行。需要注意的是，当我们创建第一个对象时，类中的实例方法就分配了入口地址，当再创建对象时，不再分配入口地址，也就是说，方法的入口地址被所有的对象共享，当所有的对象都不存在时，方法的入口地址才被取消。</p><p>对于类中的类方法，在该类被加载到内存时，就分配了相应的入口地址。从而类方法不仅可以被类创建的任何对象调用执行，也可以直接通过类名调用。类方法的入口地址直到程序退出时才被取消。</p><p>类方法在类的字节码加载到内存时就分配了入口地址。因此，Java语言允许通过类名直接调用类方法，而实例方法不能通过类名调用。在Java语言中，类中的类方法不可以操作实例变量，也不可以调用实例方法，这是因为在类创建对象之前，实例成员变量还没有分配内存，而且实例方法也没有入口地址。</p><h1 id="何时用静态方法，何时用实例方法？"><a href="#何时用静态方法，何时用实例方法？" class="headerlink" title="何时用静态方法，何时用实例方法？"></a>何时用静态方法，何时用实例方法？</h1><p>先说实例方法，当给一个类写一个方法，如果该方法需要访问某个实例的成员变量时，那么就将该方法定义成实例方法。一类的实例通常有一些成员变量，其中含有该实例的状态信息。而该方法需要改变这些状态。那么该方法需要声明成实例方法。</p><p>静态方法正好相反，它不需要访问某个实例的成员变量，它不需要去改变某个实例的状态。我们把该方法定义成静态方法。</p><h1 id="关于静态方法和实例方法的一些误区。"><a href="#关于静态方法和实例方法的一些误区。" class="headerlink" title="关于静态方法和实例方法的一些误区。"></a>关于静态方法和实例方法的一些误区。</h1><p>误区一、静态方法常驻内存，实例方法不是，所以静态方法效率高但占内存。</p><p>事实上，方法都是一样的，在加载时机和占用内存上，静态方法和实例方法是一样的，在类型第一次被使用时加载。调用的速度基本上没有差别。 </p><p>误区二、静态方法在堆上分配内存，实例方法在堆栈上。 </p><p>事实上所有的方法都不可能在堆或者堆栈上分配内存，方法作为代码是被加载到特殊的代码内存区域，这个内存区域是不可写的。 </p><p>误区三、实例方法需要先创建实例才可以调用，比较麻烦，静态方法不用，比较简单。 </p><pre><code>事实上如果一个方法与他所在类型的实例无关，那么它就应该是静态的，决不会有人把它写成实例方法。所以所有的实例方法都与实例有关，既然与实例有关，那么创建实例就是必然的步骤，没有麻烦简单一说。实际上上你可以把所有的实例方法都写成静态的，将实例作为参数传入即可。 </code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="https://blog.csdn.net/klyz1314/article/details/16845679" target="_blank" rel="noopener">https://blog.csdn.net/klyz1314/article/details/16845679</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java中静态方法和实例方法的异同&lt;/p&gt;
    
    </summary>
    
      <category term="2019年12月" scheme="http://yoursite.com/categories/2019%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Scala学习笔记III</title>
    <link href="http://yoursite.com/2019/12/23/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0III/"/>
    <id>http://yoursite.com/2019/12/23/Scala学习笔记III/</id>
    <published>2019-12-23T07:08:12.000Z</published>
    <updated>2019-12-23T09:39:43.100Z</updated>
    
    <content type="html"><![CDATA[<p>Scala学习：伴生对象中的apply方法</p><a id="more"></a><h1 id="单例对象"><a href="#单例对象" class="headerlink" title="单例对象"></a>单例对象</h1><p>Scala没有静态方法或字段，可以用object语法定义结构，对象定义了类的单个实例。<br>对象的构造器在该对象第一次使用时被调用。<br>不能提供构造器参数。<br>作为存放工具函数或常量的地方。<br>高效地共享单个不可变实例。</p><h1 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h1><p>在Scala中，可通过类和类同名的“伴生”对象来达到静态方法的目的。<br>类和它的伴生对象可以相互访问私有特性，它们必须存在于同一个源文件中</p><p>示例：</p><p>  class Account {</p><pre><code>val id = Account.newUniqueNumber()private var balance = 0.0def deposit(amount: Double): Double = {  balance += amount  balance}def nowBalance = balance;</code></pre><p>  }</p><p>  object Account {<br>    private var lastNumber = 0</p><pre><code>private def newUniqueNumber() = {  lastNumber += 1  lastNumber}</code></pre><p>  }</p><p>  object Main {<br>    def main(args: Array[String]): Unit = {<br>      val account = new Account<br>      println(account.deposit(1))<br>      println(“=” * 10)</p><pre><code>  val account1 = new Account  println(account1.id)  println(account1.deposit(10))  println(&quot;=&quot; * 10)  println(&quot;a &quot; + account.nowBalance + &quot;; b &quot; + account1.nowBalance)}</code></pre><p>  }</p><p>执行结果</p><p>  1</p><h1 id="1-0"><a href="#1-0" class="headerlink" title="  1.0"></a>  1.0</h1><p>  2</p><h1 id="10-0"><a href="#10-0" class="headerlink" title="  10.0"></a>  10.0</h1><p>  a 1.0; b 10.0</p><h1 id="apply方法"><a href="#apply方法" class="headerlink" title="apply方法"></a>apply方法</h1><p>一般在伴生对象中定义apply方法<br>常用于初始化操作或创建单例对象<br>在生成这个类的对象时，就省去了new关键字<br>在遇到Object(参数1，参数2，……，参数n)时就会自动调用apply()方法<br>    class Student private (val studentID: Int, val name: String){</p><pre><code>  override def toString: String = {    &quot;studentID &quot; + studentID + &quot; name &quot; + name  }}object Student {  private var studentID = 0  private def newSno = {    studentID += 1    studentID  }  def apply(name: String): Student = {    println(&quot;call apply method...&quot;)    new Student(newSno, name)  }}object StudentMain extends App {  // no new  val student1 = Student(&quot;YiyeLi&quot;)  println(student1.toString)  println(&quot;*&quot; * 10)  val student2 = Student(&quot;YiyeLi&quot;)  println(student2.toString)}</code></pre><p>执行结果：</p><pre><code>call apply method...studentID 1 name YiyeLi**********call apply method...studentID 2 name YiyeLi</code></pre><p>再举一个例子，一个trait可以看作是一个Java接口。我们使用一个伴生类Shape和一个伴生对象Shape，作为一个工厂。</p><pre><code>trait Shape {  def area :Double}object Shape {  private class Circle(radius: Double) extends Shape{    override val area = 3.14*radius*radius  }  private class Rectangle (height: Double, length: Double)extends Shape{    override val area = height * length  }  private class cube (x:Double,y:Double,z:Double) extends Shape{    override val area= x * y * z  }  def apply(height :Double , length :Double ) : Shape = new Rectangle(height,length)  def apply(radius :Double) : Shape = new Circle(radius)  def apply(x:Double,y:Double,z:Double): Shape = new cube(x,y,z)}object Main extends App {  val circle = Shape(2)  println(circle.area)  val rectangle = Shape(2,3)  println(rectangle.area)  val cube=Shape(3,4,5)  println(cube.area)}</code></pre><p>执行结果：</p><p>  12.56<br>  6.0<br>  60.0</p><h1 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h1><p>Scala程序必须从一个对象的main方法开始<br>有两种方法定义<br>  // 执行println语句<br>  object Main {<br>    def main(args: Array[String]): Unit = {</p><pre><code>  println(&quot;=&quot; * 10)}</code></pre><p>  }</p><p>  // 扩展App特质<br>  object Main extends App {<br>    println(“=” * 10)<br>  }</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://zhuanlan.zhihu.com/p/32834063" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32834063</a><br>【2】<a href="https://www.w3cschool.cn/scala/scala-companion-objects.html" target="_blank" rel="noopener">https://www.w3cschool.cn/scala/scala-companion-objects.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Scala学习：伴生对象中的apply方法&lt;/p&gt;
    
    </summary>
    
      <category term="2019年12月" scheme="http://yoursite.com/categories/2019%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记X</title>
    <link href="http://yoursite.com/2019/12/17/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0X/"/>
    <id>http://yoursite.com/2019/12/17/Java学习笔记X/</id>
    <published>2019-12-17T10:05:12.000Z</published>
    <updated>2019-12-19T10:25:15.159Z</updated>
    
    <content type="html"><![CDATA[<p>Java中前后端交互例如使用ajax异步传值。</p><a id="more"></a><p>AJAX（Asynchronous JavaScript and XML）意思就是用JavaScript执行异步网络请求。如果仔细观察一个Form的提交，你就会发现，一旦用户点击“Submit”按钮，表单开始提交，浏览器就会刷新页面，然后在新页面里告诉你操作是成功了还是失败了。如果不幸由于网络太慢或者其他原因，就会得到一个404页面。</p><p>这就是Web的运作原理：一次HTTP请求对应一个页面。</p><p>如果要让用户留在当前页面中，同时发出新的HTTP请求，就必须用JavaScript发送这个新请求，接收到数据后，再用JavaScript更新页面，这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断地更新。</p><p>前端代码：</p><p>  function sendMessage(tokenType){<br>     console.log(tokenType);<br>     var serverURL=”[[${serverURL}]]”;//从后端的map中获取<br>     //token服务地址<br>     var url = “/getToken”;<br>     $.ajax({<br>         type : “post”,<br>         data :{<br>         “tokenType”:tokenType<br>         },<br>         dataType:”json”,<br>         async : true,<br>         url : url,<br>         success:function(token){<br>               console.log(token)<br>               window.frames[0].postMessage(token.data,serverURL);<br>         },<br>         error: function() {<br>            alert(“获取token失败，请稍后再试！”);<br>          }<br>       });<br>后端代码：</p><pre><code>@Value(&quot;${cm.bussinessName}&quot;)//从application.yml中获取private String bussinessName;@Value(&quot;${cm.bussinessID}&quot;)private String bussinessID;@Value(&quot;${cm.sysID}&quot;)private String sysID;@Value(&quot;${cm.userName}&quot;)private String userName;@Value(&quot;${cm.serverURL}&quot;)private String serverURL;@ApiOperation(value = &quot;cm5页面接入接口&quot;)@GetMapping(&quot;/cm5&quot;)public String getCm5(ModelMap map) { String scanTargetUrl= String.format(&quot;%s/interaction/queryFile?clientId=$$$&amp;batchId=###&amp;bussinessId=%s&amp;bussTableName=%s&amp;userID=%s&amp;sysid=%s&quot;,serverURL,bussinessID,bussinessName,userName,sysID); String uploadTargetUrl=String.format(&quot;%s/interaction/operateParam?clientId=$$$&amp;batchId=###&amp;bussinessId=%s&amp;bussTableName=%s&amp;userID=longruntest&amp;sysid=%s&quot;,serverURL,bussinessID,bussinessName,sysID); map.put(&quot;scanTargetUrl&quot;,scanTargetUrl); map.put(&quot;uploadTargetUrl&quot;,uploadTargetUrl); map.put(&quot;serverURL&quot;,serverURL); return &quot;/cm5/cm5&quot;;}@PostMapping(&quot;/getToken&quot;)@ResponseBodypublic String getToken( String tokenType){    CMPlusClient cmclient = cm5UtilService.getCmPlusClient();    return cmclient.getToken(tokenType);}</code></pre><p>由于后端传递的targetUrl中的&amp;会被转义为&amp;，所以添加过滤函数</p><pre><code> function unescapeHTML(a){  a = &quot;&quot; + a;  return a.replace(/&amp;lt;/g, &quot;&lt;&quot;).replace(/&amp;gt;/g, &quot;&gt;&quot;).replace(/&amp;amp;/g, &quot;&amp;&quot;).replace(/&amp;quot;/g, &apos;&quot;&apos;).replace(/&amp;apos;/g, &quot;&apos;&quot;);}</code></pre><p>前端页面cm5.html中要注意js脚本的路径是否存在：<br>    <script src="static/js/jquery-1.11.1.min.js" type="text/javascript"></script></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="https://my.oschina.net/smfx1314/blog/3053056" target="_blank" rel="noopener">https://my.oschina.net/smfx1314/blog/3053056</a><br>【2】<a href="https://www.jianshu.com/p/35020e29206c" target="_blank" rel="noopener">https://www.jianshu.com/p/35020e29206c</a><br>【3】<a href="http://xbhong.top/2018/02/28/ajax/" target="_blank" rel="noopener">http://xbhong.top/2018/02/28/ajax/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java中前后端交互例如使用ajax异步传值。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年12月" scheme="http://yoursite.com/categories/2019%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>数据库学习笔记VI</title>
    <link href="http://yoursite.com/2019/11/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0VI/"/>
    <id>http://yoursite.com/2019/11/05/数据库学习笔记VI/</id>
    <published>2019-11-05T03:54:12.000Z</published>
    <updated>2019-12-26T11:00:23.385Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL优化及常用函数</p><a id="more"></a><h1 id="SQL-CONCAT-函数"><a href="#SQL-CONCAT-函数" class="headerlink" title="SQL CONCAT 函数"></a>SQL CONCAT 函数</h1><p>CONCAT 函数用于将两个字符串连接为一个字符串，试一下下面这个例子：</p><pre><code>SQL&gt; SELECT CONCAT(&apos;FIRST &apos;, &apos;SECOND&apos;);+----------------------------+| CONCAT(&apos;FIRST &apos;, &apos;SECOND&apos;) |+----------------------------+| FIRST SECOND               |+----------------------------+1 row in set (0.00 sec)</code></pre><h1 id="case-when-then-else-end用法"><a href="#case-when-then-else-end用法" class="headerlink" title="case when then else end用法"></a>case when then else end用法</h1><pre><code>-简单case函数case sex  when &apos;1&apos; then &apos;男&apos;  when &apos;2&apos; then &apos;女’  else &apos;其他&apos; end--case搜索函数case when sex = &apos;1&apos; then &apos;男&apos;     when sex = &apos;2&apos; then &apos;女&apos;     else &apos;其他&apos; end  </code></pre><p>需要注重的问题，case函数只返回第一个符合条件的值，剩下的case部分将会被自动忽略。</p><h1 id="GROUP-BY-语句"><a href="#GROUP-BY-语句" class="headerlink" title="GROUP BY 语句"></a>GROUP BY 语句</h1><p>GROUP BY 语句用于结合合计函数，根据一个或多个列对结果集进行分组。</p><p>实例<br>我们拥有下面这个 “Orders” 表：</p><pre><code>O_Id    OrderDate    OrderPrice    Customer1    2008/12/29    1000    Bush2    2008/11/23    1600    Carter3    2008/10/05    700    Bush4    2008/09/28    300    Bush5    2008/08/06    2000    Adams6    2008/07/21    100    Carter</code></pre><p>现在，我们希望查找每个客户的总金额（总订单）。</p><p>我们想要使用 GROUP BY 语句对客户进行组合。</p><p>我们使用下列 SQL 语句：</p><pre><code>SELECT Customer,SUM(OrderPrice) FROM OrdersGROUP BY Customer</code></pre><p>结果集类似这样：</p><pre><code>Customer    SUM(OrderPrice)Bush    2000Carter    1700Adams    2000</code></pre><p>#参考资料<br>【1】 <a href="https://tech.meituan.com/2014/06/30/mysql-index.html" target="_blank" rel="noopener">https://tech.meituan.com/2014/06/30/mysql-index.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL优化及常用函数&lt;/p&gt;
    
    </summary>
    
      <category term="2019年11月" scheme="http://yoursite.com/categories/2019%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>设计模式学习笔记II</title>
    <link href="http://yoursite.com/2019/11/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0II/"/>
    <id>http://yoursite.com/2019/11/05/设计模式学习笔记II/</id>
    <published>2019-11-05T03:12:12.000Z</published>
    <updated>2019-11-05T03:51:23.215Z</updated>
    
    <content type="html"><![CDATA[<p>工厂模式</p><a id="more"></a><p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p><p>介绍<br>意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p><p>主要解决：主要解决接口选择的问题。</p><p>何时使用：我们明确地计划不同条件下创建不同实例时。</p><p>如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。</p><p>关键代码：创建过程在其子类执行。</p><p>应用实例： 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。</p><p>优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。</p><p>缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</p><p>使用场景： 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。</p><p>注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</p><p>实现<br>我们将创建一个 Shape 接口和实现 Shape 接口的实体类。下一步是定义工厂类 ShapeFactory。</p><p>FactoryPatternDemo，我们的演示类使用 ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。</p><p>步骤 1<br>创建一个接口:</p><p>Shape.java</p><pre><code>public interface Shape {   void draw();}</code></pre><p>步骤 2<br>创建实现接口的实体类。</p><p>Rectangle.java</p><pre><code>public class Rectangle implements Shape {   @Override   public void draw() {      System.out.println(&quot;Inside Rectangle::draw() method.&quot;);   }}Square.javapublic class Square implements Shape {   @Override   public void draw() {      System.out.println(&quot;Inside Square::draw() method.&quot;);   }}Circle.javapublic class Circle implements Shape {   @Override   public void draw() {      System.out.println(&quot;Inside Circle::draw() method.&quot;);   }}</code></pre><p>步骤 3<br>创建一个工厂，生成基于给定信息的实体类的对象。</p><p>ShapeFactory.java</p><pre><code>public class ShapeFactory {   //使用 getShape 方法获取形状类型的对象   public Shape getShape(String shapeType){      if(shapeType == null){         return null;      }              if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;)){         return new Circle();      } else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;)){         return new Rectangle();      } else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;)){         return new Square();      }      return null;   }}</code></pre><p>步骤 4<br>使用该工厂，通过传递类型信息来获取实体类的对象。</p><p>FactoryPatternDemo.java</p><pre><code>public class FactoryPatternDemo {   public static void main(String[] args) {      ShapeFactory shapeFactory = new ShapeFactory();      //获取 Circle 的对象，并调用它的 draw 方法      Shape shape1 = shapeFactory.getShape(&quot;CIRCLE&quot;);      //调用 Circle 的 draw 方法      shape1.draw();      //获取 Rectangle 的对象，并调用它的 draw 方法      Shape shape2 = shapeFactory.getShape(&quot;RECTANGLE&quot;);      //调用 Rectangle 的 draw 方法      shape2.draw();      //获取 Square 的对象，并调用它的 draw 方法      Shape shape3 = shapeFactory.getShape(&quot;SQUARE&quot;);      //调用 Square 的 draw 方法      shape3.draw();   }}</code></pre><p>步骤 5<br>执行程序，输出结果：</p><pre><code>Inside Circle::draw() method.Inside Rectangle::draw() method.Inside Square::draw() method.</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】 <a href="https://www.runoob.com/design-pattern/factory-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/factory-pattern.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工厂模式&lt;/p&gt;
    
    </summary>
    
      <category term="2019年11月" scheme="http://yoursite.com/categories/2019%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Design Pattern，Java" scheme="http://yoursite.com/tags/Design-Pattern%EF%BC%8CJava/"/>
    
  </entry>
  
  <entry>
    <title>设计模式学习笔记I</title>
    <link href="http://yoursite.com/2019/10/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0I/"/>
    <id>http://yoursite.com/2019/10/17/设计模式学习笔记I/</id>
    <published>2019-10-17T02:56:12.000Z</published>
    <updated>2019-10-17T03:06:59.684Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式学习笔记</p><a id="more"></a><h1 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h1><p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</p><p>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</p><p>我们通过下面的实例来演示装饰器模式的用法。其中，我们将把一个形状装饰上不同的颜色，同时又不改变形状类。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>意图：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p><p>主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。</p><p>何时使用：在不想增加很多子类的情况下扩展类。</p><p>如何解决：将具体功能职责划分，同时继承装饰者模式。</p><p>关键代码： 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。</p><p>应用实例： 1、孙悟空有 72 变，当他变成”庙宇”后，他的根本还是一只猴子，但是他又有了庙宇的功能。 2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。</p><p>优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p><p>缺点：多层装饰比较复杂。</p><p>使用场景： 1、扩展一个类的功能。 2、动态增加功能，动态撤销。</p><p>注意事项：可代替继承。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>我们将创建一个 Shape 接口和实现了 Shape 接口的实体类。然后我们创建一个实现了 Shape 接口的抽象装饰类 ShapeDecorator，并把 Shape 对象作为它的实例变量。</p><p>RedShapeDecorator 是实现了 ShapeDecorator 的实体类。</p><p>DecoratorPatternDemo，我们的演示类使用 RedShapeDecorator 来装饰 Shape 对象。<br><a href="https://www.runoob.com/wp-content/uploads/2014/08/decorator_pattern_uml_diagram.jpg" target="_blank" rel="noopener">https://www.runoob.com/wp-content/uploads/2014/08/decorator_pattern_uml_diagram.jpg</a></p><h2 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h2><p>创建一个接口：</p><p>Shape.java</p><pre><code>public interface Shape {   void draw();}</code></pre><h2 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h2><p>创建实现接口的实体类。</p><p>Rectangle.java</p><pre><code>public class Rectangle implements Shape {   @Override   public void draw() {      System.out.println(&quot;Shape: Rectangle&quot;);   }}</code></pre><p>Circle.java</p><pre><code>public class Circle implements Shape {   @Override   public void draw() {      System.out.println(&quot;Shape: Circle&quot;);   }}</code></pre><h2 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a>步骤 3</h2><p>创建实现了 Shape 接口的抽象装饰类。</p><p>ShapeDecorator.java</p><pre><code>public abstract class ShapeDecorator implements Shape {   protected Shape decoratedShape;   public ShapeDecorator(Shape decoratedShape){      this.decoratedShape = decoratedShape;   }   public void draw(){      decoratedShape.draw();   }  }</code></pre><h2 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤 4"></a>步骤 4</h2><p>创建扩展了 ShapeDecorator 类的实体装饰类。</p><p>RedShapeDecorator.java</p><pre><code>public class RedShapeDecorator extends ShapeDecorator {   public RedShapeDecorator(Shape decoratedShape) {      super(decoratedShape);        }   @Override   public void draw() {      decoratedShape.draw();               setRedBorder(decoratedShape);   }   private void setRedBorder(Shape decoratedShape){      System.out.println(&quot;Border Color: Red&quot;);   }}</code></pre><h2 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤 5"></a>步骤 5</h2><p>使用 RedShapeDecorator 来装饰 Shape 对象。</p><p>DecoratorPatternDemo.java</p><pre><code>public class DecoratorPatternDemo {   public static void main(String[] args) {      Shape circle = new Circle();      ShapeDecorator redCircle = new RedShapeDecorator(new Circle());      ShapeDecorator redRectangle = new RedShapeDecorator(new Rectangle());      //Shape redCircle = new RedShapeDecorator(new Circle());      //Shape redRectangle = new RedShapeDecorator(new Rectangle());      System.out.println(&quot;Circle with normal border&quot;);      circle.draw();      System.out.println(&quot;\nCircle of red border&quot;);      redCircle.draw();      System.out.println(&quot;\nRectangle of red border&quot;);      redRectangle.draw();   }}</code></pre><h2 id="步骤-6"><a href="#步骤-6" class="headerlink" title="步骤 6"></a>步骤 6</h2><p>执行程序，输出结果：</p><pre><code>Circle with normal borderShape: CircleCircle of red borderShape: CircleBorder Color: RedRectangle of red borderShape: RectangleBorder Color: Red</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】 <a href="https://www.runoob.com/design-pattern/decorator-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/decorator-pattern.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计模式学习笔记&lt;/p&gt;
    
    </summary>
    
      <category term="2019年10月" scheme="http://yoursite.com/categories/2019%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Design Pattern，Java" scheme="http://yoursite.com/tags/Design-Pattern%EF%BC%8CJava/"/>
    
  </entry>
  
  <entry>
    <title>Scala学习笔记II</title>
    <link href="http://yoursite.com/2019/09/25/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0II/"/>
    <id>http://yoursite.com/2019/09/25/Scala学习笔记II/</id>
    <published>2019-09-25T07:17:12.000Z</published>
    <updated>2019-09-27T09:36:36.534Z</updated>
    
    <content type="html"><![CDATA[<p>Scala学习：=&gt;语法糖,模式匹配</p><a id="more"></a><h1 id="Scala的“-gt-”符号简介"><a href="#Scala的“-gt-”符号简介" class="headerlink" title="Scala的“=&gt;”符号简介"></a>Scala的“=&gt;”符号简介</h1><p>Scala中的=&gt;符号可以看做是创建函数实例的语法糖。例如：A =&gt; T，A,B =&gt; T表示一个函数的输入参数类型是“A”，“A,B”，返回值类型是T。请看下面这个实例：</p><pre><code>scala&gt; val f: Int =&gt; String = myInt =&gt; &quot;The value of myInt is: &quot; + myInt.toString()f: Int =&gt; String = &lt;function1&gt;scala&gt; println(f(3))The value of myInt is: 3</code></pre><p>另外，() =&gt; T表示函数输入参数为空，而A =&gt; Unit则表示函数没有返回值。</p><pre><code>object HelloScala {  def main(args: Array[String])  {    /**      * 首先定义函数d,参数类型是Int=&gt;Int的函数,返回值根据上下文推算是Int。      * 返回值: 发现没有,返回值是x(2),它调用了传入函数。结果自然就是6了。      */    def d(x: (Int) =&gt; Int) = x(2);    println(d((x: Int) =&gt; x * 3));    // 继续增加难度,设置2个值。仔细看变化,你会明白的    def c(x: (Int, Int) =&gt; Int) = x(2, 3);    println(c((x: Int, y: Int) =&gt; x * y * 3));    // 加深难度,b第一次调用返回函数(y: Int) =&gt; x + y,在一次调用返回结果。    // 相关文章参考快学scala 第十二章 高阶函数 145页    val b = (x: Int) =&gt; (y: Int) =&gt; x + y;    println(b.apply(5).apply(6));  }}</code></pre><h1 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h1><pre><code>object scala {    def main(args: Array[String]):Unit={        println(matchTest(3))    }    def matchTest(x:Int):String =x match{      case 1=&gt;&quot;one&quot;      case 2=&gt;&quot;two&quot;      case _=&gt;&quot;many&quot;    }}</code></pre><p>match 对应 Java 里的 switch，但是写在选择器表达式之后。即： 选择器 match {备选项}。</p><p>match 表达式通过以代码编写的先后次序尝试每个模式来完成计算，只要发现有一个匹配的case，剩下的case不会继续匹配。</p><p>接下来我们来看一个不同数据类型的模式匹配：</p><pre><code>object scala {    def main(args: Array[String]):Unit={      println(matchTest(&quot;two&quot;))      println(matchTest(&quot;test&quot;))      println(matchTest(1))      println(matchTest(6))    }    def matchTest(x:Any) : Any=x match {      case 1=&gt;&quot;one&quot;      case &quot;two&quot;=&gt;2      case y:Int=&gt;&quot;scala.Int&quot;      case _=&gt;&quot;many&quot;    }}</code></pre><p>输出结果为：</p><pre><code>2manyonescala.Int</code></pre><p>实例中第一个 case 对应整型数值 1，第二个 case 对应字符串值 two，第三个 case 对应类型模式，用于判断传入的值是否为整型，相比使用isInstanceOf来判断类型，使用模式匹配更好。第四个 case 表示默认的全匹配备选项，即没有找到其他匹配时的匹配项，类似 switch 中的 default。</p><h2 id="使用样例类"><a href="#使用样例类" class="headerlink" title="使用样例类"></a>使用样例类</h2><p>使用了case关键字的类定义就是就是样例类(case classes)，样例类是种特殊的类，经过优化以用于模式匹配。</p><p>以下是样例类的简单实例:</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】 <a href="https://www.orchome.com/401" target="_blank" rel="noopener">https://www.orchome.com/401</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Scala学习：=&amp;gt;语法糖,模式匹配&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记IX</title>
    <link href="http://yoursite.com/2019/09/20/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0IX/"/>
    <id>http://yoursite.com/2019/09/20/Java学习笔记IX/</id>
    <published>2019-09-20T10:32:12.000Z</published>
    <updated>2019-09-20T10:46:42.351Z</updated>
    
    <content type="html"><![CDATA[<p>Java8 中的新特性：Optional类</p><a id="more"></a><p>看到代码中出现的Optional，所以来研究一下：</p><pre><code>Optional&lt;LoanPostloanInfosEntity&gt; postloanInfo = loanPostloanInfosRepository.getByContractId(contractId);</code></pre><p>  Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</p><p>  Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</p><p>  Optional 类的引入很好的解决空指针异常。</p><h1 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h1><p>  以下是一个 java.util.Optional<t> 类的声明：</t></p><pre><code>public final class Optional&lt;T&gt;extends Object</code></pre><h1 id="Optional实例"><a href="#Optional实例" class="headerlink" title="Optional实例"></a>Optional实例</h1><pre><code>import java.util.Optional;public class Java8Tester {    public static void optionalPrac(){        Integer value1 = null;        Integer value2 = new Integer(10);        // Optional.ofNullable - 允许传递为 null 参数        Optional&lt;Integer&gt; a = Optional.ofNullable(value1);        // Optional.of - 如果传递的参数是 null，抛出异常 NullPointerException        Optional&lt;Integer&gt; b = Optional.of(value2);        System.out.println(sum(a,b));    }    public static Integer sum(Optional&lt;Integer&gt; a, Optional&lt;Integer&gt; b){        // Optional.isPresent - 判断值是否存在        System.out.println(&quot;第一个参数值存在: &quot; + a.isPresent());        System.out.println(&quot;第二个参数值存在: &quot; + b.isPresent());        // Optional.orElse - 如果值存在，返回它，否则返回默认值        Integer value1 = a.orElse(new Integer(0));        //Optional.get - 获取值，值需要存在        Integer value2 = b.get();        return value1 + value2;    }    public static void main(String args[]){        optionalPrac();}</code></pre><p>}</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<br><a href="https://www.runoob.com/java/java8-optional-class.html" target="_blank" rel="noopener">https://www.runoob.com/java/java8-optional-class.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java8 中的新特性：Optional类&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Shell学习笔记I</title>
    <link href="http://yoursite.com/2019/09/16/Shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0I/"/>
    <id>http://yoursite.com/2019/09/16/Shell学习笔记I/</id>
    <published>2019-09-16T10:51:12.000Z</published>
    <updated>2019-09-17T06:20:30.433Z</updated>
    
    <content type="html"><![CDATA[<p>Shell脚本编程，懒虫的最爱。</p><a id="more"></a><p>世界的进步是由一群聪明的懒人推动的，可惜自己不但不聪明，还很懒。每次写完博客总打着熟悉git操作的旗号手动部署，终于洗心革面决定写个脚本来自动部署。</p><pre><code>#!/bin/bashcd /Users/liyiye/yiye-project/liyiye012.github.iogit add .git commit -m &quot;github.io 自动部署&quot;git pushhexo cleanhexo ghexo d</code></pre><p>这里写下Shell脚本学习的过程。</p><h1 id="What-is-Shell-and-Shell-Script"><a href="#What-is-Shell-and-Shell-Script" class="headerlink" title="What is Shell and Shell Script"></a>What is Shell and Shell Script</h1><p>shell是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。Ken Thompson的sh是第一种Unix Shell，Windows Explorer是一个典型的图形界面Shell。</p><p>Shell脚本(Shell script)是一种电脑程序与文本文件，内容由一连串的shell命令组成，经由Unix Shell直译其内容后运作。</p><p>被当成是一种脚本语言来设计，其运作方式与直译语言相当，由Unix shell扮演命令行解释器的角色，在读取shell script之后，依序运行其中的shell命令，之后输出结果。利用Shell script可以进行系统管理，文件操作等。</p><p>业界所说的shell通常都是指shell脚本，但读者朋友要知道，shell和shell script是两个不同的概念。由于习惯的原因，简洁起见，本文出现的“shell编程”都是指shell脚本编程，不是指开发shell自身（如Windows Explorer扩展开发）</p><p>打开文本编辑器，新建一个文本文件，并命名为 test.sh。</p><p>扩展名sh代表 shell，扩展名并不影响脚本执行，见名知意就好，如果用 php 写 shell 脚本，扩展名也可以用php。</p><h2 id="第一个shell脚本-Hello-World"><a href="#第一个shell脚本-Hello-World" class="headerlink" title="第一个shell脚本 Hello World"></a>第一个shell脚本 Hello World</h2><p>在 test.sh 中输入代码：</p><pre><code>#!/bin/bashecho &quot;Hello World !&quot;  #这是一条语句</code></pre><p>第 1 行的#!是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell；后面的/bin/bash就是指明了解释器的具体位置。</p><p>第 2 行的 echo 命令用于向标准输出文件（Standard Output，stdout，一般就是指显示器）输出文本。在.sh文件中使用命令与在终端直接输入命令的效果是一样的。</p><p>第 2 行的#及其后面的内容是注释。Shell 脚本中所有以#开头的都是注释（当然以#!开头的除外）</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>运行Shell脚本有两种方法：</p><h3 id="作为可执行程序"><a href="#作为可执行程序" class="headerlink" title="作为可执行程序"></a>作为可执行程序</h3><pre><code>chmod +x test.sh./test.sh</code></pre><p>注意，一定要写成./test.sh，而不是test.sh，运行其它二进制的程序也一样，直接写test.sh，linux系统会去PATH里寻找有没有叫test.sh的，而只有/bin, /sbin, /usr/bin，/usr/sbin等在PATH里，你的当前目录通常不在PATH里，所以写成test.sh是会找不到命令的，要用./test.sh告诉系统说，就在当前目录找。</p><p>通过这种方式运行bash脚本，第一行一定要写对，好让系统查找到正确的解释器。</p><p>这里的”系统”，其实就是shell这个应用程序（想象一下Windows Explorer），但我故意写成系统，是方便理解，既然这个系统就是指shell，那么一个使用/bin/sh作为解释器的脚本是不是可以省去第一行呢？是的。</p><h3 id="作为解释器参数"><a href="#作为解释器参数" class="headerlink" title="作为解释器参数"></a>作为解释器参数</h3><p>这种运行方式是，直接运行解释器，其参数就是shell脚本的文件名，如：</p><pre><code>/bin/sh test.sh/bin/php test.php</code></pre><p>这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。</p><h2 id="stdin"><a href="#stdin" class="headerlink" title="stdin"></a>stdin</h2><pre><code>#!/bin/bashecho &quot;What is your name?&quot;read PERSONecho &quot;Hello, $PERSON&quot;</code></pre><p>第 3 行中表示从终端读取用户输入的数据，并赋值给 PERSON 变量。read 命令用来从标准输入文件（Standard Input，stdin，一般就是指键盘）读取用户输入的数据。</p><p>第 4 行表示输出变量 PERSON 的内容。注意在变量名前边要加上$，否则变量名会作为字符串的一部分处理。</p><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><pre><code>#!/bin/shcd ~mkdir shell_tutcd shell_tutfor ((i=0; i&lt;10; i++)); do    touch test_$i.txtdone</code></pre><p>示例解释</p><pre><code>第1行：指定脚本解释器，这里是用/bin/sh做解释器的第2行：切换到当前用户的home目录第3行：创建一个目录shell_tut第4行：切换到shell_tut目录第5行：循环条件，一共循环10次第6行：创建一个test_0…9.txt文件第7行：循环体结束</code></pre><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><p>定义变量时，变量名不加美元符号（$），如：</p><pre><code>your_name=&quot;qinjx&quot;</code></pre><p>注意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。</p><p>除了显式地直接赋值，还可以用语句给变量赋值，如：</p><pre><code>for file in `ls /etc`</code></pre><h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><p>使用一个定义过的变量，只要在变量名前面加美元符号即可，如：</p><pre><code>your_name=&quot;qinjx&quot;echo $your_nameecho ${your_name}</code></pre><p>变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：</p><pre><code>for skill in Ada Coffe Action Java; do    echo &quot;I am good at ${skill}Script&quot;done</code></pre><p>如果不给skill变量加花括号，写成echo “I am good at $skillScript”，解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。</p><p>推荐给所有变量加上花括号，这是个好的编程习惯。IntelliJ IDEA编写shell script时，IDE就会提示加花括号。</p><h2 id="重定义变量"><a href="#重定义变量" class="headerlink" title="重定义变量"></a>重定义变量</h2><p>已定义的变量，可以被重新定义，如：</p><pre><code>your_name=&quot;qinjx&quot;echo $your_nameyour_name=&quot;alibaba&quot;echo $your_name</code></pre><p>这样写是合法的，但注意，第二次赋值的时候不能写$your_name=”alibaba”，使用变量的时候才加美元符。</p><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>以“#”开头的行就是注释，会被解释器忽略。</p><p>##多行注释<br>sh里没有多行注释，只能每一行加一个#号。</p><p>如果在开发过程中，遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？每一行加个#符号太费力了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。</p><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>字符串是shell编程中最常用最有用的数据类型，字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟PHP类似。</p><h2 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h2><pre><code>str=&apos;this is a string&apos;</code></pre><h3 id="单引号字符串的限制："><a href="#单引号字符串的限制：" class="headerlink" title="单引号字符串的限制："></a>单引号字符串的限制：</h3><p>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的</p><p>单引号字串中不能出现单引号（对单引号使用转义符后也不行）</p><h2 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h2><pre><code>your_name=&apos;qinjx&apos;str=&quot;Hello, I know your are \&quot;$your_name\&quot;! \n&quot;</code></pre><p>双引号里可以有变量</p><p>双引号里可以出现转义字符</p><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h3><pre><code>your_name=&quot;qinjx&quot;greeting=&quot;hello, &quot;$your_name&quot; !&quot;greeting_1=&quot;hello, ${your_name} !&quot;echo $greeting $greeting_1</code></pre><h3 id="获取字符串长度："><a href="#获取字符串长度：" class="headerlink" title="获取字符串长度："></a>获取字符串长度：</h3><pre><code>string=&quot;abcd&quot;echo ${#string} #输出：4</code></pre><h3 id="提取子字符串"><a href="#提取子字符串" class="headerlink" title="提取子字符串"></a>提取子字符串</h3><pre><code>string=&quot;alibaba is a great company&quot;echo ${string:1:4} #输出：liba</code></pre><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><h1 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h1><h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><p>和Java、PHP等语言不一样，sh的流程控制不可为空，如：</p><pre><code>&lt;?phpif (isset($_GET[&quot;q&quot;])) {    search(q);}else {    //do nothing}</code></pre><p>在sh/bash里可不能这么写，如果else分支没有语句执行，就不要写这个else。</p><p>还要注意，sh里的if [ $foo -eq 0 ]，这个方括号跟Java/PHP里if后面的圆括号大不相同，它是一个可执行程序（和ls, grep一样），想不到吧？在CentOS上，它在/usr/bin目录下：</p><pre><code>ll /usr/bin/[-rwxr-xr-x. 1 root root 33408 6月  22 2012 /usr/bin/[</code></pre><p>正因为方括号在这里是一个可执行程序，方括号后面必须加空格，不能写成if [$foo -eq 0]</p><h2 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><pre><code>if conditionthen    command1    command2    ...    commandNfi</code></pre><p>写成一行（适用于终端命令提示符）：</p><pre><code>if `ps -ef | grep ssh`;  then echo hello; fi</code></pre><p>末尾的fi就是if倒过来拼写，后面还会遇到类似的</p><h3 id="if-else-1"><a href="#if-else-1" class="headerlink" title="if else"></a>if else</h3><pre><code>if conditionthen    command1    command2    ...    commandNelse    commandfi</code></pre><h3 id="if-else-if-else"><a href="#if-else-if-else" class="headerlink" title="if else-if else"></a>if else-if else</h3><pre><code>if condition1then    command1elif condition2    command2else    commandNfi</code></pre><h2 id="for-while"><a href="#for-while" class="headerlink" title="for while"></a>for while</h2><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>在开篇的示例里演示过了：</p><pre><code>for var in item1 item2 ... itemNdo    command1    command2    ...    commandNdone</code></pre><p>写成一行：</p><pre><code>for var in item1 item2 ... itemN; do command1; command2… done;</code></pre><h3 id="C风格的for"><a href="#C风格的for" class="headerlink" title="C风格的for"></a>C风格的for</h3><pre><code>for (( EXP1; EXP2; EXP3 ))do    command1    command2    command3done</code></pre><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><pre><code>while conditiondo    commanddone</code></pre><h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h3><pre><code>while :do    commanddone</code></pre><p>或者</p><pre><code>while truedo    commanddone</code></pre><p>或者</p><pre><code>for (( ; ; ))</code></pre><h3 id="until"><a href="#until" class="headerlink" title="until"></a>until</h3><pre><code>until conditiondo    commanddone</code></pre><h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><pre><code>case &quot;${opt}&quot; in    &quot;Install-Puppet-Server&quot; )        install_master $1        exit    ;;    &quot;Install-Puppet-Client&quot; )        install_client $1        exit    ;;    &quot;Config-Puppet-Server&quot; )        config_puppet_master        exit    ;;    &quot;Config-Puppet-Client&quot; )        config_puppet_client        exit    ;;    &quot;Exit&quot; )        exit    ;;    * ) echo &quot;Bad option, please choose again&quot;esac</code></pre><p>case的语法和C family语言差别很大，它需要一个esac（就是case反过来）作为结束标记，每个case分支用右圆括号，用两个分号表示break</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><p>可以使用source和.关键字，如：</p><pre><code>source ./function.sh. ./function.sh</code></pre><p>在bash里，source和.是等效的，他们都是读入function.sh的内容并执行其内容（类似PHP里的include），为了更好的可移植性，推荐使用第二种写法。</p><p>包含一个文件和执行一个文件一样，也要写这个文件的路径，不能光写文件名，比如上述例子中:</p><p>  . ./function.sh<br>不可以写作：</p><p>  . function.sh<br>如果function.sh是用户传入的参数，如何获得它的绝对路径呢？方法是：</p><pre><code>real_path=`readlink -f $1`#$1是用户输入的参数，如function.sh. $real_path</code></pre><h1 id="用户输入"><a href="#用户输入" class="headerlink" title="用户输入"></a>用户输入</h1><h2 id="执行脚本时传入"><a href="#执行脚本时传入" class="headerlink" title="执行脚本时传入"></a>执行脚本时传入</h2><h2 id="脚本运行中输入"><a href="#脚本运行中输入" class="headerlink" title="脚本运行中输入"></a>脚本运行中输入</h2><h2 id="select菜单"><a href="#select菜单" class="headerlink" title="select菜单"></a>select菜单</h2><h2 id="stdin和stdout"><a href="#stdin和stdout" class="headerlink" title="stdin和stdout"></a>stdin和stdout</h2><h1 id="常用的命令"><a href="#常用的命令" class="headerlink" title="常用的命令"></a>常用的命令</h1><p>sh脚本结合系统命令便有了强大的威力，在字符处理领域，有grep、awk、sed三剑客，grep负责找出特定的行，awk能将行拆分成多个字段，sed则可以实现更新插入删除等写操作。</p><h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p>查看进程列表</p><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>排除grep自身<br>查找与target相邻的结果</p><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><h2 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h2><h1 id="脚本解释器"><a href="#脚本解释器" class="headerlink" title="脚本解释器"></a>脚本解释器</h1><h2 id="sh"><a href="#sh" class="headerlink" title="sh"></a>sh</h2><p>即Bourne shell，POSIX（Portable Operating System Interface）标准的shell解释器，它的二进制文件路径通常是/bin/sh，由Bell Labs开发。</p><p>下面讲的是sh，如果使用其它语言用作shell编程，请参考相应语言的文档。</p><h2 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h2><p>Bash是Bourne shell的替代品，属GNU Project，二进制文件路径通常是/bin/bash。业界通常混用bash、sh、和shell，比如你会经常在招聘运维工程师的文案中见到：熟悉Linux Bash编程，精通Shell编程。</p><p>在CentOS里，/bin/sh是一个指向/bin/bash的符号链接:</p><pre><code>[root@centosraw ~]# ls -l /bin/*sh-rwxr-xr-x. 1 root root 903272 Feb 22 05:09 /bin/bash-rwxr-xr-x. 1 root root 106216 Oct 17  2012 /bin/dashlrwxrwxrwx. 1 root root      4 Mar 22 10:22 /bin/sh -&gt; bash</code></pre><p>但在Mac OS上不是，/bin/sh和/bin/bash是两个不同的文件，尽管它们的大小只相差100字节左右:</p><pre><code>iMac:~ wuxiao$ ls -l /bin/*sh-r-xr-xr-x  1 root  wheel  1371648  6 Nov 16:52 /bin/bash-rwxr-xr-x  2 root  wheel   772992  6 Nov 16:52 /bin/csh-r-xr-xr-x  1 root  wheel  2180736  6 Nov 16:52 /bin/ksh-r-xr-xr-x  1 root  wheel  1371712  6 Nov 16:52 /bin/sh-rwxr-xr-x  2 root  wheel   772992  6 Nov 16:52 /bin/tcsh-rwxr-xr-x  1 root  wheel  1103984  6 Nov 16:52 /bin/zsh</code></pre><h1 id="高级编程语言"><a href="#高级编程语言" class="headerlink" title="高级编程语言"></a>高级编程语言</h1><p>理论上讲，只要一门语言提供了解释器（而不仅是编译器），这门语言就可以胜任脚本编程，常见的解释型语言都是可以用作脚本编程的，如：Perl、Tcl、Python、PHP、Ruby。Perl是最老牌的脚本编程语言了，Python这些年也成了一些linux发行版的预置解释器。</p><p>编译型语言，只要有解释器，也可以用作脚本编程，如C shell是内置的（/bin/csh），Java有第三方解释器Jshell，Ada有收费的解释器AdaScript。</p><h1 id="如何选择shell编程语言"><a href="#如何选择shell编程语言" class="headerlink" title="如何选择shell编程语言"></a>如何选择shell编程语言</h1><h2 id="熟悉-vs-陌生"><a href="#熟悉-vs-陌生" class="headerlink" title="熟悉 vs 陌生"></a>熟悉 vs 陌生</h2><p>如果你已经掌握了一门编程语言（如PHP、Python、Java、JavaScript），建议你就直接使用这门语言编写脚本程序，虽然某些地方会有点啰嗦，但你能利用在这门语言领域里的经验（单元测试、单步调试、IDE、第三方类库）。</p><p>新增的学习成本很小，只要学会怎么使用shell解释器（Jshell、AdaScript）就可以了。</p><h2 id="简单-vs-高级"><a href="#简单-vs-高级" class="headerlink" title="简单 vs 高级"></a>简单 vs 高级</h2><p>如果你觉得自己熟悉的语言（如Java、C）写shell脚本实在太啰嗦，你只是想做一些备份文件、安装软件、下载数据之类的事情，学着使用sh，bash会是一个好主意。</p><p>shell只定义了一个非常简单的编程语言，所以，如果你的脚本程序复杂度较高，或者要操作的数据结构比较复杂，那么还是应该使用Python、Perl这样的脚本语言，或者是你本来就已经很擅长的高级语言。因为sh和bash在这方面很弱，比如说：</p><p><strong><em>它的函数只能返回字串，无法返回数组</em></strong></p><p><strong><em>它不支持面向对象，你无法实现一些优雅的设计模式</em></strong></p><p><strong><em>它是解释型的，一边解释一边执行，连PHP那种预编译都不是，如果你的脚本包含错误(例如调用了不存在的函数)，只要没执行到这一行，就不会报错</em></strong></p><h2 id="环境兼容性"><a href="#环境兼容性" class="headerlink" title="环境兼容性"></a>环境兼容性</h2><p>如果你的脚本是提供给别的用户使用，使用sh或者bash，你的脚本将具有最好的环境兼容性，perl很早就是linux标配了，python这些年也成了一些linux发行版的标配，至于mac os，它默认安装了perl、python、ruby、php、java等主流编程语言。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】 <a href="https://www.runoob.com/w3cnote/shell-quick-start.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/shell-quick-start.html</a></p><p>【2】 <a href="https://github.com/qinjx/30min_guides/blob/master/shell.md" target="_blank" rel="noopener">https://github.com/qinjx/30min_guides/blob/master/shell.md</a></p><p>【3】 <a href="http://c.biancheng.net/view/735.html" target="_blank" rel="noopener">http://c.biancheng.net/view/735.html</a></p><p>【4】 <a href="http://tldp.org/LDP/abs/html/" target="_blank" rel="noopener">http://tldp.org/LDP/abs/html/</a> ，非常详细，非常易读，大量example，既可以当入门教材，也可以当做工具书查阅</p><p>【5】 <a href="http://www.tutorialspoint.com/unix/unix-shell.htm" target="_blank" rel="noopener">http://www.tutorialspoint.com/unix/unix-shell.htm</a></p><p>【6】 <a href="https://bash.cyberciti.biz/guide/Main_Page" target="_blank" rel="noopener">https://bash.cyberciti.biz/guide/Main_Page</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Shell脚本编程，懒虫的最爱。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Shell" scheme="http://yoursite.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Scala学习笔记I</title>
    <link href="http://yoursite.com/2019/09/10/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0I/"/>
    <id>http://yoursite.com/2019/09/10/Scala学习笔记I/</id>
    <published>2019-09-10T03:32:12.000Z</published>
    <updated>2019-09-25T07:17:36.347Z</updated>
    
    <content type="html"><![CDATA[<p>Scala学习：集合，柯里化，implicit关键字</p><a id="more"></a><h1 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h1><h1 id="fold-foldLeft和foldRight区别与联系"><a href="#fold-foldLeft和foldRight区别与联系" class="headerlink" title="fold,foldLeft和foldRight区别与联系"></a>fold,foldLeft和foldRight区别与联系</h1><p>从本质上说，fold函数将一种格式的输入数据转化成另外一种格式返回。</p><pre><code>def fold(){  val a=List(1,2,3,4)  val res=a.fold(0){    (z,i) =&gt; z+i  }  println(res)  //res=10}</code></pre><p>List中的fold方法需要输入两个参数：初始值以及一个函数。输入的函数也需要输入两个参数：累加值和当前item的索引。那么上面的代码片段发生了什么事？</p><p>代码开始运行的时候，初始值0作为第一个参数传进到fold函数中，list中的第一个item作为第二个参数传进fold函数中。</p><p>1、fold函数开始对传进的两个参数进行计算，在本例中，仅仅是做加法计算，然后返回计算的值；</p><p>2、Fold函数然后将上一步返回的值作为输入函数的第一个参数，并且把list中的下一个item作为第二个参数传进继续计算，同样返回计算的值；</p><p>3、第2步将重复计算，直到list中的所有元素都被遍历之后，返回最后的计算值，整个过程结束；</p><p>4、这虽然是一个简单的例子，让我们来看看一些比较有用的东西。早在后面将会介绍foldLeft函数，并解释它和fold之间的区别，目前，你只需要想象foldLeft函数和fold函数运行过程一样。</p><h1 id="Scala-函数柯里化-Currying"><a href="#Scala-函数柯里化-Currying" class="headerlink" title="Scala 函数柯里化(Currying)"></a>Scala 函数柯里化(Currying)</h1><p>柯里化(Currying)指的是将原来接受两个参数的函数变成新的接受一个参数的函数的过程。新的函数返回一个以原有第二个参数为参数的函数。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>首先我们定义一个函数:</p><pre><code>def add(x:Int,y:Int)=x+y</code></pre><p>那么我们应用的时候，应该是这样用：add(1,2)</p><p>现在我们把这个函数变一下形：</p><pre><code>def add(x:Int)(y:Int) = x + y</code></pre><p>那么我们应用的时候，应该是这样用：add(1)(2),最后结果都一样是3，这种方式（过程）就叫柯里化。</p><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>add(1)(2) 实际上是依次调用两个普通函数（非柯里化函数），第一次调用使用一个参数 x，返回一个函数类型的值，第二次使用参数y调用这个函数类型的值。</p><p>实质上最先演变成这样一个方法：</p><pre><code>def add(x:Int)=(y:Int)=&gt;x+y</code></pre><p>那么这个函数是什么意思呢？ 接收一个x为参数，返回一个匿名函数，该匿名函数的定义是：接收一个Int型参数y，函数体为x+y。现在我们来对这个方法进行调用。</p><pre><code>val result = add(1)</code></pre><p>返回一个result，那result的值应该是一个匿名函数：(y:Int)=&gt;1+y</p><p>所以为了得到结果，我们继续调用result。</p><pre><code>val sum = result(2)</code></pre><p>最后打印出来的结果就是3。</p><h1 id="Implicit详解"><a href="#Implicit详解" class="headerlink" title="Implicit详解"></a>Implicit详解</h1><p>在 Scala 中的 implicit 定义指编译器在需要修复类型匹配时可以用来自动插入的定义。比如说，如果 x+y 类型不匹配，那么编译器可能试着使用 convert(x) + y， 其中 convert 由某个 implicit 定义的，这有点类似一个整数和一个浮点数相加，编译器可以自动把整数转换为浮点数。Scala 的 implicit 定义是对这种情况的一个推广，你可以定义一个类型在需要时，如何自动转换成另外一种类型。</p><p>Scala 的 implicit 定义符合下面一些规则：</p><h2 id="标记规则"><a href="#标记规则" class="headerlink" title="标记规则"></a>标记规则</h2><p>只有哪些使用 implicit 关键字的定义才是可以使用的隐式定义。关键字 implicit 用来标记一个隐式定义。编译器才可以选择它作为隐式变化的候选项。你可以使用 implicit 来标记任意变量，函数或是对象。</p><p>例如下面为一个隐式函数定义：</p><pre><code>implicit def intToString(x:Int) : x.toString</code></pre><p>编译器只有在 convert 被标记成 implicit 才会将 x + y 改成convert(x) + y 。当然这是在 x + y 类型不匹配时。</p><h2 id="范围规则"><a href="#范围规则" class="headerlink" title="范围规则"></a>范围规则</h2><p>编译器在选择备选 implicit 定义时，只会选取当前作用域的定义，比如说编译器不会去调用 someVariable.convert。如果你需要使用 someVariable.convert，你必须把 someVarible 引入到当前作用域。也就是说编译器在选择备选 implicit 时，只有当 convert 是当前作用域下单个标志符时才会作为备选 implicit。比如说，对于一个函数库来说，在一个 Preamble 对象中定义一些常用的隐式类型转换非常常见，因此需要使用 Preamble 的代码可以使用 “import Preamble._”  把这些 implicit 定义引入到当前作用域才可以。</p><p>这个规则有一个例外，编译器也会在类的伙伴对象定义中查找所需的 implicit 定义。例如下面的定义：</p><pre><code>object Dollar {    implicit def dollarToEuro(x:Dollar):Euro = ...    ...}class Dollar {   ...}</code></pre><p>如果在 class Dollar 的方法有需要 Euro 类型，但输入数据使用的是 Dollar，编译器会在其伙伴对象 object Dollar 查找所需的隐式类型转换，本例定义一个从 Dollar 到 Euro 的 implicit 定义可以使用。</p><h2 id="一次规则"><a href="#一次规则" class="headerlink" title="一次规则"></a>一次规则</h2><p>编译器在需要使用 implicit 定义时，只会试图转换一次，也就是编译器永远不会把 x + y 改写成 convert1(convert2(x)) + y。</p><h2 id="优先规则"><a href="#优先规则" class="headerlink" title="优先规则"></a>优先规则</h2><p>编译器不会在 x+y 已经是合法的情况下去调用 implicit 规则。</p><h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><p>你可以为 implicit 定义任意的名称。通常情况下你可以任意命名，implicit 的名称只在两种情况下有用：一是你想在一个方法中明确指明，另外一个是想把那一个引入到当前作用域。比如我们定义一个对象，包含两个 implicit定义：</p><pre><code>object MyConversions {    implicit def stringWrapper(s:String):IndexedSeq[Char] = ...    implicit def intToString(x:Int):String = ...}</code></pre><p>在你的应用中，你想使用 stringWrapper 变换，而不想把整数自动转换成字符串，你可以只引入 stringWrapper。</p><pre><code>import  MyConversions.stringWrapper</code></pre><h2 id="编译器使用-implicit-的几种情况"><a href="#编译器使用-implicit-的几种情况" class="headerlink" title="编译器使用 implicit 的几种情况"></a>编译器使用 implicit 的几种情况</h2><p>有三种情况使用 implicit: 一是转换成预期的数据类型，二是转换 selection 的 receiver，三是隐含参数。转换成预期的数据类型比如你有一个方法参数类型是 IndexedSeq[Char]，在你传入 String 时，编译器发现类型不匹配，就检查当前作用域是否有从 String 到 IndexedSeq 隐式转换。</p><p>转换 selection 的 receiver 允许你适应某些方法调用，比如 “abc”.exist ，”abc”类型为 String，本身没有定义 exist 方法，这时编辑器就检查当前作用域内 String 的隐式转换后的类型是否有 exist 方法，发现 stringWrapper 转换后成 IndexedSeq 类型后，可以有 exist 方法，这个和 C# 静态扩展方法功能类似。</p><p>隐含参数有点类似是缺省参数，如果在调用方法时没有提供某个参数，编译器会查找当前作用域是否有符合条件的 implicit 对象作为参数传入（有点类似 dependency injection)。</p><h2 id="implicit-function-隐式函数"><a href="#implicit-function-隐式函数" class="headerlink" title="implicit function 隐式函数"></a>implicit function 隐式函数</h2><h3 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h3><p>第一种implicit的用法，是将其加在function定义的前面，形式为:</p><pre><code>implicit def int2String(someInt: Int): String = {  //...}</code></pre><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>这种用法可以用来进行implicit conversion，隐式转换，也就是说，编译器可以选择在合适的时候调用这些函数来进行一个转换，来保证类型的正确性，比如我可以通过定义一个implicit的转换函数将java的类型转换为scala的类型，这样在需要scala类型但是却使用java类型作为参数的时候，编译器会自动加入这个转换函数.</p><pre><code>object HelloScala {  implicit def conv(a: Int) = {    println(&quot;in conv&quot;)    a.toString  }  def say(b: String) = println(b)  def main(args: Array[String])  {    say(5)  }}//输出结果:// in conv// 5//这说明过程是say(conv(5))//原因是编译器在检查的时候发现需要一个String类型的参数，但是代入的是一个Int，于是//他会在范围内寻找implicit的function，找到了符合这个要求的String =&gt; Int的function，于是调用</code></pre><h2 id="implicit-parameter-amp-implicit-value-隐式参数和隐式值"><a href="#implicit-parameter-amp-implicit-value-隐式参数和隐式值" class="headerlink" title="implicit parameter &amp; implicit value 隐式参数和隐式值"></a>implicit parameter &amp; implicit value 隐式参数和隐式值</h2><h3 id="形式-1"><a href="#形式-1" class="headerlink" title="形式"></a>形式</h3><h3 id="隐式参数"><a href="#隐式参数" class="headerlink" title="隐式参数"></a>隐式参数</h3><p>隐式参数是在函数中，将参数标志出implicit，形式为:</p><pre><code>def func(implicit x: Int)def func2(x: Int)(implicit y: Int)def func3(implicit x: Int, y: Int)</code></pre><p>这三种形式是有区别的，在参数中implicit只能出现一次，而在此之后，所有的参数都会变为implicit。</p><pre><code>func: x是implicit的func2: 只有y是implicit的func3: x和y都是implicit的</code></pre><p>注意避免以下几种错误写法:<br>      //以下三种情况无法编译通过<br>      def err(x: Int, implicit y: Int)<br>      def err(implicit x: Int)(implicit y: Int)<br>      def err(implicit x: Int)(y: Int)<br>这三种情况都是无法编译通过的</p><h2 id="隐式值"><a href="#隐式值" class="headerlink" title="隐式值"></a>隐式值</h2><pre><code>implicit object Testimplicit val x = 5implicit var y</code></pre><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>这种用法的作用主要是两种用法搭配起来来达到一个效果，隐式参数表明这个参数是可以缺少的，也就是说在调用的时候这个参数可以不用出现，那么这个值由什么填充呢？ 那就是用隐式的值了，以下的例子说明了这一点:<br>    object HelloScala {<br>      abstract class Sayable{<br>        def say<br>      }<br>      implicit object hello extends Sayable{<br>        override def say()={<br>          println(“hello”)<br>        }<br>      }<br>      def func(implicit x:Sayable): Unit ={<br>        x.say<br>      }<br>      implicit val impVal=5<br>      def func1(implicit x:Int)={<br>        println(x)<br>      }<br>      def main(args: Array[String])  {<br>        func<br>        func1<br>      }<br>    }</p><p>输出结果为:</p><pre><code>im in hello5</code></pre><p>因为object的类型并不是object的名字，所以使用了一个抽象class来指明type。</p><p>在调用func的时候，没有代入参数，其参数是由编译器检查之后决定的，而这里决定的就是唯一的可能，hello那个object，所以这里的say调用的就是hello object里的say</p><p>在调用func1的时候，同样没有代入参数，需要一个Int作为参数，编译器寻找值的时候寻找到impVal是implicit的值，所以这里选择impVal作为他的值，输出了5</p><h2 id="implicit-class-隐式类"><a href="#implicit-class-隐式类" class="headerlink" title="implicit class 隐式类"></a>implicit class 隐式类</h2><p>这是一个在scala 2.10中新增的用法</p><h3 id="形式-2"><a href="#形式-2" class="headerlink" title="形式"></a>形式</h3><pre><code>implicit class MyClass(x: Int)</code></pre><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><p>这里的作用主要是其主构造函数可以作为隐式转换的参数，相当于其主构造函数可以用来当做一个implicit的function，下面举例说明一下:</p><pre><code>object HelloScala {  implicit class MyName(x: Int) {    println(&quot;im in cons&quot;)    val y = x  }  def say(x: MyName) = {    println(x.y)  }  def main(args: Array[String])  {    say(5)  }}</code></pre><p>输出结果:</p><pre><code>im in cons5</code></pre><p>这里的MyName是一个隐式类，其主构造函数可以用作隐式转换，所以say需要一个MyName类型的参数，但是调用的时候给的是一个Int，这里就会调用MyName的主构造函数转换为一个MyName的对象，然后再println其y的值</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】 <a href="https://www.iteblog.com/archives/1228.html" target="_blank" rel="noopener">https://www.iteblog.com/archives/1228.html</a><br>【2】 <a href="https://www.runoob.com/scala/currying-functions.html" target="_blank" rel="noopener">https://www.runoob.com/scala/currying-functions.html</a><br>【3】 <a href="https://blog.csdn.net/qq_29343201/article/details/58588470" target="_blank" rel="noopener">https://blog.csdn.net/qq_29343201/article/details/58588470</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Scala学习：集合，柯里化，implicit关键字&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记VIII</title>
    <link href="http://yoursite.com/2019/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0VIII/"/>
    <id>http://yoursite.com/2019/09/06/Java学习笔记VIII/</id>
    <published>2019-09-06T10:43:12.000Z</published>
    <updated>2019-09-16T09:04:07.370Z</updated>
    
    <content type="html"><![CDATA[<p>使用Quzrtz 及Cron定时表达式语法解析</p><a id="more"></a><h1 id="Cron表达式范例："><a href="#Cron表达式范例：" class="headerlink" title="Cron表达式范例："></a>Cron表达式范例：</h1><pre><code>*/10 * * * * ?  每隔10秒执行一次0 */1 * * * ?  每隔1分钟执行一次0 0 23 * * ?  每天23点执行一次0 0 1 * * ?  每天凌晨1点执行一次：0 0 1 1 * ?  每月1号凌晨1点执行一次0 0 23 L * ?  每月最后一天23点执行一次0 0 1 ? * L  每周星期天凌晨1点实行一次0 26,29,33 * * * ?  在26分、29分、33分执行一次0 0 0,13,18,21 * * ? 每天的0点、13点、18点、21点都执行一次</code></pre><h1 id="Cron-表达式"><a href="#Cron-表达式" class="headerlink" title="Cron 表达式"></a>Cron 表达式</h1><p>Cron表达式由7个部分组成，各部分用空格隔开，例如0 0 12 ? * WED（每星期三下午12:00 执行）</p><p>Cron表达式的7个部分从左到右代表的含义如下</p><pre><code>Seconds Minutes Hours Day-of-Month Month Day-of-Week Year</code></pre><p>其中Year是可选的</p><h1 id="Cron表达式可选的值"><a href="#Cron表达式可选的值" class="headerlink" title="Cron表达式可选的值"></a>Cron表达式可选的值</h1><pre><code>Seconds秒：数字0－59Minutes分：数字0－59Hours时 ：数字0-23Day-of-Month月中的几号 ：可以用数字1-31 中的任一一个值，但要注意一些特别的月份Month一年中的几月：可以用0-11 或用字符串 “JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV and DEC” 表示Day-of-Week每周：数字1-7（1 ＝ 星期日），或用字符口串“SUN, MON, TUE, WED, THU, FRI and SAT”字段名                 允许的值                        允许的特殊字符  秒                    0-59                            , - * /  分                    0-59                            , - * /  小时                  0-23                            , - * /  日                    1-31                            , - * ? / L W C  月                    1-12 or JAN-DEC                 , - * /  周几                  1-7 or SUN-SAT                   , - * ? / L C #  年 (可选字段)          empty, 1970-2099                 , - * /</code></pre><h1 id="Cron中的符号"><a href="#Cron中的符号" class="headerlink" title="Cron中的符号"></a>Cron中的符号</h1><pre><code>* ：代表整个时间段./ ：表示每多长时间执行一次0/15表示每隔15分钟执行一次,“0”表示为从“0”分开始；3/20表示每隔20分钟执行一次，“3”表示从第3分钟开始执行? ：表示每月的某一天，或第几周的某一天L ：“6L”表示“每月的最后一个星期五”W：表示为最近工作日如“15W”放在每月（day-of-month）字段上表示为“到本月15日最近的工作日”#：是用来指定“的”每月第n个工作日&quot;6#3&quot;或者&quot;FRI#3&quot;:在每周（day-of-week）中表示“每月第三个星期五”问号(?)就是用来对日期和星期字段做互斥的，问号(?)的作用是指明该字段‘没有特定的值’，星号(*)和其它值，比如数字，都是给该字段指明特定的值，而星号(*)代表所有，在天时表示每一天。“?”字符：表示不确定的值“,”字符：指定数个值“-”字符：指定一个值的范围“/”字符：指定一个值的增加幅度。n/m表示从n开始，每次增加m“L”字符：用在日表示一个月中的最后一天，用在周表示该月最后一个星期X“W”字符：指定离给定日期最近的工作日(周一到周五)“#”字符：表示该月第几个周X。6#3表示该月第3个周五</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<br><a href="https://www.jianshu.com/p/f03b1497122a" target="_blank" rel="noopener">https://www.jianshu.com/p/f03b1497122a</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Quzrtz 及Cron定时表达式语法解析&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记VII</title>
    <link href="http://yoursite.com/2019/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0VII/"/>
    <id>http://yoursite.com/2019/09/06/Java学习笔记VII/</id>
    <published>2019-09-06T07:12:12.000Z</published>
    <updated>2019-09-06T07:43:28.956Z</updated>
    
    <content type="html"><![CDATA[<p>Java并发编程中synchronized的概念</p><a id="more"></a><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>synchronized 是 Java 中的关键字，是利用锁的机制来实现同步的。<br>锁机制有如下两种特性：</p><h2 id="互斥性："><a href="#互斥性：" class="headerlink" title="互斥性："></a>互斥性：</h2><p>即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程中的协调机制，这样在同一时间只有一个线程对需同步的代码块(复合操作)进行访问。互斥性我们也往往称为操作的原子性。</p><h2 id="可见性："><a href="#可见性：" class="headerlink" title="可见性："></a>可见性：</h2><p>必须确保在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的（即在获得锁时应获得最新共享变量的值），否则另一个线程可能是在本地缓存的某个副本上继续操作从而引起不一致。</p><h1 id="对象锁和类锁"><a href="#对象锁和类锁" class="headerlink" title="对象锁和类锁"></a>对象锁和类锁</h1><h2 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h2><p>在 Java 中，每个对象都会有一个 monitor 对象，这个对象其实就是 Java 对象的锁，通常会被称为“内置锁”或“对象锁”。类的对象可以有多个，所以每个对象有其独立的对象锁，互不干扰。</p><h2 id="类锁"><a href="#类锁" class="headerlink" title="类锁"></a>类锁</h2><p>在 Java 中，针对每个类也有一个锁，可以称为“类锁”，类锁实际上是通过对象锁实现的，即类的 Class 对象锁。每个类只有一个 Class 对象，所以每个类只有一个类锁。</p><h1 id="synchronized-的用法分类"><a href="#synchronized-的用法分类" class="headerlink" title="synchronized 的用法分类"></a>synchronized 的用法分类</h1><p>synchronized 的用法可以从两个维度上面分类：</p><h2 id="根据修饰对象分类"><a href="#根据修饰对象分类" class="headerlink" title="根据修饰对象分类"></a>根据修饰对象分类</h2><p>synchronized 可以修饰方法和代码块</p><h3 id="修饰代码块"><a href="#修饰代码块" class="headerlink" title="修饰代码块"></a>修饰代码块</h3><pre><code>synchronized(this|object) {}synchronized(类.class) {}</code></pre><h3 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h3><p>修饰非静态方法</p><p>修饰静态方法</p><h2 id="根据获取的锁分类"><a href="#根据获取的锁分类" class="headerlink" title="根据获取的锁分类"></a>根据获取的锁分类</h2><h3 id="获取对象锁"><a href="#获取对象锁" class="headerlink" title="获取对象锁"></a>获取对象锁</h3><pre><code>synchronized(this|object) {}</code></pre><p>修饰非静态方法</p><h3 id="获取类锁"><a href="#获取类锁" class="headerlink" title="获取类锁"></a>获取类锁</h3><pre><code>synchronized(类.class) {}</code></pre><p>修饰静态方法</p><h1 id="synchronized-的用法详解"><a href="#synchronized-的用法详解" class="headerlink" title="synchronized 的用法详解"></a>synchronized 的用法详解</h1><p>这里根据获取的锁分类来分析 synchronized 的用法</p><h2 id="获取对象锁-1"><a href="#获取对象锁-1" class="headerlink" title="获取对象锁"></a>获取对象锁</h2><h3 id="对于同一对象"><a href="#对于同一对象" class="headerlink" title="对于同一对象"></a>对于同一对象</h3><p>同步线程类：</p><pre><code>class SyncThread implements Runnable {    @Override    public void run() {        String threadName = Thread.currentThread().getName();        if (threadName.startsWith(&quot;A&quot;)) {            async();        } else if (threadName.startsWith(&quot;B&quot;)) {            sync1();        } else if (threadName.startsWith(&quot;C&quot;)) {            sync2();        }    }    /**     * 异步方法     */    private void async() {        try {            System.out.println(Thread.currentThread().getName() + &quot;_Async_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            Thread.sleep(2000);            System.out.println(Thread.currentThread().getName() + &quot;_Async_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));        } catch (InterruptedException e) {            e.printStackTrace();        }    }    /**     * 方法中有 synchronized(this|object) {} 同步代码块     */    private void sync1() {        System.out.println(Thread.currentThread().getName() + &quot;_Sync1: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));        synchronized (this) {            try {                System.out.println(Thread.currentThread().getName() + &quot;_Sync1_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));                Thread.sleep(2000);                System.out.println(Thread.currentThread().getName() + &quot;_Sync1_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }    /**     * synchronized 修饰非静态方法     */    private synchronized void sync2() {        System.out.println(Thread.currentThread().getName() + &quot;_Sync2: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));        try {            System.out.println(Thread.currentThread().getName() + &quot;_Sync2_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            Thread.sleep(2000);            System.out.println(Thread.currentThread().getName() + &quot;_Sync2_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><p>测试代码：</p><pre><code>public class SyncTest {    public static void main(String... args) {        SyncThread syncThread = new SyncThread();        Thread A_thread1 = new Thread(syncThread, &quot;A_thread1&quot;);        Thread A_thread2 = new Thread(syncThread, &quot;A_thread2&quot;);        Thread B_thread1 = new Thread(syncThread, &quot;B_thread1&quot;);        Thread B_thread2 = new Thread(syncThread, &quot;B_thread2&quot;);        Thread C_thread1 = new Thread(syncThread, &quot;C_thread1&quot;);        Thread C_thread2 = new Thread(syncThread, &quot;C_thread2&quot;);        A_thread1.start();        A_thread2.start();        B_thread1.start();        B_thread2.start();        C_thread1.start();        C_thread2.start();    }}</code></pre><p>运行结果：</p><pre><code>B_thread2_Sync1: 14:44:20A_thread1_Async_Start: 14:44:20B_thread1_Sync1: 14:44:20C_thread1_Sync2: 14:44:20A_thread2_Async_Start: 14:44:20C_thread1_Sync2_Start: 14:44:20A_thread1_Async_End: 14:44:22A_thread2_Async_End: 14:44:22C_thread1_Sync2_End: 14:44:22B_thread1_Sync1_Start: 14:44:22B_thread1_Sync1_End: 14:44:24B_thread2_Sync1_Start: 14:44:24B_thread2_Sync1_End: 14:44:26C_thread2_Sync2: 14:44:26C_thread2_Sync2_Start: 14:44:26C_thread2_Sync2_End: 14:44:28</code></pre><p>结果分析：</p><p>A 类线程访问方法中没有同步代码块，A 类线程是异步的，所以有线程访问对象的同步代码块时，另外的线程可以访问该对象的非同步代码块：</p><pre><code>A_thread1_Async_Start: 14:44:20A_thread2_Async_Start: 14:44:20A_thread1_Async_End: 14:44:22A_thread2_Async_End: 14:44:22</code></pre><p>B 类线程访问的方法中有同步代码块，B 类线程是同步的，一个线程在访问对象的同步代码块，另一个访问对象的同步代码块的线程会被阻塞：</p><pre><code>B_thread1_Sync1_End: 14:44:24B_thread2_Sync1_Start: 14:44:24B_thread2_Sync1_End: 14:44:26synchronized(this|object) {} 代码块 {} 之外的代码依然是异步的：B_thread2_Sync1: 14:44:20B_thread1_Sync1: 14:44:20</code></pre><p>C 类线程访问的是 synchronized 修饰非静态方法，C 类线程是同步的，一个线程在访问对象的同步代方法，另一个访问对象同步方法的线程会被阻塞：</p><pre><code>C_thread1_Sync2_Start: 14:44:20C_thread1_Sync2_End: 14:44:22C_thread2_Sync2_Start: 14:44:26C_thread2_Sync2_End: 14:44:28</code></pre><p>synchronized 修饰非静态方法，作用范围是整个方法，所以方法中所有的代码都是同步的：</p><pre><code>C_thread1_Sync2: 14:44:20C_thread2_Sync2: 14:44:26</code></pre><p>由结果可知 B 类和 C 类线程顺序执行，类中 synchronized(this|object) {} 代码块和 synchronized 修饰非静态方法获取的锁是同一个锁，即该类的对象的对象锁。所以 B 类线程和 C 类线程也是同步的：</p><pre><code>B_thread1_Sync1_Start: 14:44:22B_thread1_Sync1_End: 14:44:24C_thread1_Sync2_Start: 14:44:20C_thread1_Sync2_End: 14:44:22B_thread2_Sync1_Start: 14:44:24B_thread2_Sync1_End: 14:44:26C_thread2_Sync2_Start: 14:44:26C_thread2_Sync2_End: 14:44:28</code></pre><h3 id="对于不同对象"><a href="#对于不同对象" class="headerlink" title="对于不同对象"></a>对于不同对象</h3><p>修改测试代码为：</p><pre><code>public class SyncTest {    public static void main(String... args) {        Thread A_thread1 = new Thread(new SyncThread(), &quot;A_thread1&quot;);        Thread A_thread2 = new Thread(new SyncThread(), &quot;A_thread2&quot;);        Thread B_thread1 = new Thread(new SyncThread(), &quot;B_thread1&quot;);        Thread B_thread2 = new Thread(new SyncThread(), &quot;B_thread2&quot;);        Thread C_thread1 = new Thread(new SyncThread(), &quot;C_thread1&quot;);        Thread C_thread2 = new Thread(new SyncThread(), &quot;C_thread2&quot;);        A_thread1.start();        A_thread2.start();        B_thread1.start();        B_thread2.start();        C_thread1.start();        C_thread2.start();    }}</code></pre><p>运行结果：</p><pre><code>A_thread2_Async_Start: 15:01:34C_thread2_Sync2: 15:01:34B_thread2_Sync1: 15:01:34C_thread1_Sync2: 15:01:34B_thread2_Sync1_Start: 15:01:34B_thread1_Sync1: 15:01:34C_thread1_Sync2_Start: 15:01:34A_thread1_Async_Start: 15:01:34C_thread2_Sync2_Start: 15:01:34B_thread1_Sync1_Start: 15:01:34C_thread1_Sync2_End: 15:01:36A_thread1_Async_End: 15:01:36C_thread2_Sync2_End: 15:01:36B_thread2_Sync1_End: 15:01:36B_thread1_Sync1_End: 15:01:36A_thread2_Async_End: 15:01:36</code></pre><p>结果分析：</p><p>两个线程访问不同对象的 synchronized(this|object) {} 代码块和 synchronized 修饰非静态方法是异步的，同一个类的不同对象的对象锁互不干扰。</p><h2 id="获取类锁-1"><a href="#获取类锁-1" class="headerlink" title="获取类锁"></a>获取类锁</h2><h3 id="对于同一对象-1"><a href="#对于同一对象-1" class="headerlink" title="对于同一对象"></a>对于同一对象</h3><p>同步线程类：</p><pre><code>class SyncThread implements Runnable {    @Override    public void run() {        String threadName = Thread.currentThread().getName();        if (threadName.startsWith(&quot;A&quot;)) {            async();        } else if (threadName.startsWith(&quot;B&quot;)) {            sync1();        } else if (threadName.startsWith(&quot;C&quot;)) {            sync2();        }    }    /**     * 异步方法     */    private void async() {        try {            System.out.println(Thread.currentThread().getName() + &quot;_Async_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            Thread.sleep(2000);            System.out.println(Thread.currentThread().getName() + &quot;_Async_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));        } catch (InterruptedException e) {            e.printStackTrace();        }    }    /**     * 方法中有 synchronized(类.class) {} 同步代码块     */    private void sync1() {        System.out.println(Thread.currentThread().getName() + &quot;_Sync1: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));        synchronized (SyncThread.class) {            try {                System.out.println(Thread.currentThread().getName() + &quot;_Sync1_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));                Thread.sleep(2000);                System.out.println(Thread.currentThread().getName() + &quot;_Sync1_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }    /**     * synchronized 修饰静态方法     */    private synchronized static void sync2() {        System.out.println(Thread.currentThread().getName() + &quot;_Sync2: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));        try {            System.out.println(Thread.currentThread().getName() + &quot;_Sync2_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            Thread.sleep(2000);            System.out.println(Thread.currentThread().getName() + &quot;_Sync2_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><p>测试代码：</p><pre><code>public class SyncTest {    public static void main(String... args) {        SyncThread syncThread = new SyncThread();        Thread A_thread1 = new Thread(syncThread, &quot;A_thread1&quot;);        Thread A_thread2 = new Thread(syncThread, &quot;A_thread2&quot;);        Thread B_thread1 = new Thread(syncThread, &quot;B_thread1&quot;);        Thread B_thread2 = new Thread(syncThread, &quot;B_thread2&quot;);        Thread C_thread1 = new Thread(syncThread, &quot;C_thread1&quot;);        Thread C_thread2 = new Thread(syncThread, &quot;C_thread2&quot;);        A_thread1.start();        A_thread2.start();        B_thread1.start();        B_thread2.start();        C_thread1.start();        C_thread2.start();    }}</code></pre><p>运行结果：</p><pre><code>B_thread1_Sync1: 15:08:13C_thread1_Sync2: 15:08:13B_thread2_Sync1: 15:08:13A_thread1_Async_Start: 15:08:13C_thread1_Sync2_Start: 15:08:13A_thread2_Async_Start: 15:08:13C_thread1_Sync2_End: 15:08:15A_thread2_Async_End: 15:08:15A_thread1_Async_End: 15:08:15B_thread2_Sync1_Start: 15:08:15B_thread2_Sync1_End: 15:08:17B_thread1_Sync1_Start: 15:08:17B_thread1_Sync1_End: 15:08:19C_thread2_Sync2: 15:08:19C_thread2_Sync2_Start: 15:08:19C_thread2_Sync2_End: 15:08:21</code></pre><p>结果分析：</p><p>由结果可以看出，在同一对象的情况下，synchronized(类.class) {} 代码块或 synchronized 修饰静态方法和 synchronized(this|object) {} 代码块和 synchronized 修饰非静态方法的行为一致。</p><h3 id="对于不同对象-1"><a href="#对于不同对象-1" class="headerlink" title="对于不同对象"></a>对于不同对象</h3><p>修改测试代码为：</p><pre><code>public class SyncTest {    public static void main(String... args) {        Thread A_thread1 = new Thread(new SyncThread(), &quot;A_thread1&quot;);        Thread A_thread2 = new Thread(new SyncThread(), &quot;A_thread2&quot;);        Thread B_thread1 = new Thread(new SyncThread(), &quot;B_thread1&quot;);        Thread B_thread2 = new Thread(new SyncThread(), &quot;B_thread2&quot;);        Thread C_thread1 = new Thread(new SyncThread(), &quot;C_thread1&quot;);        Thread C_thread2 = new Thread(new SyncThread(), &quot;C_thread2&quot;);        A_thread1.start();        A_thread2.start();        B_thread1.start();        B_thread2.start();        C_thread1.start();        C_thread2.start();    }}</code></pre><p>运行结果：</p><pre><code>A_thread2_Async_Start: 15:17:28B_thread2_Sync1: 15:17:28A_thread1_Async_Start: 15:17:28B_thread1_Sync1: 15:17:28C_thread1_Sync2: 15:17:28C_thread1_Sync2_Start: 15:17:28C_thread1_Sync2_End: 15:17:30A_thread2_Async_End: 15:17:30B_thread1_Sync1_Start: 15:17:30A_thread1_Async_End: 15:17:30B_thread1_Sync1_End: 15:17:32B_thread2_Sync1_Start: 15:17:32B_thread2_Sync1_End: 15:17:34C_thread2_Sync2: 15:17:34C_thread2_Sync2_Start: 15:17:34C_thread2_Sync2_End: 15:17:36</code></pre><p>结果分析：</p><p>两个线程访问不同对象的 synchronized(类.class) {} 代码块或 synchronized 修饰静态方法还是同步的，类中 synchronized(类.class) {} 代码块和 synchronized 修饰静态方法获取的锁是类锁。对于同一个类的不同对象的类锁是同一个。</p><h2 id="类中同时有-synchronized-类-class-代码块或-synchronized-修饰静态方法和-synchronized-this-object-代码块和-synchronized-修饰非静态方法时会怎样？"><a href="#类中同时有-synchronized-类-class-代码块或-synchronized-修饰静态方法和-synchronized-this-object-代码块和-synchronized-修饰非静态方法时会怎样？" class="headerlink" title="类中同时有 synchronized(类.class) {} 代码块或 synchronized 修饰静态方法和 synchronized(this|object) {} 代码块和 synchronized 修饰非静态方法时会怎样？"></a>类中同时有 synchronized(类.class) {} 代码块或 synchronized 修饰静态方法和 synchronized(this|object) {} 代码块和 synchronized 修饰非静态方法时会怎样？</h2><p>修改同步线程类：</p><pre><code>class SyncThread implements Runnable {    @Override    public void run() {        String threadName = Thread.currentThread().getName();        if (threadName.startsWith(&quot;A&quot;)) {            async();        } else if (threadName.startsWith(&quot;B&quot;)) {            sync1();        } else if (threadName.startsWith(&quot;C&quot;)) {            sync2();        }    }    /**     * 异步方法     */    private void async() {        try {            System.out.println(Thread.currentThread().getName() + &quot;_Async_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            Thread.sleep(2000);            System.out.println(Thread.currentThread().getName() + &quot;_Async_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));        } catch (InterruptedException e) {            e.printStackTrace();        }    }    /**     * synchronized 修饰非静态方法     */    private synchronized void sync1() {        try {            System.out.println(Thread.currentThread().getName() + &quot;_Sync1_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            Thread.sleep(2000);            System.out.println(Thread.currentThread().getName() + &quot;_Sync1_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));        } catch (InterruptedException e) {            e.printStackTrace();        }    }    /**     * synchronized 修饰静态方法     */    private synchronized static void sync2() {        try {            System.out.println(Thread.currentThread().getName() + &quot;_Sync2_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            Thread.sleep(2000);            System.out.println(Thread.currentThread().getName() + &quot;_Sync2_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><p>修改测试代码：</p><pre><code>public class SyncTest {    public static void main(String... args) {        Thread B_thread1 = new Thread(syncThread, &quot;B_thread1&quot;);        Thread C_thread1 = new Thread(syncThread, &quot;C_thread1&quot;);        B_thread1.start();        C_thread1.start();    }}</code></pre><p>运行结果：</p><pre><code>B_thread1_Sync1_Start: 15:35:21C_thread1_Sync2_Start: 15:35:21B_thread1_Sync1_End: 15:35:23C_thread1_Sync2_End: 15:35:23</code></pre><p>运行结果分析：</p><p>由结果可以看到 B 类线程和 C 类线程是异步的，即 synchronized 修饰静态方法和 synchronized 修饰非静态方法是异步的，对于 synchronized(类.class) {} 代码块和 synchronized(this|object) {} 代码块也是一样的。所以对象锁和类锁是独立的，互不干扰。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>synchronized关键字不能继承。</p><p> 对于父类中的 synchronized 修饰方法，子类在覆盖该方法时，默认情况下不是同步的，必须显示的使用 synchronized 关键字修饰才行。</p><p>在定义接口方法时不能使用synchronized关键字。</p><p>构造方法不能使用synchronized关键字，但可以使用synchronized代码块来进行同步。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】 <a href="https://juejin.im/post/594a24defe88c2006aa01f1c" target="_blank" rel="noopener">https://juejin.im/post/594a24defe88c2006aa01f1c</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java并发编程中synchronized的概念&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记VI</title>
    <link href="http://yoursite.com/2019/09/05/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0VI/"/>
    <id>http://yoursite.com/2019/09/05/Java学习笔记VI/</id>
    <published>2019-09-05T07:12:12.000Z</published>
    <updated>2019-09-05T07:37:21.245Z</updated>
    
    <content type="html"><![CDATA[<p>Java基本数据类型和包装类的区别,不同类型为空的异常判断，集合操作</p><a id="more"></a><p>在实际的工程项目开发中，常遇到对于传入参数的异常处理，对于不同类型的参数需要进行不同的判断，例如有时int，long类型的参数需要判断是否为0，而Integer和Long类型的参数需要判断是否为空。String类型的需要使用StringUtils.isEmpty()</p><h1 id="StringUtils类中isEmpty与isBlank的区别"><a href="#StringUtils类中isEmpty与isBlank的区别" class="headerlink" title="StringUtils类中isEmpty与isBlank的区别"></a>StringUtils类中isEmpty与isBlank的区别</h1><p>org.apache.commons.lang.StringUtils类提供了String的常用操作,最为常用的判空有如下两种isEmpty(String str)和isBlank(String str)。</p><p>StringUtils.isEmpty(String str) 判断某字符串是否为空，为空的标准是 str==null 或 str.length()==0</p><pre><code>System.out.println(StringUtils.isEmpty(null));        //trueSystem.out.println(StringUtils.isEmpty(&quot;&quot;));          //trueSystem.out.println(StringUtils.isEmpty(&quot;   &quot;));       //falseSystem.out.println(StringUtils.isEmpty(&quot;dd&quot;));        //falseStringUtils.isNotEmpty(String str) 等价于 !isEmpty(String str)</code></pre><p>StringUtils.isBlank(String str) 判断某字符串是否为空或长度为0或由空白符(whitespace) 构成</p><pre><code>System.out.println(StringUtils.isBlank(null));        //trueSystem.out.println(StringUtils.isBlank(&quot;&quot;));          //trueSystem.out.println(StringUtils.isBlank(&quot;   &quot;));       //trueSystem.out.println(StringUtils.isBlank(&quot;dd&quot;));        //false    </code></pre><p>StringUtils.isBlank(String str) 等价于 !isBlank(String str)</p><h1 id="集合操作-CollectionUtils"><a href="#集合操作-CollectionUtils" class="headerlink" title="集合操作 CollectionUtils"></a>集合操作 CollectionUtils</h1><p>对于查询到的集合例如：</p><pre><code>List&lt;TblJobsEntity&gt; tblJobsEntityList = tblJobsEntityMapper.selectByExample(tblJobsEntityExample);</code></pre><p>进行判断时，不能使用</p><pre><code>if(tblJobsEntityList.isEmpty())</code></pre><p>因为若查询到的tblJobsEntityList为null，则null.isEmpty()会出现空指针异常，如</p><pre><code>Exception in thread &quot;main&quot; java.lang.NullPointerException</code></pre><p>需要使用CollectionUtils.isEmpty(tblJobsEntityList)来进行判断</p><h2 id="集合判断："><a href="#集合判断：" class="headerlink" title="集合判断："></a>集合判断：</h2><h3 id="判断集合是否为空"><a href="#判断集合是否为空" class="headerlink" title="判断集合是否为空:"></a>判断集合是否为空:</h3><pre><code>CollectionUtils.isEmpty(null): trueCollectionUtils.isEmpty(new ArrayList()): trueCollectionUtils.isEmpty({a,b}): false</code></pre><h3 id="判断集合是否不为空"><a href="#判断集合是否不为空" class="headerlink" title="判断集合是否不为空:"></a>判断集合是否不为空:</h3><pre><code>CollectionUtils.isNotEmpty(null): falseCollectionUtils.isNotEmpty(new ArrayList()): falseCollectionUtils.isNotEmpty({a,b}): true</code></pre><h3 id="2个集合间的操作："><a href="#2个集合间的操作：" class="headerlink" title="2个集合间的操作："></a>2个集合间的操作：</h3><pre><code>集合a: {1,2,3,3,4,5}集合b: {3,4,4,5,6,7}CollectionUtils.union(a, b)(并集): {1,2,3,3,4,4,5,6,7}CollectionUtils.intersection(a, b)(交集): {3,4,5}CollectionUtils.disjunction(a, b)(交集的补集): {1,2,3,4,6,7}CollectionUtils.disjunction(b, a)(交集的补集): {1,2,3,4,6,7}CollectionUtils.subtract(a, b)(A与B的差): {1,2,3}CollectionUtils.subtract(b, a)(B与A的差): {4,6,7}</code></pre><h1 id="Java基本数据类型和包装类的区别"><a href="#Java基本数据类型和包装类的区别" class="headerlink" title="Java基本数据类型和包装类的区别"></a>Java基本数据类型和包装类的区别</h1><p>Java的数据类型分两种：</p><p>基本类型：byte，short，int，long，boolean，float，double，char</p><p>引用类型：所有class和interface类型</p><p>引用类型可以赋值为null，表示空，但基本类型不能赋值为null：</p><pre><code>String s = null;int n = null; // compile error!</code></pre><p>如何把一个基本类型视为对象（引用类型）？</p><h2 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h2><p>比如，想要把int基本类型变成一个引用类型，我们可以定义一个Integer类，它只包含一个实例字段int，这样，Integer类就可以视为int的包装类（Wrapper Class）：</p><pre><code>public class Integer {    private int value;    public Integer(int value) {        this.value = value;    }    public int intValue() {        return this.value;    }}</code></pre><p>定义好了Integer类，我们就可以把int和Integer互相转换：</p><pre><code>Integer n = null;Integer n2 = new Integer(99);int n3 = n2.intValue();</code></pre><p>实际上，因为包装类型非常有用，Java核心库为每种基本类型都提供了对应的包装类型：</p><pre><code>基本类型      对应的引用类型boolean       java.lang.Booleanbyte         java.lang.Byteshort         java.lang.Shortint           java.lang.Integerlong         java.lang.Longfloat         java.lang.Floatdouble       java.lang.Doublechar         java.lang.Character</code></pre><p>我们可以直接使用，并不需要自己去定义：</p><pre><code>// Integer:public class Main {    public static void main(String[] args) {        int i = 100;        // 通过new操作符创建Integer实例(不推荐使用,会有编译警告):        Integer n1 = new Integer(i);        // 通过静态方法valueOf(int)创建Integer实例:        Integer n2 = Integer.valueOf(i);        // 通过静态方法valueOf(String)创建Integer实例:        Integer n3 = Integer.valueOf(&quot;100&quot;);        System.out.println(n3.intValue());    }}</code></pre><h2 id="Auto-Boxing"><a href="#Auto-Boxing" class="headerlink" title="Auto Boxing"></a>Auto Boxing</h2><p>因为int和Integer可以互相转换：</p><pre><code>int i = 100;Integer n = Integer.valueOf(i);int x = n.intValue();</code></pre><p>所以，Java编译器可以帮助我们自动在int和Integer之间转型：</p><pre><code>Integer n = 100; // 编译器自动使用Integer.valueOf(int)int x = n; // 编译器自动使用Integer.intValue()</code></pre><p>这种直接把int变为Integer的赋值写法，称为自动装箱（Auto Boxing），反过来，把Integer变为int的赋值写法，称为自动拆箱（Auto Unboxing）。</p><p>注意：自动装箱和自动拆箱只发生在编译阶段，目的是为了少写代码。</p><p>装箱和拆箱会影响代码的执行效率，因为编译后的class代码是严格区分基本类型和引用类型的。并且，自动拆箱执行时可能会报NullPointerException：</p><pre><code>// NullPointerExceptionpublic class Main {    public static void main(String[] args) {        Integer n = null;        int i = n;    }}</code></pre><h2 id="不变类"><a href="#不变类" class="headerlink" title="不变类"></a>不变类</h2><p>所有的包装类型都是不变类。我们查看Integer的源码可知，它的核心代码如下：</p><pre><code>public final class Integer {    private final int value;}</code></pre><p>因此，一旦创建了Integer对象，该对象就是不变的。</p><p>对两个Integer实例进行比较要特别注意：绝对不能用==比较，因为Integer是引用类型，必须使用equals()比较：</p><pre><code>// == or equals?public class Main {    public static void main(String[] args) {        Integer x = 127;        Integer y = 127;        Integer m = 99999;        Integer n = 99999;        System.out.println(&quot;x == y: &quot; + (x==y)); // true        System.out.println(&quot;m == n: &quot; + (m==n)); // false        System.out.println(&quot;x.equals(y): &quot; + x.equals(y)); // true        System.out.println(&quot;m.equals(n): &quot; + m.equals(n)); // true    }}</code></pre><p>仔细观察结果的童鞋可以发现，==比较，较小的两个相同的Integer返回true，较大的两个相同的Integer返回false，这是因为Integer是不变类，编译器把Integer x = 127;自动变为Integer x = Integer.valueOf(127);</p><p>为了节省内存，Integer.valueOf()对于较小的数，始终返回相同的实例，因此，==比较“恰好”为true，但我们绝不能因为Java标准库的Integer内部有缓存优化就用==比较，必须用equals()方法比较两个Integer。</p><p>按照语义编程，而不是针对特定的底层实现去“优化”。</p><p>因为Integer.valueOf()可能始终返回同一个Integer实例，因此，在我们自己创建Integer的时候，以下两种方法：</p><pre><code>方法1：Integer n = new Integer(100);方法2：Integer n = Integer.valueOf(100);</code></pre><p>方法2更好，因为方法1总是创建新的Integer实例，方法2把内部优化留给Integer的实现者去做，即使在当前版本没有优化，也有可能在下一个版本进行优化。</p><p>我们把能创建“新”对象的静态方法称为静态工厂方法。Integer.valueOf()就是静态工厂方法，它尽可能地返回缓存的实例以节省内存。</p><p> 创建新对象时，优先选用静态工厂方法而不是new操作符。</p><p>如果我们考察Byte.valueOf()方法的源码，可以看到，标准库返回的Byte实例全部是缓存实例，但调用者并不关心静态工厂方法以何种方式创建新实例还是直接返回缓存的实例。</p><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><p>Integer类本身还提供了大量方法，例如，最常用的静态方法parseInt()可以把字符串解析成一个整数：</p><pre><code>int x1 = Integer.parseInt(&quot;100&quot;); // 100int x2 = Integer.parseInt(&quot;100&quot;, 16); // 256,因为按16进制解析</code></pre><p>Integer还可以把整数格式化为指定进制的字符串：</p><pre><code>// Integer:public class Main {    public static void main(String[] args) {        System.out.println(Integer.toString(100)); // &quot;100&quot;,表示为10进制        System.out.println(Integer.toString(100, 36)); // &quot;2s&quot;,表示为36进制        System.out.println(Integer.toHexString(100)); // &quot;64&quot;,表示为16进制        System.out.println(Integer.toOctalString(100)); // &quot;144&quot;,表示为8进制        System.out.println(Integer.toBinaryString(100)); // &quot;1100100&quot;,表示为2进制    }}</code></pre><p>注意：上述方法的输出都是String，在计算机内存中，只用二进制表示，不存在十进制或十六进制的表示方法。int n = 100在内存中总是以4字节的二进制表示：</p><pre><code>┌────────┬────────┬────────┬────────┐│00000000│00000000│00000000│01100100│└────────┴────────┴────────┴────────┘</code></pre><p>我们经常使用的System.out.println(n);是依靠核心库自动把整数格式化为10进制输出并显示在屏幕上，使用Integer.toHexString(n)则通过核心库自动把整数格式化为16进制。</p><p>这里我们注意到程序设计的一个重要原则：数据的存储和显示要分离。</p><p>Java的包装类型还定义了一些有用的静态变量</p><pre><code>// boolean只有两个值true/false，其包装类型只需要引用Boolean提供的静态字段:Boolean t = Boolean.TRUE;Boolean f = Boolean.FALSE;// int可表示的最大/最小值:int max = Integer.MAX_VALUE; // 2147483647int min = Integer.MIN_VALUE; // -2147483648// long类型占用的bit和byte数量:int sizeOfLong = Long.SIZE; // 64 (bits)int bytesOfLong = Long.BYTES; // 8 (bytes)</code></pre><p>最后，所有的整数和浮点数的包装类型都继承自Number，因此，可以非常方便地直接通过包装类型获取各种基本类型：</p><pre><code>// 向上转型为Number:Number num = new Integer(999);// 获取byte, int, long, float, double:byte b = num.byteValue();int n = num.intValue();long ln = num.longValue();float f = num.floatValue();double d = num.doubleValue();</code></pre><h2 id="处理无符号整型"><a href="#处理无符号整型" class="headerlink" title="处理无符号整型"></a>处理无符号整型</h2><p>在Java中，并没有无符号整型（Unsigned）的基本数据类型。byte、short、int和long都是带符号整型，最高位是符号位。而C语言则提供了CPU支持的全部数据类型，包括无符号整型。无符号整型和有符号整型的转换在Java中就需要借助包装类型的静态方法完成。</p><p>例如，byte是有符号整型，范围是-128~+127，但如果把byte看作无符号整型，它的范围就是0~255。我们把一个负的byte按无符号整型转换为int：</p><pre><code>// Bytepublic class Main {    public static void main(String[] args) {        byte x = -1;        byte y = 127;        System.out.println(Byte.toUnsignedInt(x)); // 255        System.out.println(Byte.toUnsignedInt(y)); // 127    }}</code></pre><p>因为byte的-1的二进制表示是11111111，以无符号整型转换后的int就是255。</p><p>类似的，可以把一个short按unsigned转换为int，把一个int按unsigned转换为long。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Java核心库提供的包装类型可以把基本类型包装为class；</p><p>自动装箱和自动拆箱都是在编译期完成的（JDK&gt;=1.5）；</p><p>装箱和拆箱会影响执行效率，且拆箱时可能发生NullPointerException；</p><p>包装类型的比较必须使用equals()；</p><p>整数和浮点数的包装类型都继承自Number；</p><p>包装类型提供了大量实用方法。</p><h2 id="思考：Java中基本数据类型和包装类型有什么区别"><a href="#思考：Java中基本数据类型和包装类型有什么区别" class="headerlink" title="思考：Java中基本数据类型和包装类型有什么区别"></a>思考：Java中基本数据类型和包装类型有什么区别</h2><p>1、包装类是对象，拥有方法和字段，对象的调用都是通过引用对象的地址，基本类型不是</p><p>2、包装类型是引用的传递，基本类型是值的传递</p><p>3、声明方式不同，基本数据类型不需要new关键字，而包装类型需要new在堆内存中进行new来分配内存空间</p><p>4、存储位置不同，基本数据类型直接将值保存在值栈中，而包装类型是把对象放在堆中，然后通过对象的引用来调用他们</p><p>5、<strong><em>初始值不同，eg： int的初始值为 0 、 boolean的初始值为false 而包装类型的初始值为null</em></strong></p><p>6、使用方式不同，基本数据类型直接赋值使用就好 ，而包装类型是在集合如 collection Map时会使用</p><p>7.当需要往ArrayList，HashMap中放东西时，像int，double这种基本类型是放不进去的，因为容器都是装object的，这是就需要这些基本类型的外覆类了，比如</p><pre><code>List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="https://blog.csdn.net/shb_derek1/article/details/9624897" target="_blank" rel="noopener">https://blog.csdn.net/shb_derek1/article/details/9624897</a></p><p>【2】<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260473794166400" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1252599548343744/1260473794166400</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java基本数据类型和包装类的区别,不同类型为空的异常判断，集合操作&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Git学习笔记II</title>
    <link href="http://yoursite.com/2019/09/05/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0II/"/>
    <id>http://yoursite.com/2019/09/05/Git学习笔记II/</id>
    <published>2019-09-05T06:51:12.000Z</published>
    <updated>2019-09-05T07:01:26.944Z</updated>
    
    <content type="html"><![CDATA[<p>Git版本回滚</p><a id="more"></a><p>在当前branch上多次commit代码并且push后，发现不符合要求，需要回滚到特定的版本。步骤如下：</p><p>1、查找commitId</p><p>首先用命令行打开git项目路径，输入git log命令查看commit记录，如下：</p><pre><code>$ git log</code></pre><p>找到commitId是9a0d02d1578ea064479296ad7efa70c5cb1a3717记录，这是执行上面命令后打印出来的信息：</p><pre><code>commit 9a0d02d1578ea064479296ad7efa70c5cb1a3717</code></pre><p>2、找到需要回滚的commit，输入git reset –hard {commitId}，将本地文件回滚：</p><pre><code>$ git reset --hard c503cffa099332911d4fce2fc1399cb4bc3ba9d6HEAD is now at c503cffa0 add a constellation test case</code></pre><p>3、此时本地文件已经回滚到刚刚commit 9a0d02d1578ea064479296ad7efa70c5cb1a3717之后的状态，但是服务器仍然没有改变，需要继续远程回滚：</p><pre><code>$ git push -f</code></pre><p>执行，最终提示一系列内容，远程回滚成功</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】 <a href="https://blog.csdn.net/weixin_38569499/article/details/83017699" target="_blank" rel="noopener">https://blog.csdn.net/weixin_38569499/article/details/83017699</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git版本回滚&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>数据库学习笔记V</title>
    <link href="http://yoursite.com/2019/09/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0V/"/>
    <id>http://yoursite.com/2019/09/05/数据库学习笔记V/</id>
    <published>2019-09-05T02:12:12.000Z</published>
    <updated>2019-12-06T03:48:14.159Z</updated>
    
    <content type="html"><![CDATA[<p>使用ALTER命令修改数据表名或者修改数据表字段</p><a id="more"></a><p>当我们需要修改数据表名或者修改数据表字段时，就需要使用到MySQL ALTER命令。</p><h1 id="创建一张表"><a href="#创建一张表" class="headerlink" title="创建一张表"></a>创建一张表</h1><p>表名为：tablename。</p><pre><code>root@host# mysql -u root -p password;Enter password:*******mysql&gt; use RUNOOB;Database changedmysql&gt; create table tablename    -&gt; (    -&gt; i INT,    -&gt; c CHAR(1)    -&gt; );Query OK, 0 rows affected (0.05 sec)mysql&gt; SHOW COLUMNS FROM tablename;+-------+---------+------+-----+---------+-------+| Field | Type    | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| i     | int(11) | YES  |     | NULL    |       || c     | char(1) | YES  |     | NULL    |       |+-------+---------+------+-----+---------+-------+2 rows in set (0.00 sec)</code></pre><h1 id="删除，添加或修改表字段"><a href="#删除，添加或修改表字段" class="headerlink" title="删除，添加或修改表字段"></a>删除，添加或修改表字段</h1><p>如下命令使用了 ALTER 命令及 DROP 子句来删除以上创建表的 i 字段：</p><pre><code>mysql&gt; ALTER TABLE tablename  DROP i;</code></pre><p>如果数据表中只剩余一个字段则无法使用DROP来删除字段。</p><p>MySQL 中使用 ADD 子句来向数据表中添加列，如下实例在表 tablename 中添加 i 字段，并定义数据类型:</p><pre><code>mysql&gt; ALTER TABLE tablename ADD i INT;</code></pre><p>执行以上命令后，i 字段会自动添加到数据表字段的末尾。</p><pre><code>mysql&gt; SHOW COLUMNS FROM tablename;+-------+---------+------+-----+---------+-------+| Field | Type    | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| c     | char(1) | YES  |     | NULL    |       || i     | int(11) | YES  |     | NULL    |       |+-------+---------+------+-----+---------+-------+2 rows in set (0.00 sec)</code></pre><p>如果你需要指定新增字段的位置，可以使用MySQL提供的关键字 FIRST (设定位第一列)， AFTER 字段名（设定位于某个字段之后）。</p><p>尝试以下 ALTER TABLE 语句, 在执行成功后，使用 SHOW COLUMNS 查看表结构的变化：</p><pre><code>ALTER TABLE tablename DROP i;ALTER TABLE tablename ADD i INT FIRST;ALTER TABLE tablename DROP i;ALTER TABLE tablename ADD i INT AFTER c;</code></pre><p>FIRST 和 AFTER 关键字可用于 ADD 与 MODIFY 子句，所以如果你想重置数据表字段的位置就需要先使用 DROP 删除字段然后使用 ADD 来添加字段并设置位置。</p><p>类似使用到的语句：</p><pre><code>ALTER TABLE tbl_jobs ADD data_send varchar(32)</code></pre><h1 id="修改字段类型及名称"><a href="#修改字段类型及名称" class="headerlink" title="修改字段类型及名称"></a>修改字段类型及名称</h1><p>如果需要修改字段类型及名称, 你可以在ALTER命令中使用 MODIFY 或 CHANGE 子句 。</p><p>例如，把字段 c 的类型从 CHAR(1) 改为 CHAR(10)，可以执行以下命令:</p><pre><code>mysql&gt; ALTER TABLE tablename MODIFY c CHAR(10);</code></pre><p>使用 CHANGE 子句, 语法有很大的不同。 在 CHANGE 关键字之后，紧跟着的是你要修改的字段名，然后指定新字段名及类型。尝试如下实例：</p><pre><code>mysql&gt; ALTER TABLE tablename CHANGE i j BIGINT;mysql&gt; ALTER TABLE tablename CHANGE j j INT;</code></pre><h1 id="ALTER-TABLE-对-Null-值和默认值的影响"><a href="#ALTER-TABLE-对-Null-值和默认值的影响" class="headerlink" title="ALTER TABLE 对 Null 值和默认值的影响"></a>ALTER TABLE 对 Null 值和默认值的影响</h1><p>当你修改字段时，你可以指定是否包含值或者是否设置默认值。</p><p>以下实例，指定字段 j 为 NOT NULL 且默认值为100 。</p><pre><code>mysql&gt; ALTER TABLE tablename    -&gt; MODIFY j BIGINT NOT NULL DEFAULT 100;</code></pre><p>如果你不设置默认值，MySQL会自动设置该字段默认为 NULL。</p><h1 id="修改字段默认值"><a href="#修改字段默认值" class="headerlink" title="修改字段默认值"></a>修改字段默认值</h1><p>你可以使用 ALTER 来修改字段的默认值，尝试以下实例：</p><pre><code>mysql&gt; ALTER TABLE tablename ALTER i SET DEFAULT 1000;mysql&gt; SHOW COLUMNS FROM tablename;+-------+---------+------+-----+---------+-------+| Field | Type    | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| c     | char(1) | YES  |     | NULL    |       || i     | int(11) | YES  |     | 1000    |       |+-------+---------+------+-----+---------+-------+2 rows in set (0.00 sec)</code></pre><p>你也可以使用 ALTER 命令及 DROP子句来删除字段的默认值，如下实例：</p><pre><code>mysql&gt; ALTER TABLE tablename ALTER i DROP DEFAULT;mysql&gt; SHOW COLUMNS FROM tablename;+-------+---------+------+-----+---------+-------+| Field | Type    | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| c     | char(1) | YES  |     | NULL    |       || i     | int(11) | YES  |     | NULL    |       |+-------+---------+------+-----+---------+-------+2 rows in set (0.00 sec)Changing a Table Type:</code></pre><h1 id="修改数据表类型"><a href="#修改数据表类型" class="headerlink" title="修改数据表类型"></a>修改数据表类型</h1><p>可以使用 ALTER 命令及 TYPE 子句来完成。尝试以下实例，我们将表 tablename 的类型修改为 MYISAM ：</p><p>注意：查看数据表类型可以使用 SHOW TABLE STATUS 语句。</p><pre><code>mysql&gt; ALTER TABLE tablename ENGINE = MYISAM;mysql&gt;  SHOW TABLE STATUS LIKE &apos;tablename&apos;\G*************************** 1. row ****************           Name: tablename           Type: MyISAM     Row_format: Fixed           Rows: 0 Avg_row_length: 0    Data_length: 0Max_data_length: 25769803775   Index_length: 1024      Data_free: 0 Auto_increment: NULL    Create_time: 2007-06-03 08:04:36    Update_time: 2007-06-03 08:04:36     Check_time: NULL Create_options:        Comment:1 row in set (0.00 sec)</code></pre><h1 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h1><p>如果需要修改数据表的名称，可以在 ALTER TABLE 语句中使用 RENAME 子句来实现。</p><p>尝试以下实例将数据表 tablename 重命名为 alter_tbl：</p><pre><code>mysql&gt; ALTER TABLE tablename RENAME TO alter_tbl;</code></pre><h1 id="修改unique-key"><a href="#修改unique-key" class="headerlink" title="修改unique-key"></a>修改unique-key</h1><p>mysql可以使用unique key来确保数据的准确性，unique key可以是一个字段，也可以是多个字段，对应已经存在的unique key如何修改呢？分两步来完成，先drop掉，然后在创建。需要注意的是drop时关键字是“index”，而创建时关键词是“unique key”，命令如下：</p><p>alter table table_name drop index <code>uk_name</code>;</p><p>alter table table_name add unique key <code>new_uk_name</code> (<code>col1</code>,<code>col2</code>);<br>注意：如果表中已经存在数据，可能会创建失败，原因是col1, col2无法满足unique。</p><p>例如auth_roles表中原有的<br>    UNIQUE KEY <code>role_unin_name</code> (<code>application_name</code>,<code>department</code>,<code>role_name</code>)</p><p>现在先drop掉</p><pre><code>ALTER TABLE auth_roles DROP index `role_unin_name`</code></pre><p>然后再创建</p><p>  ALTER TABLE auth_roles ADD UNIQUE KEY <code>role_unin_name</code> (<code>application_name</code>,<code>department</code>,<code>role_name</code>,<br>  <code>role_type</code>)<br>其它用过的：</p><p>  ALTER TABLE<br>      <code>reporting</code>.<code>auth_users</code> CHANGE <code>application_name</code> department_name VARCHAR(64)</p><h1 id="修改表的某列为同一值"><a href="#修改表的某列为同一值" class="headerlink" title="修改表的某列为同一值"></a>修改表的某列为同一值</h1><pre><code>update 表名 set 列名=想改的值</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="https://www.runoob.com/mysql/mysql-alter.html" target="_blank" rel="noopener">https://www.runoob.com/mysql/mysql-alter.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用ALTER命令修改数据表名或者修改数据表字段&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Git学习笔记I</title>
    <link href="http://yoursite.com/2019/09/04/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0I/"/>
    <id>http://yoursite.com/2019/09/04/Git学习笔记I/</id>
    <published>2019-09-04T09:08:12.000Z</published>
    <updated>2019-09-05T06:51:17.117Z</updated>
    
    <content type="html"><![CDATA[<p>Git切换新分支，git fetch与git pull的区别，及常用命令集锦</p><a id="more"></a><h1 id="查看本地已有的分支"><a href="#查看本地已有的分支" class="headerlink" title="查看本地已有的分支"></a>查看本地已有的分支</h1><pre><code>git branch</code></pre><h1 id="本地建立新分支并推送到远程仓库"><a href="#本地建立新分支并推送到远程仓库" class="headerlink" title="本地建立新分支并推送到远程仓库"></a>本地建立新分支并推送到远程仓库</h1><h2 id="创建本地分支"><a href="#创建本地分支" class="headerlink" title="创建本地分支"></a>创建本地分支</h2><p>  git checkout -b 新分支名字</p><p>执行该指令后，会在本地创建一个新分支，该分支是从当前分支上建出的，所以所有文件内容都和当前分支一模一样，这是正常的。创建成功后，将自动切换至新分支上。</p><h2 id="推送本地分支到远程仓库"><a href="#推送本地分支到远程仓库" class="headerlink" title="推送本地分支到远程仓库"></a>推送本地分支到远程仓库</h2><p>  git push –sest-upstream origin 分支名字</p><h1 id="将远程git仓库里的指定分支拉取到本地（本地不存在的分支）"><a href="#将远程git仓库里的指定分支拉取到本地（本地不存在的分支）" class="headerlink" title="将远程git仓库里的指定分支拉取到本地（本地不存在的分支）"></a>将远程git仓库里的指定分支拉取到本地（本地不存在的分支）</h1><p>首先更新远程分支列表</p><pre><code>git remote update origin --prune或者git remote update origin -p</code></pre><p>然后将指定分支拉取到本地</p><pre><code>git checkout -b 本地分支名 origin/远程分支名</code></pre><p>这个将会自动创建一个新的本地分支，并与指定的远程分支关联起来。</p><p>如果出现提示：</p><pre><code>fatal: Cannot update paths and switch to branch &apos;dev2&apos; at the same time.Did you intend to checkout &apos;origin/dev2&apos; which can not be resolved as commit?</code></pre><p>表示拉取不成功。我们需要先执行</p><pre><code>git fetch</code></pre><p>然后再执行</p><pre><code>git checkout -b 本地分支名 origin/远程分支名</code></pre><p>即可。</p><h1 id="git-fetch与git-pull的区别"><a href="#git-fetch与git-pull的区别" class="headerlink" title="git fetch与git pull的区别"></a>git fetch与git pull的区别</h1><p>FETCH_HEAD： 是一个版本链接，记录在本地的一个文件中，指向着目前已经从远程仓库取下来的分支的末端版本。</p><p>commit-id：在每次本地工作完成后，都会做一个git commit 操作来保存当前工作到本地的repo， 此时会产生一个commit-id，这是一个能唯一标识一个版本的序列号。 在使用git push后，这个序列号还会同步到远程仓库。</p><p>有了以上的概念再来说说git fetch</p><p>git fetch：这将更新git remote 中所有的远程仓库所包含分支的最新commit-id, 将其记录到.git/FETCH_HEAD文件中</p><p>git fetch更新远程仓库的方式如下：</p><pre><code>git fetch origin master:tmp//在本地新建一个temp分支，并将远程origin仓库的master分支代码下载到本地temp分支git diff tmp//来比较本地代码与刚刚从远程下载下来的代码的区别git merge tmp//合并temp分支到本地的master分支git branch -d temp//如果不想保留temp分支 可以用这步删除</code></pre><h2 id="如果直接使用git-fetch，则步骤如下："><a href="#如果直接使用git-fetch，则步骤如下：" class="headerlink" title="如果直接使用git fetch，则步骤如下："></a>如果直接使用git fetch，则步骤如下：</h2><p>创建并更新本地远程分支。即创建并更新origin/xxx 分支，拉取代码到origin/xxx分支上。</p><p>在FETCH_HEAD中设定当前分支-origin/当前分支对应，如直接到时候git merge就可以将origin/abc合并到abc分支上。</p><h2 id="git-fetch-origin"><a href="#git-fetch-origin" class="headerlink" title="git fetch origin"></a>git fetch origin</h2><p>只是手动指定了要fetch的remote。在不指定分支时通常默认为master</p><h2 id="git-fetch-origin-dev"><a href="#git-fetch-origin-dev" class="headerlink" title="git fetch origin dev"></a>git fetch origin dev</h2><p>指定远程remote和FETCH_HEAD，并且只拉取该分支的提交。</p><h2 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull :"></a>git pull :</h2><p>首先，基于本地的FETCH_HEAD记录，比对本地的FETCH_HEAD记录与远程仓库的版本号，然后git fetch 获得当前指向的远程分支的后续版本的数据，然后再利用git merge将其与本地的当前分支合并。所以可以认为git pull是git fetch和git merge两个步骤的结合。</p><p>git pull的用法如下：</p><pre><code>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;//取回远程主机某个分支的更新，再与本地的指定分支合并。</code></pre><p>因此，与git pull相比git fetch相当于是从远程获取最新版本到本地，但不会自动merge。如果需要有选择的合并git fetch是更好的选择。效果相同时git pull将更为快捷。</p><h1 id="git-命令集锦"><a href="#git-命令集锦" class="headerlink" title="git 命令集锦"></a>git 命令集锦</h1><h2 id="git-设定"><a href="#git-设定" class="headerlink" title="git 设定"></a>git 设定</h2><pre><code>git config --global user.namegit config --global user.emailgit config --global color.ui truegit config --global alias. &lt;命令名称&gt;比如：git config —global alias.st status</code></pre><h2 id="git常用"><a href="#git常用" class="headerlink" title="git常用"></a>git常用</h2><pre><code>git init其反操作：rm -rf .gitgit clonegit statusgit status -s：仅显示已修改的文档名称git status -s -b：显示分支名称git diffgit add .git add -Agit commit -m &quot;message&quot;git commit --amend &quot;message&quot; 修改上一次 commit 內容git pushgit pullgit loggit log --graph 查看分支合并图git log --pretty=onelinegit reflog 查看命令历史rm 删除本地filegit rm 删除版本库file</code></pre><h2 id="git分支操作"><a href="#git分支操作" class="headerlink" title="git分支操作"></a>git分支操作</h2><pre><code>git branchgit branch -r 显示远端分支git branch -a 显示所有分支git branch &lt;分支名称&gt; 建立分支git branch -m &lt;旧分支名称&gt; &lt;新分支名称&gt; 修改分支名字git branch -d &lt;分支名称&gt;git checkoutgit checkout -b &lt;分支名称&gt;：表示 建立並切換 至该分支git merge &lt;分支名称&gt;git reset --merge 放弃merge</code></pre><h2 id="远端操作"><a href="#远端操作" class="headerlink" title="远端操作"></a>远端操作</h2><pre><code>git remote 显示远端数据库列表git remote add &lt;名称&gt; 添加远端数据库git checkout &lt;本地分支名称&gt; origin/&lt;远端分支名称&gt;</code></pre><h2 id="取远端分支建立本地端分支"><a href="#取远端分支建立本地端分支" class="headerlink" title="取远端分支建立本地端分支"></a>取远端分支建立本地端分支</h2><pre><code>git push &lt;分支名称&gt;</code></pre><h2 id="在远端建立分支-上传-或更新-內容至远端分支"><a href="#在远端建立分支-上传-或更新-內容至远端分支" class="headerlink" title="在远端建立分支 / 上传(或更新)內容至远端分支"></a>在远端建立分支 / 上传(或更新)內容至远端分支</h2><pre><code>git fetch &lt;分支名称&gt;</code></pre><h2 id="查看远端数据库分支的修改內容"><a href="#查看远端数据库分支的修改內容" class="headerlink" title="查看远端数据库分支的修改內容"></a>查看远端数据库分支的修改內容</h2><pre><code>git pull &lt;分支名称&gt; 合并(或更新)远端至本地端分支注：pull = fetch + mergegit push :&lt;分支名称&gt; 刪除远端分支git remote set-url &lt;名称&gt; &lt;新连接位址&gt;</code></pre><h2 id="修改远端数据库地址"><a href="#修改远端数据库地址" class="headerlink" title="修改远端数据库地址"></a>修改远端数据库地址</h2><pre><code>git remote rename &lt;旧名称&gt; &lt;新名称&gt;</code></pre><h2 id="修改远端数据库名称"><a href="#修改远端数据库名称" class="headerlink" title="修改远端数据库名称"></a>修改远端数据库名称</h2><h2 id="暂存"><a href="#暂存" class="headerlink" title="暂存"></a>暂存</h2><pre><code>git stash 暂存现在的修改狀況git stash list 列出暂存清单git stash apply 取出上一次暂存git stash pop 取出上一次暂存(该暂存会被移除)git stash@{id} 指定特定暂存git stash clear 清空所有暂存</code></pre><h2 id="操作提交记录"><a href="#操作提交记录" class="headerlink" title="操作提交记录"></a>操作提交记录</h2><pre><code>git commit --amend 修改上一次的commitgit reset HEAD 放弃该修改记录 (reset)git reset --soft HEAD^ 取消上一次 commit，並 保留 修改纪录git reset --hard HEAD^ 取消上一次 commit，並 刪除 修改纪录</code></pre><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】 <a href="https://blog.csdn.net/riddle1981/article/details/74938111" target="_blank" rel="noopener">https://blog.csdn.net/riddle1981/article/details/74938111</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git切换新分支，git fetch与git pull的区别，及常用命令集锦&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>数据库学习笔记IV</title>
    <link href="http://yoursite.com/2019/09/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0IV/"/>
    <id>http://yoursite.com/2019/09/04/数据库学习笔记IV/</id>
    <published>2019-09-04T02:00:12.000Z</published>
    <updated>2019-12-10T09:05:55.303Z</updated>
    
    <content type="html"><![CDATA[<p>SQL插入，多表查询</p><a id="more"></a><h1 id="权限配置"><a href="#权限配置" class="headerlink" title="权限配置"></a>权限配置</h1><p>在reporting数据库中找到auth_users 表，代表的是用户信息，auth_roles代表的是不同的角色信息</p><p>auth_users_roles_rela代表的是不同用户所具有的角色，auth_resources代表资源，其中要添加之前写的inner和core里controller所具有的方法，type为FUNCTION，url就是执行的url，例如/notes/updateNote，level设置为1<br>auth_role_resources_rela是不同角色所具有的资源信息，<br>现在要使用SQL语句添加新的资源，将用户yang.kai</p><h1 id="页面权限配置"><a href="#页面权限配置" class="headerlink" title="页面权限配置"></a>页面权限配置</h1><p>resource_type 为MENU，level=0时为一级菜单，level=1时为二级菜单，现将<a href="http://std-report-fe.laincloud.xyz/#/reportool中的不同级别菜单的http请求url添加到reporting数据库的资源中" target="_blank" rel="noopener">http://std-report-fe.laincloud.xyz/#/reportool中的不同级别菜单的http请求url添加到reporting数据库的资源中</a></p><pre><code>INSERT INTO reporting.auth_resources(resource_name, external_id,resource_type,application_name,resource_url,status,parent_id,level,sort)VALUES(&apos;首页&apos;,-1,&apos;MENU&apos;,&apos;reporting&apos;,&apos;/&apos;,&apos;ACTIVE&apos;,0,0,0),(&apos;报表&apos;,-1,&apos;MENU&apos;,&apos;reporting&apos;,&apos;/report/home&apos;,&apos;ACTIVE&apos;,0,0,0),(&apos;night watcher&apos;,-1,&apos;MENU&apos;,&apos;reporting&apos;,&apos;/night/home&apos;,&apos;ACTIVE&apos;,0,0,0),(&apos;report tool&apos;,-1,&apos;MENU&apos;,&apos;reporting&apos;,&apos;/reportool&apos;,&apos;ACTIVE&apos;,0,0,0),(&apos;短信模板&apos;,-1,&apos;MENU&apos;,&apos;reporting&apos;,&apos;/night/template/sms&apos;,&apos;ACTIVE&apos;,0,1,0),(&apos;邮件模板&apos;,-1,&apos;MENU&apos;,&apos;reporting&apos;,&apos;/night/template/mail&apos;,&apos;ACTIVE&apos;,0,1,0),(&apos;新增模板&apos;,-1,&apos;MENU&apos;,&apos;reporting&apos;,&apos;/night/template/mail&apos;,&apos;ACTIVE&apos;,0,1,0),(&apos;定时任务列表&apos;,-1,&apos;MENU&apos;,&apos;reporting&apos;,&apos;/reportool/jobs&apos;,&apos;ACTIVE&apos;,0,1,0),(&apos;我的笔记&apos;,-1,&apos;MENU&apos;,&apos;reporting&apos;,&apos;/reportool/notes&apos;,&apos;ACTIVE&apos;,0,1,0);</code></pre><p>再次添加一些界面：</p><pre><code>INSERT INTO reporting.auth_resources(resource_name, external_id,resource_type,application_name,resource_url,status,parent_id,level,sort)VALUES(&apos;表结构查询&apos;,-1,&apos;FUNCTION&apos;,&apos;reporting&apos;,&apos;/tool/tables&apos;,&apos;ACTIVE&apos;,0,1,0)INSERT INTO reporting.auth_resources(resource_name, external_id,resource_type,application_name,resource_url,status,parent_id,level,sort)VALUES(&apos;根据当前用户获取所有报表展示树信息&apos;,-1,&apos;FUNCTION&apos;,&apos;reporting&apos;,&apos;/auth/role/getLayout&apos;,&apos;ACTIVE&apos;,0,1,0),(&apos;根据当前用户获取所有功能展示树信息&apos;,-1,&apos;FUNCTION&apos;,&apos;reporting&apos;,&apos;/auth/role/getFunctionLayout&apos;,&apos;ACTIVE&apos;,0,1,0),(&apos;分页查询角色信息&apos;,-1,&apos;FUNCTION&apos;,&apos;reporting&apos;,&apos;/auth/role/queryRolesInfo&apos;,&apos;ACTIVE&apos;,0,1,0),(&apos;分页查询所有操作员信息&apos;,-1,&apos;FUNCTION&apos;,&apos;reporting&apos;,&apos;/auth/user/queryInfo&apos;,&apos;ACTIVE&apos;,0,1,0),(&apos;更新操作员状态（冻结/解冻）&apos;,-1,&apos;FUNCTION&apos;,&apos;reporting&apos;,&apos;/auth/user/updateStatus&apos;,&apos;ACTIVE&apos;,0,1,0)</code></pre><h1 id="INSERT语句"><a href="#INSERT语句" class="headerlink" title="INSERT语句"></a>INSERT语句</h1><p>基本语法是：</p><pre><code>INSERT INTO &lt;表名&gt; (字段1, 字段2, ...) VALUES (值1, 值2, ...);</code></pre><p>例如：<br>    INSERT INTO auth_resources<br>    (resource_name, external_id,resource_type,application_name,resource_url,status,parent_id,level,sort)<br>    VALUES<br>    (‘根据ID删除笔记’,-1,’FUNCTION’,’reporting’,’/notes/deleteNote’,’ACTIVE’,0,1,0)</p><p>还可以同时添加多条数据：</p><pre><code>INSERT INTO &lt;表名&gt; (字段1, 字段2, ...)VALUES (值1, 值2, ...),(值3, 值4, ...),(值5, 值6, ...);</code></pre><p>例如在auth_role_resources_rela中添加不同角色所拥有的资源信息：<br>    INSERT INTO auth_role_resources_rela<br>    (role_id,resource_id,status,created,updated)<br>    VALUES<br>    (3,1,’ACTIVE’,NOW(),NOW()),<br>    (3,2,’ACTIVE’,NOW(),NOW())</p><p>再添加一些权限</p><pre><code>INSERT INTO auth_role_resources_rela(role_id,resource_id,status,created,updated)VALUES(3,246,&apos;ACTIVE&apos;,NOW(),NOW()),(3,247,&apos;ACTIVE&apos;,NOW(),NOW()),(3,248,&apos;ACTIVE&apos;,NOW(),NOW()),(3,249,&apos;ACTIVE&apos;,NOW(),NOW()),(3,250,&apos;ACTIVE&apos;,NOW(),NOW())</code></pre><p>例如在线上生产环境中添加角色权限<br>    INSERT INTO reporting.auth_user_roles_rela<br>    (user_id,role_id,create_user,status,created,updated)<br>    VALUES<br>    (14,1,‘yiyeli@<strong><em>.cn’,’ACTIVE’,NOW(),NOW()),<br>    (14,5,‘yiyeli@</em></strong>.cn’,’ACTIVE’,NOW(),NOW())</p><p>例如添加某个用户具有的角色信息：</p><pre><code>INSERT INTO reporting.auth_user_roles_rela(user_id,role_id,create_user,status,created,updated)VALUES(22,4,&apos;yiyeli@***.cn&apos;,&apos;ACTIVE&apos;,NOW(),NOW()),(22,5,&apos;yiyeli@***.cn&apos;,&apos;ACTIVE&apos;,NOW(),NOW())INSERT INTO reporting.auth_user_roles_rela(user_id,role_id,create_user,status,created,updated)VALUES(41,3,&apos;kaiyang38@***.cn&apos;,&apos;ACTIVE&apos;,NOW(),NOW()),(41,4,&apos;kaiyang38@***.cn&apos;,&apos;ACTIVE&apos;,NOW(),NOW())INSERT INTO reporting.auth_user_roles_rela(user_id,role_id,create_user,status,created,updated)VALUES(41,21,&apos;zhenxinlin2&apos;,&apos;ACTIVE&apos;,NOW(),NOW()),(41,23,&apos;zhenxinlin2&apos;,&apos;ACTIVE&apos;,NOW(),NOW())</code></pre><p>在角色表中添加新的角色</p><pre><code>INSERT INTO reporting.auth_roles(application_name,department,role_name,layout_id,role_type,role_level,resource_level,description,status,created,updated)VALUES(&apos;platform&apos;,&apos;商通贷&apos;,&apos;platform-FUNCTION&apos;,&apos;47&apos;,&apos;FUNCTION&apos;,1,&apos;HIGHT&apos;, &apos;角色树根节点&apos;,&apos;ACTIVE&apos;,NOW(),NOW()),(&apos;reporting&apos;,&apos;商通贷&apos;,&apos;reporting-FUNCTION&apos;,&apos;47&apos;,&apos;FUNCTION&apos;,1,&apos;HIGHT&apos;, &apos;角色树根节点&apos;,&apos;ACTIVE&apos;,NOW(),NOW())</code></pre><h1 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h1><p>auth_users表，代表的是用户信息，auth_roles代表的是不同的角色信息，</p><p>auth_users_roles_rela代表的是不同用户所具有的角色，</p><p>现在要根据用户账号查询某个用户所具有的所有角色id</p><pre><code>SELECT role_idFROM auth_usersINNER JOIN auth_user_roles_relaON auth_users.id=auth_user_roles_rela.user_idWHERE auth_users.account=&apos;kai.yang&apos;</code></pre><p>根据角色id到auth_role_resources_rela中找到该角色所拥有的资源resource_id<br>    SELECT resource_id<br>    FROM auth_role_resources_rela<br>    WHERE role_id=(<br>      SELECT role_id<br>      FROM auth_users<br>      INNER JOIN auth_user_roles_rela<br>      ON auth_users.id=auth_user_roles_rela.user_id<br>      WHERE auth_users.account=’kai.yang’<br>      )</p><p>根据角色id连接查询auth_resources中的资源名称</p><pre><code>SELECT auth_resources.id,resource_name,resource_type,resource_urlFROM auth_resourcesINNER JOIN auth_role_resources_relaON auth_resources.id=auth_role_resources_rela.resource_idWHERE auth_role_resources_rela.role_id=(  SELECT role_id  FROM auth_users  INNER JOIN auth_user_roles_rela  ON auth_users.id=auth_user_roles_rela.user_id  WHERE auth_users.account=&apos;kai.yang&apos;  )</code></pre><h2 id="注意INNER-JOIN查询的写法"><a href="#注意INNER-JOIN查询的写法" class="headerlink" title="注意INNER JOIN查询的写法"></a>注意INNER JOIN查询的写法</h2><pre><code>先确定主表，仍然使用FROM &lt;表1&gt;的语法；再确定需要连接的表，使用INNER JOIN &lt;表2&gt;的语法；然后确定连接条件，使用ON &lt;条件...&gt;，这里的条件是auth_users.id=auth_user_roles_rela.user_id，表示auth_users表的id列与auth_user_roles_rela表的user_id列相同的行需要连接；可选：加上WHERE子句、ORDER BY等子句。使用别名不是必须的，但可以更好地简化查询语句。</code></pre><h2 id="内连接和外连接的区别："><a href="#内连接和外连接的区别：" class="headerlink" title="内连接和外连接的区别："></a>内连接和外连接的区别：</h2><p>假设查询语句是：</p><pre><code>SELECT ... FROM tableA ??? JOIN tableB ON tableA.column1 = tableB.column2;</code></pre><p>我们把tableA看作左表，把tableB看成右表，那么</p><p><strong><em>INNER JOIN是选出两张表都存在的记录</em></strong></p><p><strong><em>LEFT OUTER JOIN是选出左表存在的记录</em></strong></p><p><strong><em>RIGHT OUTER JOIN是选出右表存在的记录</em></strong></p><p><strong><em>FULL OUTER JOIN则是选出左右表都存在的记录</em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SQL插入，多表查询&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
  </entry>
  
</feed>
