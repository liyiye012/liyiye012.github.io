<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-22T12:33:17.376Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>300. Longest Increasing Subsequence最长上升子序列</title>
    <link href="http://yoursite.com/2018/08/22/300.%20Longest%20Increasing%20Subsequence%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2018/08/22/300. Longest Increasing Subsequence最长上升子序列/</id>
    <published>2018-08-22T12:30:12.000Z</published>
    <updated>2018-08-22T12:33:17.376Z</updated>
    
    <content type="html"><![CDATA[<h1 id="300-Longest-Increasing-Subsequence最长上升子序列"><a href="#300-Longest-Increasing-Subsequence最长上升子序列" class="headerlink" title="300. Longest Increasing Subsequence最长上升子序列"></a>300. Longest Increasing Subsequence最长上升子序列</h1><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><p>示例:</p><p>输入:<br>    [10,9,2,5,3,7,101,18]</p><p>输出: 4 </p><p>解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</p><p>说明:</p><p>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。<br>你算法的时间复杂度应该为 O(n2) 。</p><a id="more"></a><p>进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?</p><h2 id="动态规划解法："><a href="#动态规划解法：" class="headerlink" title="动态规划解法："></a>动态规划解法：</h2><p>首先来看一种动态规划Dynamic Programming的解法，这种解法的时间复杂度为O(n^2)，类似brute force的解法，我们维护一个一维dp数组，其中dp[i]表示以nums[i]为结尾的最长递增子串的长度，对于每一个nums[i]，我们从第一个数再搜索到i，如果发现某个数小于nums[i]，我们更新dp[i]，更新方法为dp[i] = max(dp[i], dp[j] + 1)，即比较当前dp[i]的值和那个小于num[i]的数的dp值加1的大小，我们就这样不断的更新dp数组，到最后dp数组中最大的值就是我们要返回的LIS的长度，参见代码如下：</p><pre><code>class Solution {public:    int lengthOfLIS(vector&lt;int&gt;&amp; nums) {        vector&lt;int&gt; dp(nums.size(),1);        int res=0;        for(int i=0;i&lt;nums.size();i++){            for(int j=0;j&lt;i;j++){                if(nums[i]&gt;nums[j]){                    dp[i]=max(dp[i],dp[j]+1);                }            }            res=max(res,dp[i]);        }        return res;    }};</code></pre><h2 id="进阶：二分查找法"><a href="#进阶：二分查找法" class="headerlink" title="进阶：二分查找法"></a>进阶：二分查找法</h2><p>我们来看一种思路更清晰的二分查找法，跟上面那种方法很类似，思路是先建立一个空的dp数组，然后开始遍历原数组，对于每一个遍历到的数字，我们用二分查找法在dp数组找第一个不小于它的数字，如果这个数字不存在，那么直接在dp数组后面加上遍历到的数字，如果存在，则将这个数字更新为当前遍历到的数字，最后返回dp数字的长度即可.</p><p>特别注意的是dp数组的值可能不是一个真实的LIS。{4， 2， 4， 5， 3， 7}，那么算完后的ends数组为{2， 3， 5， 7}，可以发现它不是一个原数组的LIS，只是长度相等而已参见代码如下：</p><pre><code>class Solution {public:    int lengthOfLIS(vector&lt;int&gt;&amp; nums) {        vector&lt;int&gt; dp;        for(int i=0;i&lt;nums.size();i++){            int left=0,right=dp.size();            while(left&lt;right){                int mid=left+(right-left)/2;                if(dp[mid]&lt;nums[i]) left=mid+1;                else right=mid;            }            if(right&gt;=dp.size()) dp.push_back(nums[i]);            else dp[right]=nums[i];        }        return dp.size();    }};</code></pre><h2 id="进阶：利用lowerbound函数的二分查找法"><a href="#进阶：利用lowerbound函数的二分查找法" class="headerlink" title="进阶：利用lowerbound函数的二分查找法"></a>进阶：利用lowerbound函数的二分查找法</h2><p>还有一种比较tricky的二分查找法，利用到了C++中STL的lower_bound函数，lower_bound返回数组中第一个不小于指定值的元素，跟上面的算法类似，我们还需要一个一维数组v，然后对于遍历到的nums中每一个元素，找其lower_bound，如果没有lower_bound，说明新元素比一维数组的尾元素还要大，直接添加到数组v中，跟之前解法的思路相同了。如果有lower_bound，说明新元素不是最大的，将其lower_bound替换为新元素，这个过程跟之前解法的二分查找法的部分实现相同功能，最后也是返回数组v的长度，注意数组v也不一定是真实的LIS，参见代码如下：</p><pre><code>class Solution {public:    int lengthOfLIS(vector&lt;int&gt;&amp; nums) {        vector&lt;int&gt; dp;        for(auto n:nums){            auto it=lower_bound(dp.begin(),dp.end(),n);            if(it == dp.end()) dp.push_back(n);            else *it=n;        }        return dp.size();    }};</code></pre><h2 id="进阶：利用upperbound函数的二分查找法"><a href="#进阶：利用upperbound函数的二分查找法" class="headerlink" title="进阶：利用upperbound函数的二分查找法"></a>进阶：利用upperbound函数的二分查找法</h2><p>upper_bound是返回数组中第一个大于指定值的元素，和lower_bound的区别时，它不能返回和指定值相等的元素，那么当新进来的数和数组中尾元素一样大时，upper_bound无法返回这个元素，那么按之前算法的处理方法是加到数组中，这样就不是严格的递增子串了，所以我们要做个处理，在处理每个新进来的元素时，先判断数组v中有无此元素，有的话直接跳过，这样就避免了相同数字的情况，参见代码如下：</p><pre><code>class Solution {public:    int lengthOfLIS(vector&lt;int&gt;&amp; nums) {        vector&lt;int&gt; dp;        for(auto n:nums){            if(find(dp.begin(),dp.end(),n)!=dp.end()) continue;            auto it=upper_bound(dp.begin(),dp.end(),n);            if(it==dp.end()) dp.push_back(n);            else *it=n;        }        return dp.size();    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;300-Longest-Increasing-Subsequence最长上升子序列&quot;&gt;&lt;a href=&quot;#300-Longest-Increasing-Subsequence最长上升子序列&quot; class=&quot;headerlink&quot; title=&quot;300. Longest Increasing Subsequence最长上升子序列&quot;&gt;&lt;/a&gt;300. Longest Increasing Subsequence最长上升子序列&lt;/h1&gt;&lt;p&gt;给定一个无序的整数数组，找到其中最长上升子序列的长度。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;p&gt;输入:&lt;br&gt;    [10,9,2,5,3,7,101,18]&lt;/p&gt;
&lt;p&gt;输出: 4 &lt;/p&gt;
&lt;p&gt;解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。&lt;/p&gt;
&lt;p&gt;说明:&lt;/p&gt;
&lt;p&gt;可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。&lt;br&gt;你算法的时间复杂度应该为 O(n2) 。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>C++基础概念I</title>
    <link href="http://yoursite.com/2018/08/21/C++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5I/"/>
    <id>http://yoursite.com/2018/08/21/C++基础概念I/</id>
    <published>2018-08-21T01:58:44.000Z</published>
    <updated>2018-08-22T10:13:35.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-基础概念I"><a href="#C-基础概念I" class="headerlink" title="C++基础概念I"></a>C++基础概念I</h1><p>总结C++基础概念</p><h2 id="1-C-面向对象的三大特征"><a href="#1-C-面向对象的三大特征" class="headerlink" title="1.C++面向对象的三大特征"></a>1.C++面向对象的三大特征</h2><a id="more"></a><h3 id="1-封装"><a href="#1-封装" class="headerlink" title="(1)封装:"></a>(1)封装:</h3><p>将客观事物封装成抽象的类,并且设计者可以对类的成员进行访问控制权限控制. 这样一方面可以做到数据的隐藏,保护数据安全;另一方面,封装可以修改类的内部实现而不用修改调用了该类的用户的代码.同时封装还有利于代码的 方便复用；</p><h3 id="2-继承"><a href="#2-继承" class="headerlink" title="(2)继承:"></a>(2)继承:</h3><h4 id="a"><a href="#a" class="headerlink" title="a."></a>a.</h4><p>继承具有这样一种功能,它可以使用现有类的所有功能；并且可以在不重新编写原有类的情况下对类的功能进行扩展.继承的过程是一般到特殊的过程,即是它们是is-a的关系;基类或父类是一般,而子类或派生类是基类的特殊表现;要实现继承可以通过继承和组合来实现;</p><h4 id="b"><a href="#b" class="headerlink" title="b."></a>b.</h4><p>广义上的继承分成三大类:实现继承:使用基类的属性和方法而无需额外编码的能力;接口继承:接口继承是指仅使用基类的属性和方法的名称,而具体的实现子类必须自己完成的能力;可视继承:子窗体(类)使用父窗体(类)的外观和实现代码的能力;</p><h3 id="3-多态"><a href="#3-多态" class="headerlink" title="(3)多态:"></a>(3)多态:</h3><h4 id="a-1"><a href="#a-1" class="headerlink" title="a."></a>a.</h4><p>多态的实现分成两种,一种是编译时的多态,主要是通过函数重载和运算符重</p><p>另外一种是运行时多态,主要是通过函数覆盖来实现的,它需要满足3个条件:基类函数必须是虚函数,并且基类的指针或引用指向子类的时候,当子类中对原有的虚函数进行重新定义之后形成一个更加严格的重载版本的时候,就会形成多态;它是通过动态联编实现的;</p><h4 id="b-1"><a href="#b-1" class="headerlink" title="b."></a>b.</h4><p>运行时的多态可以让基类的指针或引用指向不同的对象的时候表现出来不同的特性;</p><h2 id="2-简述C-C-程序编译时的内存分配情况"><a href="#2-简述C-C-程序编译时的内存分配情况" class="headerlink" title="2.简述C/C++程序编译时的内存分配情况"></a>2.简述C/C++程序编译时的内存分配情况</h2><h3 id="1-一般一个c-c-程序编译的时候内存布局如下-地址从低到高的顺序"><a href="#1-一般一个c-c-程序编译的时候内存布局如下-地址从低到高的顺序" class="headerlink" title="(1)一般一个c/c++程序编译的时候内存布局如下(地址从低到高的顺序)"></a>(1)一般一个c/c++程序编译的时候内存布局如下(地址从低到高的顺序)</h3><h4 id="a-代码区"><a href="#a-代码区" class="headerlink" title="a.代码区:"></a>a.代码区:</h4><p>存放程序的二进制代码.</p><h4 id="b-常量区"><a href="#b-常量区" class="headerlink" title="b.常量区:"></a>b.常量区:</h4><p>这个区和代码区的距离很近,主要存放一些非局部常量值和字符串字面值,一般不允许修改,程序结束由系统释放;具有常属性并且初始化的全局和静态变量也放在这个区.</p><h4 id="c-数据区"><a href="#c-数据区" class="headerlink" title="c.数据区:"></a>c.数据区:</h4><p>赋过初值的且不具有常属性的静态和全局变量在数据区.它和BSS段统称为静态区;程序结束后由系统释放;</p><h4 id="d-BSS段"><a href="#d-BSS段" class="headerlink" title="d.BSS段:"></a>d.BSS段:</h4><p>没有初始化的静态和全局变量;进程一旦被加载这个区所有的数据都被清0;</p><h4 id="e-堆区"><a href="#e-堆区" class="headerlink" title="e.堆区:"></a>e.堆区:</h4><p>   动态分配的内存;由程序员分配和释放,程序结束的时候如果没有释放,则由OS回收;</p><h4 id="f-栈区"><a href="#f-栈区" class="headerlink" title="f.栈区:"></a>f.栈区:</h4><p>   由编译器自动分配和释放,不使用的时候会自动的释放.主要用来存放非静态的局部变量,函数的参数和返回值, 临时变量等.</p><h4 id="g-命令行参数和环境变量区"><a href="#g-命令行参数和环境变量区" class="headerlink" title="g.命令行参数和环境变量区;"></a>g.命令行参数和环境变量区;</h4><p>下面是对应一段经典的代码:</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;  //unix下的头文件const int const_global = 10; //常全局变量int init_global = 10;        //初始化的全局变量int uninit_global;           //未初始化的全局白能量int main(int argc,char * argv[]){    const static int const_static = 10;//常属性的静态变量，不可以被赋值，初始化    static int init_static = 10;    //初始化静态变量    static int uninit_static;       //未初始化静态变量    const int const_local = 10;    // 常属性的局部变量    int  prev_local = 1;//前局部变量    int  next_local = 5;//后局部变量    int* prev_heap = malloc(sizeof(int));//前面分配的堆变量    int* next_heap = malloc(sizeof(int));//后面分配的堆变量    const char* literal = &quot;literal&quot;;      //字符串字面值，字面值常量    extern char** environ;               // 环境变量    printf(&quot;----地址最高断命令行参数和环境变量-------\n&quot;);    printf(&quot;        环境变量:%p\n&quot;,environ);    printf(&quot;      命令行参数:%p\n&quot;,argv);    printf(&quot;---------------栈区-----------------------\n&quot;);    printf(&quot;      常局部变量:%p\n&quot;,&amp;const_local);    printf(&quot;      前局部变量:%p\n&quot;,&amp;prev_local);    printf(&quot;      后局部变量:%p\n&quot;,&amp;next_local);    printf(&quot;--------------------堆--------------------\n&quot;);    printf(&quot;        前堆变量:%p\n&quot;,prev_heap);    printf(&quot;        后堆变量:%p\n&quot;,next_heap);    printf(&quot;--------------------BSS--------------------\n&quot;);    printf(&quot;未初始化全局变量:%p\n&quot;,&amp;uninit_global);    printf(&quot;未初始化静态变量:%p\n&quot;,&amp;uninit_static);    printf(&quot;----------------数据------------------------\n&quot;);    printf(&quot;  初始化全局变量:%p\n&quot;,&amp;init_static);    printf(&quot;  初始化全局变量:%p\n&quot;,&amp;init_global);    printf(&quot;----------------代码区----------------------\n&quot;);    printf(&quot;     常静态变量:%p\n&quot;,&amp;const_static);    printf(&quot;     字面值常量:%p\n&quot;,&amp;literal);    printf(&quot;     常全局变量:%p\n&quot;,&amp;const_global);    printf(&quot;           函数:%p\n&quot;,main);    return 0;}</code></pre><h3 id="2-从上面可以看出c-c-的内存分配方式主要有三种"><a href="#2-从上面可以看出c-c-的内存分配方式主要有三种" class="headerlink" title="(2)从上面可以看出c/c++的内存分配方式主要有三种"></a>(2)从上面可以看出c/c++的内存分配方式主要有三种</h3><h4 id="a-从静态存储区域分配"><a href="#a-从静态存储区域分配" class="headerlink" title="a.从静态存储区域分配:"></a>a.从静态存储区域分配:</h4><p>   内存在程序编译时已经分配好,这块内存在程序的整个运行期间都存在.速度快,不容易出错.因为由系统会善后.</p><h4 id="b-在栈上分配内存"><a href="#b-在栈上分配内存" class="headerlink" title="b.在栈上分配内存:"></a>b.在栈上分配内存:</h4><p>   在执行函数的时候,函数内非静态局部变量的存储单元都是在栈上创建,函数执行结束的时候这些存储单元自动被释放.栈内存分配内置于处理器的指令集中,效率很高但是分配的内容有限.</p><h4 id="c-从堆中分配内存"><a href="#c-从堆中分配内存" class="headerlink" title="c.从堆中分配内存:"></a>c.从堆中分配内存:</h4><p>即是动态分配内存.程序在运行的时候使用malloc/new申请任意大小的内存,程序员自己负责在何时用free/delete释放内存.动态内存的生存期由程序员决定,使用非常的灵活.如果在堆上分配了内存,就有责任去回收它,否则运行程序会出现内存泄漏,另外频繁的分配和释放不同大小的堆空间将会产生堆内碎片.不易管理;</p><h3 id="3-堆和栈之间的主要的区别是什么"><a href="#3-堆和栈之间的主要的区别是什么" class="headerlink" title="(3)堆和栈之间的主要的区别是什么?"></a>(3)堆和栈之间的主要的区别是什么?</h3><h4 id="a-管理方式不同"><a href="#a-管理方式不同" class="headerlink" title="a.管理方式不同:"></a>a.管理方式不同:</h4><p>栈是由编译器自动分配和释放,使用方便;而对于堆来说,分配和释放都必须由程序员来手动完成,不易管理,容易造成内存泄漏和内存碎片.</p><h4 id="b-可用内存空间不同"><a href="#b-可用内存空间不同" class="headerlink" title="b.可用内存空间不同:"></a>b.可用内存空间不同:</h4><p>对于栈来说,它可用的内存空间比较小;而对于堆来说它可以使用的空间比栈要大的多.</p><h4 id="c-能否产生碎片不同"><a href="#c-能否产生碎片不同" class="headerlink" title="c.能否产生碎片不同:"></a>c.能否产生碎片不同:</h4><p>由于栈采用的是后进先出的机制,所以栈空间没有内存碎片的产生;而对于堆来说,由于频繁的使用new/delete势必会造成内存空间分配的不连续,从而造成大量的碎片,使程序的效率降低.</p><h4 id="d-生长方向不同"><a href="#d-生长方向不同" class="headerlink" title="d.生长方向不同:"></a>d.生长方向不同:</h4><p>对于堆来说,它一般是向上的;即是向着地址增加的方向增长;对于栈来说,它一般是向下的,即向着地址减小的方向增长.</p><h4 id="e-分配的方式不同"><a href="#e-分配的方式不同" class="headerlink" title="e.分配的方式不同:"></a>e.分配的方式不同:</h4><p>对于堆来说,它只能是动态分配的;而对于栈来说,它分为静态分配和动态分配;静态分配由编译器来进行管理,而动态分配的栈和堆也是不一样的,动态分配的栈由编译器进行释放,无需我们程序员来释放.</p><h4 id="f-分配的效率不同"><a href="#f-分配的效率不同" class="headerlink" title="f.分配的效率不同:"></a>f.分配的效率不同:</h4><p>栈是机器系统提供的数据结构,计算机会在底层对栈提供支持:为栈分配专门的寄存器.压栈和出栈都由专门的指令进行.因此它的效率会很高;而堆则是由c/c++库函数实现的,机制是非常的负责的;例如要分配一块内存的时候,库函数会利用特定的算法在堆内存中搜索可用大小的内存空间;如果没有足够大的内存空间,就会调用系统功能去增加数据段的内存空间.这样才能得到足够大的可用的内存空间,因此堆内存的分配的效率比栈要低得多. </p><h3 id="4-new-malloc以及free-delete之间的区别"><a href="#4-new-malloc以及free-delete之间的区别" class="headerlink" title="(4)new/malloc以及free/delete之间的区别"></a>(4)new/malloc以及free/delete之间的区别</h3><h4 id="a-2"><a href="#a-2" class="headerlink" title="a."></a>a.</h4><p>new/delete是运算符,只能在C++中使用,它可以重载;mallloc/free是C的标准库函数,在C/C++中都可以使用.</p><h4 id="b-2"><a href="#b-2" class="headerlink" title="b."></a>b.</h4><p>对于非内部的数据类型的对象而言,光用malloc/free是无法满足动态对象的要求的.对象在创建的时候需要执行构造函数,对象在消亡之前需要执行析构函数.而molloc/free是库函数而不是运算符,不在编译器的控制范围之内,编译器不能将执行构造函数和析构函数的任务强加给malloc/free.因此C++需要一个能够完成动态分配内存和初始化的new,以及一个能够完成清理和释放内存的运算符delete.</p><h4 id="c"><a href="#c" class="headerlink" title="c."></a>c.</h4><p>new的返回值是指定类型的指针,可以自动的计算所需要分配的内存大小.而malloc的返回值是一个void类型的指针,我们在使用的时候要进行强制类型转换,并且分配的大小也要程序员手动的计算.</p><h4 id="d"><a href="#d" class="headerlink" title="d."></a>d.</h4><p>new/delete完全覆盖了malloc/free的功能,只所以还要保留malloc/free,是因为我们的C++程序有时要调用用C编写的而C中又没有new/delete,只能使用malloc/free.</p><h2 id="3-指针和引用之间的区别和联系"><a href="#3-指针和引用之间的区别和联系" class="headerlink" title="3.指针和引用之间的区别和联系"></a>3.指针和引用之间的区别和联系</h2><h3 id="联系"><a href="#联系" class="headerlink" title="联系:"></a>联系:</h3><h4 id="a-3"><a href="#a-3" class="headerlink" title="a."></a>a.</h4><p>指针和引用本质上都是地址的概念,引用在内部其实是用const指针来实现的.</p><h4 id="b-3"><a href="#b-3" class="headerlink" title="b."></a>b.</h4><p>给函数传递参数的时候,一级指针和引用作为函数参数的时候可以达到相同的效果.</p><h4 id="c-1"><a href="#c-1" class="headerlink" title="c."></a>c.</h4><p>指针的大部分效果都可以通过引用来实现。</p><h4 id="d-1"><a href="#d-1" class="headerlink" title="d."></a>d.</h4><p>二级指针作为参数的时候就是希望在函数的内部修改指针的指向.这个时候利用指针的引用可以达到同样的效果.</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别:"></a>区别:</h3><h4 id="a-4"><a href="#a-4" class="headerlink" title="a."></a>a.</h4><p>定义引用的时候必须初始化,定义指针的时候可以不初始化.</p><h4 id="b-4"><a href="#b-4" class="headerlink" title="b."></a>b.</h4><p>引用不能引用空,但是指针可以指向空.</p><h4 id="c-2"><a href="#c-2" class="headerlink" title="c."></a>c.</h4><p>引用的关系一旦确定,就无法改变;引用永远指向的是用来对它初始化的对象;而非常属性的指针是可以改变指向的.</p><h4 id="d-2"><a href="#d-2" class="headerlink" title="d."></a>d.</h4><p>指针是一个实体变量,在32位操作系统上面都是4个字节.而引用只是一个别名,其大小和其应用的对象的类型有关系.</p><h4 id="e"><a href="#e" class="headerlink" title="e."></a>e.</h4><p>有指向指针的指针,但是没有引用引用的引用;因为引用一旦建立,它就表示初始化它的对象.</p><h4 id="f"><a href="#f" class="headerlink" title="f."></a>f.</h4><p>有引用指针的引用,但是没有指向引用的指针；</p><h4 id="g"><a href="#g" class="headerlink" title="g."></a>g.</h4><p>有指针数组,但是没有引用数组,但是有数组的引用.<br>下面是一段代码非常的全面:</p><pre><code>#include &lt;iostream&gt;using namespace std;void foo(int a[3])/*这个地方传递的是数组的首地址*/{     cout &lt;&lt; sizeof(a)/sizeof(a[0]) &lt;&lt; endl;}void bar(int (&amp;a)[3])/*这里传参的时候就是数组的整体*/{     cout &lt;&lt; sizeof(a)/sizeof(a[0]) &lt;&lt; endl;}int main(void){     int a;     int* p = &amp;a;     int** pp = &amp;p;/*存在指向指针的指针*/     int&amp; r  = a;     int&amp;&amp; rr = r;/*error没有引用引用的引用*/     int*&amp;  rp = p; /*有引用指针的引用(指针引用)*/     int&amp;* pr = &amp;r; /*没有指向引用的指针(引用指针)*/     int x, y, z;     int* pa[] = {&amp;x,&amp;y,&amp;z};/*指针数组*/     int&amp; ra[] = {x,y,z};/*引用数组是不存在的因为引用不是一个实体*/     int arr[3] = {0};     int (&amp;ar)[3] = arr;/*数组引用(先近后远,先右后左)*/     foo(arr);/*这里传递的是数组的第一个元素的首地址*/     cout &lt;&lt; sizeof(arr)/sizeof(arr[0]) &lt;&lt; endl;     /*这里的数组名代表的是真个数组*/     int (*parr)[3] = &amp;arr;/*对数组名取地址得到的是一个数组指针                             这个时候arr代表的是数组的整体;*/     bar(arr);/*这里传递的就是数组的整体*/     return 0;}</code></pre><h2 id="4-类和结构体的区别"><a href="#4-类和结构体的区别" class="headerlink" title="4.类和结构体的区别"></a>4.类和结构体的区别</h2><p>结构体在默认情况下的成员都是public的,而类在默认情况下的成员是private的。</p><p>结构体和类都必须使用new创建，struct保证成员按照声明顺序在内存在存储，而类不保证。</p><p>C++结构体的继承默认是public，而c++类的继承默认是private。</p><h2 id="5-C-和C定义结构体区别"><a href="#5-C-和C定义结构体区别" class="headerlink" title="5.C++和C定义结构体区别"></a>5.C++和C定义结构体区别</h2><p>C++中的结构和类其实具备几乎一样的功能，结构体内也是可以声明函数，C++的结构体和类默认具有不一样的访问属性</p><h2 id="6-const常量与define宏定义的区别"><a href="#6-const常量与define宏定义的区别" class="headerlink" title="6.const常量与define宏定义的区别"></a>6.const常量与define宏定义的区别</h2><h3 id="1-编译器处理方式不同。"><a href="#1-编译器处理方式不同。" class="headerlink" title="(1) 编译器处理方式不同。"></a>(1) 编译器处理方式不同。</h3><p>define宏是在预处理阶段展开，生命周期止于编译期。只是一个常数、一个命令中的参数，没有实际的存在。#define常量存在于程序的代码段。const常量是编译运行阶段使用，const常量存在于程序的数据段.</p><h3 id="2-类型和安全检查不同。"><a href="#2-类型和安全检查不同。" class="headerlink" title="(2)类型和安全检查不同。"></a>(2)类型和安全检查不同。</h3><p>define宏没有类型，不做任何类型检查，仅仅是展开。const常量有具体的类型，在编译阶段会执行类型检查。</p><h3 id="3-存储方式不同。"><a href="#3-存储方式不同。" class="headerlink" title="(3)存储方式不同。"></a>(3)存储方式不同。</h3><p>define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。const常量会在内存中分配(可以是堆中也可以是栈中)</p><h2 id="7-memset-memcpy-和strcpy-的根本区别"><a href="#7-memset-memcpy-和strcpy-的根本区别" class="headerlink" title="7.memset ,memcpy 和strcpy 的根本区别"></a>7.memset ,memcpy 和strcpy 的根本区别</h2><p>memset用来对一段内存空间全部设置为某个字符，一般用在对定义的字符串进行初始化为’ ‘或’’；</p><p>它对较大的结构体或数组进行清零操作的一种最快方法。</p><pre><code>char temp[30];     memset(temp,&apos;\0&apos;,sizeof(temp));</code></pre><p>char temp[30]只是分配了一定的内存空间给该字符数组，但并未初始化该内存空间，即数组。所以，需要使用memset()来进行初始化。</p><p>memcpy用来做内存拷贝，你可以拿它拷贝任何数据类型的对象，可以指定拷贝的数据长度；</p><p>strcpy就只能拷贝字符串了，它遇到’\0’就结束拷贝；例如：<br>    char a[100],b[50];strcpy(a,b);</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;C-基础概念I&quot;&gt;&lt;a href=&quot;#C-基础概念I&quot; class=&quot;headerlink&quot; title=&quot;C++基础概念I&quot;&gt;&lt;/a&gt;C++基础概念I&lt;/h1&gt;&lt;p&gt;总结C++基础概念&lt;/p&gt;
&lt;h2 id=&quot;1-C-面向对象的三大特征&quot;&gt;&lt;a href=&quot;#1-C-面向对象的三大特征&quot; class=&quot;headerlink&quot; title=&quot;1.C++面向对象的三大特征&quot;&gt;&lt;/a&gt;1.C++面向对象的三大特征&lt;/h2&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++基础概念II</title>
    <link href="http://yoursite.com/2018/08/21/C++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5II/"/>
    <id>http://yoursite.com/2018/08/21/C++基础概念II/</id>
    <published>2018-08-21T01:58:44.000Z</published>
    <updated>2018-08-22T10:14:14.908Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-基础概念II"><a href="#C-基础概念II" class="headerlink" title="C++基础概念II"></a>C++基础概念II</h1><p>总结C++基础概念</p><h2 id="1-C-的四种强制类型转换关键字，及它们的特点和使用的场合"><a href="#1-C-的四种强制类型转换关键字，及它们的特点和使用的场合" class="headerlink" title="1.C++的四种强制类型转换关键字，及它们的特点和使用的场合"></a>1.C++的四种强制类型转换关键字，及它们的特点和使用的场合</h2><a id="more"></a><p>C语言中的强制类型转换可以随意的转换我们想要的类型了,格式如下</p><pre><code>(类型) 变量名;</code></pre><p>为什么c++还要引入新的4种类型转换呢?</p><p>  这是因为新的类型转换控制符可以很好的控制类型转换的过程,允许控制各种类型不同的转换.</p><p>  还有一点好处是C++的类型转换控制符能告诉程序员或读者我们这个转换的目的是什么,我们<br> 只要看一下代码的类型转换控制符,就能明白我们想要达到什么样的目的.</p><h3 id="1-static-cast-lt-T-gt-content-静态转换-在编译期间处理"><a href="#1-static-cast-lt-T-gt-content-静态转换-在编译期间处理" class="headerlink" title="1)static_cast &lt;T*&gt; (content)  静态转换.在编译期间处理"></a>1)static_cast &lt;T*&gt; (content)  静态转换.在编译期间处理</h3><p>   它主要用于C++中内置的基本数据类型之间的转换.但是没有运行时类型的检测来保证转换的安全性.</p><p>   为什么需要static_cast类型的转换?</p><h4 id="a-用于基类和子类之间的指针或引用的转换。"><a href="#a-用于基类和子类之间的指针或引用的转换。" class="headerlink" title="a.用于基类和子类之间的指针或引用的转换。"></a>a.用于基类和子类之间的指针或引用的转换。</h4><p>这种转换把子类的指针或引用转换为基类表示是安全的;进行下行转换,把基类的指针或引用转换为子类表示时,由于没有进行动态类型检测,所以是不安全的;</p><h4 id="b-把void类型的指针转换成目标类型的指针-不安全"><a href="#b-把void类型的指针转换成目标类型的指针-不安全" class="headerlink" title="b.把void类型的指针转换成目标类型的指针(不安全)."></a>b.把void类型的指针转换成目标类型的指针(不安全).</h4><h4 id="c-用于内置的基本的数据类型之间的转换"><a href="#c-用于内置的基本的数据类型之间的转换" class="headerlink" title="c.用于内置的基本的数据类型之间的转换."></a>c.用于内置的基本的数据类型之间的转换.</h4><h4 id="d-把任何类型的表达式转换成void类型的"><a href="#d-把任何类型的表达式转换成void类型的" class="headerlink" title="d.把任何类型的表达式转换成void类型的."></a>d.把任何类型的表达式转换成void类型的.</h4><p>   注意:static_cast不会转换掉content的const,volatile,__unaligned属性</p><h3 id="2-static-const-lt-T-gt-content-去常转换-编译时执行"><a href="#2-static-const-lt-T-gt-content-去常转换-编译时执行" class="headerlink" title="2)static_const&lt;T*&gt;(content):去常转换;编译时执行;"></a>2)static_const&lt;T*&gt;(content):去常转换;编译时执行;</h3><p>  它主要作用同一个类型之间的去常和添加常属性之间的转换.不能用做不同的类型之间的转换.</p><p>  它可以把一个不是常属性的转换成常属性的,同时它也可以对一个本是常属性的类型进行去常.</p><h3 id="3-dynamic-cast-lt-T-gt-content-动态类型转换-也是向下安全转型-是在运行的时候执行"><a href="#3-dynamic-cast-lt-T-gt-content-动态类型转换-也是向下安全转型-是在运行的时候执行" class="headerlink" title="3)dynamic_cast&lt;T*&gt;(content) 动态类型转换;也是向下安全转型;是在运行的时候执行;"></a>3)dynamic_cast&lt;T*&gt;(content) 动态类型转换;也是向下安全转型;是在运行的时候执行;</h3><p>   通常用于基类和派生类之间的转换.转换时会进行类型安全检查。</p><h4 id="a"><a href="#a" class="headerlink" title="a."></a>a.</h4><p>不能用于内置的基本数据类型之间的转换.</p><h4 id="b"><a href="#b" class="headerlink" title="b."></a>b.</h4><p>dynamic_cast转换成功的话返回的是类的指针或引用,失败返回null;</p><h4 id="c"><a href="#c" class="headerlink" title="c."></a>c.</h4><p>dynamic_cast进行的转换的时候基类中一定要有虚函数,因为只有类中有了虚函数, 才说明它希望让基类指针或引用指向其派生类对象的情况,这样才有意义.这是由于运行时类型检查需要运行时类型的信息,而这些信息存储在虚函数表中.</p><h4 id="d"><a href="#d" class="headerlink" title="d."></a>d.</h4><p>在类的转换时,在类层次间进行转换的时候,dynamic_cast和static_cast进行上行转换的时候效果是一样的；但是在进行下行转换的时候,dynamic_cast会进行类型检查所以它更安全.它可以让指向基类的指针转换为指向其子类的指针或是其兄弟类的指针;</p><h3 id="4-reinterpret-cast-lt-T-gt-content-重解释类型转换"><a href="#4-reinterpret-cast-lt-T-gt-content-重解释类型转换" class="headerlink" title="4)reinterpret_cast&lt;T*&gt;(content)重解释类型转换;"></a>4)reinterpret_cast&lt;T*&gt;(content)重解释类型转换;</h3><p>   它有着和C风格强制类型转换同样的功能;它可以转化任何的内置数据类型为其他的类型, 同时它也可以把任何类型的指针转化为其他的类型;它的机理是对二进制数据进行重新的的解释,不会改变原来的格式,而static_cast会改变原来的格式;</p><h2 id="2-请说出static和const关键字尽可能多的作用"><a href="#2-请说出static和const关键字尽可能多的作用" class="headerlink" title="2.请说出static和const关键字尽可能多的作用"></a>2.请说出static和const关键字尽可能多的作用</h2><h3 id="static关键字至少有下列n个作用："><a href="#static关键字至少有下列n个作用：" class="headerlink" title="static关键字至少有下列n个作用："></a>static关键字至少有下列n个作用：</h3><h4 id="（1）"><a href="#（1）" class="headerlink" title="（1）"></a>（1）</h4><p>函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；</p><h4 id="（2）"><a href="#（2）" class="headerlink" title="（2）"></a>（2）</h4><p>在模块内的static全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；</p><h4 id="（3）"><a href="#（3）" class="headerlink" title="（3）"></a>（3）</h4><p>在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；</p><h4 id="（4）"><a href="#（4）" class="headerlink" title="（4）"></a>（4）</h4><p>在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；</p><h4 id="（5）"><a href="#（5）" class="headerlink" title="（5）"></a>（5）</h4><p>在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。</p><h3 id="const关键字至少有下列n个作用："><a href="#const关键字至少有下列n个作用：" class="headerlink" title="const关键字至少有下列n个作用："></a>const关键字至少有下列n个作用：</h3><h4 id="（1）-1"><a href="#（1）-1" class="headerlink" title="（1）"></a>（1）</h4><p>欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；</p><h4 id="（2）-1"><a href="#（2）-1" class="headerlink" title="（2）"></a>（2）</h4><p>对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；</p><h4 id="（3）-1"><a href="#（3）-1" class="headerlink" title="（3）"></a>（3）</h4><p>在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；</p><h4 id="（4）-1"><a href="#（4）-1" class="headerlink" title="（4）"></a>（4）</h4><p>对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量；</p><h4 id="（5）-1"><a href="#（5）-1" class="headerlink" title="（5）"></a>（5）</h4><p>对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。例如：<br>const classA operator<em>(const classA&amp; a1,const classA&amp; a2);<br>　　operator</em>的返回结果必须是一个const对象。如果不是，这样的变态代码也不会编译出错：</p><p>classA a, b, c;<br>(a <em> b) = c; // 对a</em>b的结果赋值<br>　　操作(a * b) = c显然不符合编程者的初衷，也没有任何意义。</p><p>剖析：<br>　　惊讶吗？小小的static和const居然有这么多功能，我们能回答几个？如果只能回答1~2个，那还真得闭关再好好修炼修炼。</p><p>　　这个题可以考查面试者对程序设计知识的掌握程度是初级、中级还是比较深入，没有一定的知识广度和深度，不可能对这个问题给出全面的解答。大多数人只能回答出static和const关键字的部分功能。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;C-基础概念II&quot;&gt;&lt;a href=&quot;#C-基础概念II&quot; class=&quot;headerlink&quot; title=&quot;C++基础概念II&quot;&gt;&lt;/a&gt;C++基础概念II&lt;/h1&gt;&lt;p&gt;总结C++基础概念&lt;/p&gt;
&lt;h2 id=&quot;1-C-的四种强制类型转换关键字，及它们的特点和使用的场合&quot;&gt;&lt;a href=&quot;#1-C-的四种强制类型转换关键字，及它们的特点和使用的场合&quot; class=&quot;headerlink&quot; title=&quot;1.C++的四种强制类型转换关键字，及它们的特点和使用的场合&quot;&gt;&lt;/a&gt;1.C++的四种强制类型转换关键字，及它们的特点和使用的场合&lt;/h2&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+github搭建个人博客问题总结</title>
    <link href="http://yoursite.com/2018/08/21/Hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/08/21/Hexo+github搭建个人博客问题总结/</id>
    <published>2018-08-21T01:58:44.000Z</published>
    <updated>2018-08-22T10:14:19.065Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Hexo-github搭建个人博客问题总结"><a href="#Hexo-github搭建个人博客问题总结" class="headerlink" title="Hexo+github搭建个人博客问题总结"></a>Hexo+github搭建个人博客问题总结</h4><p>总结Hexo+github搭建个人博客过程中两个费时较长的问题及其解决方法</p><a id="more"></a><h2 id="问题1：本地同时配置多个github账号导致博客部署失败"><a href="#问题1：本地同时配置多个github账号导致博客部署失败" class="headerlink" title="问题1：本地同时配置多个github账号导致博客部署失败"></a>问题1：本地同时配置多个github账号导致博客部署失败</h2><p>因为本地同时配置有两个github账号，在Hexo+github搭建个人博客部署到账号A成功后用相同方式部署到账号B时执行hexo d时出现问题</p><pre><code>remote: Permission to B/B.github.io.git denied to A.fatal: unable to access &apos;https://github.com/B/B.github.io.git/&apos;: The requested URL returned error: 403FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: remote: Permission to B/B.github.io.git denied to A.fatal: unable to access &apos;https://github.com/B/B.github.io.git/&apos;: The requested URL returned error: 403</code></pre><p>原因是在缺省设置下，github page只有该page对应的账号A才能push，为了解决该问题，在hexo的 _config.yml部署的repo地址改用ssh而不是用https，同时对ssh地址做Host别名替换，原有repo地址为repository: <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:Name/Name.github.io.git，替换为repository: git@B:Name/Name.github.io.git。<br>在原有的~.ssh\config中配置内容如下：</p><pre><code># 该配置用于账户AHost A # Host 服务器别名HostName github.com  # HostName 服务器ip地址或机器名User A # User连接服务器的用户名IdentityFile C:\Users\yiye\.ssh\id_rsa # IdentityFile 密匙文件的具体路径# 该配置用于账户BHost B # Host 服务器别名HostName github.com # HostName 服务器ip地址或机器名User B # User连接服务器的用户名IdentityFile C:\Users\yiye\.ssh\id_rsa_new # IdentityFile 密匙文件的具体路径</code></pre><p>这样ssh解析的时候就会自动把B转换为 github.com，push的时候系统就会根据不同的仓库地址使用不同的账号提交</p><h2 id="问题2：历史删除文件仍存在于repository中"><a href="#问题2：历史删除文件仍存在于repository中" class="headerlink" title="问题2：历史删除文件仍存在于repository中"></a>问题2：历史删除文件仍存在于repository中</h2><p>原本删除的文件仍存在于生成的blog\public中，这是因为没有执行hexo clean命令</p><h2 id="问题3：Hexo-deploy-发布不成功"><a href="#问题3：Hexo-deploy-发布不成功" class="headerlink" title="问题3：Hexo deploy 发布不成功"></a>问题3：Hexo deploy 发布不成功</h2><p>始终停留在</p><pre><code>nothing to commit (working directory clean)</code></pre><p>Hexo的issue中有提到这个问题哦，原因就是第一次设置错了，然后即使正确设置 Repository 再次 Deploy 的时候它也会报错：nothing to commit, working directory clean；error: src refspec master does not match any。所以，当重新设置 Repo 的时候要把 .deploy_git/ 文件夹删掉，让 Hexo 再次初始化，否则 Hexo 只是执行 push 操作，所以会一直报错。解决方法是删除.deploy_git</p><pre><code>rm -rf .deploy_githexo generaterhexo deploy</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Hexo-github搭建个人博客问题总结&quot;&gt;&lt;a href=&quot;#Hexo-github搭建个人博客问题总结&quot; class=&quot;headerlink&quot; title=&quot;Hexo+github搭建个人博客问题总结&quot;&gt;&lt;/a&gt;Hexo+github搭建个人博客问题总结&lt;/h4&gt;&lt;p&gt;总结Hexo+github搭建个人博客过程中两个费时较长的问题及其解决方法&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="Github" scheme="http://yoursite.com/tags/Github/"/>
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>股票交易问题通解小结</title>
    <link href="http://yoursite.com/2018/08/21/%E8%82%A1%E7%A5%A8%E4%BA%A4%E6%98%93%E9%97%AE%E9%A2%98%E9%80%9A%E8%A7%A3%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2018/08/21/股票交易问题通解小结/</id>
    <published>2018-08-21T01:58:44.000Z</published>
    <updated>2018-08-22T10:14:24.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="股票交易问题通解小结"><a href="#股票交易问题通解小结" class="headerlink" title="股票交易问题通解小结"></a>股票交易问题通解小结</h1><p>本文的主要部分来自于leetcode讨论区,后面加上了一点个人的理解和扩展延伸，Leetcode中的股票交易问题共有下列几道：</p><a id="more"></a><pre><code>121.Best Time to Buy and Sell Stock122.Best Time to Buy and Sell Stock II123.Best Time to Buy and Sell Stock III188.Best Time to Buy and Sell Stock IV309.Best Time to Buy and Sell Stock with Cooldown714.Best Time to Buy and Sell Stock with Transaction Fee</code></pre><h2 id="I-–常见情况"><a href="#I-–常见情况" class="headerlink" title="I –常见情况"></a>I –常见情况</h2><p>本文的想法来自于下列的问题：给定一个代表每天股票价格的数组，是什么决定了我们能得到的最大利润？</p><p>大多数人会很快产生类似“那取决于我们处在第几天和我们被允许最多完成多少次交易”。</p><p>当然，这些是重要的因素因为它们在问题描述中就被显示出来。然而，在判断最大利润中有一个隐含因素不是那么明显但却至关重要，它将在下文中被阐述出来。</p><p>首先让我们确定符号来简化我们的分析，令prices作为长度为n的股票价格数组，i标记为第i天（i会从0到n-1)，k标记为被允许完成的最大交易次数,T[i][k]是在第i天的结尾经过最多k次交易所能获得的最大利润。很明显我们有基准情况：T[-1][k]=T[i][0]=0, 那就是没有股票或者没有交易导致没有利润（标记第1天为i=0因此i=0意味着没有股票）。</p><p>现在如果我们能够把T[i][k]和它的子问题T[i-1][k],T[i][k-1],T[i-1][k-1],…，我们会有一个可行的递推关系式<br>使得问题能够递归解决，所以我们怎样实现它呢？<br>最常见的直接方式是看第i天的行动，我们有多少种选择方式？答案是三种：买，卖，休息。我们应该采取哪种呢？</p><p>答案是：我们并不真的知道，但是可以去找哪一种最简单。假设没有其它的约束，我们可以尝试每种选择然后选择使得我们利润最大的一种。</p><p>可是我们确实有一个额外的约束，就是不能在同一时间进行重复交易，意味着如果我们决定在第i天购买，那么我们手中就应该不持有股票；如果我们决定在第i天出售，我们手中应该恰好有一只股票。我们手中<br>的股票数量是上文中提到的会影响我们第i天行为的因素同时也会影响最大利润。</p><p>因此我们对T[i][k]的定义应该被分割成两部分:T[i][k][0]和T[i][k][1],前者标记在最多k次交易和行动后我们手中没有股票的情况下第i天结尾时的最大利润，后者标记在最多k次交易和行动后我们手中只有一只股票的情况下第i天结尾时的最大利润，现在基准情况和递推关系可以被写作：</p><h3 id="1-基准情况："><a href="#1-基准情况：" class="headerlink" title="1.基准情况："></a>1.基准情况：</h3><pre><code>T[-1][k][0]=0, T[-1][k][1]=-InfinityT[i][0][0]=0, T[i][0][1]=-Infinity</code></pre><h3 id="2-递推关系："><a href="#2-递推关系：" class="headerlink" title="2.递推关系："></a>2.递推关系：</h3><pre><code>T[i][k][0]=max(T[i-1][k][0],T[i-1][k][1]+prices[i])T[i][k][1]=max(T[i-1][k][1],T[i-1][k-1][0]-prices[i])</code></pre><p>对于基准情况，T[-1][k][0] = T[i][0][0] = 0有同样的含义正如之前当T[-1][k][1] = T[i][0][1] = -Infinity强调了事实对于我们来说如果没有可获得的股票或不被允许交易那么就不可能手中有一只股票。</p><p>对于递推式中的T[i][k][0]，在第i天能采取的行动只有休息和卖，因为我们在一天结束时手中没有股票。T[i-1][k][0]是当采取行动休息时的最大利润，<br>而T[i-1][k][1] + prices[i]则是当行动卖被采取时的最大利润。</p><p>如果最大被允许的交易次数保持不变，由于一次交易包含两种成对的行为-买和卖。只有行为买会改变被允许的最大交易次数。（此处还有一种替代的解释）<br>对于递推式中的T[i][k][1]，在第i天能采取的行动只有休息和买，因为我们在一天结束时手中只有一只股票。T[i-1][k][1]是当采取行动休息时的最大利润，而T[i-1][k-1][0] - prices[i]是当采取购买行为时的最大利润。要注意被允许的最大交易次数会减一，因为在第i天的购买行为会使用掉一次交易次数。</p><p>为了找到最后一天结束时的最大利润，我们能够简化循环通过数组prices并且通过上面的递推关系式更新T[i][k][0]和T[i][k][1]。最终的答案是T[i][k][0]（我们总是有更大的利润如果我们以手中0只股票结束）</p><h2 id="II-–-对特殊情况的应用"><a href="#II-–-对特殊情况的应用" class="headerlink" title="II – 对特殊情况的应用"></a>II – 对特殊情况的应用</h2><p>前面提及的六种股票问题能够被k的值分类，k是被允许的最大交易次数（最后两个也有额外的要求例如冷却期或者交易费）。我会一个接一个的把通用解应用到这些问题上。</p><h3 id="情况I：k-1"><a href="#情况I：k-1" class="headerlink" title="情况I：k=1"></a>情况I：k=1</h3><p>对于这个情况，我们在每天都真的有两个未知变量：T[i][1][0]和T[i][1][1]，递推关系式表示：</p><pre><code>T[i][1][0] = max(T[i-1][1][0], T[i-1][1][1] + prices[i])T[i][1][1] = max(T[i-1][1][1], T[i-1][0][0] - prices[i]) = max(T[i-1][1][1], -prices[i])</code></pre><p>在第二个方程中我们充分利用了基准情况T[i][0][0]=0。<br>很容易直接写出O(n)时间复杂度和O(n)空间复杂度的解，基于上面的两个方程。可是，如果你注意到在第i天的最大利润事实上只依赖于那些在第i-1天的利润，<br>那么空间复杂度降为O(1)。这是空间最优的解法：</p><pre><code>public int maxProfit(int[] prices){    int T_i10=0,T_i11=Integer.MIN_VALUE;    for(int price:prices){        T_i10=Math.max(T_i10,T_i11 + price);        T_i11=Math.max(T_i11,-price);    }    return T_i10;}</code></pre><h3 id="情况-II-k-Infinity"><a href="#情况-II-k-Infinity" class="headerlink" title="情况 II: k=+Infinity"></a>情况 II: k=+Infinity</h3><p>如果k是正无穷的，那么在k和k-1之间没有任何真正区别，暗示了T[i-1][k-1][0] = T[i-1][k][0]和T[i-1][k-1][1] = T[i-1][k][1]，因此我们仍然在每天有两个未知变量：T[i][k][0]和T[i][k][1]，k=+Infinity,递推关系式如下：</p><pre><code>T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])T[i][k][1] = max(T[i-1][k][1], T[i-1][k-1][0] - prices[i]) = max(T[i-1][k][1], T[i-1][k][0] - prices[i])</code></pre><p>在第二个方程中我们会充分利用T[i-1][k-1][0] = T[i-1][k][0]，O(n)时间复杂度和O(1)空间复杂度的解法如下：</p><pre><code>public int maxProfit(int[] prices) {    int T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;    for (int price : prices) {        int T_ik0_old = T_ik0;        T_ik0 = Math.max(T_ik0, T_ik1 + price);        T_ik1 = Math.max(T_ik1, T_ik0_old - price);    }    return T_ik0;}</code></pre><p>(注意: 旧值缓存的T_ik0,是变量T_ik0_old,是不可能的，特别感谢0x0101和elvina澄清这一点）</p><p>这个解法提出了一种贪心的策略来获取最大利润：只要可能，在每个最小值出买股票然后在下一个局部最大值时迅速卖出。这等同于在prices中找到递增子序列，在每个子序列中的开头买入，在每个子序列的结尾卖出。这很容易展示这等同于只要有利可图时就积累利润，如<a href="https://discuss.leetcode.com/topic/726/is-this-question-a-joke中提到的。" target="_blank" rel="noopener">https://discuss.leetcode.com/topic/726/is-this-question-a-joke中提到的。</a></p><h3 id="情况-III-k-2"><a href="#情况-III-k-2" class="headerlink" title="情况 III: k=2"></a>情况 III: k=2</h3><p>与k=1的情况类似，除了现在我们每天有四个而不是两个变量：T[i][1][0], T[i][1][1], T[i][2][0], T[i][2][1]，递推关系式如下：</p><pre><code>T[i][2][0] = max(T[i-1][2][0], T[i-1][2][1] + prices[i])T[i][2][1] = max(T[i-1][2][1], T[i-1][1][0] - prices[i])T[i][1][0] = max(T[i-1][1][0], T[i-1][1][1] + prices[i])T[i][1][1] = max(T[i-1][1][1], -prices[i])</code></pre><p>在最后一个方程中我们充分利用了基准情况T[i][0][0]=0，下列解有O(n)的空间复杂度和O(1)</p><pre><code>public int maxProfit(int[] prices) {    int T_i10 = 0, T_i11 = Integer.MIN_VALUE, T_i20 = 0, T_i21 = Integer.MIN_VALUE;    for (int price : prices) {        T_i20 = Math.max(T_i20, T_i21 + price);        T_i21 = Math.max(T_i21, T_i10 - price);        T_i10 = Math.max(T_i10, T_i11 + price);        T_i11 = Math.max(T_i11, -price);    }    return T_i20;}</code></pre><h3 id="情况-IV：-k是任意的"><a href="#情况-IV：-k是任意的" class="headerlink" title="情况 IV： k是任意的"></a>情况 IV： k是任意的</h3><p>这是最通用的情况所以在每天我们都需要更新所有的有不同k值的最大利润对应在每天结尾时我们手中有0或1只股票。</p><p>可是，有一个微小的优化我们能够做的是如果k超出了一些临界值，超出了最大的利润不再依赖于允许交易的次数而是被可获得的股票数量限制（prices数组的长度），让我们计算出临界值会是什么。</p><p>一个获利交易花费至少两天（一天买另一天卖，买入价格不少于卖出价格)，如果prices数组的长度是n，最大的获利交易数量是n/2，在这之后没有可能的获益交易，<br>这暗示着最大的利润会保持不变。</p><p>因此，临界k值是n/2，如果给定的k值不小于这个值的时候，换句话说，k&gt;=n/2，我们能够把k拓展到正无穷，问题等价于情况II。</p><p>下列是时间复杂度为O(kn)，空间复杂度O(k)的解，没有优化，代码能够满足大K值时的时间约束。</p><pre><code>public int maxProfit(int k, int[] prices) {    if (k &gt;= prices.length &gt;&gt;&gt; 1) {    int T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;    for (int price : prices) {    int T_ik0_old = T_ik0;    T_ik0 = Math.max(T_ik0, T_ik1 + price);    T_ik1 = Math.max(T_ik1, T_ik0_old - price);    }    return T_ik0;}    int[] T_ik0 = new int[k + 1];    int[] T_ik1 = new int[k + 1];    Arrays.fill(T_ik1, Integer.MIN_VALUE);    for (int price : prices) {        for (int j = k; j &gt; 0; j--) {            T_ik0[j] = Math.max(T_ik0[j], T_ik1[j] + price);            T_ik1[j] = Math.max(T_ik1[j], T_ik0[j - 1] - price);        }    }    return T_ik0[k];}</code></pre><p>解法类似于<a href="https://discuss.leetcode.com/topic/8984/a-concise-dp-solution-in-java帖子中的解法，这里我使用了T数组的反向循环来避免使用临时变量。它也被证明不使用临时变量做前向循环也是可能的。" target="_blank" rel="noopener">https://discuss.leetcode.com/topic/8984/a-concise-dp-solution-in-java帖子中的解法，这里我使用了T数组的反向循环来避免使用临时变量。它也被证明不使用临时变量做前向循环也是可能的。</a></p><h3 id="情况-V：k-Infinity-有冷却期"><a href="#情况-V：k-Infinity-有冷却期" class="headerlink" title="情况 V：k=+Infinity 有冷却期"></a>情况 V：k=+Infinity 有冷却期</h3><p>这个例子相似于情况II更多是由于他们有同样的k值，除了递推式需要简单的修改来满足冷却期的要求。情况II中给出的原始递推式是：</p><pre><code>T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])T[i][k][1] = max(T[i-1][k][1], T[i-1][k][0] - prices[i])</code></pre><p>  但是由于冷却期，我们不能在第i天买入股票如果在第i-1天股票被卖出，因此，在上面的第二个方程中，我们事实上应该用T[i-2][k][0]而不是T[i-1][k][0]<br>如果我们打算在第i天买。其他所有都保持不变并且新的递推式是：</p><pre><code>T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])T[i][k][1] = max(T[i-1][k][1], T[i-2][k][0] - prices[i])</code></pre><p>下面是O（n）时间复杂度和O（1）空间复杂度的解法：</p><pre><code>public int maxProfit(int[] prices) {    int T_ik0_pre = 0, T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;    for (int price : prices) {        int T_ik0_old = T_ik0;        T_ik0 = Math.max(T_ik0, T_ik1 + price);        T_ik1 = Math.max(T_ik1, T_ik0_pre - price);        T_ik0_pre = T_ik0_old;    }    return T_ik0;}</code></pre><p>dietpepsi分享了一种非常好的解法，被证明和上述方法相同<a href="https://discuss.leetcode.com/topic/30421/share-my-thinking-process" target="_blank" rel="noopener">https://discuss.leetcode.com/topic/30421/share-my-thinking-process</a></p><h3 id="情况-VI-k-Infinity-但有交易费用"><a href="#情况-VI-k-Infinity-但有交易费用" class="headerlink" title="情况 VI:k=+Infinity 但有交易费用"></a>情况 VI:k=+Infinity 但有交易费用</h3><p>再一次的这个例子等同于情况ＩＩ因为它们有同样的ｋ值，除了现在的递推关系式需要轻微修改来满足交易费的要求。情况ＩＩ给出的原始递推关系式如下：</p><pre><code>T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])T[i][k][1] = max(T[i-1][k][1], T[i-1][k][0] - prices[i])</code></pre><p>因为现在我们需要为每次的交易行为付费，在第ｉ天的购买和出售股票获利中应该减去这个值，因此新的递推关系式应该为下面的任意一种：</p><pre><code>T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])T[i][k][1] = max(T[i-1][k][1], T[i-1][k][0] - prices[i] - fee)</code></pre><p>或</p><pre><code>T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i] - fee)T[i][k][1] = max(T[i-1][k][1], T[i-1][k][0] - prices[i])</code></pre><p>注意当我们减去费用时我们有两个选项，这是因为每次交易都会表征为两个成对出现的行为－－买和卖<br>费用能够被支付当我们买股票（第一组方程）或当我们卖股票（第二组方程），下列是Ｏ(n)时间复杂度和Ｏ(1)空间复杂度的解法对应于这两项选择，第二个解法我们需要注意可能的溢出。</p><h4 id="解法I－－当买入股票时支付交易费"><a href="#解法I－－当买入股票时支付交易费" class="headerlink" title="解法I－－当买入股票时支付交易费"></a>解法I－－当买入股票时支付交易费</h4><pre><code>public int maxProfit(int[] prices, int fee) {    int T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;    for (int price : prices) {        int T_ik0_old = T_ik0;        T_ik0 = Math.max(T_ik0, T_ik1 + price);        T_ik1 = Math.max(T_ik1, T_ik0_old - price - fee);    }    return T_ik0;}</code></pre><h4 id="解法II－－当售出股票时支付交易费"><a href="#解法II－－当售出股票时支付交易费" class="headerlink" title="解法II－－当售出股票时支付交易费"></a>解法II－－当售出股票时支付交易费</h4><pre><code>public int maxProfit(int[] prices, int fee) {    long T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;    for (int price : prices) {        long T_ik0_old = T_ik0;        T_ik0 = Math.max(T_ik0, T_ik1 + price - fee);        T_ik1 = Math.max(T_ik1, T_ik0_old - price);    }    return (int)T_ik0;}</code></pre><h1 id="III延伸拓展"><a href="#III延伸拓展" class="headerlink" title="III延伸拓展"></a>III延伸拓展</h1><p>在121. Best Time to Buy and Sell Stock中也可以将其转换成求最大子列和的问题，对于原数组，如果我们将arr[i]-arr[i-1]，也就是股票某日与前一日价格差，依次排列成一个数组，那么所求问题的答案就变成了求这个新数组的最大子列和。</p><p>在求解最大子列和问题时，使用Kadane算法。算法复杂度O（N）,kadane算法利用了数学归纳法的思想。简而言之，给定一个现成的数组，比如说−2, 1, −3, 4, −1, 2, 1, −5, 4，求其中的最大子列和，并不是容易的事情。但如果我们能从第一个数开始，随着数组的扩充，始终对其最大子列和保持跟踪，就可以求出任意一个数组的最大子列和。</p><p>详细的分析一下，往一个长度为i的数组后面插入第i+1个数，这时，数组的最大子列只有两种情况，要么包括第i+1个数，要么不包括第i+1个数。</p><p>即：<br>maxsubarraum = max(以第i+1个数结尾的子列和， 不以第i+1个数结尾的子列和)。</p><p>先计算前者，以第i+1个数结尾的子列和怎么算呢？很简单，要么它是以第i个数结尾的子列作为前缀，要么它不以之作为前缀。假设第i+1个数为x，那么：<br>以第i+1个数结尾的子列和 = max（x，以第i个数结尾的子列和+x)。</p><p>对于kadane算法的扩展还可以见于<code>hihocoder#1800 : 玩具设计师</code>一题中求二维数组的最大矩形和</p><h1 id="IV－－总结"><a href="#IV－－总结" class="headerlink" title="IV－－总结"></a>IV－－总结</h1><p> 总之，最通用的股票问题解法能够被表征为三个因素，ｉ天的序号，最大允许的交易次数ｋ和每天结束后我们手中持有的股票数。</p><p>上文已经展示了最大利润和他们终止情况的递推式，Ｏ(nk)时间复杂度和Ｏ(k)空间复杂度。结果被依次应用于六个例子，后两个由于额外的要求做了轻微的修改。<a href="https://discuss.leetcode.com/user/peterleetcode也介绍了一个很好的解法对于任意k值通用。如果有兴趣可以继续看一下。" target="_blank" rel="noopener">https://discuss.leetcode.com/user/peterleetcode也介绍了一个很好的解法对于任意k值通用。如果有兴趣可以继续看一下。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;股票交易问题通解小结&quot;&gt;&lt;a href=&quot;#股票交易问题通解小结&quot; class=&quot;headerlink&quot; title=&quot;股票交易问题通解小结&quot;&gt;&lt;/a&gt;股票交易问题通解小结&lt;/h1&gt;&lt;p&gt;本文的主要部分来自于leetcode讨论区,后面加上了一点个人的理解和扩展延伸，Leetcode中的股票交易问题共有下列几道：&lt;/p&gt;
    
    </summary>
    
      <category term="2018年8月" scheme="http://yoursite.com/categories/2018%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>前言</title>
    <link href="http://yoursite.com/2017/11/16/%E5%89%8D%E8%A8%80/"/>
    <id>http://yoursite.com/2017/11/16/前言/</id>
    <published>2017-11-16T13:14:20.000Z</published>
    <updated>2018-08-22T10:48:55.651Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>附上最近感触很深的一段话作为博客的序章</p><p>　　生命过程中能否成就事业，关键要看意志力的性质和力量，这一点比其他任何因素都来得重要．整天呼喊着＂给我机会，给我机会＂的人本质上是脆弱的，甚至是不堪一击的，因为在能够主宰一切的意志力面前，机会多得数不胜数．平庸和默默无闻很大程度上都是自己造成的，要抱怨只能抱怨自己．</p><a id="more"></a><p>　　格莱斯顿对＂平凡的人＂抱着极高的期望，他真诚的写道：＂从某种意义上说，世界上的每个人与生俱来就具备成就非凡业绩的素质，每个人都是如此．不只是那些天资聪颖，才华横溢的人，也不只是那些敏捷伶俐，遇事沉着的人，能够成就事业；那些木讷寡言，不善圆通的人，甚至那些资质鲁钝，反应迟缓的人，也能成就事业．＂<br>　　每一位受过教育的正常人都在心里深深地明白，在人生的旅途中只要采取适当的行为，就容易使自己成为了不起的人－－至少可以赢得某种程度的成功．但是，＂放松和惰性＂是事物的自然法则，他往往逐渐地屈服于这条法则的支配，慢慢地消磨了自己的棱角和锋芒，变得胸无大志，得过且过．他变得慵懒闲散，再也不能因为心中的高尚目标而受到激励，去发奋实现自己的梦想．然而，正是在这个时候，意志力应该一刻不停地发挥作用．</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;附上最近感触很深的一段话作为博客的序章&lt;/p&gt;
&lt;p&gt;　　生命过程中能否成就事业，关键要看意志力的性质和力量，这一点比其他任何因素都来得重要．整天呼喊着＂给我机会，给我机会＂的人本质上是脆弱的，甚至是不堪一击的，因为在能够主宰一切的意志力面前，机会多得数不胜数．平庸和默默无闻很大程度上都是自己造成的，要抱怨只能抱怨自己．&lt;/p&gt;
    
    </summary>
    
      <category term="2017年11月" scheme="http://yoursite.com/categories/2017%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="blog" scheme="http://yoursite.com/tags/blog/"/>
    
  </entry>
  
</feed>
