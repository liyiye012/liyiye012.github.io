<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-10-10T08:45:01.402Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指 offer38.字符串的排列</title>
    <link href="http://yoursite.com/2020/10/10/%E5%89%91%E6%8C%87%20offer38.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
    <id>http://yoursite.com/2020/10/10/剑指 offer38.字符串的排列/</id>
    <published>2020-10-10T08:20:12.000Z</published>
    <updated>2020-10-10T08:45:01.402Z</updated>
    
    <content type="html"><![CDATA[<p>输入一个字符串，打印出该字符串中字符的所有排列。</p><a id="more"></a><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><p>示例:</p><pre><code>输入：s = &quot;abc&quot;输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</code></pre><p>限制：</p><pre><code>1 &lt;= s 的长度 &lt;= 8</code></pre><h1 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h1><p><strong>排列方案数量：</strong> 对于一个长度为 <em>n</em> 的字符串（假设字符互不重复），其排列共有 n<em>(n-1)</em>(n-2)<em>…</em>2*1种方案。</p><p><strong>排列方案的生成方法：</strong> 根据字符串排列的特点，考虑深度优先搜索所有排列方案。即通过字符交换，先固定第 <em>1</em> 位字符（ <em>n</em> 种情况）、再固定第 <em>2</em> 位字符（ <em>n-1</em> 种情况）、… 、最后固定第 <em>n</em> 位字符（ <em>1</em> 种情况）。</p><p><a href="https://pic.leetcode-cn.com/dc4659dbda6d54f50a8c897647fb7c52e2b8200e741c4d6e25306dfe51f93bb6-Picture1.png" target="_blank" rel="noopener">Picture1.png</a></p><p><strong>重复方案与剪枝：</strong> 当字符串存在重复字符时，排列方案中也存在重复方案。为排除重复方案，需在固定某位字符时，保证 “每种字符只在此位固定一次” ，即遇到重复字符时不交换，直接跳过。从 DFS 角度看，此操作称为 “剪枝” 。</p><p><a href="https://pic.leetcode-cn.com/edbbe4db611791ca63e582e8b0c754261e8d7464edace38420ce3087eb96d9a5-Picture2.png" target="_blank" rel="noopener">Picture2.png</a></p><h2 id="递归解析："><a href="#递归解析：" class="headerlink" title="递归解析："></a>递归解析：</h2><ol><li><strong>终止条件：</strong> 当 <em>x = len(c) - 1</em>  时，代表所有位已固定（最后一位只有 <em>1</em> 种情况），则将当前组合 <code>c</code> 转化为字符串并加入 <code>res</code>，并返回；</li><li><strong>递推参数：</strong> 当前固定位 <em>x</em> ；</li><li><strong>递推工作：</strong> 初始化一个 Set ，用于排除重复的字符；将第 <em>x</em> 位字符与 i∈[x,len(c)]  字符分别交换，并进入下层递归；<ol><li><strong>剪枝：</strong> 若 <em>c[i]</em> 在 Set​ 中，代表其是重复字符，因此“剪枝”；</li><li>将 <em>c[i]</em> 加入 Set​ ，以便之后遇到重复字符时剪枝；</li><li><strong>固定字符：</strong> 将字符 <em>c[i]</em> 和 <em>c[x]</em> 交换，即固定 <em>c[i]</em> 为当前位字符；</li><li><strong>开启下层递归：</strong> 调用 <em>dfs(x + 1)</em> ，即开始固定第 <em>x + 1</em> 个字符；</li><li><strong>还原交换：</strong> 将字符 <em>c[i]</em> 和 <em>c[x]</em> 交换（还原之前的交换）；</li></ol></li></ol><blockquote><p>下图中 <code>list</code> 对应文中的列表 <em>c</em> 。</p></blockquote><p> <a href="https://pic.leetcode-cn.com/03ef0cdb9aa977a26d66bac91c5aa4b8bcaf612c7a90d47afd5b2774d2e7c63f-Picture3.png" target="_blank" rel="noopener">Picture3.png</a> <a href="https://pic.leetcode-cn.com/23190801938902294ce223fdec6e2b14b57c0050341dd2cd9909e5388d4fa4b6-Picture4.png" target="_blank" rel="noopener">Picture4.png</a> <a href="https://pic.leetcode-cn.com/5c71c17efa89114eee4d31678af45cefac82b0fad2a78c3887662463d10cfc83-Picture5.png" target="_blank" rel="noopener">Picture5.png</a> <a href="https://pic.leetcode-cn.com/a9d78bf7bdd7356d5c87392b731a98dc7012bb07c8a2bcde983abe7957bfde0a-Picture6.png" target="_blank" rel="noopener">Picture6.png</a> <a href="https://pic.leetcode-cn.com/546998a83a0832f3eed25ee69d1186ebcc23d238d0f45892feb02afd02bcaae9-Picture7.png" target="_blank" rel="noopener">Picture7.png</a> <a href="https://pic.leetcode-cn.com/405326ab9eccefe10fa18255704d0820ade5dd9b328a73b061634cfde8d059bd-Picture8.png" target="_blank" rel="noopener">Picture8.png</a> <a href="https://pic.leetcode-cn.com/59159c4b72187e1a4a52bebcd2b225a602badba483ef563114c9b1a7d694b0bf-Picture9.png" target="_blank" rel="noopener">Picture9.png</a> <a href="https://pic.leetcode-cn.com/d0e959953dcf93557e14cc037a0a1b62e60b3c0e3e38ca6b01f8acd06d4e5ea4-Picture10.png" target="_blank" rel="noopener">Picture10.png</a> <a href="https://pic.leetcode-cn.com/f34d4f405b2fb355fcad12d2c7818716b02ff78504e82be2343a1f7e75424eb3-Picture11.png" target="_blank" rel="noopener">Picture11.png</a> <a href="https://pic.leetcode-cn.com/58700b824790d48fe907fa6740f53d747e01cdd6d9c4b01cd60cad0135278d99-Picture12.png" target="_blank" rel="noopener">Picture12.png</a> <a href="https://pic.leetcode-cn.com/83dabfa3d9c04601ee53989ba410069153e841403584739140a499e8c4f3d8e1-Picture13.png" target="_blank" rel="noopener">Picture13.png</a> <a href="https://pic.leetcode-cn.com/337e2cdad2bcf4fd801ae2d4e5ab8a1c3ef8f30008d2b0fadde6aad7c87fd640-Picture14.png" target="_blank" rel="noopener">Picture14.png</a> <a href="https://pic.leetcode-cn.com/ba18b921c78d58e1f1c6fa55a939cbd4a2a9652c31f6c3088219565b70dc3b19-Picture15.png" target="_blank" rel="noopener">Picture15.png</a> <a href="https://pic.leetcode-cn.com/25d13a660956672f9d3b3a1fa87ddac8194fda6e58d7c354799d6421c61fab61-Picture16.png" target="_blank" rel="noopener">Picture16.png</a> <a href="https://pic.leetcode-cn.com/3efd2969a04b993303229c7e58a635fe3d018a84086b36e486f458d8f87d54cf-Picture17.png" target="_blank" rel="noopener">Picture17.png</a> </p><h2 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h2><ul><li><strong>时间复杂度 <em>O(N!)</em> ：</strong> <em>N</em> 为字符串 <code>s</code> 的长度；时间复杂度和字符串排列的方案数成线性关系，方案数为n<em>(n-1)</em>(n-2)<em>…<em>2</em>1 ，因此复杂度为 *O(N!)</em> 。</li><li><strong>空间复杂度 <em>O(N^2)</em> ：</strong> 全排列的递归深度为 <em>N</em> ，系统累计使用栈空间大小为 <em>O(N)</em> ；递归中辅助 Set 累计存储的字符数量最多为 <em>N + (N-1) + … + 2 + 1 = (N+1)N/2</em> ，即占用 <em>O(N^2)</em> 的额外空间。</li></ul><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class="line">        c, res = list(s), []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(x)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> x == len(c) - <span class="number">1</span>:</span><br><span class="line">                res.append(<span class="string">''</span>.join(c)) <span class="comment"># 添加排列方案</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dic = set()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(x, len(c)):</span><br><span class="line">                <span class="keyword">if</span> c[i] <span class="keyword">in</span> dic: <span class="keyword">continue</span> <span class="comment"># 重复，因此剪枝</span></span><br><span class="line">                dic.add(c[i])</span><br><span class="line">                c[i], c[x] = c[x], c[i] <span class="comment"># 交换，将 c[i] 固定在第 x 位</span></span><br><span class="line">                dfs(x + <span class="number">1</span>) <span class="comment"># 开启固定第 x + 1 位字符</span></span><br><span class="line">                c[i], c[x] = c[x], c[i] <span class="comment"># 恢复交换</span></span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">char</span>[] c;</span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">        c = s.toCharArray();</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> String[res.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == c.length - <span class="number">1</span>) &#123;</span><br><span class="line">            res.add(String.valueOf(c)); <span class="comment">// 添加排列方案</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashSet&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt; c.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(c[i])) <span class="keyword">continue</span>; <span class="comment">// 重复，因此剪枝</span></span><br><span class="line">            set.add(c[i]);</span><br><span class="line">            swap(i, x); <span class="comment">// 交换，将 c[i] 固定在第 x 位 </span></span><br><span class="line">            dfs(x + <span class="number">1</span>); <span class="comment">// 开启固定第 x + 1 位字符</span></span><br><span class="line">            swap(i, x); <span class="comment">// 恢复交换</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> tmp = c[a];</span><br><span class="line">        c[a] = c[b];</span><br><span class="line">        c[b] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;输入一个字符串，打印出该字符串中字符的所有排列。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年10月" scheme="http://yoursite.com/categories/2020%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Coding Interviews" scheme="http://yoursite.com/tags/Coding-Interviews/"/>
    
  </entry>
  
  <entry>
    <title>14. 最长公共前缀</title>
    <link href="http://yoursite.com/2020/10/09/14.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
    <id>http://yoursite.com/2020/10/09/14. 最长公共前缀/</id>
    <published>2020-10-09T07:52:12.000Z</published>
    <updated>2020-10-09T09:20:41.843Z</updated>
    
    <content type="html"><![CDATA[<p>编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串””。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot;</code></pre><p>示例 2:</p><pre><code>输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。</code></pre><p>说明:</p><pre><code>所有输入只包含小写字母 a-z 。</code></pre><h1 id="📺-视频题解"><a href="#📺-视频题解" class="headerlink" title="📺 视频题解"></a>📺 视频题解</h1><p><a href="8edae0a8-6480-4128-8244-9f10b83e7cf6">14 最长公共前缀.mp4</a></p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="方法一：横向扫描"><a href="#方法一：横向扫描" class="headerlink" title="方法一：横向扫描"></a>方法一：横向扫描</h2><p>用 LCP(S1,…,Sn) 表示字符串S1,…,Sn 的最长公共前缀。</p><p>可以得到以下结论：</p><pre><code>LCP(S1,...,Sn)=LCP(LCP(LCP(S1,S2),S3),...Sn)</code></pre><p>基于该结论，可以得到一种查找字符串数组中的最长公共前缀的简单方法。依次遍历字符串数组中的每个字符串，对于每个遍历到的字符串，更新最长公共前缀，当遍历完所有的字符串以后，即可得到字符串数组中的最长公共前缀。</p><p><a href="https://assets.leetcode-cn.com/solution-static/14/14_fig1.png" target="_blank" rel="noopener">fig1</a></p><p>如果在尚未遍历完所有的字符串时，最长公共前缀已经是空串，则最长公共前缀一定是空串，因此不需要继续遍历剩下的字符串，直接返回空串即可。</p><details>    <summary>横向扫描Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String prefix = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> count = strs.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; i++) &#123;</span><br><span class="line">            prefix = longestCommonPrefix(prefix, strs[i]);</span><br><span class="line">            <span class="keyword">if</span> (prefix.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = Math.min(str1.length(), str2.length());</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; length &amp;&amp; str1.charAt(index) == str2.charAt(index)) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str1.substring(<span class="number">0</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>横向扫描C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!strs.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> prefix = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> count = strs.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            prefix = longestCommonPrefix(prefix, strs[i]);</span><br><span class="line">            <span class="keyword">if</span> (!prefix.size()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str1, <span class="keyword">const</span> <span class="built_in">string</span>&amp; str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = min(str1.size(), str2.size());</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; length &amp;&amp; str1[index] == str2[index]) &#123;</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str1.substr(<span class="number">0</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>横向扫描Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: List[str])</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        </span><br><span class="line">        prefix, count = strs[<span class="number">0</span>], len(strs)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, count):</span><br><span class="line">            prefix = self.lcp(prefix, strs[i])</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> prefix:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> prefix</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lcp</span><span class="params">(self, str1, str2)</span>:</span></span><br><span class="line">        length, index = min(len(str1), len(str2)), <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> index &lt; length <span class="keyword">and</span> str1[index] == str2[index]:</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> str1[:index]</span><br></pre></td></tr></table></figure></details><details>    <summary>横向扫描Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestCommonPrefix</span><span class="params">(strs []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(strs) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">    prefix := strs[<span class="number">0</span>]</span><br><span class="line">    count := <span class="built_in">len</span>(strs)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; count; i++ &#123;</span><br><span class="line">        prefix = lcp(prefix, strs[i])</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(prefix) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prefix</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lcp</span><span class="params">(str1, str2 <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    length := min(<span class="built_in">len</span>(str1), <span class="built_in">len</span>(str2))</span><br><span class="line">    index := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> index &lt; length &amp;&amp; str1[index] == str2[index] &#123;</span><br><span class="line">        index++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str1[:index]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(mn)*，其中 *m</em> 是字符串数组中的字符串的平均长度，<em>n</em> 是字符串的数量。最坏情况下，字符串数组中的每个字符串的每个字符都会被比较一次。</p></li><li><p>空间复杂度：<em>O(1)</em>。使用的额外空间复杂度为常数。</p></li></ul><h2 id="方法二：纵向扫描"><a href="#方法二：纵向扫描" class="headerlink" title="方法二：纵向扫描"></a>方法二：纵向扫描</h2><p>方法一是横向扫描，依次遍历每个字符串，更新最长公共前缀。另一种方法是纵向扫描。纵向扫描时，从前往后遍历所有字符串的每一列，比较相同列上的字符是否相同，如果相同则继续对下一列进行比较，如果不相同则当前列不再属于公共前缀，当前列之前的部分为最长公共前缀。</p><p><a href="https://assets.leetcode-cn.com/solution-static/14/14_fig2.png" target="_blank" rel="noopener">fig2</a></p><details>    <summary>纵向扫描Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = strs[<span class="number">0</span>].length();</span><br><span class="line">        <span class="keyword">int</span> count = strs.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = strs[<span class="number">0</span>].charAt(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; count; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == strs[j].length() || strs[j].charAt(i) != c) &#123;</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>纵向扫描C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!strs.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = strs[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> count = strs.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = strs[<span class="number">0</span>][i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; count; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == strs[j].size() || strs[j][i] != c) &#123;</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>].substr(<span class="number">0</span>, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>纵向扫描Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: List[str])</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        </span><br><span class="line">        length, count = len(strs[<span class="number">0</span>]), len(strs)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">            c = strs[<span class="number">0</span>][i]</span><br><span class="line">            <span class="keyword">if</span> any(i == len(strs[j]) <span class="keyword">or</span> strs[j][i] != c <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, count)):</span><br><span class="line">                <span class="keyword">return</span> strs[<span class="number">0</span>][:i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></details><details>    <summary>纵向扫描Golang</summary><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestCommonPrefix</span><span class="params">(strs []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(strs) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(strs[<span class="number">0</span>]); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; <span class="built_in">len</span>(strs); j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> i == <span class="built_in">len</span>(strs[j]) || strs[j][i] != strs[<span class="number">0</span>][i] &#123;</span><br><span class="line">                <span class="keyword">return</span> strs[<span class="number">0</span>][:i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strs[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(mn)*，其中 *m</em> 是字符串数组中的字符串的平均长度，<em>n</em> 是字符串的数量。最坏情况下，字符串数组中的每个字符串的每个字符都会被比较一次。</p></li><li><p>空间复杂度：<em>O(1)</em>。使用的额外空间复杂度为常数。</p></li></ul><h2 id="方法三：分治"><a href="#方法三：分治" class="headerlink" title="方法三：分治"></a>方法三：分治</h2><p>注意到 LCP 的计算满足结合律，有以下结论：</p><pre><code>LCP(S1,...,Sn)=LCP(LCP(S1...SK) , LCP(SK+1...Sn))</code></pre><p>其中 LCP(S1,…,Sn) 是字符串 S1,…,Sn 的最长公共前缀，<em>1 &lt; k &lt; n</em>。</p><p>基于上述结论，可以使用分治法得到字符串数组中的最长公共前缀。对于问题LCP(Si…Sj) ，可以分解成两个子问题 LCP(si…Smid)与LCP(Smid+1…Sj)，其中 mid=(i+j)/2 。对两个子问题分别求解，然后对两个子问题的解计算最长公共前缀，即为原问题的解。</p><p><a href="https://assets.leetcode-cn.com/solution-static/14/14_fig3.png" target="_blank" rel="noopener">fig3</a></p><details>    <summary>分治Java</summary><figure class="highlight java"><figcaption><span>[sol3-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> longestCommonPrefix(strs, <span class="number">0</span>, strs.length - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">            <span class="keyword">return</span> strs[start];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (end - start) / <span class="number">2</span> + start;</span><br><span class="line">            String lcpLeft = longestCommonPrefix(strs, start, mid);</span><br><span class="line">            String lcpRight = longestCommonPrefix(strs, mid + <span class="number">1</span>, end);</span><br><span class="line">            <span class="keyword">return</span> commonPrefix(lcpLeft, lcpRight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">commonPrefix</span><span class="params">(String lcpLeft, String lcpRight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minLength = Math.min(lcpLeft.length(), lcpRight.length());       </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; minLength; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lcpLeft.charAt(i) != lcpRight.charAt(i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> lcpLeft.substring(<span class="number">0</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lcpLeft.substring(<span class="number">0</span>, minLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>分治C++</summary><figure class="highlight c++"><figcaption><span>[sol3-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!strs.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> longestCommonPrefix(strs, <span class="number">0</span>, strs.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">            <span class="keyword">return</span> strs[start];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">string</span> lcpLeft = longestCommonPrefix(strs, start, mid);</span><br><span class="line">            <span class="built_in">string</span> lcpRight = longestCommonPrefix(strs, mid + <span class="number">1</span>, end);</span><br><span class="line">            <span class="keyword">return</span> commonPrefix(lcpLeft, lcpRight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">commonPrefix</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; lcpLeft, <span class="keyword">const</span> <span class="built_in">string</span>&amp; lcpRight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minLength = min(lcpLeft.size(), lcpRight.size());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; minLength; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lcpLeft[i] != lcpRight[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> lcpLeft.substr(<span class="number">0</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lcpLeft.substr(<span class="number">0</span>, minLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>分治Python3</summary><figure class="highlight python"><figcaption><span>[sol3-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: List[str])</span> -&gt; str:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">lcp</span><span class="params">(start, end)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> start == end:</span><br><span class="line">                <span class="keyword">return</span> strs[start]</span><br><span class="line"></span><br><span class="line">            mid = (start + end) // <span class="number">2</span></span><br><span class="line">            lcpLeft, lcpRight = lcp(start, mid), lcp(mid + <span class="number">1</span>, end)</span><br><span class="line">            minLength = min(len(lcpLeft), len(lcpRight))</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(minLength):</span><br><span class="line">                <span class="keyword">if</span> lcpLeft[i] != lcpRight[i]:</span><br><span class="line">                    <span class="keyword">return</span> lcpLeft[:i]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> lcpLeft[:minLength]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span> <span class="keyword">if</span> <span class="keyword">not</span> strs <span class="keyword">else</span> lcp(<span class="number">0</span>, len(strs) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure></details><details>    <summary>分治Golang</summary><figure class="highlight golang"><figcaption><span>[sol3-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestCommonPrefix</span><span class="params">(strs []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(strs) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> lcp <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function">    <span class="title">lcp</span> = <span class="title">func</span><span class="params">(start, end <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> start == end &#123;</span><br><span class="line">            <span class="keyword">return</span> strs[start]</span><br><span class="line">        &#125;</span><br><span class="line">        mid := (start + end) / <span class="number">2</span></span><br><span class="line">        lcpLeft, lcpRight := lcp(start, mid), lcp(mid + <span class="number">1</span>, end)</span><br><span class="line">        minLength := min(<span class="built_in">len</span>(lcpLeft), <span class="built_in">len</span>(lcpRight))</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; minLength; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> lcpLeft[i] != lcpRight[i] &#123;</span><br><span class="line">                <span class="keyword">return</span> lcpLeft[:i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lcpLeft[:minLength]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lcp(<span class="number">0</span>, <span class="built_in">len</span>(strs)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>**复杂度分析**<ul><li><p>时间复杂度：<em>O(mn)*，其中 *m</em> 是字符串数组中的字符串的平均长度，<em>n</em> 是字符串的数量。时间复杂度的递推式是 T(n)=2T(n/2)+O(m)，通过计算可得 <em>T(n)=O(mn)</em>。</p></li><li><p>空间复杂度：O(mlogn) ，其中 <em>m</em> 是字符串数组中的字符串的平均长度，<em>n</em> 是字符串的数量。空间复杂度主要取决于递归调用的层数，层数最大为 logn，每层需要 <em>m</em> 的空间存储返回结果。</p></li></ul><h2 id="方法四：二分查找"><a href="#方法四：二分查找" class="headerlink" title="方法四：二分查找"></a>方法四：二分查找</h2><p>显然，最长公共前缀的长度不会超过字符串数组中的最短字符串的长度。用 minLength表示字符串数组中的最短字符串的长度，则可以在 [0,minLength] 的范围内通过二分查找得到最长公共前缀的长度。每次取查找范围的中间值mid，判断每个字符串的长度为 mid 的前缀是否相同，如果相同则最长公共前缀的长度一定大于或等于 mid，如果不相同则最长公共前缀的长度一定小于 mid ，通过上述方式将查找范围缩小一半，直到得到最长公共前缀的长度。</p><p><a href="https://assets.leetcode-cn.com/solution-static/14/14_fig4.png" target="_blank" rel="noopener">fig4</a></p><details>    <summary>二分查找Java</summary><figure class="highlight java"><figcaption><span>[sol4-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> minLength = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">            minLength = Math.min(minLength, str.length());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = minLength;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (high - low + <span class="number">1</span>) / <span class="number">2</span> + low;</span><br><span class="line">            <span class="keyword">if</span> (isCommonPrefix(strs, mid)) &#123;</span><br><span class="line">                low = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>, low);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCommonPrefix</span><span class="params">(String[] strs, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        String str0 = strs[<span class="number">0</span>].substring(<span class="number">0</span>, length);</span><br><span class="line">        <span class="keyword">int</span> count = strs.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; i++) &#123;</span><br><span class="line">            String str = strs[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (str0.charAt(j) != str.charAt(j)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>二分查找C++</summary><figure class="highlight c++"><figcaption><span>[sol4-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!strs.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> minLength = min_element(strs.begin(), strs.end(), [](<span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="keyword">const</span> <span class="built_in">string</span>&amp; t) &#123;<span class="keyword">return</span> s.size() &lt; t.size();&#125;)-&gt;size();</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = minLength;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (high - low + <span class="number">1</span>) / <span class="number">2</span> + low;</span><br><span class="line">            <span class="keyword">if</span> (isCommonPrefix(strs, mid)) &#123;</span><br><span class="line">                low = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>].substr(<span class="number">0</span>, low);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isCommonPrefix</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str0 = strs[<span class="number">0</span>].substr(<span class="number">0</span>, length);</span><br><span class="line">        <span class="keyword">int</span> count = strs.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            <span class="built_in">string</span> str = strs[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (str0[j] != str[j]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>二分查找Python3</summary><figure class="highlight python"><figcaption><span>[sol4-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: List[str])</span> -&gt; str:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isCommonPrefix</span><span class="params">(length)</span>:</span></span><br><span class="line">            str0, count = strs[<span class="number">0</span>][:length], len(strs)</span><br><span class="line">            <span class="keyword">return</span> all(strs[i][:length] == str0 <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, count))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line"></span><br><span class="line">        minLength = min(len(s) <span class="keyword">for</span> s <span class="keyword">in</span> strs)</span><br><span class="line">        low, high = <span class="number">0</span>, minLength</span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            mid = (high - low + <span class="number">1</span>) // <span class="number">2</span> + low</span><br><span class="line">            <span class="keyword">if</span> isCommonPrefix(mid):</span><br><span class="line">                low = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high = mid - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>][:low]</span><br></pre></td></tr></table></figure></details><details>    <summary>二分查找Golang</summary><figure class="highlight golang"><figcaption><span>[sol4-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestCommonPrefix</span><span class="params">(strs []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(strs) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isCommonPrefix := <span class="function"><span class="keyword">func</span><span class="params">(length <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        str0, count := strs[<span class="number">0</span>][:length], <span class="built_in">len</span>(strs)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; count; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> strs[i][:length] != str0 &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    minLength := <span class="built_in">len</span>(strs[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> _, s := <span class="keyword">range</span> strs &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt; minLength &#123;</span><br><span class="line">            minLength = <span class="built_in">len</span>(s)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    low, high := <span class="number">0</span>, minLength</span><br><span class="line">    <span class="keyword">for</span> low &lt; high &#123;</span><br><span class="line">        mid := (high - low + <span class="number">1</span>) / <span class="number">2</span> + low</span><br><span class="line">        <span class="keyword">if</span> isCommonPrefix(mid) &#123;</span><br><span class="line">            low = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strs[<span class="number">0</span>][:low]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>**复杂度分析**<ul><li><p>时间复杂度：O(mnlogm)，其中 <em>m</em> 是字符串数组中的字符串的最小长度，<em>n</em> 是字符串的数量。二分查找的迭代执行次数是 O(logm)  ，每次迭代最多需要比较 <em>mn</em> 个字符，因此总时间复杂度是O(mnlogm) 。</p></li><li><p>空间复杂度：<em>O(1)</em>。使用的额外空间复杂度为常数。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串””。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年10月" scheme="http://yoursite.com/categories/2020%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>567. 字符串的排列</title>
    <link href="http://yoursite.com/2020/10/09/567.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
    <id>http://yoursite.com/2020/10/09/567. 字符串的排列/</id>
    <published>2020-10-09T07:52:12.000Z</published>
    <updated>2020-10-10T07:12:25.325Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。</p><a id="more"></a><p>换句话说，第一个字符串的排列之一是第二个字符串的子串。</p><p>示例1:</p><pre><code>输入: s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;输出: True解释: s2 包含 s1 的排列之一 (&quot;ba&quot;).</code></pre><p>示例2:</p><pre><code>输入: s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;输出: False</code></pre><p>注意：</p><pre><code>输入的字符串只包含小写字母两个字符串的长度都在 [1, 10,000] 之间</code></pre><h1 id="方法一-暴力-超过时间限制"><a href="#方法一-暴力-超过时间限制" class="headerlink" title="方法一 暴力 [超过时间限制]"></a>方法一 暴力 [超过时间限制]</h1><p><strong>算法</strong></p><p>最简单的方法是生成短字符串的所有排列，并检查生成的排列是否是较长字符串的子字符串。</p><p>为了生成所有可能的配对，我们使用函数<code>permute（string_1，string_2，current_index）</code>。此函数创建短字符串 <em>s1</em> 的所有可能排列。</p><p>为此，permute将当前元素 <em>current_index</em> 的索引作为参数之一。然后，它将当前元素与数组中的每个其他元素交换，向右移动，以便生成数组元素的新排序。完成交换后，它会再次调用置换，但这次使用数组中下一个元素的索引。返回时，我们反转当前函数调用中的交换。</p><p>因此，当我们到达数组的末尾时，会生成数组元素的新排序。以下动画描述了生成排列的过程。</p><p> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide1.PNG" target="_blank" rel="noopener">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide2.PNG" target="_blank" rel="noopener">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide3.PNG" target="_blank" rel="noopener">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide4.PNG" target="_blank" rel="noopener">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide5.PNG" target="_blank" rel="noopener">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide6.PNG" target="_blank" rel="noopener">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide7.PNG" target="_blank" rel="noopener">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide8.PNG" target="_blank" rel="noopener">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide9.PNG" target="_blank" rel="noopener">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide10.PNG" target="_blank" rel="noopener">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide11.PNG" target="_blank" rel="noopener">1200</a> </p><details>    <summary>暴力</summary><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        permute(s1, s2, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">swap</span><span class="params">(String s, <span class="keyword">int</span> i0, <span class="keyword">int</span> i1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i0 == i1)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        String s1 = s.substring(<span class="number">0</span>, i0);</span><br><span class="line">        String s2 = s.substring(i0 + <span class="number">1</span>, i1);</span><br><span class="line">        String s3 = s.substring(i1 + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> s1 + s.charAt(i1) + s2 + s.charAt(i0) + s3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">permute</span><span class="params">(String s1, String s2, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == s1.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s2.indexOf(s1) &gt;= <span class="number">0</span>)</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; s1.length(); i++) &#123;</span><br><span class="line">                s1 = swap(s1, l, i);</span><br><span class="line">                permute(s1, s2, l + <span class="number">1</span>);</span><br><span class="line">                s1 = swap(s1, l, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n!)*。我们将 *s1</em> 的短字符串 <em>s1</em> 的所有排列与 <em>s2</em> 匹配。这里，<em>n</em> 指的是 <em>s1</em> 的长度。</p></li><li><p>空间复杂度：<em>O(n^2)<em>。递归树的深度是 *n</em>（*n</em> 是指短字符串 <em>s1</em> 的长度）。递归树的每个节点都包含一个 max 的字符串。长度 <em>n</em>。</p></li></ul><hr><h2 id="方法二-排序-超过时间限制"><a href="#方法二-排序-超过时间限制" class="headerlink" title="方法二 排序 [超过时间限制]:"></a>方法二 排序 [超过时间限制]:</h2><p><strong>算法</strong></p><p>这种方法背后的想法是，只有当两个字符串包含相同次数的相同字符时，一个字符串才是另一个字符串的排列。只有<em>sorted(x)= sorted(y)<em>时，一个字符串</em>x*才​​是其他字符串 *y</em> 的排列。</p><p>为了检查这一点，我们可以对两个字符串进行排序并进行比较。我们对短字符串 <em>s1</em> 和 <em>s2</em> 的所有子字符串进行排序，对它们进行排序并将它们与排序的 <em>s1</em> 字符串进行比较。如果两者完全匹配，<em>s1</em> 的排列是 <em>s2</em> 的子字符串，否则不是。</p><details>    <summary>排序</summary><figure class="highlight java"><figcaption><span>[solution2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        s1 = sort(s1);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s2.length() - s1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.equals(sort(s2.substring(i, i + s1.length()))))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sort</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] t = s.toCharArray();</span><br><span class="line">        Arrays.sort(t);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(l1log(l1)+(l2-l1)l1log(l1))。其中 <em>l_1</em> 是字符串 <em>l_1</em> 的长度，<em>l_2</em> 是字符串 <em>l_2</em> 的长度。</p></li><li><p>空间复杂度：<em>O(l_1)*。使用了 *t</em> 数组。</p></li></ul><hr><h2 id="方法三-使用哈希表-超过时间限制"><a href="#方法三-使用哈希表-超过时间限制" class="headerlink" title="方法三 使用哈希表 [超过时间限制]"></a>方法三 使用哈希表 [超过时间限制]</h2><p><strong>算法</strong></p><p>如上所述，只有当两个字符串包含具有相同频率的相同字符时，一个字符串才是另一个字符串的排列。我们可以考虑与 <em>s1</em> 长度相同的长字符串 <em>s2</em> 中的每个可能的子字符串，并检查出现在两者中的字符出现的频率。如果每个字母的频率完全匹配，则只有 <em>s1</em> 的排列可以是 <em>s2</em> 的子字符串。</p><p>为了实现这种方法，我们不使用排序然后比较元素的相等性，而是使用一个哈希表 <em>s1map*来存储短字符串 *s1</em> 中所有字符的出现频率。我们考虑 <em>s2</em> 的每个可能的子串，其长度与 <em>s1</em> 的长度相同，也可以找到相应的哈希表，即 <em>s2map*。因此，所考虑的子字符串可以被视为一个长度窗口，如 *s1</em> 迭代超过 <em>s2*。如果获得的两个哈希表对于任何这样的窗口是相同的，我们可以得出结论 *s1</em> 的排列是 <em>s2</em> 的子字符串，否则不是。</p><details>    <summary>使用哈希表</summary><figure class="highlight java"><figcaption><span>[solution3-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        s1 = sort(s1);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s2.length() - s1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.equals(sort(s2.substring(i, i + s1.length()))))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sort</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] t = s.toCharArray();</span><br><span class="line">        Arrays.sort(t);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(l_1+26*l_1</em>(l_2-l_1))<em>。这个哈希表包含最多26个键。其中 *l_1</em> 是字符串 <em>l_1</em> 的长度，<em>l_2</em> 是字符串 <em>l_2</em> 的长度。</li><li>空间复杂度：<em>O(1)</em>。表包含最多 26 个键值对。</li></ul><hr><h2 id="方法四-使用数组-通过"><a href="#方法四-使用数组-通过" class="headerlink" title="方法四 使用数组 [通过]"></a>方法四 使用数组 [通过]</h2><p><strong>算法</strong></p><p>我们可以使用更简单的数组数据结构来存储频率，而不是仅使用特殊的哈希表数据结构来存储字符出现的频率。给定字符串仅包含小写字母（’a’到’z’）。因此我们需要采用大小为 26 的数组。其余过程与最后一种方法保持一致。</p><details>    <summary>使用数组</summary><figure class="highlight java"><figcaption><span>[solution-4]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length() &gt; s2.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span>[] s1map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++)</span><br><span class="line">            s1map[s1.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s2.length() - s1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] s2map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s1.length(); j++) &#123;</span><br><span class="line">                s2map[s2.charAt(i + j) - <span class="string">'a'</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (matches(s1map, s2map))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(<span class="keyword">int</span>[] s1map, <span class="keyword">int</span>[] s2map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1map[i] != s2map[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><ul><li><p>时间复杂度：<em>O(l_1+26*l_1</em>(l_2-l_1))<em>。其中 *l_1</em> 是字符串 <em>l_1</em> 的长度，<em>l_2</em> 是字符串 <em>l_2</em> 的长度。</p></li><li><p>空间复杂度：<em>O(1)*。使用 *s1map</em> 和 <em>s2map</em>，大小为 26。</p></li></ul><hr><h2 id="方法五-滑动窗口-通过"><a href="#方法五-滑动窗口-通过" class="headerlink" title="方法五 滑动窗口  [通过]:"></a>方法五 滑动窗口  [通过]:</h2><p><strong>算法</strong></p><p>我们可以为 <em>s2</em> 中的第一个窗口创建一次哈希表，而不是为 <em>s2</em> 中考虑的每个窗口重新生成哈希表。然后，稍后当我们滑动窗口时，我们知道我们添加了一个前面的字符并将新的后续字符添加到所考虑的新窗口中。因此，我们可以通过仅更新与这两个字符相关联的索引来更新哈希表。同样，对于每个更新的哈希表，我们将哈希表的所有元素进行比较以获得所需的结果。</p><details>    <summary>使用数组</summary><figure class="highlight java"><figcaption><span>[solution5-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length() &gt; s2.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span>[] s1map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span>[] s2map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">            s1map[s1.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">            s2map[s2.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s2.length() - s1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matches(s1map, s2map))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            s2map[s2.charAt(i + s1.length()) - <span class="string">'a'</span>]++;</span><br><span class="line">            s2map[s2.charAt(i) - <span class="string">'a'</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matches(s1map, s2map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(<span class="keyword">int</span>[] s1map, <span class="keyword">int</span>[] s2map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1map[i] != s2map[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度分析：<em>O(l_1+26</em>(l_2-l_1))<em>。其中 *l_1</em> 是字符串 <em>l_1</em> 的长度，<em>l_2</em> 是字符串 <em>l_2</em> 的长度。</p></li><li><p>空间复杂度：<em>O(1)</em>。常数级空间。</p></li></ul><hr><h2 id="方法六-优化的滑动窗口-通过"><a href="#方法六-优化的滑动窗口-通过" class="headerlink" title="方法六 优化的滑动窗口 [通过]:"></a>方法六 优化的滑动窗口 [通过]:</h2><p><strong>算法</strong></p><p>上一种方法可以优化，如果不是比较每个更新的 <em>s2map</em> 的哈希表的所有元素，而是对应于 <em>s2</em> 考虑的每个窗口，我们会跟踪先前哈希表中已经匹配的元素数量当我们向右移动窗口时，只更新匹配元素的数量。</p><p>为此，我们维护一个 <em>count</em> 变量，该变量存储字符数（26个字母表中的数字），这些字符在 <em>s1</em> 中具有相同的出现频率，当前窗口在 <em>s2</em> 中。当我们滑动窗口时，如果扣除最后一个元素并添加新元素导致任何字符的新频率匹配，我们将 <em>count</em> 递增1.如果不是，我们保持 <em>count</em> 完整。但是，如果添加频率相同的字符（添加和删除之前）相同的字符，现在会导致频率不匹配，这会通过递减相同的 <em>count</em> 变量来考虑。如果在移动窗口后，<em>count</em> 的计算结果为26，则表示所有字符的频率完全匹配。所以，我们立即返回一个True。</p><details>    <summary>使用数组</summary><figure class="highlight java"><figcaption><span>[solution6-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length() &gt; s2.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span>[] s1map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span>[] s2map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">            s1map[s1.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">            s2map[s2.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (s1map[i] == s2map[i])</span><br><span class="line">                count++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s2.length() - s1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = s2.charAt(i + s1.length()) - <span class="string">'a'</span>, l = s2.charAt(i) - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">26</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            s2map[r]++;</span><br><span class="line">            <span class="keyword">if</span> (s2map[r] == s1map[r])</span><br><span class="line">                count++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s2map[r] == s1map[r] + <span class="number">1</span>)</span><br><span class="line">                count--;</span><br><span class="line">            s2map[l]--;</span><br><span class="line">            <span class="keyword">if</span> (s2map[l] == s1map[l])</span><br><span class="line">                count++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s2map[l] == s1map[l] - <span class="number">1</span>)</span><br><span class="line">                count--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(l_1+(l_2-l_1))*。其中 *l_1</em> 是字符串 <em>l_1</em> 的长度，<em>l_2</em> 是字符串 <em>l_2</em> 的长度。</p></li><li><p>空间复杂度：<em>O(1)</em>。常数级的空间。</p></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年10月" scheme="http://yoursite.com/categories/2020%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>3. 无重复字符的最长子串</title>
    <link href="http://yoursite.com/2020/10/09/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/2020/10/09/3. 无重复字符的最长子串/</id>
    <published>2020-10-09T04:03:12.000Z</published>
    <updated>2020-10-09T07:51:33.609Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</code></pre><p>示例 2:</p><pre><code>输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</code></pre><p>示例 3:</p><pre><code>输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</code></pre><h1 id="📺-视频题解"><a href="#📺-视频题解" class="headerlink" title="📺 视频题解"></a>📺 视频题解</h1><p><a href="fc6033f3-e9c6-41d7-b660-328fc288d2e2">3. 无重复字符的最长子串_2.mp4</a></p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="方法一：暴力解法"><a href="#方法一：暴力解法" class="headerlink" title="方法一：暴力解法"></a>方法一：暴力解法</h2><p>我一开始想到的是一个比较粗暴的方法，遍历字符串中的每一个位置，然后在该位置向两边扩展，直到遇到重复的字符，最后统计长度，但这种方法效率较低</p><details>    <summary>暴力解法</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        int maxlen = 0;</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            int j = i ;</span><br><span class="line">            int k = i ;</span><br><span class="line">            while (j &gt; 0) &#123;</span><br><span class="line">                if (s.substring(j, k + 1).contains(s.substring(j-1,j))) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            while (k &lt; s.length()-1) &#123;</span><br><span class="line">                if (s.substring(j, k+1).contains(s.substring(k + 1,k+2))) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxlen = Math.max(maxlen, k - j + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="方法二：滑动窗口"><a href="#方法二：滑动窗口" class="headerlink" title="方法二：滑动窗口"></a>方法二：滑动窗口</h2><p><strong>思路和算法</strong></p><p>我们先用一个例子来想一想如何在较优的时间复杂度内通过本题。</p><p>我们不妨以示例一中的字符串 abcabcbb  为例，找出 <strong>从每一个字符开始的，不包含重复字符的最长子串</strong>，那么其中最长的那个字符串即为答案。对于示例一中的字符串，我们列举出这些结果，其中括号中表示选中的字符以及最长的字符串：</p><ul><li>以 (a)bcabcbb 开始的最长字符串为 (abc)abcbb；</li><li>以 a(b)cabcbb 开始的最长字符串为 a(bca)bcbb ；</li><li>以 ab(c)abcbb 开始的最长字符串为 ab(cab)cbb ；</li><li>以 abc(a)bcbb  开始的最长字符串为 abc(abc)bb ；</li><li>以 abca(b)cbb 开始的最长字符串为 abca(bc)bb；</li><li>以 abcab(c)bb  开始的最长字符串为abcab(cb)b ；</li><li>以 abcabc(b)b  开始的最长字符串为 abcabc(b)b ；</li><li>以 abcabcb(b) 开始的最长字符串为 abcabcb(b) 。</li></ul><p>发现了什么？如果我们依次递增地枚举子串的起始位置，那么子串的结束位置也是递增的！这里的原因在于，假设我们选择字符串中的第 <em>k</em> 个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为 <em>r_k*。那么当我们选择第 *k+1</em> 个字符作为起始位置时，首先从 <em>k+1</em> 到 <em>r_k</em> 的字符显然是不重复的，并且由于少了原本的第 <em>k</em> 个字符，我们可以尝试继续增大 <em>r_k</em>，直到右侧出现了重复字符为止。</p><p>这样以来，我们就可以使用「滑动窗口」来解决这个问题了：</p><ul><li><p>我们使用两个指针表示字符串中的某个子串（的左右边界）。其中左指针代表着上文中「枚举子串的起始位置」，而右指针即为上文中的 <em>r_k</em>；</p></li><li><p>在每一步的操作中，我们会将左指针向右移动一格，表示 <strong>我们开始枚举下一个字符作为起始位置</strong>，然后我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着 <strong>以左指针开始的，不包含重复字符的最长子串</strong>。我们记录下这个子串的长度；</p></li><li><p>在枚举结束后，我们找到的最长的子串的长度即为答案。</p></li></ul><p><strong>判断重复字符</strong></p><p>在上面的流程中，我们还需要使用一种数据结构来判断 <strong>是否有重复的字符</strong>，常用的数据结构为哈希集合（即 <code>C++</code> 中的 <code>std::unordered_set</code>，<code>Java</code> 中的 <code>HashSet</code>，<code>Python</code> 中的 <code>set</code>, <code>JavaScript</code> 中的 <code>Set</code>）。在左指针向右移动的时候，我们从哈希集合中移除一个字符，在右指针向右移动的时候，我们往哈希集合中添加一个字符。</p><p>至此，我们就完美解决了本题。</p><details>    <summary>滑动窗口C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; occ;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">        <span class="keyword">int</span> rk = <span class="number">-1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 枚举左指针的位置，初始值隐性地表示为 -1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 左指针向右移动一格，移除一个字符</span></span><br><span class="line">                occ.erase(s[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (rk + <span class="number">1</span> &lt; n &amp;&amp; !occ.count(s[rk + <span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="comment">// 不断地移动右指针</span></span><br><span class="line">                occ.insert(s[rk + <span class="number">1</span>]);</span><br><span class="line">                ++rk;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">            ans = max(ans, rk - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>滑动窗口Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">        Set&lt;Character&gt; occ = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">        <span class="keyword">int</span> rk = -<span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 左指针向右移动一格，移除一个字符</span></span><br><span class="line">                occ.remove(s.charAt(i - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (rk + <span class="number">1</span> &lt; n &amp;&amp; !occ.contains(s.charAt(rk + <span class="number">1</span>))) &#123;</span><br><span class="line">                <span class="comment">// 不断地移动右指针</span></span><br><span class="line">                occ.add(s.charAt(rk + <span class="number">1</span>));</span><br><span class="line">                ++rk;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">            ans = Math.max(ans, rk - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>滑动窗口Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">        occ = set()</span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="comment"># 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">        rk, ans = <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 左指针向右移动一格，移除一个字符</span></span><br><span class="line">                occ.remove(s[i - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">while</span> rk + <span class="number">1</span> &lt; n <span class="keyword">and</span> s[rk + <span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> occ:</span><br><span class="line">                <span class="comment"># 不断地移动右指针</span></span><br><span class="line">                occ.add(s[rk + <span class="number">1</span>])</span><br><span class="line">                rk += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">            ans = max(ans, rk - i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>滑动窗口JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">    <span class="keyword">const</span> occ = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">const</span> n = s.length;</span><br><span class="line">    <span class="comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">    <span class="keyword">let</span> rk = <span class="number">-1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 左指针向右移动一格，移除一个字符</span></span><br><span class="line">            occ.delete(s.charAt(i - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (rk + <span class="number">1</span> &lt; n &amp;&amp; !occ.has(s.charAt(rk + <span class="number">1</span>))) &#123;</span><br><span class="line">            <span class="comment">// 不断地移动右指针</span></span><br><span class="line">            occ.add(s.charAt(rk + <span class="number">1</span>));</span><br><span class="line">            ++rk;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">        ans = <span class="built_in">Math</span>.max(ans, rk - i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>滑动窗口Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">    m := <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">    rk, ans := <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 左指针向右移动一格，移除一个字符</span></span><br><span class="line">            <span class="built_in">delete</span>(m, s[i<span class="number">-1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> rk + <span class="number">1</span> &lt; n &amp;&amp; m[s[rk+<span class="number">1</span>]] == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 不断地移动右指针</span></span><br><span class="line">            m[s[rk+<span class="number">1</span>]]++</span><br><span class="line">            rk++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">        ans = max(ans, rk - i + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(N)*，其中 *N</em> 是字符串的长度。左指针和右指针分别会遍历整个字符串一次。</p></li><li><p>空间复杂度：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(|\Sigma|)</span><br></pre></td></tr></table></figure></li></ul><p>，其中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\Sigma</span><br></pre></td></tr></table></figure><p> 表示字符集（即字符串中可以出现的字符），</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|\Sigma|</span><br></pre></td></tr></table></figure><p> 表示字符集的大小。在本题中没有明确说明字符集，因此可以默认为所有 ASCII 码在 <em>[0, 128)</em> 内的字符，即<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|\Sigma|=128</span><br><span class="line">``` </span><br><span class="line">。我们需要用到哈希集合来存储出现过的字符，而字符最多有 </span><br><span class="line">```math</span><br><span class="line">|\Sigma|</span><br></pre></td></tr></table></figure></p><p>个，因此空间复杂度为 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(|\Sigma|)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年10月" scheme="http://yoursite.com/categories/2020%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>146. LRU缓存机制</title>
    <link href="http://yoursite.com/2020/10/06/146.%20LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2020/10/06/146. LRU缓存机制/</id>
    <published>2020-10-06T02:03:12.000Z</published>
    <updated>2020-10-06T11:23:41.870Z</updated>
    
    <content type="html"><![CDATA[<p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。</p><a id="more"></a><p>它应该支持以下操作： </p><pre><code>获取数据 get 和 写入数据 put 。获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</code></pre><p>进阶:</p><pre><code>你是否可以在 O(1) 时间复杂度内完成这两种操作？</code></pre><p>示例:</p><pre><code>LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );cache.put(1, 1);cache.put(2, 2);cache.get(1);       // 返回  1cache.put(3, 3);    // 该操作会使得关键字 2 作废cache.get(2);       // 返回 -1 (未找到)cache.put(4, 4);    // 该操作会使得关键字 1 作废cache.get(1);       // 返回 -1 (未找到)cache.get(3);       // 返回  3cache.get(4);       // 返回  4</code></pre><h1 id="📺-视频题解"><a href="#📺-视频题解" class="headerlink" title="📺 视频题解"></a>📺 视频题解</h1><p><a href="42b5ca6a-4d69-4f7d-bf63-5c196aa23b44">146. LRU缓存机制.mp4</a></p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>实现本题的两种操作，需要用到一个哈希表和一个双向链表。在面试中，面试官一般会期望读者能够自己实现一个简单的双向链表，而不是使用语言自带的、封装好的数据结构。在 <code>Python</code> 语言中，有一种结合了哈希表与双向链表的数据结构 <code>OrderedDict</code>，只需要短短的几行代码就可以完成本题。在 <code>Java</code> 语言中，同样有类似的数据结构 <code>LinkedHashMap</code>。这些做法都不会符合面试官的要求，因此下面只给出使用封装好的数据结构实现的代码，而不多做任何阐述。</p><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[sol0-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span><span class="params">(collections.OrderedDict)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity: int)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.capacity = capacity</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        self.move_to_end(key)</span><br><span class="line">        <span class="keyword">return</span> self[key]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key: int, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self:</span><br><span class="line">            self.move_to_end(key)</span><br><span class="line">        self[key] = value</span><br><span class="line">        <span class="keyword">if</span> len(self) &gt; self.capacity:</span><br><span class="line">            self.popitem(last=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol0-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">Integer</span>, <span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(capacity, <span class="number">0.75F</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getOrDefault(key, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; capacity; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="方法一：哈希表-双向链表"><a href="#方法一：哈希表-双向链表" class="headerlink" title="方法一：哈希表 + 双向链表"></a>方法一：哈希表 + 双向链表</h2><p><strong>算法</strong></p><p>LRU 缓存机制可以通过哈希表辅以双向链表实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。</p><ul><li><p>双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。</p></li><li><p>哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。</p></li></ul><p>这样以来，我们首先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部，即可在 <em>O(1)</em> 的时间内完成 <code>get</code> 或者 <code>put</code> 操作。具体的方法如下：</p><ul><li><p>对于 <code>get</code> 操作，首先判断 <code>key</code> 是否存在：</p><ul><li><p>如果 <code>key</code> 不存在，则返回 <em>-1</em>；</p></li><li><p>如果 <code>key</code> 存在，则 <code>key</code> 对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值。</p></li></ul></li><li><p>对于 <code>put</code> 操作，首先判断 <code>key</code> 是否存在：</p><ul><li><p>如果 <code>key</code> 不存在，使用 <code>key</code> 和 <code>value</code> 创建一个新的节点，在双向链表的头部添加该节点，并将 <code>key</code> 和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项；</p></li><li><p>如果 <code>key</code> 存在，则与 <code>get</code> 操作类似，先通过哈希表定位，再将对应的节点的值更新为 <code>value</code>，并将该节点移到双向链表的头部。</p></li></ul></li></ul><p>上述各项操作中，访问哈希表的时间复杂度为 <em>O(1)<em>，在双向链表的头部添加节点、在双向链表的尾部删除节点的复杂度也为 *O(1)</em>。而将一个节点移到双向链表的头部，可以分成「删除该节点」和「在双向链表的头部添加节点」两步操作，都可以在 *O(1)</em> 时间内完成。</p><p><strong>小贴士</strong></p><p>在双向链表的实现中，使用一个<strong>伪头部</strong>（dummy head）和<strong>伪尾部</strong>（dummy tail）标记界限，这样在添加节点和删除节点的时候就不需要检查相邻的节点是否存在。</p><p> <a href="https://assets.leetcode-cn.com/solution-static/146/1.PNG" target="_blank" rel="noopener">fig1</a> <a href="https://assets.leetcode-cn.com/solution-static/146/2.PNG" target="_blank" rel="noopener">fig2</a> <a href="https://assets.leetcode-cn.com/solution-static/146/3.PNG" target="_blank" rel="noopener">fig3</a> <a href="https://assets.leetcode-cn.com/solution-static/146/4.PNG" target="_blank" rel="noopener">fig4</a> <a href="https://assets.leetcode-cn.com/solution-static/146/5.PNG" target="_blank" rel="noopener">fig5</a> <a href="https://assets.leetcode-cn.com/solution-static/146/6.PNG" target="_blank" rel="noopener">fig6</a> <a href="https://assets.leetcode-cn.com/solution-static/146/7.PNG" target="_blank" rel="noopener">fig7</a> <a href="https://assets.leetcode-cn.com/solution-static/146/8.PNG" target="_blank" rel="noopener">fig8</a> <a href="https://assets.leetcode-cn.com/solution-static/146/9.PNG" target="_blank" rel="noopener">fig9</a> <a href="https://assets.leetcode-cn.com/solution-static/146/10.PNG" target="_blank" rel="noopener">fig10</a> </p><details>    <summary>哈希表 + 双向链表Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DLinkedNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, key=<span class="number">0</span>, value=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.value = value</span><br><span class="line">        self.prev = <span class="keyword">None</span></span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity: int)</span>:</span></span><br><span class="line">        self.cache = dict()</span><br><span class="line">        <span class="comment"># 使用伪头部和伪尾部节点    </span></span><br><span class="line">        self.head = DLinkedNode()</span><br><span class="line">        self.tail = DLinkedNode()</span><br><span class="line">        self.head.next = self.tail</span><br><span class="line">        self.tail.prev = self.head</span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.cache:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="comment"># 如果 key 存在，先通过哈希表定位，再移到头部</span></span><br><span class="line">        node = self.cache[key]</span><br><span class="line">        self.moveToHead(node)</span><br><span class="line">        <span class="keyword">return</span> node.value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key: int, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.cache:</span><br><span class="line">            <span class="comment"># 如果 key 不存在，创建一个新的节点</span></span><br><span class="line">            node = DLinkedNode(key, value)</span><br><span class="line">            <span class="comment"># 添加进哈希表</span></span><br><span class="line">            self.cache[key] = node</span><br><span class="line">            <span class="comment"># 添加至双向链表的头部</span></span><br><span class="line">            self.addToHead(node)</span><br><span class="line">            self.size += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.size &gt; self.capacity:</span><br><span class="line">                <span class="comment"># 如果超出容量，删除双向链表的尾部节点</span></span><br><span class="line">                removed = self.removeTail()</span><br><span class="line">                <span class="comment"># 删除哈希表中对应的项</span></span><br><span class="line">                self.cache.pop(removed.key)</span><br><span class="line">                self.size -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span></span><br><span class="line">            node = self.cache[key]</span><br><span class="line">            node.value = value</span><br><span class="line">            self.moveToHead(node)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addToHead</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        node.prev = self.head</span><br><span class="line">        node.next = self.head.next</span><br><span class="line">        self.head.next.prev = node</span><br><span class="line">        self.head.next = node</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNode</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        node.prev.next = node.next</span><br><span class="line">        node.next.prev = node.prev</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveToHead</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        self.removeNode(node)</span><br><span class="line">        self.addToHead(node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeTail</span><span class="params">(self)</span>:</span></span><br><span class="line">        node = self.tail.prev</span><br><span class="line">        self.removeNode(node)</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure></details><details>    <summary>哈希表 + 双向链表Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DLinkedNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        DLinkedNode prev;</span><br><span class="line">        DLinkedNode next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DLinkedNode</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DLinkedNode</span><span class="params">(<span class="keyword">int</span> _key, <span class="keyword">int</span> _value)</span> </span>&#123;key = _key; value = _value;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, DLinkedNode&gt; cache = <span class="keyword">new</span> HashMap&lt;Integer, DLinkedNode&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> DLinkedNode head, tail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        <span class="comment">// 使用伪头部和伪尾部节点</span></span><br><span class="line">        head = <span class="keyword">new</span> DLinkedNode();</span><br><span class="line">        tail = <span class="keyword">new</span> DLinkedNode();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        DLinkedNode node = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 key 存在，先通过哈希表定位，再移到头部</span></span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        DLinkedNode node = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果 key 不存在，创建一个新的节点</span></span><br><span class="line">            DLinkedNode newNode = <span class="keyword">new</span> DLinkedNode(key, value);</span><br><span class="line">            <span class="comment">// 添加进哈希表</span></span><br><span class="line">            cache.put(key, newNode);</span><br><span class="line">            <span class="comment">// 添加至双向链表的头部</span></span><br><span class="line">            addToHead(newNode);</span><br><span class="line">            ++size;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">                <span class="comment">// 如果超出容量，删除双向链表的尾部节点</span></span><br><span class="line">                DLinkedNode tail = removeTail();</span><br><span class="line">                <span class="comment">// 删除哈希表中对应的项</span></span><br><span class="line">                cache.remove(tail.key);</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span></span><br><span class="line">            node.value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(DLinkedNode node)</span> </span>&#123;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.prev = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(DLinkedNode node)</span> </span>&#123;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(DLinkedNode node)</span> </span>&#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> DLinkedNode <span class="title">removeTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DLinkedNode res = tail.prev;</span><br><span class="line">        removeNode(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>哈希表 + 双向链表C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DLinkedNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key, value;</span><br><span class="line">    DLinkedNode* prev;</span><br><span class="line">    DLinkedNode* next;</span><br><span class="line">    DLinkedNode(): key(<span class="number">0</span>), value(<span class="number">0</span>), prev(<span class="literal">nullptr</span>), next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    DLinkedNode(<span class="keyword">int</span> _key, <span class="keyword">int</span> _value): key(_key), value(_value), prev(<span class="literal">nullptr</span>), next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, DLinkedNode*&gt; cache;</span><br><span class="line">    DLinkedNode* head;</span><br><span class="line">    DLinkedNode* tail;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LRUCache(<span class="keyword">int</span> _capacity): capacity(_capacity), size(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用伪头部和伪尾部节点</span></span><br><span class="line">        head = <span class="keyword">new</span> DLinkedNode();</span><br><span class="line">        tail = <span class="keyword">new</span> DLinkedNode();</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache.count(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 key 存在，先通过哈希表定位，再移到头部</span></span><br><span class="line">        DLinkedNode* node = cache[key];</span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache.count(key)) &#123;</span><br><span class="line">            <span class="comment">// 如果 key 不存在，创建一个新的节点</span></span><br><span class="line">            DLinkedNode* node = <span class="keyword">new</span> DLinkedNode(key, value);</span><br><span class="line">            <span class="comment">// 添加进哈希表</span></span><br><span class="line">            cache[key] = node;</span><br><span class="line">            <span class="comment">// 添加至双向链表的头部</span></span><br><span class="line">            addToHead(node);</span><br><span class="line">            ++size;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">                <span class="comment">// 如果超出容量，删除双向链表的尾部节点</span></span><br><span class="line">                DLinkedNode* removed = removeTail();</span><br><span class="line">                <span class="comment">// 删除哈希表中对应的项</span></span><br><span class="line">                cache.erase(removed-&gt;key);</span><br><span class="line">                <span class="comment">// 防止内存泄漏</span></span><br><span class="line">                <span class="keyword">delete</span> removed;</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span></span><br><span class="line">            DLinkedNode* node = cache[key];</span><br><span class="line">            node-&gt;value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;prev = head;</span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next-&gt;prev = node;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">DLinkedNode* <span class="title">removeTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DLinkedNode* node = tail-&gt;prev;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>哈希表 + 双向链表Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    size <span class="keyword">int</span></span><br><span class="line">    capacity <span class="keyword">int</span></span><br><span class="line">    cache <span class="keyword">map</span>[<span class="keyword">int</span>]*DLinkedNode</span><br><span class="line">    head, tail *DLinkedNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DLinkedNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    key, value <span class="keyword">int</span></span><br><span class="line">    prev, next *DLinkedNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initDLinkedNode</span><span class="params">(key, value <span class="keyword">int</span>)</span> *<span class="title">DLinkedNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;DLinkedNode&#123;</span><br><span class="line">        key: key,</span><br><span class="line">        value: value,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="keyword">int</span>)</span> <span class="title">LRUCache</span></span> &#123;</span><br><span class="line">    l := LRUCache&#123;</span><br><span class="line">        cache: <span class="keyword">map</span>[<span class="keyword">int</span>]*DLinkedNode&#123;&#125;,</span><br><span class="line">        head: initDLinkedNode(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        tail: initDLinkedNode(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        capacity: capacity,</span><br><span class="line">    &#125;</span><br><span class="line">    l.head.next = l.tail</span><br><span class="line">    l.tail.prev = l.head</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _, ok := this.cache[key]; !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    node := this.cache[key]</span><br><span class="line">    this.moveToHead(node)</span><br><span class="line">    <span class="keyword">return</span> node.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">Put</span><span class="params">(key <span class="keyword">int</span>, value <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">if</span> _, ok := this.cache[key]; !ok &#123;</span><br><span class="line">        node := initDLinkedNode(key, value)</span><br><span class="line">        this.cache[key] = node</span><br><span class="line">        this.addToHead(node)</span><br><span class="line">        this.size++</span><br><span class="line">        <span class="keyword">if</span> this.size &gt; this.capacity &#123;</span><br><span class="line">            removed := this.removeTail()</span><br><span class="line">            <span class="built_in">delete</span>(this.cache, removed.key)</span><br><span class="line">            this.size--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node := this.cache[key]</span><br><span class="line">        node.value = value</span><br><span class="line">        this.moveToHead(node)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">addToHead</span><span class="params">(node *DLinkedNode)</span></span> &#123;</span><br><span class="line">    node.prev = this.head</span><br><span class="line">    node.next = this.head.next</span><br><span class="line">    this.head.next.prev = node</span><br><span class="line">    this.head.next = node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">removeNode</span><span class="params">(node *DLinkedNode)</span></span> &#123;</span><br><span class="line">    node.prev.next = node.next</span><br><span class="line">    node.next.prev = node.prev</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">moveToHead</span><span class="params">(node *DLinkedNode)</span></span> &#123;</span><br><span class="line">    this.removeNode(node)</span><br><span class="line">    this.addToHead(node)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">removeTail</span><span class="params">()</span> *<span class="title">DLinkedNode</span></span> &#123;</span><br><span class="line">    node := this.tail.prev</span><br><span class="line">    this.removeNode(node)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>**复杂度分析**<ul><li><p>时间复杂度：对于 <code>put</code> 和 <code>get</code> 都是 <em>O(1)</em>。</p></li><li><p>空间复杂度：O(capacity) ，因为哈希表和双向链表最多存储 capacity+1 个元素。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年10月" scheme="http://yoursite.com/categories/2020%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Greedy" scheme="http://yoursite.com/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>134. 加油站</title>
    <link href="http://yoursite.com/2020/10/05/134.%20%E5%8A%A0%E6%B2%B9%E7%AB%99/"/>
    <id>http://yoursite.com/2020/10/05/134. 加油站/</id>
    <published>2020-10-04T17:17:12.000Z</published>
    <updated>2020-10-06T02:02:06.728Z</updated>
    
    <content type="html"><![CDATA[<p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p><a id="more"></a><p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p><p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p><p>说明: </p><p>如果题目有解，该答案即为唯一答案。<br>输入数组均为非空数组，且长度相同。<br>输入数组中的元素均为非负数。<br>示例 1:</p><pre><code>输入: gas  = [1,2,3,4,5]cost = [3,4,5,1,2]输出: 3解释:从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。因此，3 可为起始索引。</code></pre><p>示例 2:</p><pre><code>输入: gas  = [2,3,4]cost = [3,4,3]输出: -1解释:你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。因此，无论怎样，你都不可能绕环路行驶一周。</code></pre><h1 id="方法：一次遍历"><a href="#方法：一次遍历" class="headerlink" title="方法：一次遍历"></a>方法：一次遍历</h1><p><strong>想法</strong></p><p>第一想法是检查每一个加油站：</p><ul><li><p>选择该加油站为出发站</p></li><li><p>模拟汽车环路行驶，在每一个加油站检查我们还剩多少升汽油。</p></li></ul><p>这意味着 O(N^2)的时间复杂度。显然，我们可以做得更好。</p><p>首先注意两件事情：</p><blockquote><p>如果 <code>sum(gas) &lt; sum(cost)</code> ，那么不可能环行一圈，这种情况下答案是 <code>-1</code> 。</p></blockquote><p><a href="https://pic.leetcode-cn.com/4381241b2ed28ee64703425af2e6a4ddb85df5dad25d644c89d7bdbcd2927c8b-image.png" target="_blank" rel="noopener">image.png</a></p><p>我们可以用这个式子计算环行过程中邮箱里剩下的油：<code>total_tank = sum(gas) - sum(cost)</code>  ，如果 <code>total_tank &lt; 0</code> 则返回 <code>-1</code> 。</p><blockquote><p>对于加油站 <code>i</code> ，如果 <code>gas[i] - cost[i] &lt; 0</code> ，则不可能从这个加油站出发，因为在前往 <code>i + 1</code> 的过程中，汽油就不够了。</p></blockquote><p><a href="https://pic.leetcode-cn.com/5f9a6f57444dc93f334fdb782f4368e3863888b82fc90d4f9b490eeb53cf86fe-image.png" target="_blank" rel="noopener">image.png</a></p><p>第二个规则可以被一般化，我们引入变量 <code>curr_tank</code> ，记录当前油箱里剩余的总油量。如果在某一个加油站 <code>curr_tank</code>比 <code>0</code> 小，意味着我们无法到达这个加油站。<strong>一个站的收益如果小于0，肯定不能作为起点；而连续的多个站也可以等效地看做一个站，如果其累积收益小于0，就跳过，寻找下一个。</strong></p><p>下一步我们把这个加油站当做新的起点，并将 <code>curr_tank</code> 重置为 0 ，因为重新出发，油箱中的油为 0 。（从上一次重置的加油站到当前加油站的任意一个加油站出发，到达当前加油站之前， <code>curr_tank</code> 也一定会比 0 小,<strong>即如果A站不能到B站，那么A，B之间到任何一个站都不能到B站，（B站是A站第一个不能到的站）</strong> ）</p><p><strong>算法</strong></p><p>那么现在算法是很直接明了的：</p><ol><li><p>初始化 <code>total_tank</code> 和 <code>curr_tank</code> 为 0 ，并且选择 <code>0</code> 号加油站为起点。</p></li><li><p>遍历所有的加油站：</p><ul><li><p>每一步中，都通过加上 <code>gas[i]</code> 和减去 <code>cost[i]</code> 来更新 <code>total_tank</code> 和 <code>curr_tank</code> 。</p></li><li><p>如果在 <code>i + 1</code> 号加油站， <code>curr_tank &lt; 0</code> ，将 <code>i + 1</code> 号加油站作为新的起点，同时重置 <code>curr_tank = 0</code> ，让油箱也清空。</p></li></ul></li><li><p>如果 <code>total_tank &lt; 0</code> ，返回 <code>-1</code> ，否则返回 <code>starting station</code>。</p></li></ol><p><strong>算法原理</strong></p><p>想象 <code>total_tank &gt;= 0</code> 的情况，同时上述算法返回 <em>N_s</em> 作为出发加油站。</p><p>算法直接保证了从 <em>N_s</em> 可以到达 <em>0</em> ，但是剩余的路程，即从 <em>0</em> 到站 <em>N_s</em> 是否有足够的油呢？</p><blockquote><p>如何确保从 <em>N_s</em> 出发可以环行一圈？</p></blockquote><p>我们使用 <a href="https://baike.baidu.com/item/%E5%8F%8D%E8%AF%81%E6%B3%95/5017739?fr=aladdin" target="_blank" rel="noopener">反证法</a> 。假设存在 <em>0 &lt; k &lt; N_s</em> ，使得我们从 <em>N_s</em> 出发无法到达 <code>k</code> 号加油站。</p><p>条件 <code>total_tank &gt;= 0</code> 可以被写作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\sum_&#123;i=1&#125;^&#123;N&#125;&#123;\alpha_i&#125;\ge0\qquad(1)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\alpha_i&gt;=0</span><br></pre></td></tr></table></figure><p>,<br>其中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\alpha_i=gas[i]-cost[i]</span><br></pre></td></tr></table></figure><p>我们将出发站点 <em>N_s</em> 和无法到达站点 <code>k</code> 作为分隔点，将左式分成三个部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\sum_&#123;i=1&#125;^&#123;k&#125;&#123;\alpha_i&#125;+\sum_&#123;i=k+1&#125;^&#123;N_s-1&#125;&#123;\alpha_i&#125;+\sum_&#123;i=N_s&#125;^&#123;N&#125;&#123;\alpha_i&#125;\ge0\qquad(2)</span><br></pre></td></tr></table></figure><p>根据算法流程，第二项为负，因为每一个出发点前面一段路途的 <code>curr_tank</code> 一定为负。否则，出发点应该是比 <em>N_s</em> 更靠前的一个加油站而不是 <em>N_s</em> 。当且仅当 <em>k = N_s - 1</em> ，第二项才为 0 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\sum_&#123;i=k+1&#125;^&#123;i=N_s-1&#125;&#123;\alpha_i&#125;\le0\qquad(3)</span><br></pre></td></tr></table></figure><p>结合不等式 <code>(2)</code> 和 <code>(3)</code> ，可以得到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\sum_&#123;i=0&#125;^&#123;i=k&#125;&#123;\alpha_i&#125;+\sum_&#123;i=N_s&#125;^&#123;i=N&#125;&#123;\alpha_i&#125;\ge0\qquad(4)</span><br></pre></td></tr></table></figure><p>同时，因为 <em>k</em> 是一个从 <em>N_s</em> 出发不可到达的站点，意味着</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\sum_&#123;i=N_s&#125;^&#123;i=N&#125;&#123;\alpha_i&#125;+\sum_&#123;i=0&#125;^&#123;i=k&#125;&#123;\alpha_i&#125;&lt;0\qquad(5)</span><br></pre></td></tr></table></figure><p>结合不等式 <code>(4)</code> 和 <code>(5)</code> ，可以得到一个矛盾。因此，假设 “存在一个 <em>0 &lt; k &lt; N_s</em> ，从 <em>N_s</em> 出发无法到达 <em>k</em>” 不成立。</p><p>因此，从 <em>N_s</em> 出发一定能环行一圈， <em>N_s</em> 是一个可行解。根据题目描述，答案是唯一的。</p><p>上面的官方题解看起来很饶，公式（5）存在以结论证结论的问题，而以每站汽油累计量profit[i] = gas[i] - cost[i]思考这个问题更容易理解。</p><p>若sum(gas) &gt;= sum(cost)，则必定存在解（贪心策略不用严格证明，大家以汽油累计量为0，每站汽油累计量可正可负，极限条件画个环形图理解下：大致就是左边累积量少，我就往右边走，反之亦然）</p><p>再加上题目条件若有解则唯一，</p><p>我们只需找到以i开头的总累计油量有剩余cur_tank + gas[i] - cost[i] &gt;= 0即可——这就是本题贪心策略的依据</p><p><strong>实现</strong></p><p> <a href="https://pic.leetcode-cn.com/87e7bb7a0745fe4916de8deb8687b4a84b3482daab0643f1ae6d4a02cf03ceb0-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/4dad65b5a9ed763e2760129635f1704be4a9e093ea66bc4e244657cb59c35744-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/022e56703b9ce5f53fb8ad9c6d51cc74468bff670eb29dfa48cb0625c9d57cba-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/256c9491248c8cf0e8fca7370346ea22333edc4394c57f211c1783a6b163235a-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/d1cef311a434c64d3fd85ea0d1adb5374e1b16d802110c90c833ceb4121bb19c-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/6be953413c1dbb884e5b2e92837cc4384ba32fa662f7c2c0784cb8e1bff973b2-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/ca82d1cec3e8d2a325c20f1dab270bcae405e21f4990e46f38f5394fe6c65249-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/469511c0afc12420e34588cf19cb373ee22e9d4fb5c472d6b92e764f12e0fd7e-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/dcbe6e6975e1ee7d2cedfbdc9cff3d8212b066e6d5d63535ba435aceec67af9c-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/8c6d7bb66df5271a3383bce38fadbf0bfd52c1b035582903c3a6ebd4df8d1989-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/f1aea61b070c96e2e5c718dd3b9a35e40fa74f769204398fbdbd0a7466fa7eff-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/d450f8d85053fbdd914e21e6e0d56b0b7ebd797bea4cfb6fa5b250f794bcaf61-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/67399856acdd96570218a3de68ec86de6d6f385e517cc5e1991493433ca58b05-image.png" target="_blank" rel="noopener">image.png</a> </p><details>    <summary>一次遍历Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canCompleteCircuit</span><span class="params">(self, gas, cost)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type gas: List[int]</span></span><br><span class="line"><span class="string">        :type cost: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(gas)</span><br><span class="line">        </span><br><span class="line">        total_tank, curr_tank = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        starting_station = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            total_tank += gas[i] - cost[i]</span><br><span class="line">            curr_tank += gas[i] - cost[i]</span><br><span class="line">            <span class="comment"># If one couldn't get here,</span></span><br><span class="line">            <span class="keyword">if</span> curr_tank &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># Pick up the next station as the starting one.</span></span><br><span class="line">                starting_station = i + <span class="number">1</span></span><br><span class="line">                <span class="comment"># Start with an empty tank.</span></span><br><span class="line">                curr_tank = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> starting_station <span class="keyword">if</span> total_tank &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></details><details>    <summary>一次遍历Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="keyword">int</span>[] gas, <span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = gas.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> total_tank = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> curr_tank = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> starting_station = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      total_tank += gas[i] - cost[i];</span><br><span class="line">      curr_tank += gas[i] - cost[i];</span><br><span class="line">      <span class="comment">// If one couldn't get here,</span></span><br><span class="line">      <span class="keyword">if</span> (curr_tank &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Pick up the next station as the starting one.</span></span><br><span class="line">        starting_station = i + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// Start with an empty tank.</span></span><br><span class="line">        curr_tank = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total_tank &gt;= <span class="number">0</span> ? starting_station : -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>一次遍历C++</summary><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; gas, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = gas.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> total_tank = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> curr_tank = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> starting_station = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      total_tank += gas[i] - cost[i];</span><br><span class="line">      curr_tank += gas[i] - cost[i];</span><br><span class="line">      <span class="comment">// If one couldn't get here,</span></span><br><span class="line">      <span class="keyword">if</span> (curr_tank &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Pick up the next station as the starting one.</span></span><br><span class="line">        starting_station = i + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// Start with an empty tank.</span></span><br><span class="line">        curr_tank = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total_tank &gt;= <span class="number">0</span> ? starting_station : <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度： O(N) ， 这是因为只有一个遍历了所有加油站一次的循环。</p></li><li><p>空间复杂度： O(1)  ，因为此算法只使用了常数个变量。</p></li></ul><p><strong>延伸阅读</strong></p><p>还有许多加油站问题的变种问题，这里是一些例子：</p><p><a href="https://www.sciencedirect.com/science/article/pii/S002001901730203X" target="_blank" rel="noopener">允许 Δ 次停留的加油站间最小路径开销</a> </p><p><a href="https://link.springer.com/chapter/10.1007/978-3-540-75520-3_48" target="_blank" rel="noopener">油箱有容量限制下的加油站间最小路径开销</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年10月" scheme="http://yoursite.com/categories/2020%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Greedy" scheme="http://yoursite.com/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>412. Fizz Buzz</title>
    <link href="http://yoursite.com/2020/10/05/412.%20Fizz%20Buzz/"/>
    <id>http://yoursite.com/2020/10/05/412. Fizz Buzz/</id>
    <published>2020-10-04T16:26:12.000Z</published>
    <updated>2020-10-04T17:02:23.520Z</updated>
    
    <content type="html"><![CDATA[<p>写一个程序，输出从 1 到 n 数字的字符串表示。</p><a id="more"></a><ol><li><p>如果n是3的倍数，输出“Fizz”；</p></li><li><p>如果n是5的倍数，输出“Buzz”；</p></li><li><p>如果n同时是3和5的倍数，输出 “FizzBuzz”。</p></li></ol><p>示例：</p><pre><code>n = 15,</code></pre><p>返回:</p><pre><code>[    &quot;1&quot;,    &quot;2&quot;,    &quot;Fizz&quot;,    &quot;4&quot;,    &quot;Buzz&quot;,    &quot;Fizz&quot;,    &quot;7&quot;,    &quot;8&quot;,    &quot;Fizz&quot;,    &quot;Buzz&quot;,    &quot;11&quot;,    &quot;Fizz&quot;,    &quot;13&quot;,    &quot;14&quot;,    &quot;FizzBuzz&quot;]</code></pre><h1 id="方法一：-模拟法"><a href="#方法一：-模拟法" class="headerlink" title="方法一： 模拟法"></a>方法一： 模拟法</h1><p><strong>思路</strong></p><p>就像你每次玩 FizzBuzz 那样，你只需要判断这个数是能被 <code>3</code> 整除？ 还是能被 <code>5</code> 整除？ 或者是都能被整除。</p><p><strong>算法</strong></p><ol><li>初始化一个空的答案列表。</li><li>遍历 <em>1 … N</em>。</li><li>对于每个数，判断它能不能同时被 3 和 5 整除，如果可以就把 FizzBuzz 加入答案列表。</li><li>如果不行，判断它能不能被 3 整除，如果可以，把 Fizz 加入答案列表。</li><li>如果还是不行，判断它能不能被 5 整除，如果可以，把 Buzz 加入答案列表。</li><li>如果以上都不行，把这个数加入答案列表。<details> <summary>模拟法Java</summary></details></li></ol><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">fizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ans list</span></span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">1</span>; num &lt;= n; num++) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">boolean</span> divisibleBy3 = (num % <span class="number">3</span> == <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">boolean</span> divisibleBy5 = (num % <span class="number">5</span> == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (divisibleBy3 &amp;&amp; divisibleBy5) &#123;</span><br><span class="line">        <span class="comment">// Divides by both 3 and 5, add FizzBuzz</span></span><br><span class="line">        ans.add(<span class="string">"FizzBuzz"</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (divisibleBy3) &#123;</span><br><span class="line">        <span class="comment">// Divides by 3, add Fizz</span></span><br><span class="line">        ans.add(<span class="string">"Fizz"</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (divisibleBy5) &#123;</span><br><span class="line">        <span class="comment">// Divides by 5, add Buzz</span></span><br><span class="line">        ans.add(<span class="string">"Buzz"</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Not divisible by 3 or 5, add the number</span></span><br><span class="line">        ans.add(Integer.toString(num));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details>    <summary>模拟法Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fizzBuzz</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># ans list</span></span><br><span class="line">        ans = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line"></span><br><span class="line">            divisible_by_3 = (num % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">            divisible_by_5 = (num % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> divisible_by_3 <span class="keyword">and</span> divisible_by_5:</span><br><span class="line">                <span class="comment"># Divides by both 3 and 5, add FizzBuzz</span></span><br><span class="line">                ans.append(<span class="string">"FizzBuzz"</span>)</span><br><span class="line">            <span class="keyword">elif</span> divisible_by_3:</span><br><span class="line">                <span class="comment"># Divides by 3, add Fizz</span></span><br><span class="line">                ans.append(<span class="string">"Fizz"</span>)</span><br><span class="line">            <span class="keyword">elif</span> divisible_by_5:</span><br><span class="line">                <span class="comment"># Divides by 5, add Buzz</span></span><br><span class="line">                ans.append(<span class="string">"Buzz"</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># Not divisible by 3 or 5, add the number</span></span><br><span class="line">                ans.append(str(num))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度： <em>O(N)</em></li><li>空间复杂度： <em>O(1)</em></li></ul><h1 id="方法二：-字符串连接"><a href="#方法二：-字符串连接" class="headerlink" title="方法二： 字符串连接"></a>方法二： 字符串连接</h1><p><strong>思路</strong></p><p>这个方法不会降低渐进复杂度，但是当 <code>FizzBuzz</code> 的规则变得更复杂的时候，这将会是个更优雅的解法。比方说，玩个 <code>FizzBuzzJazz</code> 的游戏。规则如下：</p><pre>3 ---> "Fizz" , 5 ---> "Buzz", 7 ---> "Jazz"</pre><p>如果你还是用之前的方法来解决这个问题的话，那将会有非常多的条件需要判断哦~</p><ol><li>能不能被 3 整除</li><li>能不能被 5 整除</li><li>能不能被 7 整除</li><li>能不能同时被 3 和 5 整除</li><li>能不能同时被 5 和 7 整除</li><li>能不能同时被 3 和 7 整除</li><li>能不能同时被 3，5，7 整除</li><li>不能被 3，5，7 其中任何一个数整除</li></ol><p>如果 <code>FizzBuzz</code> 照着这种方式变地更复杂的话，那么你要写的判断可能会让你抓狂。</p><p><strong>算法</strong></p><p>我们放弃使用之前的联合判断，取而代之依次判断是否能被给定的数整数。这道题中，就是依次判断能不能被 3 整除，能不能被 5 整除。如果能被 3 整除，就把对应的 <code>Fizz</code> 连接到答案字符串，如果能被 5 整除，就把 <code>Buzz</code> 连接到答案字符串。</p><p>举个例子，现在需要判断 15，步骤将会是下面这样的：</p><blockquote><p>条件 1： 15 % 3 == 0, num_ans_str = “Fizz”<br>条件 2： 15 % 5 == 0, num_ans_str += “Buzz”<br>=&gt; num_ans_str = “FizzBuzz”</p></blockquote><p>对于 <code>FizzBuzz</code> 来说，只需要判断两个条件就可以了，而不需要像方法一中那样判断三个条件。</p><p>同样的，对于 <code>FizzBuzzJazz</code>，现在只需要判断三个条件就可以了。</p><details>    <summary>字符串连接Java</summary><figure class="highlight java"><figcaption><span>[solution-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">fizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ans list</span></span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">1</span>; num &lt;= n; num++) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">boolean</span> divisibleBy3 = (num % <span class="number">3</span> == <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">boolean</span> divisibleBy5 = (num % <span class="number">5</span> == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      String numAnsStr = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (divisibleBy3) &#123;</span><br><span class="line">        <span class="comment">// Divides by 3, add Fizz</span></span><br><span class="line">        numAnsStr += <span class="string">"Fizz"</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (divisibleBy5) &#123;</span><br><span class="line">        <span class="comment">// Divides by 5, add Buzz</span></span><br><span class="line">        numAnsStr += <span class="string">"Buzz"</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (numAnsStr.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">        <span class="comment">// Not divisible by 3 or 5, add the number</span></span><br><span class="line">        numAnsStr += Integer.toString(num);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Append the current answer str to the ans list</span></span><br><span class="line">      ans.add(numAnsStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>字符串连接Python</summary><figure class="highlight python"><figcaption><span>[solution-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fizzBuzz</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># ans list</span></span><br><span class="line">        ans = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line"></span><br><span class="line">            divisible_by_3 = (num % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">            divisible_by_5 = (num % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            num_ans_str = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> divisible_by_3:</span><br><span class="line">                <span class="comment"># Divides by 3</span></span><br><span class="line">                num_ans_str += <span class="string">"Fizz"</span></span><br><span class="line">            <span class="keyword">if</span> divisible_by_5:</span><br><span class="line">                <span class="comment"># Divides by 5</span></span><br><span class="line">                num_ans_str += <span class="string">"Buzz"</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> num_ans_str:</span><br><span class="line">                <span class="comment"># Not divisible by 3 or 5</span></span><br><span class="line">                num_ans_str = str(num)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Append the current answer str to the ans list</span></span><br><span class="line">            ans.append(num_ans_str)  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details>**复杂度分析**<ul><li>时间复杂度： <em>O(N)</em></li><li>空间复杂度： <em>O(1)</em><br><br></li></ul><h1 id="方法三-用散列表"><a href="#方法三-用散列表" class="headerlink" title="方法三 用散列表"></a>方法三 用散列表</h1><p><strong>思路</strong></p><p>这个方法是对方法二的优化。当数字和答案的映射是定好的，那么方法二用起来也还可以。但是如果你遇到一个变态的面试官，他跟你说他需要更自由的映射关系呢？</p><p>每个映射一个判断显然是不可行的，这样写出来的代码一定是丑陋不堪且难以维护的。</p><p>如果老板有这样一个需求，明天你把映射关系换掉或者删除一个映射关系吧。对于这种要求，我们只能一个个去修改判断条件的代码。</p><p>但我们实际上有个更优雅的做法，那就是把映射关系放在 <code>散列表</code> 里面。</p><p><strong>算法</strong></p><ol><li>把所有的映射关系放在散列表 <code>fizzBuzzHash</code> 中，这个散列表形如 <code>{ 3: &#39;Fizz&#39;, 5: &#39;Buzz&#39; }</code>。</li><li>遍历 <em>1 … N</em>。</li><li>对于每个数字，遍历 <code>fizzBuzzHash</code> 中的键，检查是否能被它整除。</li><li>如果这个数能被键整除，就把当前键映射的值加到到答案字符串后面去。对于散列表的每个键值对，都这样操作。</li><li>最后将答案字符串加入答案列表。</li></ol><blockquote><p>通过这样的方式你可以对散列表<code>添加/删除</code>映射关系，同时还不需要修改太多代码。</p></blockquote><p>而对于 <code>FizzBuzzJazz</code> 这个问题，散列表就可以是这样的，<code>{ 3: &#39;Fizz&#39;, 5: &#39;Buzz&#39;, 7: &#39;Jazz&#39; }</code>。</p><details>    <summary>用散列表Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">fizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ans list</span></span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hash map to store all fizzbuzz mappings.</span></span><br><span class="line">    HashMap&lt;Integer, String&gt; fizzBizzDict =</span><br><span class="line">        <span class="keyword">new</span> HashMap&lt;Integer, String&gt;() &#123;</span><br><span class="line">          &#123;</span><br><span class="line">            put(<span class="number">3</span>, <span class="string">"Fizz"</span>);</span><br><span class="line">            put(<span class="number">5</span>, <span class="string">"Buzz"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">1</span>; num &lt;= n; num++) &#123;</span><br><span class="line"></span><br><span class="line">      String numAnsStr = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (Integer key : fizzBizzDict.keySet()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the num is divisible by key,</span></span><br><span class="line">        <span class="comment">// then add the corresponding string mapping to current numAnsStr</span></span><br><span class="line">        <span class="keyword">if</span> (num % key == <span class="number">0</span>) &#123;</span><br><span class="line">          numAnsStr += fizzBizzDict.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (numAnsStr.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">        <span class="comment">// Not divisible by 3 or 5, add the number</span></span><br><span class="line">        numAnsStr += Integer.toString(num);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Append the current answer str to the ans list</span></span><br><span class="line">      ans.add(numAnsStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>用散列表Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fizzBuzz</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># ans list</span></span><br><span class="line">        ans = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Dictionary to store all fizzbuzz mappings</span></span><br><span class="line">        fizz_buzz_dict = &#123;<span class="number">3</span> : <span class="string">"Fizz"</span>, <span class="number">5</span> : <span class="string">"Buzz"</span>&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line"></span><br><span class="line">            num_ans_str = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> key <span class="keyword">in</span> fizz_buzz_dict.keys():</span><br><span class="line"></span><br><span class="line">                <span class="comment"># If the num is divisible by key,</span></span><br><span class="line">                <span class="comment"># then add the corresponding string mapping to current num_ans_str</span></span><br><span class="line">                <span class="keyword">if</span> num % key == <span class="number">0</span>:</span><br><span class="line">                    num_ans_str += fizz_buzz_dict[key]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> num_ans_str:</span><br><span class="line">                num_ans_str = str(num)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Append the current answer str to the ans list</span></span><br><span class="line">            ans.append(num_ans_str)  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度： <em>O(N)</em></li><li>空间复杂度： <em>O(1)</em></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写一个程序，输出从 1 到 n 数字的字符串表示。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年10月" scheme="http://yoursite.com/categories/2020%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>371. 两整数之和</title>
    <link href="http://yoursite.com/2020/10/04/371.%20%E4%B8%A4%E6%95%B4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://yoursite.com/2020/10/04/371. 两整数之和/</id>
    <published>2020-10-04T04:40:12.000Z</published>
    <updated>2020-10-04T16:25:24.939Z</updated>
    
    <content type="html"><![CDATA[<p>不使用运算符 + 和 -，计算两整数a、b之和。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: a = 1, b = 2输出: 3</code></pre><p>示例 2:</p><pre><code>输入: a = -2, b = 3输出: 1</code></pre><h1 id="利用位操作实现加法"><a href="#利用位操作实现加法" class="headerlink" title="利用位操作实现加法"></a>利用位操作实现加法</h1><p>首先看十进制是如何做的： 5+7=12，三步走 </p><ul><li>第一步：相加各位的值，不算进位，得到2。 </li><li>第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。  </li><li>第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。 </li></ul><p>同样我们可以用三步走的方式计算二进制值相加： 5—101，7—111 </p><ul><li>第一步：相加各位的值，不算进位，得到010，<strong>二进制每位相加就相当于各位做异或操作</strong>，101^111。 </li><li>第二步：计算进位值，得到1010，<strong>相当于各位进行与操作得到101，再向左移一位得到1010</strong>，(101&amp;111)&lt;&lt;1。  </li><li>第三步重复上述两步，各位相加 010^1010=1000，进位值为100=(010 &amp; 1010)&lt;&lt;1。 </li><li>继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。 </li><li>结束条件：<strong>进位为0，即a为最终的求和结果。</strong><details>  <summary>利用位操作实现加法</summary></details></li></ul><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(b != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = a ^ b;</span><br><span class="line">            b = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            a = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回顾一下我们小学就开始学习的十进制的加法，比如<code>15+7</code>，最低位<code>5+7</code>得到<code>12</code>，对<code>10</code>取模得到<code>2</code>，进位为<code>1</code>，再高位相加<code>1+0</code>再加上进位<code>1</code>就得到高位结果<code>2</code>,组合起来就是<code>22</code>。这里面涉及到了两个数字，一个是相加得到的低位，也就是<code>5+7</code>得到的结果<code>2</code>，第二个是进位<code>1</code>。在二进制的计算中就是要通过位操作来得到结果的低位和进位，对于不同的情况，用表格来表示一下，两个数字分别为<code>a</code>和<code>b</code></p><table><thead><tr><th align="center">a</th><th align="center">b</th><th align="center">低位</th><th align="center">进位</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">1</td></tr></tbody></table><p>从上面的表格就可以发现，<code>低位 = a^b</code>，<code>进位 = a &amp; b</code>。这样的计算可能要持续多次，回想一下在十进制的计算中，如果进位一直大于0，就得往后面进行计算，在这里也是一样，只要进位不是0，我们就得一直重复计算低位和进位的操作（需要在下一次计算之前要把进位向左移动一位，这样进位才能和更高位进行运算）。这个时候的<code>a</code>和<code>b</code>就是刚才计算的低位和进位，用简单的加法迭代的代码表示：</p><details>    <summary>利用位操作实现加法</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a==<span class="number">0</span>) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">if</span> (b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">int</span> lower;</span><br><span class="line">    <span class="keyword">int</span> carrier;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        lower = a^b;    <span class="comment">// 计算低位</span></span><br><span class="line">        carrier = a&amp;b;  <span class="comment">// 计算进位</span></span><br><span class="line">        <span class="keyword">if</span> (carrier==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        a = lower;</span><br><span class="line">        b = carrier&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lower;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不使用运算符 + 和 -，计算两整数a、b之和。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年10月" scheme="http://yoursite.com/categories/2020%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
  <entry>
    <title>202. 快乐数</title>
    <link href="http://yoursite.com/2020/10/04/202.%20%E5%BF%AB%E4%B9%90%E6%95%B0/"/>
    <id>http://yoursite.com/2020/10/04/202. 快乐数/</id>
    <published>2020-10-04T01:30:12.000Z</published>
    <updated>2020-10-04T04:38:25.560Z</updated>
    
    <content type="html"><![CDATA[<p>编写一个算法来判断一个数 n 是不是快乐数。</p><a id="more"></a><p>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为1，那么这个数就是快乐数。</p><p>如果 n 是快乐数就返回 True ；不是，则返回 False 。</p><p>示例：</p><pre><code>输入：19输出：true解释：1^2 + 9^2 = 828^2 + 2^2 = 686^2 + 8^2 = 1001^2 + 0^2 + 0^2 = 1</code></pre><h1 id="📺-视频题解"><a href="#📺-视频题解" class="headerlink" title="📺 视频题解"></a>📺 视频题解</h1><p><a href="9d8ce931-e835-45d1-a3d2-ab54b52b5377">202. 快乐数 - Lizzi.mp4</a></p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="方法一：用-HashSet-检测循环"><a href="#方法一：用-HashSet-检测循环" class="headerlink" title="方法一：用 HashSet 检测循环"></a>方法一：用 HashSet 检测循环</h2><p>我们可以先举几个例子。我们从 <em>7</em> 开始。则下一个数字是 <em>49<em>（因为 *7^2=49</em>），然后下一个数字是 <em>97</em>（因为 <em>4^2+9^2=97</em>）。我们可以不断重复该的过程，直到我们得到 <em>1</em>。因为我们得到了 <em>1</em>，我们知道 *7</em> 是一个快乐数，函数应该返回 <code>true</code>。</p><p><a href="https://assets.leetcode-cn.com/solution-static/202/202_fig1.png" target="_blank" rel="noopener">fig1</a></p><p>再举一个例子，让我们从 <em>116</em> 开始。通过反复通过平方和计算下一个数字，我们最终得到 <em>58</em>，再继续计算之后，我们又回到 <em>58</em>。由于我们回到了一个已经计算过的数字，可以知道有一个循环，因此不可能达到 <em>1</em>。所以对于 <em>116</em>，函数应该返回 <code>false</code>。</p><p><a href="https://assets.leetcode-cn.com/solution-static/202/202_fig2.png" target="_blank" rel="noopener">fig2</a></p><p>根据我们的探索，我们猜测会有以下三种可能。</p><ol><li>最终会得到 <em>1</em>。</li><li>最终会进入循环。</li><li>值会越来越大，最后接近无穷大。</li></ol><p>第三个情况比较难以检测和处理。我们怎么知道它会继续变大，而不是最终得到 <em>1</em> 呢？我们可以仔细想一想，每一位数的最大数字的下一位数是多少。</p><table><thead><tr><th>Digits</th><th align="center">Largest</th><th align="right">Next</th></tr></thead><tbody><tr><td>1</td><td align="center">9</td><td align="right">81</td></tr><tr><td>2</td><td align="center">99</td><td align="right">162</td></tr><tr><td>3</td><td align="center">999</td><td align="right">243</td></tr><tr><td>4</td><td align="center">9999</td><td align="right">324</td></tr><tr><td>13</td><td align="center">9999999999999</td><td align="right">1053</td></tr></tbody></table><p>对于 <em>3</em> 位数的数字，它不可能大于 <em>243*。这意味着它要么被困在 *243</em> 以下的循环内，要么跌到 <em>1</em>。<em>4</em> 位或 <em>4</em> 位以上的数字在每一步都会丢失一位，直到降到 <em>3</em> 位为止。所以我们知道，最坏的情况下，算法可能会在 <em>243</em> 以下的所有数字上循环，然后回到它已经到过的一个循环或者回到 <em>1</em>。但它不会无限期地进行下去，所以我们排除第三种选择。</p><p>即使在代码中你不需要处理第三种情况，你仍然需要理解为什么它永远不会发生，这样你就可以证明为什么你不处理它。</p><p><strong>算法：</strong></p><p>算法分为两部分，我们需要设计和编写代码。</p><ol><li>给一个数字 <em>n</em>，它的下一个数字是什么？</li><li>按照一系列的数字来判断我们是否进入了一个循环。</li></ol><p>第 1 部分我们按照题目的要求做数位分离，求平方和。</p><p>第 2 部分可以使用 HashSet 完成。每次生成链中的下一个数字时，我们都会检查它是否已经在 HashSet 中。</p><ul><li>如果它不在 HashSet 中，我们应该添加它。</li><li>如果它在 HashSet 中，这意味着我们处于一个循环中，因此应该返回 <code>false</code>。</li></ul><p>我们使用 HashSet  而不是向量、列表或数组的原因是因为我们反复检查其中是否存在某数字。检查数字是否在哈希集中需要 <em>O(1)</em> 的时间，而对于其他数据结构，则需要 <em>O(n)</em> 的时间。选择正确的数据结构是解决这些问题的关键部分。</p><details>    <summary>用 HashSet 检测循环Python</summary><figure class="highlight python"><figcaption><span>[solution1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isHappy</span><span class="params">(self, n: int)</span> -&gt; bool:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next</span><span class="params">(n)</span>:</span></span><br><span class="line">        total_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            n, digit = divmod(n, <span class="number">10</span>)</span><br><span class="line">            total_sum += digit ** <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> total_sum</span><br><span class="line"></span><br><span class="line">    seen = set()</span><br><span class="line">    <span class="keyword">while</span> n != <span class="number">1</span> <span class="keyword">and</span> n <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">        seen.add(n)</span><br><span class="line">        n = get_next(n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span></span><br></pre></td></tr></table></figure></details><details>    <summary>用 HashSet 检测循环Java</summary><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = n % <span class="number">10</span>;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">            totalSum += d * d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; seen = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">1</span> &amp;&amp; !seen.contains(n)) &#123;</span><br><span class="line">            seen.add(n);</span><br><span class="line">            n = getNext(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>用 HashSet 检测循环C#</summary><figure class="highlight csharp"><figcaption><span>[solution1-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNext</span>(<span class="params"><span class="keyword">int</span> n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = n % <span class="number">10</span>;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">            totalSum += d * d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsHappy</span>(<span class="params"><span class="keyword">int</span> n</span>) </span>&#123;</span><br><span class="line">        HashSet &lt;<span class="keyword">int</span>&gt; seen = <span class="keyword">new</span> HashSet&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">1</span> &amp;&amp; !seen.Contains(n)) &#123;</span><br><span class="line">            seen.Add(n);</span><br><span class="line">            n = getNext(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>用 HashSet 检测循环Golang</summary><figure class="highlight golang"><figcaption><span>[solution1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isHappy</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> ; n != <span class="number">1</span> &amp;&amp; !m[n]; n, m[n] = step(n), <span class="literal">true</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">step</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        sum += (n%<span class="number">10</span>) * (n%<span class="number">10</span>)</span><br><span class="line">        n = n/<span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><p>确定这个问题的时间复杂度对于一个 “简单” 级别的问题来说是一个挑战。如果您对这些问题还不熟悉，可以尝试只计算  <code>getNext(n)</code> 函数的时间复杂度。</p><ul><li>时间复杂度：<br>O(243 *3 + logn+loglogn+logloglogn)…=O(logn)。<ul><li>查找给定数字的下一个值的成本为O(logn) ，因为我们正在处理数字中的每位数字，而数字中的位数由 logn 给定。</li><li>要计算出总的时间复杂度，我们需要仔细考虑循环中有多少个数字，它们有多大。</li></ul><ul><li>我们在上面确定，一旦一个数字低于 <em>243*，它就不可能回到 *243</em> 以上。因此，我们就可以用 <em>243</em> 以下最长循环的长度来代替 <em>243</em>，不过，因为常数无论如何都无关紧要，所以我们不会担心它。</li><li>对于高于 <em>243</em> 的 <em>n</em>，我们需要考虑循环中每个数高于 <em>243</em> 的成本。通过数学运算，我们可以证明在最坏的情况下，这些成本将是 O(logn)+O(loglogn)+O(logloglogn) 。幸运的是，O(logn)  是占主导地位的部分，而其他部分相比之下都很小（总的来说，它们的总和小于O(logn)），所以我们可以忽略它们。</li></ul></li><li>空间复杂度：O(logn) 。与时间复杂度密切相关的是衡量我们放入 HashSet 中的数字以及它们有多大的指标。对于足够大的 <em>n</em>，大部分空间将由 <em>n</em> 本身占用。我们可以很容易地优化到O(243<em>3)=O(1) ，方法是只保存集合中小于 *243</em> 的数字，因为对于较高的数字，无论如何都不可能返回到它们。</li></ul><h2 id="方法二：快慢指针法"><a href="#方法二：快慢指针法" class="headerlink" title="方法二：快慢指针法"></a>方法二：快慢指针法</h2><p>通过反复调用 <code>getNext(n)</code> 得到的链是一个隐式的链表。隐式意味着我们没有实际的链表节点和指针，但数据仍然形成链表结构。起始数字是链表的头 “节点”，链中的所有其他数字都是节点。<code>next</code> 指针是通过调用 <code>getNext(n)</code> 函数获得。</p><p>意识到我们实际有个链表，那么这个问题就可以转换为检测一个链表是否有环。因此我们在这里可以使用弗洛伊德循环查找算法。这个算法是两个奔跑选手，一个跑的快，一个跑得慢。在龟兔赛跑的寓言中，跑的快的称为 “乌龟”，跑得快的称为 “兔子”。</p><p>不管乌龟和兔子在循环中从哪里开始，它们最终都会相遇。这是因为兔子每走一步就向乌龟靠近一个节点（在它们的移动方向上）。</p><p> <a href="https://assets.leetcode-cn.com/solution-static/202/1.jpg" target="_blank" rel="noopener">fig1</a> <a href="https://assets.leetcode-cn.com/solution-static/202/2.jpg" target="_blank" rel="noopener">fig2</a> <a href="https://assets.leetcode-cn.com/solution-static/202/3.jpg" target="_blank" rel="noopener">fig3</a> <a href="https://assets.leetcode-cn.com/solution-static/202/4.jpg" target="_blank" rel="noopener">fig4</a> <a href="https://assets.leetcode-cn.com/solution-static/202/5.jpg" target="_blank" rel="noopener">fig5</a> <a href="https://assets.leetcode-cn.com/solution-static/202/6.jpg" target="_blank" rel="noopener">fig6</a> <a href="https://assets.leetcode-cn.com/solution-static/202/7.jpg" target="_blank" rel="noopener">fig7</a> <a href="https://assets.leetcode-cn.com/solution-static/202/8.jpg" target="_blank" rel="noopener">fig8</a> </p><p><strong>算法：</strong></p><p>我们不是只跟踪链表中的一个值，而是跟踪两个值，称为快跑者和慢跑者。在算法的每一步中，慢速在链表中前进 1 个节点，快跑者前进 2 个节点（对 <code>getNext(n)</code> 函数的嵌套调用）。</p><p>如果 <code>n</code> 是一个快乐数，即没有循环，那么快跑者最终会比慢跑者先到达数字 1。</p><p>如果 <code>n</code> 不是一个快乐的数字，那么最终快跑者和慢跑者将在同一个数字上相遇。</p><details>    <summary>快慢指针法Python</summary><figure class="highlight python"><figcaption><span>[solution2-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isHappy</span><span class="params">(self, n: int)</span> -&gt; bool:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next</span><span class="params">(number)</span>:</span></span><br><span class="line">        total_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> number &gt; <span class="number">0</span>:</span><br><span class="line">            number, digit = divmod(number, <span class="number">10</span>)</span><br><span class="line">            total_sum += digit ** <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> total_sum</span><br><span class="line"></span><br><span class="line">    slow_runner = n</span><br><span class="line">    fast_runner = get_next(n)</span><br><span class="line">    <span class="keyword">while</span> fast_runner != <span class="number">1</span> <span class="keyword">and</span> slow_runner != fast_runner:</span><br><span class="line">        slow_runner = get_next(slow_runner)</span><br><span class="line">        fast_runner = get_next(get_next(fast_runner))</span><br><span class="line">    <span class="keyword">return</span> fast_runner == <span class="number">1</span></span><br></pre></td></tr></table></figure></details><details>    <summary>快慢指针法Java</summary><figure class="highlight java"><figcaption><span>[solution2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = n % <span class="number">10</span>;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">            totalSum += d * d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slowRunner = n;</span><br><span class="line">        <span class="keyword">int</span> fastRunner = getNext(n);</span><br><span class="line">        <span class="keyword">while</span> (fastRunner != <span class="number">1</span> &amp;&amp; slowRunner != fastRunner) &#123;</span><br><span class="line">            slowRunner = getNext(slowRunner);</span><br><span class="line">            fastRunner = getNext(getNext(fastRunner));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fastRunner == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>快慢指针法C#</summary><figure class="highlight csharp"><figcaption><span>[solution2-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNext</span>(<span class="params"><span class="keyword">int</span> n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = n % <span class="number">10</span>;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">            totalSum += d * d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsHappy</span>(<span class="params"><span class="keyword">int</span> n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slowRunner = n;</span><br><span class="line">        <span class="keyword">int</span> fastRunner = getNext(n);</span><br><span class="line">        <span class="keyword">while</span> (fastRunner != <span class="number">1</span> &amp;&amp; slowRunner != fastRunner) &#123;</span><br><span class="line">            slowRunner = getNext(slowRunner);</span><br><span class="line">            fastRunner = getNext(getNext(fastRunner));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fastRunner == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>快慢指针法Golang</summary><figure class="highlight golang"><figcaption><span>[solution2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isHappy</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    slow, fast := n, step(n)</span><br><span class="line">    <span class="keyword">for</span> fast != <span class="number">1</span> &amp;&amp; slow != fast &#123;</span><br><span class="line">        slow = step(slow)</span><br><span class="line">        fast = step(step(fast))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fast == <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">step</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        sum += (n%<span class="number">10</span>) * (n%<span class="number">10</span>)</span><br><span class="line">        n = n/<span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(logn)  。该分析建立在对前一种方法的分析的基础上，但是这次我们需要跟踪两个指针而不是一个指针来分析，以及在它们相遇前需要绕着这个循环走多少次。<ul><li>如果没有循环，那么快跑者将先到达 1，慢跑者将到达链表中的一半。我们知道最坏的情况下，成本是    O(2logn) = O(logn) 。</li><li>一旦两个指针都在循环中，在每个循环中，快跑者将离慢跑者更近一步。一旦快跑者落后慢跑者一步，他们就会在下一步相遇。假设循环中有 <em>k</em> 个数字。如果他们的起点是相隔 <em>k-1</em> 的位置（这是他们可以开始的最远的距离），那么快跑者需要 <em>k-1</em> 步才能到达慢跑者，这对于我们的目的来说也是不变的。因此，主操作仍然在计算起始 n 的下一个值，即 O(logn)  。</li></ul></li><li>空间复杂度：<em>O(1)</em>，对于这种方法，我们不需要哈希集来检测循环。指针需要常数的额外空间。</li></ul><h2 id="方法三：数学"><a href="#方法三：数学" class="headerlink" title="方法三：数学"></a>方法三：数学</h2><p>前两种方法是你在面试中应该想到的。第三种方法不是你在面试中会写的，而是针对对数学好奇的人，因为它很有趣。</p><p>下一个值可能比自己大的最大数字是什么？根据我们之前的分析，我们知道它必须低于 243。因此，我们知道任何循环都必须包含小于 243 的数字，用这么小的数字，编写一个能找到所有周期的强力程序并不困难。</p><p>如果这样做，您会发现只有一个循环：4→16→37→58→89→145→42→20→4 。所有其他数字都在进入这个循环的链上，或者在进入 <em>1</em> 的链上。</p><p>因此，我们可以硬编码一个包含这些数字的散列集，如果我们达到其中一个数字，那么我们就知道在循环中。</p><p><strong>算法：</strong></p><details>    <summary>数学Python</summary><figure class="highlight python"><figcaption><span>[solution3-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isHappy</span><span class="params">(self, n: int)</span> -&gt; bool:</span></span><br><span class="line"></span><br><span class="line">    cycle_members = &#123;<span class="number">4</span>, <span class="number">16</span>, <span class="number">37</span>, <span class="number">58</span>, <span class="number">89</span>, <span class="number">145</span>, <span class="number">42</span>, <span class="number">20</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next</span><span class="params">(number)</span>:</span></span><br><span class="line">        total_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> number &gt; <span class="number">0</span>:</span><br><span class="line">            number, digit = divmod(number, <span class="number">10</span>)</span><br><span class="line">            total_sum += digit ** <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> total_sum</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> n != <span class="number">1</span> <span class="keyword">and</span> n <span class="keyword">not</span> <span class="keyword">in</span> cycle_members:</span><br><span class="line">        n = get_next(n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span></span><br></pre></td></tr></table></figure></details><details>    <summary>数学Java</summary><figure class="highlight java"><figcaption><span>[solution3-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Set&lt;Integer&gt; cycleMembers =</span><br><span class="line">        <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="number">4</span>, <span class="number">16</span>, <span class="number">37</span>, <span class="number">58</span>, <span class="number">89</span>, <span class="number">145</span>, <span class="number">42</span>, <span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = n % <span class="number">10</span>;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">            totalSum += d * d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">1</span> &amp;&amp; !cycleMembers.contains(n)) &#123;</span><br><span class="line">            n = getNext(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>数学C#</summary><figure class="highlight csharp"><figcaption><span>[solution3-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNext</span>(<span class="params"><span class="keyword">int</span> n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = n % <span class="number">10</span>;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">            totalSum += d * d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsHappy</span>(<span class="params"><span class="keyword">int</span> n</span>) </span>&#123;</span><br><span class="line">        HashSet&lt;<span class="keyword">int</span>&gt; cycleMembers =</span><br><span class="line">            <span class="keyword">new</span> HashSet&lt;<span class="keyword">int</span>&gt;(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>] &#123;<span class="number">4</span>, <span class="number">16</span>, <span class="number">37</span>, <span class="number">58</span>, <span class="number">89</span>, <span class="number">145</span>, <span class="number">42</span>, <span class="number">20</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">1</span> &amp;&amp; !cycleMembers.Contains(n)) &#123;</span><br><span class="line">            n = getNext(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>数学Golang</summary><figure class="highlight golang"><figcaption><span>[solution3-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isHappy</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    cycle := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>&#123;<span class="number">4</span>: <span class="literal">true</span>, <span class="number">6</span>: <span class="literal">true</span>, <span class="number">37</span>: <span class="literal">true</span>, <span class="number">58</span>: <span class="literal">true</span>, <span class="number">89</span>: <span class="literal">true</span>, <span class="number">145</span>: <span class="literal">true</span>, <span class="number">42</span>: <span class="literal">true</span>, <span class="number">20</span>: <span class="literal">true</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> n != <span class="number">1</span> &amp;&amp; !cycle[n] &#123;</span><br><span class="line">        n = step(n)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">step</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        sum += (n%<span class="number">10</span>) * (n%<span class="number">10</span>)</span><br><span class="line">        n = n/<span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(logn)  。和上面一样。</li><li>空间复杂度：<em>O(1)</em>，我们没有保留我们所遇到的数字的历史记录。硬编码哈希集的大小是固定的。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写一个算法来判断一个数 n 是不是快乐数。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年10月" scheme="http://yoursite.com/categories/2020%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>326. 3的幂</title>
    <link href="http://yoursite.com/2020/09/30/326.%203%E7%9A%84%E5%B9%82/"/>
    <id>http://yoursite.com/2020/09/30/326. 3的幂/</id>
    <published>2020-09-30T06:30:12.000Z</published>
    <updated>2020-10-03T16:14:24.038Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数，写一个函数来判断它是否是3的幂次方。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: 27输出: true</code></pre><p>示例 2:</p><pre><code>输入: 0输出: false</code></pre><p>示例 3:</p><pre><code>输入: 9输出: true</code></pre><p>示例 4:</p><pre><code>输入: 45输出: false</code></pre><p>进阶：</p><pre><code>你能不使用循环或者递归来完成本题吗？</code></pre><h1 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h1><p>在本文中，我们将探讨加速简单计算的方法，以及为什么在实践中有用。 </p><h2 id="方法一：循环迭代"><a href="#方法一：循环迭代" class="headerlink" title="方法一：循环迭代"></a>方法一：循环迭代</h2><p>找出数字 <code>n</code> 是否是数字 <code>b</code> 的幂的一个简单方法是，<code>n%3</code>  只要余数为 0，就一直将 <code>n</code> 除以 <code>b</code>。</p><pre><code>n=b^x * n=b*b*...*b</code></pre><p>因此，应该可以将 <code>n</code> 除以 <code>b</code>  x 次，每次都有 0 的余数，最终结果是 1。 </p><details>    <summary>循环迭代</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            n /= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>注意我们需要一个警卫来检查那个 <code>n！=0</code>，否则 while 循环将永远不会结束。对于负数，该算法没有意义，因此我们也将包括该保护。 </p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(log_b(n)) ，在我们的例子中是O(logn) 。除数是用对数表示的。 </li><li>空间复杂度：<em>O(1)</em>，没有使用额外的空间。</li></ul><h2 id="方法二：基准转换"><a href="#方法二：基准转换" class="headerlink" title="方法二：基准转换"></a>方法二：基准转换</h2><p>在基数 10 中，10 的所有幂都从数字 1 开始，然后只跟 0（例如10、100、1000）。其他基地及其各自的权力也是如此。例如，在基数 2 中，<em>10 _2<em>、</em>100 _2</em> 和 <em>1000 _2</em> 分别表示为  <em>2_{10}</em>, <em>4_{10}</em> 和 <em>8_{10}</em>。因此，如果我们把我们的数转换成基3，并且表示形式是 100…0，那么这个数就是3的幂。</p><p><strong>证明 ：</strong><br>给定以 3 为底的数字表示为数组 <code>s</code>，第 0 位开始为有效数。<br>因此，只有一个数字 1，其余的都是 0，这意味着这个数字是 3 的幂。 </p><p><strong>实现：</strong></p><ul><li>我们所要做的就是将数字转换为以3为底的基数 ，并检查它是否为前导1，后跟所有 0。 </li><li>两个内置的Java函数将帮助我们前进。 </li></ul><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String baseChange = Integer.toString(number, base);</span><br></pre></td></tr></table></figure><ul><li>上面的代码将 <code>number</code> 转换以 <code>base</code> 为底的基数，并以字符串形式返回结果。例如，<code>integer.toString（5，2）=“101”</code> 和 <code>integer.toString（5，3）=“12”</code>。 </li></ul><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> matches = myString.matches(<span class="string">"123"</span>);</span><br></pre></td></tr></table></figure><p>上面的代码检查字符串中是否存在特定的正则表达式。例如，如果字符串 <code>mystring</code> 中存在子字符串 “123”，上面的内容将返回 true。 </p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> powerOfThree = baseChange.matches(<span class="string">"^10**"</span>)</span><br></pre></td></tr></table></figure><p>我们将使用上面的正则表达式来检查字符串是否以1 <code>^1</code> 开头，后跟 0 或 多个 0 <code>0*</code> 并且不包含任何其他值 <code>*</code>。</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.toString(n, <span class="number">3</span>).matches(<span class="string">"^10**"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(log_3n)</em>。<ul><li>假设：<ul><li><code>Integer.toString()</code> - 基转换通常是作为一个重复的除法来实现的。复杂性应该类似于我们的方法 1:<em>O（\ log_3n）</em>的复杂性。</li><li><code>String.matches()</code> - 方法迭代整个字符串。<code>n</code> 以 3 为基数表示的位数是<em>O（\log_3n）</em>。 </li></ul></li></ul></li><li>空间复杂度：<em>O(\log_3n)</em>。我们使用两个附加变量。<ul><li>以 3 为基数表示数字的字符串（大小为 <em>\log_3n</em>）</li><li>正则表达式的字符串（常量大小） </li></ul></li></ul><h2 id="方法三：运算法"><a href="#方法三：运算法" class="headerlink" title="方法三：运算法"></a>方法三：运算法</h2><p>我们可以用下面的数学公式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n = 3^i </span><br><span class="line"></span><br><span class="line">\ i = \ log_3(n) </span><br><span class="line"></span><br><span class="line">\ i = \frac&#123;\ log_b(n)&#125;&#123;\ log_b(3)&#125;</span><br></pre></td></tr></table></figure><p>若 <code>n</code> 是 3 的幂则 <code>i</code> 是整数。在 Java 中，我们通过取小数部分（利用 <code>% 1</code>）来检查数字是否是整数，并检查它是否是 0。 </p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Math.log10(n) / Math.log10(<span class="number">3</span>)) % <span class="number">1</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>常见的陷阱 :</strong><br>这个解决方案是有问题的，因为我们开始使用 <code>double</code> s，这意味着我们会遇到精度错误。说明在比较双精度数时不应使用 <code>==</code>。这是因为 <code>Math.log10(n)/Math.log10(3)</code> 的结果可能是 <code>5.0000001</code> 或 <code>4.9999999</code>。使用 <code>Math.log()</code> 函数而不是<code>Math.log10()</code> 可以观察到这种效果。 </p><p>为了解决这个问题，我们需要将结果与 <code>epsilon</code> 进行比较。</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (Math.log(n) / Math.log(<span class="number">3</span>) + epsilon) % <span class="number">1</span> &lt;= <span class="number">2</span> * epsilon;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：*Unknown$。这里主要消耗时间的运算是 <code>Math.log</code>，它限制了我们算法的时间复杂性。实现依赖于我们使用的语言和编译器 。</li><li>空间复杂度： <em>O(1)</em>，我们没有使用任何额外的内存。<code>epsilon</code> 变量可以是内联的。 </li></ul><h2 id="方法四：整数限制"><a href="#方法四：整数限制" class="headerlink" title="方法四：整数限制"></a>方法四：整数限制</h2><p>一个重要的信息可以从函数名中推导出来。</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br></pre></td></tr></table></figure><p>我们可以看出 <code>n</code> 的类型是  <code>int</code>。在 Java 中说明了该变量是四个字节，他的最大值为 <strong>2147483647</strong>。有三种方法可以计算出该最大值。</p><ol><li><a href="http://stackoverflow.com/questions/15004944/max-value-of-integer" target="_blank" rel="noopener">Google</a></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3. MaxInt = 2^32/2 - 1 ,因为我们使用 32 位来表示数字，所以范围的一半用于负数，0 是正数的一部分。</span><br><span class="line"></span><br><span class="line">知道了 `n` 的限制，我们现在可以推断出 `n` 的最大值，也就是 3 的幂，是 **1162261467**。我们计算如下： </span><br><span class="line"></span><br><span class="line">```math</span><br><span class="line">3^&#123;\lfloor&#123;&#125;\log_3&#123;MaxInt&#125;\rfloor&#123;&#125;&#125; = 3^&#123;\lfloor&#123;&#125;19.56\rfloor&#123;&#125;&#125; = 3^&#123;19&#125; = 1162261467</span><br></pre></td></tr></table></figure></li></ol><p>因此，我们应该返回 <code>true</code> 的 <code>n</code> 的可能值是 <em>3^0<em>，</em>3^1<em>…</em>3 ^ {19}*。因为 3 是质数，所以 *3^{19}</em> 的除数只有 <em>3^0<em>，</em>3^1<em>…</em>3 ^{19}*，因此我们只需要将 *3^{19}</em> 除以 <code>n</code>。若余数为 <strong>0</strong> 意味着 <code>n</code> 是 *3^{19}$ 的除数，因此是 3 的幂。 </p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; <span class="number">1162261467</span> % n == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(1)</em>。我们只做了一次操作。 </li><li>空间复杂度： <em>O(1)</em>，没有使用额外空间。</li></ul><h2 id="性能测量-："><a href="#性能测量-：" class="headerlink" title="性能测量 ："></a>性能测量 ：</h2><p>函数的单次运行使得难以测量两种解的差别。在 leetcode 上的 $Accepted* <em>Solutions</em>  <em>Runtime</em> <em>Distribution</em> 页面上，所有解决方案都在 <code>15 ms</code> 到 <code>20 ms</code> 之间。为了完整性，我们提出了以下基准，以了解这两个解决方案的区别。 </p><p><strong>Java基准码 :</strong></p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Solution sol = <span class="keyword">new</span> Solution();</span><br><span class="line">    <span class="keyword">int</span> iterations = <span class="number">1</span>; <span class="comment">// See table header for this value</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">        sol.isPowerOfThree(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在下表中，以秒为单位。<br>| Iterations |<em>10^6</em> |<em>10^7</em>|<em>10^8</em>|<em>10^9</em>|*Maxint$|<br>|–|–|–|–|–|–|<br>| Java Approach 1: (Naive) | 0.04 |0.07|0.30|2.47|5.26|<br>|Java Approach 2: (Strings) | 0.68 |4.02|38.90|409.16|893.89|<br>| Java Approach 3: (Logarithms) | 0.09 |0.50|4.59|45.53|97.50|<br>|Java Approach 4: (Fast) | 0.04 |0.06|0.08|0.41|0.78|</p><p>正如我们所看到的，对于小的 N 值，差异并不明显，但是随着我们进行更多的迭代，并且传递给 <code>isPowerOfThree()</code> 的 <code>n</code> 的值增长，我们看到方法 4 的性能显著提高。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论 :"></a>结论 :</h2><p>像这样的简单优化似乎可以忽略不计，但历史上，当计算能力成为一个问题时，它允许某些计算机程序（如Quake 3）成为可能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数，写一个函数来判断它是否是3的幂次方。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>268. 缺失数字</title>
    <link href="http://yoursite.com/2020/09/30/268.%20%E7%BC%BA%E5%A4%B1%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2020/09/30/268. 缺失数字/</id>
    <published>2020-09-30T02:30:12.000Z</published>
    <updated>2020-09-30T03:16:46.091Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: [3,0,1]输出: 2</code></pre><p>示例 2:</p><pre><code>输入: [9,6,4,2,3,5,7,0,1]输出: 8</code></pre><p>说明:</p><pre><code>你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现?</code></pre><h1 id="方法一：排序"><a href="#方法一：排序" class="headerlink" title="方法一：排序"></a>方法一：排序</h1><p><strong>分析</strong></p><p>如果数组是有序的，那么就很容易知道缺失的数字是哪个了。</p><p><strong>算法</strong></p><p>首先我们对数组进行排序，随后我们可以在常数时间内判断两种特殊情况：0 没有出现在数组的首位，以及 <em>n</em> 没有出现在数组的末位。如果这两种特殊情况都不满足，那么缺失的数字一定在 0 和 <em>n</em> 之间（不包括两者）。此时我们可以在线性时间内扫描这个数组，如果某一个数比它前面的那个数大了超过 1，那么这两个数之间的那个数即为缺失的数字。</p><details>    <summary>排序Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断 n 是否出现在末位</span></span><br><span class="line">        <span class="keyword">if</span> (nums[nums.length-<span class="number">1</span>] != nums.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断 0 是否出现在首位</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[<span class="number">0</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时缺失的数字一定在 (0, n) 中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> expectedNum = nums[i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != expectedNum) &#123;</span><br><span class="line">                <span class="keyword">return</span> expectedNum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 未缺失任何数字（保证函数有返回值）</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>排序Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        nums.sort()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Ensure that n is at the last index</span></span><br><span class="line">        <span class="keyword">if</span> nums[<span class="number">-1</span>] != len(nums):</span><br><span class="line">            <span class="keyword">return</span> len(nums)</span><br><span class="line">        <span class="comment"># Ensure that 0 is at the first index</span></span><br><span class="line">        <span class="keyword">elif</span> nums[<span class="number">0</span>] != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># If we get here, then the missing number is on the range (0, n)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            expected_num = nums[i<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] != expected_num:</span><br><span class="line">                <span class="keyword">return</span> expected_num</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(nlogn)。由于排序的时间复杂度为 O(nlogn) ，扫描数组的时间复杂度为 <em>O(n)</em>，因此总的时间复杂度为O(nlogn)。</li><li>空间复杂度：<em>O(1)</em> 或 <em>O(n)*。空间复杂度取决于使用的排序算法，根据排序算法是否进行原地排序（即不使用额外的数组进行临时存储），空间复杂度为 *O(1)</em> 或 <em>O(n)</em>。</li></ul><h1 id="方法二：哈希表"><a href="#方法二：哈希表" class="headerlink" title="方法二：哈希表"></a>方法二：哈希表</h1><p><strong>分析</strong></p><p>我们可以直接查询每个数是否在数组中出现过来找出缺失的数字。如果使用哈希表，那么每一次查询操作都是常数时间的。</p><p><strong>算法</strong></p><p>我们将数组中的所有数插入到一个集合中，这样每次查询操作的时间复杂度都是 <em>O(1)</em> 的。</p><details>    <summary>哈希表Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; numSet = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) numSet.add(num);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> expectedNumCount = nums.length + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> number = <span class="number">0</span>; number &lt; expectedNumCount; number++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!numSet.contains(number)) &#123;</span><br><span class="line">                <span class="keyword">return</span> number;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>哈希表Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        num_set = set(nums)</span><br><span class="line">        n = len(nums) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> number <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> number <span class="keyword">not</span> <span class="keyword">in</span> num_set:</span><br><span class="line">                <span class="keyword">return</span> number</span><br></pre></td></tr></table></figure></details>**复杂度分析**<ul><li>时间复杂度：<em>O(n)<em>。集合的插入操作的时间复杂度都是 *O(1)</em>，一共插入了 *n</em> 个数，时间复杂度为 <em>O(n)<em>。集合的查询操作的时间复杂度同样是 *O(1)</em>，最多查询 *n+1</em> 次，时间复杂度为 <em>O(n)</em>。因此总的时间复杂度为 <em>O(n)</em>。</li><li>空间复杂度：<em>O(n)*。集合中会存储 *n</em> 个数，因此空间复杂度为 <em>O(n)</em>。</li></ul><h1 id="方法三：位运算"><a href="#方法三：位运算" class="headerlink" title="方法三：位运算"></a>方法三：位运算</h1><p><strong>分析</strong></p><p>由于异或运算（XOR）满足结合律，并且对一个数进行两次完全相同的异或运算会得到原来的数，因此我们可以通过异或运算找到缺失的数字。</p><p><strong>算法</strong></p><p>我们知道数组中有 <em>n</em> 个数，并且缺失的数在 <em>[0..n]</em> 中。因此我们可以先得到 <em>[0..n]</em> 的异或值，再将结果对数组中的每一个数进行一次异或运算。未缺失的数在 <em>[0..n]</em> 和数组中各出现一次，因此异或后得到 0。而缺失的数字只在 <em>[0..n]</em> 中出现了一次，在数组中没有出现，因此最终的异或结果即为这个缺失的数字。</p><p>在编写代码时，由于 <em>[0..n]</em> 恰好是这个数组的下标加上 <em>n</em>，因此可以用一次循环完成所有的异或运算，例如下面这个例子：</p><table><thead><tr><th>下标</th><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>数字</td><td>0</td><td>1</td><td>3</td><td>4</td></tr></tbody></table><p>可以将结果的初始值设为 <em>n</em>，再对数组中的每一个数以及它的下标进行一个异或运算，<br>就得到了缺失的数字为 2。</p><details>    <summary>位运算Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> missing = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            missing ^= i ^ nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> missing;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>位运算Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        missing = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            missing ^= i ^ num</span><br><span class="line">        <span class="keyword">return</span> missing</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(n)*。这里假设异或运算的时间复杂度是常数的，总共会进行 *O(n)</em> 次异或运算，因此总的时间复杂度为 <em>O(n)</em>。</li><li>空间复杂度：<em>O(1)*。算法中只用到了 *O(1)</em> 的额外空间，用来存储答案。</li></ul><h1 id="方法四：数学"><a href="#方法四：数学" class="headerlink" title="方法四：数学"></a>方法四：数学</h1><p><strong>分析</strong></p><p>我们可以用 <a href="https://baike.baidu.com/item/%E9%AB%98%E6%96%AF%E6%B1%82%E5%92%8C" target="_blank" rel="noopener">高斯求和公式</a> 求出 <em>[0..n]</em> 的和，减去数组中所有数的和，就得到了缺失的数字。</p><p><strong>算法</strong></p><p>我们在线性时间内可以求出数组中所有数的和，并在常数时间内求出前 <em>n+1</em> 个自然数（包括 0）的和，将后者减去前者，就得到了缺失的数字。</p><details>    <summary>数学Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> expectedSum = nums.length*(nums.length + <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> actualSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) actualSum += num;</span><br><span class="line">        <span class="keyword">return</span> expectedSum - actualSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>数学Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        expected_sum = len(nums)*(len(nums)+<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line">        actual_sum = sum(nums)</span><br><span class="line">        <span class="keyword">return</span> expected_sum - actual_sum</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(n)</em>。求出数组中所有数的和的时间复杂度为 <em>O(n)</em>，高斯求和公式的时间复杂度为 <em>O(1)</em>，因此总的时间复杂度为 <em>O(n)</em>。</li><li>空间复杂度：<em>O(1)*。算法中只用到了 *O(1)</em> 的额外空间，用来存储答案。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>204. 计数质数</title>
    <link href="http://yoursite.com/2020/09/29/204.%20%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0/"/>
    <id>http://yoursite.com/2020/09/29/204. 计数质数/</id>
    <published>2020-09-29T08:30:12.000Z</published>
    <updated>2020-09-30T02:45:06.077Z</updated>
    
    <content type="html"><![CDATA[<p>统计所有小于非负整数 n 的质数的数量。</p><a id="more"></a><p>示例 1：</p><pre><code>输入：n = 10输出：4解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</code></pre><p>示例 2：</p><pre><code>输入：n = 0输出：0</code></pre><p>示例 3：</p><pre><code>输入：n = 1输出：0</code></pre><p>提示：</p><pre><code>0 &lt;= n &lt;= 5 * 106</code></pre><h1 id="总括："><a href="#总括：" class="headerlink" title="总括："></a>总括：</h1><p>此篇题解将共讲述暴力算法、优化暴力算法、厄拉多塞（话说这位老哥第一个量了地球周长）所创造的厄拉多塞筛法、及运用厄拉多塞筛法时于内存上的优化方法。在解释思路时，将尽量一步步地进行详细解读。</p><p>希望对大家能有所帮助！</p><hr><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h1><h2 id="暴力法（计算超时）："><a href="#暴力法（计算超时）：" class="headerlink" title="暴力法（计算超时）："></a><strong>暴力法（计算超时）：</strong></h2><p>验证一个数是否为质数（素数）有很多方法。但最容易想到的莫非用暴力计算的方式一步步碾压过去的方法。虽然这种方法不是最优的，但是其对于我们了解素数仍是有所帮助的。</p><p>思路：验证某个数是否为质数时，将其对每一个比其小的数进行取余运算，并对取余为零的情况进行计数。由于质数是指在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。所以，当计数结果为 1 时，该数为质数。</p><p>在实际操作中，由于 1 和任意一个数必然取余为零，所以可以直接排除。并当没有取余为零的情况时，其才为质数。</p><p>得代码如下：</p><details>    <summary>暴力法Csharp</summary><figure class="highlight csharp"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CountPrimes</span>(<span class="params"><span class="keyword">int</span> n</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> sign = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % j == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sign = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sign)</span><br><span class="line">            count++; ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>暴力法C++</summary><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">bool</span> sign = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i % j == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sign = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sign)</span><br><span class="line">            count++; ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="优化暴力算法："><a href="#优化暴力算法：" class="headerlink" title="优化暴力算法："></a><strong>优化暴力算法：</strong></h2><p>细究暴力计算的方法，我们可以发现，假如一个数为 9 ，那么其二分之一（4.5）后的数都可以不用进行计算，因为肯定是有余的 。事实上情况会比这更好一些：对正整数 n ，如果用 2 到 √n 之间(包含边界)的所有整数去除，均无法整除，则 n 为质数。</p><p>并且，我们可以发现，一切非 2 偶数一定不可能为质数。所以，我们可以在此处进行另一步的优化。</p><p>有个这些令人庆幸的发现，我们的代码也将如虎添翼：</p><details>    <summary>暴力法Csharp</summary><figure class="highlight csharp"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CountPrimes</span>(<span class="params"><span class="keyword">int</span> n</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;;</span><br><span class="line">    <span class="comment">//从3开始验算，所以初始值为1（2为质数）。</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当某个数为 2 的 n 次方时（n为自然数），其 &amp; (n - 1) 所得值将等价于取余运算所得值</span></span><br><span class="line">        <span class="comment">//*如果 x = 2^n ，则 x &amp; (n - 1) == x % n</span></span><br><span class="line">        <span class="comment">//if(i % 2 == 0)</span></span><br><span class="line">        <span class="keyword">if</span> ((i &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>; ;</span><br><span class="line">        <span class="keyword">bool</span> sign = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//用 j * j &lt;= i 代替 j &lt;= √i 会更好。</span></span><br><span class="line">        <span class="comment">//因为我们已经排除了所有偶数，所以每次循环加二将规避偶数会减少循环次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">3</span>; j * j &lt;=i; j+=<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % j == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sign = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sign)</span><br><span class="line">            count++; ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>暴力法C++</summary><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;;</span><br><span class="line">    <span class="comment">//从3开始验算，所以初始值为1（2为质数）。</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="comment">//当某个数为 2 的 n 次方时（n为自然数），其 &amp; (n - 1) 所得值将等价于取余运算所得值</span></span><br><span class="line">        <span class="comment">//*如果 x = 2^n ，则 x &amp; (n - 1) == x % n</span></span><br><span class="line">        <span class="comment">//if(i % 2 == 0)</span></span><br><span class="line">        <span class="keyword">if</span> ((i &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>; ;</span><br><span class="line">        <span class="keyword">bool</span> sign = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//用 j * j &lt;= i 代替 j &lt;= √i 会更好。</span></span><br><span class="line">        <span class="comment">//因为我们已经排除了所有偶数，所以每次循环加二将规避偶数会减少循环次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">3</span>; j * j &lt;=i; j+=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i % j == <span class="number">0</span>)&#123;</span><br><span class="line">                sign = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sign)</span><br><span class="line">            count++; ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>暴力法Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (odd(i)) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">odd</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i*i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>(暴力法系列的 C# 和 C++ 的代码几乎相同。)</p><p>经过对暴力算法的此番优化，我们的代码初步达到了应用的最低门槛，但显然还是不大理想，好似总感觉存在不必要的操作。但我们经过以上的研究（可以早一步排除偶数），再结合质数的性质，可以推想出：如果我们在进行顺序遍历时，每取得一个数（排除0、1），如果将它所有的倍数（排除0、1、本身）都清除，那么，剩下的数是不是必为素数？</p><p>没错，这个有趣且实用的方法便是著名的<strong>厄拉多塞筛法</strong>！</p><h2 id="三、厄拉多塞筛法："><a href="#三、厄拉多塞筛法：" class="headerlink" title="三、厄拉多塞筛法："></a><strong>三、厄拉多塞筛法：</strong></h2><p>使用厄拉多塞筛法进行 1 到 64 的质数查找的过程如下：</p><p> <a href="https://pic.leetcode-cn.com/a1faca1423ae40210283ae99735d3816702ccf4ea3d14b452bd31b52dc5c1ab7-%E8%B4%A8%E6%95%B001.png" target="_blank" rel="noopener">质数01.png</a> <a href="https://pic.leetcode-cn.com/9ce249c55336894269a24b07b24aeda45c9282d2bd7bcfe8b6a4924010f30c56-%E8%B4%A8%E6%95%B002.png" target="_blank" rel="noopener">质数02.png</a> <a href="https://pic.leetcode-cn.com/9907eb6310771945b98d85507e9ac396066eca6687d4a124d8d580cb4cb77331-%E8%B4%A8%E6%95%B003.png" target="_blank" rel="noopener">质数03.png</a> <a href="https://pic.leetcode-cn.com/44a83633f6e730b105c747efe1ea99f1ade9461278735ac1bb310264fe7f7890-%E8%B4%A8%E6%95%B004.png" target="_blank" rel="noopener">质数04.png</a> <a href="https://pic.leetcode-cn.com/11cdfac5138c3a0a1529407157264c066cc36b2acbd6160cb94fe848d5882c47-%E8%B4%A8%E6%95%B005.png" target="_blank" rel="noopener">质数05.png</a> <a href="https://pic.leetcode-cn.com/1474c46f44db885dd00a70dfb475d68cdde33a882cbd9f0e8f16561189441bd6-%E8%B4%A8%E6%95%B006.png" target="_blank" rel="noopener">质数06.png</a> <a href="https://pic.leetcode-cn.com/d1892c5f2c2fc9c76f7d998ac0bf57fa8f11579fb17a6e3305896d40c263b41e-%E8%B4%A8%E6%95%B007.png" target="_blank" rel="noopener">质数07.png</a> <a href="https://pic.leetcode-cn.com/4983199ef4fd10fff41c3e11f052793ea4c7e8fa1122ff1c31ece11a94eea561-%E8%B4%A8%E6%95%B008.png" target="_blank" rel="noopener">质数08.png</a> <a href="https://pic.leetcode-cn.com/cd1a2a9c42fc47a45c907c2e72f88421847d995275a677fd75c0eacce8996c06-%E8%B4%A8%E6%95%B009.png" target="_blank" rel="noopener">质数09.png</a> <a href="https://pic.leetcode-cn.com/e5172309e50d91eb5fced486d2b479677a6cbf594f157e18cc2b080b2cf7acdd-%E8%B4%A8%E6%95%B010.png" target="_blank" rel="noopener">质数10.png</a> <a href="https://pic.leetcode-cn.com/d9c9c9a293b63a9ae6b991f491add5a527b4ed0590c5c1e55bc1d7adf0bbcd30-%E8%B4%A8%E6%95%B011.png" target="_blank" rel="noopener">质数11.png</a> <a href="https://pic.leetcode-cn.com/f6bbb60ddcd9b5ad283163d9ac1612e128fc909120125192e86d77bdf80db6e9-%E8%B4%A8%E6%95%B012.png" target="_blank" rel="noopener">质数12.png</a> <a href="https://pic.leetcode-cn.com/95d13d8085953ddd6cba4298479fe110672e7331922b43b105c8eedaed14a870-%E8%B4%A8%E6%95%B013.png" target="_blank" rel="noopener">质数13.png</a> <a href="https://pic.leetcode-cn.com/9f6f86ac5a51f27e5abbeb25dd25cc527125ef7bcb3822e7ff6229b739166e7b-%E8%B4%A8%E6%95%B014.png" target="_blank" rel="noopener">质数14.png</a> <a href="https://pic.leetcode-cn.com/a81d726b272aec84d583574a6f8ab82245bf85591495a07aff84ed4f5db3db96-%E8%B4%A8%E6%95%B015.png" target="_blank" rel="noopener">质数15.png</a> <a href="https://pic.leetcode-cn.com/95be087f2ccf42f1e020ca2b762ab31eb82209c02a1f2dd5ddcf0ce3dec28eb3-%E8%B4%A8%E6%95%B016.png" target="_blank" rel="noopener">质数16.png</a> <a href="https://pic.leetcode-cn.com/d173b60cd95b8b6cbdadb8a8c5ccc477a8afd48093c3b4bac07216e1d0cd6b83-%E8%B4%A8%E6%95%B017.png" target="_blank" rel="noopener">质数17.png</a> </p><p>（做图片的时候把质数弄成了素数……）</p><p>对此，我们可以声明一个长度为最大限制数的布尔数组。用布尔值来区别筛选出的数和质数。</p><p>运用厄拉多塞筛法得代码如下：</p><details>    <summary>厄拉多塞筛法Csharp</summary><figure class="highlight csharp"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CountPrimes</span>(<span class="params"><span class="keyword">int</span> n</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span>[] signs = <span class="keyword">new</span> <span class="keyword">bool</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//因为在 C# 中，布尔类型的默认值为 假。所以在此处用了逻辑非（！）操作符。</span></span><br><span class="line">        <span class="keyword">if</span> (!signs[i])</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt; n; j += i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//排除不是质数的数</span></span><br><span class="line">                signs[j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>厄拉多塞筛法C++</summary><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//初始默认所有数为质数</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; signs(n, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (signs[i]) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt; n; j += i) &#123;</span><br><span class="line">                <span class="comment">//排除不是质数的数</span></span><br><span class="line">                signs[j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>厄拉多塞筛法Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] signs = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//因为在 Java 中，布尔类型的默认值为 假。所以在此处用了逻辑非（！）操作符。</span></span><br><span class="line">            <span class="keyword">if</span> (!signs[i]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt; n; j += i) &#123;</span><br><span class="line">                    signs[j] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>## **四、运用比特表（Bitmap）算法对筛法进行内存优化：**<p>上面运用厄拉多塞筛法求一定范围内的质数已经十分高效了。然而，我们使用布尔数组标记一个数是否为质数时，每个值都占用了一个字节（Byte）。但是，我们仅需要两个不同的值来表示是否为质数即可。即一个比特（bit）来表示即可（0、1）。如果这样的话，我们便最优可节省八分之七的空间（然而，还得结合代码和实际情况，并不是用了就一定有效果）。</p><ul><li>关于比特表算法在此便简要概述以下（可略过）：</li></ul><p>假如有从 1 至 8 总共八个数。现有一个字节大小的内存空间可供使用（仅供参考，不考虑实际用途及比特算法的最佳用处）。如何将每个数登记下来，并可以随时检查一个数是否存在呢？</p><p>如果用一个数组表示，即使不考虑数组的内存开销，哪怕用一个 byte 类型的变量记录每一数也将超出内存可使用范围。但是由于每个字节共有八个比特位，则可以用每个比特位来表示每个数字则恰好可以登记完所有的数字。</p><p>示例：</p><ol><li>登记数字 1 ：0 0 0 0 0 0 0 1</li><li>登记数字 1、3：0 0 0 0 0 1 0 1</li><li>登记数字 1、2、3、4、5 ：0 0 0 1 1 1 1 1</li></ol><p>得代码如下：</p><details>    <summary>运用比特表Csharp</summary><figure class="highlight csharp"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CountPrimes</span>(<span class="params"><span class="keyword">int</span> n</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//一个 int 变量占用 32 字节</span></span><br><span class="line">    <span class="comment">//在C#中，提供了点阵列（BitArray）数组，用这玩意可读性一定会好于我写的代码。</span></span><br><span class="line">    <span class="keyword">int</span>[] signs = <span class="keyword">new</span> <span class="keyword">int</span>[n / <span class="number">32</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将元素和需确定得数字经行按位或运算，如果值改变，说明不存在该数字（未登记该数字），则其为质数。</span></span><br><span class="line">        <span class="comment">//(当某个数为 2 的 n 次方时（n为自然数），其 &amp; (n - 1) 所得值将等价于取余运算所得值)</span></span><br><span class="line">        <span class="comment">//*如果 x = 2^n ，则 x &amp; (n - 1) == x % n</span></span><br><span class="line">        <span class="comment">//下面判断可以写成</span></span><br><span class="line">        <span class="comment">//if ((signs[i / size] &amp; (1 &lt;&lt; (i % 32))) == 0)</span></span><br><span class="line">        <span class="keyword">if</span> ((signs[i / <span class="number">32</span>] &amp; (<span class="number">1</span> &lt;&lt; (i &amp; <span class="number">31</span>))) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt; n; j += i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//登记该数字</span></span><br><span class="line">                signs[j / <span class="number">32</span>] |= <span class="number">1</span> &lt;&lt; (j &amp; <span class="number">31</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>运用比特表C++</summary><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//一个 int 变量不知道占多少字节（但请注意，这里采用了常量）</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; signs(n / size + <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="comment">//将元素和需确定得数字经行按位或运算，如果值改变，说明不存在该数字（未登记该数字），则其为质数。</span></span><br><span class="line">        <span class="comment">//在C++中，其提供了 bitset 来操作位，在此便不做介绍了。如果用了，可读性肯定会更好。</span></span><br><span class="line">        <span class="comment">//(当某个数为 2 的 n 次方时（n为自然数），其 &amp; (n - 1) 所得值将等价于取余运算所得值)</span></span><br><span class="line">        <span class="comment">//*如果 x = 2^n ，则 x &amp; (n - 1) == x % n</span></span><br><span class="line">        <span class="comment">//下面判断可以写成</span></span><br><span class="line">        <span class="comment">//if ((signs[i / size] &amp; (1 &lt;&lt; (i % 32))) == 0)</span></span><br><span class="line">        <span class="keyword">if</span> ((signs[i / size] &amp; (<span class="number">1</span> &lt;&lt; (i &amp; (size - <span class="number">1</span>)))) == <span class="number">0</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt; n; j += i)&#123;</span><br><span class="line">                <span class="comment">//登记该数字</span></span><br><span class="line">            signs[j / size] |= <span class="number">1</span> &lt;&lt; (j &amp; (size - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>经测试，C# 内存优化效果较为明显，但 C++ 效果不大明显。但这种方法显然是为了特殊情况而准备（比如一亿个数）。不过也可能是我写的不好。仅作参考，如果有所错误恳请您斧正。<p>（其实有时候代码的可读性要胜于代码改动所带来的一点的性能上的提升。）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;统计所有小于非负整数 n 的质数的数量。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>191. 位1的个数</title>
    <link href="http://yoursite.com/2020/09/28/191.%20%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>http://yoursite.com/2020/09/28/191. 位1的个数/</id>
    <published>2020-09-28T03:27:12.000Z</published>
    <updated>2020-09-29T08:37:42.516Z</updated>
    
    <content type="html"><![CDATA[<p>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。</p><a id="more"></a><p>示例 1：</p><pre><code>输入：00000000000000000000000000001011输出：3解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &apos;1&apos;。</code></pre><p>示例 2：</p><pre><code>输入：00000000000000000000000010000000输出：1解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &apos;1&apos;。</code></pre><p>示例 3：</p><pre><code>输入：11111111111111111111111111111101输出：31解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &apos;1&apos;。</code></pre><p>提示：</p><p>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</p><p>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。</p><p>进阶:</p><pre><code>如果多次调用这个函数，你将如何优化你的算法？</code></pre><h1 id="方法-1：循环和位移动"><a href="#方法-1：循环和位移动" class="headerlink" title="方法 1：循环和位移动"></a>方法 1：循环和位移动</h1><p><strong>算法</strong></p><p>这个方法比较直接。我们遍历数字的 32 位。如果某一位是 <em>1</em> ，将计数器加一。</p><p>我们使用 <em>位掩码</em> 来检查数字的第 <em>i^{th}</em> 位。一开始，掩码 <em>m=1</em> 因为 <em>1</em> 的二进制表示是</p><pre><code>0000 0000 0000 0000 0000 0000 0000 0001</code></pre><p>显然，任何数字跟掩码 <em>1</em> 进行逻辑与运算，都可以让我们获得这个数字的最低位。检查下一位时，我们将掩码左移一位。</p><pre><code>0000 0000 0000 0000 0000 0000 0000 0010</code></pre><p>并重复此过程。</p><details>    <summary>循环和位移动</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bits = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mask = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n &amp; mask) != <span class="number">0</span>) &#123;</span><br><span class="line">            bits++;</span><br><span class="line">        &#125;</span><br><span class="line">        mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(1)</em> 。运行时间依赖于数字 <em>n</em> 的位数。由于这题中 <em>n</em> 是一个 32 位数，所以运行时间是 <em>O(1)</em> 的。</p></li><li><p>空间复杂度：<em>O(1)</em>。没有使用额外空间。</p></li></ul><h1 id="方法-2：位操作的小技巧"><a href="#方法-2：位操作的小技巧" class="headerlink" title="方法 2：位操作的小技巧"></a>方法 2：位操作的小技巧</h1><p><strong>算法</strong></p><p>我们可以把前面的算法进行优化。我们不再检查数字的每一个位，而是不断把数字最后一个 <em>1</em> 反转，并把答案加一。当数字变成 <em>0</em> 的时候偶，我们就知道它没有 <em>1</em> 的位了，此时返回答案。</p><p>这里关键的想法是对于任意数字 <em>n</em> ，将 <em>n</em> 和 <em>n - 1</em> 做与运算，会把最后一个 <em>1</em> 的位变成 <em>0</em> 。为什么？考虑 <em>n</em> 和 <em>n - 1</em> 的二进制表示。</p><p><a href="https://pic.leetcode-cn.com/abfd6109e7482d70d20cb8fc1d632f90eacf1b5e89dfecb2e523da1bcb562f66-image.png" target="_blank" rel="noopener">image.png</a></p><p><em>图片 1. 将 *n</em> 和 <em>n-1</em> 做与运算会将最低位的 <em>1</em> 变成 <em>0*</em></p><p>在二进制表示中，数字 <em>n</em> 中最低位的 <em>1</em> 总是对应 <em>n - 1</em> 中的 <em>0</em> 。因此，将 <em>n</em> 和 <em>n - 1</em> 与运算总是能把 <em>n</em> 中最低位的 <em>1</em> 变成 <em>0</em> ，并保持其他位不变。</p><p>使用这个小技巧，代码变得非常简单。</p><details>    <summary>位操作的小技巧</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        sum++;</span><br><span class="line">        n &amp;= (n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>**复杂度分析**<ul><li><p>时间复杂度：<em>O(1)</em> 。运行时间与 <em>n</em> 中位为 <em>1</em> 的有关。在最坏情况下， <em>n</em> 中所有位都是 <em>1</em> 。对于 32 位整数，运行时间是 <em>O(1)</em> 的。</p></li><li><p>空间复杂度：<em>O(1)</em> 。没有使用额外空间。</p></li></ul><h1 id="位运算技巧"><a href="#位运算技巧" class="headerlink" title="位运算技巧"></a>位运算技巧</h1><h2 id="n-amp-n-1-把最后一个-1-的位变成-0"><a href="#n-amp-n-1-把最后一个-1-的位变成-0" class="headerlink" title="n &amp; (n-1) 把最后一个 1 的位变成 0"></a>n &amp; (n-1) 把最后一个 1 的位变成 0</h2><p>任意数字 n ，将 n 和 n - 1 做与运算，会把最后一个 1 的位变成 0</p><h2 id="n-amp-n-保留-n-最右边的-1"><a href="#n-amp-n-保留-n-最右边的-1" class="headerlink" title="n &amp; (-n) 保留 n 最右边的 1"></a>n &amp; (-n) 保留 <code>n</code> 最右边的 <code>1</code></h2><p>我们通过 <code>n &amp; (-n)</code> 保留 <code>n</code> 最右边的 <code>1</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
  <entry>
    <title>172. 阶乘后的零</title>
    <link href="http://yoursite.com/2020/09/27/172.%20%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6/"/>
    <id>http://yoursite.com/2020/09/27/172. 阶乘后的零/</id>
    <published>2020-09-27T07:27:12.000Z</published>
    <updated>2020-09-27T07:56:47.989Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数 n，返回 n! 结果尾数中零的数量。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: 3输出: 0解释: 3! = 6, 尾数中没有零。</code></pre><p>示例 2:</p><pre><code>输入: 5输出: 1解释: 5! = 120, 尾数中有 1 个零.说明: 你算法的时间复杂度应为 O(log n) 。</code></pre><h1 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h1><p>看到这道题首先排除掉计算阶乘，先求乘数中含有10，5，2的个数，零的数量取决于这三个因子</p><details>    <summary>解法一</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int trailingZeroes(int n) &#123;</span><br><span class="line">        int numfive=0;</span><br><span class="line">        int numtwo=0;</span><br><span class="line">        int numten=0;</span><br><span class="line">        for (int j = 1; j &lt;= n; j++) &#123;</span><br><span class="line">            int i = j;</span><br><span class="line">            while (i % 10 == 0) &#123;</span><br><span class="line">                numten++;</span><br><span class="line">                i = i / 10;</span><br><span class="line">            &#125;</span><br><span class="line">            while (i % 5 == 0) &#123;</span><br><span class="line">                numfive++;</span><br><span class="line">                i = i / 5;</span><br><span class="line">            &#125;</span><br><span class="line">            while (i % 2 == 0) &#123;</span><br><span class="line">                numtwo++;</span><br><span class="line">                i = i / 2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return numten + Math.min(numfive, numtwo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h1><p>之前小红书面试的时候碰到的一道题，没想到又是 leetcode 的原题。这种没有通用解法的题，完全依靠于对题目的分析理解了，自己当时也是在面试官的提示下慢慢出来的，要是想不到题目的点，还是比较难做的。</p><p>首先肯定不能依赖于把阶乘算出来再去判断有多少个零了，因为阶乘很容易就溢出了，所以先一步一步理一下思路吧。</p><p>首先末尾有多少个 <code>0</code> ，只需要给当前数乘以一个 <code>10</code> 就可以加一个 <code>0</code>。</p><p>再具体对于 <code>5!</code>，也就是 <code>5 * 4 * 3 * 2 * 1 = 120</code>，我们发现结果会有一个 <code>0</code>，原因就是 <code>2</code> 和 <code>5</code> 相乘构成了一个 <code>10</code>。而对于 <code>10</code> 的话，其实也只有 <code>2 * 5</code>  可以构成，所以我们只需要找有多少对 <code>2/5</code>。</p><p>我们把每个乘数再稍微分解下，看一个例子。</p><p><code>11! = 11 * 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1 = 11 * (2 * 5) * 9 * (4 * 2) * 7 * (3 * 2) * (1 * 5) * (2 * 2) * 3 * (1 * 2) * 1</code></p><p>对于含有 <code>2</code> 的因子的话是  <code>1 * 2, 2 * 2, 3 * 2, 4 * 2 ...</code></p><p>对于含有 <code>5</code> 的因子的话是  <code>1 * 5, 2 * 5...</code></p><p>含有 <code>2</code> 的因子每两个出现一次，含有 <code>5</code> 的因子每 <code>5</code> 个出现一次，所有 <code>2</code> 出现的个数远远多于 <code>5</code>，换言之找到一个 <code>5</code>，一定能找到一个 <code>2</code> 与之配对。所以我们只需要找有多少个 <code>5</code>。</p><p>直接的，我们只需要判断每个累乘的数有多少个 <code>5</code> 的因子即可。</p><details>    <summary>解法二</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> N = i;</span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (N % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                N /= <span class="number">5</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>但发生了超时，我们继续分析。</p><p>对于一个数的阶乘，就如之前分析的，<code>5</code> 的因子一定是每隔 <code>5</code> 个数出现一次，也就是下边的样子。</p><p><code>n! = 1 * 2 * 3 * 4 * (1 * 5) * ... * (2 * 5) * ... * (3 * 5) *... * n</code></p><p>因为每隔 <code>5</code> 个数出现一个 <code>5</code>，所以计算出现了多少个 <code>5</code>，我们只需要用 <code>n/5</code> 就可以算出来。</p><p>但还没有结束，继续分析。</p><p><code>... * (1 * 5) * ... * (1 * 5 * 5) * ... * (2 * 5 * 5) * ... * (3 * 5 * 5) * ... * n</code></p><p>每隔 <code>25</code> 个数字，出现的是两个 <code>5</code>，所以除了每隔 <code>5</code> 个数算作一个 <code>5</code>，每隔 <code>25</code> 个数，还需要多算一个 <code>5</code>。</p><p>也就是我们需要再加上 <code>n / 25</code> 个 <code>5</code>。</p><p>同理我们还会发现每隔 <code>5 * 5 * 5 = 125</code> 个数字，会出现 <code>3</code> 个 <code>5</code>，所以我们还需要再加上 <code>n / 125</code> 。</p><p>综上，规律就是每隔 <code>5</code> 个数，出现一个 <code>5</code>，每隔 <code>25</code> 个数，出现 <code>2</code> 个 <code>5</code>，每隔 <code>125</code> 个数，出现 <code>3</code> 个 <code>5</code>… 以此类推。</p><p>最终 <code>5</code> 的个数就是 <code>n / 5 + n / 25 + n / 125 ...</code></p><p>写程序的话，如果直接按照上边的式子计算，分母可能会造成溢出。所以算 <code>n / 25</code> 的时候，我们先把 <code>n</code> 更新，<code>n = n / 5</code>，然后再计算 <code>n / 5</code> 即可。后边的同理。</p><details>    <summary>解法二</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        count += n / <span class="number">5</span>;</span><br><span class="line">        n = n / <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数 n，返回 n! 结果尾数中零的数量。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>190. 颠倒二进制位</title>
    <link href="http://yoursite.com/2020/09/27/190.%20%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/"/>
    <id>http://yoursite.com/2020/09/27/190. 颠倒二进制位/</id>
    <published>2020-09-27T07:27:12.000Z</published>
    <updated>2020-09-28T03:12:13.275Z</updated>
    
    <content type="html"><![CDATA[<p>颠倒给定的 32 位无符号整数的二进制位。</p><a id="more"></a><p>示例 1：</p><pre><code>输入: 00000010100101000001111010011100输出: 00111001011110000010100101000000解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。</code></pre><p>示例 2：</p><pre><code>输入：11111111111111111111111111111101输出：10111111111111111111111111111111解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。</code></pre><p>提示：</p><pre><code>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。</code></pre><p>进阶:</p><pre><code>如果多次调用这个函数，你将如何优化你的算法？</code></pre><h1 id="方法一：逐位颠倒"><a href="#方法一：逐位颠倒" class="headerlink" title="方法一：逐位颠倒"></a>方法一：逐位颠倒</h1><p>虽然这个问题并不难，但它常常是面试开始时的一个热身问题。重点是测试一个人对数据类型和位操作的基本知识。</p><p>在面试的时候逐位颠倒作为最直接的解决方案。</p><p><a href="https://pic.leetcode-cn.com/15bcf5b6db9b5211046655737571e3fe2668f9ecfc24ce517cd2b0882824aecd-file_1585801736085" target="_blank" rel="noopener">逐位颠倒</a></p><p>尽管听起来很简单，但上述逻辑的不同实现产生不同的解决方案。例如，要检索整数 <code>n</code> 中最右边的位，可以应用模运算（即 <code>n%2</code>）或与运算（即 <code>n &amp;1</code>）。另一个例子是，为了组合反转位（例如 <em>2^a，2^b</em>）的结果，可以使用加法运算（即 <em>2^a+2^b</em>）或再次使用位或运算（即 <em>2^a | 2^b</em>）。</p><p><strong>算法：</strong><br>在这里，我们将展示基于上述逻辑的实现示例。</p><p><a href="https://pic.leetcode-cn.com/ca2460d77758bd033e787f6b1602f5571891520acae4eefa7bcc7f1fe48b5a2e-file_1585801736110" target="_blank" rel="noopener">实现示例</a><br>关键思想是，对于位于索引 <code>i</code> 处的位，在反转之后，其位置应为 <code>31-i</code>（注：索引从零开始）。</p><ul><li>我们从右到左遍历输入整数的位字符串（即 <code>n=n&gt;&gt;1</code>）。要检索整数的最右边的位，我们应用与运算（<code>n&amp;1</code>）。</li><li>对于每个位，我们将其反转到正确的位置（即<code>（n&amp;1）&lt;&lt;power</code>）。然后添加到最终结果。</li><li>当 <code>n==0</code> 时，我们终止迭代。</li></ul><details>    <summary>逐位颠倒Java</summary><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 1. 将给定的二进制数,由低到高位逐个取出</span></span><br><span class="line">            <span class="comment">// 1.1 右移 i 位,</span></span><br><span class="line">            <span class="keyword">int</span> tmp = n &gt;&gt; i;</span><br><span class="line">            <span class="comment">// 1.2  取有效位</span></span><br><span class="line">            tmp = tmp &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 2. 然后通过位运算将其放置到反转后的位置.</span></span><br><span class="line">            tmp = tmp &lt;&lt; (<span class="number">31</span> - i);</span><br><span class="line">            <span class="comment">// 3. 将上述结果再次通过运算结合到一起</span></span><br><span class="line">            result |= tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>逐位颠倒Python</summary><figure class="highlight python"><figcaption><span>[solution1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param n, an integer</span></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBits</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        ret, power = <span class="number">0</span>, <span class="number">31</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            ret += (n &amp; <span class="number">1</span>) &lt;&lt; power</span><br><span class="line">            n = n &gt;&gt; <span class="number">1</span></span><br><span class="line">            power -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure></details><details>    <summary>逐位颠倒C++</summary><figure class="highlight c++"><figcaption><span>[solution1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">uint32_t</span> reverseBits(<span class="keyword">uint32_t</span> n) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> ret = <span class="number">0</span>, power = <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">      ret += (n &amp; <span class="number">1</span>) &lt;&lt; power;</span><br><span class="line">      n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      power -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>逐位颠倒Go</summary><figure class="highlight go"><figcaption><span>[solution1-Go]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseBits</span><span class="params">(num <span class="keyword">uint32</span>)</span> <span class="title">uint32</span></span> &#123;</span><br><span class="line">    ret := <span class="keyword">uint32</span>(<span class="number">0</span>)</span><br><span class="line">    power := <span class="keyword">uint32</span>(<span class="number">31</span>)</span><br><span class="line">    <span class="keyword">for</span> num != <span class="number">0</span> &#123;</span><br><span class="line">        ret += (num &amp; <span class="number">1</span>) &lt;&lt; power</span><br><span class="line">        num = num &gt;&gt; <span class="number">1</span></span><br><span class="line">        power -= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>**复杂度分析**<ul><li>时间复杂度：log_2(N) 。在算法中，我们有一个循环来迭代输入的最高非零位，即log_2(N)  。</li><li>空间复杂度：O(1) ，因为不管输入是什么，内存的消耗是固定的。</li></ul><h1 id="方法二：带记忆化的按字节颠倒"><a href="#方法二：带记忆化的按字节颠倒" class="headerlink" title="方法二：带记忆化的按字节颠倒"></a>方法二：带记忆化的按字节颠倒</h1><p>有人可能会说，每字节（8 位的比特位）反转可能更有效。由于该题的输入是固定的 32 位整数，所以在本题中不一定是这样的。但是在处理长字节流时，它会变得更有效。</p><p><a href="https://pic.leetcode-cn.com/365599a4030d26a019d37ad97c201e64e2fa3ae9fd7b43d689e8a4d7f802141e-file_1585801736122" target="_blank" rel="noopener">带记忆化的按字节颠倒</a></p><p>使用字节作为迭代单位的另一个隐含优点是，我们可以使用记忆化技术，可以缓存先前计算的值，以避免重新计算。</p><p>记忆化的后续问题是：如果该函数多次被调用，你该如何优化。</p><p>若要按自己为单位反转位，可以应用上述所示的算法。在这里，我们展示一种完全基于算术和位操作，不基于任何循环语句，如下所示：</p><figure class="highlight python"><figcaption><span>[example-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseByte</span><span class="params">(byte)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (byte * <span class="number">0x0202020202</span> &amp; <span class="number">0x010884422010</span>) % <span class="number">1023</span></span><br></pre></td></tr></table></figure><p>这个算法为用 3 个操作反转一个字节中的位，在 Sean Eron Anderson 的在线电子书 Bit Twiddling Hacks 中可以看到更多的细节。</p><p><strong>算法：</strong></p><ul><li>我们按字节遍历整数。为了检索整数中最右边的字节，我们应用位掩码为 <code>11111111</code> 的与操作（即 <code>n&amp;0xff</code>）。</li><li>对于每个字节，首先我们通过一个名为 <code>reverseByte(byte)</code> 的函数来反转字节中的位。然后将反转的结果添加到答案中。</li><li>对于函数 <code>reverseByte(byte)</code>，我们使用记忆化技术，它缓存函数的结果并直接返回结果，以便将来遇到相同的输入。</li></ul><p>注意，可以选择更小的单位而不是字节，例如 4 位的单位，这将需要更多的计算来交换更少的缓存空间。记忆化技术是空间和计算时间之间的权衡。</p><details>    <summary>带记忆化的按字节颠倒Python</summary><figure class="highlight python"><figcaption><span>[solution21-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param n, an integer</span></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBits</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        ret, power = <span class="number">0</span>, <span class="number">24</span></span><br><span class="line">        cache = dict()</span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            ret += self.reverseByte(n &amp; <span class="number">0xff</span>, cache) &lt;&lt; power</span><br><span class="line">            n = n &gt;&gt; <span class="number">8</span></span><br><span class="line">            power -= <span class="number">8</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseByte</span><span class="params">(self, byte, cache)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> byte <span class="keyword">not</span> <span class="keyword">in</span> cache:</span><br><span class="line">            cache[byte] = (byte * <span class="number">0x0202020202</span> &amp; <span class="number">0x010884422010</span>) % <span class="number">1023</span> </span><br><span class="line">        <span class="keyword">return</span> cache[byte]</span><br></pre></td></tr></table></figure></details><details>    <summary>带记忆化的按字节颠倒Python</summary><figure class="highlight python"><figcaption><span>[solution21-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param n, an integer</span></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBits</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        ret, power = <span class="number">0</span>, <span class="number">24</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            ret += self.reverseByte(n &amp; <span class="number">0xff</span>) &lt;&lt; power</span><br><span class="line">            n = n &gt;&gt; <span class="number">8</span></span><br><span class="line">            power -= <span class="number">8</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">    <span class="comment"># memoization with decorator</span></span><br><span class="line"><span class="meta">    @functools.lru_cache(maxsize=256)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseByte</span><span class="params">(self, byte)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (byte * <span class="number">0x0202020202</span> &amp; <span class="number">0x010884422010</span>) % <span class="number">1023</span></span><br></pre></td></tr></table></figure></details><details>    <summary>带记忆化的按字节颠倒C++</summary><figure class="highlight c++"><figcaption><span>[solution21-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">uint32_t</span> reverseByte(<span class="keyword">uint32_t</span> byte, <span class="built_in">map</span>&lt;<span class="keyword">uint32_t</span>, <span class="keyword">uint32_t</span>&gt; cache) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache.find(byte) != cache.end()) &#123;</span><br><span class="line">            <span class="keyword">return</span> cache[byte];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">uint32_t</span> value = (byte * <span class="number">0x0202020202</span> &amp; <span class="number">0x010884422010</span>) % <span class="number">1023</span>;</span><br><span class="line">        cache.emplace(byte, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> reverseBits(<span class="keyword">uint32_t</span> n) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> ret = <span class="number">0</span>, power = <span class="number">24</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">uint32_t</span>, <span class="keyword">uint32_t</span>&gt; cache;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            ret += reverseByte(n &amp; <span class="number">0xff</span>, cache) &lt;&lt; power;</span><br><span class="line">            n = n &gt;&gt; <span class="number">8</span>;</span><br><span class="line">            power -= <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>带记忆化的按字节颠倒Go</summary><figure class="highlight go"><figcaption><span>[solution21-Go]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseByte</span><span class="params">(b <span class="keyword">uint32</span>, cache <span class="keyword">map</span>[<span class="keyword">uint32</span>]<span class="keyword">uint64</span>)</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line">    value, ok := cache[b]</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">    value = (<span class="keyword">uint64</span>(b) * <span class="number">0x0202020202</span> &amp; <span class="number">0x010884422010</span>) % <span class="number">1023</span></span><br><span class="line">    cache[b] = value</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseBits</span><span class="params">(num <span class="keyword">uint32</span>)</span> <span class="title">uint32</span></span> &#123;</span><br><span class="line">    ret := <span class="keyword">uint64</span>(<span class="number">0</span>)</span><br><span class="line">    power := <span class="keyword">uint64</span>(<span class="number">24</span>)</span><br><span class="line">    <span class="keyword">var</span> cache = <span class="keyword">map</span>[<span class="keyword">uint32</span>]<span class="keyword">uint64</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> num != <span class="number">0</span> &#123;</span><br><span class="line">        ret += reverseByte(num &amp; <span class="number">0xff</span>, cache) &lt;&lt; power</span><br><span class="line">        num = num &gt;&gt; <span class="number">8</span></span><br><span class="line">        power -= <span class="number">8</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">uint32</span>(ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(1) 。尽管我们在算法中有一个循环，但是无论输入是什么，迭代次数都是固定的，因为在我们的问题中整数是固定大小（32 位）的。</li><li>空间复杂度：O(1) ，同样，尽管我们使用了缓存来保留反转字节的结果，但缓存中的大小总数限制为 <em>2^8=256</em>。</li></ul><h1 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h1><p>在方法 2 中，我们展示了一个关于如何在不使用循环语句的情况下反转字节中的位的示例。</p><p><strong>在面试过程中，你可能会被要求在不使用循环的情况下反转整个 32 位。</strong> </p><p>在这里，我们提出了一种只使用位操作的解决方案。</p><p>这种思想可以看作是一种分治的策略，我们通过掩码将 32 位整数划分成具有较少位的块，然后通过将每个块反转，最后将每个块的结果合并得到最终结果。</p><p>在下图中，我们演示如何使用上述思想反转两个位。同样的，这个想法可以应用到比特块上。</p><p><a href="https://pic.leetcode-cn.com/c57a82424197ba1f4091a67cc4a6c575b35dcc0bf9d077415838d3b22d4b1ff3-file_1585801736118" target="_blank" rel="noopener">不使用循环语句的情况下反转字节中的位</a></p><p><strong>算法：</strong></p><p>我们可以通过以下步骤实现该算法：</p><ul><li>首先，我们将原来的 32 位分为 2 个 16 位的块。</li><li>然后我们将 16 位块分成 2 个 8 位的块。</li><li>然后我们继续将这些块分成更小的块，直到达到 1 位的块。</li><li>在上述每个步骤中，我们将中间结果合并为一个整数，作为下一步的输入。</li></ul><p>既然知道 int 值一共32位，那么可以采用分治思想，反转左右16位，然后反转每个16位中的左右8位，依次类推，最后反转2位，反转后合并即可，同时可以利用位运算在原地反转。JDK中的Integer.bitCount()函数也是使用类似的方法。</p><p>这么说比较抽象，可以直接结合代码看下面的步骤，也可以拿代码在IDE中debug一下，看每一步都做了什么</p><ol><li>首先随便找一个数 (为了看的清楚用_作分隔，可以忽略)</li></ol><pre><code>十进制43261596;   // 0000 ‭0010 1001 0100 _ 0001 1110 1001 1100‬</code></pre><ol start="2"><li>左边16位移到右边，右边16位移到左边，然后使用|符号合并起来</li></ol><pre><code>Java中的无符号位移 &gt;&gt;&gt;：无论是正数还是负数，高位通通补0。&gt;&gt;：带符号右移。正数右移高位补0，负数右移高位补1。|：按位或逻辑，该位只要有一位为1，结果就为1，这里用来合并</code></pre><ol start="3"><li>使用一些有规律的数，将16位，再分成左右8位进行反转后合并，起始数字变为‭0001 1110 1001 1100 _ 0000 0010 1001 0100‬</li></ol><pre><code>0xff00ff00 表示16进制数1111 1111 0000 0000 _ 1111 1111 0000 0000 ，0x00ff00ff 表示16进制数0000 0000 1111 1111 _ 0000 0000 1111 1111，</code></pre><ol start="4"><li><p>重复以上步骤，分组、合并，最后得到反转后的结果。</p></li><li><p>总结来说就是利用位运算进行反转，同时存储反转后的数，继续分治进行反转，直到全部反转完成，变化过程为：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 原数字43261596</span><br><span class="line"> 0000 ‭0010 1001 0100 _ 0001 1110 1001 1100‬ </span><br><span class="line">// 反转左右16位：</span><br><span class="line">‭ 0001 1110 1001 1100 _ 0000 0010 1001 0100‬ </span><br><span class="line">// 继续分为8位一组反转：</span><br><span class="line"> 1001 1100 0001 1110 _ 1001 0100 0000 0010</span><br><span class="line">// 4位一组反转：</span><br><span class="line"> 1100 1001 1110 0001 _ 0100 1001 0010 0000‬</span><br><span class="line">// 2位一组反转：</span><br><span class="line"> 0011 0110 1011 0100 _ 0001 0110 1000 0000</span><br><span class="line">// 每两位再反转一下</span><br><span class="line">‭ 0011 1001 0111 1000 _ 0010 1001 0100 0000‬‬</span><br><span class="line">// 这就是43261596反转后的结果：‭964176192‬</span><br></pre></td></tr></table></figure><details>    <summary>不使用循环语句的情况下反转字节中的位Java</summary><figure class="highlight java"><figcaption><span>[solution3-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        n = (n &gt;&gt;&gt; <span class="number">16</span>) | (n &lt;&lt; <span class="number">16</span>); </span><br><span class="line">        n = ((n &amp; <span class="number">0xff00ff00</span>) &gt;&gt;&gt; <span class="number">8</span>) | ((n &amp; <span class="number">0x00ff00ff</span>) &lt;&lt; <span class="number">8</span>); </span><br><span class="line">        n = ((n &amp; <span class="number">0xf0f0f0f0</span>) &gt;&gt;&gt; <span class="number">4</span>) | ((n &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span>); </span><br><span class="line">        n = ((n &amp; <span class="number">0xcccccccc</span>) &gt;&gt;&gt; <span class="number">2</span>) | ((n &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span>); </span><br><span class="line">        n = ((n &amp; <span class="number">0xaaaaaaaa</span>) &gt;&gt;&gt; <span class="number">1</span>) | ((n &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span>); </span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>不使用循环语句的情况下反转字节中的位Python</summary><figure class="highlight python"><figcaption><span>[solution3-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param n, an integer</span></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBits</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        n = (n &gt;&gt; <span class="number">16</span>) | (n &lt;&lt; <span class="number">16</span>)</span><br><span class="line">        n = ((n &amp; <span class="number">0xff00ff00</span>) &gt;&gt; <span class="number">8</span>) | ((n &amp; <span class="number">0x00ff00ff</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">        n = ((n &amp; <span class="number">0xf0f0f0f0</span>) &gt;&gt; <span class="number">4</span>) | ((n &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span>)</span><br><span class="line">        n = ((n &amp; <span class="number">0xcccccccc</span>) &gt;&gt; <span class="number">2</span>) | ((n &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span>)</span><br><span class="line">        n = ((n &amp; <span class="number">0xaaaaaaaa</span>) &gt;&gt; <span class="number">1</span>) | ((n &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n</span><br></pre></td></tr></table></figure></details><details>    <summary>不使用循环语句的情况下反转字节中的位C++</summary><figure class="highlight c++"><figcaption><span>[solution3-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">uint32_t</span> reverseBits(<span class="keyword">uint32_t</span> n) &#123;</span><br><span class="line">        n = (n &gt;&gt; <span class="number">16</span>) | (n &lt;&lt; <span class="number">16</span>);</span><br><span class="line">        n = ((n &amp; <span class="number">0xff00ff00</span>) &gt;&gt; <span class="number">8</span>) | ((n &amp; <span class="number">0x00ff00ff</span>) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">        n = ((n &amp; <span class="number">0xf0f0f0f0</span>) &gt;&gt; <span class="number">4</span>) | ((n &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span>);</span><br><span class="line">        n = ((n &amp; <span class="number">0xcccccccc</span>) &gt;&gt; <span class="number">2</span>) | ((n &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        n = ((n &amp; <span class="number">0xaaaaaaaa</span>) &gt;&gt; <span class="number">1</span>) | ((n &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>不使用循环语句的情况下反转字节中的位Go</summary><figure class="highlight go"><figcaption><span>[solution3-Go]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseBits</span><span class="params">(num <span class="keyword">uint32</span>)</span> <span class="title">uint32</span></span> &#123;</span><br><span class="line">    num = (num &gt;&gt; <span class="number">16</span>) | (num &lt;&lt; <span class="number">16</span>)</span><br><span class="line">    num = ((num &amp; <span class="number">0xff00ff</span>00) &gt;&gt; <span class="number">8</span>) | ((num &amp; <span class="number">0x00ff00ff</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">    num = ((num &amp; <span class="number">0xf0f0f0f</span>0) &gt;&gt; <span class="number">4</span>) | ((num &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span>)</span><br><span class="line">    num = ((num &amp; <span class="number">0xcccccccc</span>) &gt;&gt; <span class="number">2</span>) | ((num &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span>)</span><br><span class="line">    num = ((num &amp; <span class="number">0xaaaaaaaa</span>) &gt;&gt; <span class="number">1</span>) | ((num &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(1) ，没有使用循环。</li><li>空间复杂度：O(1) ，没有使用变量。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;颠倒给定的 32 位无符号整数的二进制位。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
  <entry>
    <title>166. 分数到小数</title>
    <link href="http://yoursite.com/2020/09/18/166.%20%E5%88%86%E6%95%B0%E5%88%B0%E5%B0%8F%E6%95%B0/"/>
    <id>http://yoursite.com/2020/09/18/166. 分数到小数/</id>
    <published>2020-09-18T09:27:12.000Z</published>
    <updated>2020-09-27T07:22:11.464Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个整数，分别表示分数的分子numerator和分母denominator，以字符串形式返回小数。</p><a id="more"></a><p>如果小数部分为循环小数，则将循环的部分括在括号内。</p><p>示例 1:</p><pre><code>输入: numerator = 1, denominator = 2输出: &quot;0.5&quot;</code></pre><p>示例 2:</p><pre><code>输入: numerator = 2, denominator = 1输出: &quot;2&quot;</code></pre><p>示例 3:</p><pre><code>输入: numerator = 2, denominator = 3输出: &quot;0.(6)&quot;</code></pre><h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>这是一道非常直观的代码题，但需要考虑很多细节。</p><h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><ol><li>不需要复杂的数学知识，只需要数学的基本知识。了解长除法的运算规则。</li><li>使用长除法计算 4/9 ，循环节很显然就会找到。那么计算 4/333 呢，能找到规律吗？</li><li>注意边界情况！列出所有你可以想到的测试数据并验证你的代码。</li></ol><h1 id="方法：长除法"><a href="#方法：长除法" class="headerlink" title="方法：长除法"></a>方法：长除法</h1><p><strong>思路</strong></p><p>核心思想是当余数出现循环的时候，对应的商也会循环。参见<a href="https://leetcode-cn.com/problems/fraction-to-recurring-decimal/solution/fen-shu-dao-xiao-shu-by-leetcode/" target="_blank" rel="noopener">^1</a></p><p><strong>算法</strong></p><p>需要用一个哈希表记录余数出现在小数部分的位置，当你发现已经出现的余数，就可以将重复出现的小数部分用括号括起来。</p><p>再出发过程中余数可能为 0，意味着不会出现循环小数，立刻停止程序。</p><p>就像 <a href="(https://leetcode-cn.com/problems/divide-two-integers/)">两数相除</a> 问题一样，要考虑负分数以及极端情况，比如说-2147483648/-1  。</p><p>下面列出了一些很好的测试样例：</p><table><thead><tr><th>测试样例</th><th>解释</th></tr></thead><tbody><tr><td>0/1</td><td>被除数为 0。</td></tr><tr><td>1/0</td><td>除数为 0，应当抛出异常，这里为了简单起见不考虑。</td></tr><tr><td>20/4</td><td>答案是整数，不包括小数部分。</td></tr><tr><td>1/2</td><td>答案是 0.5，是有限小数。</td></tr><tr><td>-1/4 or 1/-4</td><td>除数被除数有一个为负数，结果为负数。</td></tr><tr><td>-1/-4</td><td>除数和被除数都是负数，结果为正数。</td></tr><tr><td>-2147483648/-1</td><td>转成整数时注意可能溢出。</td></tr></tbody></table><details>    <summary>长除法</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">fractionToDecimal</span><span class="params">(<span class="keyword">int</span> numerator, <span class="keyword">int</span> denominator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numerator == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder fraction = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">// If either one is negative (not both)</span></span><br><span class="line">    <span class="keyword">if</span> (numerator &lt; <span class="number">0</span> ^ denominator &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        fraction.append(<span class="string">"-"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Convert to Long or else abs(-2147483648) overflows</span></span><br><span class="line">    <span class="keyword">long</span> dividend = Math.abs(Long.valueOf(numerator));</span><br><span class="line">    <span class="keyword">long</span> divisor = Math.abs(Long.valueOf(denominator));</span><br><span class="line">    fraction.append(String.valueOf(dividend / divisor));</span><br><span class="line">    <span class="keyword">long</span> remainder = dividend % divisor;</span><br><span class="line">    <span class="keyword">if</span> (remainder == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fraction.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    fraction.append(<span class="string">"."</span>);</span><br><span class="line">    Map&lt;Long, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (remainder != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(remainder)) &#123;</span><br><span class="line">            fraction.insert(map.get(remainder), <span class="string">"("</span>);</span><br><span class="line">            fraction.append(<span class="string">")"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(remainder, fraction.length());</span><br><span class="line">        remainder *= <span class="number">10</span>;</span><br><span class="line">        fraction.append(String.valueOf(remainder / divisor));</span><br><span class="line">        remainder %= divisor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fraction.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个整数，分别表示分数的分子numerator和分母denominator，以字符串形式返回小数。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>149. 直线上最多的点数</title>
    <link href="http://yoursite.com/2020/09/18/149.%20%E7%9B%B4%E7%BA%BF%E4%B8%8A%E6%9C%80%E5%A4%9A%E7%9A%84%E7%82%B9%E6%95%B0/"/>
    <id>http://yoursite.com/2020/09/18/149. 直线上最多的点数/</id>
    <published>2020-09-18T01:27:12.000Z</published>
    <updated>2020-09-18T09:50:19.555Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二维平面，平面上有 n 个点，求最多有多少个点在同一条直线上。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: [[1,1],[2,2],[3,3]]输出: 3解释:^||        o|     o|  o  +-------------&gt;0  1  2  3  4</code></pre><p>示例 2:</p><pre><code>输入: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]输出: 4解释:^||  o|     o        o|        o|  o        o+-------------------&gt;0  1  2  3  4  5  6</code></pre><h1 id="题目描述（困难难度）"><a href="#题目描述（困难难度）" class="headerlink" title="题目描述（困难难度）"></a>题目描述（困难难度）</h1><p>平面上有很多点，找出经过某一条直线最多有多少个点。</p><h1 id="解法一-暴力破解"><a href="#解法一-暴力破解" class="headerlink" title="解法一 暴力破解"></a>解法一 暴力破解</h1><p>两点确定一条直线，最简单的方式考虑任意两点组成一条直线，然后判断其他点在不在这条直线上。</p><p>两点确定一条直线，直线方程可以表示成下边的样子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\frac&#123;y_2-y_1&#125;&#123;x_2-x_1&#125;=\frac&#123;y-y_2&#125;&#123;x-x_2&#125;</span><br></pre></td></tr></table></figure><p>所以当来了一个点 <code>(x,y)</code> 的时候，理论上，我们只需要代入到上边的方程进行判断即可。</p><p>但是在计算机中，算上边的除法的时候，结果可能是小数，计算机中用浮点数存储，但小数并不能精确表示，可以参考这篇 <a href="https://zhuanlan.zhihu.com/p/75581822" target="_blank" rel="noopener">浮点数</a> 的讲解。所以我们不能直接去判断等式两边是否相等。</p><p>第一个想法是，等式两边分子乘分母，转换为乘法的形式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(y_2-y_1)*(x-x_2)=(y-y_2)*(x_2-x_1)</span><br></pre></td></tr></table></figure><p>所以我们可以写一个 <code>test</code> 函数来判断点 <code>(x,y)</code> 是否在由点 <code>(x1,y1)</code> 和 <code>(x2,y2)</code> 组成的直线上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (y2 - y1) * (x - x2) == (y - y2) * (x2 - x1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上边看起来没问题，但如果乘积过大的话就可能造成溢出，从而产生问题。</p><p>最直接的解决方案就是不用 <code>int</code> 存，改用 <code>long</code> 存，可以暂时解决上边的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">long</span>)(y2 - y1) * (x - x2) == (<span class="keyword">long</span>)(y - y2) * (x2 - x1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但如果数据过大，依旧可能造成溢出，再直接的方法就是用 <code>java</code> 提供的 <code>BigInteger</code> 类处理。记得 <code>import java.math.BigInteger;</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;        </span><br><span class="line">    BigInteger x11 = BigInteger.valueOf(x1);</span><br><span class="line">    BigInteger x22 = BigInteger.valueOf(x2);</span><br><span class="line">    BigInteger y11 = BigInteger.valueOf(y1);</span><br><span class="line">   BigInteger y22 = BigInteger.valueOf(y2);</span><br><span class="line">    BigInteger x0 = BigInteger.valueOf(x);</span><br><span class="line">    BigInteger y0 = BigInteger.valueOf(y);</span><br><span class="line">    <span class="keyword">return</span> y22.subtract(y11).multiply(x0.subtract(x22)).equals(y0.subtract(y22).multiply(x22.subtract(x11)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，还有一个方案。</p><p>对于下边的等式，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\frac&#123;y_2-y_1&#125;&#123;x_2-x_1&#125;=\frac&#123;y-y_2&#125;&#123;x-x_2&#125;</span><br></pre></td></tr></table></figure><p>还可以理解成判断两个分数相等，回到数学上，我们只需要将两个分数约分到最简，然后分别判断分子和分母是否相等即可。</p><p>所以，我们需要求分子和分母的最大公约数，直接用<a href="https://baike.baidu.com/item/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/1647675?fromtitle=%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95&fromid=4625352" target="_blank" rel="noopener">辗转相除法</a>即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a % b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后 <code>test</code> 函数就可以写成下边的样子。需要注意的是，我们求了<code>y - y2</code> 和 <code>x - x2</code> 最大公约数，所以要保证他俩都不是 <code>0</code> ，防止除零错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> g1 = gcd(y2 - y1, x2 - x1);</span><br><span class="line">    <span class="keyword">if</span>(y == y2 &amp;&amp; x == x2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> g2 = gcd(y - y2, x - x2);</span><br><span class="line">    <span class="keyword">return</span> (y2 - y1) / g1 == (y - y2) / g2 &amp;&amp; (x2 - x1) / g1 == (x - x2) / g2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了 <code>test</code> 函数，接下来，我们只需要三层遍历。前两层遍历选择两个点的所有组合构成一条直线，第三层遍历其他所有点，来判断当前点在不在之前两个点组成的直线上。</p><p>需要注意的是，因为我们两点组成一条直线，必须保证这两个点不重合。所以我们进入第三层循环之前，如果两个点相等就可以直接跳过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (points[i][<span class="number">0</span>] == points[j][<span class="number">0</span>] &amp;&amp; points[i][<span class="number">1</span>] == points[j][<span class="number">1</span>]) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，我们还需要考虑所有点都相等的情况，这样就可以看做所有点都在一条直线上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; i &lt; points.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (points[i][<span class="number">0</span>] != points[i + <span class="number">1</span>][<span class="number">0</span>] || points[i][<span class="number">1</span>] != points[i + <span class="number">1</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i == points.length - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> points.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有就是点的数量只有两个，或者一个，零个的时候，直接返回点的数量即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (points.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> points.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上所述，代码就出来了，其中 <code>test</code> 函数有三种写法。</p><details>    <summary>暴力破解</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (points.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> points.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; points.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (points[i][<span class="number">0</span>] != points[i + <span class="number">1</span>][<span class="number">0</span>] || points[i][<span class="number">1</span>] != points[i + <span class="number">1</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == points.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> points.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; points.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (points[i][<span class="number">0</span>] == points[j][<span class="number">0</span>] &amp;&amp; points[i][<span class="number">1</span>] == points[j][<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> tempMax = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; points.length; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k != i &amp;&amp; k != j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (test(points[i][<span class="number">0</span>], points[i][<span class="number">1</span>], points[j][<span class="number">0</span>], points[j][<span class="number">1</span>], points[k][<span class="number">0</span>], points[k][<span class="number">1</span>])) &#123;</span><br><span class="line">                        tempMax++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tempMax &gt; max) &#123;</span><br><span class="line">                max = tempMax;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加上直线本身的两个点</span></span><br><span class="line">    <span class="keyword">return</span> max + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*private boolean test(int x1, int y1, int x2, int y2, int x, int y) &#123;</span></span><br><span class="line"><span class="comment">return (long)(y2 - y1) * (x - x2) == (long)(y - y2) * (x2 - x1);</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*private boolean test(int x1, int y1, int x2, int y2, int x, int y) &#123;        </span></span><br><span class="line"><span class="comment">    BigInteger x11 = BigInteger.valueOf(x1);</span></span><br><span class="line"><span class="comment">    BigInteger x22 = BigInteger.valueOf(x2);</span></span><br><span class="line"><span class="comment">    BigInteger y11 = BigInteger.valueOf(y1);</span></span><br><span class="line"><span class="comment">   BigInteger y22 = BigInteger.valueOf(y2);</span></span><br><span class="line"><span class="comment">    BigInteger x0 = BigInteger.valueOf(x);</span></span><br><span class="line"><span class="comment">    BigInteger y0 = BigInteger.valueOf(y);</span></span><br><span class="line"><span class="comment">    return y22.subtract(y11).multiply(x0.subtract(x22)).equals(y0.subtract(y22).multiply(x22.subtract(x11)));</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> g1 = gcd(y2 - y1, x2 - x1);</span><br><span class="line">    <span class="keyword">if</span>(y == y2 &amp;&amp; x == x2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> g2 = gcd(y - y2, x - x2);</span><br><span class="line">    <span class="keyword">return</span> (y2 - y1) / g1 == (y - y2) / g2 &amp;&amp; (x2 - x1) / g1 == (x - x2) / g2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a % b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h1><p>解法一很暴力，我们考虑在其基础上进行优化。</p><p>注意到，如果是下边的情况。</p><p><a href="https://pic.leetcode-cn.com/c2640aab030eac4f019a44b6b88b830002ed056f571c04b4b8dd6a3910bfae5c.jpg" target="_blank" rel="noopener">情况</a></p><p>对于解法一的算法，我们会经过下边的流程。</p><p>我们先考虑 <code>1,2</code> 组成的直线，看 <code>3,4,5,6</code>在不在 <code>1,2</code> 的直线上。</p><p>再考虑 <code>1,3</code> 组成的直线，看 <code>2,4,5,6</code>在不在 <code>1,3</code> 的直线上。</p><p>再考虑 <code>1,4</code> 组成的直线，看 <code>2,3,5,6</code>在不在 <code>1,4</code> 的直线上。</p><p>….</p><p>上边的问题很明显了，对于 <code>1,2</code>，<code>1,3</code>，<code>1,4</code>  … 组成的直线，其实是同一条，我们只需要判断一次就可以了。</p><p>所以我们需要做的是，怎么保证在判断完 <code>1,2</code> 构成的直线后，把 <code>1,3</code>，<code>1,4</code>… 这些在 <code>1,2</code> 直线上的点直接跳过。</p><p>回到数学上，给定两个点可以唯一的确定一条直线，表达式为 <code>y = kx + b</code>。</p><p>对于 <code>1,2</code>，<code>1,3</code>，<code>1,4</code> 这些点求出来的表达式都是唯一确定的。</p><p>所以我们当考虑 <code>1,2</code> 两个点的时候，我们可以求出 <code>k</code> 和 <code>b</code> 把它存到 <code>HashSet</code> 中，然后当考虑 <code>1,3</code> 以及后边的点的时候，先求出 <code>k</code> 和 <code>b</code>，然后从 <code>HashSet</code> 中看是否存在即可。</p><p>当然存的时候，我们可以用一个技巧，<code>key</code> 存一个  <code>String</code> ，也就是 <code>k + &quot;@&quot; + b</code> 。</p><details>    <summary>暴力破解优化</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(points.length &lt; <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> points.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//判断所有点是否都相同的特殊情况</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; points.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (points[i][<span class="number">0</span>] != points[i + <span class="number">1</span>][<span class="number">0</span>] || points[i][<span class="number">1</span>] != points[i + <span class="number">1</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == points.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> points.length;</span><br><span class="line">    &#125;</span><br><span class="line">    HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; points.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (points[i][<span class="number">0</span>] == points[j][<span class="number">0</span>] &amp;&amp; points[i][<span class="number">1</span>] == points[j][<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String key = getK(points[i][<span class="number">0</span>], points[i][<span class="number">1</span>], points[j][<span class="number">0</span>], points[j][<span class="number">1</span>])</span><br><span class="line">                       + <span class="string">"@"</span></span><br><span class="line">                       + getB(points[i][<span class="number">0</span>], points[i][<span class="number">1</span>], points[j][<span class="number">0</span>], points[j][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (set.contains(key)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> tempMax = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; points.length; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k != i &amp;&amp; k != j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (test(points[i][<span class="number">0</span>], points[i][<span class="number">1</span>], points[j][<span class="number">0</span>], points[j][<span class="number">1</span>], points[k][<span class="number">0</span>], points[k][<span class="number">1</span>])) &#123;</span><br><span class="line">                        tempMax++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tempMax &gt; max) &#123;</span><br><span class="line">                max = tempMax;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">getB</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (y2 == y1) &#123;</span><br><span class="line">        <span class="keyword">return</span> Double.POSITIVE_INFINITY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">double</span>) (x2 - x1) * (-y1) / (y2 - y1) + x1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">getK</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x2 - x1 == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Double.POSITIVE_INFINITY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">double</span>) (y2 - y1) / (x2 - x1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">long</span>)(y2 - y1) * (x - x2) == (<span class="keyword">long</span>)(y - y2) * (x2 - x1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>上边的算法虽然能 <code>AC</code>，但如果严格来说其实是有问题的。还是因为之前说的浮点数的问题，计算机并不能精确表示小数。这就造成不同的直线可能会求出相同的 <code>k</code> 和 <code>b</code>。</p><p>如果要修改的话，我们可以用分数表示小数，同时必须进行约分，使得分数化成最简。</p><p>对于上边的算法，有两个变量都需要用小数表示，所以可能会复杂些，可以看一下解法三的思路。</p><h1 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h1><p>解法二中，我们相当于是对直线的分类，一条直线一条直线的考虑，去求直线上的点。</p><p><a href="https://leetcode.com/problems/max-points-on-a-line/discuss/47113/A-java-solution-with-notes" target="_blank" rel="noopener">这里</a> 看到另一种想法，分享一下。</p><p>灵感应该来自于直线方程的另一种表示方式，「点斜式」，换句话，一个点加一个斜率即可唯一的确定一条直线。</p><p>所以我们可以对「点」进行分类然后去求，问题转换成，经过某个点的直线，哪条直线上的点最多。</p><p><a href="https://pic.leetcode-cn.com/f9da822aada3c01a0eaf203d6df4107c58cf0cf06dc99082a32fa31360368c6d.jpg" target="_blank" rel="noopener">示意图</a></p><p>当确定一个点后，平面上的其他点都和这个点可以求出一个斜率，斜率相同的点就意味着在同一条直线上。</p><p>所以我们可以用 <code>HashMap</code> 去计数，斜率作为 <code>key</code>，然后遍历平面上的其他点，相同的 <code>key</code> 意味着在同一条直线上。</p><p>上边的思想解决了「经过某个点的直线，哪条直线上的点最多」的问题。接下来只需要换一个点，然后用同样的方法考虑完所有的点即可。</p><p>当然还有一个问题就是斜率是小数，怎么办。</p><p>之前提到过了，我们用分数去表示，求分子分母的最大公约数，然后约分，最后将 「分子 + “@” + “分母”」作为 <code>key</code> 即可。</p><p>最后还有一个细节就是，当确定某个点的时候，平面内如果有和这个重叠的点，如果按照正常的算法约分的话，会出现除 <code>0</code> 的情况，所以我们需要单独用一个变量记录重复点的个数，而重复点一定是过当前点的直线的。</p><details>    <summary>暴力破解</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (points.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> points.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历每个点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> duplicate = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;<span class="comment">//保存经过当前点的直线中，最多的点</span></span><br><span class="line">        HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; points.length; j++) &#123;</span><br><span class="line">            <span class="comment">//求出分子分母</span></span><br><span class="line">            <span class="keyword">int</span> x = points[j][<span class="number">0</span>] - points[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = points[j][<span class="number">1</span>] - points[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//重叠的点</span></span><br><span class="line">                duplicate++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进行约分</span></span><br><span class="line">            <span class="keyword">int</span> gcd = gcd(x, y);</span><br><span class="line">            x = x / gcd;</span><br><span class="line">            y = y / gcd;</span><br><span class="line">            String key = x + <span class="string">"@"</span> + y;</span><br><span class="line">            map.put(key, map.getOrDefault(key, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            max = Math.max(max, map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1 代表当前考虑的点，duplicate 代表和当前的点重复的点</span></span><br><span class="line">        res = Math.max(res, max + duplicate + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a % b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="解惑"><a href="#解惑" class="headerlink" title="解惑"></a>解惑</h1><p>解法三还是不太明白，如果有两条平行直线，那么斜率一样，不就都存到一个哈希key里去了吗？</p><p>以注意下循环和辅助哈希表的创建位置，最外层的循环已经确保了当前哈希表里的斜率是对当前节点points[i]的。每次循环到一个点都会重新定义一个哈希表，所以会避免这种情况</p><h1 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h1><p>这道题首先还是去想暴力的想法，然后去考虑重复的情况，对情况进行分类从而优化时间复杂度。同样解法三其实也是一种分类的思想，会减少很多不必要情况的讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个二维平面，平面上有 n 个点，求最多有多少个点在同一条直线上。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>260. 只出现一次的数字III</title>
    <link href="http://yoursite.com/2020/09/17/260.%20%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97III/"/>
    <id>http://yoursite.com/2020/09/17/260. 只出现一次的数字III/</id>
    <published>2020-09-17T09:55:12.000Z</published>
    <updated>2020-09-17T10:37:15.626Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。</p><a id="more"></a><p> 示例 :</p><pre><code>输入: [1,2,1,3,2,5]输出: [3,5]</code></pre><p> 注意：</p><pre><code>结果输出的顺序并不重要，对于上面的例子， [5, 3] 也是正确答案。你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？</code></pre><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>使用哈希表可以在 O(N) 的时间复杂度和 O(N)  的空间复杂度中解决该问题。</p><p>这个问题在常数的空间复杂度中解决有点困难，但可以借助两个位掩码来实现。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjYwL3R3bzIucG5n?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><h1 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h1><p>建立一个值到频率的映射关系的哈希表，返回频率为 1 的数字。</p><p><strong>算法：</strong></p><details>    <summary>哈希表Python</summary><figure class="highlight python"><figcaption><span>[solution1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums: int)</span> -&gt; List[int]:</span></span><br><span class="line">        hashmap = Counter(nums)</span><br><span class="line">        <span class="keyword">return</span> [x <span class="keyword">for</span> x <span class="keyword">in</span> hashmap <span class="keyword">if</span> hashmap[x] == <span class="number">1</span>]</span><br></pre></td></tr></table></figure></details><details>    <summary>哈希表Java</summary><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumber(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; hashmap = <span class="keyword">new</span> HashMap();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : nums)</span><br><span class="line">      hashmap.put(n, hashmap.getOrDefault(n, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] output = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; item : hashmap.entrySet())</span><br><span class="line">      <span class="keyword">if</span> (item.getValue() == <span class="number">1</span>) output[idx++] = item.getKey();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(N)。</li><li>空间复杂度：O(N) ，哈希表所使用的空间。</li></ul><h1 id="方法二：两个掩码"><a href="#方法二：两个掩码" class="headerlink" title="方法二：两个掩码"></a>方法二：两个掩码</h1><p>本文将使用两个按位技巧：</p><ul><li>使用异或运算可以帮助我们消除出现两次的数字；我们计算 <code>bitmask ^= x</code>，则 <code>bitmask</code> 留下的就是出现奇数次的位。</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjYwL3hvcjMucG5n?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><ul><li><code>x &amp; (-x)</code> 是保留位中最右边 <code>1</code> ，且将其余的 <code>1</code> 设位 <code>0</code> 的方法。</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjYwL2lzb2xhdGUzLnBuZw?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><p><strong>算法：</strong></p><p>首先计算 <code>bitmask ^= x</code>，则 <code>bitmask</code> 不会保留出现两次数字的值，因为相同数字的异或值为 <code>0</code>。</p><p>但是 <code>bitmask</code> 会保留只出现一次的两个数字（<code>x</code> 和 <code>y</code>）之间的差异。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjYwL2RpZmZfbmV3LnBuZw?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><p>我们可以直接从 <code>bitmask</code> 中提取 <code>x</code> 和 <code>y</code> 吗？不能，但是我们可以用 <code>bitmask</code> 作为标记来分离 <code>x</code> 和 <code>y</code>。</p><p>我们通过 <code>bitmask &amp; (-bitmask)</code> 保留 <code>bitmask</code> 最右边的 <code>1</code>，这个 <code>1</code> 要么来自 <code>x</code>，要么来自 <code>y</code>。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjYwL2lzb2xhdGUyX25ldy5wbmc?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>当我们找到了 <code>x</code>，那么 <code>y = bitmask^x</code>。</p><details>    <summary>两个掩码Python</summary><figure class="highlight python"><figcaption><span>[solution2-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># difference between two numbers (x and y) which were seen only once</span></span><br><span class="line">        bitmask = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            bitmask ^= num</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># rightmost 1-bit diff between x and y</span></span><br><span class="line">        diff = bitmask &amp; (-bitmask)</span><br><span class="line">        </span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># bitmask which will contain only x</span></span><br><span class="line">            <span class="keyword">if</span> num &amp; diff:</span><br><span class="line">                x ^= num</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [x, bitmask^x]</span><br></pre></td></tr></table></figure></details><details>    <summary>两个掩码Java</summary><figure class="highlight java"><figcaption><span>[solution2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumber(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="comment">// difference between two numbers (x and y) which were seen only once</span></span><br><span class="line">    <span class="keyword">int</span> bitmask = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) bitmask ^= num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rightmost 1-bit diff between x and y</span></span><br><span class="line">    <span class="keyword">int</span> diff = bitmask &amp; (-bitmask);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// bitmask which will contain only x</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) <span class="keyword">if</span> ((num &amp; diff) != <span class="number">0</span>) x ^= num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x, bitmask^x&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(N) 的时间遍历输入数组。</li><li>空间复杂度：O(1)。</li></ul><h2 id="解惑"><a href="#解惑" class="headerlink" title="解惑"></a>解惑</h2><p><strong>这里我一开始有些疑惑，为什么要么来自于x要么来自于y呢，后来才想到如果x和y最右边的1位相同的话那么在bitmask中该位一定是0，bitmask中最右边的1一定是x和y从右边开始第一个不同的位</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
  <entry>
    <title>136. 只出现一次的数字</title>
    <link href="http://yoursite.com/2020/09/16/136.%20%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2020/09/16/136. 只出现一次的数字/</id>
    <published>2020-09-16T09:12:12.000Z</published>
    <updated>2020-09-16T09:01:09.183Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><a id="more"></a><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p>示例 1:</p><pre><code>输入: [2,2,1]输出: 1</code></pre><p>示例 2:</p><pre><code>输入: [4,1,2,1,2]输出: 4</code></pre><h1 id="📺-视频题解"><a href="#📺-视频题解" class="headerlink" title="📺 视频题解"></a>📺 视频题解</h1><p><a href="47a527e0-e01f-4ece-a158-140764b7c319">136. 只出现一次的数字.mp4</a></p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="方法一：位运算"><a href="#方法一：位运算" class="headerlink" title="方法一：位运算"></a>方法一：位运算</h2><p>如果没有时间复杂度和空间复杂度的限制，这道题有很多种解法，可能的解法有如下几种。</p><ul><li><p>使用集合存储数字。遍历数组中的每个数字，如果集合中没有该数字，则将该数字加入集合，如果集合中已经有该数字，则将该数字从集合中删除，最后剩下的数字就是只出现一次的数字。</p></li><li><p>使用哈希表存储每个数字和该数字出现的次数。遍历数组即可得到每个数字出现的次数，并更新哈希表，最后遍历哈希表，得到只出现一次的数字。</p></li><li><p>使用集合存储数组中出现的所有数字，并计算数组中的元素之和。由于集合保证元素无重复，因此计算集合中的所有元素之和的两倍，即为每个元素出现两次的情况下的元素之和。由于数组中只有一个元素出现一次，其余元素都出现两次，因此用集合中的元素之和的两倍减去数组中的元素之和，剩下的数就是数组中只出现一次的数字。</p></li></ul><p>上述三种解法都需要额外使用 <em>O(n)</em> 的空间，其中 <em>n</em> 是数组长度。如果要求使用线性时间复杂度和常数空间复杂度，上述三种解法显然都不满足要求。那么，如何才能做到线性时间复杂度和常数空间复杂度呢？</p><p>答案是使用位运算。对于这道题，可使用异或运算 ^ 。异或运算有以下三个性质。</p><ol><li>任何数和 <em>0</em> 做异或运算，结果仍然是原来的数。</li><li>任何数和其自身做异或运算，结果是 <em>0</em>。</li><li>异或运算满足交换律和结合律.</li></ol><p>假设数组中有 <em>2m+1</em> 个数，其中有 <em>m</em> 个数各出现两次，一个数出现一次。令 <em>a_{1}<em>、</em>a_{2}<em>、…、</em>a_{m}</em> 为出现两次的 <em>m</em> 个数，<em>a_{m+1}</em> 为出现一次的数。</p><p>因此，数组中的全部元素的异或运算结果即为数组中只出现一次的数字。</p><details>    <summary>位运算Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> single = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            single ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>位运算C++</summary><figure class="highlight cpp"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> e: nums) ret ^= e;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>位运算Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y: x ^ y, nums)</span><br></pre></td></tr></table></figure></details><details>    <summary>位运算C#</summary><figure class="highlight csharp"><figcaption><span>[sol1-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">SingleNumber</span>(<span class="params"><span class="keyword">int</span>[] nums</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">int</span> e <span class="keyword">in</span> nums) ret ^= e;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>位运算Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">singleNumber</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    single := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        single ^= num</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> single</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)*，其中 *n</em> 是数组长度。只需要对数组遍历一次。</p></li><li><p>空间复杂度：<em>O(1)</em>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>137. 只出现一次的数字II</title>
    <link href="http://yoursite.com/2020/09/16/137.%20%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97II/"/>
    <id>http://yoursite.com/2020/09/16/137. 只出现一次的数字II/</id>
    <published>2020-09-16T09:12:12.000Z</published>
    <updated>2020-09-17T09:53:05.162Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。 </p><a id="more"></a><p> 说明： </p><pre><code>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ </code></pre><p> 示例 1: </p><pre><code>输入: [2,2,3,2]输出: 3</code></pre><p> 示例 2: </p><pre><code>输入: [0,1,0,1,0,1,99]输出: 99 </code></pre><h1 id="解题思路-1："><a href="#解题思路-1：" class="headerlink" title="解题思路^1："></a>解题思路<a href="https://leetcode-cn.com/problems/single-number-ii/solution/single-number-ii-mo-ni-san-jin-zhi-fa-by-jin407891/" target="_blank" rel="noopener">^1</a>：</h1><p>如下图所示，考虑数字的二进制形式，对于出现三次的数字，各 <strong>二进制位</strong> 出现的次数都是 <em>3</em> 的倍数。<br>因此，统计所有数字的各二进制位中 <em>1</em> 的出现次数，并对 <em>3</em> 求余，结果则为只出现一次的数字。</p><p><a href="https://pic.leetcode-cn.com/28f2379be5beccb877c8f1586d8673a256594e0fc45422b03773b8d4c8418825-Picture1.png" target="_blank" rel="noopener">Picture1.png</a></p><h1 id="方法一：有限状态自动机"><a href="#方法一：有限状态自动机" class="headerlink" title="方法一：有限状态自动机"></a>方法一：有限状态自动机</h1><p>各二进制位的 <strong>位运算规则相同</strong> ，因此只需考虑一位即可。如下图所示，对于所有数字中的某二进制位 <em>1</em> 的个数，存在 3 种状态，即对 3 余数为 <em>0, 1, 2</em> 。</p><ul><li>若输入二进制位 <em>1</em> ，则状态按照以下顺序转换；</li><li>若输入二进制位 <em>0</em> ，则状态不变。</li></ul><p>0-&gt;1-&gt;2-&gt;0-&gt;…</p><p><a href="https://pic.leetcode-cn.com/ab00d4d1ad961a3cd4fc1840e34866992571162096000325e7ce10ff75fda770-Picture2.png" target="_blank" rel="noopener">Picture2.png</a></p><p>如下图所示，由于二进制只能表示 <em>0, 1</em> ，因此需要使用两个二进制位来表示 <em>3</em> 个状态。设此两位分别为 <em>two</em> , <em>one</em> ，则状态转换变为：</p><p>00-&gt;01-&gt;10-&gt;00</p><p><a href="https://pic.leetcode-cn.com/0a7ea5bca055b095673620d8bb4c98ef6c610a22f999294ed11ae35d43621e93-Picture3.png" target="_blank" rel="noopener">Picture3.png</a></p><p>接下来，需要通过 <strong>状态转换表</strong> 导出 <strong>状态转换的计算公式</strong> 。首先回忆一下位运算特点，对于任意二进制位 <em>x</em> ，有：</p><ul><li>异或运算：<code>x ^ 0 = x</code>​ ， <code>x ^ 1 = ~x</code></li><li>与运算：<code>x &amp; 0 = 0</code> ， <code>x &amp; 1 = x</code></li></ul><p><strong>计算 <em>one</em> 方法：</strong></p><p>设当前状态为 <em>two</em> <em>one</em> ，此时输入二进制位 <em>n</em> 。如下图所示，通过对状态表的情况拆分，可推出 <em>one</em> 的计算方法为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> two == <span class="number">0</span>:</span><br><span class="line">  <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">    one = one</span><br><span class="line">  <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">    one = ~one</span><br><span class="line"><span class="keyword">if</span> two == <span class="number">1</span>:</span><br><span class="line">    one = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>引入 <strong>异或运算</strong> ，可将以上拆分简化为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> two == <span class="number">0</span>:</span><br><span class="line">    one = one ^ n</span><br><span class="line"><span class="keyword">if</span> two == <span class="number">1</span>:</span><br><span class="line">    one = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>引入 <strong>与运算</strong> ，可继续简化为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one = one ^ n &amp; ~two</span><br></pre></td></tr></table></figure><p><a href="https://pic.leetcode-cn.com/f75d89219ad93c69757b187c64784b4c7a57dce7911884fe82f14073d654d32f-Picture4.png" target="_blank" rel="noopener">Picture4.png</a></p><p><strong>计算 <em>two</em> 方法：</strong></p><p>由于是先计算 <em>one</em> ，因此应在新 <em>one</em> 的基础上计算 <em>two</em> 。<br>如下图所示，修改为新 <em>one</em> 后，得到了新的状态图。观察发现，可以使用同样的方法计算 <em>two</em> ，即：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">two = two ^ n &amp; ~one</span><br></pre></td></tr></table></figure><p><strong>这部分我一开始看时有些疑惑，但仔细看下面这张图会发现其中one都是新的变化后的，可以再把one和two调换位置就发现整个状态变化图是等效的了。</strong></p><p><a href="https://pic.leetcode-cn.com/6ba76dba1ac98ee2bb982e011fdffd1df9a6963f157b2780461dbce453f0ded3-Picture5.png" target="_blank" rel="noopener">Picture5.png</a></p><p><strong>返回值：</strong></p><p>以上是对数字的二进制中 “一位” 的分析，而 <code>int</code> 类型的其他 31 位具有相同的运算规则，因此可将以上公式直接套用在 32 位数上。</p><p>遍历完所有数字后，各二进制位都处于状态 <em>00</em> 和状态 <em>01</em> （取决于 “只出现一次的数字” 的各二进制位是 <em>1</em> 还是 <em>0</em> ），而此两状态是由 <em>one</em> 来记录的（此两状态下 <em>twos</em> 恒为 <em>0</em> ），因此返回 <em>ones</em> 即可。</p><h2 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h2><ul><li><p><strong>时间复杂度 <em>O(N)</em> ：</strong> 其中 <em>N</em> 位数组 <em>nums</em> 的长度；遍历数组占用 <em>O(N)</em> ，每轮中的常数个位运算操作占用 O(32<em>3</em>2)=O(1)。</p></li><li><p><strong>空间复杂度 <em>O(1)</em> ：</strong> 变量 <em>ones</em> , <em>twos</em> 使用常数大小的额外空间。</p><p><a href="https://pic.leetcode-cn.com/045023f05080e0844f05b8ee5b68885e1b9e41926d3e4ab054c68e6dceacfc0a-Picture6.png" target="_blank" rel="noopener">Picture6.png</a> <a href="https://pic.leetcode-cn.com/fd0ab6b3cd20c18729321957f6b4bedbf6480fd6862c01de1c5d598c82a26d2b-Picture7.png" target="_blank" rel="noopener">Picture7.png</a> <a href="https://pic.leetcode-cn.com/46b0974b13206beda512dd037df10772fae1c7375a97a7a05abb4a736dc0ebb3-Picture8.png" target="_blank" rel="noopener">Picture8.png</a> <a href="https://pic.leetcode-cn.com/4cfe4cf13367851efdb9dee5fceed969326cc3478be0769c8f60294ef5d2866d-Picture9.png" target="_blank" rel="noopener">Picture9.png</a> <a href="https://pic.leetcode-cn.com/fa2e7ecb991d5183e2f53ca7741150ae18badb087b01bff4a32caaec245fec79-Picture10.png" target="_blank" rel="noopener">Picture10.png</a> <a href="https://pic.leetcode-cn.com/6a6b8561c913c45d7be3428ff8553a2188890fee0687a1a113a7c2bea12b95a9-Picture11.png" target="_blank" rel="noopener">Picture11.png</a> </p></li></ul><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><details>    <summary>有限状态自动机python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        ones, twos = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            ones = ones ^ num &amp; ~twos</span><br><span class="line">            twos = twos ^ num &amp; ~ones</span><br><span class="line">        <span class="keyword">return</span> ones</span><br></pre></td></tr></table></figure></details><details>    <summary>有限状态自动机java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            ones = ones ^ num &amp; ~twos;</span><br><span class="line">            twos = twos ^ num &amp; ~ones;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ones;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="方法二：遍历统计"><a href="#方法二：遍历统计" class="headerlink" title="方法二：遍历统计"></a>方法二：遍历统计</h1><blockquote><p>此方法相对容易理解，但效率较低，总体推荐方法一。</p></blockquote><p>使用 <strong>与运算</strong> ，可获取二进制数字 <em>num</em> 的最右一位 <em>n_1</em> ：</p><p>n_1=num &amp; i</p><p>配合 <strong>无符号右移操作</strong> ，可获取 <em>num</em> 所有位的值（即 <em>n_1</em> ~ <em>n_{32}</em> ）：</p><p>num = num &gt;&gt;&gt; 1</p><p>建立一个长度为 32 的数组 <em>counts</em> ，通过以上方法可记录所有数字的各二进制位的 <em>1</em> 的出现次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span>; j++) &#123;</span><br><span class="line">        counts[j] += nums[i] &amp; <span class="number">1</span>; <span class="comment">// 更新第 j 位</span></span><br><span class="line">        nums[i] &gt;&gt;&gt;= <span class="number">1</span>; <span class="comment">// 第 j 位 --&gt; 第 j + 1 位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 <em>counts</em> 各元素对 <em>3</em> 求余，则结果为 “只出现一次的数字” 的各二进制位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">    counts[i] %= <span class="number">3</span>; <span class="comment">// 得到 只出现一次的数字 的第 (31 - i) 位 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用 <strong>左移操作</strong> 和 <strong>或运算</strong> ，可将 <em>counts</em> 数组中各二进位的值恢复到数字 <em>res</em> 上（循环区间是 <img src="./p__i_in__0,_31__.png" alt="i\in\[0,31\] ">  ）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; counts.length; i++) &#123;</span><br><span class="line">    res &lt;&lt;= <span class="number">1</span>; <span class="comment">// 左移 1 位</span></span><br><span class="line">    res |= counts[<span class="number">31</span> - i]; <span class="comment">// 恢复第 i 位的值到 res</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终返回 <em>res</em> 即可。</p><blockquote><p>由于 Python 的存储负数的特殊性，需要先将 <em>0</em> - <em>32</em> 位取反（即 <code>res ^ 0xffffffff</code> ），再将所有位取反（即 <code>~</code> ）。<br>两个组合操作实质上是将数字 <em>32</em> 以上位取反， <em>0</em> - <em>32</em> 位不变。</p></blockquote><h2 id="复杂度分析：-1"><a href="#复杂度分析：-1" class="headerlink" title="复杂度分析："></a>复杂度分析：</h2><ul><li><strong>时间复杂度 <em>O(N)</em> ：</strong> 其中 <em>N</em> 位数组 <em>nums</em> 的长度；遍历数组占用 <em>O(N)</em> ，每轮中的常数个位运算操作占用 <em>O(1)</em> 。</li><li><strong>空间复杂度 <em>O(1)</em> ：</strong> 数组 <em>counts</em> 长度恒为 <em>32</em> ，占用常数大小的额外空间。</li></ul><h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><p>实际上，只需要修改求余数值 <em>m</em> ，即可实现解决 <strong>除了一个数字以外，其余数字都出现 <em>m</em> 次</strong> 的通用问题。</p><details>    <summary>遍历统计python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        counts = [<span class="number">0</span>] * <span class="number">32</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">                counts[j] += num &amp; <span class="number">1</span></span><br><span class="line">                num &gt;&gt;= <span class="number">1</span></span><br><span class="line">        res, m = <span class="number">0</span>, <span class="number">3</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">            res &lt;&lt;= <span class="number">1</span></span><br><span class="line">            res |= counts[<span class="number">31</span> - i] % m</span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> counts[<span class="number">31</span>] % m == <span class="number">0</span> <span class="keyword">else</span> ~(res ^ <span class="number">0xffffffff</span>)</span><br></pre></td></tr></table></figure></details><details>    <summary>遍历统计java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span>; j++) &#123;</span><br><span class="line">                counts[j] += num &amp; <span class="number">1</span>;</span><br><span class="line">                num &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, m = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            res &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            res |= counts[<span class="number">31</span> - i] % m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。 &lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
</feed>
