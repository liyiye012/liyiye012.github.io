<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-03-04T08:47:03.890Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>269.火星词典</title>
    <link href="http://yoursite.com/2021/02/27/269.%E7%81%AB%E6%98%9F%E8%AF%8D%E5%85%B8/"/>
    <id>http://yoursite.com/2021/02/27/269.火星词典/</id>
    <published>2021-02-27T06:12:12.000Z</published>
    <updated>2021-03-04T08:47:03.890Z</updated>
    
    <content type="html"><![CDATA[<p>有一种新的使用拉丁字母的外来语言。但是，你不知道字母之间的顺序。你会从词典中收到一个非空的单词列表，其中的单词在这种新语言的规则下按字典顺序排序。请推导出这种语言的字母顺序</p><a id="more"></a><p>此题也是LintCode上的 892. 外星人字典，可以直接在官网链接<a href="https://www.lintcode.com/problem/alien-dictionary?utm_source=sc-zhihuzl-sy" target="_blank" rel="noopener">^1</a>提交代码测试。也曾经是抖音的一道面试题。</p><ol><li>你可以假设所有的字母都是小写。</li><li>如果a是b的前缀且b出现在a之前，那么这个顺序是无效的。</li><li>如果顺序是无效的，则返回空字符串。</li><li>这里可能有多个有效的字母顺序，返回以正常字典顺序看来最小的。</li></ol><p>样例 1:</p><pre><code>输入：[&quot;wrt&quot;,&quot;wrf&quot;,&quot;er&quot;,&quot;ett&quot;,&quot;rftt&quot;]输出：&quot;wertf&quot;解释：从 &quot;wrt&quot;和&quot;wrf&quot; ,我们可以得到 &apos;t&apos;&lt;&apos;f&apos;从 &quot;wrt&quot;和&quot;er&quot; ,我们可以得到&apos;w&apos;&lt;&apos;e&apos;从 &quot;er&quot;和&quot;ett&quot; ,我们可以得到 get &apos;r&apos;&lt;&apos;t&apos;从 &quot;ett&quot;和&quot;rftt&quot; ,我们可以得到 &apos;e&apos;&lt;&apos;r&apos;所以返回 &quot;wertf&quot;</code></pre><p>样例 2:</p><pre><code>输入：[&quot;z&quot;,&quot;x&quot;]输出：&quot;zx&quot;解释：从 &quot;z&quot; 和 &quot;x&quot;，我们可以得到 &apos;z&apos; &lt; &apos;x&apos;所以返回&quot;zx&quot;</code></pre><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这是很明显的拓扑排序，可以参考210.课程表II的代码。区别在于那个拓扑排序是对整数而且输入样例是给好的。这道题里要自己整理好要拓扑排序的数据，而且将拓扑排序的代码更改为对字符串排序，在改动的过程中踩了一些坑。</p><p>网上很多博客的代码也踩了这些坑，比如如果a是b的前缀且b出现在a之前，那么这个顺序是无效的，[“abc”,”ab”]，所以是没法通过的。</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><details>    <summary>宽度优先搜索-拓扑排序</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public static String findOrder(Set&lt;Character&gt; set,Character[][] prerequisites) &#123;</span><br><span class="line">        Map&lt;Character, List&lt;Character&gt;&gt; edges;</span><br><span class="line">        Map&lt;Character,Integer&gt; indeg;</span><br><span class="line">        String res=&quot;&quot;;</span><br><span class="line"></span><br><span class="line">        edges=new HashMap&lt;&gt;();</span><br><span class="line">        indeg=new HashMap&lt;&gt;();</span><br><span class="line">        for(Character[] info: prerequisites)&#123;</span><br><span class="line">            List&lt;Character&gt; list = edges.get(info[1]);</span><br><span class="line">            if (Objects.isNull(list)) &#123;</span><br><span class="line">                list = new ArrayList&lt;Character&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(info[0]);</span><br><span class="line">            edges.put(info[1], list);</span><br><span class="line">            indeg.put(info[0], indeg.getOrDefault(info[0],0) + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        //这里可能有多个有效的字母顺序，返回以正常字典顺序看来最小的，[&quot;z&quot;,&quot;x&quot;,&quot;z&quot;]</span><br><span class="line">        //所以使用优先队列</span><br><span class="line">        PriorityQueue&lt;Character&gt; queue=new PriorityQueue&lt;Character&gt;();</span><br><span class="line">        for (Character c: set) &#123;</span><br><span class="line">            if (indeg.getOrDefault(c,0) == 0) &#123;</span><br><span class="line">                queue.offer(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while(!queue.isEmpty())&#123;</span><br><span class="line">            Character u=queue.poll();</span><br><span class="line">            res+=u;</span><br><span class="line">            if (!Objects.isNull(edges.get(u))) &#123;</span><br><span class="line">                for (Character v : edges.get(u)) &#123;</span><br><span class="line">                    indeg.put(v, indeg.getOrDefault(v, 0) - 1);</span><br><span class="line">                    if (indeg.getOrDefault(v, 0) == 0) &#123;</span><br><span class="line">                        queue.offer(v);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (set.size() != res.length()) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * @param words: a list of words</span><br><span class="line">     * @return: a string which is correct order</span><br><span class="line">     */</span><br><span class="line">    public String alienOrder(String[] words) &#123;</span><br><span class="line">        // Write your code here</span><br><span class="line">        Set&lt;Character&gt; set=new HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;Character[]&gt; lists=new HashSet&lt;&gt;();</span><br><span class="line">        int maxlen=0;</span><br><span class="line">        for (String s : words) &#123;</span><br><span class="line">            maxlen = Math.max(s.length(), maxlen);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; maxlen; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; words.length; j++) &#123;</span><br><span class="line">                Character c;</span><br><span class="line">                if (words[j].length() &gt; i) &#123;</span><br><span class="line">                    c = words[j].charAt(i);</span><br><span class="line">                    set.add(c);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                for (int k = j + 1; k &lt; words.length; k++) &#123;</span><br><span class="line">                    Character d;</span><br><span class="line">                    if (words[k].length() &gt; i) &#123;</span><br><span class="line">                        d = words[k].charAt(i);</span><br><span class="line">                        set.add(d);</span><br><span class="line">                        if (d != c &amp;&amp; words[j].substring(0,i).equals(words[k].substring(0,i))) &#123;</span><br><span class="line">                            lists.add(new Character[]&#123;d,c&#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                        //如果a是b的前缀且b出现在a之前，那么这个顺序是无效的，[&quot;abc&quot;,&quot;ab&quot;]</span><br><span class="line">                        if (words[j].startsWith(words[k])) &#123;</span><br><span class="line">                            return &quot;&quot;;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Character[][] character = new Character[lists.size()][];</span><br><span class="line">        int index = 0;</span><br><span class="line">        for (Character[] c : lists) &#123;</span><br><span class="line">            character[index] = c;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        return findOrder(set,character);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="解法II"><a href="#解法II" class="headerlink" title="解法II"></a>解法II</h2><details>    <summary>宽度优先搜索-拓扑排序</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String alienOrder(String[] words) &#123;</span><br><span class="line">        Map&lt;Character, Set&lt;Character&gt;&gt; graph = constructGraph(words);</span><br><span class="line">        if (graph == null) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return topologicalSorting(graph);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">    private Map&lt;Character, Set&lt;Character&gt;&gt; constructGraph(String[] words) &#123;</span><br><span class="line">        Map&lt;Character, Set&lt;Character&gt;&gt; graph = new HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        // create nodes</span><br><span class="line">        for (int i = 0; i &lt; words.length; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; words[i].length(); j++) &#123;</span><br><span class="line">                char c = words[i].charAt(j);</span><br><span class="line">                if (!graph.containsKey(c)) &#123;</span><br><span class="line">                    graph.put(c, new HashSet&lt;Character&gt;());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // create edges</span><br><span class="line">        for (int i = 0; i &lt; words.length - 1; i++) &#123;</span><br><span class="line">            int index = 0;</span><br><span class="line">            while (index &lt; words[i].length() &amp;&amp; index &lt; words[i + 1].length()) &#123;</span><br><span class="line">                if (words[i].charAt(index) != words[i + 1].charAt(index)) &#123;</span><br><span class="line">                    graph.get(words[i].charAt(index)).add(words[i + 1].charAt(index));</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果a是b的前缀且b出现在a之前，那么这个顺序是无效的，[&quot;abc&quot;,&quot;ab&quot;]</span><br><span class="line">            if (index == Math.min(words[i].length(), words[i + 1].length())) &#123;</span><br><span class="line">                if (words[i].length() &gt; words[i + 1].length()) &#123;</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return graph;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private Map&lt;Character, Integer&gt; getIndegree(Map&lt;Character, Set&lt;Character&gt;&gt; graph) &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; indegree = new HashMap&lt;&gt;();</span><br><span class="line">        for (Character u : graph.keySet()) &#123;</span><br><span class="line">            indegree.put(u, 0);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for (Character u : graph.keySet()) &#123;</span><br><span class="line">            for (Character v : graph.get(u)) &#123;</span><br><span class="line">                indegree.put(v, indegree.get(v) + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;     </span><br><span class="line">        </span><br><span class="line">        return indegree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String topologicalSorting(Map&lt;Character, Set&lt;Character&gt;&gt; graph) &#123;</span><br><span class="line">        // as we should return the topo order with lexicographical order</span><br><span class="line">        // we should use PriorityQueue instead of a FIFO Queue</span><br><span class="line">        Map&lt;Character, Integer&gt; indegree = getIndegree(graph);</span><br><span class="line">        Queue&lt;Character&gt; queue = new PriorityQueue&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        for (Character u : indegree.keySet()) &#123;</span><br><span class="line">            if (indegree.get(u) == 0) &#123;</span><br><span class="line">                queue.offer(u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            Character head = queue.poll();</span><br><span class="line">            sb.append(head);</span><br><span class="line">            for (Character neighbor : graph.get(head)) &#123;</span><br><span class="line">                indegree.put(neighbor, indegree.get(neighbor) - 1);</span><br><span class="line">                if (indegree.get(neighbor) == 0) &#123;</span><br><span class="line">                    queue.offer(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (sb.length() != indegree.size()) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>官网的题解<a href="https://www.jiuzhang.com/solutions/alien-dictionary/" target="_blank" rel="noopener">^2</a>和我自己魔改的版本其实没有太大区别，主要的不同之处在于使用了Map&lt;Character, Set<character>&gt;来存储拓扑图，StringBuilder来保存最终结果，以及判断如果a是b的前缀且b出现在a之前，那么这个顺序是无效的，[“abc”,”ab”]，如果使用Strings自带的startsWith方法效率会比改题解中的利用下标判断低。</character></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一种新的使用拉丁字母的外来语言。但是，你不知道字母之间的顺序。你会从词典中收到一个非空的单词列表，其中的单词在这种新语言的规则下按字典顺序排序。请推导出这种语言的字母顺序&lt;/p&gt;
    
    </summary>
    
      <category term="2021年2月" scheme="http://yoursite.com/categories/2021%E5%B9%B42%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Breadth-first Search" scheme="http://yoursite.com/tags/Breadth-first-Search/"/>
    
      <category term="Topological sort" scheme="http://yoursite.com/tags/Topological-sort/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识-装箱和拆箱</title>
    <link href="http://yoursite.com/2021/02/22/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1/"/>
    <id>http://yoursite.com/2021/02/22/Java基础知识-装箱和拆箱/</id>
    <published>2021-02-22T03:25:12.000Z</published>
    <updated>2021-02-22T07:24:00.286Z</updated>
    
    <content type="html"><![CDATA[<p>装箱和拆箱</p><a id="more"></a><h1 id="什么是装箱？什么是拆箱？"><a href="#什么是装箱？什么是拆箱？" class="headerlink" title="什么是装箱？什么是拆箱？"></a>什么是装箱？什么是拆箱？</h1><p>在java中有八种基本数据类型对应每种基本类型又有八种包装类型：<a href="https://zhuanlan.zhihu.com/p/78590948" target="_blank" rel="noopener">^1</a></p><p>基本类型：boolean， char， int， byte，short，long， float，double</p><p>包装器类型：Boolean，Character，Integer，Byte，Short，Long，Float，Double</p><p>从上面我们可以看到除了 char和int其它的包装类型名称和对应的基本类型一样只是首字母大写了。</p><p>既然有了基本类型为什么还要有包装类呢？我们在使用的过程中究竟用基本类型还是包装类呢？</p><p>在某些场合不能使用基本类型必须使用包装类，比如集合能接收的类型为Object,基本类型是无法添加进去的，还有范型也必须使用包装类。</p><p>另外假设我们要定义一个变量表示分数 如果用基本类型表示的话：int score;</p><p>默认值为零，如果我想表示分数为空也就是没有参加考试就没法表现了因为值类型是无法赋空值的，如果使用包装类型Integer score,就可以表示这种情况，因为Integer的默认值为空。</p><p>在Java SE5之前，如果要生成一个数值为10的Integer对象，必须这样进行：</p><pre><code>Integer i = new Integer(10);</code></pre><p>　　而在从Java SE5开始就提供了自动装箱的特性，如果要生成一个数值为10的Integer对象，只需要这样就可以了：</p><pre><code>Integer i = 10;</code></pre><p>　　这个过程中会自动根据数值创建对应的 Integer对象，这就是装箱。</p><p>　　那什么是拆箱呢？顾名思义，跟装箱对应，就是自动将包装器类型转换为基本数据类型：</p><pre><code>Integer i = 10;  //装箱int n = i;   //拆箱</code></pre><p>　　<br>　　简单一点说，装箱就是  自动将基本数据类型转换为包装器类型；拆箱就是  自动将包装器类型转换为基本数据类型。</p><h1 id="装箱和拆箱是如何实现的"><a href="#装箱和拆箱是如何实现的" class="headerlink" title="装箱和拆箱是如何实现的"></a>装箱和拆箱是如何实现的</h1><p>这部分主要内容来自于<a href="https://www.cnblogs.com/dolphin0520/p/3780005.html" target="_blank" rel="noopener">^2</a>，作者是Matrix海子，写的很清楚，这里为了阅读方便转载一下，内容如下：</p><details>    <summary>装箱和拆箱是如何实现的</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        Integer i = 10;</span><br><span class="line">        int n = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>先编译<code>javac Main.java</code>，然后反编译class文件 <code>javap -c Main</code>后</p><p>从反编译得到的字节码内容可以看出，在装箱的时候自动调用的是Integer的valueOf(int)方法。而在拆箱的时候自动调用的是Integer的intValue方法。</p><p>　　其他的也类似，比如Double、Character，不相信的朋友可以自己手动尝试一下。</p><p>　　因此可以用一句话总结装箱和拆箱的实现过程：</p><p>　　装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。（xxx代表对应的基本数据类型）。</p><h1 id="面试中相关的问题"><a href="#面试中相关的问题" class="headerlink" title="面试中相关的问题"></a>面试中相关的问题</h1><ol><li>代码的输出结果是什么<details> <summary>代码的输出结果是什么</summary></details></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        Integer i1 = 100;</span><br><span class="line">        Integer i2 = 100;</span><br><span class="line">        Integer i3 = 200;</span><br><span class="line">        Integer i4 = 200;</span><br><span class="line">         </span><br><span class="line">        System.out.println(i1==i2);</span><br><span class="line">        System.out.println(i3==i4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果表明i1和i2指向的是同一个对象，而i3和i4指向的是不同的对象。此时只需一看源码便知究竟,Integer的valueOf方法的具体实现和IntegerCache类的实现，通过valueOf方法创建Integer对象的时候，如果数值在[-128,127]之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。</p><p>　　上面的代码中i1和i2的数值为100，因此会直接从cache中取已经存在的对象，所以i1和i2指向的是同一个对象，而i3和i4则是分别指向不同的对象。</p><ol start="2"><li>代码的输出结果是什么</li></ol><details>    <summary>代码的输出结果是什么</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        Double i1 = 100.0;</span><br><span class="line">        Double i2 = 100.0;</span><br><span class="line">        Double i3 = 200.0;</span><br><span class="line">        Double i4 = 200.0;</span><br><span class="line">         </span><br><span class="line">        System.out.println(i1==i2);</span><br><span class="line">        System.out.println(i3==i4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>具体为什么，可以去看Double类的valueOf的实现。</p><p>　　在这里只解释一下为什么Double类的valueOf方法会采用与Integer类的valueOf方法不同的实现。很简单：在某个范围内的整型数值的个数是有限的，而浮点数却不是。</p><p>　　注意，Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的。</p><p>　　　　　Double、Float的valueOf方法的实现是类似的。　</p><ol start="3"><li>代码的输出结果是什么</li></ol><details>    <summary>代码的输出结果是什么</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Boolean i1 = false;</span><br><span class="line">        Boolean i2 = false;</span><br><span class="line">        Boolean i3 = true;</span><br><span class="line">        Boolean i4 = true;</span><br><span class="line">         </span><br><span class="line">        System.out.println(i1==i2);</span><br><span class="line">        System.out.println(i3==i4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>输出结果都是true,至于为什么是这个结果，同样地，看了Boolean类的源码也会一目了然</p><ol start="4"><li>谈谈Integer i = new Integer(xxx)和Integer i =xxx;这两种方式的区别。</li></ol><p>　　当然，这个题目属于比较宽泛类型的。但是要点一定要答上，我总结一下主要有以下这两点区别：</p><p>　　1）第一种方式不会触发自动装箱的过程；而第二种方式会触发；</p><p>　　2）在执行效率和资源占用上的区别。第二种方式的执行效率和资源占用在一般性情况下要优于第一种情况（注意这并不是绝对的）。</p><ol start="5"><li>代码的输出结果是什么</li></ol><details>    <summary>代码的输出结果是什么</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        Integer a = 1;</span><br><span class="line">        Integer b = 2;</span><br><span class="line">        Integer c = 3;</span><br><span class="line">        Integer d = 3;</span><br><span class="line">        Integer e = 321;</span><br><span class="line">        Integer f = 321;</span><br><span class="line">        Long g = 3L;</span><br><span class="line">        Long h = 2L;</span><br><span class="line">         </span><br><span class="line">        System.out.println(c==d);</span><br><span class="line">        System.out.println(e==f);</span><br><span class="line">        System.out.println(c==(a+b));</span><br><span class="line">        System.out.println(c.equals(a+b));</span><br><span class="line">        System.out.println(g==(a+b));</span><br><span class="line">        System.out.println(g.equals(a+b));</span><br><span class="line">        System.out.println(g.equals(a+h));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>当 “==”运算符的两个操作数都是包装器类型的引用，则是比较指向的是否是同一个对象，而如果其中有一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程）。另外，对于包装器类型，equals方法并不会进行类型转换。明白了这2点之后，上面的输出结果便一目了然：</p><pre><code>truefalsetruetruetruefalsetrue</code></pre><p>第一个和第二个输出结果没有什么疑问。第三句由于  a+b包含了算术运算，因此会触发自动拆箱过程（会调用intValue方法），因此它们比较的是数值是否相等。而对于c.equals(a+b)会先触发自动拆箱过程，再触发自动装箱过程，也就是说a+b，会先各自调用intValue方法，得到了加法运算后的数值之后，便调用Integer.valueOf方法，再进行equals比较。同理对于后面的也是这样，不过要注意倒数第二个和最后一个输出的结果（如果数值是int类型的，装箱过程调用的是Integer.valueOf；如果是long类型的，装箱调用的Long.valueOf方法）。</p><p>如果对上面的具体执行过程有疑问，可以尝试获取反编译的字节码内容进行查看。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;装箱和拆箱&lt;/p&gt;
    
    </summary>
    
      <category term="2021年2月" scheme="http://yoursite.com/categories/2021%E5%B9%B42%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识-重写 `equals` 时为何必须重写 `hashCode` 方法</title>
    <link href="http://yoursite.com/2021/02/22/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E9%87%8D%E5%86%99%20%60equals%60%20%E6%97%B6%E4%B8%BA%E4%BD%95%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99%20%60hashCode%60%20%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2021/02/22/Java基础知识-重写 `equals` 时为何必须重写 `hashCode` 方法/</id>
    <published>2021-02-22T02:00:12.000Z</published>
    <updated>2021-02-22T02:58:44.532Z</updated>
    
    <content type="html"><![CDATA[<p>重写 <code>equals</code> 时为何必须重写 <code>hashCode</code> 方法</p><a id="more"></a><h1 id="hashCode-与-equals"><a href="#hashCode-与-equals" class="headerlink" title="hashCode()与 equals()"></a>hashCode()与 equals()</h1><p>面试官可能会问你：“你重写过 <code>hashcode</code> 和 <code>equals</code>么，为什么重写 <code>equals</code> 时必须重写 <code>hashCode</code> 方法？”</p><p><strong>1)hashCode()介绍:</strong></p><p><code>hashCode()</code> 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。<code>hashCode()</code>定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是： <code>Object</code> 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p><p><strong>2)为什么要有 hashCode？</strong></p><p>我们以“<code>HashSet</code> 如何检查重复”为例子来说明为什么要有 hashCode？</p><p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 <code>equals()</code> 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的 Java 启蒙书《Head First Java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p><p><strong>3)为什么重写 <code>equals</code> 时必须重写 <code>hashCode</code> 方法？</strong></p><p>如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。<strong>因此，equals 方法被覆盖过，则 <code>hashCode</code> 方法也必须被覆盖。</strong></p><blockquote><p> <code>hashCode()</code>的默认行为是对堆上的对象产生独特值。如果没有重写 <code>hashCode()</code>，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p></blockquote><p><strong>4)为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？</strong></p><p>在这里解释一位小伙伴的问题。以下内容摘自《Head Fisrt Java》。</p><p>因为 <code>hashCode()</code> 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code>。</p><p>我们刚刚也提到了 <code>HashSet</code>,如果 <code>HashSet</code> 在对比的时候，同样的 hashcode 有多个对象，它会使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashcode</code> 只是用来缩小查找成本。</p><p>更多关于 <code>hashcode()</code> 和 <code>equals()</code> 的内容可以查看：<a href="https://www.cnblogs.com/skywang12345/p/3324958.html" target="_blank" rel="noopener">Java hashCode() 和 equals()的若干问题解答</a></p><p>上面的解释我读起来还是有点儿懵，从链接里我才真正明白了。</p><p>我们以“类的用途”来将“hashCode() 和 equals()的关系”分2种情况来说明。</p><ol><li><p>第一种 不会创建“类对应的散列表”</p><p>这里所说的“不会创建类对应的散列表”是说：我们不会在HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构中，用到该类。例如，不会创建该类的HashSet集合。</p></li></ol><p>在这种情况下，该类的“hashCode() 和 equals() ”没有半毛钱关系的！<br>这种情况下，equals() 用来比较该类的两个对象是否相等。而hashCode() 则根本没有任何作用，所以，不用理会hashCode()。</p><p>下面，我们通过示例查看类的两个对象相等 以及 不等时hashCode()的取值。</p><p>源码如下 (NormalHashCodeTest.java)：</p><details>    <summary>NormalHashCodeTest</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">import java.lang.Comparable;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @desc 比较equals() 返回true 以及 返回false时， hashCode()的值。</span><br><span class="line"> *</span><br><span class="line"> * @author skywang</span><br><span class="line"> * @emai kuiwu-wang@163.com</span><br><span class="line"> */</span><br><span class="line">public class NormalHashCodeTest&#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 新建2个相同内容的Person对象，</span><br><span class="line">        // 再用equals比较它们是否相等</span><br><span class="line">        Person p1 = new Person(&quot;eee&quot;, 100);</span><br><span class="line">        Person p2 = new Person(&quot;eee&quot;, 100);</span><br><span class="line">        Person p3 = new Person(&quot;aaa&quot;, 200);</span><br><span class="line">        System.out.printf(&quot;p1.equals(p2) : %s; p1(%d) p2(%d)\n&quot;, p1.equals(p2), p1.hashCode(), p2.hashCode());</span><br><span class="line">        System.out.printf(&quot;p1.equals(p3) : %s; p1(%d) p3(%d)\n&quot;, p1.equals(p3), p1.hashCode(), p3.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @desc Person类。</span><br><span class="line">     */</span><br><span class="line">    private static class Person &#123;</span><br><span class="line">        int age;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        public Person(String name, int age) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">            this.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            return name + &quot; - &quot; +age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * @desc 覆盖equals方法</span><br><span class="line">         */</span><br><span class="line">        public boolean equals(Object obj)&#123;</span><br><span class="line">            if(obj == null)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //如果是同一个对象返回true，反之返回false</span><br><span class="line">            if(this == obj)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //判断是否类型相同</span><br><span class="line">            if(this.getClass() != obj.getClass())&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Person person = (Person)obj;</span><br><span class="line">            return name.equals(person.name) &amp;&amp; age==person.age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>运行结果：</p><pre><code>p1.equals(p2) : true; p1(1169863946) p2(1901116749)p1.equals(p3) : false; p1(1169863946) p3(2131949076)</code></pre><p>从结果也可以看出：p1和p2相等的情况下，hashCode()也不一定相等。</p><ol start="2"><li>第二种 会创建“类对应的散列表”</li></ol><p>这里所说的“会创建类对应的散列表”是说：我们会在HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构中，用到该类。例如，会创建该类的HashSet集合。</p><p>在这种情况下，该类的“hashCode() 和 equals() ”是有关系的：</p><p>1)、如果两个对象相等，那么它们的hashCode()值一定相同。<br>      这里的相等是指，通过equals()比较两个对象时返回true。</p><p>2)、如果两个对象hashCode()相等，它们并不一定相等。<br>       因为在散列表中，hashCode()相等，即两个键值对的哈希值相等。然而哈希值相等，并不一定能得出键值对相等。补充说一句：“两个不同的键值对，哈希值相等”，这就是哈希冲突。</p><p>此外，在这种情况下。若要判断两个对象是否相等，除了要覆盖equals()之外，也要覆盖hashCode()函数。否则，equals()无效。<br>例如，创建Person类的HashSet集合，必须同时覆盖Person类的equals() 和 hashCode()方法。<br>        如果单单只是覆盖equals()方法。我们会发现，equals()方法没有达到我们想要的效果。</p><p>参考代码 (ConflictHashCodeTest1.java)：</p><details>    <summary>ConflictHashCodeTest1</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">import java.lang.Comparable;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @desc 比较equals() 返回true 以及 返回false时， hashCode()的值。</span><br><span class="line"> *</span><br><span class="line"> * @author skywang</span><br><span class="line"> * @emai kuiwu-wang@163.com</span><br><span class="line"> */</span><br><span class="line">public class ConflictHashCodeTest1&#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 新建Person对象，</span><br><span class="line">        Person p1 = new Person(&quot;eee&quot;, 100);</span><br><span class="line">        Person p2 = new Person(&quot;eee&quot;, 100);</span><br><span class="line">        Person p3 = new Person(&quot;aaa&quot;, 200);</span><br><span class="line"></span><br><span class="line">        // 新建HashSet对象</span><br><span class="line">        HashSet set = new HashSet();</span><br><span class="line">        set.add(p1);</span><br><span class="line">        set.add(p2);</span><br><span class="line">        set.add(p3);</span><br><span class="line"></span><br><span class="line">        // 比较p1 和 p2， 并打印它们的hashCode()</span><br><span class="line">        System.out.printf(&quot;p1.equals(p2) : %s; p1(%d) p2(%d)\n&quot;, p1.equals(p2), p1.hashCode(), p2.hashCode());</span><br><span class="line">        // 打印set</span><br><span class="line">        System.out.printf(&quot;set:%s\n&quot;, set);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @desc Person类。</span><br><span class="line">     */</span><br><span class="line">    private static class Person &#123;</span><br><span class="line">        int age;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        public Person(String name, int age) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">            this.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            return &quot;(&quot;+name + &quot;, &quot; +age+&quot;)&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * @desc 覆盖equals方法</span><br><span class="line">         */</span><br><span class="line">        @Override</span><br><span class="line">        public boolean equals(Object obj)&#123;</span><br><span class="line">            if(obj == null)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //如果是同一个对象返回true，反之返回false</span><br><span class="line">            if(this == obj)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //判断是否类型相同</span><br><span class="line">            if(this.getClass() != obj.getClass())&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Person person = (Person)obj;</span><br><span class="line">            return name.equals(person.name) &amp;&amp; age==person.age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>运行结果：<pre><code>p1.equals(p2) : true; p1(1169863946) p2(1690552137)set:[(eee, 100), (eee, 100), (aaa, 200)]</code></pre><p>结果分析：</p><p>我们重写了Person的equals()。但是，很奇怪的发现：HashSet中仍然有重复元素：p1 和 p2。为什么会出现这种情况呢？</p><p>这是因为虽然p1 和 p2的内容相等，但是它们的hashCode()不等；所以，HashSet在添加p1和p2的时候，认为它们不相等。</p><p>下面，我们同时覆盖equals() 和 hashCode()方法。</p><p>参考代码 (ConflictHashCodeTest2.java)：</p><details>    <summary>ConflictHashCodeTest2</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">import java.lang.Comparable;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @desc 比较equals() 返回true 以及 返回false时， hashCode()的值。</span><br><span class="line"> *</span><br><span class="line"> * @author skywang</span><br><span class="line"> * @emai kuiwu-wang@163.com</span><br><span class="line"> */</span><br><span class="line">public class ConflictHashCodeTest2&#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 新建Person对象，</span><br><span class="line">        Person p1 = new Person(&quot;eee&quot;, 100);</span><br><span class="line">        Person p2 = new Person(&quot;eee&quot;, 100);</span><br><span class="line">        Person p3 = new Person(&quot;aaa&quot;, 200);</span><br><span class="line">        Person p4 = new Person(&quot;EEE&quot;, 100);</span><br><span class="line"></span><br><span class="line">        // 新建HashSet对象</span><br><span class="line">        HashSet set = new HashSet();</span><br><span class="line">        set.add(p1);</span><br><span class="line">        set.add(p2);</span><br><span class="line">        set.add(p3);</span><br><span class="line"></span><br><span class="line">        // 比较p1 和 p2， 并打印它们的hashCode()</span><br><span class="line">        System.out.printf(&quot;p1.equals(p2) : %s; p1(%d) p2(%d)\n&quot;, p1.equals(p2), p1.hashCode(), p2.hashCode());</span><br><span class="line">        // 比较p1 和 p4， 并打印它们的hashCode()</span><br><span class="line">        System.out.printf(&quot;p1.equals(p4) : %s; p1(%d) p4(%d)\n&quot;, p1.equals(p4), p1.hashCode(), p4.hashCode());</span><br><span class="line">        // 打印set</span><br><span class="line">        System.out.printf(&quot;set:%s\n&quot;, set);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @desc Person类。</span><br><span class="line">     */</span><br><span class="line">    private static class Person &#123;</span><br><span class="line">        int age;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        public Person(String name, int age) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">            this.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            return name + &quot; - &quot; +age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * @desc重写hashCode</span><br><span class="line">         */</span><br><span class="line">        @Override</span><br><span class="line">        public int hashCode()&#123;</span><br><span class="line">            int nameHash =  name.toUpperCase().hashCode();</span><br><span class="line">            return nameHash ^ age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * @desc 覆盖equals方法</span><br><span class="line">         */</span><br><span class="line">        @Override</span><br><span class="line">        public boolean equals(Object obj)&#123;</span><br><span class="line">            if(obj == null)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //如果是同一个对象返回true，反之返回false</span><br><span class="line">            if(this == obj)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //判断是否类型相同</span><br><span class="line">            if(this.getClass() != obj.getClass())&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Person person = (Person)obj;</span><br><span class="line">            return name.equals(person.name) &amp;&amp; age==person.age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>运行结果：</p><pre><code>p1.equals(p2) : true; p1(68545) p2(68545)p1.equals(p4) : false; p1(68545) p4(68545)set:[aaa - 200, eee - 100]</code></pre><p>结果分析：</p><p>这下，equals()生效了，HashSet中没有重复元素。<br>比较p1和p2，我们发现：它们的hashCode()相等，通过equals()比较它们也返回true。所以，p1和p2被视为相等。<br>比较p1和p4，我们发现：虽然它们的hashCode()相等；但是，通过equals()比较它们返回false。所以，p1和p4被视为不相等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重写 &lt;code&gt;equals&lt;/code&gt; 时为何必须重写 &lt;code&gt;hashCode&lt;/code&gt; 方法&lt;/p&gt;
    
    </summary>
    
      <category term="2021年2月" scheme="http://yoursite.com/categories/2021%E5%B9%B42%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>77. 组合</title>
    <link href="http://yoursite.com/2021/02/03/77.%20%E7%BB%84%E5%90%88/"/>
    <id>http://yoursite.com/2021/02/03/77. 组合/</id>
    <published>2021-02-03T02:12:12.000Z</published>
    <updated>2021-02-19T08:30:24.077Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p><a id="more"></a><p>示例:</p><pre><code>输入: n = 4, k = 2输出:[  [2,4],  [3,4],  [2,3],  [1,2],  [1,3],  [1,4],]</code></pre><h1 id="方法一：递归实现组合型枚举"><a href="#方法一：递归实现组合型枚举" class="headerlink" title="方法一：递归实现组合型枚举"></a>方法一：递归实现组合型枚举</h1><p><strong>思路与算法</strong></p><p>从 <em>n</em> 个当中选 <em>k</em> 个的所有方案对应的枚举是组合型枚举。在「方法一」中我们用递归来实现组合型枚举。</p><p>首先我们先回忆一下如何用递归实现二进制枚举（子集枚举），假设我们需要找到一个长度为 <em>n</em> 的序列 <em>a</em> 的所有子序列，代码框架是这样的：</p><details>    <summary>二进制枚举</summary><figure class="highlight cpp"><figcaption><span>[demo1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == n + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 记录答案</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 考虑选择当前位置</span></span><br><span class="line">    temp.push_back(cur);</span><br><span class="line">    dfs(cur + <span class="number">1</span>, n, k);</span><br><span class="line">    temp.pop_back();</span><br><span class="line">    <span class="comment">// 考虑不选择当前位置</span></span><br><span class="line">    dfs(cur + <span class="number">1</span>, n, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>见<a href="https://leetcode-cn.com/problems/combinations/solution/zu-he-by-leetcode-solution/" target="_blank" rel="noopener">^1</a></p><details>    <summary>二进制枚举</summary><figure class="highlight cpp"><figcaption><span>[demo2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录合法的答案</span></span><br><span class="line">    <span class="keyword">if</span> (temp.size() == k) &#123;</span><br><span class="line">        ans.push_back(temp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cur == n + 1 的时候结束递归</span></span><br><span class="line">    <span class="keyword">if</span> (cur == n + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 考虑选择当前位置</span></span><br><span class="line">    temp.push_back(cur);</span><br><span class="line">    dfs(cur + <span class="number">1</span>, n, k);</span><br><span class="line">    temp.pop_back();</span><br><span class="line">    <span class="comment">// 考虑不选择当前位置</span></span><br><span class="line">    dfs(cur + <span class="number">1</span>, n, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>这个时候我们可以做一个剪枝，如果当前 temp 的大小为 <em>s</em>，未确定状态的区间cur的长度为 <em>t</em>，如果 <em>s + t &lt; k*，那么即使 *t</em> 个都被选中，也不可能构造出一个长度为 <em>k</em> 的序列，故这种情况就没有必要继续向下递归，即我们可以在每次递归开始的时候做一次这样的判断：</p><figure class="highlight cpp"><figcaption><span>[demo3-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (temp.size() + (n - cur + <span class="number">1</span>) &lt; k) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码就变成了这样：</p><details>    <summary>二进制枚举</summary><figure class="highlight cpp"><figcaption><span>[demo4-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 剪枝：temp 长度加上区间 [cur, n] 的长度小于 k，不可能构造出长度为 k 的 temp</span></span><br><span class="line">    <span class="keyword">if</span> (temp.size() + (n - cur + <span class="number">1</span>) &lt; k) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录合法的答案</span></span><br><span class="line">    <span class="keyword">if</span> (temp.size() == k) &#123;</span><br><span class="line">        ans.push_back(temp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cur == n + 1 的时候结束递归</span></span><br><span class="line">    <span class="keyword">if</span> (cur == n + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 考虑选择当前位置</span></span><br><span class="line">    temp.push_back(cur);</span><br><span class="line">    dfs(cur + <span class="number">1</span>, n, k);</span><br><span class="line">    temp.pop_back();</span><br><span class="line">    <span class="comment">// 考虑不选择当前位置</span></span><br><span class="line">    dfs(cur + <span class="number">1</span>, n, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>剪枝方法见<a href="https://leetcode-cn.com/problems/combinations/solution/zu-he-by-leetcode-solution/" target="_blank" rel="noopener">^1</a></p><p><strong>代码</strong></p><details>    <summary>二进制枚举C++</summary><figure class="highlight cpp"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 剪枝：temp 长度加上区间 [cur, n] 的长度小于 k，不可能构造出长度为 k 的 temp</span></span><br><span class="line">        <span class="keyword">if</span> (temp.size() + (n - cur + <span class="number">1</span>) &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录合法的答案</span></span><br><span class="line">        <span class="keyword">if</span> (temp.size() == k) &#123;</span><br><span class="line">            ans.push_back(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑选择当前位置</span></span><br><span class="line">        temp.push_back(cur);</span><br><span class="line">        dfs(cur + <span class="number">1</span>, n, k);</span><br><span class="line">        temp.pop_back();</span><br><span class="line">        <span class="comment">// 考虑不选择当前位置</span></span><br><span class="line">        dfs(cur + <span class="number">1</span>, n, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        dfs(<span class="number">1</span>, n, k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>二进制枚举Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        dfs(<span class="number">1</span>, n, k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 剪枝：temp 长度加上区间 [cur, n] 的长度小于 k，不可能构造出长度为 k 的 temp</span></span><br><span class="line">        <span class="keyword">if</span> (temp.size() + (n - cur + <span class="number">1</span>) &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录合法的答案</span></span><br><span class="line">        <span class="keyword">if</span> (temp.size() == k) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(temp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑选择当前位置</span></span><br><span class="line">        temp.add(cur);</span><br><span class="line">        dfs(cur + <span class="number">1</span>, n, k);</span><br><span class="line">        temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 考虑不选择当前位置</span></span><br><span class="line">        dfs(cur + <span class="number">1</span>, n, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>二进制枚举JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> combine = <span class="function"><span class="keyword">function</span>(<span class="params">n, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ans = [];</span><br><span class="line">    <span class="keyword">const</span> dfs = <span class="function">(<span class="params">cur, n, k, temp</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 剪枝：temp 长度加上区间 [cur, n] 的长度小于 k，不可能构造出长度为 k 的 temp</span></span><br><span class="line">        <span class="keyword">if</span> (temp.length + (n - cur + <span class="number">1</span>) &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录合法的答案</span></span><br><span class="line">        <span class="keyword">if</span> (temp.length == k) &#123;</span><br><span class="line">            ans.push(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑选择当前位置</span></span><br><span class="line">        dfs(cur + <span class="number">1</span>, n, k, [...temp, cur]);</span><br><span class="line">        <span class="comment">// 考虑不选择当前位置</span></span><br><span class="line">        dfs(cur + <span class="number">1</span>, n, k, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, n, k, []);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>二进制枚举Golang</summary><figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(n <span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="params">(ans [][]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">temp := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">dfs</span> = <span class="title">func</span><span class="params">(cur <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 剪枝：temp 长度加上区间 [cur, n] 的长度小于 k，不可能构造出长度为 k 的 temp</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(temp) + (n - cur + <span class="number">1</span>) &lt; k &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 记录合法的答案</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(temp) == k &#123;</span><br><span class="line">comb := <span class="built_in">make</span>([]<span class="keyword">int</span>, k)</span><br><span class="line"><span class="built_in">copy</span>(comb, temp)</span><br><span class="line">ans = <span class="built_in">append</span>(ans, comb)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 考虑选择当前位置</span></span><br><span class="line">temp = <span class="built_in">append</span>(temp, cur)</span><br><span class="line">dfs(cur + <span class="number">1</span>)</span><br><span class="line">temp = temp[:<span class="built_in">len</span>(temp)<span class="number">-1</span>]</span><br><span class="line"><span class="comment">// 考虑不选择当前位置</span></span><br><span class="line">dfs(cur + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>二进制枚举C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* temp;</span><br><span class="line"><span class="keyword">int</span> tempSize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>** ans;</span><br><span class="line"><span class="keyword">int</span> ansSize;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 剪枝：temp 长度加上区间 [cur, n] 的长度小于 k，不可能构造出长度为 k 的 temp</span></span><br><span class="line">    <span class="keyword">if</span> (tempSize + (n - cur + <span class="number">1</span>) &lt; k) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录合法的答案</span></span><br><span class="line">    <span class="keyword">if</span> (tempSize == k) &#123;</span><br><span class="line">        <span class="keyword">int</span>* tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            tmp[i] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        ans[ansSize++] = tmp;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 考虑选择当前位置</span></span><br><span class="line">    temp[tempSize++] = cur;</span><br><span class="line">    dfs(cur + <span class="number">1</span>, n, k);</span><br><span class="line">    tempSize--;</span><br><span class="line">    <span class="comment">// 考虑不选择当前位置</span></span><br><span class="line">    dfs(cur + <span class="number">1</span>, n, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>** <span class="title">combine</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span>* returnSize, <span class="keyword">int</span>** returnColumnSizes)</span> </span>&#123;</span><br><span class="line">    temp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * k);</span><br><span class="line">    ans = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*) * <span class="number">10001</span>);</span><br><span class="line">    tempSize = ansSize = <span class="number">0</span>;</span><br><span class="line">    dfs(<span class="number">1</span>, n, k);</span><br><span class="line">    *returnSize = ansSize;</span><br><span class="line">    *returnColumnSizes = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * ansSize);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ansSize; i++) &#123;</span><br><span class="line">        (*returnColumnSizes)[i] = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><p>见<a href="https://leetcode-cn.com/problems/combinations/solution/zu-he-by-leetcode-solution/" target="_blank" rel="noopener">^1</a></p><h1 id="方法二：非递归（字典序法）实现组合型枚举"><a href="#方法二：非递归（字典序法）实现组合型枚举" class="headerlink" title="方法二：非递归（字典序法）实现组合型枚举"></a>方法二：非递归（字典序法）实现组合型枚举</h1><p><strong>思路与算法</strong></p><p><strong>小贴士：这个方法理解起来比「方法一」复杂，建议读者遇到不理解的地方可以在草稿纸上举例模拟这个过程。</strong></p><p>这里的非递归版不是简单的用栈模拟递归转化为非递归：我们希望通过合适的手段，消除递归栈带来的额外空间代价。</p><p>假设我们把原序列中被选中的位置记为 <em>1</em>，不被选中的位置记为 <em>0</em>，对于每个方案都可以构造出一个二进制数。我们让原序列从大到小排列。我们先看一看 <em>n = 4<em>，</em>k = 2</em> 的例子：</p><table><thead><tr><th>原序列中被选中的数</th><th>对应的二进制数</th><th>方案</th></tr></thead><tbody><tr><td><em>43[2][1]</em></td><td><em>0011</em></td><td><em>2, 1</em></td></tr><tr><td><em>4[3]2[1]</em></td><td><em>0101</em></td><td><em>3, 1</em></td></tr><tr><td><em>4[3][2]1</em></td><td><em>0110</em></td><td><em>3, 2</em></td></tr><tr><td><em>[4]32[1]</em></td><td><em>1001</em></td><td><em>4, 1</em></td></tr><tr><td><em>[4]3[2]1</em></td><td><em>1010</em></td><td><em>4, 2</em></td></tr><tr><td><em>[4][3]21</em></td><td><em>1100</em></td><td><em>4, 3</em></td></tr></tbody></table><p>我们可以看出「对应的二进制数」一列包含了由 <em>k</em> 个 <em>1</em> 和 <em>n - k</em> 个 <em>0</em> 组成的所有二进制数，并且按照字典序排列。这给了我们一些启发，我们可以通过某种方法枚举，使得生成的序列是根据字典序递增的。我们可以考虑我们一个二进制数数字 <em>x</em>，它由 <em>k</em> 个 <em>1</em> 和 <em>n - k</em> 个 <em>0</em> 组成，见<a href="https://leetcode-cn.com/problems/combinations/solution/zu-he-by-leetcode-solution/" target="_blank" rel="noopener">^1</a></p><p><strong>代码</strong></p><details>    <summary>非递归（字典序法）实现组合型枚举C++</summary><figure class="highlight cpp"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="comment">// 将 temp 中 [0, k - 1] 每个位置 i 设置为 i + 1，即 [0, k - 1] 存 [1, k]</span></span><br><span class="line">        <span class="comment">// 末尾加一位 n + 1 作为哨兵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">            temp.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        temp.push_back(n + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">            ans.emplace_back(temp.begin(), temp.begin() + k);</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 寻找第一个 temp[j] + 1 != temp[j + 1] 的位置 t</span></span><br><span class="line">            <span class="comment">// 我们需要把 [0, t - 1] 区间内的每个位置重置成 [1, t]</span></span><br><span class="line">            <span class="keyword">while</span> (j &lt; k &amp;&amp; temp[j] + <span class="number">1</span> == temp[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                temp[j] = j + <span class="number">1</span>;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// j 是第一个 temp[j] + 1 != temp[j + 1] 的位置</span></span><br><span class="line">            ++temp[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>非递归（字典序法）实现组合型枚举Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="comment">// 将 temp 中 [0, k - 1] 每个位置 i 设置为 i + 1，即 [0, k - 1] 存 [1, k]</span></span><br><span class="line">        <span class="comment">// 末尾加一位 n + 1 作为哨兵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">            temp.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        temp.add(n + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(temp.subList(<span class="number">0</span>, k)));</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 寻找第一个 temp[j] + 1 != temp[j + 1] 的位置 t</span></span><br><span class="line">            <span class="comment">// 我们需要把 [0, t - 1] 区间内的每个位置重置成 [1, t]</span></span><br><span class="line">            <span class="keyword">while</span> (j &lt; k &amp;&amp; temp.get(j) + <span class="number">1</span> == temp.get(j + <span class="number">1</span>)) &#123;</span><br><span class="line">                temp.set(j, j + <span class="number">1</span>);</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// j 是第一个 temp[j] + 1 != temp[j + 1] 的位置</span></span><br><span class="line">            temp.set(j, temp.get(j) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>非递归（字典序法）实现组合型枚举JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol2-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> combine = <span class="function"><span class="keyword">function</span>(<span class="params">n, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> temp = [];</span><br><span class="line">    <span class="keyword">const</span> ans = [];</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="comment">// 将 temp 中 [0, k - 1] 每个位置 i 设置为 i + 1，即 [0, k - 1] 存 [1, k]</span></span><br><span class="line">    <span class="comment">// 末尾加一位 n + 1 作为哨兵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">        temp.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    temp.push(n + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">        ans.push(temp.slice(<span class="number">0</span>, k));</span><br><span class="line">        j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 寻找第一个 temp[j] + 1 != temp[j + 1] 的位置 t</span></span><br><span class="line">        <span class="comment">// 我们需要把 [0, t - 1] 区间内的每个位置重置成 [1, t]</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt; k &amp;&amp; temp[j] + <span class="number">1</span> == temp[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            temp[j] = j + <span class="number">1</span>;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// j 是第一个 temp[j] + 1 != temp[j + 1] 的位置</span></span><br><span class="line">        ++temp[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>非递归（字典序法）实现组合型枚举Golang</summary><figure class="highlight go"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(n <span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="params">(ans [][]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="comment">// 将 temp 中 [0, k - 1] 每个位置 i 设置为 i + 1，即 [0, k - 1] 存 [1, k]</span></span><br><span class="line"><span class="comment">// 末尾加一位 n + 1 作为哨兵</span></span><br><span class="line">temp := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= k; i++ &#123;</span><br><span class="line">temp = <span class="built_in">append</span>(temp, i)</span><br><span class="line">&#125;</span><br><span class="line">temp = <span class="built_in">append</span>(temp, n+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; k; &#123;</span><br><span class="line">comb := <span class="built_in">make</span>([]<span class="keyword">int</span>, k)</span><br><span class="line"><span class="built_in">copy</span>(comb, temp[:k])</span><br><span class="line">ans = <span class="built_in">append</span>(ans, comb)</span><br><span class="line"><span class="comment">// 寻找第一个 temp[j] + 1 != temp[j + 1] 的位置 t</span></span><br><span class="line"><span class="comment">// 我们需要把 [0, t - 1] 区间内的每个位置重置成 [1, t]</span></span><br><span class="line"><span class="keyword">for</span> j = <span class="number">0</span>; j &lt; k &amp;&amp; temp[j]+<span class="number">1</span> == temp[j+<span class="number">1</span>]; j++ &#123;</span><br><span class="line">temp[j] = j + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// j 是第一个 temp[j] + 1 != temp[j + 1] 的位置</span></span><br><span class="line">temp[j]++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>非递归（字典序法）实现组合型枚举C</summary><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>** <span class="title">combine</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span>* returnSize, <span class="keyword">int</span>** returnColumnSizes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* temp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (k + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">int</span> tempSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>** ans = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*) * <span class="number">10001</span>);</span><br><span class="line">    <span class="keyword">int</span> ansSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="comment">// 将 temp 中 [0, k - 1] 每个位置 i 设置为 i + 1，即 [0, k - 1] 存 [1, k]</span></span><br><span class="line">    <span class="comment">// 末尾加一位 n + 1 作为哨兵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">        temp[i - <span class="number">1</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    temp[k] = n + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">        <span class="keyword">int</span>* tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            tmp[i] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        ans[ansSize++] = tmp;</span><br><span class="line">        j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 寻找第一个 temp[j] + 1 != temp[j + 1] 的位置 t</span></span><br><span class="line">        <span class="comment">// 我们需要把 [0, t - 1] 区间内的每个位置重置成 [1, t]</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt; k &amp;&amp; temp[j] + <span class="number">1</span> == temp[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            temp[j] = j + <span class="number">1</span>;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// j 是第一个 temp[j] + 1 != temp[j + 1] 的位置</span></span><br><span class="line">        ++temp[j];</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = ansSize;</span><br><span class="line">    *returnColumnSizes = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * ansSize);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ansSize; i++) &#123;</span><br><span class="line">        (*returnColumnSizes)[i] = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><p>见<a href="https://leetcode-cn.com/problems/combinations/solution/zu-he-by-leetcode-solution/" target="_blank" rel="noopener">^1</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年2月" scheme="http://yoursite.com/categories/2021%E5%B9%B42%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>57. 插入区间</title>
    <link href="http://yoursite.com/2021/02/02/57.%20%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/"/>
    <id>http://yoursite.com/2021/02/02/57. 插入区间/</id>
    <published>2021-02-02T09:12:12.000Z</published>
    <updated>2021-02-03T01:37:17.352Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个 无重叠的 ，按照区间起始端点排序的区间列表。</p><p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p><a id="more"></a><p>示例 1：</p><pre><code>输入：intervals = [[1,3],[6,9]], newInterval = [2,5]输出：[[1,5],[6,9]]</code></pre><p>示例 2：</p><pre><code>输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]输出：[[1,2],[3,10],[12,16]]解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。</code></pre><p>示例 3：</p><pre><code>输入：intervals = [], newInterval = [5,7]输出：[[5,7]]</code></pre><p>示例 4：</p><pre><code>输入：intervals = [[1,5]], newInterval = [2,3]输出：[[1,5]]</code></pre><p>示例 5：</p><pre><code>输入：intervals = [[1,5]], newInterval = [2,7]输出：[[1,7]]</code></pre><p>提示：</p><pre><code>0 &lt;= intervals.length &lt;= 104intervals[i].length == 20 &lt;= intervals[i][0] &lt;= intervals[i][1] &lt;= 105intervals 根据 intervals[i][0] 按 升序 排列newInterval.length == 20 &lt;= newInterval[0] &lt;= newInterval[1] &lt;= 105</code></pre><h1 id="方法一：模拟"><a href="#方法一：模拟" class="headerlink" title="方法一：模拟"></a>方法一：模拟</h1><p><strong>思路与算法</strong></p><p>见<a href="https://leetcode-cn.com/problems/insert-interval/solution/cha-ru-qu-jian-by-leetcode-solution/" target="_blank" rel="noopener">^1</a></p><p><strong>代码</strong></p><details>    <summary>模拟C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; insert(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; newInterval) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = newInterval[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> right = newInterval[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">bool</span> placed = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; interval: intervals) &#123;</span><br><span class="line">            <span class="keyword">if</span> (interval[<span class="number">0</span>] &gt; right) &#123;</span><br><span class="line">                <span class="comment">// 在插入区间的右侧且无交集</span></span><br><span class="line">                <span class="keyword">if</span> (!placed) &#123;</span><br><span class="line">                    ans.push_back(&#123;left, right&#125;);</span><br><span class="line">                    placed = <span class="literal">true</span>;                    </span><br><span class="line">                &#125;</span><br><span class="line">                ans.push_back(interval);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (interval[<span class="number">1</span>] &lt; left) &#123;</span><br><span class="line">                <span class="comment">// 在插入区间的左侧且无交集</span></span><br><span class="line">                ans.push_back(interval);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 与插入区间有交集，计算它们的并集</span></span><br><span class="line">                left = min(left, interval[<span class="number">0</span>]);</span><br><span class="line">                right = max(right, interval[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!placed) &#123;</span><br><span class="line">            ans.push_back(&#123;left, right&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>模拟Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] insert(<span class="keyword">int</span>[][] intervals, <span class="keyword">int</span>[] newInterval) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = newInterval[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> right = newInterval[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">boolean</span> placed = <span class="keyword">false</span>;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; ansList = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] interval : intervals) &#123;</span><br><span class="line">            <span class="keyword">if</span> (interval[<span class="number">0</span>] &gt; right) &#123;</span><br><span class="line">                <span class="comment">// 在插入区间的右侧且无交集</span></span><br><span class="line">                <span class="keyword">if</span> (!placed) &#123;</span><br><span class="line">                    ansList.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left, right&#125;);</span><br><span class="line">                    placed = <span class="keyword">true</span>;                    </span><br><span class="line">                &#125;</span><br><span class="line">                ansList.add(interval);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (interval[<span class="number">1</span>] &lt; left) &#123;</span><br><span class="line">                <span class="comment">// 在插入区间的左侧且无交集</span></span><br><span class="line">                ansList.add(interval);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 与插入区间有交集，计算它们的并集</span></span><br><span class="line">                left = Math.min(left, interval[<span class="number">0</span>]);</span><br><span class="line">                right = Math.max(right, interval[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!placed) &#123;</span><br><span class="line">            ansList.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left, right&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[ansList.size()][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ansList.size(); ++i) &#123;</span><br><span class="line">            ans[i] = ansList.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>模拟Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, intervals: List[List[int]], newInterval: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        left, right = newInterval</span><br><span class="line">        placed = <span class="keyword">False</span></span><br><span class="line">        ans = list()</span><br><span class="line">        <span class="keyword">for</span> li, ri <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="keyword">if</span> li &gt; right:</span><br><span class="line">                <span class="comment"># 在插入区间的右侧且无交集</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> placed:</span><br><span class="line">                    ans.append([left, right])</span><br><span class="line">                    placed = <span class="keyword">True</span></span><br><span class="line">                ans.append([li, ri])</span><br><span class="line">            <span class="keyword">elif</span> ri &lt; left:</span><br><span class="line">                <span class="comment"># 在插入区间的左侧且无交集</span></span><br><span class="line">                ans.append([li, ri])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 与插入区间有交集，计算它们的并集</span></span><br><span class="line">                left = min(left, li)</span><br><span class="line">                right = max(right, ri)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> placed:</span><br><span class="line">            ans.append([left, right])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>模拟Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(intervals [][]<span class="keyword">int</span>, newInterval []<span class="keyword">int</span>)</span> <span class="params">(ans [][]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    left, right := newInterval[<span class="number">0</span>], newInterval[<span class="number">1</span>]</span><br><span class="line">    merged := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> _, interval := <span class="keyword">range</span> intervals &#123;</span><br><span class="line">        <span class="keyword">if</span> interval[<span class="number">0</span>] &gt; right &#123;</span><br><span class="line">            <span class="comment">// 在插入区间的右侧且无交集</span></span><br><span class="line">            <span class="keyword">if</span> !merged &#123;</span><br><span class="line">                ans = <span class="built_in">append</span>(ans, []<span class="keyword">int</span>&#123;left, right&#125;)</span><br><span class="line">                merged = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, interval)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> interval[<span class="number">1</span>] &lt; left &#123;</span><br><span class="line">            <span class="comment">// 在插入区间的左侧且无交集</span></span><br><span class="line">            ans = <span class="built_in">append</span>(ans, interval)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 与插入区间有交集，计算它们的并集</span></span><br><span class="line">            left = min(left, interval[<span class="number">0</span>])</span><br><span class="line">            right = max(right, interval[<span class="number">1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !merged &#123;</span><br><span class="line">        ans = <span class="built_in">append</span>(ans, []<span class="keyword">int</span>&#123;left, right&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>模拟C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>** <span class="title">insert</span><span class="params">(<span class="keyword">int</span>** intervals, <span class="keyword">int</span> intervalsSize, <span class="keyword">int</span>* intervalsColSize, <span class="keyword">int</span>* newInterval, <span class="keyword">int</span> newIntervalSize, <span class="keyword">int</span>* returnSize, <span class="keyword">int</span>** returnColumnSizes)</span> </span>&#123;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = newInterval[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> right = newInterval[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">bool</span> placed = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span>** ans = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*) * (intervalsSize + <span class="number">1</span>));</span><br><span class="line">    *returnColumnSizes = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*) * (intervalsSize + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervalsSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span>* interval = intervals[i];</span><br><span class="line">        <span class="keyword">if</span> (interval[<span class="number">0</span>] &gt; right) &#123;</span><br><span class="line">            <span class="comment">// 在插入区间的右侧且无交集</span></span><br><span class="line">            <span class="keyword">if</span> (!placed) &#123;</span><br><span class="line">                <span class="keyword">int</span>* tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">2</span>);</span><br><span class="line">                tmp[<span class="number">0</span>] = left, tmp[<span class="number">1</span>] = right;</span><br><span class="line">                (*returnColumnSizes)[*returnSize] = <span class="number">2</span>;</span><br><span class="line">                ans[(*returnSize)++] = tmp;</span><br><span class="line">                placed = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span>* tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">2</span>);</span><br><span class="line">            <span class="built_in">memcpy</span>(tmp, interval, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">2</span>);</span><br><span class="line">            (*returnColumnSizes)[*returnSize] = <span class="number">2</span>;</span><br><span class="line">            ans[(*returnSize)++] = tmp;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (interval[<span class="number">1</span>] &lt; left) &#123;</span><br><span class="line">            <span class="comment">// 在插入区间的左侧且无交集</span></span><br><span class="line">            <span class="keyword">int</span>* tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">2</span>);</span><br><span class="line">            <span class="built_in">memcpy</span>(tmp, interval, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">2</span>);</span><br><span class="line">            (*returnColumnSizes)[*returnSize] = <span class="number">2</span>;</span><br><span class="line">            ans[(*returnSize)++] = tmp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 与插入区间有交集，计算它们的并集</span></span><br><span class="line">            left = fmin(left, interval[<span class="number">0</span>]);</span><br><span class="line">            right = fmax(right, interval[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!placed) &#123;</span><br><span class="line">        <span class="keyword">int</span>* tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">2</span>);</span><br><span class="line">        tmp[<span class="number">0</span>] = left, tmp[<span class="number">1</span>] = right;</span><br><span class="line">        (*returnColumnSizes)[*returnSize] = <span class="number">2</span>;</span><br><span class="line">        ans[(*returnSize)++] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)*，其中 *n</em> 是数组 intervals 的长度，即给定的区间个数。</p></li><li><p>空间复杂度：<em>O(1)</em>。除了存储返回答案的空间以外，我们只需要额外的常数空间即可。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你一个 无重叠的 ，按照区间起始端点排序的区间列表。&lt;/p&gt;
&lt;p&gt;在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年2月" scheme="http://yoursite.com/categories/2021%E5%B9%B42%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Sort" scheme="http://yoursite.com/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>17. 电话号码的字母组合</title>
    <link href="http://yoursite.com/2021/02/02/17.%20%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
    <id>http://yoursite.com/2021/02/02/17. 电话号码的字母组合/</id>
    <published>2021-02-02T07:12:12.000Z</published>
    <updated>2021-02-02T08:10:39.889Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><a id="more"></a><p>示例 1：</p><pre><code>输入：digits = &quot;23&quot;输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</code></pre><p>示例 2：</p><pre><code>输入：digits = &quot;&quot;输出：[]</code></pre><p>示例 3：</p><pre><code>输入：digits = &quot;2&quot;输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</code></pre><p>提示：</p><pre><code>0 &lt;= digits.length &lt;= 4digits[i] 是范围 [&apos;2&apos;, &apos;9&apos;] 的一个数字。</code></pre><h1 id="方法一：回溯"><a href="#方法一：回溯" class="headerlink" title="方法一：回溯"></a>方法一：回溯</h1><p>首先使用哈希表存储每个数字对应的所有可能的字母，然后进行回溯操作。</p><p>回溯过程中维护一个字符串，表示已有的字母排列（如果未遍历完电话号码的所有数字，则已有的字母排列是不完整的）。该字符串初始为空。每次取电话号码的一位数字，从哈希表中获得该数字对应的所有可能的字母，并将其中的一个字母插入到已有的字母排列后面，然后继续处理电话号码的后一位数字，直到处理完电话号码中的所有数字，即得到一个完整的字母排列。然后进行回退操作，遍历其余的字母排列。</p><p>回溯算法用于寻找所有的可行解，如果发现一个解不可行，则会舍弃不可行的解。在这道题中，由于每个数字对应的每个字母都可能进入字母组合，因此不存在不可行的解，直接穷举所有的解即可。</p><details>    <summary>回溯Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; combinations = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">if</span> (digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> combinations;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character, String&gt; phoneMap = <span class="keyword">new</span> HashMap&lt;Character, String&gt;() &#123;&#123;</span><br><span class="line">            put(<span class="string">'2'</span>, <span class="string">"abc"</span>);</span><br><span class="line">            put(<span class="string">'3'</span>, <span class="string">"def"</span>);</span><br><span class="line">            put(<span class="string">'4'</span>, <span class="string">"ghi"</span>);</span><br><span class="line">            put(<span class="string">'5'</span>, <span class="string">"jkl"</span>);</span><br><span class="line">            put(<span class="string">'6'</span>, <span class="string">"mno"</span>);</span><br><span class="line">            put(<span class="string">'7'</span>, <span class="string">"pqrs"</span>);</span><br><span class="line">            put(<span class="string">'8'</span>, <span class="string">"tuv"</span>);</span><br><span class="line">            put(<span class="string">'9'</span>, <span class="string">"wxyz"</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        backtrack(combinations, phoneMap, digits, <span class="number">0</span>, <span class="keyword">new</span> StringBuffer());</span><br><span class="line">        <span class="keyword">return</span> combinations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;String&gt; combinations, Map&lt;Character, String&gt; phoneMap, String digits, <span class="keyword">int</span> index, StringBuffer combination)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == digits.length()) &#123;</span><br><span class="line">            combinations.add(combination.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">char</span> digit = digits.charAt(index);</span><br><span class="line">            String letters = phoneMap.get(digit);</span><br><span class="line">            <span class="keyword">int</span> lettersCount = letters.length();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lettersCount; i++) &#123;</span><br><span class="line">                combination.append(letters.charAt(i));</span><br><span class="line">                backtrack(combinations, phoneMap, digits, index + <span class="number">1</span>, combination);</span><br><span class="line">                combination.deleteCharAt(index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>回溯C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; combinations;</span><br><span class="line">        <span class="keyword">if</span> (digits.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> combinations;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; phoneMap&#123;</span><br><span class="line">            &#123;<span class="string">'2'</span>, <span class="string">"abc"</span>&#125;,</span><br><span class="line">            &#123;<span class="string">'3'</span>, <span class="string">"def"</span>&#125;,</span><br><span class="line">            &#123;<span class="string">'4'</span>, <span class="string">"ghi"</span>&#125;,</span><br><span class="line">            &#123;<span class="string">'5'</span>, <span class="string">"jkl"</span>&#125;,</span><br><span class="line">            &#123;<span class="string">'6'</span>, <span class="string">"mno"</span>&#125;,</span><br><span class="line">            &#123;<span class="string">'7'</span>, <span class="string">"pqrs"</span>&#125;,</span><br><span class="line">            &#123;<span class="string">'8'</span>, <span class="string">"tuv"</span>&#125;,</span><br><span class="line">            &#123;<span class="string">'9'</span>, <span class="string">"wxyz"</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">string</span> combination;</span><br><span class="line">        backtrack(combinations, phoneMap, digits, <span class="number">0</span>, combination);</span><br><span class="line">        <span class="keyword">return</span> combinations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; combinations, <span class="keyword">const</span> <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt;&amp; phoneMap, <span class="keyword">const</span> <span class="built_in">string</span>&amp; digits, <span class="keyword">int</span> index, <span class="built_in">string</span>&amp; combination)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == digits.length()) &#123;</span><br><span class="line">            combinations.push_back(combination);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">char</span> digit = digits[index];</span><br><span class="line">            <span class="keyword">const</span> <span class="built_in">string</span>&amp; letters = phoneMap.at(digit);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span>&amp; letter: letters) &#123;</span><br><span class="line">                combination.push_back(letter);</span><br><span class="line">                backtrack(combinations, phoneMap, digits, index + <span class="number">1</span>, combination);</span><br><span class="line">                combination.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>回溯Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> phoneMap <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">"2"</span>: <span class="string">"abc"</span>,</span><br><span class="line">    <span class="string">"3"</span>: <span class="string">"def"</span>,</span><br><span class="line">    <span class="string">"4"</span>: <span class="string">"ghi"</span>,</span><br><span class="line">    <span class="string">"5"</span>: <span class="string">"jkl"</span>,</span><br><span class="line">    <span class="string">"6"</span>: <span class="string">"mno"</span>,</span><br><span class="line">    <span class="string">"7"</span>: <span class="string">"pqrs"</span>,</span><br><span class="line">    <span class="string">"8"</span>: <span class="string">"tuv"</span>,</span><br><span class="line">    <span class="string">"9"</span>: <span class="string">"wxyz"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> combinations []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">letterCombinations</span><span class="params">(digits <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(digits) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    combinations = []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    backtrack(digits, <span class="number">0</span>, <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">return</span> combinations</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backtrack</span><span class="params">(digits <span class="keyword">string</span>, index <span class="keyword">int</span>, combination <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> index == <span class="built_in">len</span>(digits) &#123;</span><br><span class="line">        combinations = <span class="built_in">append</span>(combinations, combination)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        digit := <span class="keyword">string</span>(digits[index])</span><br><span class="line">        letters := phoneMap[digit]</span><br><span class="line">        lettersCount := <span class="built_in">len</span>(letters)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; lettersCount; i++ &#123;</span><br><span class="line">            backtrack(digits, index + <span class="number">1</span>, combination + <span class="keyword">string</span>(letters[i]))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>回溯C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> phoneMap[<span class="number">11</span>][<span class="number">5</span>] = &#123;<span class="string">"\0"</span>, <span class="string">"\0"</span>, <span class="string">"abc\0"</span>, <span class="string">"def\0"</span>, <span class="string">"ghi\0"</span>, <span class="string">"jkl\0"</span>, <span class="string">"mno\0"</span>, <span class="string">"pqrs\0"</span>, <span class="string">"tuv\0"</span>, <span class="string">"wxyz\0"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* digits_tmp;</span><br><span class="line"><span class="keyword">int</span> digits_size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>** combinations;</span><br><span class="line"><span class="keyword">int</span> combinations_size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* combination;</span><br><span class="line"><span class="keyword">int</span> combination_size;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == digits_size) &#123;</span><br><span class="line">        <span class="keyword">char</span>* tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * (combination_size + <span class="number">1</span>));</span><br><span class="line">        <span class="built_in">memcpy</span>(tmp, combination, <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * (combination_size + <span class="number">1</span>));</span><br><span class="line">        combinations[combinations_size++] = tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">char</span> digit = digits_tmp[index];</span><br><span class="line">        <span class="keyword">char</span>* letters = phoneMap[digit - <span class="string">'0'</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(letters);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            combination[combination_size++] = letters[i];</span><br><span class="line">            combination[combination_size] = <span class="number">0</span>;</span><br><span class="line">            backtrack(index + <span class="number">1</span>);</span><br><span class="line">            combination[--combination_size] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>** <span class="title">letterCombinations</span><span class="params">(<span class="keyword">char</span>* digits, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">    combinations_size = combination_size = <span class="number">0</span>;</span><br><span class="line">    digits_tmp = digits;</span><br><span class="line">    digits_size = <span class="built_in">strlen</span>(digits);</span><br><span class="line">    <span class="keyword">if</span> (digits_size == <span class="number">0</span>) &#123;</span><br><span class="line">        *returnSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> combinations;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; digits_size; i++) num *= <span class="number">4</span>;</span><br><span class="line">    combinations = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>*) * num);</span><br><span class="line">    combination = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>*) * digits_size);</span><br><span class="line">    backtrack(<span class="number">0</span>);</span><br><span class="line">    *returnSize = combinations_size;</span><br><span class="line">    <span class="keyword">return</span> combinations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>回溯Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits: str)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line">            <span class="keyword">return</span> list()</span><br><span class="line">        </span><br><span class="line">        phoneMap = &#123;</span><br><span class="line">            <span class="string">"2"</span>: <span class="string">"abc"</span>,</span><br><span class="line">            <span class="string">"3"</span>: <span class="string">"def"</span>,</span><br><span class="line">            <span class="string">"4"</span>: <span class="string">"ghi"</span>,</span><br><span class="line">            <span class="string">"5"</span>: <span class="string">"jkl"</span>,</span><br><span class="line">            <span class="string">"6"</span>: <span class="string">"mno"</span>,</span><br><span class="line">            <span class="string">"7"</span>: <span class="string">"pqrs"</span>,</span><br><span class="line">            <span class="string">"8"</span>: <span class="string">"tuv"</span>,</span><br><span class="line">            <span class="string">"9"</span>: <span class="string">"wxyz"</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(index: int)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> index == len(digits):</span><br><span class="line">                combinations.append(<span class="string">""</span>.join(combination))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                digit = digits[index]</span><br><span class="line">                <span class="keyword">for</span> letter <span class="keyword">in</span> phoneMap[digit]:</span><br><span class="line">                    combination.append(letter)</span><br><span class="line">                    backtrack(index + <span class="number">1</span>)</span><br><span class="line">                    combination.pop()</span><br><span class="line"></span><br><span class="line">        combination = list()</span><br><span class="line">        combinations = list()</span><br><span class="line">        backtrack(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> combinations</span><br></pre></td></tr></table></figure></details><details>    <summary>回溯Python</summary><figure class="highlight python"><figcaption><span>[sol1-Python3_oneliner]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits: str)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line">            <span class="keyword">return</span> list()</span><br><span class="line">        </span><br><span class="line">        phoneMap = &#123;</span><br><span class="line">            <span class="string">"2"</span>: <span class="string">"abc"</span>,</span><br><span class="line">            <span class="string">"3"</span>: <span class="string">"def"</span>,</span><br><span class="line">            <span class="string">"4"</span>: <span class="string">"ghi"</span>,</span><br><span class="line">            <span class="string">"5"</span>: <span class="string">"jkl"</span>,</span><br><span class="line">            <span class="string">"6"</span>: <span class="string">"mno"</span>,</span><br><span class="line">            <span class="string">"7"</span>: <span class="string">"pqrs"</span>,</span><br><span class="line">            <span class="string">"8"</span>: <span class="string">"tuv"</span>,</span><br><span class="line">            <span class="string">"9"</span>: <span class="string">"wxyz"</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        groups = (phoneMap[digit] <span class="keyword">for</span> digit <span class="keyword">in</span> digits)</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">""</span>.join(combination) <span class="keyword">for</span> combination <span class="keyword">in</span> itertools.product(*groups)]</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(3^m * 4^n)，其中 <em>m</em> 是输入中对应 <em>3</em> 个字母的数字个数（包括数字 <em>2</em>、<em>3</em>、<em>4</em>、<em>5</em>、<em>6</em>、<em>8</em>），<em>n</em> 是输入中对应 <em>4</em> 个字母的数字个数（包括数字 <em>7</em>、<em>9</em>），<em>m+n</em> 是输入数字的总个数。当输入包含 <em>m</em> 个对应 <em>3</em> 个字母的数字和 <em>n</em> 个对应 <em>4</em> 个字母的数字时，不同的字母组合一共有3^m * 4^n 种，需要遍历每一种字母组合。</p></li><li><p>空间复杂度：<em>O(m+n)</em>，其中 </p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。&lt;/p&gt;
&lt;p&gt;给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年2月" scheme="http://yoursite.com/categories/2021%E5%B9%B42%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
  </entry>
  
  <entry>
    <title>909. 蛇梯棋</title>
    <link href="http://yoursite.com/2021/01/28/909.%20%E8%9B%87%E6%A2%AF%E6%A3%8B/"/>
    <id>http://yoursite.com/2021/01/28/909. 蛇梯棋/</id>
    <published>2021-01-28T06:23:12.000Z</published>
    <updated>2021-01-28T09:28:27.707Z</updated>
    
    <content type="html"><![CDATA[<p>N x N 的棋盘 board 上，按从 1 到 N<em>N 的数字给方格编号，编号 从左下角开始，每一行交替方向。返回达到方格 N</em>N 所需的最少移动次数，如果不可能，则返回 -1。</p><a id="more"></a><p>例如，一块 6 x 6 大小的棋盘，编号如下：</p><p>r 行 c 列的棋盘，按前述方法编号，棋盘格中可能存在 “蛇” 或 “梯子”；如果 board[r][c] != -1，那个蛇或梯子的目的地将会是 board[r][c]。</p><p>玩家从棋盘上的方格 1 （总是在最后一行、第一列）开始出发。</p><p>每一回合，玩家需要从当前方格 x 开始出发，按下述要求前进：</p><p>选定目标方格：选择从编号 x+1，x+2，x+3，x+4，x+5，或者 x+6 的方格中选出一个目标方格 s ，目标方格的编号 &lt;= N*N。<br>该选择模拟了掷骰子的情景，无论棋盘大小如何，你的目的地范围也只能处于区间 [x+1, x+6] 之间。<br>传送玩家：如果目标方格 S 处存在蛇或梯子，那么玩家会传送到蛇或梯子的目的地。否则，玩家传送到目标方格 S。<br>注意，玩家在每回合的前进过程中最多只能爬过蛇或梯子一次：就算目的地是另一条蛇或梯子的起点，你也不会继续移动。</p><p>返回达到方格 N*N 所需的最少移动次数，如果不可能，则返回 -1。</p><p>示例：</p><pre><code>输入：[[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]输出：4解释：首先，从方格 1 [第 5 行，第 0 列] 开始。你决定移动到方格 2，并必须爬过梯子移动到到方格 15。然后你决定移动到方格 17 [第 3 行，第 5 列]，必须爬过蛇到方格 13。然后你决定移动到方格 14，且必须通过梯子移动到方格 35。然后你决定移动到方格 36, 游戏结束。可以证明你需要至少 4 次移动才能到达第 N*N 个方格，所以答案是 4。</code></pre><p>提示：</p><pre><code>2 &lt;= board.length = board[0].length &lt;= 20board[i][j] 介于 1 和 N*N 之间或者等于 -1。编号为 1 的方格上没有蛇或梯子。编号为 N*N 的方格上没有蛇或梯子。</code></pre><h1 id="方法-1：广度优先搜索"><a href="#方法-1：广度优先搜索" class="headerlink" title="方法 1：广度优先搜索"></a>方法 1：广度优先搜索</h1><p><strong>想法</strong></p><p>由于我们需要找到一条最短路径，广度优先搜索是一种理想的方法。难点在于如何对每个方格枚举所有可能的移动。</p><p><strong>算法</strong></p><p>假设我们在方格 <code>s</code> 上，我们想知道一次移动之后所有可能的终点 <code>s2</code>。</p><p>这需要知道方格 <code>s2</code> 的坐标 <code>get(s2)</code>，这有一个小技巧：我们知道行号每 <code>N</code> 个方格改变一次，所以只依赖于 <code>quot = (s2-1) / N</code>；同样列号依赖于 <code>rem = (s2-1) % N</code>。</p><p>由此，我们可以实现一个根据方格 <code>s</code>  的信息进行广度优先搜索。</p><details>    <summary>广度优先搜索Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">snakesAndLadders</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = board.length;</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer, Integer&gt; dist = <span class="keyword">new</span> HashMap();</span><br><span class="line">        dist.put(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        queue.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> s = queue.remove();</span><br><span class="line">            <span class="keyword">if</span> (s == N*N) <span class="keyword">return</span> dist.get(s);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s2 = s+<span class="number">1</span>; s2 &lt;= Math.min(s+<span class="number">6</span>, N*N); ++s2) &#123;</span><br><span class="line">                <span class="keyword">int</span> rc = get(s2, N);</span><br><span class="line">                <span class="keyword">int</span> r = rc / N, c = rc % N;</span><br><span class="line">                <span class="keyword">int</span> s2Final = board[r][c] == -<span class="number">1</span> ? s2 : board[r][c];</span><br><span class="line">                <span class="keyword">if</span> (!dist.containsKey(s2Final)) &#123;</span><br><span class="line">                    dist.put(s2Final, dist.get(s) + <span class="number">1</span>);</span><br><span class="line">                    queue.add(s2Final);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Given a square num s, return board coordinates (r, c) as r*N + c</span></span><br><span class="line">        <span class="keyword">int</span> quot = (s-<span class="number">1</span>) / N;</span><br><span class="line">        <span class="keyword">int</span> rem = (s-<span class="number">1</span>) % N;</span><br><span class="line">        <span class="keyword">int</span> row = N - <span class="number">1</span> - quot;</span><br><span class="line">        <span class="keyword">int</span> col = row % <span class="number">2</span> != N % <span class="number">2</span> ? rem : N - <span class="number">1</span> - rem;</span><br><span class="line">        <span class="keyword">return</span> row * N + col;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>广度优先搜索Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">snakesAndLadders</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        N = len(board)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(s)</span>:</span></span><br><span class="line">            <span class="comment"># Given a square num s, return board coordinates (r, c)</span></span><br><span class="line">            quot, rem = divmod(s<span class="number">-1</span>, N)</span><br><span class="line">            row = N - <span class="number">1</span> - quot</span><br><span class="line">            col = rem <span class="keyword">if</span> row%<span class="number">2</span> != N%<span class="number">2</span> <span class="keyword">else</span> N - <span class="number">1</span> - rem</span><br><span class="line">            <span class="keyword">return</span> row, col</span><br><span class="line"></span><br><span class="line">        dist = &#123;<span class="number">1</span>: <span class="number">0</span>&#125;</span><br><span class="line">        queue = collections.deque([<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            s = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> s == N*N: <span class="keyword">return</span> dist[s]</span><br><span class="line">            <span class="keyword">for</span> s2 <span class="keyword">in</span> xrange(s+<span class="number">1</span>, min(s+<span class="number">6</span>, N*N) + <span class="number">1</span>):</span><br><span class="line">                r, c = get(s2)</span><br><span class="line">                <span class="keyword">if</span> board[r][c] != <span class="number">-1</span>:</span><br><span class="line">                    s2 = board[r][c]</span><br><span class="line">                <span class="keyword">if</span> s2 <span class="keyword">not</span> <span class="keyword">in</span> dist:</span><br><span class="line">                    dist[s2] = dist[s] + <span class="number">1</span></span><br><span class="line">                    queue.append(s2)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(N^2)*，其中 *N</em> 是 <code>board</code> 的长度。</li><li>空间复杂度：<em>O(N^2)</em>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;N x N 的棋盘 board 上，按从 1 到 N&lt;em&gt;N 的数字给方格编号，编号 从左下角开始，每一行交替方向。返回达到方格 N&lt;/em&gt;N 所需的最少移动次数，如果不可能，则返回 -1。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年1月" scheme="http://yoursite.com/categories/2021%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Breadth-first Search" scheme="http://yoursite.com/tags/Breadth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>688. “马”在棋盘上的概率</title>
    <link href="http://yoursite.com/2021/01/27/688.%20%E2%80%9C%E9%A9%AC%E2%80%9D%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87/"/>
    <id>http://yoursite.com/2021/01/27/688. “马”在棋盘上的概率/</id>
    <published>2021-01-27T09:23:12.000Z</published>
    <updated>2021-01-28T06:16:05.034Z</updated>
    
    <content type="html"><![CDATA[<p>已知一个 NxN 的国际象棋棋盘，求移动结束后，“马” 仍留在棋盘上的概率。</p><a id="more"></a><p>已知一个 NxN 的国际象棋棋盘，棋盘的行号和列号都是从 0 开始。即最左上角的格子记为 (0, 0)，最右下角的记为 (N-1, N-1)。 </p><p>现有一个 “马”（也译作 “骑士”）位于 (r, c) ，并打算进行 K 次移动。 </p><p>如下图所示，国际象棋的 “马” 每一步先沿水平或垂直方向移动 2 个格子，然后向与之相垂直的方向再移动 1 个格子，共有 8 个可选的位置。</p><p>现在 “马” 每一步都从可选的位置（包括棋盘外部的）中独立随机地选择一个进行移动，直到移动了 K 次或跳到了棋盘外面。</p><p>求移动结束后，“马” 仍留在棋盘上的概率。</p><p>示例：</p><pre><code>输入: 3, 2, 0, 0输出: 0.0625解释: 输入的数据依次为 N, K, r, c第 1 步时，有且只有 2 种走法令 “马” 可以留在棋盘上（跳到（1,2）或（2,1））。对于以上的两种情况，各自在第2步均有且只有2种走法令 “马” 仍然留在棋盘上。所以 “马” 在结束后仍在棋盘上的概率为 0.0625。</code></pre><p>注意：</p><pre><code>N 的取值范围为 [1, 25]K 的取值范围为 [0, 100]开始时，“马” 总是位于棋盘上</code></pre><h1 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h1><p><strong>算法：</strong></p><ul><li>令 <code>f[r][c][steps]</code> 代表马在位置 <code>(r, c)</code> 移动了 <code>steps</code> 次以后还留在棋盘上的概率，根据马的移动方式，我们有以下递归：<br>  <code>f[r][c][steps]=sum(f[r+dr][c+dc][steps-1])/8.0</code></li><li>根据题目我们可以知道 <em>(dr, dc)</em> 的可能数据对是 <em>(2, 1),</em> <em>(2, -1),</em> <em>(-2, 1),</em> <em>(-2, -1),</em> <em>(1, 2),</em> <em>(1, -2),</em> <em>(-1, 2),</em> <em>(-1, -2)</em>。</li><li>我们将使用二维的 <code>dp</code> 和 <code>dp2</code> 来存储我们的数据，而不是使用三维数组 <code>f</code>。<code>dp2</code> 代表 <code>f[][][steps]</code>，<code>dp</code> 代表 <code>f[][][steps-1]</code>。 </li></ul><details>    <summary>动态规划Java</summary><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">knightProbability</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span>[][] dp = <span class="keyword">new</span> <span class="keyword">double</span>[N][N];</span><br><span class="line">        <span class="keyword">int</span>[] dr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dc = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>, -<span class="number">2</span>, <span class="number">2</span>, -<span class="number">2</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        dp[sr][sc] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; K &gt; <span class="number">0</span>; K--) &#123;</span><br><span class="line">            <span class="keyword">double</span>[][] dp2 = <span class="keyword">new</span> <span class="keyword">double</span>[N][N];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; N; r++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; N; c++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++) &#123;</span><br><span class="line">                        <span class="keyword">int</span> cr = r + dr[k];</span><br><span class="line">                        <span class="keyword">int</span> cc = c + dc[k];</span><br><span class="line">                        <span class="keyword">if</span> (<span class="number">0</span> &lt;= cr &amp;&amp; cr &lt; N &amp;&amp; <span class="number">0</span> &lt;= cc &amp;&amp; cc &lt; N) &#123;</span><br><span class="line">                            dp2[cr][cc] += dp[r][c] / <span class="number">8.0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp = dp2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">double</span>[] row: dp) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">double</span> x: row) ans += x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```    </span><br><span class="line">    </span><br><span class="line">&lt;/details&gt;</span><br><span class="line"></span><br><span class="line">&lt;details&gt;</span><br><span class="line">    &lt;summary&gt;动态规划Python&lt;/summary&gt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">```python [solution1-Python]</span><br><span class="line">class Solution(object):</span><br><span class="line">    <span class="function">def <span class="title">knightProbability</span><span class="params">(self, N, K, r, c)</span>:</span></span><br><span class="line"><span class="function">        dp </span>= [[<span class="number">0</span>] * <span class="function">N <span class="keyword">for</span> _ in <span class="title">xrange</span><span class="params">(N)</span>]</span></span><br><span class="line"><span class="function">        dp[r][c] </span>= <span class="number">1</span></span><br><span class="line">        <span class="function"><span class="keyword">for</span> _ in <span class="title">xrange</span><span class="params">(K)</span>:</span></span><br><span class="line"><span class="function">            dp2 </span>= [[<span class="number">0</span>] * <span class="function">N <span class="keyword">for</span> _ in <span class="title">xrange</span><span class="params">(N)</span>]</span></span><br><span class="line"><span class="function">            <span class="keyword">for</span> r, row in <span class="title">enumerate</span><span class="params">(dp)</span>:</span></span><br><span class="line"><span class="function">                <span class="keyword">for</span> c, val in <span class="title">enumerate</span><span class="params">(row)</span>:</span></span><br><span class="line"><span class="function">                    <span class="keyword">for</span> dr, dc <span class="title">in</span> <span class="params">((<span class="number">2</span>,<span class="number">1</span>)</span>,<span class="params">(<span class="number">2</span>,<span class="number">-1</span>)</span>,<span class="params">(<span class="number">-2</span>,<span class="number">1</span>)</span>,<span class="params">(<span class="number">-2</span>,<span class="number">-1</span>)</span>,</span></span><br><span class="line"><span class="function">                                   <span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span>,<span class="params">(<span class="number">1</span>,<span class="number">-2</span>)</span>,<span class="params">(<span class="number">-1</span>,<span class="number">2</span>)</span>,<span class="params">(<span class="number">-1</span>,<span class="number">-2</span>)</span>):</span></span><br><span class="line"><span class="function">                        <span class="keyword">if</span> 0 &lt;</span>= r + dr &lt; N and <span class="number">0</span> &lt;= c + dc &lt; N:</span><br><span class="line">                            dp2[r+dr][c+dc] += val / <span class="number">8.0</span></span><br><span class="line">            dp = dp2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum(map(sum, dp))</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(N^2 K)*。其中 *N, K</em> 为题目中的定义。我们对 <em>N^2</em> 元素的每一层 <code>dp</code> 进行 <em>O(1)</em> 工作，并且考虑了 <em>K</em> 层。 </li><li>空间复杂度：<em>O(N^2)</em>，<code>dp</code> 和 <code>dp2</code> 的大小。 </li></ul><h1 id="方法二：矩阵求幂"><a href="#方法二：矩阵求幂" class="headerlink" title="方法二：矩阵求幂"></a>方法二：矩阵求幂</h1><p>方法 1 中表示的状态重复表达了过渡到其他的线性组合的状态。 任何情况下，我们都可以将整个转换表示为这些线性组合的矩阵。然后，这个矩阵的第 <em>n</em> 次方代表了 <em>n</em> 移动的转换，因此我们可以将问题简化为矩阵求幂问题。 </p><p><strong>算法：</strong></p><p>见<a href="https://leetcode-cn.com/problems/knight-probability-in-chessboard/solution/ma-zai-qi-pan-shang-de-gai-lu-by-leetcode/" target="_blank" rel="noopener">^1</a></p><details>    <summary>矩阵求幂Java</summary><figure class="highlight java"><figcaption><span>[solution2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">knightProbability</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, -<span class="number">2</span>, -<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dc = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, -<span class="number">2</span>, <span class="number">2</span>, -<span class="number">2</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] index = <span class="keyword">new</span> <span class="keyword">int</span>[N * N];</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; N; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; N; c++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r * N + c == canonical(r, c, N)) &#123;</span><br><span class="line">                    index[r * N + c] = t;</span><br><span class="line">                    t++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    index[r * N + c] = index[canonical(r, c, N)];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span>[][] T = <span class="keyword">new</span> <span class="keyword">double</span>[t][t];</span><br><span class="line">        <span class="keyword">int</span> curRow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; N; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; N; c++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r * N + c == canonical(r, c, N)) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++) &#123;</span><br><span class="line">                        <span class="keyword">int</span> cr = r + dr[k], cc = c + dc[k];</span><br><span class="line">                        <span class="keyword">if</span> (<span class="number">0</span> &lt;= cr &amp;&amp; cr &lt; N &amp;&amp; <span class="number">0</span> &lt;= cc &amp;&amp; cc &lt; N) &#123;</span><br><span class="line">                            T[curRow][index[canonical(cr, cc, N)]] += <span class="number">0.125</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    curRow++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span>[] row = matrixExpo(T, K)[index[sr*N + sc]];</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">double</span> x: row) ans += x;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canonical</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span>*r &gt; N) r = N-<span class="number">1</span>-r;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span>*c &gt; N) c = N-<span class="number">1</span>-c;</span><br><span class="line">        <span class="keyword">if</span> (r &gt; c) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = r;</span><br><span class="line">            r = c;</span><br><span class="line">            c = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r * N + c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[][] matrixMult(<span class="keyword">double</span>[][] A, <span class="keyword">double</span>[][] B) &#123;</span><br><span class="line">        <span class="keyword">double</span>[][] ans = <span class="keyword">new</span> <span class="keyword">double</span>[A.length][A.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; B.length; k++) &#123;</span><br><span class="line">                    ans[i][j] += A[i][k] * B[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[][] matrixExpo(<span class="keyword">double</span>[][] A, <span class="keyword">int</span> pow) &#123;</span><br><span class="line">        <span class="keyword">double</span>[][] ans = <span class="keyword">new</span> <span class="keyword">double</span>[A.length][A.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) ans[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (pow == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">if</span> (pow == <span class="number">1</span>) <span class="keyword">return</span> A;</span><br><span class="line">        <span class="keyword">if</span> (pow % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> matrixMult(matrixExpo(A, pow-<span class="number">1</span>), A);</span><br><span class="line">        <span class="keyword">double</span>[][] B = matrixExpo(A, pow / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> matrixMult(B, B);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>矩阵求幂Python</summary><figure class="highlight python"><figcaption><span>[solution2-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">knightProbability</span><span class="params">(self, N, K, sr, sc)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">canonical</span><span class="params">(r, c)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">2</span> * r &gt; N: r = N - <span class="number">1</span> - r</span><br><span class="line">            <span class="keyword">if</span> <span class="number">2</span> * c &gt; N: c = N - <span class="number">1</span> - c</span><br><span class="line">            <span class="keyword">if</span> r &gt; c: r, c = c, r</span><br><span class="line">            <span class="keyword">return</span> r*N + c</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">matrix_mult</span><span class="params">(A, B)</span>:</span></span><br><span class="line">            ZB = zip(*B)</span><br><span class="line">            <span class="keyword">return</span> [[sum(a * b <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(row, col))</span><br><span class="line">                     <span class="keyword">for</span> col <span class="keyword">in</span> ZB] <span class="keyword">for</span> row <span class="keyword">in</span> A]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">matrix_expo</span><span class="params">(A, K)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> K == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> [[+(i==j) <span class="keyword">for</span> j <span class="keyword">in</span> xrange(len(A))]</span><br><span class="line">                        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(A))]</span><br><span class="line">            <span class="keyword">if</span> K == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> A</span><br><span class="line">            <span class="keyword">elif</span> K % <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> matrix_mult(matrix_expo(A, K<span class="number">-1</span>), A)</span><br><span class="line">            B = matrix_expo(A, K/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> matrix_mult(B, B)</span><br><span class="line"></span><br><span class="line">        index = [<span class="number">0</span>] * (N*N)</span><br><span class="line">        t = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> xrange(N):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> xrange(N):</span><br><span class="line">                <span class="keyword">if</span> r*N + c == canonical(r, c):</span><br><span class="line">                    index[r*N + c] = t</span><br><span class="line">                    t += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    index[r*N + c] = index[canonical(r, c)]</span><br><span class="line"></span><br><span class="line">        T = []</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> xrange(N):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> xrange(N):</span><br><span class="line">                <span class="keyword">if</span> r*N + c == canonical(r, c):</span><br><span class="line">                    row = [<span class="number">0</span>] * t</span><br><span class="line">                    <span class="keyword">for</span> dr, dc <span class="keyword">in</span> ((<span class="number">2</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">-1</span>),(<span class="number">-2</span>,<span class="number">1</span>),(<span class="number">-2</span>,<span class="number">-1</span>),</span><br><span class="line">                                    (<span class="number">1</span>,<span class="number">2</span>),(<span class="number">1</span>,<span class="number">-2</span>),(<span class="number">-1</span>,<span class="number">2</span>),(<span class="number">-1</span>,<span class="number">-2</span>)):</span><br><span class="line">                        <span class="keyword">if</span> <span class="number">0</span> &lt;= r+dr &lt; N <span class="keyword">and</span> <span class="number">0</span> &lt;= c+dc &lt; N:</span><br><span class="line">                            row[index[(r+dr)*N + c+dc]] += <span class="number">0.125</span></span><br><span class="line">                    T.append(row)</span><br><span class="line"></span><br><span class="line">        Tk = matrix_expo(T, K)</span><br><span class="line">        i = index[sr * N + sc]</span><br><span class="line">        <span class="keyword">return</span> sum(Tk[i])</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;已知一个 NxN 的国际象棋棋盘，求移动结束后，“马” 仍留在棋盘上的概率。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年1月" scheme="http://yoursite.com/categories/2021%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Dynammic Programming" scheme="http://yoursite.com/tags/Dynammic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>782. 变为棋盘</title>
    <link href="http://yoursite.com/2021/01/27/782.%20%E5%8F%98%E4%B8%BA%E6%A3%8B%E7%9B%98/"/>
    <id>http://yoursite.com/2021/01/27/782. 变为棋盘/</id>
    <published>2021-01-27T09:23:12.000Z</published>
    <updated>2021-02-01T10:02:42.648Z</updated>
    
    <content type="html"><![CDATA[<p>一个 N x N的 board 仅由 0 和 1 组成 。每次移动，你能任意交换两列或是两行的位置。</p><p>输出将这个矩阵变为 “棋盘” 所需的最小移动次数。“棋盘” 是指任意一格的上下左右四个方向的值均与本身不同的矩阵。如果不存在可行的变换，输出 -1。</p><a id="more"></a><p>示例:</p><pre><code>输入: board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]]输出: 2解释:一种可行的变换方式如下，从左到右：0110     1010     10100110 --&gt; 1010 --&gt; 01011001     0101     10101001     0101     0101第一次移动交换了第一列和第二列。第二次移动交换了第二行和第三行。输入: board = [[0, 1], [1, 0]]输出: 0解释:注意左上角的格值为0时也是合法的棋盘，如：0110也是合法的棋盘.输入: board = [[1, 0], [1, 0]]输出: -1解释:任意的变换都不能使这个输入变为合法的棋盘。提示：board 是方阵，且行列数的范围是[2, 30]。board[i][j] 将只包含 0或 1。</code></pre><h1 id="方法一：分维度计算"><a href="#方法一：分维度计算" class="headerlink" title="方法一：分维度计算"></a>方法一：分维度计算</h1><p><strong>思路</strong></p><p>首先需要思考的是一次交换之后，棋盘会发生什么变化。为了简单起见，这里用交换列来做例子。在对任意两列进行交换之后，可以看到列交换是不会改变任意两行之间的状态的，简单的来说如果这两行原本就相同，列交换之后这两行依旧相同，如果这两行本来就不同，列交换之后也还是不同。由于最终的棋盘只有两种不同的行，最初的棋盘也一定只有两种不同的行，否则不管怎么做列交换都不会得到最终的棋盘。</p><p>之后再来看棋盘行的规律，棋盘有两种行，这两种行每一位都互相不同。同时对于每一行来说，一定有一半为 <code>1</code>，一半为 <code>0</code>（如果长度为奇数，会多一个 <code>1</code> 或多一个 <code>0</code>）。对于棋盘的列也是同样的规律。</p><p>可以观察到，先换行再换列跟先换列再换行结果是一样的。在这里先将所有的行调到正确的位置，再将所有的列调到正确的位置。</p><p>考虑到只有两种不同的行，可以分别用 0，1 对其表示。要达成最终的棋盘实际上等价于将棋盘的行表示成 0，1相隔的状态。假设在将棋盘的行用 0，1 表示之后得到数组为 <code>[0, 1, 1, 1, 0, 0]</code>，那么只需求这个数组变成 <code>[0, 1, 0, 1, 0, 1]</code> 和 <code>[1, 0, 1, 0, 1, 0]</code> 的代价，之后取其中最小的代价就好了。同理，对列也是如此，这就将二维问题变成了两个一维问题。</p><p><strong>算法</strong></p><p>首先需要确认是否有且只有两种行（列）存在，且这两种行（列）的 0，1 排布合法，如果不符合条件直接返回 <code>-1</code>。之后需要生成理想的行（列）的状态（即0，1相隔的数组排列），对于每种理想状态，计算其与初始状态之间变换的代价。举个例子，对于 <code>[0, 1, 1, 1, 0, 0]</code> 初始状态来说，有两种理想状态，分别是 <code>[0, 1, 0, 1, 0, 1]</code> 和 <code>[1, 0, 1, 0, 1, 0]</code>，对于 <code>[0, 1, 1, 1, 0]</code> 初始状态只有一种理想状态 <code>[1, 0, 1, 0, 1]</code>。</p><p>在 Java 实现中，用整型来表示每行。之后将其与 <code>0b010101010101.....01</code> 进行异或来计算初始状态转换到理想状态的代价。为了代码简洁，这里统一使用 <code>0xAAAAAAAA</code> 和 <code>0x55555555</code>，为了不引入额外的转换代价，还需要根据行的长度 <code>N</code> 生成 <code>0b00...0011...11</code> 掩码与结果做与运算。</p><details>    <summary>分维度计算Java</summary><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 关键点：</span></span><br><span class="line">    <span class="comment">// 1、行交换不影响列之间的相同与否状态（列交换同理），可以分别计算</span></span><br><span class="line">    <span class="comment">// 2、某行（列）0、1的个数是一半（+1）</span></span><br><span class="line">    <span class="comment">// 3、只有两种状态的行（列），且个数是一半（+1）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movesToChessboard</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = board.length;</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer, Integer&gt; count = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="comment">// 先检查行属性</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row: board) &#123; </span><br><span class="line">            <span class="keyword">int</span> code = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x: row)  <span class="comment">// 每行中的元素们</span></span><br><span class="line">                code = <span class="number">2</span> * code + x; <span class="comment">// code代表此行的二进制数，即*2（左移）+当前数</span></span><br><span class="line">            <span class="comment">//把每行的&lt;二进制数code，对应的行数&gt;放到map</span></span><br><span class="line">            count.put(code, count.getOrDefault(code, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> k1 = analyzeCount(count, N); <span class="comment">// 计算行交换次数（其实是使行排列正确，需要交换列）</span></span><br><span class="line">        <span class="keyword">if</span> (k1 == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">//  行不正确直接返回</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查列属性（和行一样）</span></span><br><span class="line">        count = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; N; ++c) &#123;</span><br><span class="line">            <span class="keyword">int</span> code = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; N; ++r)</span><br><span class="line">                code = <span class="number">2</span> * code + board[r][c];</span><br><span class="line">            count.put(code, count.getOrDefault(code, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> k2 = analyzeCount(count, N); <span class="comment">// 计算列交换次数</span></span><br><span class="line">        <span class="keyword">return</span> k2 &gt;= <span class="number">0</span> ? k1 + k2 : -<span class="number">1</span>;  <span class="comment">// 走到这里说明行正确，若列不正确返回-1，否则返回二者和</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">analyzeCount</span><span class="params">(Map&lt;Integer, Integer&gt; count, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 若状态不是2种，肯定不行，返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (count.size() != <span class="number">2</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; keys = <span class="keyword">new</span> ArrayList(count.keySet());</span><br><span class="line">        <span class="keyword">int</span> k1 = keys.get(<span class="number">0</span>), k2 = keys.get(<span class="number">1</span>); <span class="comment">// k1，k2就是上面的code二进制数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两种状态的行（列）都不是一半（+1）</span></span><br><span class="line">        <span class="keyword">if</span> (!(count.get(k1) == N/<span class="number">2</span> &amp;&amp; count.get(k2) == (N+<span class="number">1</span>)/<span class="number">2</span>) &amp;&amp;</span><br><span class="line">                !(count.get(k2) == N/<span class="number">2</span> &amp;&amp; count.get(k1) == (N+<span class="number">1</span>)/<span class="number">2</span>))</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两种不相反，错误：</span></span><br><span class="line">        <span class="comment">// 巧妙的用异或，和N位1比较</span></span><br><span class="line">        <span class="keyword">if</span> ((k1 ^ k2) != (<span class="number">1</span>&lt;&lt;N) - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> Nones = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>;<span class="comment">// N位1：00..0011..111，后面&amp; Nones是为了截断前面多余的位数，</span></span><br><span class="line">        <span class="keyword">int</span> ones = Integer.bitCount(k1 &amp; Nones); <span class="comment">// bitCount统计状态1的二进制中1的个数</span></span><br><span class="line">        <span class="keyword">int</span> cand = Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">// 以下两种情况都要计算一次：要使行中的数字相邻之间不同，需要交换列</span></span><br><span class="line">        <span class="comment">// N是偶数，或者奇数且1的个数小于N，那么就是0开头的状态（AAAA截N位刚好首尾是0）</span></span><br><span class="line">        <span class="keyword">if</span> (N%<span class="number">2</span> == <span class="number">0</span> || ones * <span class="number">2</span> &lt; N) <span class="comment">// 0xAAAAAAAA：10101010101010101010101010101010</span></span><br><span class="line">            <span class="comment">// 找到与正确的1010...相差的位数，则需要交换的次数是一半（/2）</span></span><br><span class="line">            cand = Math.min(cand, Integer.bitCount(k1 ^ <span class="number">0xAAAAAAAA</span> &amp; Nones) / <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// N是偶数，或者奇数且1的个数大于N，那么就是1开头的状态</span></span><br><span class="line">        <span class="keyword">if</span> (N%<span class="number">2</span> == <span class="number">0</span> || ones * <span class="number">2</span> &gt; N) <span class="comment">// 0x55555555：01010101010101010101010101010101</span></span><br><span class="line">            cand = Math.min(cand, Integer.bitCount(k1 ^ <span class="number">0x55555555</span> &amp; Nones) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cand;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>分维度计算Python</summary><figure class="highlight python"><figcaption><span>[solution1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movesToChessboard</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        N = len(board)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="comment"># For each count of lines from &#123;rows, columns&#125;...</span></span><br><span class="line">        <span class="keyword">for</span> count <span class="keyword">in</span> (collections.Counter(map(tuple, board)),</span><br><span class="line">                      collections.Counter(zip(*board))):</span><br><span class="line"></span><br><span class="line">            <span class="comment"># If there are more than 2 kinds of lines,</span></span><br><span class="line">            <span class="comment"># or if the number of kinds is not appropriate ...</span></span><br><span class="line">            <span class="keyword">if</span> len(count) != <span class="number">2</span> <span class="keyword">or</span> sorted(count.values()) != [N/<span class="number">2</span>, (N+<span class="number">1</span>)/<span class="number">2</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># If the lines are not opposite each other, impossible</span></span><br><span class="line">            line1, line2 = count</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> all(x ^ y <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(line1, line2)):</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># starts = what could be the starting value of line1</span></span><br><span class="line">            <span class="comment"># If N is odd, then we have to start with the more</span></span><br><span class="line">            <span class="comment"># frequent element</span></span><br><span class="line">            starts = [+(line1.count(<span class="number">1</span>) * <span class="number">2</span> &gt; N)] <span class="keyword">if</span> N%<span class="number">2</span> <span class="keyword">else</span> [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># To transform line1 into the ideal line [i%2 for i ...],</span></span><br><span class="line">            <span class="comment"># we take the number of differences and divide by two</span></span><br><span class="line">            ans += min(sum((i-x) % <span class="number">2</span> <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(line1, start))</span><br><span class="line">                       <span class="keyword">for</span> start <span class="keyword">in</span> starts) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(N^2)*，其中 *N</em> 是 <code>board</code> 的行（或列）的长度。</p></li><li><p>空间复杂度：<em>O(N)</em>，<code>count</code> 的空间。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个 N x N的 board 仅由 0 和 1 组成 。每次移动，你能任意交换两列或是两行的位置。&lt;/p&gt;
&lt;p&gt;输出将这个矩阵变为 “棋盘” 所需的最小移动次数。“棋盘” 是指任意一格的上下左右四个方向的值均与本身不同的矩阵。如果不存在可行的变换，输出 -1。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年1月" scheme="http://yoursite.com/categories/2021%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>1275. 找出井字棋的获胜者</title>
    <link href="http://yoursite.com/2021/01/25/1275.%20%E6%89%BE%E5%87%BA%E4%BA%95%E5%AD%97%E6%A3%8B%E7%9A%84%E8%8E%B7%E8%83%9C%E8%80%85/"/>
    <id>http://yoursite.com/2021/01/25/1275. 找出井字棋的获胜者/</id>
    <published>2021-01-25T06:12:12.000Z</published>
    <updated>2021-01-27T09:22:43.454Z</updated>
    
    <content type="html"><![CDATA[<p>A 和 B 在一个 3 x 3 的网格上玩井字棋。最近对棋类游戏格外感兴趣，准备深入研究研究。</p><a id="more"></a><p>井字棋游戏的规则如下：</p><p>玩家轮流将棋子放在空方格 (“ “) 上。<br>第一个玩家 A 总是用 “X” 作为棋子，而第二个玩家 B 总是用 “O” 作为棋子。</p><p>“X” 和 “O” 只能放在空方格中，而不能放在已经被占用的方格上。</p><p>只要有 3 个相同的（非空）棋子排成一条直线（行、列、对角线）时，游戏结束。</p><p>如果所有方块都放满棋子（不为空），游戏也会结束。<br>游戏结束后，棋子无法再进行任何移动。</p><p>给你一个数组 moves，其中每个元素是大小为 2 的另一个数组（元素分别对应网格的行和列），它按照 A 和 B 的行动顺序（先 A 后 B）记录了两人各自的棋子位置。</p><p>如果游戏存在获胜者（A 或 B），就返回该游戏的获胜者；如果游戏以平局结束，则返回 “Draw”；如果仍会有行动（游戏未结束），则返回 “Pending”。</p><p>你可以假设 moves 都 有效（遵循井字棋规则），网格最初是空的，A 将先行动。</p><p>示例 1：</p><pre><code>输入：moves = [[0,0],[2,0],[1,1],[2,1],[2,2]]输出：&quot;A&quot;解释：&quot;A&quot; 获胜，他总是先走。&quot;X  &quot;    &quot;X  &quot;    &quot;X  &quot;    &quot;X  &quot;    &quot;X  &quot;&quot;   &quot; -&gt; &quot;   &quot; -&gt; &quot; X &quot; -&gt; &quot; X &quot; -&gt; &quot; X &quot;&quot;   &quot;    &quot;O  &quot;    &quot;O  &quot;    &quot;OO &quot;    &quot;OOX&quot;</code></pre><p>示例 2：</p><pre><code>输入：moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]]输出：&quot;B&quot;解释：&quot;B&quot; 获胜。&quot;X  &quot;    &quot;X  &quot;    &quot;XX &quot;    &quot;XXO&quot;    &quot;XXO&quot;    &quot;XXO&quot;&quot;   &quot; -&gt; &quot; O &quot; -&gt; &quot; O &quot; -&gt; &quot; O &quot; -&gt; &quot;XO &quot; -&gt; &quot;XO &quot; &quot;   &quot;    &quot;   &quot;    &quot;   &quot;    &quot;   &quot;    &quot;   &quot;    &quot;O  &quot;</code></pre><p>示例 3：</p><pre><code>输入：moves = [[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]]输出：&quot;Draw&quot;输出：由于没有办法再行动，游戏以平局结束。&quot;XXO&quot;&quot;OOX&quot;&quot;XOX&quot;</code></pre><p>示例 4：</p><pre><code>输入：moves = [[0,0],[1,1]]输出：&quot;Pending&quot;解释：游戏还没有结束。&quot;X  &quot;&quot; O &quot;&quot;   &quot;</code></pre><p>提示：</p><pre><code>1 &lt;= moves.length &lt;= 9moves[i].length == 20 &lt;= moves[i][j] &lt;= 2moves 里没有重复的元素。moves 遵循井字棋的规则。</code></pre><h1 id="方法一：模拟法"><a href="#方法一：模拟法" class="headerlink" title="方法一：模拟法"></a>方法一：模拟法</h1><p>模拟法是最容易想到的，先想到的是直接用矩阵来模拟，但这样时间效率较低，更高效的方法是用集合来存储两个玩家的落子位置，然后用一个集合来存储所有的获胜情况，直接判断玩家是否命中获胜情况。如果直到落子完毕仍然没有玩家获胜，那么根据数组 <code>move</code> 的长度返回平局 <code>Draw</code> 或游戏未结束 <code>Pending</code>。写这种方法时一开始犯了个错误，忘记有可能玩家落子数大于3，这时直接用list.contains()判断就会出错，需要用list.containsAll()。</p><details>    <summary>模拟法C++</summary><figure class="highlight c++"><figcaption><span>[sol1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkwin</span><span class="params">(<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&amp; S, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; wins)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> win: wins) &#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> pos: win) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!S.count(pos)) &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">tictactoe</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; moves)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; wins = &#123;</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">            &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;,</span><br><span class="line">            &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>&#125;,</span><br><span class="line">            &#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">4</span>, <span class="number">8</span>&#125;,</span><br><span class="line">            &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; A, B;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; moves.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = moves[i][<span class="number">0</span>] * <span class="number">3</span> + moves[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                A.insert(pos);</span><br><span class="line">                <span class="keyword">if</span> (checkwin(A, wins)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"A"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                B.insert(pos);</span><br><span class="line">                <span class="keyword">if</span> (checkwin(B, wins)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"B"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (moves.size() == <span class="number">9</span> ? <span class="string">"Draw"</span> : <span class="string">"Pending"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>模拟法Python</summary><figure class="highlight python"><figcaption><span>[sol1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tictactoe</span><span class="params">(self, moves: List[List[int]])</span> -&gt; str:</span></span><br><span class="line">        wins = [</span><br><span class="line">            [(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">2</span>)],</span><br><span class="line">            [(<span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">2</span>)],</span><br><span class="line">            [(<span class="number">2</span>, <span class="number">0</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">2</span>)],</span><br><span class="line">            [(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">2</span>, <span class="number">0</span>)],</span><br><span class="line">            [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">1</span>)],</span><br><span class="line">            [(<span class="number">0</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">2</span>)],</span><br><span class="line">            [(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">2</span>)],</span><br><span class="line">            [(<span class="number">0</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">0</span>)],</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">checkwin</span><span class="params">(S)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> win <span class="keyword">in</span> wins:</span><br><span class="line">                flag = <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">for</span> pos <span class="keyword">in</span> win:</span><br><span class="line">                    <span class="keyword">if</span> pos <span class="keyword">not</span> <span class="keyword">in</span> S:</span><br><span class="line">                        flag = <span class="keyword">False</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> flag:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        A, B = set(), set()</span><br><span class="line">        <span class="keyword">for</span> i, (x, y) <span class="keyword">in</span> enumerate(moves):</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                A.add((x, y))</span><br><span class="line">                <span class="keyword">if</span> checkwin(A):</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"A"</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                B.add((x, y))</span><br><span class="line">                <span class="keyword">if</span> checkwin(B):</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"B"</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Draw"</span> <span class="keyword">if</span> len(moves) == <span class="number">9</span> <span class="keyword">else</span> <span class="string">"Pending"</span></span><br><span class="line">```    </span><br><span class="line">&lt;/details&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;details&gt;</span><br><span class="line">    &lt;summary&gt;模拟法Java&lt;/summary&gt;</span><br><span class="line"></span><br><span class="line">```Java [sol1]</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public String tictactoe(int[][] moves) &#123;</span><br><span class="line">        boolean flag = true;</span><br><span class="line">        ArrayList&lt;Integer&gt; listA = new ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; listB = new ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (int[] m : moves) &#123;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                listA.add(m[<span class="number">0</span>] * <span class="number">3</span> + m[<span class="number">1</span>]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                listB.add(m[<span class="number">0</span>] * <span class="number">3</span> + m[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            flag = !flag;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (checkwins(listA)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"A"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (checkwins(listB)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"B"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        return listA.size() + listB.size() &lt; 9 ? "Pending" : "Draw";</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean checkwins(ArrayList&lt;Integer&gt; list) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList1 = new ArrayList&lt;&gt;(Arrays.asList(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList2 = new ArrayList&lt;&gt;(Arrays.asList(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList3 = new ArrayList&lt;&gt;(Arrays.asList(<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>));</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList4 = new ArrayList&lt;&gt;(Arrays.asList(<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>));</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList5 = new ArrayList&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>));</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList6 = new ArrayList&lt;&gt;(Arrays.asList(<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>));</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList7 = new ArrayList&lt;&gt;(Arrays.asList(<span class="number">0</span>, <span class="number">4</span>, <span class="number">8</span>));</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList8 = new ArrayList&lt;&gt;(Arrays.asList(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>));</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; arrayList = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(</span><br><span class="line">                Arrays.asList(arrayList1,arrayList2,arrayList3,arrayList4,arrayList5,arrayList6,arrayList7,arrayList8)</span><br><span class="line">        ) &#123;&#125;;</span><br><span class="line">        boolean flag = false;</span><br><span class="line">        <span class="keyword">for</span> (ArrayList&lt;Integer&gt; l : arrayList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list.containsAll(l)) &#123;</span><br><span class="line">                flag = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```    </span><br><span class="line">&lt;/details&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**复杂度分析**</span><br><span class="line"></span><br><span class="line">- 时间复杂度：*O(N^<span class="number">4</span>)*，其中 *N* 是棋盘的边长，在本题中 *N = <span class="number">3</span>*。集合 `wins` 中存放的排成一条直线的所有情况的数量为 *O(<span class="number">2</span>N+<span class="number">2</span>)=O(N)*，对于每一步落子我们需要遍历所有的情况，而每一种情况有 *N* 个位置，因此时间复杂度为 *O(N^<span class="number">2</span>)*。在最坏情况下，落子的数量为 *O(N^<span class="number">2</span>)*，因此总时间复杂度为 *O(N^<span class="number">4</span>)*。</span><br><span class="line"></span><br><span class="line">- 空间复杂度：*O(N^<span class="number">2</span>)*。集合 `wins` 占用的空间为 *O(N^<span class="number">2</span>)*，而集合 `A` 和 `B` 在最坏情况下占用的空间也为 *O(N^<span class="number">2</span>)*。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二：bitmask</span></span><br><span class="line"></span><br><span class="line">也可以使用bitmask来存储枚举的成功情况,重点在判断能获胜的位置上是否有棋子就可以</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;details&gt;</span><br><span class="line">    &lt;summary&gt;bitmask Java&lt;/summary&gt;</span><br><span class="line"></span><br><span class="line">```Java [sol1]</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public String tictactoe(int[][] moves) &#123;</span><br><span class="line">        int[] wins = &#123;</span><br><span class="line">                (<span class="number">1</span>&lt;&lt;<span class="number">0</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">1</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">2</span>),</span><br><span class="line">                (<span class="number">1</span>&lt;&lt;<span class="number">3</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">4</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">5</span>),</span><br><span class="line">                (<span class="number">1</span>&lt;&lt;<span class="number">6</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">7</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">8</span>),</span><br><span class="line">                (<span class="number">1</span>&lt;&lt;<span class="number">0</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">3</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">6</span>),</span><br><span class="line">                (<span class="number">1</span>&lt;&lt;<span class="number">1</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">4</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">7</span>),</span><br><span class="line">                (<span class="number">1</span>&lt;&lt;<span class="number">2</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">5</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">8</span>),</span><br><span class="line">                (<span class="number">1</span>&lt;&lt;<span class="number">0</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">4</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">8</span>),</span><br><span class="line">                (<span class="number">1</span>&lt;&lt;<span class="number">2</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">4</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">6</span>)&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isWin(moves, wins, true)) <span class="keyword">return</span> <span class="string">"A"</span>;</span><br><span class="line">        <span class="keyword">if</span> (isWin(moves, wins, false)) <span class="keyword">return</span> <span class="string">"B"</span>;</span><br><span class="line">        return moves.length==9 ? "Draw" : "Pending";</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean isWin(int[][] moves, int[] wins, boolean fromA) &#123;</span><br><span class="line">        int bitmask = <span class="number">0</span>;</span><br><span class="line">        int startIndex = fromA ? 0 : 1;</span><br><span class="line">        // 保证A/B至少下满<span class="number">3</span>次</span><br><span class="line">        <span class="keyword">if</span> (fromA &amp;&amp; moves.length &lt; <span class="number">5</span>) <span class="keyword">return</span> false;</span><br><span class="line">        <span class="keyword">if</span> (!fromA &amp;&amp; moves.length &lt; <span class="number">6</span>) <span class="keyword">return</span> false;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int i=startIndex; i&lt;moves.length; i+=<span class="number">2</span>) &#123;</span><br><span class="line">            int index = <span class="number">3</span> * moves[i][<span class="number">0</span>] + moves[i][<span class="number">1</span>];</span><br><span class="line">            bitmask |= <span class="number">1</span>&lt;&lt;index;</span><br><span class="line">        &#125;</span><br><span class="line">        // 判断当前下法是否属于赢法的一种</span><br><span class="line">        <span class="keyword">for</span> (int win: wins) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((win &amp; bitmask) == win) &#123;</span><br><span class="line">                <span class="keyword">return</span> true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```    </span><br><span class="line">&lt;/details&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法三：非枚举</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 虽然有A、B、Pending、Draw四种答案的可能。我们首先判断A、B谁能赢，再讨论A、B都未胜的情况下游戏是结束了还是继续进行；</span><br><span class="line"><span class="number">2.</span> 判断A、B是否有人能取胜，只需要判断最后一个落棋的人是否能胜；（因为要是另外一个人赢了，游戏就结束了，不再有继续下棋的机会）</span><br><span class="line"><span class="number">3.</span> 用数组记录最后落棋者的走棋情况，如果等于三，游戏结束，此人胜利；（以<span class="number">3</span>x3为例，其余可以类推）</span><br><span class="line"><span class="number">4.</span> 最后落棋者为未胜时，棋盘被下满则Draw，棋盘未下满则Pending。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;details&gt;</span><br><span class="line">    &lt;summary&gt;bitmask Java&lt;/summary&gt;</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public String tictactoe(int[][] moves) &#123;</span><br><span class="line">int m = moves.length;</span><br><span class="line">// 用数组记录<span class="number">0</span><span class="number">-2</span>行、<span class="number">0</span><span class="number">-2</span>列、正对角线、副对角线是否已满<span class="number">3</span>个棋子</span><br><span class="line">// count[<span class="number">0</span><span class="number">-2</span>]对应<span class="number">0</span><span class="number">-2</span>行、count[<span class="number">3</span><span class="number">-5</span>]对应<span class="number">0</span><span class="number">-2</span>列、count[<span class="number">6</span>]对应正对角线、count[<span class="number">7</span>]对应副对角线</span><br><span class="line">int[] count = new int[<span class="number">8</span>];</span><br><span class="line">// 思路第<span class="number">2</span>步已解释为何只需考虑最后一个落棋的人</span><br><span class="line">// 倒序统计此人走棋情况</span><br><span class="line"><span class="keyword">for</span>(int i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -= <span class="number">2</span>) &#123;</span><br><span class="line">// 此棋对行的影响</span><br><span class="line">count[moves[i][<span class="number">0</span>]]++;</span><br><span class="line">// 此棋对列的影响</span><br><span class="line">count[moves[i][<span class="number">1</span>] + <span class="number">3</span>]++;</span><br><span class="line">// 此棋对正对角线的影响</span><br><span class="line"><span class="keyword">if</span>(moves[i][<span class="number">0</span>] == moves[i][<span class="number">1</span>])</span><br><span class="line">count[<span class="number">6</span>]++;</span><br><span class="line">// 此棋对副对角线的影响 (</span><br><span class="line">// 此处为<span class="number">3</span>x3的情况，其余大小的棋盘可以类推</span><br><span class="line"><span class="keyword">if</span>(moves[i][<span class="number">0</span>] + moves[i][<span class="number">1</span>] == <span class="number">2</span>)</span><br><span class="line">count[<span class="number">7</span>]++;</span><br><span class="line">// 满<span class="number">3</span>个棋子则胜利</span><br><span class="line"><span class="keyword">if</span>(count[moves[i][<span class="number">0</span>]] == <span class="number">3</span> || count[moves[i][<span class="number">1</span>] + <span class="number">3</span>] == <span class="number">3</span> || </span><br><span class="line">count[<span class="number">6</span>] == <span class="number">3</span> || count[<span class="number">7</span>] == <span class="number">3</span>) </span><br><span class="line">// A先B后 则总长度为偶时 最后为B 反之为A</span><br><span class="line">return m % 2 == 0 ? "B" : "A";</span><br><span class="line">&#125;</span><br><span class="line">// 未胜时，棋盘未下满则继续</span><br><span class="line"><span class="keyword">if</span>(moves.length &lt; <span class="number">9</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Pending"</span>;</span><br><span class="line">// 未胜时，棋盘下满则平局结束</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Draw"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>时间和空间复杂度</strong></p><ul><li>时间复杂度：O(m) m为moves.length</li><li>空间复杂度：O(1) 棋盘固定 则空间开销固定</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;A 和 B 在一个 3 x 3 的网格上玩井字棋。最近对棋类游戏格外感兴趣，准备深入研究研究。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年1月" scheme="http://yoursite.com/categories/2021%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>312. 戳气球</title>
    <link href="http://yoursite.com/2020/12/29/312.%20%E6%88%B3%E6%B0%94%E7%90%83/"/>
    <id>http://yoursite.com/2020/12/29/312. 戳气球/</id>
    <published>2020-12-29T02:57:12.000Z</published>
    <updated>2021-01-11T02:32:24.714Z</updated>
    
    <content type="html"><![CDATA[<p>有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。</p><a id="more"></a><p>现在要求你戳破所有的气球。如果你戳破气球 i ，就可以获得 nums[left] * nums[i] * nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。</p><p>求所能获得硬币的最大数量。</p><p>说明:</p><p>你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。<br>0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100<br>示例:</p><pre><code>输入: [3,1,5,8]输出: 167 解释: nums = [3,1,5,8] --&gt; [3,5,8] --&gt;   [3,8]   --&gt;  [8]  --&gt; []     coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167</code></pre><h1 id="方法一：记忆化搜索"><a href="#方法一：记忆化搜索" class="headerlink" title="方法一：记忆化搜索"></a>方法一：记忆化搜索</h1><p><strong>思路及算法</strong><br><a href="https://leetcode-cn.com/problems/burst-balloons/solution/chuo-qi-qiu-by-leetcode-solution/" target="_blank" rel="noopener">^1</a></p><p><strong>代码</strong></p><details>    <summary>记忆化搜索C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; rec;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rec[left][right] != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rec[left][right];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt; right; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = val[left] * val[i] * val[right];</span><br><span class="line">            sum += solve(left, i) + solve(i, right);</span><br><span class="line">            rec[left][right] = max(rec[left][right], sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rec[left][right];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        val.resize(n + <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            val[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        val[<span class="number">0</span>] = val[n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        rec.resize(n + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">2</span>, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> solve(<span class="number">0</span>, n + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>记忆化搜索Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] rec;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] val;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        val = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            val[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        val[<span class="number">0</span>] = val[n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        rec = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>][n + <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            Arrays.fill(rec[i], -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> solve(<span class="number">0</span>, n + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rec[left][right] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rec[left][right];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt; right; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = val[left] * val[i] * val[right];</span><br><span class="line">            sum += solve(left, i) + solve(i, right);</span><br><span class="line">            rec[left][right] = Math.max(rec[left][right], sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rec[left][right];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>记忆化搜索Python</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxCoins</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        val = [<span class="number">1</span>] + nums + [<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line"><span class="meta">        @lru_cache(None)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(left: int, right: int)</span> -&gt; int:</span></span><br><span class="line">            <span class="keyword">if</span> left &gt;= right - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            best = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(left + <span class="number">1</span>, right):</span><br><span class="line">                total = val[left] * val[i] * val[right]</span><br><span class="line">                total += solve(left, i) + solve(i, right)</span><br><span class="line">                best = max(best, total)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> best</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> solve(<span class="number">0</span>, n + <span class="number">1</span>)</span><br></pre></td></tr></table></figure></details><details>    <summary>记忆化搜索Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxCoins</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    val := <span class="built_in">make</span>([]<span class="keyword">int</span>, n + <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        val[i] = nums[i - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    val[<span class="number">0</span>], val[n+<span class="number">1</span>] = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    rec := <span class="built_in">make</span>([][]<span class="keyword">int</span>, n + <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(rec); i++ &#123;</span><br><span class="line">        rec[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, n + <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(rec[i]); j++ &#123;</span><br><span class="line">            rec[i][j] = <span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> solve(<span class="number">0</span>, n + <span class="number">1</span>, val, rec)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">solve</span><span class="params">(left, right <span class="keyword">int</span>, val []<span class="keyword">int</span>, rec [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> left &gt;= right - <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> rec[left][right] != <span class="number">-1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rec[left][right]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := left + <span class="number">1</span>; i &lt; right; i++ &#123;</span><br><span class="line">        sum := val[left] * val[i] * val[right]</span><br><span class="line">        sum += solve(left, i, val, rec) + solve(i, right, val, rec)</span><br><span class="line">        rec[left][right] = max(rec[left][right], sum)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rec[left][right]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>记忆化搜索C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> rec[<span class="number">502</span>][<span class="number">502</span>];</span><br><span class="line"><span class="keyword">int</span> val[<span class="number">502</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rec[left][right] != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> rec[left][right];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt; right; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = val[left] * val[i] * val[right];</span><br><span class="line">        sum += solve(left, i) + solve(i, right);</span><br><span class="line">        rec[left][right] = fmax(rec[left][right], sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rec[left][right];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(rec, <span class="number">-1</span>, <span class="keyword">sizeof</span>(rec));</span><br><span class="line">    val[<span class="number">0</span>] = val[numsSize + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= numsSize; i++) &#123;</span><br><span class="line">        val[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> solve(<span class="number">0</span>, numsSize + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h1><p><strong>思路及算法</strong><br><a href="https://leetcode-cn.com/problems/burst-balloons/solution/chuo-qi-qiu-by-leetcode-solution/" target="_blank" rel="noopener">^1</a></p><p><strong>代码</strong></p><details>    <summary>动态规划C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; rec(n + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">2</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; val(n + <span class="number">2</span>);</span><br><span class="line">        val[<span class="number">0</span>] = val[n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            val[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">2</span>; j &lt;= n + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = val[i] * val[k] * val[j];</span><br><span class="line">                    sum += rec[i][k] + rec[k][j];</span><br><span class="line">                    rec[i][j] = max(rec[i][j], sum);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rec[<span class="number">0</span>][n + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[][] rec = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>][n + <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span>[] val = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>];</span><br><span class="line">        val[<span class="number">0</span>] = val[n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            val[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">2</span>; j &lt;= n + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = val[i] * val[k] * val[j];</span><br><span class="line">                    sum += rec[i][k] + rec[k][j];</span><br><span class="line">                    rec[i][j] = Math.max(rec[i][j], sum);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rec[<span class="number">0</span>][n + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划Python</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxCoins</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        rec = [[<span class="number">0</span>] * (n + <span class="number">2</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">2</span>)]</span><br><span class="line">        val = [<span class="number">1</span>] + nums + [<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">2</span>, n + <span class="number">2</span>):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(i + <span class="number">1</span>, j):</span><br><span class="line">                    total = val[i] * val[k] * val[j]</span><br><span class="line">                    total += rec[i][k] + rec[k][j]</span><br><span class="line">                    rec[i][j] = max(rec[i][j], total)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> rec[<span class="number">0</span>][n + <span class="number">1</span>]</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划Golang</summary><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxCoins</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    rec := <span class="built_in">make</span>([][]<span class="keyword">int</span>, n + <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n + <span class="number">2</span>; i++ &#123;</span><br><span class="line">        rec[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, n + <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    val := <span class="built_in">make</span>([]<span class="keyword">int</span>, n + <span class="number">2</span>)</span><br><span class="line">    val[<span class="number">0</span>], val[n+<span class="number">1</span>] = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        val[i] = nums[i<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="keyword">for</span> j := i + <span class="number">2</span>; j &lt;= n + <span class="number">1</span>; j++ &#123;</span><br><span class="line">            <span class="keyword">for</span> k := i + <span class="number">1</span>; k &lt; j; k++ &#123;</span><br><span class="line">                sum := val[i] * val[k] * val[j]</span><br><span class="line">                sum += rec[i][k] + rec[k][j]</span><br><span class="line">                rec[i][j] = max(rec[i][j], sum)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rec[<span class="number">0</span>][n+<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划C</summary><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rec[numsSize + <span class="number">2</span>][numsSize + <span class="number">2</span>];</span><br><span class="line">    <span class="built_in">memset</span>(rec, <span class="number">0</span>, <span class="keyword">sizeof</span>(rec));</span><br><span class="line">    <span class="keyword">int</span> val[numsSize + <span class="number">2</span>];</span><br><span class="line">    val[<span class="number">0</span>] = val[numsSize + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= numsSize; i++) &#123;</span><br><span class="line">        val[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = numsSize - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">2</span>; j &lt;= numsSize + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = val[i] * val[k] * val[j];</span><br><span class="line">                sum += rec[i][k] + rec[k][j];</span><br><span class="line">                rec[i][j] = fmax(rec[i][j], sum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rec[<span class="number">0</span>][numsSize + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年12月" scheme="http://yoursite.com/categories/2020%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Divide and Conquer" scheme="http://yoursite.com/tags/Divide-and-Conquer/"/>
    
  </entry>
  
  <entry>
    <title>406. 根据身高重建队列</title>
    <link href="http://yoursite.com/2020/12/23/406.%20%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2020/12/23/406. 根据身高重建队列/</id>
    <published>2020-12-23T08:12:12.000Z</published>
    <updated>2020-12-24T03:33:03.081Z</updated>
    
    <content type="html"><![CDATA[<p>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。</p><p>请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p><a id="more"></a><p>示例 1：</p><pre><code>输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]解释：编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。</code></pre><p>示例 2：</p><pre><code>输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]</code></pre><p>提示：</p><pre><code>1 &lt;= people.length &lt;= 20000 &lt;= hi &lt;= 1060 &lt;= ki &lt; people.length题目数据确保队列可以被重建</code></pre><h1 id="方法一：从低到高考虑"><a href="#方法一：从低到高考虑" class="headerlink" title="方法一：从低到高考虑"></a>方法一：从低到高考虑</h1><p><strong>思路与算法</strong></p><p>当每个人的身高都不相同时，如果我们将他们按照身高从小到大进行排序，那么就可以很方便地还原出原始的队列了。</p><p>为了叙述方便，我们设人数为 <em>n</em>，在进行排序后，它们的身高依次为h0,h1,…,hn-1 ，且排在第 <em>i</em> 个人前面身高<strong>大于</strong> <em>h_i</em> 的人数为 <em>k_i*。如果我们按照排完序后的顺序，依次将每个人放入队列中，那么当我们放入第 *i</em> 个人时：</p><ul><li><p>第 0,…,i-1 个人已经在队列中被安排了位置，并且他们无论站在哪里，对第 <em>i</em> 个人都没有任何影响，因为他们都比第 <em>i</em> 个人矮；</p></li><li><p>而第 i+1,…,n-1 个人还没有被放入队列中，但他们只要站在第 <em>i</em> 个人的前面，就会对第 <em>i</em> 个人产生影响，因为他们都比第 <em>i</em> 个人高。</p></li></ul><p>如果我们在初始时建立一个包含 <em>n</em> 个位置的空队列，而我们每次将一个人放入队列中时，会将一个「空」位置变成「满」位置，那么当我们放入第 <em>i</em> 个人时，我们需要给他安排一个「空」位置，并且这个「空」位置前面恰好还有 <em>k_i</em> 个「空」位置，用来安排给后面身高更高的人。也就是说，<strong>第 <em>i</em> 个人的位置，就是队列中从左往右数第 <em>k_i+1</em> 个「空」位置</strong>。</p><p>那么如果有身高相同的人，上述 <em>k_i</em> 定义中的<strong>大于</strong>就与题目描述中要求的<strong>大于等于</strong>不等价了，此时应该怎么修改上面的方法呢？我们可以这样想，如果第 <em>i</em> 个人和第 <em>j</em> 个人的身高相同，即 <em>h_i = h_j<em>，那么我们可以把在队列中处于较后位置的那个人的身高减小一点点。换句话说，对于某一个身高值 *h</em>，我们将队列中第一个身高为 *h</em> 的人保持不变，第二个身高为 <em>h</em> 的人的身高减少 delta，第三个身高为 <em>h</em> 的人的身高减少 2delta，以此类推，其中 delta  是一个很小的常数，它使得任何身高为 <em>h</em> 的人不会与其它（身高不为 <em>h</em> 的）人造成影响。</p><p>如何找到第一个、第二个、第三个身高为 <em>h</em> 的人呢？我们可以借助 <em>k</em> 值，可以发现：当 <em>h_i=h_j</em> 时，如果 <em>k_i &gt; k_j*，那么说明 *i</em> 一定相对于 <em>j</em> 在队列中处于较后的位置（因为在第 <em>j</em> 个人之前比他高的所有人，一定都比第 <em>i</em> 个人要高），按照修改之后的结果，<em>h_i</em> 略小于 <em>h_j*，第 *i</em> 个人在排序后应该先于第 <em>j</em> 个人被放入队列。因此，我们不必真的去对身高进行修改，而只需要按照 <em>h_i</em> 为第一关键字升序，<em>k_i</em> 为第二关键字降序进行排序即可。此时，具有相同身高的人会按照它们在队列中的位置逆序进行排列，也就间接实现了上面将身高减少 delta 这一操作的效果。</p><p>这样一来，我们只需要使用一开始提到的方法，将第 <em>i</em> 个人放入队列中的第 <em>k_i+1</em> 个空位置，即可得到原始的队列。</p><p><strong>代码</strong></p><details>    <summary>从低到高考虑C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; reconstructQueue(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        sort(people.begin(), people.end(), [](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; u, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v) &#123;</span><br><span class="line">            <span class="keyword">return</span> u[<span class="number">0</span>] &lt; v[<span class="number">0</span>] || (u[<span class="number">0</span>] == v[<span class="number">0</span>] &amp;&amp; u[<span class="number">1</span>] &gt; v[<span class="number">1</span>]);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> n = people.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; person: people) &#123;</span><br><span class="line">            <span class="keyword">int</span> spaces = person[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ans[i].empty()) &#123;</span><br><span class="line">                    --spaces;</span><br><span class="line">                    <span class="keyword">if</span> (!spaces) &#123;</span><br><span class="line">                        ans[i] = person;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>从低到高考虑Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] reconstructQueue(<span class="keyword">int</span>[][] people) &#123;</span><br><span class="line">        Arrays.sort(people, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] person1, <span class="keyword">int</span>[] person2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (person1[<span class="number">0</span>] != person2[<span class="number">0</span>]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> person1[<span class="number">0</span>] - person2[<span class="number">0</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> person2[<span class="number">1</span>] - person1[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> n = people.length;</span><br><span class="line">        <span class="keyword">int</span>[][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] person : people) &#123;</span><br><span class="line">            <span class="keyword">int</span> spaces = person[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ans[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    --spaces;</span><br><span class="line">                    <span class="keyword">if</span> (spaces == <span class="number">0</span>) &#123;</span><br><span class="line">                        ans[i] = person;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>从低到高考虑Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reconstructQueue</span><span class="params">(self, people: List[List[int]])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        people.sort(key=<span class="keyword">lambda</span> x: (x[<span class="number">0</span>], -x[<span class="number">1</span>]))</span><br><span class="line">        n = len(people)</span><br><span class="line">        ans = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> person <span class="keyword">in</span> people:</span><br><span class="line">            spaces = person[<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> ans[i]:</span><br><span class="line">                    spaces -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> spaces == <span class="number">0</span>:</span><br><span class="line">                        ans[i] = person</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>从低到高考虑Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reconstructQueue</span><span class="params">(people [][]<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    sort.Slice(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        a, b := people[i], people[j]</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>] || a[<span class="number">0</span>] == b[<span class="number">0</span>] &amp;&amp; a[<span class="number">1</span>] &gt; b[<span class="number">1</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">    ans := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="built_in">len</span>(people))</span><br><span class="line">    <span class="keyword">for</span> _, person := <span class="keyword">range</span> people &#123;</span><br><span class="line">        spaces := person[<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">range</span> ans &#123;</span><br><span class="line">            <span class="keyword">if</span> ans[i] == <span class="literal">nil</span> &#123;</span><br><span class="line">                spaces--</span><br><span class="line">                <span class="keyword">if</span> spaces == <span class="number">0</span> &#123;</span><br><span class="line">                    ans[i] = person</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>从低到高考虑C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* _a, <span class="keyword">const</span> <span class="keyword">void</span>* _b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *a = *(<span class="keyword">int</span>**)_a, *b = *(<span class="keyword">int</span>**)_b;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">0</span>] == b[<span class="number">0</span>] ? b[<span class="number">1</span>] - a[<span class="number">1</span>] : a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>** <span class="title">reconstructQueue</span><span class="params">(<span class="keyword">int</span>** people, <span class="keyword">int</span> peopleSize, <span class="keyword">int</span>* peopleColSize, <span class="keyword">int</span>* returnSize, <span class="keyword">int</span>** returnColumnSizes)</span> </span>&#123;</span><br><span class="line">    qsort(people, peopleSize, <span class="keyword">sizeof</span>(<span class="keyword">int</span>*), cmp);</span><br><span class="line">    <span class="keyword">int</span>** ans = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*) * peopleSize);</span><br><span class="line">    *returnSize = peopleSize;</span><br><span class="line">    *returnColumnSizes = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * peopleSize);</span><br><span class="line">    <span class="built_in">memset</span>(*returnColumnSizes, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * peopleSize);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; peopleSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> spaces = people[i][<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; peopleSize; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*returnColumnSizes)[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                spaces--;</span><br><span class="line">                <span class="keyword">if</span> (!spaces) &#123;</span><br><span class="line">                    (*returnColumnSizes)[j] = <span class="number">2</span>;</span><br><span class="line">                    ans[j] = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">2</span>);</span><br><span class="line">                    ans[j][<span class="number">0</span>] = people[i][<span class="number">0</span>], ans[j][<span class="number">1</span>] = people[i][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n^2)*，其中 *n</em> 是数组 people 的长度。我们需要O(nlogn) 的时间进行排序，随后需要 <em>O(n^2)</em> 的时间遍历每一个人并将他们放入队列中。由于前者在渐近意义下小于后者，因此总时间复杂度为 <em>O(n^2)</em>。</p></li><li><p>空间复杂度：O(logn) ，即为排序需要使用的栈空间。</p></li></ul><h1 id="方法二：从高到低考虑"><a href="#方法二：从高到低考虑" class="headerlink" title="方法二：从高到低考虑"></a>方法二：从高到低考虑</h1><p><strong>思路与算法</strong></p><p>同样地，我们也可以将每个人按照身高从大到小进行排序，处理身高相同的人使用的方法类似，即：按照 <em>h_i</em> 为第一关键字降序，<em>k_i</em> 为第二关键字升序进行排序。如果我们按照排完序后的顺序，依次将每个人放入队列中，那么当我们放入第 <em>i</em> 个人时：</p><ul><li><p>第 0,…,i-1 个人已经在队列中被安排了位置，他们只要站在第 <em>i</em> 个人的前面，就会对第 <em>i</em> 个人产生影响，因为他们都比第 <em>i</em> 个人高；</p></li><li><p>而第 i+1,…,n-1 个人还没有被放入队列中，并且他们无论站在哪里，对第 <em>i</em> 个人都没有任何影响，因为他们都比第 <em>i</em> 个人矮。</p></li></ul><p>在这种情况下，我们无从得知应该给后面的人安排多少个「空」位置，因此就不能沿用方法一。但我们可以发现，后面的人既然不会对第 <em>i</em> 个人造成影响，我们可以采用「插空」的方法，依次给每一个人在当前的队列中选择一个插入的位置。也就是说，当我们放入第 <em>i</em> 个人时，只需要将其插入队列中，使得他的前面恰好有 <em>k_i</em> 个人即可。</p><p><strong>代码</strong></p><details>    <summary>从高到低考虑C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; reconstructQueue(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        sort(people.begin(), people.end(), [](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; u, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v) &#123;</span><br><span class="line">            <span class="keyword">return</span> u[<span class="number">0</span>] &gt; v[<span class="number">0</span>] || (u[<span class="number">0</span>] == v[<span class="number">0</span>] &amp;&amp; u[<span class="number">1</span>] &lt; v[<span class="number">1</span>]);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; person: people) &#123;</span><br><span class="line">            ans.insert(ans.begin() + person[<span class="number">1</span>], person);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>从高到低考虑Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] reconstructQueue(<span class="keyword">int</span>[][] people) &#123;</span><br><span class="line">        Arrays.sort(people, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] person1, <span class="keyword">int</span>[] person2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (person1[<span class="number">0</span>] != person2[<span class="number">0</span>]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> person2[<span class="number">0</span>] - person1[<span class="number">0</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> person1[<span class="number">1</span>] - person2[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; ans = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] person : people) &#123;</span><br><span class="line">            ans.add(person[<span class="number">1</span>], person);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[ans.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>从高到低考虑Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reconstructQueue</span><span class="params">(self, people: List[List[int]])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        people.sort(key=<span class="keyword">lambda</span> x: (-x[<span class="number">0</span>], x[<span class="number">1</span>]))</span><br><span class="line">        n = len(people)</span><br><span class="line">        ans = list()</span><br><span class="line">        <span class="keyword">for</span> person <span class="keyword">in</span> people:</span><br><span class="line">            ans[person[<span class="number">1</span>]:person[<span class="number">1</span>]] = [person]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>从高到低考虑Golang</summary><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reconstructQueue</span><span class="params">(people [][]<span class="keyword">int</span>)</span> <span class="params">(ans [][]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    sort.Slice(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        a, b := people[i], people[j]</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &gt; b[<span class="number">0</span>] || a[<span class="number">0</span>] == b[<span class="number">0</span>] &amp;&amp; a[<span class="number">1</span>] &lt; b[<span class="number">1</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">for</span> _, person := <span class="keyword">range</span> people &#123;</span><br><span class="line">        idx := person[<span class="number">1</span>]</span><br><span class="line">        ans = <span class="built_in">append</span>(ans[:idx], <span class="built_in">append</span>([][]<span class="keyword">int</span>&#123;person&#125;, ans[idx:]...)...)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>从高到低考虑C</summary><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* _a, <span class="keyword">const</span> <span class="keyword">void</span>* _b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *a = *(<span class="keyword">int</span>**)_a, *b = *(<span class="keyword">int</span>**)_b;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">0</span>] == b[<span class="number">0</span>] ? a[<span class="number">1</span>] - b[<span class="number">1</span>] : b[<span class="number">0</span>] - a[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>** <span class="title">reconstructQueue</span><span class="params">(<span class="keyword">int</span>** people, <span class="keyword">int</span> peopleSize, <span class="keyword">int</span>* peopleColSize, <span class="keyword">int</span>* returnSize, <span class="keyword">int</span>** returnColumnSizes)</span> </span>&#123;</span><br><span class="line">    qsort(people, peopleSize, <span class="keyword">sizeof</span>(<span class="keyword">int</span>*), cmp);</span><br><span class="line">    <span class="keyword">int</span>** ans = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*) * peopleSize);</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    *returnColumnSizes = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * peopleSize);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; peopleSize; i++) &#123;</span><br><span class="line">        (*returnColumnSizes)[i] = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; peopleSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span>* person = people[i];</span><br><span class="line">        (*returnSize)++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = (*returnSize) - <span class="number">1</span>; j &gt; person[<span class="number">1</span>]; j--) &#123;</span><br><span class="line">            ans[j] = ans[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>* tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">2</span>);</span><br><span class="line">        tmp[<span class="number">0</span>] = person[<span class="number">0</span>], tmp[<span class="number">1</span>] = person[<span class="number">1</span>];</span><br><span class="line">        ans[person[<span class="number">1</span>]] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n^2)*，其中 *n</em> 是数组people 的长度。我们需要 O(nlogn)  的时间进行排序，随后需要 <em>O(n^2)</em> 的时间遍历每一个人并将他们放入队列中。由于前者在渐近意义下小于后者，因此总时间复杂度为 <em>O(n^2)</em>。</p></li><li><p>空间复杂度：O(logn) 。</p></li></ul><h1 id="方法三：拓扑排序"><a href="#方法三：拓扑排序" class="headerlink" title="方法三：拓扑排序"></a>方法三：拓扑排序</h1><p>每次都找第二个元素为0的最矮的人插入，然后将所有身高比这个人还矮的第二个元素减一，循环n次即可。</p><details>    <summary>拓扑排序C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; reconstructQueue(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; peo(people.begin(),people.end());</span><br><span class="line">        <span class="keyword">int</span> n=people.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(people[j][<span class="number">1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(temp==<span class="number">-1</span>) temp=j;</span><br><span class="line">                    <span class="keyword">else</span> temp=people[temp][<span class="number">0</span>]&lt;people[j][<span class="number">0</span>]?temp:j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(peo[temp]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(people[j][<span class="number">0</span>]&lt;=people[temp][<span class="number">0</span>]) people[j][<span class="number">1</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。&lt;/p&gt;
&lt;p&gt;请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年12月" scheme="http://yoursite.com/categories/2020%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Greedy" scheme="http://yoursite.com/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>301. 删除无效的括号</title>
    <link href="http://yoursite.com/2020/12/23/301.%20%E5%88%A0%E9%99%A4%E6%97%A0%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <id>http://yoursite.com/2020/12/23/301. 删除无效的括号/</id>
    <published>2020-12-23T07:57:12.000Z</published>
    <updated>2020-12-29T02:36:17.383Z</updated>
    
    <content type="html"><![CDATA[<p>删除最小数量的无效括号，使得输入的字符串有效，返回所有可能的结果。</p><p>说明: 输入可能包含了除 ( 和 ) 以外的字符。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: &quot;()())()&quot;输出: [&quot;()()()&quot;, &quot;(())()&quot;]</code></pre><p>示例 2:</p><pre><code>输入: &quot;(a)())()&quot;输出: [&quot;(a)()()&quot;, &quot;(a())()&quot;]</code></pre><p>示例 3:</p><pre><code>输入: &quot;)(&quot;输出: [&quot;&quot;]</code></pre><h1 id="方法一：回溯"><a href="#方法一：回溯" class="headerlink" title="方法一：回溯"></a>方法一：回溯</h1><p>对于这个问题，我们得到了一个由括号组成的表达式，并且表达式中可能有一些错误的括号或额外的括号，导致它无效。只有当每个右括号都有对应的左括号时，由括号组成的表达式才被视为有效，反之亦然。 </p><p>这意味着，如果我们从左到右查看每个括号，一旦遇到右括号，就应该有一个左括号来匹配它。否则表达式将变为无效。如果左括号的数目大于右括号的数目则表达式也无效。 </p><p>让我们看看一个无效的表达式和所有可能的有效表达式，这些表达式可以通过删除一些方括号从中形成。我们可以删除哪些括号没有限制。我们只需要使表达式有效。</p><blockquote><p>唯一的条件是，我们应该删除最小的括号数，使一个无效的表达式有效。如果不存在这个条件，我们可以潜在地删除大部分括号。</p></blockquote><p><a href="https://pic.leetcode-cn.com/8377829e1e0c5b30c0bef7aab047610d9c3810a0477aafa30dcebd4b11ca2b5b-image.png" target="_blank" rel="noopener">image.png</a></p><p>在上图中需要注意的一件重要的事情是，有多种方法可以达到相同的解，也就是说，为了使原始表达式有效，需要删除的括号的最佳数目是 k。我们可以删除多组不同的 k 括号，这些括号最终将给出相同的最终表达式。但是，每个有效表达式只应记录一次。我们必须在解决方案中解决这个问题。请注意，还有其他可能的方法可以达到上面所示的两个有效表达式之一。对于这两个有效表达式，我们只演示了三种方法。 </p><p>回到我们的问题上来，现在出现的问题是，如何决定要删除哪些括号？ </p><blockquote><p>因为我们不知道哪一个括号可能被删除，所以我们尝试了所有的选项！ </p></blockquote><p>对于每个括号，我们有两个选择：</p><ul><li>它可以被视为最终表达式的一部分</li><li>它可以被忽略，也就是说，我们可以从最终表达式中删除它。 </li></ul><blockquote><p>这样的问题，我们有多个选择，我们没有战略或指标来贪婪地决定选择哪一个选择，我们尝试了所有的选择，看看哪一个导致了答案。</p></blockquote><p>算法：</p><ol><li>初始化最终将存储所有有效表达式的数组。</li><li>从给定序列中最左边的括号开始，然后向右递归</li><li>递归状态由我们当前在原始表达式中处理的索引定义。让这个索引用字符 <code>i</code> 来表示。另外，我们有两个不同的变量 <code>left_count</code> 和 <code>right_count</code> ，它们表示我们到目前为止添加到表达式中的左括号和右括号的数目。这些是被考虑的括号。</li><li>如果当前字符，即 <code>s[i]</code>（考虑 s 是表达式字符串）既不是右括号也不是左括号，那么我们只需将此字符添加到当前递归的最终解决方案字符串中。  </li><li>但是，如果当前字符是两个方括号中的一个，即 <code>S[i] == &#39;(&#39; or S[i] == &#39;)&#39;</code>，则我们有两个选项。我们可以通过将此字符标记为无效字符来丢弃它，也可以将此括号视为最终表达式的一部分。 </li><li>当原始表达式中的所有括号都被处理后，我们只需检查 <code>expr</code> 表示的表达式是否有效，即到目前为止形成的表达式是否有效。我们检查最后一个表达式是否有效的方法是通过查看 <code>left_count</code> 和 <code>right_count</code> 的值。表达式必须是有效的 <code>left_count == right_count</code>。如果它确实有效，那么它可能是我们可能的解决方案之一。<ul><li>即使我们有一个有效的表达式，我们也需要跟踪我们为获得这个表达式所做的删除操作的数量。这是由另一个名为 <code>rem_count</code> 的递归中传递的变量完成的。</li><li>一旦递归完成，我们将检查 <code>rem_count</code> 的当前值是否小于我们迄今为止为形成有效表达式所采取的最少步骤数，即全局最小值。如果不是这样的话，我们不会记录新的表达式，否则我们会记录它。 </li></ul></li></ol><p>从实现的角度来看，我们可以做的一个小的优化就是在我们的算法中引入某种修剪。现在，我们只需到最后一步，即处理所有的括号，当我们处理完所有的括号后，我们检查我们的表达式是否可以被考虑。 </p><p>我们必须等到最后才决定递归中形成的表达式是否是有效的表达式。有没有一种方法可以让我们从早期的一些递归路径中切断，因为它们不会导致一个解决方案？答案是肯定的！优化基于以下思想。</p><p>对于递归过程中遇到的左括号，如果我们决定考虑它，那么它可能会导致或可能不会导致无效的最终表达式。如果后面没有匹配的右括号，最终可能导致表达式无效。但是，我们不确定这是否会发生。 </p><blockquote><p>但是，对于右括号，如果我们决定将其作为最终表达式的一部分保留（请记住，对于每个括号，我们都有两个选项，要么保留它，要么删除它并进一步递归），并且到目前为止表达式中没有对应的左括号来匹配它，那么无论之后做什么，它都肯定会导致无效表达式。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( (  ) ) )</span><br></pre></td></tr></table></figure><p>在这种情况下，第三个右括号将使表达式无效。不管之后会发生什么，这都会给我们一个无效的表达式，如果发生这种情况，我们不应该进一步递归，只需要修剪递归树。</p><p>这就是为什么，除了在我们当前正在处理的原始字符串/表达式中具有索引之外 ，并且到目前为止已经形成了表达式字符串之外，我们还跟踪左括号和右括号的数量。每当我们在表达式中保留左括号时，我们就增加它的计数器。对于右括号，我们检查 <code>right_count &lt; left_count</code>。如果是这种情况，那么我们只考虑右括号，并进一步递归。否则，我们不知道它会使表达式无效。这个简单的优化节省了很多运行时间。 </p><p>现在，让我们看看这个算法的实现。</p><details>    <summary>回溯Java</summary><figure class="highlight java"><figcaption><span>[ ]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Set&lt;String&gt; validExpressions = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> minimumRemoved;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.validExpressions.clear();</span><br><span class="line">    <span class="keyword">this</span>.minimumRemoved = Integer.MAX_VALUE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recurse</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      String s,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> index,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> leftCount,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> rightCount,</span></span></span><br><span class="line"><span class="function"><span class="params">      StringBuilder expression,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> removedCount)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we have reached the end of string.</span></span><br><span class="line">    <span class="keyword">if</span> (index == s.length()) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If the current expression is valid.</span></span><br><span class="line">      <span class="keyword">if</span> (leftCount == rightCount) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the current count of removed parentheses is &lt;= the current minimum count</span></span><br><span class="line">        <span class="keyword">if</span> (removedCount &lt;= <span class="keyword">this</span>.minimumRemoved) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Convert StringBuilder to a String. This is an expensive operation.</span></span><br><span class="line">          <span class="comment">// So we only perform this when needed.</span></span><br><span class="line">          String possibleAnswer = expression.toString();</span><br><span class="line"></span><br><span class="line">          <span class="comment">// If the current count beats the overall minimum we have till now</span></span><br><span class="line">          <span class="keyword">if</span> (removedCount &lt; <span class="keyword">this</span>.minimumRemoved) &#123;</span><br><span class="line">            <span class="keyword">this</span>.validExpressions.clear();</span><br><span class="line">            <span class="keyword">this</span>.minimumRemoved = removedCount;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">this</span>.validExpressions.add(possibleAnswer);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">char</span> currentCharacter = s.charAt(index);</span><br><span class="line">      <span class="keyword">int</span> length = expression.length();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If the current character is neither an opening bracket nor a closing one,</span></span><br><span class="line">      <span class="comment">// simply recurse further by adding it to the expression StringBuilder</span></span><br><span class="line">      <span class="keyword">if</span> (currentCharacter != <span class="string">'('</span> &amp;&amp; currentCharacter != <span class="string">')'</span>) &#123;</span><br><span class="line">        expression.append(currentCharacter);</span><br><span class="line">        <span class="keyword">this</span>.recurse(s, index + <span class="number">1</span>, leftCount, rightCount, expression, removedCount);</span><br><span class="line">        expression.deleteCharAt(length);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Recursion where we delete the current character and move forward</span></span><br><span class="line">        <span class="keyword">this</span>.recurse(s, index + <span class="number">1</span>, leftCount, rightCount, expression, removedCount + <span class="number">1</span>);</span><br><span class="line">        expression.append(currentCharacter);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If it's an opening parenthesis, consider it and recurse</span></span><br><span class="line">        <span class="keyword">if</span> (currentCharacter == <span class="string">'('</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.recurse(s, index + <span class="number">1</span>, leftCount + <span class="number">1</span>, rightCount, expression, removedCount);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rightCount &lt; leftCount) &#123;</span><br><span class="line">          <span class="comment">// For a closing parenthesis, only recurse if right &lt; left</span></span><br><span class="line">          <span class="keyword">this</span>.recurse(s, index + <span class="number">1</span>, leftCount, rightCount + <span class="number">1</span>, expression, removedCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Undoing the append operation for other recursions.</span></span><br><span class="line">        expression.deleteCharAt(length);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">removeInvalidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.reset();</span><br><span class="line">    <span class="keyword">this</span>.recurse(s, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">new</span> StringBuilder(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList(<span class="keyword">this</span>.validExpressions);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>回溯Python</summary><figure class="highlight python"><figcaption><span>[ ]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.valid_expressions = <span class="keyword">None</span></span><br><span class="line">        self.min_removed = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reset</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.valid_expressions = set()</span><br><span class="line">        self.min_removed = float(<span class="string">"inf"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        string: The original string we are recursing on.</span></span><br><span class="line"><span class="string">        index: current index in the original string.</span></span><br><span class="line"><span class="string">        left: number of left parentheses till now.</span></span><br><span class="line"><span class="string">        right: number of right parentheses till now.</span></span><br><span class="line"><span class="string">        ans: the resulting expression in this particular recursion.</span></span><br><span class="line"><span class="string">        ignored: number of parentheses ignored in this particular recursion.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remaining</span><span class="params">(self, string, index, left_count, right_count, expr, rem_count)</span>:</span></span><br><span class="line">        <span class="comment"># If we have reached the end of string.</span></span><br><span class="line">        <span class="keyword">if</span> index == len(string):</span><br><span class="line"></span><br><span class="line">            <span class="comment"># If the current expression is valid. The only scenario where it can be</span></span><br><span class="line">            <span class="comment"># invalid here is if left &gt; right. The other way around we handled early on in the recursion.</span></span><br><span class="line">            <span class="keyword">if</span> left_count == right_count:</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> rem_count &lt;= self.min_removed:</span><br><span class="line">                    <span class="comment"># This is the resulting expression.</span></span><br><span class="line">                    <span class="comment"># Strings are immutable in Python so we move around a list in the recursion</span></span><br><span class="line">                    <span class="comment"># and eventually join to get the final string.</span></span><br><span class="line">                    possible_ans = <span class="string">""</span>.join(expr)</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># If the current count of brackets removed &lt; current minimum, ignore</span></span><br><span class="line">                    <span class="comment"># previous answers and update the current minimum count.</span></span><br><span class="line">                    <span class="keyword">if</span> rem_count &lt; self.min_removed:</span><br><span class="line">                        self.valid_expressions = set()</span><br><span class="line">                        self.min_removed = rem_count</span><br><span class="line"></span><br><span class="line">                    self.valid_expressions.add(possible_ans)    </span><br><span class="line">        <span class="keyword">else</span>:        </span><br><span class="line"></span><br><span class="line">            current_char = string[index]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># If the current character is not a parenthesis, just recurse one step ahead.</span></span><br><span class="line">            <span class="keyword">if</span> current_char != <span class="string">'('</span> <span class="keyword">and</span>  current_char != <span class="string">')'</span>:</span><br><span class="line">                expr.append(current_char)</span><br><span class="line">                self.remaining(string, index + <span class="number">1</span>, left_count, right_count, expr, rem_count)</span><br><span class="line">                expr.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># Else, one recursion is with ignoring the current character.</span></span><br><span class="line">                <span class="comment"># So, we increment the ignored counter and leave the left and right untouched.</span></span><br><span class="line">                self.remaining(string, index + <span class="number">1</span>, left_count, right_count, expr, rem_count + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">                expr.append(current_char)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># If the current parenthesis is an opening bracket, we consider it</span></span><br><span class="line">                <span class="comment"># and increment left and  move forward</span></span><br><span class="line">                <span class="keyword">if</span> string[index] == <span class="string">'('</span>:</span><br><span class="line">                    self.remaining(string, index + <span class="number">1</span>, left_count + <span class="number">1</span>, right_count, expr, rem_count)</span><br><span class="line">                <span class="keyword">elif</span> right_count &lt; left_count:</span><br><span class="line">                    <span class="comment"># If the current parenthesis is a closing bracket, we consider it only if we</span></span><br><span class="line">                    <span class="comment"># have more number of opening brackets and increment right and move forward.</span></span><br><span class="line">                    self.remaining(string, index + <span class="number">1</span>, left_count, right_count + <span class="number">1</span>, expr, rem_count)</span><br><span class="line"></span><br><span class="line">                expr.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeInvalidParentheses</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Reset the class level variables that we use for every test case.</span></span><br><span class="line">        self.reset()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Recursive call</span></span><br><span class="line">        self.remaining(s, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, [], <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> list(self.valid_expressions)</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(2^N)*。因为在最坏的情况下，表达式中只有左括号，对于每个括号，我们都有两个选项，即是删除还是考虑它。考虑到表达式有 *N</em> 括号，时间复杂性将为<em>O(2^N)</em>。 </li><li>空间复杂度：<em>O(N)</em>，因为我们使用的是递归解决方案，对于递归解决方案，在递归过程中，始终有堆栈空间用作内部函数状态保存到堆栈中。递归的最大深度决定了所使用的堆栈空间。因为我们一次处理一个字符，而递归的基本情况是当我们处理完表达式字符串的所有字符时，堆栈的大小将为 <em>O(n)</em>。注意，我们不考虑存储有效表达式所需的空间。我们只计算中间过程的空间。 </li></ul><h1 id="方法二：有限的回溯"><a href="#方法二：有限的回溯" class="headerlink" title="方法二：有限的回溯"></a>方法二：有限的回溯</h1><p>虽然之前的解决方案在平台上得到了认可，但这是一个非常低效的解决方案，因为我们尝试从表达式中删除每个可能的括号，最后我们检查两件事： </p><ol><li>表达式有效或无效 </li><li>当前递归中删除的括号总数是否小于当前为止的全局最小值。 </li></ol><p>我们无法确定哪一个括号放错了位置，在问题陈述提出 我们可以删除多个括号组合，最后得到一个有效的表达式。这意味着一个无效表达式可以有多个有效表达式，我们必须找到所有这些表达式。 </p><blockquote><p>所有这些有效表达式的一个共同点是，它们的长度都相同，即与原始表达式相比，所有这些表达式都将删除相同数量的字符。 </p></blockquote><p>如果我们能确定这个数呢？ </p><p>如果除了确定要删除的字符数之外，我们还可以确定要从原始表达式中删除的左括号数和右括号数，以获得任何有效的表达式呢？ </p><p>这将极大地减少计算量，从而导致运行时急剧下降。这样做的原因是，如果我们知道要从原始表达式中删除多少左括号和右括号以获得有效的表达式，那么我们将减少不需要的递归调用。 </p><p>假设原始表达式是 1000个字符，其中只有 3 个放错了位置 <code>(</code> 括号和 2 个放错了位置的 <code>)</code> 括号。在前面的解决方案中，我们最终将尝试删除左括号和右括号中的每一个，并尝试在末尾达到有效的表达式，而我们只应尝试删除 3 个 <code>(</code> 括号和 2 个 <code>)</code>括号。 </p><blockquote><p>我们需要不多不少的获取有效表达式必须删除的 <code>(</code> 和 <code>)</code> 的确切数目。 </p></blockquote><p>让我们先看看如何找出给定表达式中左括号和右括号放错的数目，然后我们将稍微修改原始算法以合并这些计数。</p><ol><li>我们从左边开始，一次处理一个括号的表达式。 </li><li>假设我们遇到一个左括号，即 <code>(</code> ，它可能会导致或可能不会导致一个无效的表达式，因为表达式的其余部分的某个地方可能有一个匹配的右括号。这里，我们只需增加计数器来跟踪左括号的出现次数。<code>left += 1</code></li><li>如果我们遇到一个右括号，这有两个含义： <ul><li>要么是这个右括号没有匹配的左括号，在这种情况下，该表达式是无效的。当 <code>left == 0</code> 时，即没有不匹配的左括号可用时，就是这种情况。在这种情况下，我们增加另一个计数器叫 <code>right+=1</code>来表示放错了位置的右括号。</li><li>或者，我们有一些未匹配的左括号来匹配这个右括号。当 <code>left &gt; 0</code> 时就是这样。在这种情况下，我们只需减小我们使用的 <code>left</code> 计数器，即 <code>left -= 1</code>。</li></ul></li><li>继续处理字符串，直到处理完所有括号。</li><li>最后，左括号和右括号的值分别告诉我们不匹配 <code>(</code> 和 <code>)</code> 括号的数目。 </li></ol><p>现在我们有了这两个值，它们告诉我们为了使无效表达式有效而必须删除的左括号（和右括号）的总数，我们将修改上一个会话中讨论的原始算法，以避免不必要的递归。</p><p><strong>算法：</strong><br>整个算法与以前完全相同。我们将纳入的变更如下：</p><ul><li>递归的状态现在由五个不同的变量定义：<ol><li><code>index</code> 它表示我们必须在原始字符串中处理的当前字符。 </li><li><code>left_count</code> 它表示添加到我们正在构建的表达式中的左括号数。 </li><li><code>right_count</code> 它表示添加到我们正在构建的表达式中的右括号数。 </li><li><code>left_rem</code> 是要删除的左括号数。 </li><li><code>right_rem</code>  表示保留要删除的右括号数。总的来说，为了使最终表达式有效，<code>left_rem == 0</code> 和 <code>right_rem == 0</code>。 </li></ol></li><li>当我们决定不考虑括号时，即删除括号，不管是左括号还是右括号，我们也必须考虑它们相应的剩余计数。这意味着，如果 <code>left_rem &gt; 0</code>，我们只能放弃左括号；同样，对于右括号，我们将检查 <code>right_rem &gt; 0</code>。 </li><li>检查括号没有变化。只有丢弃圆括号的条件才会改变。</li><li>表达式在基本情况下有效的条件现在将变为<code>left_rem == 0 and right_rem == 0</code>。注意，我们不必再检查 <code>left_count == right_count</code> 了，因为在有效表达式的情况下，在递归结束时，我们会删除所有放错位置或无效的括号。所以，只有当 <code>left_rem == 0 and right_rem == 0</code> 时，我们才需要检查。 <blockquote><p>这里最重要的是，我们已经完全摆脱了检查移除的括号数量是否小于当前的最小值。这样做的原因是我们总是在递归开始时删除相同数量的括号，这些括号是由 <code>left_rem + right_rem</code> 定义的。 </p></blockquote></li></ul><p>现在让我们看看这个修改过的算法版本的实现。</p><details>    <summary>有限的回溯Java</summary><figure class="highlight java"><figcaption><span>[ ]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Set&lt;String&gt; validExpressions = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recurse</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      String s,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> index,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> leftCount,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> rightCount,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> leftRem,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> rightRem,</span></span></span><br><span class="line"><span class="function"><span class="params">      StringBuilder expression)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we reached the end of the string, just check if the resulting expression is</span></span><br><span class="line">    <span class="comment">// valid or not and also if we have removed the total number of left and right</span></span><br><span class="line">    <span class="comment">// parentheses that we should have removed.</span></span><br><span class="line">    <span class="keyword">if</span> (index == s.length()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (leftRem == <span class="number">0</span> &amp;&amp; rightRem == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.validExpressions.add(expression.toString());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">char</span> character = s.charAt(index);</span><br><span class="line">      <span class="keyword">int</span> length = expression.length();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// The discard case. Note that here we have our pruning condition.</span></span><br><span class="line">      <span class="comment">// We don't recurse if the remaining count for that parenthesis is == 0.</span></span><br><span class="line">      <span class="keyword">if</span> ((character == <span class="string">'('</span> &amp;&amp; leftRem &gt; <span class="number">0</span>) || (character == <span class="string">')'</span> &amp;&amp; rightRem &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.recurse(</span><br><span class="line">            s,</span><br><span class="line">            index + <span class="number">1</span>,</span><br><span class="line">            leftCount,</span><br><span class="line">            rightCount,</span><br><span class="line">            leftRem - (character == <span class="string">'('</span> ? <span class="number">1</span> : <span class="number">0</span>),</span><br><span class="line">            rightRem - (character == <span class="string">')'</span> ? <span class="number">1</span> : <span class="number">0</span>),</span><br><span class="line">            expression);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      expression.append(character);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Simply recurse one step further if the current character is not a parenthesis.</span></span><br><span class="line">      <span class="keyword">if</span> (character != <span class="string">'('</span> &amp;&amp; character != <span class="string">')'</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.recurse(s, index + <span class="number">1</span>, leftCount, rightCount, leftRem, rightRem, expression);</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (character == <span class="string">'('</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Consider an opening bracket.</span></span><br><span class="line">        <span class="keyword">this</span>.recurse(s, index + <span class="number">1</span>, leftCount + <span class="number">1</span>, rightCount, leftRem, rightRem, expression);</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rightCount &lt; leftCount) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Consider a closing bracket.</span></span><br><span class="line">        <span class="keyword">this</span>.recurse(s, index + <span class="number">1</span>, leftCount, rightCount + <span class="number">1</span>, leftRem, rightRem, expression);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Delete for backtracking.</span></span><br><span class="line">      expression.deleteCharAt(length);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">removeInvalidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// First, we find out the number of misplaced left and right parentheses.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Simply record the left one.</span></span><br><span class="line">      <span class="keyword">if</span> (s.charAt(i) == <span class="string">'('</span>) &#123;</span><br><span class="line">        left++;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">')'</span>) &#123;</span><br><span class="line">        <span class="comment">// If we don't have a matching left, then this is a misplaced right, record it.</span></span><br><span class="line">        right = left == <span class="number">0</span> ? right + <span class="number">1</span> : right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Decrement count of left parentheses because we have found a right</span></span><br><span class="line">        <span class="comment">// which CAN be a matching one for a left.</span></span><br><span class="line">        left = left &gt; <span class="number">0</span> ? left - <span class="number">1</span> : left;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.recurse(s, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, left, right, <span class="keyword">new</span> StringBuilder());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="keyword">this</span>.validExpressions);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>有限的回溯Python</summary><figure class="highlight python"><figcaption><span>[ ]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeInvalidParentheses</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># First, we find out the number of misplaced left and right parentheses.</span></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Simply record the left one.</span></span><br><span class="line">            <span class="keyword">if</span> char == <span class="string">'('</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> char == <span class="string">')'</span>:</span><br><span class="line">                <span class="comment"># If we don't have a matching left, then this is a misplaced right, record it.</span></span><br><span class="line">                right = right + <span class="number">1</span> <span class="keyword">if</span> left == <span class="number">0</span> <span class="keyword">else</span> right</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Decrement count of left parentheses because we have found a right</span></span><br><span class="line">                <span class="comment"># which CAN be a matching one for a left.</span></span><br><span class="line">                left = left - <span class="number">1</span> <span class="keyword">if</span> left &gt; <span class="number">0</span> <span class="keyword">else</span> left</span><br><span class="line"></span><br><span class="line">        result = &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recurse</span><span class="params">(s, index, left_count, right_count, left_rem, right_rem, expr)</span>:</span></span><br><span class="line">            <span class="comment"># If we reached the end of the string, just check if the resulting expression is</span></span><br><span class="line">            <span class="comment"># valid or not and also if we have removed the total number of left and right</span></span><br><span class="line">            <span class="comment"># parentheses that we should have removed.</span></span><br><span class="line">            <span class="keyword">if</span> index == len(s):</span><br><span class="line">                <span class="keyword">if</span> left_rem == <span class="number">0</span> <span class="keyword">and</span> right_rem == <span class="number">0</span>:</span><br><span class="line">                    ans = <span class="string">""</span>.join(expr)</span><br><span class="line">                    result[ans] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">                <span class="comment"># The discard case. Note that here we have our pruning condition.</span></span><br><span class="line">                <span class="comment"># We don't recurse if the remaining count for that parenthesis is == 0.</span></span><br><span class="line">                <span class="keyword">if</span> (s[index] == <span class="string">'('</span> <span class="keyword">and</span> left_rem &gt; <span class="number">0</span>) <span class="keyword">or</span> (s[index] == <span class="string">')'</span> <span class="keyword">and</span> right_rem &gt; <span class="number">0</span>):</span><br><span class="line">                    recurse(s, index + <span class="number">1</span>,</span><br><span class="line">                            left_count,</span><br><span class="line">                            right_count,</span><br><span class="line">                            left_rem - (s[index] == <span class="string">'('</span>),</span><br><span class="line">                            right_rem - (s[index] == <span class="string">')'</span>), expr)</span><br><span class="line"></span><br><span class="line">                expr.append(s[index])    </span><br><span class="line"></span><br><span class="line">                <span class="comment"># Simply recurse one step further if the current character is not a parenthesis.</span></span><br><span class="line">                <span class="keyword">if</span> s[index] != <span class="string">'('</span> <span class="keyword">and</span> s[index] != <span class="string">')'</span>:</span><br><span class="line">                    recurse(s, index + <span class="number">1</span>,</span><br><span class="line">                            left_count,</span><br><span class="line">                            right_count,</span><br><span class="line">                            left_rem,</span><br><span class="line">                            right_rem, expr)</span><br><span class="line">                <span class="keyword">elif</span> s[index] == <span class="string">'('</span>:</span><br><span class="line">                    <span class="comment"># Consider an opening bracket.</span></span><br><span class="line">                    recurse(s, index + <span class="number">1</span>,</span><br><span class="line">                            left_count + <span class="number">1</span>,</span><br><span class="line">                            right_count,</span><br><span class="line">                            left_rem,</span><br><span class="line">                            right_rem, expr)</span><br><span class="line">                <span class="keyword">elif</span> s[index] == <span class="string">')'</span> <span class="keyword">and</span> left_count &gt; right_count:</span><br><span class="line">                    <span class="comment"># Consider a closing bracket.</span></span><br><span class="line">                    recurse(s, index + <span class="number">1</span>,</span><br><span class="line">                            left_count,</span><br><span class="line">                            right_count + <span class="number">1</span>,</span><br><span class="line">                            left_rem,</span><br><span class="line">                            right_rem, expr)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Pop for backtracking.</span></span><br><span class="line">                expr.pop()                 </span><br><span class="line"></span><br><span class="line">        <span class="comment"># Now, the left and right variables tell us the number of misplaced left and</span></span><br><span class="line">        <span class="comment"># right parentheses and that greatly helps pruning the recursion.</span></span><br><span class="line">        recurse(s, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, left, right, [])     </span><br><span class="line">        <span class="keyword">return</span> list(result.keys())</span><br></pre></td></tr></table></figure></details><h1 id="回溯简明版"><a href="#回溯简明版" class="headerlink" title="回溯简明版"></a>回溯简明版</h1><details>    <summary>回溯简明版Java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用集合存储所有正确的字符串，可避免重复</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">removeInvalidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] ss = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> open = <span class="number">0</span>, close = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 获取应该去除的左右括号数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : ss) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'('</span>) open ++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">')'</span>)</span><br><span class="line">                <span class="keyword">if</span> (open &gt; <span class="number">0</span>) open --;</span><br><span class="line">                <span class="keyword">else</span> close ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        backTracking(ss, <span class="keyword">new</span> StringBuilder(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, open, close);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList(set);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(<span class="keyword">char</span>[] ss, StringBuilder sb, <span class="keyword">int</span> index, <span class="keyword">int</span> open, <span class="keyword">int</span> close, <span class="keyword">int</span> openRem, <span class="keyword">int</span> closeRem)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 回溯函数</span></span><br><span class="line"><span class="comment">         * 分别对字符串中的每一位置的字符进行处理，最终获得符合要求的字符串加入集合中</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> ss 字符串对应的字符数组</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> sb 储存当前处理过且未去除字符的字符串</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> index 当前处理的字符位置</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> open 当前sb中储存的左括号数</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> close 当前sb中储存的右括号数</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> openRem 当前需要去除的左括号数</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> closeRem 当前需要去除的右括号数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 所有字符都处理完毕</span></span><br><span class="line">        <span class="keyword">if</span> (index == ss.length) &#123;</span><br><span class="line">            <span class="comment">// 如果应去除的左右括号数都变为0，则将sb插入set</span></span><br><span class="line">            <span class="keyword">if</span> (openRem == <span class="number">0</span> &amp;&amp; closeRem == <span class="number">0</span>)</span><br><span class="line">                set.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 去掉当前位置的字符（括号），并处理下一个字符</span></span><br><span class="line">        <span class="keyword">if</span> (ss[index] == <span class="string">'('</span> &amp;&amp; openRem &gt; <span class="number">0</span> || ss[index] == <span class="string">')'</span> &amp;&amp; closeRem &gt; <span class="number">0</span>)</span><br><span class="line">            backTracking(ss, sb, index + <span class="number">1</span>, open, close, openRem - (ss[index] == <span class="string">'('</span> ? <span class="number">1</span> : <span class="number">0</span>), closeRem - (ss[index] == <span class="string">')'</span> ? <span class="number">1</span> : <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 不去掉当前位置字符</span></span><br><span class="line">        <span class="comment">// 将当前位置字符插入sb</span></span><br><span class="line">        sb.append(ss[index]);</span><br><span class="line">        <span class="comment">// 当前位置不为括号，则直接处理下一个字符</span></span><br><span class="line">        <span class="keyword">if</span> (ss[index] != <span class="string">'('</span> &amp;&amp; ss[index] != <span class="string">')'</span>)</span><br><span class="line">            backTracking(ss, sb, index + <span class="number">1</span>, open, close, openRem, closeRem);</span><br><span class="line">        <span class="comment">// 当前位置为左括号，增加左括号计数，处理下一个字符</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ss[index] == <span class="string">'('</span>)</span><br><span class="line">            backTracking(ss, sb, index + <span class="number">1</span>, open + <span class="number">1</span>, close, openRem, closeRem);</span><br><span class="line">        <span class="comment">// 当前位置为右括号，且当前左括号计数大于右括号计数，则增加右括号计数，处理下一个字符</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (open &gt; close) </span><br><span class="line">            backTracking(ss, sb, index + <span class="number">1</span>, open, close + <span class="number">1</span>, openRem, closeRem);</span><br><span class="line">        <span class="comment">// 去除当前加入sb的字符</span></span><br><span class="line">        sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：我们所执行的优化只是一种更好的修剪形式。在最坏的情况下，我们可以有 <code>(((((((((</code> 和 <code>left_rem = len(S)</code> 和在这种情况下我们可以丢弃所有字符，因为所有字符都放错了位置。在最坏的情况下，每个括号中仍然有两个选项，这给了我们 <em>O(2^n)</em> 的复杂性。 </li><li>空间复杂度：空间复杂性与以前的解决方案保持相同，即 <em>O(N)*。 在到达基本情况之前，我们必须达到 *N</em> 的最大递归深度。注意，我们不考虑存储有效表达式所需的空间。我们只计算中间过程空间。</li></ul><h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><details>    <summary>广度优先遍历</summary><pre><code class="java"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">removeInvalidParentheses</span><span class="params">(String s)</span> </span>{        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();        List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();        set.add(s);        <span class="keyword">while</span> (<span class="keyword">true</span>) {            <span class="keyword">for</span> (String str : set) {                <span class="keyword">if</span> (isRegular(str))                    ans.add(str);            }            <span class="keyword">if</span> (ans.size() &gt; <span class="number">0</span>) <span class="keyword">return</span> ans;            Set&lt;String&gt; nextSet = <span class="keyword">new</span> HashSet&lt;&gt;();            <span class="keyword">for</span> (String str : set) {                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i ++) {                    <span class="keyword">if</span> (str.charAt(i) == <span class="string">'('</span> || str.charAt(i) == <span class="string">')'</span>)                        nextSet.add(str.substring(<span class="number">0</span>, i) + str.substring(i + <span class="number">1</span>, str.length()));                }            }            set = nextSet;        }    }    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRegular</span><span class="params">(String s)</span> </span>{        <span class="keyword">char</span>[] ss = s.toCharArray();        <span class="keyword">int</span> count = <span class="number">0</span>;        <span class="keyword">for</span> (<span class="keyword">char</span> c : ss) {            <span class="keyword">if</span> (c == <span class="string">'('</span>) count ++;            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">')'</span>) count --;            <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;        }        <span class="keyword">return</span> count == <span class="number">0</span>;    }}</code></pre></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;删除最小数量的无效括号，使得输入的字符串有效，返回所有可能的结果。&lt;/p&gt;
&lt;p&gt;说明: 输入可能包含了除 ( 和 ) 以外的字符。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年12月" scheme="http://yoursite.com/categories/2020%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Breadth-first Search" scheme="http://yoursite.com/tags/Breadth-first-Search/"/>
    
      <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>76. 最小覆盖子串</title>
    <link href="http://yoursite.com/2020/12/17/76.%20%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/2020/12/17/76. 最小覆盖子串/</id>
    <published>2020-12-17T02:54:12.000Z</published>
    <updated>2020-12-23T07:51:07.521Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p><a id="more"></a><p>注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。</p><p>示例 1：</p><p>输入：s = “ADOBECODEBANC”, t = “ABC”<br>输出：”BANC”<br>示例 2：</p><p>输入：s = “a”, t = “a”<br>输出：”a”</p><p>提示：</p><p>1 &lt;= s.length, t.length &lt;= 105<br>s 和 t 由英文字母组成</p><p>进阶：你能设计一个在 o(n) 时间内解决此问题的算法吗？</p><h1 id="📺-视频题解"><a href="#📺-视频题解" class="headerlink" title="📺 视频题解"></a>📺 视频题解</h1><p><a href="37fa6129-0eb2-4c1f-a75b-152e1d6b2f5e">76. 最小覆盖子串.mp4</a></p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="方法一：滑动窗口"><a href="#方法一：滑动窗口" class="headerlink" title="方法一：滑动窗口"></a>方法一：滑动窗口</h2><p><strong>思路和算法</strong></p><p>本问题要求我们返回字符串 <em>s</em> 中包含字符串 <em>t</em> 的全部字符的最小窗口。我们称包含 <em>t</em> 的全部字母的窗口为「可行」窗口。</p><p>我们可以用滑动窗口的思想解决这个问题，在滑动窗口类型的问题中都会有两个指针。一个用于「延伸」现有窗口的 <em>r</em> 指针，和一个用于「收缩」窗口的 <em>l</em> 指针。在任意时刻，只有一个指针运动，而另一个保持静止。<strong>我们在 <em>s</em> 上滑动窗口，通过移动 <em>r</em> 指针不断扩张窗口。当窗口包含 <em>t</em> 全部所需的字符后，如果能收缩，我们就收缩窗口直到得到最小窗口。</strong></p><p> <a href="https://assets.leetcode-cn.com/solution-static/76/76_fig1.gif" target="_blank" rel="noopener">fig1</a></p><p>如何判断当前的窗口包含所有 <em>t</em> 所需的字符呢？我们可以用一个哈希表表示 <em>t</em> 中所有的字符以及它们的个数，用一个哈希表动态维护窗口中所有的字符以及它们的个数，如果这个动态表中包含 <em>t</em> 的哈希表中的所有字符，并且对应的个数都不小于 <em>t</em> 的哈希表中各个字符的个数，那么当前的窗口是「可行」的。</p><p><strong>注意：这里 <em>t</em> 中可能出现重复的字符，所以我们要记录字符的个数。</strong></p><p><strong>考虑如何优化？</strong> 如果 s=XX…XABCXXXX ， t=ABC ，那么显然 [XX…XABC] 是第一个得到的「可行」区间，得到这个可行区间后，我们按照「收缩」窗口的原则更新左边界，得到最小区间。我们其实做了一些无用的操作，就是更新右边界的时候「延伸」进了很多无用的 X ，更新左边界的时候「收缩」扔掉了这些无用的 X ，做了这么多无用的操作，只是为了得到短短的 ABC。没错，其实在 <em>s</em> 中，有的字符我们是不关心的，我们只关心 <em>t</em> 中出现的字符，我们可不可以先预处理 <em>s</em>，扔掉那些 <em>t</em> 中没有出现的字符，然后再做滑动窗口呢？也许你会说，这样可能出现 XXABXXC 的情况，在统计长度的时候可以扔掉前两个 X，但是不扔掉中间的 X ，怎样解决这个问题呢？优化后的时空复杂度又是多少？<strong>这里代码给出没有优化的版本，以上的三个问题留给读者思考。</strong></p><p><strong>代码</strong></p><details>    <summary>C++</summary><figure class="highlight cpp"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span> &lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; ori, cnt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p: ori) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[p.first] &lt; p.second) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;c: t) &#123;</span><br><span class="line">            ++ori[c];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> len = INT_MAX, ansL = <span class="number">-1</span>, ansR = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (r &lt; <span class="keyword">int</span>(s.size())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ori.find(s[++r]) != ori.end()) &#123;</span><br><span class="line">                ++cnt[s[r]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (check() &amp;&amp; l &lt;= r) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r - l + <span class="number">1</span> &lt; len) &#123;</span><br><span class="line">                    len = r - l + <span class="number">1</span>;</span><br><span class="line">                    ansL = l;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ori.find(s[l]) != ori.end()) &#123;</span><br><span class="line">                    --cnt[s[l]];</span><br><span class="line">                &#125;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ansL == <span class="number">-1</span> ? <span class="built_in">string</span>() : s.substr(ansL, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; ori = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">    Map&lt;Character, Integer&gt; cnt = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tLen = t.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tLen; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = t.charAt(i);</span><br><span class="line">            ori.put(c, ori.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len = Integer.MAX_VALUE, ansL = -<span class="number">1</span>, ansR = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sLen = s.length();</span><br><span class="line">        <span class="keyword">while</span> (r &lt; sLen) &#123;</span><br><span class="line">            ++r;</span><br><span class="line">            <span class="keyword">if</span> (r &lt; sLen &amp;&amp; ori.containsKey(s.charAt(r))) &#123;</span><br><span class="line">                cnt.put(s.charAt(r), cnt.getOrDefault(s.charAt(r), <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (check() &amp;&amp; l &lt;= r) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r - l + <span class="number">1</span> &lt; len) &#123;</span><br><span class="line">                    len = r - l + <span class="number">1</span>;</span><br><span class="line">                    ansL = l;</span><br><span class="line">                    ansR = l + len;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ori.containsKey(s.charAt(l))) &#123;</span><br><span class="line">                    cnt.put(s.charAt(l), cnt.getOrDefault(s.charAt(l), <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ansL == -<span class="number">1</span> ? <span class="string">""</span> : s.substring(ansL, ansR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Iterator iter = ori.entrySet().iterator(); </span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123; </span><br><span class="line">            Map.Entry entry = (Map.Entry) iter.next(); </span><br><span class="line">            Character key = (Character) entry.getKey(); </span><br><span class="line">            Integer val = (Integer) entry.getValue(); </span><br><span class="line">            <span class="keyword">if</span> (cnt.getOrDefault(key, <span class="number">0</span>) &lt; val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minWindow</span><span class="params">(s <span class="keyword">string</span>, t <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    ori, cnt := <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>&#123;&#125;, <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(t); i++ &#123;</span><br><span class="line">        ori[t[i]]++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sLen := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="built_in">len</span> := math.MaxInt32</span><br><span class="line">    ansL, ansR := <span class="number">-1</span>, <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    check := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> k, v := <span class="keyword">range</span> ori &#123;</span><br><span class="line">            <span class="keyword">if</span> cnt[k] &lt; v &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> l, r := <span class="number">0</span>, <span class="number">0</span>; r &lt; sLen; r++ &#123;</span><br><span class="line">        <span class="keyword">if</span> r &lt; sLen &amp;&amp; ori[s[r]] &gt; <span class="number">0</span> &#123;</span><br><span class="line">            cnt[s[r]]++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> check() &amp;&amp; l &lt;= r &#123;</span><br><span class="line">            <span class="keyword">if</span> (r - l + <span class="number">1</span> &lt; <span class="built_in">len</span>) &#123;</span><br><span class="line">                <span class="built_in">len</span> = r - l + <span class="number">1</span></span><br><span class="line">                ansL, ansR = l, l + <span class="built_in">len</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> _, ok := ori[s[l]]; ok &#123;</span><br><span class="line">                cnt[s[l]] -= <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            l++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ansL == <span class="number">-1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s[ansL:ansR]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：最坏情况下左右指针对 <em>s</em> 的每个元素各遍历一遍，哈希表中对 <em>s</em> 中的每个元素各插入、删除一次，对 <em>t</em> 中的元素各插入一次。每次检查是否可行会遍历整个 <em>t</em> 的哈希表，哈希表的大小与字符集的大小有关，设字符集大小为 <em>C</em>，则渐进时间复杂度为 O(C*|s|+|t|)  。</li><li>空间复杂度：这里用了两张哈希表作为辅助空间，每张哈希表最多不会存放超过字符集大小的键值对，我们设字符集大小为 <em>C</em> ，则渐进空间复杂度为 <em>O(C)</em>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年12月" scheme="http://yoursite.com/categories/2020%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>41. 缺失的第一个正数</title>
    <link href="http://yoursite.com/2020/12/16/41.%20%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/"/>
    <id>http://yoursite.com/2020/12/16/41. 缺失的第一个正数/</id>
    <published>2020-12-16T11:06:12.000Z</published>
    <updated>2020-12-16T12:01:08.206Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: [1,2,0]输出: 3</code></pre><p>示例 2:</p><pre><code>输入: [3,4,-1,1]输出: 2</code></pre><p>示例 3:</p><pre><code>输入: [7,8,9,11,12]输出: 1</code></pre><p>提示：</p><p>你的算法的时间复杂度应为O(n)，并且只能使用常数级别的额外空间。</p><h1 id="📺-视频题解"><a href="#📺-视频题解" class="headerlink" title="📺 视频题解"></a>📺 视频题解</h1><p><a href="cac80bf0-8440-4325-94bb-b9f729db7dde">41. 缺失的第一个正数.mp4</a></p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果本题没有额外的时空复杂度要求，那么就很容易实现：</p><ul><li><p>我们可以将数组所有的数放入哈希表，随后从 <em>1</em> 开始依次枚举正整数，并判断其是否在哈希表中；</p></li><li><p>我们可以从 <em>1</em> 开始依次枚举正整数，并遍历数组，判断其是否在数组中。</p></li></ul><p>如果数组的长度为 <em>N</em>，那么第一种做法的时间复杂度为 <em>O(N)</em>，空间复杂度为 <em>O(N)</em>；第二种做法的时间复杂度为 <em>O(N^2)</em>，空间复杂度为 <em>O(1)</em>。但它们都不满足题目的要求：时间复杂度为 <em>O(N)</em>，空间复杂度为 <em>O(1)</em>。</p><p>「真正」满足此要求的算法是不存在的。但是我们可以退而求其次：利用给定数组中的空间来存储一些状态。也就是说，如果题目给定的数组是<strong>不可修改</strong>的，那么就不存在满足时空复杂度要求的算法；但如果我们可以修改给定的数组，那么是存在满足要求的算法的。</p><h2 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h2><p>对于「前言」中提到的第一种做法：</p><blockquote><p>我们可以将数组所有的数放入哈希表，随后从 <em>1</em> 开始依次枚举正整数，并判断其是否在哈希表中。</p></blockquote><p>仔细想一想，我们为什么要使用哈希表？这是因为哈希表是一个可以支持快速查找的数据结构：给定一个元素，我们可以在 <em>O(1)</em> 的时间查找该元素是否在哈希表中。因此，我们可以考虑将给定的数组设计成哈希表的「替代产品」。</p><p>实际上，对于一个长度为 <em>N</em> 的数组，其中没有出现的最小正整数只能在 <em>[1, N+1]</em> 中。这是因为如果 <em>[1, N]</em> 都出现了，那么答案是 <em>N+1*，否则答案是 *[1, N]</em> 中没有出现的最小正整数。这样一来，<strong>我们将所有在 <em>[1, N]</em></strong> 范围内的数放入哈希表，也可以得到最终的答案。而给定的数组恰好长度为 <em>N</em>，这让我们有了一种将数组设计成哈希表的思路：</p><blockquote><p>我们对数组进行遍历，对于遍历到的数 <em>x</em>，如果它在 <em>[1, N]</em> 的范围内，那么就将数组中的第 <em>x-1</em> 个位置（注意：数组下标从 <em>0</em> 开始）打上「标记」。在遍历结束之后，如果所有的位置都被打上了标记，那么答案是 <em>N+1</em>，否则答案是最小的没有打上标记的位置加 <em>1</em>。</p></blockquote><p>那么如何设计这个「标记」呢？由于数组中的数没有任何限制，因此这并不是一件容易的事情。但我们可以继续利用上面的提到的性质：由于我们只在意 <em>[1, N]</em> 中的数，因此我们可以先对数组进行遍历，把不在 <em>[1, N]</em> 范围内的数修改成任意一个大于 <em>N</em> 的数（例如 <em>N+1</em>）。这样一来，<strong>数组中的所有数就都是正数了</strong>，因此我们就可以将「标记」表示为「负号」。算法的流程如下：</p><ul><li><p>我们将数组中所有小于等于 <em>0</em> 的数修改为 <em>N+1</em>；</p></li><li><p>我们遍历数组中的每一个数 <em>x</em>，它可能已经被打了标记，因此原本对应的数为 <em>|x|*，其中 || 为绝对值符号。如果 |x| in [1,N]，那么我们给数组中的第 *|x| - 1</em> 个位置的数添加一个负号。注意如果它已经有负号，不需要重复添加；</p></li><li><p>在遍历完成之后，如果数组中的每一个数都是负数，那么答案是 <em>N+1</em>，否则答案是第一个正数的位置加 <em>1</em>。</p></li></ul><p><a href="https://assets.leetcode-cn.com/solution-static/41/41_fig1.png" target="_blank" rel="noopener">fig1</a></p><details>    <summary>哈希表C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; num: nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                num = n + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="built_in">abs</span>(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (num &lt;= n) &#123;</span><br><span class="line">                nums[num - <span class="number">1</span>] = -<span class="built_in">abs</span>(nums[num - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>哈希表Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                nums[i] = n + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = Math.abs(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (num &lt;= n) &#123;</span><br><span class="line">                nums[num - <span class="number">1</span>] = -Math.abs(nums[num - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>哈希表Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt;= <span class="number">0</span>:</span><br><span class="line">                nums[i] = n + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            num = abs(nums[i])</span><br><span class="line">            <span class="keyword">if</span> num &lt;= n:</span><br><span class="line">                nums[num - <span class="number">1</span>] = -abs(nums[num - <span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span></span><br></pre></td></tr></table></figure></details><details>    <summary>哈希表C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            nums[i] = numsSize + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="built_in">abs</span>(nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (num &lt;= numsSize) &#123;</span><br><span class="line">            nums[num - <span class="number">1</span>] = -<span class="built_in">abs</span>(nums[num - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numsSize + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>哈希表Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">firstMissingPositive</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt;= <span class="number">0</span> &#123;</span><br><span class="line">            nums[i] = n + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        num := abs(nums[i])</span><br><span class="line">        <span class="keyword">if</span> num &lt;= n &#123;</span><br><span class="line">            fmt.Println(num<span class="number">-1</span>)</span><br><span class="line">            nums[num - <span class="number">1</span>] = -abs(nums[num - <span class="number">1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">abs</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(N)*，其中 *N</em> 是数组的长度。</p></li><li><p>空间复杂度：<em>O(1)</em>。</p></li></ul><h2 id="方法二：置换"><a href="#方法二：置换" class="headerlink" title="方法二：置换"></a>方法二：置换</h2><p>除了打标记以外，我们还可以使用置换的方法，将给定的数组「恢复」成下面的形式：</p><blockquote><p>如果数组中包含 x in [1,N]  ，那么恢复后，数组的第 <em>x - 1</em> 个元素为 <em>x</em>。</p></blockquote><p>在恢复后，数组应当有 <code>[1, 2, ..., N]</code> 的形式，但其中有若干个位置上的数是错误的，每一个错误的位置就代表了一个缺失的正数。以题目中的示例二 <code>[3, 4, -1, 1]</code> 为例，恢复后的数组应当为 <code>[1, -1, 3, 4]</code>，我们就可以知道缺失的数为 <em>2</em>。</p><p>那么我们如何将数组进行恢复呢？我们可以对数组进行一次遍历，对于遍历到的数<code>x=nums[i]</code>，如果<code>x in [1,N]</code> ，我们就知道 <em>x</em> 应当出现在数组中的 <em>x - 1</em> 的位置，因此交换nums[i] 和nums[x-1] ，这样 <em>x</em> 就出现在了正确的位置。在完成交换后，新的 nums[i]  可能还在 <em>[1, N]</em> 的范围内，我们需要继续进行交换操作，直到 <code>x not in [1,N]</code> 。</p><p>注意到上面的方法可能会陷入死循环。如果 nums[i]  恰好与 nums[x-1]  相等，那么就会无限交换下去。此时我们有 <code>nums[i] = x = nums[x-1]</code>，说明 <em>x</em> 已经出现在了正确的位置。因此我们可以跳出循环，开始遍历下一个数。</p><p>由于每次的交换操作都会使得某一个数交换到正确的位置，因此交换的次数最多为 <em>N</em>，整个方法的时间复杂度为 <em>O(N)</em>。</p><details>    <summary>置换C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - <span class="number">1</span>] != nums[i]) &#123;</span><br><span class="line">                swap(nums[nums[i] - <span class="number">1</span>], nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>置换Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - <span class="number">1</span>] != nums[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[nums[i] - <span class="number">1</span>];</span><br><span class="line">                nums[nums[i] - <span class="number">1</span>] = nums[i];</span><br><span class="line">                nums[i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>置换Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">while</span> <span class="number">1</span> &lt;= nums[i] &lt;= n <span class="keyword">and</span> nums[nums[i] - <span class="number">1</span>] != nums[i]:</span><br><span class="line">                nums[nums[i] - <span class="number">1</span>], nums[i] = nums[i], nums[nums[i] - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != i + <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span></span><br></pre></td></tr></table></figure></details><details>    <summary>置换C</summary><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= numsSize &amp;&amp;</span><br><span class="line">               nums[nums[i] - <span class="number">1</span>] != nums[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = nums[nums[i] - <span class="number">1</span>];</span><br><span class="line">            nums[nums[i] - <span class="number">1</span>] = nums[i], nums[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numsSize + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>置换Golang</summary><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">firstMissingPositive</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i]<span class="number">-1</span>] != nums[i] &#123;</span><br><span class="line">            nums[nums[i]<span class="number">-1</span>], nums[i] = nums[i], nums[nums[i]<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] != i + <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(N)*，其中 *N</em> 是数组的长度。</p></li><li><p>空间复杂度：<em>O(1)</em>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年12月" scheme="http://yoursite.com/categories/2020%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>89. 格雷编码</title>
    <link href="http://yoursite.com/2020/12/16/89.%20%E6%A0%BC%E9%9B%B7%E7%BC%96%E7%A0%81/"/>
    <id>http://yoursite.com/2020/12/16/89. 格雷编码/</id>
    <published>2020-12-16T08:26:12.000Z</published>
    <updated>2020-12-16T10:11:12.382Z</updated>
    
    <content type="html"><![CDATA[<p>格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。</p><p>给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。即使有多个不同答案，你也只需要返回其中一种。</p><p>格雷编码序列必须以 0 开头。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: 2输出: [0,1,3,2]解释:00 - 001 - 111 - 310 - 2对于给定的 n，其格雷编码序列并不唯一。例如，[0,2,3,1] 也是一个有效的格雷编码序列。00 - 010 - 211 - 301 - 1</code></pre><p>示例 2:</p><pre><code>输入: 0输出: [0]解释: 我们定义格雷编码序列必须以 0 开头。     给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。     因此，当 n = 0 时，其格雷编码序列为 [0]。</code></pre><h1 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h1><ul><li>设 <em>n</em> 阶格雷码集合为 <em>G(n)*，则 *G(n+1)</em> 阶格雷码为：<ul><li>给 <em>G(n)</em> 阶格雷码每个元素二进制形式前面添加 <em>0</em>，得到 <em>G’(n)</em>；</li><li>设 <em>G(n)</em> 集合倒序（镜像）为 <em>R(n)*，给 *R(n)</em> 每个元素二进制形式前面添加 <em>1</em>，得到 <em>R’(n)</em>；</li><li><em>G(n+1) = G’(n) ∪ R’(n)</em> 拼接两个集合即可得到下一阶格雷码。</li></ul></li><li>根据以上规律，可从 <em>0</em> 阶格雷码推导致任何阶格雷码。</li><li>代码解析：<ul><li>由于最高位前默认为 <em>0</em>，因此 <em>G’(n) = G(n)*，只需在 <code>res</code>(即 *G(n)</em> )后添加 <em>R’(n)</em> 即可；</li><li>计算 <em>R’(n)*：执行 <code>head = 1 &lt;&lt; i</code> 计算出对应位数，以给 *R(n)</em> 前添加 <em>1</em> 得到对应 <em>R’(n)</em>；</li><li>倒序遍历 <code>res</code>(即 <em>G(n)</em> )：依次求得 <em>R’(n)</em> 各元素添加至 <code>res</code> 尾端，遍历完成后 <code>res</code>(即 <em>G(n+1)</em>)。</li></ul></li></ul><h1 id="图解："><a href="#图解：" class="headerlink" title="图解："></a>图解：</h1><p> <a href="https://pic.leetcode-cn.com/6c8d62ea7150ece8ed135e6d29bc614eb4022d136b08f3640132fb66e40694c4-Picture1.png" target="_blank" rel="noopener">Picture1.png</a> <a href="https://pic.leetcode-cn.com/e3dcfa34510e7625bfa170388389b14e7fc79e21486db077aac41acf044133f8-Picture2.png" target="_blank" rel="noopener">Picture2.png</a> <a href="https://pic.leetcode-cn.com/d0df7e038c396acf7c5283e8080963ecefe2ab37d4b607982eb3e40b1e5ee03b-Picture3.png" target="_blank" rel="noopener">Picture3.png</a> <a href="https://pic.leetcode-cn.com/28acf6d5b1fae0fb2dddbedd7ac92ffeee8902cd28233bdfb08b52af411a9bb2-Picture4.png" target="_blank" rel="noopener">Picture4.png</a> </p><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">grayCode</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">        res, head = [<span class="number">0</span>], <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(res) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                res.append(head + res[j])</span><br><span class="line">            head &lt;&lt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">grayCode</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;() &#123;&#123; add(<span class="number">0</span>); &#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> head = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = res.size() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">                res.add(head + res.get(j));</span><br><span class="line">            head &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。&lt;/p&gt;
&lt;p&gt;给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。即使有多个不同答案，你也只需要返回其中一种。&lt;/p&gt;
&lt;p&gt;格雷编码序列必须以 0 开头。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年12月" scheme="http://yoursite.com/categories/2020%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>61. 旋转链表</title>
    <link href="http://yoursite.com/2020/12/15/61.%20%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/12/15/61. 旋转链表/</id>
    <published>2020-12-15T09:26:12.000Z</published>
    <updated>2020-12-16T08:01:10.275Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个链表，旋转链表，将链表每个节点向右移动k个位置，其中k是非负数。</p><a id="more"></a><p>示例1:</p><pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL解释:向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</code></pre><p>示例2:</p><pre><code>输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4输出: 2-&gt;0-&gt;1-&gt;NULL解释:向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL</code></pre><h1 id="方法-1："><a href="#方法-1：" class="headerlink" title="方法 1："></a>方法 1：</h1><p><strong>直觉</strong></p><p>链表中的点已经相连，一次旋转操作意味着：</p><ul><li>先将链表闭合成环</li><li>找到相应的位置断开这个环，确定新的链表头和链表尾</li></ul><p><a href="https://pic.leetcode-cn.com/e3371c6b03e3c8d3758dcf0b35a45d0a6b39c111373cf7b5bde53e14b6271a04-61.png" target="_blank" rel="noopener">61.png</a></p><blockquote><p>新的链表头在哪里？</p></blockquote><p>在位置 <code>n-k</code> 处，其中 <code>n</code> 是链表中点的个数，新的链表尾就在头的前面，位于位置 <code>n-k-1</code>。</p><blockquote><p>我们这里假设 <code>k &lt; n</code></p><p>如果  <code>k &gt;= n</code>  怎么处理？</p></blockquote><p><code>k</code> 可以被写成 <code>k = (k // n) * n + k % n</code> 两者加和的形式，其中前面的部分不影响最终的结果，因此只需要考虑 <code>k%n</code> 的部分，这个值一定比 <code>n</code> 小。</p><p><strong>算法</strong></p><p>算法实现很直接：</p><ul><li>找到旧的尾部并将其与链表头相连 <code>old_tail.next = head</code>，整个链表闭合成环，同时计算出链表的长度 <code>n</code>。</li><li>找到新的尾部，第 <code>(n - k % n - 1)</code> 个节点 ，新的链表头是第 <code>(n - k % n)</code> 个节点。</li><li>断开环 <code>new_tail.next = None</code>，并返回新的链表头 <code>new_head</code>。</li></ul><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base cases</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// close the linked list into the ring</span></span><br><span class="line">    ListNode old_tail = head;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">for</span>(n = <span class="number">1</span>; old_tail.next != <span class="keyword">null</span>; n++)</span><br><span class="line">      old_tail = old_tail.next;</span><br><span class="line">    old_tail.next = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find new tail : (n - k % n - 1)th node</span></span><br><span class="line">    <span class="comment">// and new head : (n - k % n)th node</span></span><br><span class="line">    ListNode new_tail = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - k % n - <span class="number">1</span>; i++)</span><br><span class="line">      new_tail = new_tail.next;</span><br><span class="line">    ListNode new_head = new_tail.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// break the ring</span></span><br><span class="line">    new_tail.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_head;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateRight</span><span class="params">(self, head: <span class="string">'ListNode'</span>, k: <span class="string">'int'</span>)</span> -&gt; 'ListNode':</span></span><br><span class="line">        <span class="comment"># base cases</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># close the linked list into the ring</span></span><br><span class="line">        old_tail = head</span><br><span class="line">        n = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> old_tail.next:</span><br><span class="line">            old_tail = old_tail.next</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">        old_tail.next = head</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># find new tail : (n - k % n - 1)th node</span></span><br><span class="line">        <span class="comment"># and new head : (n - k % n)th node</span></span><br><span class="line">        new_tail = head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - k % n - <span class="number">1</span>):</span><br><span class="line">            new_tail = new_tail.next</span><br><span class="line">        new_head = new_tail.next</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># break the ring</span></span><br><span class="line">        new_tail.next = <span class="keyword">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> new_head</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(N)*，其中 *N</em> 是链表中的元素个数</li><li>空间复杂度：<em>O(1)</em>，因为只需要常数的空间</li></ul></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个链表，旋转链表，将链表每个节点向右移动k个位置，其中k是非负数。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年12月" scheme="http://yoursite.com/categories/2020%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>8. 字符串转换整数 (atoi)</title>
    <link href="http://yoursite.com/2020/12/09/8.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0%20(atoi)/"/>
    <id>http://yoursite.com/2020/12/09/8. 字符串转换整数 (atoi)/</id>
    <published>2020-12-09T06:26:12.000Z</published>
    <updated>2020-12-15T09:22:19.958Z</updated>
    
    <content type="html"><![CDATA[<p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p><a id="more"></a><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：</p><p>如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。<br>假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。<br>该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。<br>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0 。</p><p>提示：</p><p>本题中的空白字符只包括空格字符 ‘ ‘ 。<br>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p><p>示例 1:</p><pre><code>输入: &quot;42&quot;输出: 42</code></pre><p>示例 2:</p><pre><code>输入: &quot;   -42&quot;输出: -42解释: 第一个非空白字符为 &apos;-&apos;, 它是一个负号。     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</code></pre><p>示例 3:</p><pre><code>输入: &quot;4193 with words&quot;输出: 4193解释: 转换截止于数字 &apos;3&apos; ，因为它的下一个字符不为数字。</code></pre><p>示例 4:</p><pre><code>输入: &quot;words and 987&quot;输出: 0解释: 第一个非空字符是 &apos;w&apos;, 但它不是数字或正、负号。     因此无法执行有效的转换。</code></pre><p>示例 5:</p><pre><code>输入: &quot;-91283472332&quot;输出: -2147483648解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。      因此返回 INT_MIN (−231) 。</code></pre><h1 id="视频题解"><a href="#视频题解" class="headerlink" title="视频题解"></a>视频题解</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>根据问题的描述我们来判断并且描述对应的解题方法。对于这道题目，很明显是字符串的转化问题。需要明确转化规则，尽量根据转化规则编写对应的子函数。</p><p>这里我们要进行模式识别，一旦涉及整数的运算，我们需要注意溢出。本题可能产生溢出的步骤在于推入，乘 10 操作和累加操作都可能造成溢出。对于溢出的处理方式通常可以转换为 <code>INT_MAX</code> 的逆操作。比如判断某数乘 10 是否会溢出，那么就把该数和 <code>INT_MAX</code> 除 10 进行比较。</p><p><a href="3c712e6e-fcf7-4953-9401-bd1d5c2b9cb8">字符串转换整数 (atoi).mp4</a></p><h1 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>这个问题其实没有考察算法的知识，模拟的是日常开发中对于原始数据的处理（例如「参数校验」等场景），如果面试中遇到类似的问题，应先仔细阅读题目文字说明和示例，有疑惑的地方和需要和面试官确认，在编码的时候需要耐心和细心地调试。</p><p>其实很多时候，业务需求就是类似这样的问题，工作中如果遇到：</p><p>1、有现成的工具和类库需尽量使用，因为它们是性能更优，且经过更严格测试，是相对可靠的；<br>2、能抽取成工具类、工具方法的尽量抽取，以突出主干逻辑、方便以后代码复用；<br>3、不得不写得比较繁琐、冗长的时候，需要写清楚注释、体现逻辑层次，以便上线以后排查问题和后续维护。</p><p>在这我罗列几个要点：</p><ul><li>根据示例 1，需要去掉前导空格；</li><li>根据示例 2，需要判断第 1 个字符为 <code>+</code> 和 <code>-</code> 的情况，因此，可以设计一个变量 <code>sign</code>，初始化的时候为 <code>1</code>，如果遇到 <code>-</code> ，将 <code>sign</code> 修正为 <code>-1</code>；</li><li>判断是否是数字，可以使用字符的 ASCII 码数值进行比较，即 <code>0 &lt;= c &lt;= &#39;9&#39;</code>；</li><li>根据示例 3 和示例 4 ，在遇到第 1 个不是数字的字符的情况下，转换停止，退出循环；</li><li>根据示例 5，如果转换以后的数字超过了 <code>int</code> 类型的范围，需要截取。这里不能将结果 <code>res</code> 变量设计为 <code>long</code> 类型，<strong>注意</strong>：由于输入的字符串转换以后也有可能超过 <code>long</code> 类型，因此需要在循环内部就判断是否越界，只要越界就退出循环，这样也可以减少不必要的计算；</li><li>由于涉及下标访问，因此全程需要考虑数组下标是否越界的情况。</li></ul><p><strong>特别注意</strong>：</p><p>1、由于题目中说「环境只能保存 32 位整数」，因此这里在每一轮循环之前先要检查乘以 <em>10</em> 以后是否溢出，具体细节请见编码。</p><p>2、Java 、Python 和 C++ 字符串的设计都是不可变的，即使用 <code>trim()</code> 会产生新的变量，因此我们<strong>尽量不使用库函数，使用一个变量 <code>index</code> 去做遍历，这样遍历完成以后就得到转换以后的数值</strong>。</p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="comment">// str.charAt(i) 方法回去检查下标的合法性，一般先转换成字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] charArray = str.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、去除前导空格</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; len &amp;&amp; charArray[index] == <span class="string">' '</span>) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、如果已经遍历完成（针对极端用例 "      "）</span></span><br><span class="line">        <span class="keyword">if</span> (index == len) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、如果出现符号字符，仅第 1 个有效，并记录正负</span></span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> firstChar = charArray[index];</span><br><span class="line">        <span class="keyword">if</span> (firstChar == <span class="string">'+'</span>) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstChar == <span class="string">'-'</span>) &#123;</span><br><span class="line">            index++;</span><br><span class="line">            sign = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、将后续出现的数字字符进行转换</span></span><br><span class="line">        <span class="comment">// 不能使用 long 类型，这是题目说的</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; len) &#123;</span><br><span class="line">            <span class="keyword">char</span> currChar = charArray[index];</span><br><span class="line">            <span class="comment">// 4.1 先判断不合法的情况</span></span><br><span class="line">            <span class="keyword">if</span> (currChar &gt; <span class="string">'9'</span> || currChar &lt; <span class="string">'0'</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 题目中说：环境只能存储 32 位大小的有符号整数，因此，需要提前判：断乘以 10 以后是否越界</span></span><br><span class="line">            <span class="keyword">if</span> (res &gt; Integer.MAX_VALUE / <span class="number">10</span> || (res == Integer.MAX_VALUE / <span class="number">10</span> &amp;&amp; (currChar - <span class="string">'0'</span>) &gt; Integer.MAX_VALUE % <span class="number">10</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (res &lt; Integer.MIN_VALUE / <span class="number">10</span> || (res == Integer.MIN_VALUE / <span class="number">10</span> &amp;&amp; (currChar - <span class="string">'0'</span>) &gt; -(Integer.MIN_VALUE % <span class="number">10</span>))) &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.2 合法的情况下，才考虑转换，每一步都把符号位乘进去</span></span><br><span class="line">            res = res * <span class="number">10</span> + sign * (currChar - <span class="string">'0'</span>);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> len = str.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去除前导空格</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[index] != <span class="string">' '</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index == len) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 处理第 1 个非空字符为正负符号，这两个判断需要写在一起</span></span><br><span class="line">        <span class="keyword">if</span> (str[index] == <span class="string">'+'</span>) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[index] == <span class="string">'-'</span>) &#123;</span><br><span class="line">            sign = <span class="number">-1</span>;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据题目限制，只能使用 int 类型</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; len) &#123;</span><br><span class="line">            <span class="keyword">char</span> curChar = str[index];</span><br><span class="line">            <span class="keyword">if</span> (curChar &lt; <span class="string">'0'</span> || curChar &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (res &gt; INT_MAX / <span class="number">10</span> || (res == INT_MAX / <span class="number">10</span> &amp;&amp; (curChar - <span class="string">'0'</span>) &gt; INT_MAX % <span class="number">10</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> INT_MAX;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (res &lt; INT_MIN / <span class="number">10</span> || (res == INT_MIN / <span class="number">10</span> &amp;&amp; (curChar - <span class="string">'0'</span>) &gt; -(INT_MIN % <span class="number">10</span>))) &#123;</span><br><span class="line">                <span class="keyword">return</span> INT_MIN;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res = res * <span class="number">10</span> + sign * (curChar - <span class="string">'0'</span>);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<em>O(N)*，这里 *N</em> 为字符串的长度；</li><li>空间复杂度：<em>O(1)</em>。</li></ul><h2 id="自动机"><a href="#自动机" class="headerlink" title="自动机"></a>自动机</h2><p><strong>思路</strong></p><p>字符串处理的题目往往涉及复杂的流程以及条件情况，如果直接上手写程序，一不小心就会写出极其臃肿的代码。</p><p>因此，为了有条理地分析每个输入字符的处理方法，我们可以使用自动机这个概念：</p><p>我们的程序在每个时刻有一个状态 <code>s</code>，每次从序列中输入一个字符 <code>c</code>，并根据字符 <code>c</code> 转移到下一个状态 <code>s&#39;</code>。这样，我们只需要建立一个覆盖所有情况的从 <code>s</code> 与 <code>c</code> 映射到 <code>s&#39;</code> 的表格即可解决题目中的问题。</p><p><strong>算法</strong></p><p>本题可以建立如下图所示的自动机：</p><p><a href="https://assets.leetcode-cn.com/solution-static/8_fig1.PNG" target="_blank" rel="noopener">fig1</a></p><p>我们也可以用下面的表格来表示这个自动机：</p><table><thead><tr><th></th><th align="center">‘ ‘</th><th align="center">+/-</th><th align="center">number</th><th align="center">other</th></tr></thead><tbody><tr><td><strong>start</strong></td><td align="center">start</td><td align="center">signed</td><td align="center">in_number</td><td align="center">end</td></tr><tr><td><strong>signed</strong></td><td align="center">end</td><td align="center">end</td><td align="center">in_number</td><td align="center">end</td></tr><tr><td><strong>in_number</strong></td><td align="center">end</td><td align="center">end</td><td align="center">in_number</td><td align="center">end</td></tr><tr><td><strong>end</strong></td><td align="center">end</td><td align="center">end</td><td align="center">end</td><td align="center">end</td></tr></tbody></table><p>接下来编程部分就非常简单了：我们只需要把上面这个状态转换表抄进代码即可。</p><p>另外自动机也需要记录当前已经输入的数字，只要在 <code>s&#39;</code> 为 <code>in_number</code> 时，更新我们输入的数字，即可最终得到输入的数字。</p><details>    <summary>自动机Python</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">INT_MAX = <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span></span><br><span class="line">INT_MIN = <span class="number">-2</span> ** <span class="number">31</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Automaton</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.state = <span class="string">'start'</span></span><br><span class="line">        self.sign = <span class="number">1</span></span><br><span class="line">        self.ans = <span class="number">0</span></span><br><span class="line">        self.table = &#123;</span><br><span class="line">            <span class="string">'start'</span>: [<span class="string">'start'</span>, <span class="string">'signed'</span>, <span class="string">'in_number'</span>, <span class="string">'end'</span>],</span><br><span class="line">            <span class="string">'signed'</span>: [<span class="string">'end'</span>, <span class="string">'end'</span>, <span class="string">'in_number'</span>, <span class="string">'end'</span>],</span><br><span class="line">            <span class="string">'in_number'</span>: [<span class="string">'end'</span>, <span class="string">'end'</span>, <span class="string">'in_number'</span>, <span class="string">'end'</span>],</span><br><span class="line">            <span class="string">'end'</span>: [<span class="string">'end'</span>, <span class="string">'end'</span>, <span class="string">'end'</span>, <span class="string">'end'</span>],</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_col</span><span class="params">(self, c)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> c.isspace():</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> c == <span class="string">'+'</span> <span class="keyword">or</span> c == <span class="string">'-'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> c.isdigit():</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, c)</span>:</span></span><br><span class="line">        self.state = self.table[self.state][self.get_col(c)]</span><br><span class="line">        <span class="keyword">if</span> self.state == <span class="string">'in_number'</span>:</span><br><span class="line">            self.ans = self.ans * <span class="number">10</span> + int(c)</span><br><span class="line">            self.ans = min(self.ans, INT_MAX) <span class="keyword">if</span> self.sign == <span class="number">1</span> <span class="keyword">else</span> min(self.ans, -INT_MIN)</span><br><span class="line">        <span class="keyword">elif</span> self.state == <span class="string">'signed'</span>:</span><br><span class="line">            self.sign = <span class="number">1</span> <span class="keyword">if</span> c == <span class="string">'+'</span> <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, str: str)</span> -&gt; int:</span></span><br><span class="line">        automaton = Automaton()</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> str:</span><br><span class="line">            automaton.get(c)</span><br><span class="line">        <span class="keyword">return</span> automaton.sign * automaton.ans</span><br></pre></td></tr></table></figure></details><details>    <summary>自动机C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Automaton</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> state = <span class="string">"start"</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; table = &#123;</span><br><span class="line">        &#123;<span class="string">"start"</span>, &#123;<span class="string">"start"</span>, <span class="string">"signed"</span>, <span class="string">"in_number"</span>, <span class="string">"end"</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"signed"</span>, &#123;<span class="string">"end"</span>, <span class="string">"end"</span>, <span class="string">"in_number"</span>, <span class="string">"end"</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"in_number"</span>, &#123;<span class="string">"end"</span>, <span class="string">"end"</span>, <span class="string">"in_number"</span>, <span class="string">"end"</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"end"</span>, &#123;<span class="string">"end"</span>, <span class="string">"end"</span>, <span class="string">"end"</span>, <span class="string">"end"</span>&#125;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_col</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(c)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'+'</span> <span class="keyword">or</span> c == <span class="string">'-'</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        state = table[state][get_col(c)];</span><br><span class="line">        <span class="keyword">if</span> (state == <span class="string">"in_number"</span>) &#123;</span><br><span class="line">            ans = ans * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">            ans = sign == <span class="number">1</span> ? min(ans, (<span class="keyword">long</span> <span class="keyword">long</span>)INT_MAX) : min(ans, -(<span class="keyword">long</span> <span class="keyword">long</span>)INT_MIN);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state == <span class="string">"signed"</span>)</span><br><span class="line">            sign = c == <span class="string">'+'</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        Automaton automaton;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : str)</span><br><span class="line">            automaton.get(c);</span><br><span class="line">        <span class="keyword">return</span> automaton.sign * automaton.ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>自动机Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        Automaton automaton = <span class="keyword">new</span> Automaton();</span><br><span class="line">        <span class="keyword">int</span> length = str.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            automaton.get(str.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (automaton.sign * automaton.ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Automaton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> String state = <span class="string">"start"</span>;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String[]&gt; table = <span class="keyword">new</span> HashMap&lt;String, String[]&gt;() &#123;&#123;</span><br><span class="line">        put(<span class="string">"start"</span>, <span class="keyword">new</span> String[]&#123;<span class="string">"start"</span>, <span class="string">"signed"</span>, <span class="string">"in_number"</span>, <span class="string">"end"</span>&#125;);</span><br><span class="line">        put(<span class="string">"signed"</span>, <span class="keyword">new</span> String[]&#123;<span class="string">"end"</span>, <span class="string">"end"</span>, <span class="string">"in_number"</span>, <span class="string">"end"</span>&#125;);</span><br><span class="line">        put(<span class="string">"in_number"</span>, <span class="keyword">new</span> String[]&#123;<span class="string">"end"</span>, <span class="string">"end"</span>, <span class="string">"in_number"</span>, <span class="string">"end"</span>&#125;);</span><br><span class="line">        put(<span class="string">"end"</span>, <span class="keyword">new</span> String[]&#123;<span class="string">"end"</span>, <span class="string">"end"</span>, <span class="string">"end"</span>, <span class="string">"end"</span>&#125;);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        state = table.get(state)[get_col(c)];</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"in_number"</span>.equals(state)) &#123;</span><br><span class="line">            ans = ans * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">            ans = sign == <span class="number">1</span> ? Math.min(ans, (<span class="keyword">long</span>) Integer.MAX_VALUE) : Math.min(ans, -(<span class="keyword">long</span>) Integer.MIN_VALUE);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"signed"</span>.equals(state)) &#123;</span><br><span class="line">            sign = c == <span class="string">'+'</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">get_col</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">' '</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'+'</span> || c == <span class="string">'-'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Character.isDigit(c)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)*，其中 *n</em> 为字符串的长度。我们只需要依次处理所有的字符，处理每个字符需要的时间为 <em>O(1)</em>。</p></li><li><p>空间复杂度：<em>O(1)</em>，自动机的状态只需要常数空间存储。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;请你来实现一个 atoi 函数，使其能将字符串转换成整数。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年12月" scheme="http://yoursite.com/categories/2020%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>1. 两数之和</title>
    <link href="http://yoursite.com/2020/12/02/1.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://yoursite.com/2020/12/02/1. 两数之和/</id>
    <published>2020-12-02T09:26:12.000Z</published>
    <updated>2020-12-02T10:29:22.179Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><a id="more"></a><p>示例:</p><pre><code>给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]</code></pre><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="方法一：暴力枚举"><a href="#方法一：暴力枚举" class="headerlink" title="方法一：暴力枚举"></a>方法一：暴力枚举</h2><p><strong>思路及算法</strong></p><p>最容易想到的方法是枚举数组中的每一个数 <code>x</code>，寻找数组中是否存在 <code>target - x</code>。</p><p>当我们使用遍历整个数组的方式寻找 <code>target - x</code> 时，需要注意到每一个位于 <code>x</code> 之前的元素都已经和 <code>x</code> 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 <code>x</code> 后面的元素中寻找 <code>target - x</code>。</p><p><strong>代码</strong></p><details>    <summary>暴力枚举Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>暴力枚举C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>暴力枚举C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; numsSize; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                <span class="keyword">int</span>* ret = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">2</span>);</span><br><span class="line">                ret[<span class="number">0</span>] = i, ret[<span class="number">1</span>] = j;</span><br><span class="line">                *returnSize = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>暴力枚举Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[j] == target:</span><br><span class="line">                    <span class="keyword">return</span> [i, j]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure></details><details>    <summary>暴力枚举Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i, x := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(nums); j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> x+nums[j] == target &#123;</span><br><span class="line">                <span class="keyword">return</span> []<span class="keyword">int</span>&#123;i, j&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(N^2)*，其中 *N</em> 是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。</p></li><li><p>空间复杂度：<em>O(1)</em>。</p></li></ul><h2 id="方法二：哈希表"><a href="#方法二：哈希表" class="headerlink" title="方法二：哈希表"></a>方法二：哈希表</h2><p><strong>思路及算法</strong></p><p>注意到方法一的时间复杂度较高的原因是寻找 <code>target - x</code> 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。</p><p>使用哈希表，可以将寻找 <code>target - x</code> 的时间复杂度降低到从 <em>O(N)</em> 降低到 <em>O(1)</em>。</p><p>这样我们创建一个哈希表，对于每一个 <code>x</code>，我们首先查询哈希表中是否存在 <code>target - x</code>，然后将 <code>x</code> 插入到哈希表中，即可保证不会让 <code>x</code> 和自己匹配。</p><p><strong>代码</strong></p><details>    <summary>哈希表Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; hashtable = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashtable.containsKey(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;hashtable.get(target - nums[i]), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashtable.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>哈希表C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashtable;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = hashtable.find(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (it != hashtable.end()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;it-&gt;second, i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashtable[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>哈希表C</summary><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    UT_hash_handle hh;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span>* <span class="title">hashtable</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct hashTable* <span class="title">find</span><span class="params">(<span class="keyword">int</span> ikey)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span>* <span class="title">tmp</span>;</span></span><br><span class="line">    HASH_FIND_INT(hashtable, &amp;ikey, tmp);</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> ikey, <span class="keyword">int</span> ival)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span>* <span class="title">it</span> = <span class="title">find</span>(<span class="title">ikey</span>);</span></span><br><span class="line">    <span class="keyword">if</span> (it == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span>* <span class="title">tmp</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">hashTable</span>));</span></span><br><span class="line">        tmp-&gt;key = ikey, tmp-&gt;val = ival;</span><br><span class="line">        HASH_ADD_INT(hashtable, key, tmp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        it-&gt;val = ival;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">    hashtable = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span>* <span class="title">it</span> = <span class="title">find</span>(<span class="title">target</span> - <span class="title">nums</span>[<span class="title">i</span>]);</span></span><br><span class="line">        <span class="keyword">if</span> (it != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span>* ret = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">2</span>);</span><br><span class="line">            ret[<span class="number">0</span>] = it-&gt;val, ret[<span class="number">1</span>] = i;</span><br><span class="line">            *returnSize = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        insert(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>哈希表Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        hashtable = dict()</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> target - num <span class="keyword">in</span> hashtable:</span><br><span class="line">                <span class="keyword">return</span> [hashtable[target - num], i]</span><br><span class="line">            hashtable[nums[i]] = i</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure></details><details>    <summary>哈希表Golang</summary><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    hashTable := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i, x := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> p, ok := hashTable[target-x]; ok &#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="keyword">int</span>&#123;p, i&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        hashTable[x] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(N)*，其中 *N</em> 是数组中的元素数量。对于每一个元素 <code>x</code>，我们可以 <em>O(1)</em> 地寻找 <code>target - x</code>。</p></li><li><p>空间复杂度：<em>O(N)*，其中 *N</em> 是数组中的元素数量。主要为哈希表的开销。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。&lt;/p&gt;
&lt;p&gt;你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年12月" scheme="http://yoursite.com/categories/2020%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>176. 第二高的薪水</title>
    <link href="http://yoursite.com/2020/11/30/176.%20%E7%AC%AC%E4%BA%8C%E9%AB%98%E7%9A%84%E8%96%AA%E6%B0%B4/"/>
    <id>http://yoursite.com/2020/11/30/176. 第二高的薪水/</id>
    <published>2020-11-30T09:12:12.000Z</published>
    <updated>2020-11-30T10:10:47.161Z</updated>
    
    <content type="html"><![CDATA[<p>编写一个 SQL 查询，获取 Employee 表中第二高的薪水（Salary） 。</p><a id="more"></a><p>编写一个 SQL 查询，获取 Employee 表中第二高的薪水（Salary） 。</p><pre><code>+----+--------+| Id | Salary |+----+--------+| 1  | 100    || 2  | 200    || 3  | 300    |+----+--------+</code></pre><p>例如上述 Employee 表，SQL查询应该返回 200 作为第二高的薪水。如果不存在第二高的薪水，那么查询应返回 null。</p><pre><code>+---------------------+| SecondHighestSalary |+---------------------+| 200                 |+---------------------+</code></pre><h1 id="方法一：使用子查询和-LIMIT-子句"><a href="#方法一：使用子查询和-LIMIT-子句" class="headerlink" title="方法一：使用子查询和 LIMIT 子句"></a>方法一：使用子查询和 <code>LIMIT</code> 子句</h1><p><strong>算法</strong></p><p>将不同的薪资按降序排序，然后使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>LIMIT</code></a> 子句获得第二高的薪资。</p><details>    <summary>使用子查询和 `LIMIT` 子句</summary><figure class="highlight plain"><figcaption><span>[7gHRPQAW-MySQL]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT</span><br><span class="line">    Salary AS SecondHighestSalary</span><br><span class="line">FROM</span><br><span class="line">    Employee</span><br><span class="line">ORDER BY Salary DESC</span><br><span class="line">LIMIT 1 OFFSET 1</span><br></pre></td></tr></table></figure></details><p>然而，如果没有这样的第二最高工资，这个解决方案将被判断为 “错误答案”，因为本表可能只有一项记录。为了克服这个问题，我们可以将其作为临时表。</p><details>    <summary>使用子查询和 `LIMIT` 子句</summary><figure class="highlight plain"><figcaption><span>[Z4dXjTB5-MySQL]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    (SELECT DISTINCT</span><br><span class="line">            Salary</span><br><span class="line">        FROM</span><br><span class="line">            Employee</span><br><span class="line">        ORDER BY Salary DESC</span><br><span class="line">        LIMIT 1 OFFSET 1) AS SecondHighestSalary</span><br><span class="line">;</span><br></pre></td></tr></table></figure></details><h1 id="方法二：使用-IFNULL-和-LIMIT-子句"><a href="#方法二：使用-IFNULL-和-LIMIT-子句" class="headerlink" title="方法二：使用 IFNULL 和 LIMIT 子句"></a>方法二：使用 <code>IFNULL</code> 和 <code>LIMIT</code> 子句</h1><p>解决 “NULL” 问题的另一种方法是使用 “IFNULL” 函数，如下所示。</p><details>    <summary>使用 `IFNULL` 和 `LIMIT` 子句</summary><figure class="highlight plain"><figcaption><span>[UF7BUDgS-MySQL]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    IFNULL(</span><br><span class="line">      (SELECT DISTINCT Salary</span><br><span class="line">       FROM Employee</span><br><span class="line">       ORDER BY Salary DESC</span><br><span class="line">        LIMIT 1 OFFSET 1),</span><br><span class="line">    NULL) AS SecondHighestSalary</span><br></pre></td></tr></table></figure></details><h1 id="limit和offset用法"><a href="#limit和offset用法" class="headerlink" title="limit和offset用法"></a>limit和offset用法</h1><p>mysql里分页一般用limit来实现，</p><pre><code>select* from test LIMIT 3;</code></pre><p>当 limit后面跟一个参数的时候，该参数表示要取的数据的数量。 表示直接取前三条数据，类似sqlserver里的top语法。</p><p>以下的两种方式均表示取2,3,4三条条数据。</p><p>1.select* from test LIMIT 1,3;<br>当limit后面跟两个参数的时候，第一个数表示要跳过的数量，后一位表示要取的数量。</p><p>2.select * from test LIMIT 3 OFFSET 1;</p><p>(在mysql 5以后支持这种写法)<br>当 limit和offset组合使用的时候，limit后面只能有一个参数，表示要取的的数量,offset表示要跳过的数量 。表示跳过1条数据,从第2条数据开始取，取3条数据，也就是取2,3,4三条数据</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写一个 SQL 查询，获取 Employee 表中第二高的薪水（Salary） 。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年11月" scheme="http://yoursite.com/categories/2020%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Database" scheme="http://yoursite.com/tags/Database/"/>
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
</feed>
