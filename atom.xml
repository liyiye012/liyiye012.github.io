<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-24T01:47:21.206Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>230. 二叉搜索树中第K小的元素</title>
    <link href="http://yoursite.com/2020/08/22/230.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2020/08/22/230. 二叉搜索树中第K小的元素/</id>
    <published>2020-08-22T05:44:12.000Z</published>
    <updated>2020-08-24T01:47:21.206Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。</p><a id="more"></a><p>说明：<br>你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。</p><p>示例 1:</p><pre><code>输入: root = [3,1,4,null,2], k = 1   3  / \ 1   4  \   2输出: 1</code></pre><p>示例 2:</p><pre><code>输入: root = [5,3,6,2,4,null,null,1], k = 3       5      / \     3   6    / \   2   4  / 1输出: 3</code></pre><p>进阶：</p><p>如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 kthSmallest 函数？</p><h1 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h1><p><strong>怎么遍历树：</strong></p><ul><li>深度优先搜索（<code>DFS</code>）</li></ul><p>在这个策略中，我们从根延伸到某一片叶子，然后再返回另一个分支。根据根节点，左节点，右节点的相对顺序，<code>DFS</code> 还可以分为前序，中序，后序。 </p><ul><li>广度优先搜索（<code>BFS</code>）</li></ul><p>在这个策略中，我们逐层，从上到下扫描整个树。</p><p>下图展示了不同的遍历策略：<br><a href="https://pic.leetcode-cn.com/40cb9af2a0c21fdc1ce72e6e24b48bd73d5f280c0f4b207ce3d7cf0c19fbdf21-file_1579413216186" target="_blank" rel="noopener">不同的遍历策略</a></p><p>为了解决这个问题，可以使用 BST 的特性：BST 的中序遍历是升序序列。</p><h1 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h1><p><strong>算法：</strong></p><p>通过构造 BST 的中序遍历序列，则第 <code>k-1</code> 个元素就是第 <code>k</code> 小的元素。</p><p><a href="https://pic.leetcode-cn.com/7dc3fe454519e27105c5aaf57d20b26137bd77c56bb0289830bf18116627de12-file_1579413216156" target="_blank" rel="noopener">递归</a></p><details>    <summary>递归python</summary><figure class="highlight python"><figcaption><span>[solution1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, root, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(r)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> inorder(r.left) + [r.val] + inorder(r.right) <span class="keyword">if</span> r <span class="keyword">else</span> []</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> inorder(root)[k - <span class="number">1</span>]</span><br></pre></td></tr></table></figure></details><details>    <summary>递归java</summary><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">inorder</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    inorder(root.left, arr);</span><br><span class="line">    arr.add(root.val);</span><br><span class="line">    inorder(root.right, arr);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; nums = inorder(root, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    <span class="keyword">return</span> nums.get(k - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>**复杂度分析**<ul><li>时间复杂度：<em>O(N)</em>，遍历了整个树。</li><li>空间复杂度：<em>O(N)</em>，用了一个数组存储中序序列。</li></ul><h1 id="方法二：迭代"><a href="#方法二：迭代" class="headerlink" title="方法二：迭代"></a>方法二：迭代</h1><p><strong>算法：</strong></p><p>在栈的帮助下，可以将方法一的递归转换为迭代，这样可以加快速度，因为这样可以不用遍历整个树，可以在找到答案后停止。</p><p><a href="https://pic.leetcode-cn.com/25159a5137867644b75f203ee1917645d2cd454d8f4871e371d7edfa67bef083-file_1579413216176" target="_blank" rel="noopener">迭代</a></p><details>    <summary>迭代python</summary><figure class="highlight python"><figcaption><span>[solution2-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, root, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        stack = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            root = stack.pop()</span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> k:</span><br><span class="line">                <span class="keyword">return</span> root.val</span><br><span class="line">            root = root.right</span><br></pre></td></tr></table></figure></details><details>    <summary>迭代java</summary><figure class="highlight java"><figcaption><span>[solution2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.add(root);</span><br><span class="line">        root = root.left;</span><br><span class="line">      &#125;</span><br><span class="line">      root = stack.removeLast();</span><br><span class="line">      <span class="keyword">if</span> (--k == <span class="number">0</span>) <span class="keyword">return</span> root.val;</span><br><span class="line">      root = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(H+k) ，其中 <em>H</em> 指的是树的高度，由于我们开始遍历之前，要先向下达到叶，当树是一个平衡树时：复杂度为 O(logN+k) 。当树是一个不平衡树时：复杂度为O(N+k) ，此时所有的节点都在左子树。</li><li>空间复杂度：O(H+k)  。当树是一个平衡树时：O(logN+k) 。当树是一个非平衡树时：O(N+k) 。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年8月" scheme="http://yoursite.com/categories/2020%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>380. 常数时间插入、删除和获取随机元素</title>
    <link href="http://yoursite.com/2020/08/21/380.%20%E5%B8%B8%E6%95%B0%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2020/08/21/380. 常数时间插入、删除和获取随机元素/</id>
    <published>2020-08-21T09:26:12.000Z</published>
    <updated>2020-08-22T05:41:24.660Z</updated>
    
    <content type="html"><![CDATA[<p>设计一个支持在平均时间复杂度 O(1)下，执行以下操作的数据结构。</p><a id="more"></a><p>操作:</p><pre><code>insert(val)：当元素 val 不存在时，向集合中插入该项。remove(val)：元素 val 存在时，从集合中移除该项。getRandom：随机返回现有集合中的一项。每个元素应该有相同的概率被返回。</code></pre><p>示例 :</p><pre><code>// 初始化一个空的集合。RandomizedSet randomSet = new RandomizedSet();// 向集合中插入 1 。返回 true 表示 1 被成功地插入。randomSet.insert(1);// 返回 false ，表示集合中不存在 2 。randomSet.remove(2);// 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。randomSet.insert(2);// getRandom 应随机返回 1 或 2 。randomSet.getRandom();// 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。randomSet.remove(1);// 2 已在集合中，所以返回 false 。randomSet.insert(2);// 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。randomSet.getRandom();</code></pre><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>我们需要在平均复杂度为  O(1)  实现以下操作：</p><ol><li><code>insert</code></li><li><code>remove</code></li><li><code>getRadom</code></li></ol><p>让我们想想如何实现它。从 <code>insert</code> 开始，我们具有两个平均插入时间为 O(1)的选择：</p><ul><li>哈希表：Java 中为 <code>HashMap</code>，Python 中为 <code>dictionary</code>。</li><li>动态数组：Java 中为 <code>ArrayList</code>，Python 中为 <code>list</code>。</li></ul><p>让我们一个个进行思考，虽然哈希表提供常数时间的插入和删除，但是实现 <code>getRandom</code> 时会出现问题。</p><p><code>getRandom</code> 的思想是选择一个随机索引，然后使用该索引返回一个元素。而哈希表中没有索引，因此要获得真正的随机值，则要将哈希表中的键转换为列表，这需要线性时间。解决的方法是用一个列表存储值，并在该列表中实现常数时间的 <code>getRandom</code>。</p><p>列表有索引可以实现常数时间的 <code>insert</code> 和 <code>getRandom</code>，则接下来的问题是如何实现常数时间的 <code>remove</code>。</p><p>删除任意索引元素需要线性时间，这里的解决方案是总是删除最后一个元素。</p><ul><li>将要删除元素和最后一个元素交换。</li><li>将最后一个元素删除。</li></ul><p>为此，必须在常数时间获取到要删除元素的索引，因此需要一个哈希表来存储值到索引的映射。</p><p>综上所述，我们使用以下数据结构：</p><ul><li>动态数组存储元素值</li><li>哈希表存储存储值到索引的映射。</li></ul><h1 id="方法：哈希表-动态数组"><a href="#方法：哈希表-动态数组" class="headerlink" title="方法：哈希表 + 动态数组"></a>方法：哈希表 + 动态数组</h1><h2 id="Insert"><a href="#Insert" class="headerlink" title="Insert:"></a><strong>Insert:</strong></h2><ul><li>添加元素到动态数组。</li><li>在哈希表中添加值到索引的映射</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMzgwL2lzZXJ0LnBuZw?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><details>    <summary>哈希表 + 动态数组python</summary><figure class="highlight python"><figcaption><span>[insert-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, val: int)</span> -&gt; bool:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Inserts a value to the set. Returns true if the set did not already contain the specified element.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> val <span class="keyword">in</span> self.dict:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    self.dict[val] = len(self.list)</span><br><span class="line">    self.list.append(val)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></details><details>    <summary>哈希表 + 动态数组java</summary><figure class="highlight java"><figcaption><span>[insert-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (dict.containsKey(val)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">  dict.put(val, list.size());</span><br><span class="line">  list.add(list.size(), val);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="remove"><a href="#remove" class="headerlink" title="remove:"></a><strong>remove:</strong></h2><ul><li>在哈希表中查找要删除元素的索引。</li><li>将要删除元素与最后一个元素交换。</li><li>删除最后一个元素。</li><li>更新哈希表中的对应关系。</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMzgwL2RlbGV0ZS5wbmc?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><details>    <summary>哈希表 + 动态数组python</summary><figure class="highlight python"><figcaption><span>[remove-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, val: int)</span> -&gt; bool:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Removes a value from the set. Returns true if the set contained the specified element.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> val <span class="keyword">in</span> self.dict:</span><br><span class="line">        <span class="comment"># move the last element to the place idx of the element to delete</span></span><br><span class="line">        last_element, idx = self.list[<span class="number">-1</span>], self.dict[val]</span><br><span class="line">        self.list[idx], self.dict[last_element] = last_element, idx</span><br><span class="line">        <span class="comment"># delete the last element</span></span><br><span class="line">        self.list.pop()</span><br><span class="line">        <span class="keyword">del</span> self.dict[val]</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></details><details>    <summary>哈希表 + 动态数组java</summary><figure class="highlight java"><figcaption><span>[remove-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Removes a value from the set. Returns true if the set contained the specified element. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (! dict.containsKey(val)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// move the last element to the place idx of the element to delete</span></span><br><span class="line">  <span class="keyword">int</span> lastElement = list.get(list.size() - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">int</span> idx = dict.get(val);</span><br><span class="line">  list.set(idx, lastElement);</span><br><span class="line">  dict.put(lastElement, idx);</span><br><span class="line">  <span class="comment">// delete the last element</span></span><br><span class="line">  list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">  dict.remove(val);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="getRandom："><a href="#getRandom：" class="headerlink" title="getRandom："></a><strong>getRandom：</strong></h2><p>借助 Python 中的 <code>random.choice</code> 和 Java 中 的 <code>Random</code> 实现。</p><details>    <summary>python</summary><figure class="highlight python"><figcaption><span>[getRandom-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getRandom</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Get a random element from the set.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> choice(self.list)</span><br></pre></td></tr></table></figure></details><details>    <summary>java</summary><figure class="highlight java"><figcaption><span>[getRandom-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Get a random element from the set. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> list.get(rand.nextInt(list.size()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="完整代码："><a href="#完整代码：" class="headerlink" title="完整代码："></a><strong>完整代码：</strong></h2><details>    <summary>python</summary><figure class="highlight python"><figcaption><span>[solution1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.dict = &#123;&#125;</span><br><span class="line">        self.list = []</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, val: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Inserts a value to the set. Returns true if the set did not already contain the specified element.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> self.dict:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        self.dict[val] = len(self.list)</span><br><span class="line">        self.list.append(val)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, val: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Removes a value from the set. Returns true if the set contained the specified element.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> self.dict:</span><br><span class="line">            <span class="comment"># move the last element to the place idx of the element to delete</span></span><br><span class="line">            last_element, idx = self.list[<span class="number">-1</span>], self.dict[val]</span><br><span class="line">            self.list[idx], self.dict[last_element] = last_element, idx</span><br><span class="line">            <span class="comment"># delete the last element</span></span><br><span class="line">            self.list.pop()</span><br><span class="line">            <span class="keyword">del</span> self.dict[val]</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRandom</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Get a random element from the set.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> choice(self.list)</span><br></pre></td></tr></table></figure></details><details>    <summary>java</summary><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> </span>&#123;</span><br><span class="line">  Map&lt;Integer, Integer&gt; dict;</span><br><span class="line">  List&lt;Integer&gt; list;</span><br><span class="line">  Random rand = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RandomizedSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dict = <span class="keyword">new</span> HashMap();</span><br><span class="line">    list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dict.containsKey(val)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    dict.put(val, list.size());</span><br><span class="line">    list.add(list.size(), val);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Removes a value from the set. Returns true if the set contained the specified element. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! dict.containsKey(val)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// move the last element to the place idx of the element to delete</span></span><br><span class="line">    <span class="keyword">int</span> lastElement = list.get(list.size() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> idx = dict.get(val);</span><br><span class="line">    list.set(idx, lastElement);</span><br><span class="line">    dict.put(lastElement, idx);</span><br><span class="line">    <span class="comment">// delete the last element</span></span><br><span class="line">    list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">    dict.remove(val);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Get a random element from the set. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> list.get(rand.nextInt(list.size()));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<code>getRandom</code> 时间复杂度为  O(1)，<code>insert</code> 和 <code>remove</code> 平均时间复杂度为  O(1) ，在最坏情况下为  O(N) 当元素数量超过当前分配的动态数组和哈希表的容量导致空间重新分配时。</li><li>空间复杂度：<em>O(N)*，在动态数组和哈希表分别存储了 *N</em> 个元素的信息。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计一个支持在平均时间复杂度 O(1)下，执行以下操作的数据结构。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年8月" scheme="http://yoursite.com/categories/2020%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Design" scheme="http://yoursite.com/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>454. 四数相加 II</title>
    <link href="http://yoursite.com/2020/08/21/454.%20%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0%20II/"/>
    <id>http://yoursite.com/2020/08/21/454. 四数相加 II/</id>
    <published>2020-08-21T07:34:12.000Z</published>
    <updated>2020-08-21T09:15:42.339Z</updated>
    
    <content type="html"><![CDATA[<p>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。</p><a id="more"></a><p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。</p><p>例如:</p><pre><code>输入:A = [ 1, 2]B = [-2,-1]C = [-1, 2]D = [ 0, 2]输出:2解释:两个元组如下:1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 02. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</code></pre><h1 id="map函数介绍"><a href="#map函数介绍" class="headerlink" title="map函数介绍"></a>map函数介绍</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当Map集合中有这个key时，就使用这个key值，如果没有就使用默认值defaultValue</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span></span></span><br><span class="line"><span class="function"><span class="comment">//如果key值已存在，则不替换对应的value</span></span></span><br><span class="line"><span class="function">V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span></span></span><br></pre></td></tr></table></figure><h1 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h1><p><strong>思路：</strong></p><p>一. 采用分为两组，HashMap存一组，另一组和HashMap进行比对。</p><p>二. 这样的话情况就可以分为三种：</p><pre><code>1. HashMap存一个数组，如A。然后计算三个数组之和，如BCD。时间复杂度为：O(n)+O(n^3),得到O(n^3).2. HashMap存三个数组之和，如ABC。然后计算一个数组，如D。时间复杂度为：O(n^3)+O(n),得到O(n^3).3. HashMap存两个数组之和，如AB。然后计算两个数组之和，如CD。时间复杂度为：O(n^2)+O(n^2),得到O(n^2).</code></pre><p>三.根据第二点我们可以得出要存两个数组算两个数组。</p><p>四.我们以存AB两数组之和为例。首先求出A和B任意两数之和sumAB，以sumAB为key，sumAB出现的次数为value，存入hashmap中。<br>然后计算C和D中任意两数之和的相反数sumCD，在hashmap中查找是否存在key为sumCD。<br>算法时间复杂度为O(n2)。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><details>    <summary>java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span>[] C, <span class="keyword">int</span>[] D)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a : A) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b : B) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum1 = a + b;</span><br><span class="line">            map1.put(sum1, map1.getOrDefault(sum1, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c : C) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d : D) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum2 = c + d;</span><br><span class="line">            <span class="keyword">if</span>(map1.containsKey(-sum2))  res += map1.get(-sum2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="方法二：二分查找"><a href="#方法二：二分查找" class="headerlink" title="方法二：二分查找"></a>方法二：二分查找</h1><p>1）求和法</p><p>A与B所有元素求和，得到数组first；</p><p>C与D所有元素求和，得到数组second：</p><p>2）对second进行排序；</p><p>3）针对first中数组元素*-1，在second数组中遍历，由于可能存在多个，因此我们要获得上边界和下边界</p><p>可以使用lower_bound 和upper_bound</p><p>也可以直接使用equal_range</p><details>    <summary>C++</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;C, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;D)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; firstvec;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; secondvec;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; A.size(); j++) &#123;</span><br><span class="line">                firstvec.push_back(A[i] + B[j]);</span><br><span class="line">                secondvec.push_back(C[i] + D[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sort(secondvec.begin(), secondvec.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; firstvec.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> findvalue = firstvec[i] * (<span class="number">-1</span>);</span><br><span class="line">            pair&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator&gt; range = equal_range(secondvec.begin(), secondvec.end(), findvalue);</span><br><span class="line">            result += range.second - range.first;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年8月" scheme="http://yoursite.com/categories/2020%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>171. Excel表列序号</title>
    <link href="http://yoursite.com/2020/08/21/Excel%E8%A1%A8%E5%88%97%E5%BA%8F%E5%8F%B7/"/>
    <id>http://yoursite.com/2020/08/21/Excel表列序号/</id>
    <published>2020-08-21T07:33:12.000Z</published>
    <updated>2020-08-21T09:16:24.239Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个Excel表格中的列名称，返回其相应的列序号。</p><a id="more"></a><p>例如，</p><pre><code>A -&gt; 1B -&gt; 2C -&gt; 3...Z -&gt; 26AA -&gt; 27AB -&gt; 28 ...</code></pre><p>示例 1:</p><pre><code>输入: &quot;A&quot;输出: 1</code></pre><p>示例 2:</p><pre><code>输入: &quot;AB&quot;输出: 28</code></pre><p>示例 3:</p><pre><code>输入: &quot;ZY&quot;输出: 701</code></pre><p>这道题很简单</p><h1 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>标签：字符串遍历，进制转换</li><li>初始化结果<code>ans = 0</code>，遍历时将每个字母与A做减法，因为A表示1，所以减法后需要每个数加1，计算其代表的数值<code>num = 字母 - ‘A’ + 1</code></li><li>因为有26个字母，所以相当于26进制，每26个数则向前进一位</li><li>所以每遍历一位则<code>ans = ans * 26 + num</code></li><li>以ZY为例，Z的值为26，Y的值为25，则结果为<code>26 * 26 + 25=701</code></li><li>时间复杂度：O(n)</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = s.charAt(i) - <span class="string">'A'</span> + <span class="number">1</span>;</span><br><span class="line">            ans = ans * <span class="number">26</span> + num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="画解"><a href="#画解" class="headerlink" title="画解"></a>画解</h2><p> <a href="https://pic.leetcode-cn.com/97416a122f3315e3a0eb9951a1d742e7c1734d915f4b96099610a92629899d04-frame_00001.png" target="_blank" rel="noopener">frame_00001.png</a></p><p> <a href="https://pic.leetcode-cn.com/a5e8e39fa19491e3e1d82c6aba3dec24e080c368d0400bf57012548b0fdb2af4-frame_00002.png" target="_blank" rel="noopener">frame_00002.png</a> </p><p> <a href="https://pic.leetcode-cn.com/da62003ebc140532fe1e42ff2c46d5c920101d6de50fd3c6910eee1e9d9c7df5-frame_00003.png" target="_blank" rel="noopener">frame_00003.png</a> </p><p> <a href="https://pic.leetcode-cn.com/4267220aeef6e659dcae4fa7b59d63c68efdb7b0f748d431d8acca4af278de65-frame_00004.png" target="_blank" rel="noopener">frame_00004.png</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个Excel表格中的列名称，返回其相应的列序号。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年8月" scheme="http://yoursite.com/categories/2020%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>328. 奇偶链表</title>
    <link href="http://yoursite.com/2020/08/21/328.%20%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/08/21/328. 奇偶链表/</id>
    <published>2020-08-21T03:45:12.000Z</published>
    <updated>2020-08-21T07:22:45.846Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p><a id="more"></a><p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p><p>示例 1:</p><pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</code></pre><p>示例 2:</p><pre><code>输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL 输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</code></pre><p>说明:</p><ul><li>应当保持奇数节点和偶数节点的相对顺序。</li><li>链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>我一开始想用快慢指针来解决，但是没有找到合适的方法来交换奇偶节点。所以还是采用下面的方法。</p><p><strong>想法</strong></p><p>将奇节点放在一个链表里，偶链表放在另一个链表里。然后把偶链表接在奇链表的尾部。</p><p><strong>算法</strong></p><p>这个解法非常符合直觉思路也很简单。但是要写一个精确且没有 bug 的代码还是很费一番功夫，想要避免空指针和循环链表的情况需要认真考虑边界条件。</p><p>一个 <code>LinkedList</code> 需要一个头指针和一个尾指针来支持双端操作。我们用变量 <code>head</code> 和 <code>odd</code> 保存奇链表的头和尾指针。 <code>evenHead</code> 和 <code>even</code> 保存偶链表的头和尾指针。算法会遍历原链表一次并把奇节点放到奇链表里去、偶节点放到偶链表里去。遍历整个链表我们至少需要一个指针作为迭代器。这里 <code>odd</code> 指针和 <code>even</code> 指针不仅仅是尾指针，也可以扮演原链表迭代器的角色。</p><p>解决链表问题最好的办法是在脑中或者纸上把链表画出来。比方说：</p><p><a href="https://pic.leetcode-cn.com/00bd1d974b5a2e6d7d4faf0d5baad1c691f4ed8963cb1b7133d1112bad4c5e86-image.png" target="_blank" rel="noopener">奇偶链表的例子</a></p><figure class="highlight java"><figcaption><span>[solution-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode odd = head, even = head.next, evenHead = even;</span><br><span class="line">        <span class="keyword">while</span> (even != <span class="keyword">null</span> &amp;&amp; even.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            odd.next = even.next;</span><br><span class="line">            odd = odd.next;</span><br><span class="line">            even.next = odd.next;</span><br><span class="line">            even = even.next;</span><br><span class="line">        &#125;</span><br><span class="line">        odd.next = evenHead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度： <em>O(n)</em> 。总共有 <em>n</em> 个节点，我们每个遍历一次。</p></li><li><p>空间复杂度： <em>O(1)</em> 。我们只需要 4 个指针。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年8月" scheme="http://yoursite.com/categories/2020%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>237. 删除链表中的节点</title>
    <link href="http://yoursite.com/2020/08/21/237.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>http://yoursite.com/2020/08/21/237. 删除链表中的节点/</id>
    <published>2020-08-21T03:12:12.000Z</published>
    <updated>2020-08-21T03:44:57.927Z</updated>
    
    <content type="html"><![CDATA[<p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点 。</p><a id="more"></a><p>现有一个链表 – head = [4,5,1,9]，它可以表示为:</p><p>示例 1：</p><pre><code>输入：head = [4,5,1,9], node = 5输出：[4,1,9]解释：给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</code></pre><p>示例 2：</p><pre><code>输入：head = [4,5,1,9], node = 1输出：[4,5,9]解释：给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</code></pre><p>提示：</p><pre><code>链表至少包含两个节点。链表中所有节点的值都是唯一的。给定的节点为非末尾节点并且一定是链表中的一个有效节点。不要从你的函数中返回任何结果。</code></pre><h1 id="方法：与下一个节点交换"><a href="#方法：与下一个节点交换" class="headerlink" title="方法：与下一个节点交换"></a>方法：与下一个节点交换</h1><p>我一开始用了遍历整个链表最后丢弃尾节点，后来发现并不需要这么麻烦</p><p>从链表里删除一个节点 <code>node</code> 的最常见方法是修改<em>之前</em>节点的 <code>next</code> 指针，使其指向<em>之后</em>的节点。</p><p><a href="https://pic.leetcode-cn.com/3579a496897df5321c110bf1301872b6e10c342f5e400ce45d2db0348d00d715-file_1555866623326" target="_blank" rel="noopener">image</a></p><p>因为，我们无法访问我们想要删除的节点 <em>之前</em> 的节点，我们始终不能修改该节点的 <code>next</code> 指针。相反，我们必须将想要删除的节点的值替换为它后面节点中的值，然后删除它之后的节点。</p><p><a href="https://pic.leetcode-cn.com/858fae01d89c2080eb7e45a1f9d9a2b2f76e1a5c87815b324fd946e0bd8da495-file_1555866651920" target="_blank" rel="noopener">image</a></p><p><a href="https://pic.leetcode-cn.com/902dc5d3f8c44d3cbc0b6e837711cad2eefc021fd2b9de8dfabc6d478bc779b1-file_1555866680932" target="_blank" rel="noopener">image</a></p><p><a href="https://pic.leetcode-cn.com/2a6409b98dd73d6649fdc6fb984c88690547127467104c3923367be6f8fbc916-file_1555866773685" target="_blank" rel="noopener">image</a></p><p>因为我们知道要删除的节点不是列表的末尾，所以我们可以保证这种方法是可行的。</p><figure class="highlight java"><figcaption><span>[juoWzFbK-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">    node.val = node.next.val;</span><br><span class="line">    node.next = node.next.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><p>时间和空间复杂度都是：<em>O(1)</em>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点 。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年8月" scheme="http://yoursite.com/categories/2020%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>234. 回文链表</title>
    <link href="http://yoursite.com/2020/08/20/234.%20%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/08/20/234. 回文链表/</id>
    <published>2020-08-20T09:53:12.000Z</published>
    <updated>2020-08-21T03:06:08.248Z</updated>
    
    <content type="html"><![CDATA[<p>请判断一个链表是否为回文链表。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: 1-&gt;2输出: false</code></pre><p>示例 2:</p><pre><code>输入: 1-&gt;2-&gt;2-&gt;1输出: true</code></pre><p>进阶：</p><p>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p><h1 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h1><ol><li>采用快慢两个指针去寻找链表的中间节点；</li><li>根据链表的中间节点反转后一半的链表；</li><li>迭代比较链表前一半的元素和后一半的元素，判断节点的值是否相等，得出是否为回文。</li></ol><h1 id="图解："><a href="#图解：" class="headerlink" title="图解："></a>图解：</h1><p><a href="https://pic.leetcode-cn.com/cb25ad29e4c902e12bfe088a79b491dc8e6ff890786f15ce6b176d5419bcbf71-%E9%93%BE%E8%A1%A8%E5%9B%9E%E6%96%87%E5%A5%87%E6%95%B0.jpeg" target="_blank" rel="noopener">链表回文奇数.jpeg</a></p><p><a href="https://pic.leetcode-cn.com/79a887a172f927142b591a28f2d4638223ee992279f6925ec418e1ce1cbc5c1a-%E9%93%BE%E8%A1%A8%E5%9B%9E%E6%96%87%E5%81%B6%E6%95%B0.jpeg" target="_blank" rel="noopener">链表回文偶数.jpeg</a></p><h1 id="解题代码："><a href="#解题代码：" class="headerlink" title="解题代码："></a>解题代码：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isPalindrome(ListNode head) &#123;</span><br><span class="line">        if(head == null) return true;</span><br><span class="line"></span><br><span class="line">        ListNode midNode = findMidNode(head);</span><br><span class="line">        ListNode secondHalfHead = reverseLinked(midNode.next);</span><br><span class="line">        ListNode curr1 = head;</span><br><span class="line">        ListNode curr2 = secondHalfHead;</span><br><span class="line"></span><br><span class="line">        boolean palindrome = true;</span><br><span class="line">        while(palindrome &amp;&amp; curr2 != null)&#123;</span><br><span class="line">            if(curr1.val != curr2.val) palindrome = false;</span><br><span class="line">            curr1 = curr1.next;</span><br><span class="line">            curr2 = curr2.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return palindrome;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 反转链表 */</span><br><span class="line">    private ListNode reverseLinked(ListNode head)&#123;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode prev = null;</span><br><span class="line">        while(cur != null)&#123;</span><br><span class="line">            ListNode nextTemp = cur.next;</span><br><span class="line">            cur.next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = nextTemp;</span><br><span class="line">        &#125;</span><br><span class="line">        return prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 快慢指针寻找中间节点 */</span><br><span class="line">    private ListNode findMidNode(ListNode head)&#123;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode low = head;</span><br><span class="line">        while(fast.next != null &amp;&amp; fast.next.next != null)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            low = low.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return low;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;请判断一个链表是否为回文链表。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年8月" scheme="http://yoursite.com/categories/2020%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>92. 反转链表II</title>
    <link href="http://yoursite.com/2020/08/19/92.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8II/"/>
    <id>http://yoursite.com/2020/08/19/92. 反转链表II/</id>
    <published>2020-08-19T09:15:12.000Z</published>
    <updated>2020-08-20T09:50:00.006Z</updated>
    
    <content type="html"><![CDATA[<p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p><a id="more"></a><p> 说明:<br>1 ≤ m ≤ n ≤ 链表长度。</p><p> 示例:</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4</p><p>输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</p><h1 id="方法一-递归"><a href="#方法一-递归" class="headerlink" title="方法一: 递归"></a>方法一: 递归</h1><p>这种方法实际上是交换节点的值而非反转链表的指针</p><p><strong>直觉</strong></p><p>使用递归反转链表的思路来源于反转字符串时使用的类似方法。反转字符串的一个巨大优势是可以使用下标信息。我们可以创建两个指针，一个开头，一个结尾。不断地交换这两个指针指向的元素，并将两个指针向中间移动。在分析链表的情况前，先让我们看看字符串上的示例。</p><p><a href="https://pic.leetcode-cn.com/7f6ec0687455cfecce2019fcb560d7066d7e7dfedd46922d3cc96bcbff3c1eb5-image.png" target="_blank" rel="noopener">image.png</a></p><p>反转给定链表的一部分的思路基于上述方法。我们需要两个不同指针，一个指向第 <em>m</em> 个结点，另一个指向第 <em>n</em> 个结点。一旦有了这两个指针，我们就可以不断地交换这两个指针指向结点的数据，并将两个指针相向移动，就像字符串的情况那样。</p><blockquote><p>然而，链表中没有向后指针，也没有下标。因此，我们需要使用递归来 <strong>模拟</strong> 向后指针。递归中的回溯可以帮助我们模拟一个指针从第<em>n</em>个结点向中心移动的移动过程。</p></blockquote><p><strong>算法</strong></p><ol><li>我们定义一个递归函数用于反转给定链表的一部分。</li><li>将函数记为 <code>recurse</code>。该函数使用三个参数: <code>m</code> 为反转的起点, <code>n</code> 为反转的终点, 以及从第 <em>n</em> 个结点开始，随着递归回溯过程向后移动的指针 <code>right</code>。不清楚的话，可以参考后文的示意图。</li><li>此外，我们还有一个指针 <code>left</code>，它从第 <code>m</code> 个结点开始向前移动。在 <code>Python</code> 中, 我们需要一个全局变量，值随着递归的进行而改变。在其他函数调用造成的变化可以持续的编程语言中，可以考虑将该指针加为函数 <code>recurse</code> 的一个变量。</li><li>在递归调用中，给定 <code>m</code>，<code>n</code>，和 <code>right</code>, 首先判断 <code>n = 1</code>。 若判断为真, 则结束。</li><li>于是，当 <code>n</code> 的值达到 1 时，我们便<strong>回溯</strong>。这时，<code>right</code> 指针在我们要反转的子链表结尾，<code>left</code> 到达了字列表的开头。于是，我们置换数据，并将 <code>left</code> 指针前移：<code>left = left.next</code>。我们需要此变化在回溯过程中保持。</li><li>自此，每当我们回溯时，<code>right</code> 指针向后移一位。这就是前文所说的模拟。通过回溯模拟向后移动。</li><li>当 <code>right == left</code> 或者 <code>right.next == left</code> 时停止交换。当子链表的长度为奇数时，情况为前者；当子链表长度为偶数时为后者。我们使用一个全局 boolean 变量 flag 来停止交换。</li></ol><p>下面是一系列整个算法的示意图，希望能够帮助你理解清楚。</p><p><img src="http://pic.leetcode-cn.com/1adc7164bea5cd650af1545682900c792bd37a82df607aeb4f87a233d3eb69cf-image.png" alt="image.png"></p><p>这是递归过程的第一步。给定所用链表，<code>left</code> 和 <code>right</code> 指针从链表的 <code>head</code> 开始。第一步是以更新过的 <code>m</code> 和 <code>n</code> 进行递归调用，换而言之，它们的值各自减 1。此外，<code>left</code> 和 <code>right</code> 指针向前移动一位。</p><p><a href="https://pic.leetcode-cn.com/162f18666a30ffd98e185da1311f2daa48b087b03d3a9eefeeb9541eafbcd013-image.png" target="_blank" rel="noopener">image.png</a></p><p>接下来的两步展示了 <code>left</code> 和 <code>right</code> 指针在链表中的移动。注意到在第二步之后，<code>left</code> 指针抵达了目标位置。因此，后续不再移动。从现在起，只有 <code>right</code> 指针继续移动，直到抵达结点 <code>6</code>。</p><p><a href="https://pic.leetcode-cn.com/4213450e7d9466ddf22f289d5e753df47a94a9a87789312a02de2979ed161718-image.png" target="_blank" rel="noopener">image.png</a></p><p>如你所见，在第五步之后，两个指针均抵达了目标位置，可以开始进行回溯。我们不再继续递归。回溯过程中的操作是交换 <code>left</code> 和 <code>right</code> 结点的数据。</p><p><a href="https://pic.leetcode-cn.com/36b2ed0c1859c5574a17597070797d8f26b77a9c13a0c3462ea150b1058fbbce-image.png" target="_blank" rel="noopener">image.png</a></p><p>如你所见，在第三步（回溯）之后，<code>right</code> 指针 <strong>穿过了</strong> <code>left</code> 指针，此时已经完成了要求部分链表的反转。结果是 <code>[7 → 9 → 8 → 1 → 10 → 2 → 6]</code>。 于是不再进行数据交换，在代码中，我们使用全局 boolean 变量 flag 来停止数据交换。不能直接跳出递归。</p><details>    <summary>递归Java</summary><figure class="highlight java"><figcaption><span>[solution 1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Object level variables since we need the changes</span></span><br><span class="line">    <span class="comment">// to persist across recursive calls and Java is pass by value.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> stop;</span><br><span class="line">    <span class="keyword">private</span> ListNode left;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recurseAndReverse</span><span class="params">(ListNode right, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// base case. Don't proceed any further</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Keep moving the right pointer one step forward until (n == 1)</span></span><br><span class="line">        right = right.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Keep moving left pointer to the right until we reach the proper node</span></span><br><span class="line">        <span class="comment">// from where the reversal is to start.</span></span><br><span class="line">        <span class="keyword">if</span> (m &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left = <span class="keyword">this</span>.left.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Recurse with m and n reduced.</span></span><br><span class="line">        <span class="keyword">this</span>.recurseAndReverse(right, m - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// In case both the pointers cross each other or become equal, we</span></span><br><span class="line">        <span class="comment">// stop i.e. don't swap data any further. We are done reversing at this</span></span><br><span class="line">        <span class="comment">// point.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left == right || right.next == <span class="keyword">this</span>.left) &#123;</span><br><span class="line">            <span class="keyword">this</span>.stop = <span class="keyword">true</span>;            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Until the boolean stop is false, swap data between the two pointers</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.stop) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="keyword">this</span>.left.val;</span><br><span class="line">            <span class="keyword">this</span>.left.val = right.val;</span><br><span class="line">            right.val = t;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Move left one step to the right.</span></span><br><span class="line">            <span class="comment">// The right pointer moves one step back via backtracking.</span></span><br><span class="line">            <span class="keyword">this</span>.left = <span class="keyword">this</span>.left.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = head;</span><br><span class="line">        <span class="keyword">this</span>.stop = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">this</span>.recurseAndReverse(head, m, n);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>递归Python</summary><figure class="highlight python"><figcaption><span>[solution 1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span><span class="params">(self, head, m, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        left, right = head, head</span><br><span class="line">        stop = <span class="keyword">False</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recurseAndReverse</span><span class="params">(right, m, n)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> left, stop</span><br><span class="line"></span><br><span class="line">            <span class="comment"># base case. Don't proceed any further</span></span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Keep moving the right pointer one step forward until (n == 1)</span></span><br><span class="line">            right = right.next</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Keep moving left pointer to the right until we reach the proper node</span></span><br><span class="line">            <span class="comment"># from where the reversal is to start.</span></span><br><span class="line">            <span class="keyword">if</span> m &gt; <span class="number">1</span>:</span><br><span class="line">                left = left.next</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Recurse with m and n reduced.</span></span><br><span class="line">            recurseAndReverse(right, m - <span class="number">1</span>, n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># In case both the pointers cross each other or become equal, we</span></span><br><span class="line">            <span class="comment"># stop i.e. don't swap data any further. We are done reversing at this</span></span><br><span class="line">            <span class="comment"># point.</span></span><br><span class="line">            <span class="keyword">if</span> left == right <span class="keyword">or</span> right.next == left:</span><br><span class="line">                stop = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Until the boolean stop is false, swap data between the two pointers     </span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stop:</span><br><span class="line">                left.val, right.val = right.val, left.val</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Move left one step to the right.</span></span><br><span class="line">                <span class="comment"># The right pointer moves one step back via backtracking.</span></span><br><span class="line">                left = left.next           </span><br><span class="line"></span><br><span class="line">        recurseAndReverse(right, m, n)</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度: <em>O(N)</em>。对每个结点最多处理两次。递归过程</li><li>回溯</li><li>在回溯过程中，我们只交换了一半的结点，但总复杂度是 <em>O(N)</em>。</li><li>空间复杂度: 最坏情况下为 <em>O(N)</em>。在最坏的情况下，我们需要反转整个链表。这是此时递归栈的大小。<br><br></li></ul><hr><h1 id="方法二-迭代链接反转"><a href="#方法二-迭代链接反转" class="headerlink" title="方法二: 迭代链接反转"></a>方法二: 迭代链接反转</h1><p>我一开始想到的就是通过迭代方法来反转，但是在处理反转后调整成环的情况时翻车了，想了半天，还是参照下面图例中的方法比较直观。</p><p><strong>直觉</strong></p><p>在上个方法中，我们研究了一种反转给定链表部分的算法，该算法不改变给定链表的内在结构，只是修改了对于结点的值。 然而，有时可能无法修改结点的数据值。这时，我们就需要改变结点的链接来完成反转。</p><p>从位置 <code>m</code> 到位置 <code>n</code> 的全部结点，我们需要反转每个结点的 <code>next</code> 指针。下面来看看具体的算法。</p><p><strong>算法</strong></p><p>在看具体算法之前，有必要先弄清楚链接反转的原理以及需要哪些指针。举例而言，有一个三个不同结点组成的链表 <code>A → B → C</code>，需要反转结点中的链接成为 <code>A ← B ← C</code>。</p><p>假设我们有两个指针，一个指向结点 <code>A</code>，一个指向结点 <code>B</code>。 分别记为 <code>prev</code> 和 <code>cur</code>。则可以用这两个指针简单地实现 <code>A 和 B</code> 之间的链接反转：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cur.next = prev</span><br></pre></td></tr></table></figure><p>这样做唯一的问题是，没有办法继续下去，换而言之，这样做之后就无法再访问到结点 <code>C</code>。因此，我们需要引入第三个指针，用于帮助反转过程的进行。因此，我们不采用上面的反转方法，而是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">third = cur.next</span><br><span class="line">cur.next = prev</span><br><span class="line">prev = cur</span><br><span class="line">cur = third</span><br></pre></td></tr></table></figure><p> <strong>迭代</strong> 地进行上述过程，即可完成问题的要求。下面来看看算法的步骤。</p><ol><li>如上所述，我们需要两个指针 <code>prev</code> 和 <code>cur</code>。</li><li><code>prev</code> 指针初始化为 <code>None</code>，<code>cur</code> 指针初始化为链表的 <code>head</code>。</li><li>一步步地向前推进 <code>cur</code> 指针，<code>prev</code> 指针跟随其后。</li><li>如此推进两个指针，直到 <code>cur</code> 指针到达从链表头起的第 <em>m</em> 个结点。这就是我们反转链表的起始位置。</li><li>注意我们要引入两个额外指针，分别称为 <code>tail</code> 和 <code>con</code>。<code>tail</code> 指针指向从链表头起的第<em>m</em>个结点，此结点是反转后链表的尾部，故称为 <code>tail</code>。<code>con</code> 指针指向第 <em>m</em> 个结点的前一个结点，此结点是新链表的头部。下图可以帮助你更好的理解这两个指针。</li></ol><p><a href="https://pic.leetcode-cn.com/bf38eaeb92184fbfb55bd76336c7f746b6f01b3c83bd921268afe84a3c3cf183-image.png" target="_blank" rel="noopener">image.png</a></p><ol start="6"><li><code>tail</code> 和 <code>con</code> 指针在算法开始时被初始化，在算法最后被调用，用于完成链表反转。</li><li>如前文所解释的那样，抵达第 <em>m</em> 个结点后，在用到上述两个指针前，先迭代地反转链接。不断迭代，直到完成指向第 <em>n</em> 个结点的链接。此时，<code>prev</code> 指针会指向第 <em>n</em> 个结点。</li><li>我们使用 <code>con</code> 指针来连接 <code>prev</code> 指针，这是因为 <code>prev</code> 指针当前指向的结点(第 <em>n</em> 个结点)会代替第 <em>m</em> 个结点的位置。 类似地，我们利用 <code>tail</code> 指针来连接 <code>prev</code> 指针之后的结点（第 <em>n+1</em> 个结点）。</li></ol><p>为了便于理清每个指针的用法，我们来看一个算法运行的实例。给定一个链表 <code>7 → 9 → 2 → 10 → 1 → 8 → 6</code>，我们需要反转从第 3 个结点到第 6 个结点的子链表。</p><p><a href="https://pic.leetcode-cn.com/08d4eb39be0db6ded442a208399b5778bbab1cf75c26bc5b3d93128b7c224cb4-image.png" target="_blank" rel="noopener">image.png</a></p><p>从上图可以看到迭代法的前几步。第一步展示了两个指针的初始化，第三步展示了链表反转过程的初始位置。</p><p><a href="https://pic.leetcode-cn.com/77af1e2ca8bd5f9ccc89802094ce07e2505c6b4483ccd6887f2762a6e67310e1-image.png" target="_blank" rel="noopener">image.png</a></p><p>上图详细显示了链接反转的过程以及反转两个结点的链接后如何向前移动。如下图所示，本步骤将执行多次。</p><p><a href="https://pic.leetcode-cn.com/f634c434bcc5092d84b3125a4cd7c723aa3ddd53dcfb9ec3077423cbff1d2f85-image.png" target="_blank" rel="noopener">image.png</a></p><p><a href="https://pic.leetcode-cn.com/b11861e6d3a86cdec19152d442dd243aaf0fb6c914787e7cf60990f2ecf0d558-image.png" target="_blank" rel="noopener">image.png</a></p><p>如上图所示, 两个指针都已经到达最终位置。我们完成了子链表的反转工作。然而，还有一些链接需要调整。下图展示了利用 <code>tail</code> 和 <code>con</code> 指针完成链接调整的过程。</p><p><a href="https://pic.leetcode-cn.com/968684e83b4cbc4b4db6f80e3bda03748729af672e702a8d3473b24cd04a7092-image.png" target="_blank" rel="noopener">image.png</a></p><details>    <summary>迭代链接反转Java</summary><figure class="highlight java"><figcaption><span>[solution 2]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Empty list</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Move the two pointers until they reach the proper starting point</span></span><br><span class="line">        <span class="comment">// in the list.</span></span><br><span class="line">        ListNode cur = head, prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (m &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            m--;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The two pointers that will fix the final connections.</span></span><br><span class="line">        ListNode con = prev, tail = cur;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Iteratively reverse the nodes until n becomes 0.</span></span><br><span class="line">        ListNode third = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            third = cur.next;</span><br><span class="line">            cur.next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = third;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Adjust the final connections as explained in the algorithm</span></span><br><span class="line">        <span class="keyword">if</span> (con != <span class="keyword">null</span>) &#123;</span><br><span class="line">            con.next = prev;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = prev;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tail.next = cur;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>迭代链接反转Python</summary><figure class="highlight python"><figcaption><span>[solution 2]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span><span class="params">(self, head, m, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Empty list</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Move the two pointers until they reach the proper starting point</span></span><br><span class="line">        <span class="comment"># in the list.</span></span><br><span class="line">        cur, prev = head, <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> m &gt; <span class="number">1</span>:</span><br><span class="line">            prev = cur</span><br><span class="line">            cur = cur.next</span><br><span class="line">            m, n = m - <span class="number">1</span>, n - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># The two pointers that will fix the final connections.</span></span><br><span class="line">        tail, con = cur, prev</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Iteratively reverse the nodes until n becomes 0.</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            third = cur.next</span><br><span class="line">            cur.next = prev</span><br><span class="line">            prev = cur</span><br><span class="line">            cur = third</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Adjust the final connections as explained in the algorithm</span></span><br><span class="line">        <span class="keyword">if</span> con:</span><br><span class="line">            con.next = prev</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            head = prev</span><br><span class="line">        tail.next = cur</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度: <em>O(N)*。考虑包含 *N</em> 个结点的链表。对每个节点最多会处理</li><li>（第 <em>n</em> 个结点之后的结点不处理）。</li><li>空间复杂度: <em>O(1)*。我们仅仅在原有链表的基础上调整了一些指针，只使用了 *O(1)</em> 的额外存储空间来获得结果。<br></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年8月" scheme="http://yoursite.com/categories/2020%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>206. 反转链表</title>
    <link href="http://yoursite.com/2020/08/18/206.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/08/18/206. 反转链表/</id>
    <published>2020-08-18T09:51:12.000Z</published>
    <updated>2020-08-19T09:56:23.485Z</updated>
    
    <content type="html"><![CDATA[<p>反转一个单链表。</p><a id="more"></a><p>示例:</p><pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</code></pre><p>进阶:</p><pre><code>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</code></pre><h1 id="方法一：迭代"><a href="#方法一：迭代" class="headerlink" title="方法一：迭代"></a>方法一：迭代</h1><p>假设存在链表 <code>1 → 2 → 3 → Ø</code>，我们想要把它改成 <code>Ø ← 1 ← 2 ← 3</code>。</p><p>在遍历列表时，将当前节点的 <code>next</code> 指针改为指向前一个元素。由于节点没有引用其上一个节点，因此必须事先存储其前一个元素。在更改引用之前，还需要另一个指针来存储下一个节点。不要忘记在最后返回新的头引用！</p><details>    <summary>迭代</summary><figure class="highlight java"><figcaption><span>[Tww6MiPp-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode nextTemp = curr.next;</span><br><span class="line">        curr.next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = nextTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(n)*，假设 *n</em> 是列表的长度，时间复杂度是 <em>O(n)</em>。</li><li>空间复杂度：<em>O(1)</em>。</li></ul><hr><h1 id="方法二：递归"><a href="#方法二：递归" class="headerlink" title="方法二：递归"></a>方法二：递归</h1><p>递归版本稍微复杂一些，其关键在于反向工作。假设列表的其余部分已经被反转，现在我该如何反转它前面的部分？</p><p>假设列表为：</p><p>n1→…→nk−1    →n k→n k+1→…→nm→∅</p><p>若从节点 <em>n_{k+1}</em> 到 <em>n_{m}</em> 已经被反转，而我们正处于 <em>n_{k}</em>。</p><p>n1→…→nk−1→n k→n k+1←…←nm</p><p>我们希望 <em>n_{k+1}</em> 的下一个节点指向 <em>n_{k}</em>。</p><p>所以，<em>n_{k}</em>.next.next = <em>n_{k}</em>。</p><p>要小心的是 <em>n_{1}</em> 的下一个必须指向 Ø 。如果你忽略了这一点，你的链表中可能会产生循环。如果使用大小为 2 的链表测试代码，则可能会捕获此错误。</p><details>    <summary>递归</summary><figure class="highlight java"><figcaption><span>[ESkYHVXb-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode p = reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>**复杂度分析**<ul><li>时间复杂度：<em>O(n)*，假设 *n</em> 是列表的长度，那么时间复杂度为 <em>O(n)</em>。</li><li>空间复杂度：<em>O(n)*，由于使用递归，将会使用隐式栈空间。递归深度可能会达到 *n</em> 层。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;反转一个单链表。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年8月" scheme="http://yoursite.com/categories/2020%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>160. 相交链表</title>
    <link href="http://yoursite.com/2020/08/18/160.%20%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/08/18/160. 相交链表/</id>
    <published>2020-08-18T08:55:12.000Z</published>
    <updated>2020-08-18T09:50:02.811Z</updated>
    
    <content type="html"><![CDATA[<p>编写一个程序，找到两个单链表相交的起始节点。</p><a id="more"></a><p>如下面的两个链表：</p><p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" target="_blank" rel="noopener">image</a></p><p>在节点 c1 开始相交。</p><p>示例 1：</p><pre><code>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Reference of the node with value = 8输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</code></pre><p>示例 2：</p><pre><code>输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Reference of the node with value = 2输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</code></pre><p>示例 3：</p><pre><code>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。解释：这两个链表不相交，因此返回 null。</code></pre><p>注意：</p><pre><code>如果两个链表没有交点，返回 null.在返回结果后，两个链表仍须保持原有的结构。可假定整个链表结构中没有循环。程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</code></pre><h1 id="方法一-暴力法"><a href="#方法一-暴力法" class="headerlink" title="方法一: 暴力法"></a>方法一: 暴力法</h1><p>对链表A中的每一个结点 <em>a_i*，遍历整个链表 <code>B</code> 并检查链表 <code>B</code> 中是否存在结点和 *a_i</em> 相同。</p><details>    <summary>暴力法</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;</span><br><span class="line">        ListNode p1=headA;</span><br><span class="line">        while (p1 != null) &#123;</span><br><span class="line">            ListNode p2 = headB;</span><br><span class="line">            while ( p2 != null) &#123;</span><br><span class="line">                if (p1 == p2) &#123;</span><br><span class="line">                    return p2;</span><br><span class="line">                &#125;</span><br><span class="line">                p2=p2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p1=p1.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>**复杂度分析*** 时间复杂度 : *(mn)*。* 空间复杂度 : *O(1)*。<br><br><hr><h1 id="方法二-哈希表法"><a href="#方法二-哈希表法" class="headerlink" title="方法二: 哈希表法"></a>方法二: 哈希表法</h1><p>遍历链表 <code>A</code> 并将每个结点的地址/引用存  储在哈希表中。然后检查链表 <code>B</code> 中的每一个结点 <em>b_i</em> 是否在哈希表中。若在，则 <em>b_i</em> 为相交结点。</p><details>    <summary>哈希表法</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;</span><br><span class="line">        if (headA == null || headB == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;ListNode,Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        ListNode pA = headA, pB = headB;</span><br><span class="line">        while (pA != null) &#123;</span><br><span class="line">            map.put(pA,1);</span><br><span class="line">            pA=pA.next;</span><br><span class="line">        &#125;</span><br><span class="line">        while (pB != null) &#123;</span><br><span class="line">            if (map.containsKey(pB)) &#123;</span><br><span class="line">                return pB;</span><br><span class="line">            &#125;</span><br><span class="line">            pB=pB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 : <em>O(m+n)</em>。</li><li>空间复杂度 : <em>O(m)</em> 或 <em>O(n)</em>。<br><br></li></ul><hr><h1 id="方法三：双指针法"><a href="#方法三：双指针法" class="headerlink" title="方法三：双指针法"></a>方法三：双指针法</h1><ul><li>创建两个指针 <em>pA</em> 和 <em>pB</em>，分别初始化为链表 <code>A</code> 和 <code>B</code> 的头结点。然后让它们向后逐结点遍历。 </li><li>当 <em>pA</em> 到达链表的尾部时，将它重定位到链表 <code>B</code> 的头结点 (你没看错，就是链表 <code>B</code>); 类似的，当 <em>pB</em> 到达链表的尾部时，将它重定位到链表 <code>A</code> 的头结点。 </li><li>若在某一时刻 <em>pA</em> 和 <em>pB</em> 相遇，则 <em>pA</em>/<em>pB</em> 为相交结点。</li><li>想弄清楚为什么这样可行, 可以考虑以下两个链表: <code>A={1,3,5,7,9,11}</code> 和 <code>B={2,4,9,11}</code>，相交于结点 <code>9</code>。 由于 <code>B.length (=4) &lt; A.length (=6)</code>，<em>pB</em> 比 <em>pA</em> 少经过 <em>2</em> 个结点，会先到达尾部。将 <em>pB</em> 重定向到 <code>A</code> 的头结点，<em>pA</em> 重定向到 <code>B</code> 的头结点后，<em>pB</em> 要比 <em>pA</em> 多走 <code>2</code> 个结点。因此，它们会同时到达交点。</li><li>如果两个链表存在相交，它们末尾的结点必然相同。因此当 <em>pA</em>/<em>pB</em> 到达链表结尾时，记录下链表 <code>A/B</code> 对应的元素。若最后元素不相同，则两个链表不相交。</li></ul><p>这里使用图解的方式，解释比较巧妙的一种实现。</p><p>根据题目意思<br>如果两个链表相交，那么相交点之后的长度是相同的</p><p>我们需要做的事情是，让两个链表从同距离末尾同等距离的位置开始遍历。这个位置只能是较短链表的头结点位置。<br>为此，我们必须消除两个链表的长度差</p><ol><li>指针 pA 指向 A 链表，指针 pB 指向 B 链表，依次往后遍历</li><li>如果 pA 到了末尾，则 pA = headB 继续遍历</li><li>如果 pB 到了末尾，则 pB = headA 继续遍历</li><li>比较长的链表指针指向较短链表head时，长度差就消除了</li><li>如此，只需要将最短链表遍历两次即可找到位置</li></ol><p>听着可能有点绕，看图最直观，链表的题目最适合看图了</p><p><a href="https://pic.leetcode-cn.com/e86e947c8b87ac723b9c858cd3834f9a93bcc6c5e884e41117ab803d205ef662-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8.png" target="_blank" rel="noopener">相交链表</a></p><p>代码也很简单（此处代码是参考评论区的高手的）</p><details>    <summary>双指针法</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode pA = headA, pB = headB;</span><br><span class="line">        <span class="keyword">while</span> (pA != pB) &#123;</span><br><span class="line">            pA = pA == <span class="keyword">null</span> ? headB : pA.next;</span><br><span class="line">            pB = pB == <span class="keyword">null</span> ? headA : pB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 : <em>O(m+n)</em>。</li><li>空间复杂度 : <em>O(1)</em>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写一个程序，找到两个单链表相交的起始节点。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年8月" scheme="http://yoursite.com/categories/2020%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>142. 环形链表II</title>
    <link href="http://yoursite.com/2020/07/25/142.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/"/>
    <id>http://yoursite.com/2020/07/25/142. 环形链表II/</id>
    <published>2020-07-25T10:22:12.000Z</published>
    <updated>2020-07-31T06:41:23.218Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个链表，返回链表开始入环的第一个节点。如果链表无环，则返回null。</p><a id="more"></a><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p>说明：不允许修改给定的链表。</p><p>示例 1：</p><pre><code>输入：head = [3,2,0,-4], pos = 1输出：tail connects to node index 1解释：链表中有一个环，其尾部连接到第二个节点。</code></pre><p>示例 2：</p><pre><code>输入：head = [1,2], pos = 0输出：tail connects to node index 0解释：链表中有一个环，其尾部连接到第一个节点。</code></pre><p>示例 3：</p><pre><code>输入：head = [1], pos = -1输出：no cycle解释：链表中没有环。</code></pre><p>进阶：<br>你是否可以不用额外空间解决此题？</p><h1 id="方法-1：哈希表"><a href="#方法-1：哈希表" class="headerlink" title="方法 1：哈希表"></a>方法 1：哈希表</h1><p><strong>想法</strong></p><p>如果我们用一个 <code>Set</code> 保存已经访问过的节点，我们可以遍历整个列表并返回第一个出现重复的节点。</p><p><strong>算法</strong></p><p>首先，我们分配一个 <code>Set</code> 去保存所有的列表节点。我们逐一遍历列表，检查当前节点是否出现过，如果节点已经出现过，那么一定形成了环且它是环的入口。否则如果有其他点是环的入口，我们应该先访问到其他节点而不是这个节点。其他情况，没有成环则直接返回 <code>null</code> 。</p><p>算法会在遍历有限个节点后终止，这是因为输入列表会被分成两类：成环的和不成环的。一个不成欢的列表在遍历完所有节点后会到达 <code>null</code> - 即链表的最后一个元素后停止。一个成环列表可以想象成是一个不成环列表将最后一个 <code>null</code> 元素换成环的入口。</p><p>如果 <code>while</code> 循环终止，我们返回 <code>null</code> 因为我们已经将所有的节点遍历了一遍且没有遇到重复的节点，这种情况下，列表是不成环的。对于循环列表， <code>while</code> 循环永远不会停止，但在某个节点上， <code>if</code> 条件会被满足并导致函数的退出。</p><details>    <summary>哈希表Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Set&lt;ListNode&gt; visited = <span class="keyword">new</span> HashSet&lt;ListNode&gt;();</span><br><span class="line"></span><br><span class="line">        ListNode node = head;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.contains(node)) &#123;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">            visited.add(node);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>哈希表Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        visited = set()</span><br><span class="line"></span><br><span class="line">        node = head</span><br><span class="line">        <span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">return</span> node</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                visited.add(node)</span><br><span class="line">                node = node.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)</em></p><p>  不管是成环还是不成环的输入，算法肯定都只会访问每个节点一次。对于非成环列表这是显而易见的，因为第 <em>n</em> 个节点指向 <code>null</code> ，这会让循环退出。对于循环列表， <code>if</code> 条件满足时会导致函数的退出，因为它指向了某个已经访问过的节点。两种情况下，访问的节点数最多都是 <em>n</em> 个，所以运行时间跟节点数目成线性关系。</p></li><li><p>空间复杂度：<em>O(n)</em></p><p>  不管成环或者不成欢的输入，我们都需要将每个节点插入 <code>Set</code> 中一次。两者唯一的区别是最后访问的节点后是 <code>null</code> 还是一个已经访问过的节点。因此，由于 <code>Set</code> 包含 <em>n</em> 个不同的节点，所需空间与节点数目也是线性关系的。</p></li></ul><hr><h1 id="方法-2：Floyd-算法"><a href="#方法-2：Floyd-算法" class="headerlink" title="方法 2：Floyd 算法"></a>方法 2：Floyd 算法</h1><p><strong>想法</strong></p><p>当然一个跑得快的人和一个跑得慢的人在一个圆形的赛道上赛跑，会发生什么？在某一个时刻，跑得快的人一定会从后面赶上跑得慢的人。</p><p><strong>算法</strong></p><p>Floyd 的算法被划分成两个不同的 <em>阶段</em> 。在第一阶段，找出列表中是否有环，如果没有环，可以直接返回 <code>null</code> 并退出。否则，用 <code>相遇节点</code> 来找到环的入口。</p><h2 id="阶段-1"><a href="#阶段-1" class="headerlink" title="阶段 1"></a>阶段 1</h2><p>这里我们初始化两个指针 - 快指针和慢指针。我们每次移动慢指针一步、快指针两步，直到快指针无法继续往前移动。如果在某次移动后，快慢指针指向了同一个节点，我们就返回它。否则，我们继续，直到 <code>while</code> 循环终止且没有返回任何节点，这种情况说明没有成环，我们返回 <code>null</code> 。</p><p>下图说明了这个算法的工作方式：</p><p> <a href="https://pic.leetcode-cn.com/ea37804a3d86a51a1bf827b9068e1f515ffddf840a0563ea0d1174c58ac64352-image.png" target="_blank" rel="noopener">image.png</a></p><p>环中的节点从 0 到 <em>C-1</em> 编号，其中 <em>C</em> 是环的长度。非环节点从 <em>-F</em> 到 <em>-1</em> 编号，其中 <em>F</em> 是环以外节点的数目。 <em>F</em> 次迭代以后，慢指针指向了 0 且快指针指向某个节点 <em>h</em> ，其中F=h(mod C) 。这是因为快指针在 <em>F</em> 次迭代中遍历了 <em>2F</em> 个节点，且恰好有 <em>F</em> 个在环中。继续迭代 <em>C-h</em> 次，慢指针显然指向第 <em>C-h</em> 号节点，而快指针也会指向相同的节点。原因在于，快指针从 <em>h</em> 号节点出发遍历了 <em>2(C-h)</em> 个节点。</p><pre><code>h+2(C−h)=2C−h≡C−h(modC)</code></pre><p>因此，如果列表是有环的，快指针和慢指针最后会同时指向同一个节点，因此被称为 <em>相遇</em> 。</p><h2 id="阶段-2"><a href="#阶段-2" class="headerlink" title="阶段 2"></a>阶段 2</h2><p>给定阶段 1 找到的相遇点，阶段 2 将找到环的入口。首先我们初始化额外的两个指针： <code>ptr1</code> ，指向链表的头， <code>ptr2</code> 指向相遇点。然后，我们每次将它们往前移动一步，直到它们相遇，它们相遇的点就是环的入口，返回这个节点。</p><p>下面的图将更好的帮助理解和证明这个方法的正确性。</p><p> <a href="https://pic.leetcode-cn.com/99987d4e679fdfbcfd206a4429d9b076b46ad09bd2670f886703fb35ef130635-image.png" target="_blank" rel="noopener">image.png</a></p><p>我们利用已知的条件：慢指针移动 1 步，快指针移动 2 步，来说明它们相遇在环的入口处。（下面证明中的 tortoise 表示慢指针，hare 表示快指针）</p><pre><code>2⋅distance(tortoise)=distance(hare)2(F+a)=F+a+b+a2F+2a=F+2a+bF=b</code></pre><p>因为 <em>F=b</em> ，指针从 <em>h</em> 点出发和从链表的头出发，最后会遍历相同数目的节点后在环的入口处相遇。</p><p><strong>这个公式F=b其实就说明了相遇节点和头节点距离入口节点的距离是相同的，所以只要从这两个节点同时出发一定会在入口节点相遇。</strong></p><p>下面的动画中动态地演示了整个算法过程：</p><p>  <a href="https://pic.leetcode-cn.com/26d91419cd4e90a8954f4253f779681e135527eb9efcfa761fdea990f6b10770-image.png" target="_blank" rel="noopener">image.png</a>  <a href="https://pic.leetcode-cn.com/4e82b6ff8e2e46f006da98414ae9f9e5ba342e90405ecc37802e83d7652f33aa-image.png" target="_blank" rel="noopener">image.png</a>  <a href="https://pic.leetcode-cn.com/efe62f7f9d2b003819dc617dab2342e1b7428a9019fcd5eeceef383b0bf1c6fc-image.png" target="_blank" rel="noopener">image.png</a>  <a href="https://pic.leetcode-cn.com/05848364a6b75ced28ad6d5f172bf18f9f37c58e89382c7c6f4c5715c00b4d17-image.png" target="_blank" rel="noopener">image.png</a>  <a href="https://pic.leetcode-cn.com/b16ab0dbc5d98adf9b79f9cf1a83b352c1f316dde4f28aab24d980bc17e7a38d-image.png" target="_blank" rel="noopener">image.png</a>  <a href="https://pic.leetcode-cn.com/0e1f5788dba0f811c0bfc63fa275424885d3373b43616ab51efb07c8b811f52e-image.png" target="_blank" rel="noopener">image.png</a>  <a href="https://pic.leetcode-cn.com/566912d38a4fdf7f9fed96cd4d50104c2a110ef24c491e3b8596f0591df1e77c-image.png" target="_blank" rel="noopener">image.png</a>  <a href="https://pic.leetcode-cn.com/c1aa9989085dacdbfc527130186eeffd1af8a1710528b5c10b318314f5c9ff79-image.png" target="_blank" rel="noopener">image.png</a>  <a href="https://pic.leetcode-cn.com/e1f0345de3ffc0eff25b1ecd4d80e121c7f38610d2a74f3b98ac38bfd5d38c92-image.png" target="_blank" rel="noopener">image.png</a>  <a href="https://pic.leetcode-cn.com/4f90bf4e8f1a7d44b686a23394e000573f2bf551fa62816e523161bf0d2da474-image.png" target="_blank" rel="noopener">image.png</a>  <a href="https://pic.leetcode-cn.com/b7d865deedbda8d686fa9c57e9cc819b57527325e852f26721d1fbcd62719757-image.png" target="_blank" rel="noopener">image.png</a>  <a href="https://pic.leetcode-cn.com/744cd130ed875602db99c9ee82f2e7d4b6681831b7674ae919764b5e87e44cd5-image.png" target="_blank" rel="noopener">image.png</a>  <a href="https://pic.leetcode-cn.com/a0dc8d96c672509eabcd2ba856c1d533fa2208894a7e40c05981e1616576c8f4-image.png" target="_blank" rel="noopener">image.png</a> </p><details>    <summary>Floyd 算法Java版</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">getIntersect</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode tortoise = head;</span><br><span class="line">        ListNode hare = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// A fast pointer will either loop around a cycle and meet the slow</span></span><br><span class="line">        <span class="comment">// pointer or reach the `null` at the end of a non-cyclic list.</span></span><br><span class="line">        <span class="keyword">while</span> (hare != <span class="keyword">null</span> &amp;&amp; hare.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            tortoise = tortoise.next;</span><br><span class="line">            hare = hare.next.next;</span><br><span class="line">            <span class="keyword">if</span> (tortoise == hare) &#123;</span><br><span class="line">                <span class="keyword">return</span> tortoise;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there is a cycle, the fast/slow pointers will intersect at some</span></span><br><span class="line">        <span class="comment">// node. Otherwise, there is no cycle, so we cannot find an e***ance to</span></span><br><span class="line">        <span class="comment">// a cycle.</span></span><br><span class="line">        ListNode intersect = getIntersect(head);</span><br><span class="line">        <span class="keyword">if</span> (intersect == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// To find the e***ance to the cycle, we have two pointers traverse at</span></span><br><span class="line">        <span class="comment">// the same speed -- one from the front of the list, and the other from</span></span><br><span class="line">        <span class="comment">// the point of intersection.</span></span><br><span class="line">        ListNode ptr1 = head;</span><br><span class="line">        ListNode ptr2 = intersect;</span><br><span class="line">        <span class="keyword">while</span> (ptr1 != ptr2) &#123;</span><br><span class="line">            ptr1 = ptr1.next;</span><br><span class="line">            ptr2 = ptr2.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ptr1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Floyd 算法Python版</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersect</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        tortoise = head</span><br><span class="line">        hare = head</span><br><span class="line"></span><br><span class="line">        <span class="comment"># A fast pointer will either loop around a cycle and meet the slow</span></span><br><span class="line">        <span class="comment"># pointer or reach the `null` at the end of a non-cyclic list.</span></span><br><span class="line">        <span class="keyword">while</span> hare <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> hare.next <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            tortoise = tortoise.next</span><br><span class="line">            hare = hare.next.next</span><br><span class="line">            <span class="keyword">if</span> tortoise == hare:</span><br><span class="line">                <span class="keyword">return</span> tortoise</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># If there is a cycle, the fast/slow pointers will intersect at some</span></span><br><span class="line">        <span class="comment"># node. Otherwise, there is no cycle, so we cannot find an e***ance to</span></span><br><span class="line">        <span class="comment"># a cycle.</span></span><br><span class="line">        intersect = self.getIntersect(head)</span><br><span class="line">        <span class="keyword">if</span> intersect <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># To find the e***ance to the cycle, we have two pointers traverse at</span></span><br><span class="line">        <span class="comment"># the same speed -- one from the front of the list, and the other from</span></span><br><span class="line">        <span class="comment"># the point of intersection.</span></span><br><span class="line">        ptr1 = head</span><br><span class="line">        ptr2 = intersect</span><br><span class="line">        <span class="keyword">while</span> ptr1 != ptr2:</span><br><span class="line">            ptr1 = ptr1.next</span><br><span class="line">            ptr2 = ptr2.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ptr1</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)</em></p><p>  对有环列表，快指针和慢指针在 <em>F+C-h</em> 次迭代以后会指向同一个节点，正如上面正确性证明所示，  F+C-h≤F+C=n  ，所以阶段 1 运行时间在 <em>O(n)</em> 时间以内，阶段 2 运行 <em>F &lt; n</em> 次迭代，所以它运行时间也在 <em>O(n)</em> 以内。</p><p>  对于无环链表，快指针大约需要迭代 n/2  次会抵达链表的尾部，这样不会进入阶段 2 就直接退出。</p><p>  因此，不管是哪一类链表，都会在与节点数成线性关系的时间内运行完。</p></li><li><p>空间复杂度：<em>O(1)</em></p><p>Floyd 的快慢指针算法仅需要几个指针，所以只需常数级别的额外空间。</p></li></ul><h2 id="直观理解"><a href="#直观理解" class="headerlink" title="直观理解"></a>直观理解</h2><p>看不懂算式证明的话，或者你可以这样解释性地来理解阶段2：</p><ol><li><p>快指针1次走2步，慢指针1次走1步。所以快指针总是走了慢指针两倍的路。</p></li><li><p>回顾一下阶段1的过程，设头节点到入环点的路途为 n, 那么慢指针走了入环路途的一半（n/2）时，快指针就到达入环点了(走完n了)。</p></li><li><p>慢指针再继续走完剩下的一般入环路途（剩下的n/2），到达入环点时，快指针已经在环内又走了一个 n 那么远的路了。</p></li><li><p>为了方便理解，这里先讨论环很大，大于n的情况（其他情况后文补充）。此时，慢指针正处于入环点，快指针距离入环点的距离为n。环内路，可以用此时快指针的位置分割为两段，前面的 n 部分，和后面的 b 部分。</p></li><li><p>此时开始继续快慢指针跑圈，因为已经在环内了，他们其实就是在一条nbnbnbnbnbnbnb（无尽nb路）上跑步。</p></li><li><p>慢指针从入环处开始跑b步，距离入环处就剩下了n。此时，快指针则是从距离入环处n步远的位置开始跑了2b步，距离入环处也是剩下了n。他们相遇了，并且距离入环处的距离就是n，n就是头节点到入环点的距离阿!!! 后面的不用说了吧。</p></li></ol><p>环很小的情况，其实跟环很大是一样的，比如你可以理解为将多个小环的循环铺开，虚拟扩展成一个大环来理解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个链表，返回链表开始入环的第一个节点。如果链表无环，则返回null。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年7月" scheme="http://yoursite.com/categories/2020%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>148. 排序链表</title>
    <link href="http://yoursite.com/2020/07/25/148.%20%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/07/25/148. 排序链表/</id>
    <published>2020-07-25T10:22:12.000Z</published>
    <updated>2020-08-18T08:48:04.575Z</updated>
    
    <content type="html"><![CDATA[<p>在O(nlogn) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4</code></pre><p>示例 2:</p><pre><code>输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</code></pre><p>这道题拖的时间比较长，从写博客到做完持续了半个多月，创纪录了，第二种解法还没太吃透，有待深究。</p><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p><p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p><ol><li><p>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</p></li><li><p>自下而上的迭代；</p></li></ol><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</p></li><li><p>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</p></li><li><p>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</p></li><li><p>重复步骤 3 直到某一指针达到序列尾；</p></li><li><p>将另一序列剩下的所有元素直接复制到合并序列尾。</p></li></ol><h1 id="解答一：归并排序（递归法）"><a href="#解答一：归并排序（递归法）" class="headerlink" title="解答一：归并排序（递归法）"></a>解答一：归并排序（递归法）</h1><ul><li><p>题目要求时间空间复杂度分别为<em>O(nlogn)</em>和<em>O(1)</em>，根据时间复杂度我们自然想到二分法，从而联想到归并排序；</p></li><li><p>对数组做归并排序的空间复杂度为 <em>O(n)</em>，分别由新开辟数组<em>O(n)</em>和递归函数调用<em>O(logn)</em>组成，而根据链表特性：</p><ul><li>数组额外空间：链表可以通过修改引用来更改节点顺序，无需像数组一样开辟额外空间；</li><li>递归额外空间：递归调用函数将带来<em>O(logn)</em>的空间复杂度，因此若希望达到<em>O(1)</em>空间复杂度，则不能使用递归。</li></ul></li><li><p>通过递归实现链表归并排序，有以下两个环节：</p><ul><li><strong>分割 cut 环节：</strong> 找到当前链表<code>中点</code>，并从<code>中点</code>将链表断开（以便在下次递归 <code>cut</code> 时，链表片段拥有正确边界）；<ul><li>我们使用 <code>fast,slow</code> 快慢双指针法，奇数个节点找到中点，偶数个节点找到中心左边的节点。</li><li>找到中点 <code>slow</code> 后，执行 <code>slow.next = None</code> 将链表切断。</li><li>递归分割时，输入当前链表左端点 <code>head</code> 和中心节点 <code>slow</code> 的下一个节点 <code>tmp</code>(因为链表是从 <code>slow</code> 切断的)。</li><li><strong>cut 递归终止条件：</strong> 当<code>head.next == None</code>时，说明只有一个节点了，直接返回此节点。</li></ul></li><li><strong>合并 merge 环节：</strong> 将两个排序链表合并，转化为一个排序链表。<ul><li>双指针法合并，建立辅助ListNode <code>h</code> 作为头部。</li><li>设置两指针 <code>left</code>, <code>right</code> 分别指向两链表头部，比较两指针处节点值大小，由小到大加入合并链表头部，指针交替前进，直至添加完两个链表。</li><li>返回辅助ListNode <code>h</code> 作为头部的下个节点 <code>h.next</code>。</li><li>时间复杂度 <code>O(l + r)</code>，<code>l, r</code> 分别代表两个链表长度。 </li></ul></li><li>当题目输入的 <code>head == None</code> 时，直接返回None。</li></ul></li></ul><p><img src="https://pic.leetcode-cn.com/8c47e58b6247676f3ef14e617a4686bc258cc573e36fcf67c1b0712fa7ed1699-Picture2.png" alt="Picture2.png"></p><details>    <summary>归并排序（递归法）python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next: <span class="keyword">return</span> head <span class="comment"># termination.</span></span><br><span class="line">        <span class="comment"># cut the LinkedList at the mid index.</span></span><br><span class="line">        slow, fast = head, head.next</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            fast, slow = fast.next.next, slow.next</span><br><span class="line">        mid, slow.next = slow.next, <span class="keyword">None</span> <span class="comment"># save and cut.</span></span><br><span class="line">        <span class="comment"># recursive for cutting.</span></span><br><span class="line">        left, right = self.sortList(head), self.sortList(mid)</span><br><span class="line">        <span class="comment"># merge `left` and `right` linked list and return it.</span></span><br><span class="line">        h = res = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">if</span> left.val &lt; right.val: h.next, left = left, left.next</span><br><span class="line">            <span class="keyword">else</span>: h.next, right = right, right.next</span><br><span class="line">            h = h.next</span><br><span class="line">        h.next = left <span class="keyword">if</span> left <span class="keyword">else</span> right</span><br><span class="line">        <span class="keyword">return</span> res.next</span><br></pre></td></tr></table></figure></details><details>    <summary>归并排序（递归法）java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//分割 cut 环节： 找到当前链表中点，并从中点将链表断开（以便在下次递归 cut 时，链表片段拥有正确边界）；</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//cut 递归终止条件： 当head.next == None时，说明只有一个节点了，直接返回此节点</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用 fast,slow 快慢双指针法，奇数个节点找到中点，偶数个节点找到中心左边的节点</span></span><br><span class="line">        ListNode fast=head.next,slow=head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到中点 slow 后，执行 slow.next = None 将链表切断</span></span><br><span class="line">        ListNode tmp=slow.next;</span><br><span class="line">        slow.next=<span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//递归分割时，输入当前链表左端点 head 和中心节点 slow 的下一个节点 tmp</span></span><br><span class="line">        ListNode left = sortList(head);</span><br><span class="line">        ListNode right = sortList(tmp);</span><br><span class="line">        <span class="comment">//合并 merge 环节： 将两个排序链表合并，转化为一个排序链表。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//双指针法合并，建立辅助ListNode h 作为头部。</span></span><br><span class="line">        ListNode h = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode res=h;</span><br><span class="line">        <span class="comment">//设置两指针 left, right 分别指向两链表头部，比较两指针处节点值大小，由小到大加入合并链表头部，指针交替前进，直至添加完两个链表。</span></span><br><span class="line">        <span class="keyword">while</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left.val &lt; right.val) &#123;</span><br><span class="line">                h.next = left;</span><br><span class="line">                left = left.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                h.next=right;</span><br><span class="line">                right=right.next;</span><br><span class="line">            &#125;</span><br><span class="line">            h = h.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回辅助ListNode h 作为头部的下个节点 h.next。</span></span><br><span class="line">        h.next=(left !=<span class="keyword">null</span>) ? left:right;</span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="解答二：归并排序（从底至顶直接合并）"><a href="#解答二：归并排序（从底至顶直接合并）" class="headerlink" title="解答二：归并排序（从底至顶直接合并）"></a>解答二：归并排序（从底至顶直接合并）</h1><ul><li>对于非递归的归并排序，需要使用迭代的方式替换<code>cut</code>环节：<ul><li>我们知道，<code>cut</code>环节本质上是通过二分法得到链表最小节点单元，再通过多轮合并得到排序结果。</li><li>每一轮合并<code>merge</code>操作针对的单元都有固定长度<code>intv</code>，例如：<ul><li>第一轮合并时<code>intv = 1</code>，即将整个链表切分为多个长度为1的单元，并按顺序两两排序合并，合并完成的已排序单元长度为2。</li><li>第二轮合并时<code>intv = 2</code>，即将整个链表切分为多个长度为2的单元，并按顺序两两排序合并，合并完成已排序单元长度为4。</li><li>以此类推，直到单元长度<code>intv &gt;= 链表长度</code>，代表已经排序完成。</li></ul></li><li>根据以上推论，我们可以仅根据<code>intv</code>计算每个单元边界，并完成链表的每轮排序合并，例如:<ul><li>当<code>intv = 1</code>时，将链表第<code>1</code>和第<code>2</code>节点排序合并，第<code>3</code>和第<code>4</code>节点排序合并，……。</li><li>当<code>intv = 2</code>时，将链表第<code>1-2</code>和第<code>3-4</code>节点排序合并，第<code>5-6</code>和第<code>7-8</code>节点排序合并，……。</li><li>当<code>intv = 4</code>时，将链表第<code>1-4</code>和第<code>5-8</code>节点排序合并，第<code>9-12</code>和第<code>13-16</code>节点排序合并，……。</li></ul></li></ul></li><li>此方法时间复杂度<em>O(nlogn)</em>，空间复杂度<em>O(1)</em>。</li></ul><p><img src="https://pic.leetcode-cn.com/c1d5347aa56648afdec22372ee0ed13cf4c25347bd2bb9727b09327ce04360c2-Picture1.png" alt="Picture1.png"></p><ul><li>模拟上述的多轮排序合并：<ul><li>统计链表长度<code>length</code>，用于通过判断<code>intv &lt; length</code>判定是否完成排序；</li><li>额外声明一个节点<code>res</code>，作为头部后面接整个链表，用于：<ul><li><code>intv *= 2</code>即切换到下一轮合并时，可通过<code>res.next</code>找到链表头部<code>h</code>；</li><li>执行排序合并时，需要一个辅助节点作为头部，而<code>res</code>则作为链表头部排序合并时的辅助头部<code>pre</code>；后面的合并排序可以将上次合并排序的尾部<code>tail</code>用做辅助节点。</li></ul></li><li>在每轮<code>intv</code>下的合并流程：<ol><li>根据<code>intv</code>找到合并单元1和单元2的头部<code>h1</code>, <code>h2</code>。由于链表长度可能不是<code>2^n</code>，需要考虑边界条件：<ul><li>在找<code>h2</code>过程中，如果链表剩余元素个数少于<code>intv</code>，则无需合并环节，直接<code>break</code>，执行下一轮合并；</li><li>若<code>h2</code>存在，但以<code>h2</code>为头部的剩余元素个数少于<code>intv</code>，也执行合并环节，<code>h2</code>单元的长度为<code>c2 = intv - i</code>。</li></ul></li><li>合并长度为<code>c1, c2</code>的<code>h1, h2</code>链表，其中：<ul><li>合并完后，需要修改新的合并单元的尾部<code>pre</code>指针指向下一个合并单元头部<code>h</code>。（在寻找<code>h1, h2</code>环节中，h指针已经被移动到下一个单元头部）</li><li>合并单元尾部同时也作为下次合并的辅助头部<code>pre</code>。</li></ul></li><li>当<code>h == None</code>，代表此轮<code>intv</code>合并完成，跳出。</li></ol></li><li>每轮合并完成后将单元长度×2，切换到下轮合并：<code>intv *= 2</code>。<details><summary>归并排序（从底至顶直接合并) python</summary></details></li></ul></li></ul><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        h, length, intv = head, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> h: h, length = h.next, length + <span class="number">1</span></span><br><span class="line">        res = ListNode(<span class="number">0</span>)</span><br><span class="line">        res.next = head</span><br><span class="line">        <span class="comment"># merge the list in different intv.</span></span><br><span class="line">        <span class="keyword">while</span> intv &lt; length:</span><br><span class="line">            pre, h = res, res.next</span><br><span class="line">            <span class="keyword">while</span> h:</span><br><span class="line">                <span class="comment"># get the two merge head `h1`, `h2`</span></span><br><span class="line">                h1, i = h, intv</span><br><span class="line">                <span class="keyword">while</span> i <span class="keyword">and</span> h: h, i = h.next, i - <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> i: <span class="keyword">break</span> <span class="comment"># no need to merge because the `h2` is None.</span></span><br><span class="line">                h2, i = h, intv</span><br><span class="line">                <span class="keyword">while</span> i <span class="keyword">and</span> h: h, i = h.next, i - <span class="number">1</span></span><br><span class="line">                c1, c2 = intv, intv - i <span class="comment"># the `c2`: length of `h2` can be small than the `intv`.</span></span><br><span class="line">                <span class="comment"># merge the `h1` and `h2`.</span></span><br><span class="line">                <span class="keyword">while</span> c1 <span class="keyword">and</span> c2:</span><br><span class="line">                    <span class="keyword">if</span> h1.val &lt; h2.val: pre.next, h1, c1 = h1, h1.next, c1 - <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>: pre.next, h2, c2 = h2, h2.next, c2 - <span class="number">1</span></span><br><span class="line">                    pre = pre.next</span><br><span class="line">                pre.next = h1 <span class="keyword">if</span> c1 <span class="keyword">else</span> h2</span><br><span class="line">                <span class="keyword">while</span> c1 &gt; <span class="number">0</span> <span class="keyword">or</span> c2 &gt; <span class="number">0</span>: pre, c1, c2 = pre.next, c1 - <span class="number">1</span>, c2 - <span class="number">1</span></span><br><span class="line">                pre.next = h </span><br><span class="line">            intv *= <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> res.next</span><br></pre></td></tr></table></figure><details>    <summary>归并排序（从底至顶直接合并）java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        模拟上述的多轮排序合并：</span></span><br><span class="line"><span class="comment">//        统计链表长度length，用于通过判断intv &lt; length判定是否完成排序；</span></span><br><span class="line">        ListNode h,h1,h2,pre,res;</span><br><span class="line">        h=head;</span><br><span class="line">        <span class="keyword">int</span> length=<span class="number">0</span>,intv=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (h != <span class="keyword">null</span>) &#123;</span><br><span class="line">            h=h.next;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        额外声明一个节点res，作为头部后面接整个链表，用于：</span></span><br><span class="line">        res = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        res.next=head;</span><br><span class="line"><span class="comment">//        intv *= 2即切换到下一轮合并时，可通过res.next找到链表头部h；</span></span><br><span class="line"><span class="comment">//        执行排序合并时，需要一个辅助节点作为头部，而res则作为链表头部排序合并时的辅助头部pre；后面的合并排序可以将上次合并排序的尾部tail用做辅助节点。</span></span><br><span class="line">        <span class="keyword">while</span> (intv &lt; length) &#123;</span><br><span class="line">            pre = res;</span><br><span class="line">            h = res.next;</span><br><span class="line"><span class="comment">//        在每轮intv下的合并流程：</span></span><br><span class="line"><span class="comment">//        a. 根据intv找到合并单元1和单元2的头部h1, h2。由于链表长度可能不是2^n，需要考虑边界条件：</span></span><br><span class="line">            <span class="keyword">while</span> (h != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> i = intv;</span><br><span class="line">                h1 = h;</span><br><span class="line">                <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; h != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    h = h.next;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//              在找h2过程中，如果链表剩余元素个数少于intv，则无需合并环节，直接break，执行下一轮合并；</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                i = intv;</span><br><span class="line">                h2 = h;</span><br><span class="line">                <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; h != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    h = h.next;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//        若h2存在，但以h2为头部的剩余元素个数少于intv，也执行合并环节，h2单元的长度为c2 = intv - i。</span></span><br><span class="line">                <span class="keyword">int</span> c1 = intv, c2 = intv - i;</span><br><span class="line"><span class="comment">//        b. 合并长度为c1, c2的h1, h2链表，其中：</span></span><br><span class="line">                <span class="keyword">while</span> (c1 &gt; <span class="number">0</span> &amp;&amp; c2 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (h1.val &lt; h2.val) &#123;</span><br><span class="line">                        pre.next = h1;</span><br><span class="line">                        h1 = h1.next;</span><br><span class="line">                        c1--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        pre.next = h2;</span><br><span class="line">                        h2 = h2.next;</span><br><span class="line">                        c2--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    pre = pre.next;</span><br><span class="line">                &#125;</span><br><span class="line">                pre.next = c1 == <span class="number">0</span> ? h2 : h1;</span><br><span class="line">                <span class="keyword">while</span> (c1 &gt; <span class="number">0</span> || c2 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    pre = pre.next;</span><br><span class="line">                    c1--;</span><br><span class="line">                    c2--;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//        合并完后，需要修改新的合并单元的尾部pre指针指向下一个合并单元头部h。（在寻找h1, h2环节中，h指针已经被移动到下一个单元头部）</span></span><br><span class="line"><span class="comment">//        合并单元尾部同时也作为下次合并的辅助头部pre。</span></span><br><span class="line">                pre.next = h;</span><br><span class="line"><span class="comment">//        c. 当h == None，代表此轮intv合并完成，跳出。</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//        每轮合并完成后将单元长度×2，切换到下轮合并：intv *= 2。</span></span><br><span class="line">            intv *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在O(nlogn) 时间复杂度和常数级空间复杂度下，对链表进行排序。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年7月" scheme="http://yoursite.com/categories/2020%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
      <category term="Sort" scheme="http://yoursite.com/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>141. 环形链表</title>
    <link href="http://yoursite.com/2020/07/24/141.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/07/24/141. 环形链表/</id>
    <published>2020-07-24T07:22:12.000Z</published>
    <updated>2020-07-25T10:07:47.894Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个链表，判断链表中是否有环。</p><a id="more"></a><p>这道题十分经典，快慢指针这种解法应该是耳熟能详，记得面试头条时三面时被问到有没有比快慢指针更好的办法或改进方法，当时想了半天没想到递归的方法，现在补充到题解中。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p>示例 1：</p><pre><code>输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。</code></pre><p>示例 2：</p><pre><code>输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。</code></pre><p>示例 3：</p><pre><code>输入：head = [1], pos = -1输出：false解释：链表中没有环。</code></pre><p>进阶：</p><pre><code>你能用 O(1)（即，常量）内存解决此问题吗？</code></pre><hr><h1 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h1><p><strong>思路</strong></p><p>我们可以通过检查一个结点此前是否被访问过来判断链表是否为环形链表。常用的方法是使用哈希表。</p><p><strong>算法</strong></p><p>我们遍历所有结点并在哈希表中存储每个结点的引用（或内存地址）。如果当前结点为空结点 <code>null</code>（即已检测到链表尾部的下一个结点），那么我们已经遍历完整个链表，并且该链表不是环形链表。如果当前结点的引用已经存在于哈希表中，那么返回 <code>true</code>（即该链表为环形链表）。</p><details>    <summary>哈希表Java</summary><figure class="highlight java"><figcaption><span>[SiMGFWod-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    Set&lt;ListNode&gt; nodesSeen = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodesSeen.contains(head)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nodesSeen.add(head);</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)*，对于含有 *n</em> 个元素的链表，我们访问每个元素最多一次。添加一个结点到哈希表中只需要花费 <em>O(1)</em> 的时间。</p></li><li><p>空间复杂度：<em>O(n)*，空间取决于添加到哈希表中的元素数目，最多可以添加 *n</em> 个元素。</p></li></ul><hr><h1 id="方法二：双指针"><a href="#方法二：双指针" class="headerlink" title="方法二：双指针"></a>方法二：双指针</h1><p><strong>思路</strong></p><p>想象一下，两名运动员以不同的速度在环形赛道上跑步会发生什么？</p><p><strong>算法</strong></p><p>通过使用具有 <strong>不同速度</strong> 的快、慢两个指针遍历链表，空间复杂度可以被降低至 <em>O(1)</em>。慢指针每次移动一步，而快指针每次移动两步。</p><p>如果列表中不存在环，最终快指针将会最先到达尾部，此时我们可以返回 <code>false</code>。</p><p>现在考虑一个环形链表，把慢指针和快指针想象成两个在环形赛道上跑步的运动员（分别称之为慢跑者与快跑者）。而快跑者最终一定会追上慢跑者。这是为什么呢？考虑下面这种情况（记作情况 A）- 假如快跑者只落后慢跑者一步，在下一次迭代中，它们就会分别跑了一步或两步并相遇。</p><p>其他情况又会怎样呢？例如，我们没有考虑快跑者在慢跑者之后两步或三步的情况。但其实不难想到，因为在下一次或者下下次迭代后，又会变成上面提到的情况 A。</p><details>    <summary>双指针Java</summary><figure class="highlight java"><figcaption><span>[qdD5r8PV-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head.next;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)*，让我们将 *n</em> 设为链表中结点的总数。为了分析时间复杂度，我们分别考虑下面两种情况。</p><ul><li><p><strong><em>链表中不存在环：</em></strong><br>快指针将会首先到达尾部，其时间取决于列表的长度，也就是 <em>O(n)</em>。</p></li><li><p><strong><em>链表中存在环：</em></strong><br>我们将慢指针的移动过程划分为两个阶段：非环部分与环形部分：</p><ol><li><p>慢指针在走完非环部分阶段后将进入环形部分：此时，快指针已经进入环中 <code>迭代次数=非环部分长度=N</code></p></li><li><p>两个指针都在环形区域中：考虑两个在环形赛道上的运动员 - 快跑者每次移动两步而慢跑者每次只移动一步。其速度的差值为 1，因此需要经过二者之间距离/速度差值 次循环后，快跑者可以追上慢跑者。这个距离几乎就是 “环形部分长度 K”” 且速度差值为 1，我们得出这样的结论迭代次数=近似于环形部分长度K。</p></li></ol><p>因此，在最糟糕的情形下，时间复杂度为 <em>O(N+K)</em>，也就是 <em>O(n)</em>。</p></li></ul></li><li><p>空间复杂度：<em>O(1)</em>，我们只使用了慢指针和快指针两个结点，所以空间复杂度为 <em>O(1)</em>。</p></li></ul><p>这道题相当的经典，重温时一开始被pos迷惑住了，还以为条件变了，要自己写到链表结尾的跳转代码，后来看入参才发现不需要自己处理。</p><h1 id="方法三：JS特殊解法"><a href="#方法三：JS特殊解法" class="headerlink" title="方法三：JS特殊解法"></a>方法三：JS特殊解法</h1><p>相信对于 JS 中的 JSON.stringify() 方法大家都用过，主要用于将 JS 对象 转换为 JSON 字符串。基本使用如下：</p><details>    <summary>基本使用</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var car = &#123; </span><br><span class="line">  name: &apos;小喵&apos;, </span><br><span class="line">  age: 20, </span><br><span class="line">&#125; </span><br><span class="line">var str = JSON.stringify(car);</span><br><span class="line">console.log(str) </span><br><span class="line">//=&gt; &#123;&quot;name&quot;:&quot;小喵&quot;,&quot;age&quot;:20&#125;</span><br></pre></td></tr></table></figure></details>大家想一下，如果是自己实现这样的一个函数，我们需要处理什么样的特殊情况？对，就是循环引用。因为对于循环引用，我们很难通过 JSON 的结构将其进行展示！比如下面：<details>    <summary>例子</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;&#125; </span><br><span class="line">var b = &#123; </span><br><span class="line">  a: a </span><br><span class="line">&#125;</span><br><span class="line">a.b = b</span><br><span class="line">console.log(JSON.stringify(a))</span><br><span class="line">//=&gt; TypeError: Converting circular structure to JSON</span><br></pre></td></tr></table></figure></details>那我们思考，对于环形链表，是不是就是一个循环结构呢？当然是！因为只要是环形链表，它一定存在类似以下代码：<details>    <summary>例子</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.Next = b</span><br><span class="line">b.Next = a</span><br></pre></td></tr></table></figure></details><p>所以我们可以通过 JSON.stringify() 的特性进行求解：</p><details>    <summary>JS特殊解法</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var hasCycle = function(head) &#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        JSON.stringify(head)</span><br><span class="line">    &#125;catch(e)&#123;</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">    return false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details>当然，这种解法并不是建议的标准题解！在此列出是为了拓宽思维！（如有兴趣，可以自己去看下JSON.stringify 内部的实现，是如何检测循环引用的。）<h1 id="方法四：递归：破坏链表结构"><a href="#方法四：递归：破坏链表结构" class="headerlink" title="方法四：递归：破坏链表结构"></a>方法四：递归：破坏链表结构</h1><details>    <summary>递归：破坏链表结构</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean hasCycle(ListNode head) &#123;</span><br><span class="line">        if (head == null || head.next == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断是否是自环状态</span><br><span class="line">        if (head == head.next) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        //让遍历过的节点自环</span><br><span class="line">        ListNode breaker=head.next;</span><br><span class="line">        head.next=head;</span><br><span class="line">        return hasCycle(breaker);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>这种方法可以只使用一个指针来解决，每次遍历一个节点后都把它变成自环结构，这样如果遍历到开始成环的节点时该节点的指向的环路上的节点必然是已经自环的节点，递归到这个自环节点时返回true。</p><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)</em></p></li><li><p>空间复杂度：<em>O(1)</em></p></li></ul><h1 id="方法五：递归：标记法"><a href="#方法五：递归：标记法" class="headerlink" title="方法五：递归：标记法"></a>方法五：递归：标记法</h1><details>    <summary>递归：标记法</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean hasCycle(ListNode head) &#123;</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (head.val == 0xcafebabe) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        head.val=0xcafebabe;</span><br><span class="line">        return hasCycle(head.next);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>这种递归方法是遍历到一个节点就把它的值标记为魔数0xcafebabe（用个别的十六进制数标记也行），一直递归到遇到标记过的节点或者是空指针。</p><p>魔数0xcafebabe：Java中class文件的前四个字节是 CAFEBABE，它表示这个文件的类型是Class文件(类似于文件名后缀，不过魔数是给编译器看的，后缀是给执行程序看的)</p><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)</em></p></li><li><p>空间复杂度：<em>O(1)</em></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个链表，判断链表中是否有环。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年7月" scheme="http://yoursite.com/categories/2020%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>138. 复制带随机指针的链表</title>
    <link href="http://yoursite.com/2020/07/23/138.%20%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/07/23/138. 复制带随机指针的链表/</id>
    <published>2020-07-23T08:22:12.000Z</published>
    <updated>2020-07-24T03:06:27.074Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。</p><p>要求返回这个链表的 深拷贝。很经典的一道题，也是剑指Offer 上的面试题26. 复杂链表的复制。</p><a id="more"></a><p>我们用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：</p><ul><li>val：一个表示 Node.val 的整数。</li><li>random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。</li></ul><p>示例 1：</p><pre><code>输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</code></pre><p>示例 2：</p><pre><code>输入：head = [[1,1],[2,1]]输出：[[1,1],[2,1]]</code></pre><p>示例 3：</p><pre><code>输入：head = [[3,null],[3,0],[3,null]]输出：[[3,null],[3,0],[3,null]]</code></pre><p>示例 4：</p><pre><code>输入：head = []输出：[]解释：给定的链表为空（空指针），因此返回 null。</code></pre><p>提示：</p><pre><code>-10000 &lt;= Node.val &lt;= 10000Node.random 为空（null）或指向链表中的节点。节点数目不超过 1000 。</code></pre><p>首先，我们来看一下有向链表<a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/solution/fu-zhi-dai-sui-ji-zhi-zhen-de-lian-biao-by-leetcod/" target="_blank" rel="noopener">^1</a>：</p><p> <a href="https://pic.leetcode-cn.com/6a547c42c3a2d05e054223a2a512844ed2bc7f424433e0d99ae20a4a191c582d-image.png" target="_blank" rel="noopener">image.png</a></p><p>在上图中，对于一个节点，它的 <code>next</code> 指针指向链表中的下一个节点。 <code>next</code> 指针是通常有向链表中有的部分且将所有节点 <strong><em>链接</em></strong> 起来。图中有趣的一点，也是这题有趣的一点在于 <code>random</code> 指针，正如名字所示，它可以指向链表中的任一节点也可以为空。</p><h1 id="方法-1：回溯"><a href="#方法-1：回溯" class="headerlink" title="方法 1：回溯"></a>方法 1：回溯</h1><p><strong>想法</strong></p><p>回溯算法的第一想法是将链表想象成一张图。链表中每个节点都有 2 个指针（图中的边）。因为随机指针给图结构添加了随机性，所以我们可能会访问相同的节点多次，这样就形成了环。</p><p> <a href="https://pic.leetcode-cn.com/990d6483f673537e98e6162cc9e1c6c4ca32729d0d54b82bb5e46cbdaf2246b8-image.png" target="_blank" rel="noopener">image.png</a></p><p>上图中，我们可以看到随机指针指向了前一个节点，因此成环。我们需要考虑这种环的实现。</p><p>此方法中，我们只需要遍历整个图并拷贝它。拷贝的意思是每当遇到一个新的未访问过的节点，你都需要创造一个新的节点。遍历按照深度优先进行。我们需要在回溯的过程中记录已经访问过的节点，否则因为随机指针的存在我们可能会产生死循环。</p><p><strong>算法</strong></p><ol><li><p>从 <code>头</code> 指针开始遍历整个图。</p><p> 我们将链表看做一张图。下图对应的是上面的有向链表的例子，<code>Head</code> 是图的出发节点。</p><p><a href="https://pic.leetcode-cn.com/bd3fb0c9f6d3fdcc3bbc4afdb47183d6aaef93552df135130ea42da77aab911d-image.png" target="_blank" rel="noopener">image.png</a></p></li></ol><ol start="2"><li>当我们遍历到某个点时，如果我们已经有了当前节点的一个拷贝，我们不需要重复进行拷贝。</li><li>如果我们还没拷贝过当前节点，我们创造一个新的节点，并把该节点放到已访问字典中，即：<br><code>visited_dictionary[current_node] = cloned_node_for_current_node.</code></li><li>我们针对两种情况进行回溯调用：一个顺着 <code>random</code> 指针调用，另一个沿着 <code>next</code> 指针调用。步骤 1 中将 <code>random</code> 和 <code>next</code> 指针分别红红色和蓝色标注。然后我们分别对两个指针进行函数递归调用：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cloned_node_for_current_node.next = copyRandomList(current_node.next);</span><br><span class="line">cloned_node_for_current_node.random = copyRandomList(current_node.random);</span><br></pre></td></tr></table></figure><details>    <summary>回溯Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment">    public Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val,Node _next,Node _random) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">        random = _random;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="comment">// HashMap which holds old nodes as keys and new nodes as its values.</span></span><br><span class="line">  HashMap&lt;Node, Node&gt; visitedHash = <span class="keyword">new</span> HashMap&lt;Node, Node&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we have already processed the current node, then we simply return the cloned version of</span></span><br><span class="line">    <span class="comment">// it.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.visitedHash.containsKey(head)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.visitedHash.get(head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a new node with the value same as old node. (i.e. copy the node)</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(head.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save this value in the hash map. This is needed since there might be</span></span><br><span class="line">    <span class="comment">// loops during traversal due to randomness of random pointers and this would help us avoid</span></span><br><span class="line">    <span class="comment">// them.</span></span><br><span class="line">    <span class="keyword">this</span>.visitedHash.put(head, node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recursively copy the remaining linked list starting once from the next pointer and then from</span></span><br><span class="line">    <span class="comment">// the random pointer.</span></span><br><span class="line">    <span class="comment">// Thus we have two independent recursive calls.</span></span><br><span class="line">    <span class="comment">// Finally we update the next and random pointers for the new node created.</span></span><br><span class="line">    node.next = <span class="keyword">this</span>.copyRandomList(head.next);</span><br><span class="line">    node.random = <span class="keyword">this</span>.copyRandomList(head.random);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>回溯Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type head: Node</span></span><br><span class="line"><span class="string">    :rtype: Node</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Dictionary which holds old nodes as keys and new nodes as its values.</span></span><br><span class="line">        self.visitedHash = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span><span class="params">(self, head)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> head == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># If we have already processed the current node, then we simply return the cloned version of it.</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">in</span> self.visitedHash:</span><br><span class="line">            <span class="keyword">return</span> self.visitedHash[head]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># create a new node</span></span><br><span class="line">        <span class="comment"># with the value same as old node.</span></span><br><span class="line">        node = Node(head.val, <span class="keyword">None</span>, <span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Save this value in the hash map. This is needed since there might be</span></span><br><span class="line">        <span class="comment"># loops during traversal due to randomness of random pointers and this would help us avoid them.</span></span><br><span class="line">        self.visitedHash[head] = node</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Recursively copy the remaining linked list starting once from the next pointer and then from the random pointer.</span></span><br><span class="line">        <span class="comment"># Thus we have two independent recursive calls.</span></span><br><span class="line">        <span class="comment"># Finally we update the next and random pointers for the new node created.</span></span><br><span class="line">        node.next = self.copyRandomList(head.next)</span><br><span class="line">        node.random = self.copyRandomList(head.random)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(N)</em> ，其中 <em>N</em> 是链表中节点的数目。</li><li>空间复杂度：<em>O(N)</em> 。如果我们仔细分析，我们需要维护一个回溯的栈，同时也需要记录已经被深拷贝过的节点，也就是维护一个已访问字典。渐进时间复杂度为 <em>O(N)</em> 。</li></ul><br><h1 id="方法-2：-O-N-空间的迭代"><a href="#方法-2：-O-N-空间的迭代" class="headerlink" title="方法 2： O(N) 空间的迭代"></a>方法 2： <em>O(N)</em> 空间的迭代</h1><p><strong>想法</strong></p><p>迭代算法不需要将链表视为一个图。当我们在迭代链表时，我们只需要为 <code>random</code> 指针和 <code>next</code> 指针指向的未访问过节点创造新的节点并赋值即可。</p><p><strong>算法</strong></p><ol><li><p>从 <code>head</code> 节点开始遍历链表。下图中，我们首先创造新的 <code>head</code> 拷贝节点。拷贝的节点如下图虚线所示。实现中，我们将该新建节点的引用也放入已访问字典中。</p><p><a href="https://pic.leetcode-cn.com/ba345f073f3edebb79e2500ffea5fd744bf2266bb1426e5b4221f2f21ecea900-image.png" target="_blank" rel="noopener">image.png</a></p></li></ol><ol start="2"><li><p><code>random</code> 指针</p><ul><li><p>如果当前节点 <em>i</em> 的 <code>random</code> 指针指向一个节点 <em>j</em> 且节点 <em>j</em> 已经被拷贝过，我们将直接使用已访问字典中该节点的引用而不会新建节点。</p></li><li><p>如果当前节点 <em>i</em> 的 <code>random</code> 指针指向的节点 <em>j</em> 还没有被拷贝过，我们就对 <em>j</em> 节点创建对应的新节点，并把它放入已访问节点字典中。</p><p>下图中， <em>A</em> 的 <code>random</code> 指针指向的节点 <em>C</em> 。前图中可以看出，节点 <em>C</em> 还没有被访问过，所以我们创造一个拷贝的 <em>C’</em> 节点与之对应，并将它添加到已访问字典中。</p></li></ul></li></ol><p> <a href="https://pic.leetcode-cn.com/ac190cfe6d9de91a765c103c2a79a89f25b404fa355f1b3cb41f30e47467a676-image.png" target="_blank" rel="noopener">image.png</a></p><ol start="3"><li><code>next</code> 指针<ul><li>如果当前节点 <em>i</em> 的 <code>next</code> 指针指向的节点 <em>j</em> 在已访问字典中已有拷贝，我们直接使用它的拷贝节点。</li><li>如果当前节点 <em>i</em> 的<code>next</code> 指针指向的节点 <em>j</em> 还没有被访问过，我们创建一个对应节点的拷贝，并放入已访问字典。</li></ul></li></ol><p>下图中，<em>A</em> 节点的 <code>next</code> 指针指向节点 <em>B</em> 。节点 <em>B</em> 在前面的图中还没有被访问过，因此我们创造一个新的拷贝 <em>B’</em> 节点，并放入已访问字典中。</p><p> <a href="https://pic.leetcode-cn.com/02c55bd01ea1f85231e34ea714de8db3ccb8717f434a80f94c0efdac62b15246-image.png" target="_blank" rel="noopener">image.png</a></p><ol start="4"><li>我们重复步骤 2 和步骤 3 ，直到我们到达链表的结尾。</li></ol><p>下图中， 节点 <em>B</em> 的 <code>random</code> 指针指向的节点 <em>A</em> 已经被访问过了，因此在步骤 2 中，我们不会创建新的拷贝，</p><p>将节点 <em>B’</em> 的 <code>random</code> 指针指向克隆节点 <em>A’</em> 。</p><p>同样的， 节点 <em>B</em> 的 <code>next</code> 指针指向的节点 <em>C</em> 已经访问过，因此在步骤 3 中，我们不会创建新的拷贝，而直接将 <em>B’</em> 的 <code>next</code> 指针指向已经存在的拷贝节点 <em>C’</em> 。</p><p> <a href="https://pic.leetcode-cn.com/203559119fb45aa1bb844a5441ce18089f4005fa386bd794048c51fd25686e87-image.png" target="_blank" rel="noopener">image.png</a></p><details>    <summary>迭代算法Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment">    public Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val,Node _next,Node _random) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">        random = _random;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Visited dictionary to hold old node reference as "key" and new node reference as the "value"</span></span><br><span class="line">  HashMap&lt;Node, Node&gt; visited = <span class="keyword">new</span> HashMap&lt;Node, Node&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Node <span class="title">getClonedNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If the node exists then</span></span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Check if the node is in the visited dictionary</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.visited.containsKey(node)) &#123;</span><br><span class="line">        <span class="comment">// If its in the visited dictionary then return the new node reference from the dictionary</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.visited.get(node);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Otherwise create a new node, add to the dictionary and return it</span></span><br><span class="line">        <span class="keyword">this</span>.visited.put(node, <span class="keyword">new</span> Node(node.val, <span class="keyword">null</span>, <span class="keyword">null</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.visited.get(node);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node oldNode = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Creating the new head node.</span></span><br><span class="line">    Node newNode = <span class="keyword">new</span> Node(oldNode.val);</span><br><span class="line">    <span class="keyword">this</span>.visited.put(oldNode, newNode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate on the linked list until all nodes are cloned.</span></span><br><span class="line">    <span class="keyword">while</span> (oldNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Get the clones of the nodes referenced by random and next pointers.</span></span><br><span class="line">      newNode.random = <span class="keyword">this</span>.getClonedNode(oldNode.random);</span><br><span class="line">      newNode.next = <span class="keyword">this</span>.getClonedNode(oldNode.next);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Move one step ahead in the linked list.</span></span><br><span class="line">      oldNode = oldNode.next;</span><br><span class="line">      newNode = newNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.visited.get(head);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>迭代算法Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Creating a visited dictionary to hold old node reference as "key" and new node reference as the "value"</span></span><br><span class="line">        self.visited = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getClonedNode</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="comment"># If node exists then</span></span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            <span class="comment"># Check if its in the visited dictionary          </span></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">in</span> self.visited:</span><br><span class="line">                <span class="comment"># If its in the visited dictionary then return the new node reference from the dictionary</span></span><br><span class="line">                <span class="keyword">return</span> self.visited[node]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># Otherwise create a new node, save the reference in the visited dictionary and return it.</span></span><br><span class="line">                self.visited[node] = Node(node.val, <span class="keyword">None</span>, <span class="keyword">None</span>)</span><br><span class="line">                <span class="keyword">return</span> self.visited[node]</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: Node</span></span><br><span class="line"><span class="string">        :rtype: Node</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        old_node = head</span><br><span class="line">        <span class="comment"># Creating the new head node.       </span></span><br><span class="line">        new_node = Node(old_node.val, <span class="keyword">None</span>, <span class="keyword">None</span>)</span><br><span class="line">        self.visited[old_node] = new_node</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Iterate on the linked list until all nodes are cloned.</span></span><br><span class="line">        <span class="keyword">while</span> old_node != <span class="keyword">None</span>:</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Get the clones of the nodes referenced by random and next pointers.</span></span><br><span class="line">            new_node.random = self.getClonedNode(old_node.random)</span><br><span class="line">            new_node.next = self.getClonedNode(old_node.next)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Move one step ahead in the linked list.</span></span><br><span class="line">            old_node = old_node.next</span><br><span class="line">            new_node = new_node.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.visited[head]</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(N)</em> 。因为我们需要将原链表逐一遍历。</li><li>空间复杂度：<em>O(N)</em> 。 我们需要维护一个字典，保存旧的节点和新的节点的对应。因此总共需要 <em>N</em> 个节点，需要 <em>O(N)</em> 的空间复杂度。</li></ul><br><h1 id="方法-3：O-1-空间的迭代"><a href="#方法-3：O-1-空间的迭代" class="headerlink" title="方法 3：O(1) 空间的迭代"></a>方法 3：<em>O(1)</em> 空间的迭代</h1><p><strong>想法</strong></p><p>与上面提到的维护一个旧节点和新节点对应的字典不同，我们通过扭曲原来的链表，并将每个拷贝节点都放在原来对应节点的旁边。这种旧节点和新节点交错的方法让我们可以在不需要额外空间的情况下解决这个问题。让我们看看这个算法如何工作</p><p><strong>算法</strong></p><ol><li>遍历原来的链表并拷贝每一个节点，将拷贝节点放在原来节点的旁边，创造出一个旧节点和新节点交错的链表。</li></ol><p> <a href="https://pic.leetcode-cn.com/c4e075d7eb23b27074430abda66ff5a74307f85958b063ebb530873b66c117b8-image.png" target="_blank" rel="noopener">image.png</a><br> <a href="https://pic.leetcode-cn.com/62ba6efc1d3a77ba04956a105eeaa5738ef1771d9e2fc9f4daf80a0cf1275d70-image.png" target="_blank" rel="noopener">image.png</a></p><p> 如你所见，我们只是用了原来节点的值拷贝出新的节点。原节点 <code>next</code> 指向的都是新创造出来的节点。</p><p><code>cloned_node.next = original_node.next</code></p><p><code>original_node.next = cloned_node</code></p><ol start="2"><li><p>迭代这个新旧节点交错的链表，并用旧节点的 <code>random</code> 指针去更新对应新节点的 <code>random</code> 指针。比方说， <code>B</code> 的 <code>random</code> 指针指向 <code>A</code> ，意味着 <code>B&#39;</code> 的 <code>random</code> 指针指向 <code>A&#39;</code> 。</p><p><a href="https://pic.leetcode-cn.com/1789e6dd9bbe41223cab82b2e0a7615cd1a8ed16a3c992462d4e1eaec3b82fb1-image.png" target="_blank" rel="noopener">image.png</a></p></li><li><p>现在 <code>random</code> 指针已经被赋值给正确的节点， <code>next</code> 指针也需要被正确赋值，以便将新的节点正确链接同时将旧节点重新正确链接。</p></li></ol><p> <a href="https://pic.leetcode-cn.com/a28323ef84883ec02e7d99fd13b444dede9355389c7567e43e7ee1c85262a2d3-image.png" target="_blank" rel="noopener">image.png</a></p><p>说实话前两个方法我都没能太理解，但这种方法清晰易懂，而且空间复杂度较低，推荐。C++版本的是2018.1.9时提交的，回过头来刚看时还是迷糊，太久没有复习这部分内容了，好像狗熊掰棒子哈哈。</p><details>    <summary>O(1)空间的迭代Java</summary><figure class="highlight"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment">    public Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val,Node _next,Node _random) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">        random = _random;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Creating a new weaved list of original and copied nodes.</span></span><br><span class="line">    Node ptr = head;</span><br><span class="line">    <span class="keyword">while</span> (ptr != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Cloned node</span></span><br><span class="line">      Node newNode = <span class="keyword">new</span> Node(ptr.val);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Inserting the cloned node just next to the original node.</span></span><br><span class="line">      <span class="comment">// If A-&gt;B-&gt;C is the original linked list,</span></span><br><span class="line">      <span class="comment">// Linked list after weaving cloned nodes would be A-&gt;A'-&gt;B-&gt;B'-&gt;C-&gt;C'</span></span><br><span class="line">      newNode.next = ptr.next;</span><br><span class="line">      ptr.next = newNode;</span><br><span class="line">      ptr = newNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ptr = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now link the random pointers of the new nodes created.</span></span><br><span class="line">    <span class="comment">// Iterate the newly created list and use the original nodes' random pointers,</span></span><br><span class="line">    <span class="comment">// to assign references to random pointers for cloned nodes.</span></span><br><span class="line">    <span class="keyword">while</span> (ptr != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ptr.next.random = (ptr.random != <span class="keyword">null</span>) ? ptr.random.next : <span class="keyword">null</span>;</span><br><span class="line">      ptr = ptr.next.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unweave the linked list to get back the original linked list and the cloned list.</span></span><br><span class="line">    <span class="comment">// i.e. A-&gt;A'-&gt;B-&gt;B'-&gt;C-&gt;C' would be broken to A-&gt;B-&gt;C and A'-&gt;B'-&gt;C'</span></span><br><span class="line">    Node ptr_old_list = head; <span class="comment">// A-&gt;B-&gt;C</span></span><br><span class="line">    Node ptr_new_list = head.next; <span class="comment">// A'-&gt;B'-&gt;C'</span></span><br><span class="line">    Node head_old = head.next;</span><br><span class="line">    <span class="keyword">while</span> (ptr_old_list != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ptr_old_list.next = ptr_old_list.next.next;</span><br><span class="line">      ptr_new_list.next = (ptr_new_list.next != <span class="keyword">null</span>) ? ptr_new_list.next.next : <span class="keyword">null</span>;</span><br><span class="line">      ptr_old_list = ptr_old_list.next;</span><br><span class="line">      ptr_new_list = ptr_new_list.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head_old;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">```    </span><br><span class="line">&lt;/details&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;details&gt;</span><br><span class="line">    &lt;summary&gt;O(1)空间的迭代Python&lt;/summary&gt;</span><br><span class="line"></span><br><span class="line">```Python []</span><br><span class="line">class Solution(object):</span><br><span class="line">    <span class="function">def <span class="title">copyRandomList</span><span class="params">(self, head)</span>:</span></span><br><span class="line"><span class="function">        """</span></span><br><span class="line"><span class="function">        :type head: Node</span></span><br><span class="line"><span class="function">        :rtype: Node</span></span><br><span class="line"><span class="function">        """</span></span><br><span class="line"><span class="function">        <span class="keyword">if</span> not head:</span></span><br><span class="line"><span class="function">            return head</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        # Creating a new weaved list of original and copied nodes.</span></span><br><span class="line"><span class="function">        ptr </span>= head</span><br><span class="line">        <span class="keyword">while</span> ptr:</span><br><span class="line"></span><br><span class="line">            # Cloned node</span><br><span class="line">            new_node = Node(ptr.val, None, None)</span><br><span class="line"></span><br><span class="line">            # Inserting the cloned node just next to the original node.</span><br><span class="line">            # If A-&gt;B-&gt;C is the original linked list,</span><br><span class="line">            # Linked list after weaving cloned nodes would be A-&gt;A'-&gt;B-&gt;B'-&gt;C-&gt;C'</span><br><span class="line">            new_node.next = ptr.next</span><br><span class="line">            ptr.next = new_node</span><br><span class="line">            ptr = new_node.next</span><br><span class="line"></span><br><span class="line">        ptr = head</span><br><span class="line"></span><br><span class="line">        # Now link the random pointers of the new nodes created.</span><br><span class="line">        # Iterate the newly created list and use the original nodes random pointers,</span><br><span class="line">        # to assign references to random pointers for cloned nodes.</span><br><span class="line">        <span class="keyword">while</span> ptr:</span><br><span class="line">            ptr.next.random = ptr.random.next <span class="keyword">if</span> ptr.random <span class="keyword">else</span> None</span><br><span class="line">            ptr = ptr.next.next</span><br><span class="line"></span><br><span class="line">        # Unweave the linked list to get back the original linked list and the cloned list.</span><br><span class="line">        # i.e. A-&gt;A'-&gt;B-&gt;B'-&gt;C-&gt;C' would be broken to A-&gt;B-&gt;C and A'-&gt;B'-&gt;C'</span><br><span class="line">        ptr_old_list = head # A-&gt;B-&gt;C</span><br><span class="line">        ptr_new_list = head.next # A'-&gt;B'-&gt;C'</span><br><span class="line">        head_old = head.next</span><br><span class="line">        <span class="keyword">while</span> ptr_old_list:</span><br><span class="line">            ptr_old_list.next = ptr_old_list.next.next</span><br><span class="line">            ptr_new_list.next = ptr_new_list.next.next <span class="keyword">if</span> ptr_new_list.next <span class="keyword">else</span> None</span><br><span class="line">            ptr_old_list = ptr_old_list.next</span><br><span class="line">            ptr_new_list = ptr_new_list.next</span><br><span class="line">        <span class="keyword">return</span> head_old</span><br><span class="line">```    </span><br><span class="line">&lt;/details&gt;</span><br><span class="line">&lt;details&gt;</span><br><span class="line">    &lt;summary&gt;O(1)空间的迭代C++&lt;/summary&gt;</span><br></pre></td></tr></table></figure><p>/**</p><ul><li><p>Definition for singly-linked list with a random pointer.</p></li><li><p>struct RandomListNode {</p></li><li><p>int label;</p></li><li><p>RandomListNode *next, *random;</p></li><li><p>RandomListNode(int x) : label(x), next(NULL), random(NULL) {}</p></li><li><p>};</p><p> 剑指Offer 面试题２６　复杂链表的复制</p></li><li><p>/<br>class Solution {<br>public:<br>  RandomListNode *copyRandomList(RandomListNode *head) {</p><pre><code>CloneNodes(head);ConnectRandomNodes(head);return ReconnectNodes(head);</code></pre><p>  }</p></li></ul><pre><code>void CloneNodes(RandomListNode* pHead){    RandomListNode *pNode=pHead;    while(pNode!=NULL){        RandomListNode *pCloned;//= new RandomListNode();        /* copy the node and create the new node */        pCloned=new RandomListNode(pNode-&gt;label);       // pCloned-&gt;label=pNode-&gt;label;        pCloned-&gt;next=pNode-&gt;next;        pCloned-&gt;random=NULL;        pNode-&gt;next=pCloned;// connect the new clone node to the old node        pNode=pCloned-&gt;next;// push forward = i++    }}void ConnectRandomNodes(RandomListNode *pHead){    RandomListNode *pNode=pHead;    while(pNode!= NULL){        RandomListNode *pCloned=pNode-&gt;next;        if(pNode-&gt;random!=NULL){            pCloned-&gt;random = pNode-&gt;random-&gt;next;// pNode-&gt;random-&gt;next point to the next Clone Node which can see the graph of the P149        }        pNode= pCloned-&gt;next;// push forward to the next Node    }}RandomListNode * ReconnectNodes(RandomListNode *pHead){    RandomListNode *pNode=pHead;    RandomListNode *pClonedHead=NULL;    RandomListNode *pClonedNode = NULL;    if(pNode!=NULL){        pClonedHead= pClonedNode= pNode-&gt; next;        pNode-&gt;next=pClonedNode-&gt;next;        pNode = pNode-&gt;next;    }    while(pNode!= NULL){        pClonedNode-&gt;next= pNode-&gt;next;        pClonedNode=pClonedNode-&gt;next;        pNode-&gt;next=pClonedNode-&gt;next;        pNode=pNode-&gt;next;    }    return pClonedHead;}</code></pre><p>};<br>//runtime:50 ms<br>//memory:N/A</p><p>```</p></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(N)</em></li><li>空间复杂度：<em>O(1)</em>    </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。&lt;/p&gt;
&lt;p&gt;要求返回这个链表的 深拷贝。很经典的一道题，也是剑指Offer 上的面试题26. 复杂链表的复制。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年7月" scheme="http://yoursite.com/categories/2020%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>150. 逆波兰表达式求值</title>
    <link href="http://yoursite.com/2020/07/23/150.%20%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"/>
    <id>http://yoursite.com/2020/07/23/150. 逆波兰表达式求值/</id>
    <published>2020-07-23T07:36:12.000Z</published>
    <updated>2020-07-23T08:21:38.495Z</updated>
    
    <content type="html"><![CDATA[<p>根据 逆波兰表示法，求表达式的值。</p><p>有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><a id="more"></a><p>说明：</p><p>整数除法只保留整数部分。<br>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p><p>示例 1：</p><pre><code>输入: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]输出: 9解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</code></pre><p>示例 2：</p><pre><code>输入: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]输出: 6解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</code></pre><p>示例 3：</p><pre><code>输入: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]输出: 22解释: 该算式转化为常见的中缀算术表达式为：  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5= ((10 * (6 / (12 * -11))) + 17) + 5= ((10 * (6 / -132)) + 17) + 5= ((10 * 0) + 17) + 5= (0 + 17) + 5= 17 + 5= 22</code></pre><p>逆波兰表达式：</p><p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p><ul><li>平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。</li><li>该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。</li></ul><p>逆波兰表达式主要有以下两个优点：</p><ul><li>去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。</li><li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。</li></ul><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>我首先想到的是用栈的解法</p><p><strong>Java相关优化操作：</strong></p><ul><li>switch代替if-else，效率优化</li><li>Integer.parseInt代替Integer.valueOf,减少自动拆箱装箱操作</li></ul><details>    <summary>栈</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Stack;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int evalRPN(String[] tokens) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        for (String s : tokens) &#123;</span><br><span class="line">            if (!isOp(s)) &#123;</span><br><span class="line">                stack.push(Integer.parseInt(s));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                int ans = res(s.charAt(0), stack.pop(), stack.pop());</span><br><span class="line">                stack.push(ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean isOp(String s) &#123;</span><br><span class="line">        if (s.length() &gt; 1) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        switch (s.charAt(0)) &#123;</span><br><span class="line">            case &apos;*&apos;:</span><br><span class="line">                return true; //因为直接返回了所以不加break了</span><br><span class="line">            case &apos;/&apos;:</span><br><span class="line">                return true;</span><br><span class="line">            case &apos;+&apos;:</span><br><span class="line">                return true;</span><br><span class="line">            case &apos;-&apos;:</span><br><span class="line">                return true;</span><br><span class="line">            default:</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int res(char op, int b, int a) &#123;</span><br><span class="line">        int res=0;</span><br><span class="line">        switch (op) &#123;</span><br><span class="line">            case &apos;*&apos;:</span><br><span class="line">                res = a * b;</span><br><span class="line">                break;</span><br><span class="line">            case &apos;/&apos;:</span><br><span class="line">                res = a / b;</span><br><span class="line">                break;</span><br><span class="line">            case &apos;+&apos;:</span><br><span class="line">                res = a + b;</span><br><span class="line">                break;</span><br><span class="line">            case &apos;-&apos;:</span><br><span class="line">                res = a - b;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="纯数组模拟栈实现："><a href="#纯数组模拟栈实现：" class="headerlink" title="纯数组模拟栈实现："></a>纯数组模拟栈实现：</h1><p><strong>其他Java相关优化操作：</strong></p><ul><li>数组最大长度为<code>tokens.length / 2 + 1</code></li></ul><details>    <summary>纯数组模拟栈实现(推荐)</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="comment">//纯数组模拟栈实现(推荐)   3 ms36 MB</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] numStack = <span class="keyword">new</span> <span class="keyword">int</span>[tokens.length / <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (String s : tokens) &#123;</span><br><span class="line"><span class="keyword">switch</span> (s) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">numStack[index - <span class="number">2</span>] += numStack[--index];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">numStack[index - <span class="number">2</span>] -= numStack[--index];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">numStack[index - <span class="number">2</span>] *= numStack[--index];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">numStack[index - <span class="number">2</span>] /= numStack[--index];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// numStack[index++] = Integer.valueOf(s);</span></span><br><span class="line"><span class="comment">//valueOf改为parseInt，减少自动拆箱装箱操作</span></span><br><span class="line">numStack[index++] = Integer.parseInt(s);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> numStack[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据 逆波兰表示法，求表达式的值。&lt;/p&gt;
&lt;p&gt;有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年7月" scheme="http://yoursite.com/categories/2020%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>341. 扁平化嵌套列表迭代器</title>
    <link href="http://yoursite.com/2020/07/23/341.%20%E6%89%81%E5%B9%B3%E5%8C%96%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <id>http://yoursite.com/2020/07/23/341. 扁平化嵌套列表迭代器/</id>
    <published>2020-07-23T06:21:12.000Z</published>
    <updated>2020-07-23T07:34:33.200Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个嵌套的整型列表。请你设计一个迭代器，使其能够遍历这个整型列表中的所有整数。</p><p>列表中的每一项或者为一个整数，或者是另一个列表。其中列表的元素也可能是整数或是其他列表。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: [[1,1],2,[1,1]]输出: [1,1,2,1,1]解释: 通过重复调用 next 直到 hasNext 返回 false，next 返回的元素的顺序应该是: [1,1,2,1,1]。</code></pre><p>示例 2:</p><pre><code>输入: [1,[4,[6]]]输出: [1,4,6]解释: 通过重复调用 next 直到 hasNext 返回 false，next 返回的元素的顺序应该是: [1,4,6]。</code></pre><h1 id="递归："><a href="#递归：" class="headerlink" title="递归："></a>递归：</h1><p>简单粗暴，在初始化迭代器的时候就直接把结果遍历出来，递归遍历列表中的数据，是整数就放入List，不是则再递归遍历，代码结构简单。但这种解法很奇怪，因为题目没给数据结构的具体结构，不知道哪来的isInteger()这种库函数的</p><details>    <summary>递归</summary><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Integer</span>&gt; </span>{    <span class="keyword">private</span> List&lt;Integer&gt; list;    <span class="keyword">private</span> <span class="keyword">int</span> index;    <span class="function"><span class="keyword">public</span> <span class="title">NestedIterator</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>{        list = integerIterator(nestedList);        index = -<span class="number">1</span>;    }    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span> </span>{        <span class="keyword">if</span> (<span class="keyword">this</span>.hasNext())  <span class="keyword">return</span> list.get(++index);        <span class="keyword">return</span> <span class="keyword">null</span>;    }    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>{        <span class="keyword">if</span> (index + <span class="number">1</span> &lt; list.size()) <span class="keyword">return</span> <span class="keyword">true</span>;        <span class="keyword">return</span> <span class="keyword">false</span>;    }    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">integerIterator</span><span class="params">(List&lt;NestedInteger&gt; nestedIntegerList)</span> </span>{        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(nestedIntegerList.size());        <span class="keyword">for</span> (NestedInteger tmp : nestedIntegerList) {            <span class="keyword">if</span> (tmp.isInteger())                 list.add(tmp.getInteger());            <span class="keyword">else</span>                 list.addAll(integerIterator(tmp.getList()));        }        <span class="keyword">return</span> list;    }}</code></pre></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你一个嵌套的整型列表。请你设计一个迭代器，使其能够遍历这个整型列表中的所有整数。&lt;/p&gt;
&lt;p&gt;列表中的每一项或者为一个整数，或者是另一个列表。其中列表的元素也可能是整数或是其他列表。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年7月" scheme="http://yoursite.com/categories/2020%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
      <category term="Design" scheme="http://yoursite.com/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>基本计算器 II</title>
    <link href="http://yoursite.com/2020/07/23/227.%20%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8%20II/"/>
    <id>http://yoursite.com/2020/07/23/227. 基本计算器 II/</id>
    <published>2020-07-23T03:12:12.000Z</published>
    <updated>2020-07-23T06:15:33.763Z</updated>
    
    <content type="html"><![CDATA[<p>实现一个基本的计算器来计算一个简单的字符串表达式的值。</p><p>字符串表达式仅包含非负整数，+， - ，*，/ 四种运算符和空格  。 整数除法仅保留整数部分。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: &quot;3+2*2&quot;输出: 7</code></pre><p>示例 2:</p><pre><code>输入: &quot; 3/2 &quot;输出: 1</code></pre><p>示例 3:</p><pre><code>输入: &quot; 3+5 / 2 &quot;输出: 5</code></pre><p>说明：</p><p>你可以假设所给定的表达式都是有效的。<br>请不要使用内置的库函数 eval。</p><h1 id="栈的经典应用"><a href="#栈的经典应用" class="headerlink" title="栈的经典应用"></a>栈的经典应用</h1><p>此算法的思路很简单，先把乘除法的值计算出来，最终将所有的运算简化成只有加法。</p><ol><li>先跳过空格</li><li>出现了数字则记录整个数字是多少，然后根据之前的运算符决定下一步：</li></ol><ul><li>如果是加号’+’，说明前面的运算独立于以后的运算，可以将结果暂时放入栈；</li><li>如果是减号’-‘，可以看成<code>-1 * tempNum</code>，然后将<code>-tempNum</code>入栈；</li><li>如果是乘号’*’或者除号’/‘，由于前面的运算独立于此，可以先计算<code>lastNum</code>和<code>tempNum</code>积，然后结果入栈。</li></ul><ol start="3"><li>最后将栈中的所有元素相加就是答案。<details> <summary>栈的经典应用</summary></details></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int calculate(String s) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; numStack = new Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        char lastOp = &apos;+&apos;;</span><br><span class="line">        char[] arr = s.toCharArray();</span><br><span class="line">        for(int i = 0; i &lt; arr.length; i ++)&#123;</span><br><span class="line">            if(arr[i] == &apos; &apos;) continue;</span><br><span class="line"></span><br><span class="line">            if(Character.isDigit(arr[i]))&#123;</span><br><span class="line">                int tempNum = arr[i] - &apos;0&apos;;</span><br><span class="line">                while(++i &lt; arr.length &amp;&amp; Character.isDigit(arr[i]))&#123;</span><br><span class="line">                    tempNum = tempNum * 10 + (arr[i] - &apos;0&apos;);</span><br><span class="line">                &#125; i--;</span><br><span class="line"></span><br><span class="line">                if(lastOp == &apos;+&apos;) numStack.push(tempNum);</span><br><span class="line">                else if(lastOp == &apos;-&apos;) numStack.push(-tempNum);</span><br><span class="line">                else numStack.push(res(lastOp, numStack.pop(), tempNum));</span><br><span class="line">            &#125; else lastOp = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ans = 0;</span><br><span class="line">        for(int num : numStack) ans += num;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private int res(char op, int a, int b)&#123;</span><br><span class="line">        if(op == &apos;*&apos;) return a * b;</span><br><span class="line">        else if(op == &apos;/&apos;) return a / b;</span><br><span class="line">        else if(op == &apos;+&apos;) return a + b; //其实加减运算可以忽略</span><br><span class="line">        else return a - b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实现一个基本的计算器来计算一个简单的字符串表达式的值。&lt;/p&gt;
&lt;p&gt;字符串表达式仅包含非负整数，+， - ，*，/ 四种运算符和空格  。 整数除法仅保留整数部分。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年7月" scheme="http://yoursite.com/categories/2020%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>239. 滑动窗口最大值</title>
    <link href="http://yoursite.com/2020/07/19/239.%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>http://yoursite.com/2020/07/19/239. 滑动窗口最大值/</id>
    <published>2020-07-18T17:12:12.000Z</published>
    <updated>2020-07-23T03:08:31.353Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p><a id="more"></a><p>进阶：</p><p>你能在线性时间复杂度内解决此题吗？</p><p>示例:</p><pre><code>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3输出: [3,3,5,5,6,7] </code></pre><p>解释: </p><pre><code>  滑动窗口的位置                最大值---------------               -----[1  3  -1] -3  5  3  6  7       3 1 [3  -1  -3] 5  3  6  7       3 1  3 [-1  -3  5] 3  6  7       5 1  3  -1 [-3  5  3] 6  7       5 1  3  -1  -3 [5  3  6] 7       6 1  3  -1  -3  5 [3  6  7]      7</code></pre><p>提示：</p><pre><code>1 &lt;= nums.length &lt;= 10^5-10^4 &lt;= nums[i] &lt;= 10^41 &lt;= k &lt;= nums.length</code></pre><h1 id="我的解法："><a href="#我的解法：" class="headerlink" title="我的解法："></a>我的解法：</h1><p>我首先想到的是用一个max保存窗口中的最大值，每次滑动窗口时都更新一下max并放到结果数组中，但是遇到问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">测试用例:[1,-1]</span><br><span class="line">1</span><br><span class="line">测试结果:[1,1]</span><br><span class="line">期望结果:[1,-1]</span><br></pre></td></tr></table></figure><p>是因为没有考虑到滑动到新窗口时如果原来的最大值恰好是原窗口的首个这种情况，需要把原来的最大值去掉，然后找到剩余元素的最大值，再去更新新窗口中的最大值。</p><details>    <summary>我的解法Java版</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] maxSlidingWindow(int[] nums, int k) &#123;</span><br><span class="line">        int[] res = new int[nums.length - k + 1];</span><br><span class="line">        int max = findMax(nums, 0, k - 1);</span><br><span class="line">        res[0]=max;</span><br><span class="line">        int index = 1;</span><br><span class="line">        for (int i = k; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (max == nums[i - k]) &#123;</span><br><span class="line">                max = findMax(nums, i - k + 1, i - 1);</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max, nums[i]);</span><br><span class="line">            res[index++] = max;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int findMax(int[] nums, int begin, int end) &#123;</span><br><span class="line">        int max=Integer.MIN_VALUE;</span><br><span class="line">        for (int i = begin; i &lt;= end; i++) &#123;</span><br><span class="line">            max = Math.max(max, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>哈哈哈通过了，这道Hard的题目只改了一次就过了，前所未有。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">info</span><br><span class="line">解答成功:</span><br><span class="line">执行耗时:4 ms,击败了92.27% 的Java用户</span><br><span class="line">内存消耗:51.1 MB,击败了6.67% 的Java用户</span><br></pre></td></tr></table></figure><h1 id="方法一：暴力法-1"><a href="#方法一：暴力法-1" class="headerlink" title="方法一：暴力法^1"></a>方法一：暴力法<a href="https://leetcode-cn.com/problems/sliding-window-maximum/solution/hua-dong-chuang-kou-zui-da-zhi-by-leetcode-3/" target="_blank" rel="noopener">^1</a></h1><p><strong>直觉</strong></p><p>最简单直接的方法是遍历每个滑动窗口，找到每个窗口的最大值。一共有  <code>N - k + 1</code> 个滑动窗口，每个有 <code>k</code> 个元素，于是算法的时间复杂度为 <em>O(N k)</em>，表现较差。</p><p><strong>实现</strong></p><details>    <summary>暴力解法Python版</summary><figure class="highlight python"><figcaption><span>[solution 1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums: <span class="string">'List[int]'</span>, k: <span class="string">'int'</span>)</span> -&gt; 'List[int]':</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n * k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [max(nums[i:i + k]) <span class="keyword">for</span> i <span class="keyword">in</span> range(n - k + <span class="number">1</span>)]</span><br></pre></td></tr></table></figure></details><details>    <summary>暴力解法Java版</summary><figure class="highlight java"><figcaption><span>[solution 1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n * k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> [] output = <span class="keyword">new</span> <span class="keyword">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - k + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; i + k; j++) </span><br><span class="line">                max = Math.max(max, nums[j]);</span><br><span class="line">            output[i] = max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(N k)</em>。其中 <code>N</code> 为数组中元素个数。</p></li><li><p>空间复杂度：<em>O(N - k + 1)</em>，用于输出数组。</p><br><br></li></ul><hr><h1 id="方法二：双向队列"><a href="#方法二：双向队列" class="headerlink" title="方法二：双向队列"></a>方法二：双向队列</h1><p><strong>直觉</strong></p><p>如何优化时间复杂度呢？首先想到的是使用<strong>堆</strong>，因为在最大堆中 <code>heap[0]</code> 永远是最大的元素。在大小为 <code>k</code> 的堆中插入一个元素消耗log(k) 时间，因此算法的时间复杂度为 O(Nlog(k))。</p><blockquote><p>能否得到只要 <em>O(N)</em> 的算法？</p></blockquote><p>我们可以使用<strong>双向队列</strong>，该数据结构可以从两端以常数时间压入/弹出元素。</p><p>存储双向队列的索引比存储元素更方便，因为两者都能在数组解析中使用。</p><p><strong>算法</strong></p><p>算法非常直截了当：</p><ul><li><p>处理前 <code>k</code> 个元素，初始化双向队列。</p></li><li><p>遍历整个数组。在每一步 :</p><p>  清理双向队列 :</p><pre><code>- 只保留当前滑动窗口中有的元素的索引。- 移除比当前元素小的所有元素，它们不可能是最大的。</code></pre></li></ul><ul><li>将当前元素添加到双向队列中。</li><li>将 <code>deque[0]</code> 添加到输出中。</li><li>返回输出数组。</li></ul><p><strong>实现</strong></p><details>    <summary>双向队列Python实现</summary><figure class="highlight python"><figcaption><span>[solution 2]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums: <span class="string">'List[int]'</span>, k: <span class="string">'int'</span>)</span> -&gt; 'List[int]':</span></span><br><span class="line">        <span class="comment"># base cases</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n * k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">clean_deque</span><span class="params">(i)</span>:</span></span><br><span class="line">            <span class="comment"># remove indexes of elements not from sliding window</span></span><br><span class="line">            <span class="keyword">if</span> deq <span class="keyword">and</span> deq[<span class="number">0</span>] == i - k:</span><br><span class="line">                deq.popleft()</span><br><span class="line">                </span><br><span class="line">            <span class="comment"># remove from deq indexes of all elements </span></span><br><span class="line">            <span class="comment"># which are smaller than current element nums[i]</span></span><br><span class="line">            <span class="keyword">while</span> deq <span class="keyword">and</span> nums[i] &gt; nums[deq[<span class="number">-1</span>]]:</span><br><span class="line">                deq.pop()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># init deque and output</span></span><br><span class="line">        deq = deque()</span><br><span class="line">        max_idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            clean_deque(i)</span><br><span class="line">            deq.append(i)</span><br><span class="line">            <span class="comment"># compute max in nums[:k]</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[max_idx]:</span><br><span class="line">                max_idx = i</span><br><span class="line">        output = [nums[max_idx]]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># build output</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k, n):</span><br><span class="line">            clean_deque(i)          </span><br><span class="line">            deq.append(i)</span><br><span class="line">            output.append(nums[deq[<span class="number">0</span>]])</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure></details><details>    <summary>双向队列Java实现</summary><figure class="highlight java"><figcaption><span>[solution 2]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  ArrayDeque&lt;Integer&gt; deq = <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;();</span><br><span class="line">  <span class="keyword">int</span> [] nums;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clean_deque</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// remove indexes of elements not from sliding window</span></span><br><span class="line">    <span class="keyword">if</span> (!deq.isEmpty() &amp;&amp; deq.getFirst() == i - k)</span><br><span class="line">      deq.removeFirst();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// remove from deq indexes of all elements </span></span><br><span class="line">    <span class="comment">// which are smaller than current element nums[i]</span></span><br><span class="line">    <span class="keyword">while</span> (!deq.isEmpty() &amp;&amp; nums[i] &gt; nums[deq.getLast()])   </span><br><span class="line">    deq.removeLast();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (n * k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init deque and output</span></span><br><span class="line">    <span class="keyword">this</span>.nums = nums;</span><br><span class="line">    <span class="keyword">int</span> max_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">      clean_deque(i, k);</span><br><span class="line">      deq.addLast(i);</span><br><span class="line">      <span class="comment">// compute max in nums[:k]</span></span><br><span class="line">      <span class="keyword">if</span> (nums[i] &gt; nums[max_idx]) max_idx = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> [] output = <span class="keyword">new</span> <span class="keyword">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">    output[<span class="number">0</span>] = nums[max_idx];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build output</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i  = k; i &lt; n; i++) &#123;</span><br><span class="line">      clean_deque(i, k);</span><br><span class="line">      deq.addLast(i);</span><br><span class="line">      output[i - k + <span class="number">1</span>] = nums[deq.getFirst()];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(N)</em>，每个元素被处理两次- 其索引被添加到双向队列中和被双向队列删除。</p></li><li><p>空间复杂度：<em>O(N)*，输出数组使用了 *O(N - k + 1)</em> 空间，双向队列使用了 <em>O(k)</em>。</p><br><br></li></ul><hr><h1 id="方法三-动态规划"><a href="#方法三-动态规划" class="headerlink" title="方法三: 动态规划"></a>方法三: 动态规划</h1><p><strong>直觉</strong></p><p>这是另一个 <em>{O}(N)</em> 的算法。本算法的优点是不需要使用 <code>数组 / 列表</code> 之外的任何数据结构。</p><p>算法的思想是将输入数组分割成有 <code>k</code> 个元素的块。<br>若 <code>n % k != 0</code>，则最后一块的元素个数可能更少。</p><p> <a href="https://pic.leetcode-cn.com/95c5c42bcedb9c417b96925e5204e5bdad34456e29bd1b61a41138abd80e4b0b-image.png" target="_blank" rel="noopener">image.png</a></p><p>开头元素为 <code>i</code> ，结尾元素为 <code>j</code> 的当前滑动窗口可能在一个块内，也可能在两个块中。</p><p> <a href="https://pic.leetcode-cn.com/27af2b52e80803bcb7a8285dbd27cfa9292a6cf6dd0a6454454d6d3357da15c6-image.png" target="_blank" rel="noopener">image.png</a></p><p>情况 <code>1</code> 比较简单。 建立数组 <code>left</code>， 其中 <code>left[j]</code> 是从块的开始到下标 <code>j</code> 最大的元素，方向 <code>左-&gt;右</code>。</p><p> <a href="https://pic.leetcode-cn.com/79cbfbefc4c891c337f6b5de8c29f9d3ab39883c92c084a46163f2fa4f0f1d37-image.png" target="_blank" rel="noopener">image.png</a></p><p>为了处理更复杂的情况 <code>2</code>，我们需要数组 <code>right</code>，其中 <code>right[j]</code> 是从块的结尾到下标 <code>j</code> 最大的元素，方向 <code>右-&gt;左</code>。<code>right</code> 数组和 <code>left</code> 除了方向不同以外基本一致。</p><p> <a href="https://pic.leetcode-cn.com/b404188e760dd82a2bd4ebf4f6fe2e8b3c229bb506ed2f3cc8a01675744c351b-image.png" target="_blank" rel="noopener">image.png</a></p><p>两数组一起可以提供两个块内元素的全部信息。考虑从下标 <code>i</code> 到下标 <code>j</code>的滑动窗口。 根据定义，<code>right[i]</code> 是<strong>左侧块内的最大元素</strong>， <code>left[j]</code> 是<strong>右侧块内的最大元素</strong>。因此滑动窗口中的最大元素为 <code>max(right[i], left[j])</code>。</p><p> <a href="https://pic.leetcode-cn.com/3074f1eb068151ebdebbf1b605234815c64d0bf7812d33c8eb5ba044ab625300-image.png" target="_blank" rel="noopener">image.png</a></p><p>说实话我一开始看到这个方法有点儿迷糊，但重点理解<code>right[i]</code> 是<strong>左侧块内的最大元素</strong>， <code>left[j]</code> 是<strong>右侧块内的最大元素</strong>，配合下面的图解就能轻松理解了。</p><p><strong>算法</strong></p><p>算法十分直截了当：</p><ul><li><p>从左到右遍历数组，建立数组 <code>left</code>。</p></li><li><p>从右到左遍历数组，建立数组 <code>right</code>。</p></li><li><p>建立输出数组 <code>max(right[i], left[i + k - 1])</code>，其中 <code>i</code> 取值范围为 <code>(0, n - k + 1)</code>。</p></li></ul><p><strong>实现</strong></p><p>  <a href="https://pic.leetcode-cn.com/e793d5c8ede0be91804b291f1565ab90c980371879d6ec683d0a05c1b4f7e984-image.png" target="_blank" rel="noopener">image.png</a>  <a href="https://pic.leetcode-cn.com/4a699746334bfd5548a8a2a920e5bcd2b2922f6c39ca0bf2a52bc741a8b9c10d-image.png" target="_blank" rel="noopener">image.png</a>  <a href="https://pic.leetcode-cn.com/f20d788625572649bd3def127aafdd287eb9d958fdb7e8323183980a4721f7aa-image.png" target="_blank" rel="noopener">image.png</a>  <a href="https://pic.leetcode-cn.com/df789ba3e0741df8493eaedbbb5cc483a5805e7f4fc65a5a16436749a29bd08b-image.png" target="_blank" rel="noopener">image.png</a>  <a href="https://pic.leetcode-cn.com/f060cabc30a2f902c9be177070a68df07e9a1586aff921c4243dbc376c276738-image.png" target="_blank" rel="noopener">image.png</a>  <a href="https://pic.leetcode-cn.com/263dd3579de8f15c38164db0e7c506d9269c657c34f50dff0512469867a26f78-image.png" target="_blank" rel="noopener">image.png</a> </p><details>    <summary>动态规划Python</summary><figure class="highlight python"><figcaption><span>[solution 3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums: <span class="string">'List[int]'</span>, k: <span class="string">'int'</span>)</span> -&gt; 'List[int]':</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n * k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        </span><br><span class="line">        left = [<span class="number">0</span>] * n</span><br><span class="line">        left[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        right = [<span class="number">0</span>] * n</span><br><span class="line">        right[n - <span class="number">1</span>] = nums[n - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="comment"># from left to right</span></span><br><span class="line">            <span class="keyword">if</span> i % k == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># block start</span></span><br><span class="line">                left[i] = nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left[i] = max(left[i - <span class="number">1</span>], nums[i])</span><br><span class="line">            <span class="comment"># from right to left</span></span><br><span class="line">            j = n - i - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span>) % k == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># block end</span></span><br><span class="line">                right[j] = nums[j]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right[j] = max(right[j + <span class="number">1</span>], nums[j])</span><br><span class="line">        </span><br><span class="line">        output = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - k + <span class="number">1</span>):</span><br><span class="line">            output.append(max(left[i + k - <span class="number">1</span>], right[i]))</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划Java</summary><figure class="highlight java"><figcaption><span>[solution 3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (n * k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> [] left = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    left[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> [] right = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    right[n - <span class="number">1</span>] = nums[n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="comment">// from left to right</span></span><br><span class="line">      <span class="keyword">if</span> (i % k == <span class="number">0</span>) left[i] = nums[i];  <span class="comment">// block_start</span></span><br><span class="line">      <span class="keyword">else</span> left[i] = Math.max(left[i - <span class="number">1</span>], nums[i]);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// from right to left</span></span><br><span class="line">      <span class="keyword">int</span> j = n - i - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> ((j + <span class="number">1</span>) % k == <span class="number">0</span>) right[j] = nums[j];  <span class="comment">// block_end</span></span><br><span class="line">      <span class="keyword">else</span> right[j] = Math.max(right[j + <span class="number">1</span>], nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> [] output = <span class="keyword">new</span> <span class="keyword">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - k + <span class="number">1</span>; i++)</span><br><span class="line">      output[i] = Math.max(left[i + k - <span class="number">1</span>], right[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>**复杂度分析**<ul><li><p>时间复杂度：<em>O(N)</em>，我们对长度为 <code>N</code> 的数组处理了 <code>3</code>次。 </p></li><li><p>空间复杂度：<em>O(N)</em>，用于存储长度为 <code>N</code> 的 <code>left</code> 和 <code>right</code> 数组，以及长度为 <code>N - k + 1</code>的输出数组。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。&lt;/p&gt;
&lt;p&gt;返回滑动窗口中的最大值。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年7月" scheme="http://yoursite.com/categories/2020%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Heap" scheme="http://yoursite.com/tags/Heap/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>347. 前 K 个高频元素</title>
    <link href="http://yoursite.com/2020/07/18/347.%20%E5%89%8D%20K%20%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2020/07/18/347. 前 K 个高频元素/</id>
    <published>2020-07-18T15:40:12.000Z</published>
    <updated>2020-07-18T16:52:44.424Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2]</code></pre><p>示例 2:</p><pre><code>输入: nums = [1], k = 1输出: [1]</code></pre><p>提示：</p><pre><code>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。你可以按任意顺序返回答案。</code></pre><h1 id="最小堆的两种定义方法："><a href="#最小堆的两种定义方法：" class="headerlink" title="最小堆的两种定义方法："></a>最小堆的两种定义方法：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 遍历map，用最小堆保存频率最大的k个元素</span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(</span><br><span class="line">        new Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Integer a, Integer b) &#123;</span><br><span class="line">                return map.get(a) - map.get(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line"> // init heap &apos;the less frequent element first&apos;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; heap =</span><br><span class="line">            new PriorityQueue&lt;Integer&gt;(</span><br><span class="line">            (n1, n2) -&gt; count.get(n1) - count.get(n2));</span><br></pre></td></tr></table></figure><h1 id="方法-1：堆"><a href="#方法-1：堆" class="headerlink" title="方法 1：堆"></a>方法 1：堆</h1><p><strong>想法</strong></p><p><code>k = 1</code> 时问题很简单，线性时间内就可以解决。只需要用哈希表维护元素出现频率，每一步更新最高频元素即可。</p><p>当 <code>k &gt; 1</code> 就需要一个能够根据出现频率快速获取元素的数据结构，这就是优先队列。</p><p>首先建立一个元素值对应出现频率的哈希表。在 Java 中使用 <code>HashMap</code>，但需要手工填值。在 Python 中提供一个字典结构用作哈希表和在 <code>collections</code> 库中的 <code>Counter</code> 方法去构建我们需要的哈希表。</p><p>这个步骤需要 <em>O(N)</em> 时间其中 <em>N</em> 是列表中元素个数。</p><p>第二步建立堆，堆中添加一个元素的复杂度是 O(log(k)) ，要进行 <em>N</em> 次复杂度是 <em>O(N)</em>。</p><p>最后一步是输出结果，复杂度为O(klog(k))。</p><p>在 Python 中可以使用 <code>heapq</code> 库中的 <code>nlargest</code> <a href="https://hg.python.org/cpython/file/2.7/Lib/heapq.py#l203" target="_blank" rel="noopener">方法</a>，可以在相同时间内完成，但只需要一行代码解决。</p><p>  <a href="https://pic.leetcode-cn.com/4155ee86a93437e3e97c26051fa9cf9dd8524306099f08ae1073eaad57cb3bc0-1.png" target="_blank" rel="noopener">1.png</a>  <a href="https://pic.leetcode-cn.com/f355b6e6d76fccab2f2b874cdc009248a02badd8d906ef97197fe21effef257f-2.png" target="_blank" rel="noopener">2.png</a>  <a href="https://pic.leetcode-cn.com/02b4ba46f1998841f15b9e49c35a33a0f02d41b3a4b09543fea549bcfa75e3b1-3.png" target="_blank" rel="noopener">3.png</a>  <a href="https://pic.leetcode-cn.com/561698deee4cf6e015f2d7675b93298d4d03693ae94f6a0c639d4c642257bfd9-4.png" target="_blank" rel="noopener">4.png</a>  <a href="https://pic.leetcode-cn.com/f637fa869f031dc419d2d5069d06897cabf64ab741384cd4b3ec5c1d44cc5874-5.png" target="_blank" rel="noopener">5.png</a>  <a href="https://pic.leetcode-cn.com/a9d96837cd26c63a25f976c3bb5a8adcb657ca4cebc09cfb88c9b48d4747409a-6.png" target="_blank" rel="noopener">6.png</a>  <a href="https://pic.leetcode-cn.com/9c91828d3e5148d871c7a23a09e2a01a090c7753adf4e1746a5ec4fa1465e41b-7.png" target="_blank" rel="noopener">7.png</a>  <a href="https://pic.leetcode-cn.com/933940bb7826b91ae778c3c6cb03ec126e11a53eb054b46d0f801809804f7a27-8.png" target="_blank" rel="noopener">8.png</a>  <a href="https://pic.leetcode-cn.com/6042da7ca897f1786253c0f912d9900336577bf72141e848cb30f44f2f541dc6-9.png" target="_blank" rel="noopener">9.png</a>  <a href="https://pic.leetcode-cn.com/24622621a7be3f475be38c95d13779984631ed99496e91cf4358c3403beeb544-10.png" target="_blank" rel="noopener">10.png</a>  <a href="https://pic.leetcode-cn.com/b0ff8900eddeaf8b85e5b03a0ae91a49449b315a8fda7b6e03434c9ba374b757-11.png" target="_blank" rel="noopener">11.png</a>  <a href="https://pic.leetcode-cn.com/f1395b1ed88ad7c3c2e76b24b29b3b8d88e992b8338aadf9d14de9da3349969e-12.png" target="_blank" rel="noopener">12.png</a>  <a href="https://pic.leetcode-cn.com/ace094402432ad08005f17c02525d841bd2744ab98039eade6fb10968453e718-13.png" target="_blank" rel="noopener">13.png</a>  <a href="https://pic.leetcode-cn.com/bac7c7fd0f87a8f4c6ccb329bcb4590683862db937c66d18cdd034effbaaaaa1-14.png" target="_blank" rel="noopener">14.png</a> </p><p>具体操作为：</p><ul><li>借助 <strong>哈希表</strong> 来建立数字和其出现次数的映射，遍历一遍数组统计元素的频率</li><li>维护一个元素数目为 <em>k</em> 的最小堆</li><li>每次都将新的元素与堆顶元素（堆中频率最小的元素）进行比较</li><li>如果新的元素的频率比堆顶端的元素大，则弹出堆顶端的元素，将新的元素添加进堆中</li><li>最终，堆中的 <em>k</em> 个元素即为前 <em>k</em> 个高频元素</li></ul><figure class="highlight java"><figcaption><span>[-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// build hash map : character and how often it appears</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; count = <span class="keyword">new</span> HashMap();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n: nums) &#123;</span><br><span class="line">      count.put(n, count.getOrDefault(n, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init heap 'the less frequent element first'</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; heap =</span><br><span class="line">            <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;((n1, n2) -&gt; count.get(n1) - count.get(n2));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// keep k top frequent elements in the heap</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n: count.keySet()) &#123;</span><br><span class="line">      heap.add(n);</span><br><span class="line">      <span class="keyword">if</span> (heap.size() &gt; k)</span><br><span class="line">        heap.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build output list</span></span><br><span class="line">    List&lt;Integer&gt; top_k = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    <span class="keyword">while</span> (!heap.isEmpty())</span><br><span class="line">      top_k.add(heap.poll());</span><br><span class="line">    Collections.reverse(top_k);</span><br><span class="line">    <span class="keyword">return</span> top_k;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span> </span><br><span class="line">        count = collections.Counter(nums)   </span><br><span class="line">        <span class="keyword">return</span> heapq.nlargest(k, count.keys(), key=count.get)</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度：O(Nlog(k)) 。<code>Counter</code> 方法的复杂度是 <em>O(N)</em>，建堆和输出的复杂度是 O(Nlog(k))。因此总复杂度为O(N+Nlog(k)))=O(Nlog(k)).</li><li>空间复杂度：<em>O(N)*，存储哈希表的开销。最坏情况下（每个元素都不同），map 需要存储 *n</em> 个键值对，优先队列需要存储 <em>k</em> 个元素，因此，空间复杂度是 <em>O(n)</em>。</li></ul><p><strong>注释</strong></p><p>根据复杂度分析，方法对于小 <code>k</code> 的情况是很优的。但是如果 <code>k</code> 值很大，我们可以将算法改成删除频率最低的若干个元素。</p><h1 id="方法2-：桶排序法"><a href="#方法2-：桶排序法" class="headerlink" title="方法2 ：桶排序法"></a>方法2 ：桶排序法</h1><p>首先依旧使用哈希表统计频率，统计完成后，创建一个数组，将频率作为数组下标，对于出现频率不同的数字集合，存入对应的数组下标即可。</p><p> <a href="https://pic.leetcode-cn.com/ad27531bbe762c0cf408a1e80f6468800d3e4ee2d6318963276b9ed923dd2c54-file_1561712388097" target="_blank" rel="noopener">桶排序法</a></p><p>代码实现如下：</p><figure class="highlight java"><figcaption><span>[-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于桶排序求解「前 K 个高频元素」</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="comment">// 使用字典，统计每个元素出现的次数，元素为键，元素出现的次数为值</span></span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(num)) &#123;</span><br><span class="line">                map.put(num, map.get(num) + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(num, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//桶排序</span></span><br><span class="line">        <span class="comment">//将频率作为数组下标，对于出现频率不同的数字集合，存入对应的数组下标</span></span><br><span class="line">        List&lt;Integer&gt;[] list = <span class="keyword">new</span> List[nums.length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> key : map.keySet())&#123;</span><br><span class="line">            <span class="comment">// 获取出现的次数作为下标</span></span><br><span class="line">            <span class="keyword">int</span> i = map.get(key);</span><br><span class="line">            <span class="keyword">if</span>(list[i] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                list[i] = <span class="keyword">new</span> ArrayList();</span><br><span class="line">            &#125;</span><br><span class="line">            list[i].add(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 倒序遍历数组获取出现顺序从大到小的排列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = list.length - <span class="number">1</span>;i &gt;= <span class="number">0</span> &amp;&amp; res.size() &lt; k;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list[i] == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            res.addAll(list[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] topk = <span class="keyword">new</span> <span class="keyword">int</span>[res.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;res.size() ; i++) &#123;</span><br><span class="line">            topk[i] = res.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> topk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>这里要用<code>List&lt;Integer&gt;[] list = new List[nums.length+1];</code>的原因是出现频率相同的元素可能不止有一个。如果只用List<integer>来保存结果就会出现如下：</integer></p><p>例如    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">测试用例:[1,2]</span><br><span class="line">2</span><br><span class="line">测试结果:[2,0]</span><br><span class="line">期望结果:[1,2]</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度</strong>：<em>O(n)<em>，</em>n</em> 表示数组的长度。首先，遍历一遍数组统计元素的频率，这一系列操作的时间复杂度是 <em>O(n)</em>；桶的数量为 <em>n + 1</em>，所以桶排序的时间复杂度为 <em>O(n)</em>；因此，总的时间复杂度是 <em>O(n)</em>。 </li><li><strong>空间复杂度</strong>：很明显为 <em>O(n)</em></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个非空的整数数组，返回其中出现频率前 k 高的元素。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年7月" scheme="http://yoursite.com/categories/2020%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Heap" scheme="http://yoursite.com/tags/Heap/"/>
    
  </entry>
  
  <entry>
    <title>Java编程思想-第二十二章 枚举阅读笔记</title>
    <link href="http://yoursite.com/2020/07/12/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E7%AB%A0%20%E6%9E%9A%E4%B8%BE%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/07/12/Java编程思想-第二十二章 枚举阅读笔记/</id>
    <published>2020-07-12T15:10:12.000Z</published>
    <updated>2020-07-14T09:21:20.922Z</updated>
    
    <content type="html"><![CDATA[<p>可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用。</p><a id="more"></a><p>[TOC]</p><!-- Enumerations --><h1 id="第二十二章-枚举"><a href="#第二十二章-枚举" class="headerlink" title="第二十二章 枚举"></a>第二十二章 枚举</h1><blockquote><p>关键字 enum 可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用。这是一种非常有用的功能</p></blockquote><p>在<a href>初始化和清理 </a> 这章结束的时候，我们已经简单地介绍了枚举的概念。现在，你对 Java 已经有了更深刻的理解，因此可以更深入地学习 Java 中的枚举了。你将在本章中看到，使用 enum 可以做很多有趣的事情，同时，我们也会深入其他的 Java 特性，例如泛型和反射。在这个过程中，我们还将学习一些设计模式。</p><!-- Basic enum Features --><h2 id="基本-enum-特性"><a href="#基本-enum-特性" class="headerlink" title="基本 enum 特性"></a>基本 enum 特性</h2><p>我们已经在<a href>初始化和清理 </a> 这章章看到，调用 enum 的 values() 方法，可以遍历 enum 实例 .values() 方法返回 enum 实例的数组，而且该数组中的元素严格保持其在 enum 中声明时的顺序，因此你可以在循环中使用 values() 返回的数组。</p><p>创建 enum 时，编译器会为你生成一个相关的类，这个类继承自 Java.lang.Enum。下面的例子演示了 Enum 提供的一些功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enums/EnumClass.java</span></span><br><span class="line"><span class="comment">// Capabilities of the Enum class</span></span><br><span class="line"><span class="keyword">enum</span> Shrubbery &#123; GROUND, CRAWLING, HANGING &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Shrubbery s : Shrubbery.values()) &#123;</span><br><span class="line">            System.out.println(</span><br><span class="line">                    s + <span class="string">" ordinal: "</span> + s.ordinal());</span><br><span class="line">            System.out.print(</span><br><span class="line">                    s.compareTo(Shrubbery.CRAWLING) + <span class="string">" "</span>);</span><br><span class="line">            System.out.print(</span><br><span class="line">                    s.equals(Shrubbery.CRAWLING) + <span class="string">" "</span>);</span><br><span class="line">            System.out.println(s == Shrubbery.CRAWLING);</span><br><span class="line">            System.out.println(s.getDeclaringClass());</span><br><span class="line">            System.out.println(s.name());</span><br><span class="line">            System.out.println(<span class="string">"********************"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// Produce an enum value from a String name:</span></span><br><span class="line">        <span class="keyword">for</span>(String s :</span><br><span class="line">                <span class="string">"HANGING CRAWLING GROUND"</span>.split(<span class="string">" "</span>)) &#123;</span><br><span class="line">            Shrubbery shrub =</span><br><span class="line">                    Enum.valueOf(Shrubbery.class, s);</span><br><span class="line">            System.out.println(shrub);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GROUND ordinal: 0</span><br><span class="line">-1 false false</span><br><span class="line">class Shrubbery</span><br><span class="line">GROUND</span><br><span class="line">********************</span><br><span class="line">CRAWLING ordinal: 1</span><br><span class="line">0 true true</span><br><span class="line">class Shrubbery</span><br><span class="line">CRAWLING</span><br><span class="line">********************</span><br><span class="line">HANGING ordinal: 2</span><br><span class="line">1 false false</span><br><span class="line">class Shrubbery</span><br><span class="line">HANGING</span><br><span class="line">********************</span><br><span class="line">HANGING</span><br><span class="line">CRAWLING</span><br><span class="line">GROUND</span><br></pre></td></tr></table></figure><p>ordinal() 方法返回一个 int 值，这是每个 enum 实例在声明时的次序，从 0 开始。可以使用==来比较 enum 实例，编译器会自动为你提供 equals() 和 hashCode() 方法。Enum 类实现了 Comparable 接口，所以它具有 compareTo() 方法。同时，它还实现了 Serializable 接口。</p><p>如果在 enum 实例上调用 getDeclaringClass() 方法，我们就能知道其所属的 enum 类。</p><p>name() 方法返回 enum 实例声明时的名字，这与使用 toString() 方法效果相同。valueOf() 是在 Enum 中定义的 static 方法，它根据给定的名字返回相应的 enum 实例，如果不存在给定名字的实例，将会抛出异常。</p><h3 id="将静态类型导入用于-enum"><a href="#将静态类型导入用于-enum" class="headerlink" title="将静态类型导入用于 enum"></a>将静态类型导入用于 enum</h3><p>先看一看 <a href>初始化和清理 </a> 这章中 Burrito.java 的另一个版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enums/SpicinessEnum.java</span></span><br><span class="line"><span class="keyword">package</span> enums;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SpicinessEnum &#123;</span><br><span class="line">    NOT, MILD, MEDIUM, HOT, FLAMING</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// enums/Burrito2.java</span></span><br><span class="line"><span class="comment">// &#123;java enums.Burrito2&#125;</span></span><br><span class="line"><span class="keyword">package</span> enums;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> enums.SpicinessEnum.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Burrito2</span> </span>&#123;</span><br><span class="line">    SpicinessEnum degree;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Burrito2</span><span class="params">(SpicinessEnum degree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.degree = degree;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Burrito is "</span>+ degree;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Burrito2(NOT));</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Burrito2(MEDIUM));</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Burrito2(HOT));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Burrito is NOT</span><br><span class="line">Burrito is MEDIUM</span><br><span class="line">Burrito is HOT</span><br></pre></td></tr></table></figure><p>使用 static import 能够将 enum 实例的标识符带入当前的命名空间，所以无需再用 enum 类型来修饰 enum 实例。这是一个好的想法吗？或者还是显式地修饰 enum 实例更好？这要看代码的复杂程度了。编译器可以确保你使用的是正确的类型，所以唯一需要担心的是，使用静态导入会不会导致你的代码令人难以理解。多数情况下，使用 static import 还是有好处的，不过，程序员还是应该对具体情况进行具体分析。</p><p>注意，在定义 enum 的同一个文件中，这种技巧无法使用，如果是在默认包中定义 enum，这种技巧也无法使用（在 Sun 内部对这一点显然也有不同意见）。</p><!-- Adding Methods to an enum --><h2 id="方法添加"><a href="#方法添加" class="headerlink" title="方法添加"></a>方法添加</h2><p>除了不能继承自一个 enum 之外，我们基本上可以将 enum 看作一个常规的类。也就是说我们可以向 enum 中添加方法。enum 甚至可以有 main() 方法。</p><p>一般来说，我们希望每个枚举实例能够返回对自身的描述，而不仅仅只是默认的 toString() 实现，这只能返回枚举实例的名字。为此，你可以提供一个构造器，专门负责处理这个额外的信息，然后添加一个方法，返回这个描述信息。看一看下面的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enums/OzWitch.java</span></span><br><span class="line"><span class="comment">// The witches in the land of Oz</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> OzWitch &#123;</span><br><span class="line">    <span class="comment">// Instances must be defined first, before methods:</span></span><br><span class="line">    WEST(<span class="string">"Miss Gulch, aka the Wicked Witch of the West"</span>),</span><br><span class="line">    NORTH(<span class="string">"Glinda, the Good Witch of the North"</span>),</span><br><span class="line">    EAST(<span class="string">"Wicked Witch of the East, wearer of the Ruby "</span> +</span><br><span class="line">            <span class="string">"Slippers, crushed by Dorothy's house"</span>),</span><br><span class="line">    SOUTH(<span class="string">"Good by inference, but missing"</span>);</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="comment">// Constructor must be package or private access:</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">OzWitch</span><span class="params">(String description)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> description; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(OzWitch witch : OzWitch.values())</span><br><span class="line">            System.out.println(</span><br><span class="line">                    witch + <span class="string">": "</span> + witch.getDescription());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WEST: Miss Gulch, aka the Wicked Witch of the West</span><br><span class="line">NORTH: Glinda, the Good Witch of the North</span><br><span class="line">EAST: Wicked Witch of the East, wearer of the Ruby</span><br><span class="line">Slippers, crushed by Dorothy&apos;s house</span><br><span class="line">SOUTH: Good by inference, but missing</span><br></pre></td></tr></table></figure><p>注意，如果你打算定义自己的方法，那么必须在 enum 实例序列的最后添加一个分号。同时，Java 要求你必须先定义 enum 实例。如果在定义 enum 实例之前定义了任何方法或属性，那么在编译时就会得到错误信息。</p><p>enum 中的构造器与方法和普通的类没有区别，因为除了有少许限制之外，enum 就是一个普通的类。所以，我们可以使用 enum 做许多事情（虽然，我们一般只使用普通的枚举类型）</p><p>在这个例子中，虽然我们有意识地将 enum 的构造器声明为 private，但对于它的可访问性而言，其实并没有什么变化，因为（即使不声明为 private）我们只能在 enum 定义的内部使用其构造器创建 enum 实例。一旦 enum 的定义结束，编译器就不允许我们再使用其构造器来创建任何实例了。</p><h3 id="覆盖-enum-的方法"><a href="#覆盖-enum-的方法" class="headerlink" title="覆盖 enum 的方法"></a>覆盖 enum 的方法</h3><p>覆盖 toSring() 方法，给我们提供了另一种方式来为枚举实例生成不同的字符串描述信息。<br>在下面的示例中，我们使用的就是实例的名字，不过我们希望改变其格式。覆盖 enum 的 toSring() 方法与覆盖一般类的方法没有区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enums/SpaceShip.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SpaceShip &#123;</span><br><span class="line">    SCOUT, CARGO, TRANSPORT,</span><br><span class="line">    CRUISER, BATTLESHIP, MOTHERSHIP;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String id = name();</span><br><span class="line">        String lower = id.substring(<span class="number">1</span>).toLowerCase();</span><br><span class="line">        <span class="keyword">return</span> id.charAt(<span class="number">0</span>) + lower;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream.of(values())</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Scout</span><br><span class="line">Cargo</span><br><span class="line">Transport</span><br><span class="line">Cruiser</span><br><span class="line">Battleship</span><br><span class="line">Mothership</span><br></pre></td></tr></table></figure><p>toString() 方法通过调用 name() 方法取得 SpaceShip 的名字，然后将其修改为只有首字母大写的格式。</p><!-- enums in switch Statements --><h2 id="switch-语句中的-enum"><a href="#switch-语句中的-enum" class="headerlink" title="switch 语句中的 enum"></a>switch 语句中的 enum</h2><p>在 switch 中使用 enum，是 enum 提供的一项非常便利的功能。一般来说，在 switch 中只能使用整数值，而枚举实例天生就具备整数值的次序，并且可以通过 ordinal() 方法取得其次序（显然编译器帮我们做了类似的工作），因此我们可以在 switch 语句中使用 enum。</p><p>虽然一般情况下我们必须使用 enum 类型来修饰一个 enum 实例，但是在 case 语句中却不必如此。下面的例子使用 enum 构造了一个小型状态机：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enums/TrafficLight.java</span></span><br><span class="line"><span class="comment">// Enums in switch statements</span></span><br><span class="line"><span class="comment">// Define an enum type:</span></span><br><span class="line"><span class="keyword">enum</span> Signal &#123; GREEN, YELLOW, RED, &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrafficLight</span> </span>&#123;</span><br><span class="line">    Signal color = Signal.RED;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(color) &#123;</span><br><span class="line">           <span class="comment">// Note you don't have to say Signal.RED</span></span><br><span class="line">            <span class="comment">// in the case statement:</span></span><br><span class="line">            <span class="keyword">case</span> RED: color = Signal.GREEN;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> GREEN: color = Signal.YELLOW;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> YELLOW: color = Signal.RED;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"The traffic light is "</span> + color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TrafficLight t = <span class="keyword">new</span> TrafficLight();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            System.out.println(t);</span><br><span class="line">            t.change();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">The traffic light is RED</span><br><span class="line">The traffic light is GREEN</span><br><span class="line">The traffic light is YELLOW</span><br><span class="line">The traffic light is RED</span><br><span class="line">The traffic light is GREEN</span><br><span class="line">The traffic light is YELLOW</span><br><span class="line">The traffic light is RED</span><br></pre></td></tr></table></figure><p>编译器并没有抱怨 switch 中没有 default 语句，但这并不是因为每一个 Signal 都有对应的 case 语句。如果你注释掉其中的某个 case 语句，编译器同样不会抱怨什么。这意味着，你必须确保自己覆盖了所有的分支。但是，如果在 case 语句中调用 return，那么编译器就会抱怨缺少 default 语句了。这与是否覆盖了 enum 的所有实例无关。</p><!-- The Mystery of values() --><h2 id="values-方法的神秘之处"><a href="#values-方法的神秘之处" class="headerlink" title="values 方法的神秘之处"></a>values 方法的神秘之处</h2><p>前面已经提到，编译器为你创建的 enum 类都继承自 Enum 类。然而，如果你研究一下 Enum 类就会发现，它并没有 values() 方法。可我们明明已经用过该方法了，难道存在某种“隐藏的”方法吗？我们可以利用反射机制编写一个简单的程序，来查看其中的究竟：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enums/Reflection.java</span></span><br><span class="line"><span class="comment">// Analyzing enums using reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">enum</span> Explore &#123; HERE, THERE &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reflection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span></span><br><span class="line">    <span class="function">Set&lt;String&gt; <span class="title">analyze</span><span class="params">(Class&lt;?&gt; enumClass)</span> </span>&#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">                <span class="string">"_____ Analyzing "</span> + enumClass + <span class="string">" _____"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Interfaces:"</span>);</span><br><span class="line">        <span class="keyword">for</span>(Type t : enumClass.getGenericInterfaces())</span><br><span class="line">            System.out.println(t);</span><br><span class="line">        System.out.println(</span><br><span class="line">                <span class="string">"Base: "</span> + enumClass.getSuperclass());</span><br><span class="line">        System.out.println(<span class="string">"Methods: "</span>);</span><br><span class="line">        Set&lt;String&gt; methods = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Method m : enumClass.getMethods())</span><br><span class="line">            methods.add(m.getName());</span><br><span class="line">        System.out.println(methods);</span><br><span class="line">        <span class="keyword">return</span> methods;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; exploreMethods =</span><br><span class="line">                analyze(Explore.class);</span><br><span class="line">        Set&lt;String&gt; enumMethods = analyze(Enum.class);</span><br><span class="line">        System.out.println(</span><br><span class="line">                <span class="string">"Explore.containsAll(Enum)? "</span> +</span><br><span class="line">                        exploreMethods.containsAll(enumMethods));</span><br><span class="line">        System.out.print(<span class="string">"Explore.removeAll(Enum): "</span>);</span><br><span class="line">        exploreMethods.removeAll(enumMethods);</span><br><span class="line">        System.out.println(exploreMethods);</span><br><span class="line"><span class="comment">// Decompile the code for the enum:</span></span><br><span class="line">        OSExecute.command(</span><br><span class="line">                <span class="string">"javap -cp build/classes/main Explore"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">_____ Analyzing <span class="class"><span class="keyword">class</span> <span class="title">Explore</span> <span class="title">_____</span></span></span><br><span class="line">Interfaces:</span><br><span class="line">Base: <span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Enum</span></span></span><br><span class="line">Methods:</span><br><span class="line">[compareTo, equals, getClass, getDeclaringClass,</span><br><span class="line">hashCode, name, notify, notifyAll, ordinal, toString,</span><br><span class="line">valueOf, values, wait]</span><br><span class="line">_____ Analyzing <span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Enum</span> <span class="title">_____</span></span></span><br><span class="line">Interfaces:</span><br><span class="line">java.lang.Comparable&lt;E&gt;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line">Base: class java.lang.Object</span><br><span class="line">Methods:</span><br><span class="line">[compareTo, equals, getClass, getDeclaringClass,</span><br><span class="line">hashCode, name, notify, notifyAll, ordinal, toString,</span><br><span class="line">valueOf, wait]</span><br><span class="line">Explore.containsAll(Enum)? <span class="keyword">true</span></span><br><span class="line">Explore.removeAll(Enum): [values]</span><br><span class="line">Compiled from <span class="string">"Reflection.java"</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Explore</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Enum</span>&lt;<span class="title">Explore</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Explore HERE;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Explore THERE;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Explore[] values();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Explore <span class="title">valueOf</span><span class="params">(java.lang.String)</span></span>;</span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是，values() 是由编译器添加的 static 方法。可以看出，在创建 Explore 的过程中，编译器还为其添加了 valueOf() 方法。这可能有点令人迷惑，Enum 类不是已经有 valueOf() 方法了吗。</p><p>不过 Enum 中的 valueOf() 方法需要两个参数，而这个新增的方法只需一个参数。由于这里使用的 Set 只存储方法的名字，而不考虑方法的签名，所以在调用 Explore.removeAll(Enum) 之后，就只剩下[values] 了。</p><p>从最后的输出中可以看到，编译器将 Explore 标记为 final 类，所以无法继承自 enum，其中还有一个 static 的初始化子句，稍后我们将学习如何重定义该句。</p><p>由于擦除效应（在<a href>泛型 </a> 章节中介绍过），反编译无法得到 Enum 的完整信息，所以它展示的 Explore 的父类只是一个原始的 Enum，而非事实上的 Enum&lt;Explore&gt;。</p><p>由于 values() 方法是由编译器插入到 enum 定义中的 static 方法，所以，如果你将 enum 实例向上转型为 Enum，那么 values() 方法就不可访问了。不过，在 Class 中有一个 getEnumConstants0 方法，所以即便 Enum 接口中没有 values0 方法，我们仍然可以通过 Class 对象取得所有 enum 实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enums/UpcastEnum.java</span></span><br><span class="line"><span class="comment">// No values() method if you upcast an enum</span></span><br><span class="line"><span class="keyword">enum</span> Search &#123; HITHER, YON &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UpcastEnum</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Search[] vals = Search.values();</span><br><span class="line">        Enum e = Search.HITHER; <span class="comment">// Upcast</span></span><br><span class="line"><span class="comment">// e.values(); // No values() in Enum</span></span><br><span class="line">        <span class="keyword">for</span>(Enum en : e.getClass().getEnumConstants())</span><br><span class="line">            System.out.println(en);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HITHER</span><br><span class="line">YON</span><br></pre></td></tr></table></figure><p>因为 getEnumConstants() 是 Class 上的方法，所以你甚至可以对不是枚举的类调用此方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enums/NonEnum.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonEnum</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class&lt;Integer&gt; intClass = Integer.class;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(Object en : intClass.getEnumConstants())</span><br><span class="line">                System.out.println(en);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Expected: "</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expected: java.lang.NullPointerException</span><br></pre></td></tr></table></figure><p>只不过，此时该方法返回 null，所以当你试图使用其返回的结果时会发生异常。</p><!-- Implements, not Inherits --><h2 id="实现而非继承"><a href="#实现而非继承" class="headerlink" title="实现而非继承"></a>实现而非继承</h2><p>我们已经知道，所有的 enum 都继承自 Java.lang.Enum 类。由于 Java 不支持多重继承，所以你的 enum 不能再继承其他类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> NotPossible extends Pet &#123; ... <span class="comment">// Won't work</span></span><br></pre></td></tr></table></figure><p>然而，在我们创建一个新的 enum 时，可以同时实现一个或多个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enums/cartoons/EnumImplementation.java</span></span><br><span class="line"><span class="comment">// An enum can implement an interface</span></span><br><span class="line"><span class="comment">// &#123;java enums.cartoons.EnumImplementation&#125;</span></span><br><span class="line"><span class="keyword">package</span> enums.cartoons;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">enum</span> CartoonCharacter</span><br><span class="line">        implements Supplier&lt;CartoonCharacter&gt; &#123;</span><br><span class="line">    SLAPPY, SPANKY, PUNCHY,</span><br><span class="line">    SILLY, BOUNCY, NUTTY, BOB;</span><br><span class="line">    <span class="keyword">private</span> Random rand =</span><br><span class="line">            <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CartoonCharacter <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> values()[rand.nextInt(values().length)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumImplementation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">printNext</span><span class="params">(Supplier&lt;T&gt; rg)</span> </span>&#123;</span><br><span class="line">        System.out.print(rg.get() + <span class="string">", "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Choose any instance:</span></span><br><span class="line">        CartoonCharacter cc = CartoonCharacter.BOB;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">            printNext(cc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BOB, PUNCHY, BOB, SPANKY, NUTTY, PUNCHY, SLAPPY, NUTTY,</span><br><span class="line">NUTTY, SLAPPY,</span><br></pre></td></tr></table></figure><p>这个结果有点奇怪，不过你必须要有一个 enum 实例才能调用其上的方法。现在，在任何接受 Supplier 参数的方法中，例如 printNext()，都可以使用 CartoonCharacter。</p><!-- Random Selection --><h2 id="随机选择"><a href="#随机选择" class="headerlink" title="随机选择"></a>随机选择</h2><p>就像你在 CartoonCharacter.get() 中看到的那样，本章中的很多示例都需要从 enum 实例中进行随机选择。我们可以利用泛型，从而使得这个工作更一般化，并将其加入到我们的工具库中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/Enums.java</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Enums</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Enum&lt;T&gt;&gt; <span class="function">T <span class="title">random</span><span class="params">(Class&lt;T&gt; ec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> random(ec.getEnumConstants());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">random</span><span class="params">(T[] values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> values[rand.nextInt(values.length)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>古怪的语法&lt;T extends Enum&lt;T&gt;&gt; 表示 T 是一个 enum 实例。而将 Class&lt;T&gt; 作为参数的话，我们就可以利用 Class 对象得到 enum 实例的数组了。重载后的 random() 方法只需使用 T[] 作为参数，因为它并不会调用 Enum 上的任何操作，它只需从数组中随机选择一个元素即可。这样，最终的返回类型正是 enum 的类型。</p><p>下面是 random() 方法的一个简单示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enums/RandomTest.java</span></span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">enum</span> Activity &#123; SITTING, LYING, STANDING, HOPPING,</span><br><span class="line">    RUNNING, DODGING, JUMPING, FALLING, FLYING &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">            System.out.print(</span><br><span class="line">                    Enums.random(Activity.class) + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">STANDING FLYING RUNNING STANDING RUNNING STANDING LYING</span><br><span class="line">DODGING SITTING RUNNING HOPPING HOPPING HOPPING RUNNING</span><br><span class="line">STANDING LYING FALLING RUNNING FLYING LYING</span><br></pre></td></tr></table></figure><!-- Using Interfaces for Organization --><h2 id="使用接口组织枚举"><a href="#使用接口组织枚举" class="headerlink" title="使用接口组织枚举"></a>使用接口组织枚举</h2><p>无法从 enum 继承子类有时很令人沮丧。这种需求有时源自我们希望扩展原 enum 中的元素，有时是因为我们希望使用子类将一个 enum 中的元素进行分组。</p><p>在一个接口的内部，创建实现该接口的枚举，以此将元素进行分组，可以达到将枚举元素分类组织的目的。举例来说，假设你想用 enum 来表示不同类别的食物，同时还希望每个 enum 元素仍然保持 Food 类型。那可以这样实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enums/menu/Food.java</span></span><br><span class="line"><span class="comment">// Subcategorization of enums within interfaces</span></span><br><span class="line"><span class="keyword">package</span> enums.menu;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> Appetizer implements Food &#123;</span><br><span class="line">        SALAD, SOUP, SPRING_ROLLS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">enum</span> MainCourse implements Food &#123;</span><br><span class="line">        LASAGNE, BURRITO, PAD_THAI,</span><br><span class="line">        LENTILS, HUMMOUS, VINDALOO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">enum</span> Dessert implements Food &#123;</span><br><span class="line">        TIRAMISU, GELATO, BLACK_FOREST_CAKE,</span><br><span class="line">        FRUIT, CREME_CARAMEL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">enum</span> Coffee implements Food &#123;</span><br><span class="line">        BLACK_COFFEE, DECAF_COFFEE, ESPRESSO,</span><br><span class="line">        LATTE, CAPPUCCINO, TEA, HERB_TEA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 enum 而言，实现接口是使其子类化的唯一办法，所以嵌入在 Food 中的每个 enum 都实现了 Food 接口。现在，在下面的程序中，我们可以说“所有东西都是某种类型的 Food”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enums/menu/TypeOfFood.java</span></span><br><span class="line"><span class="comment">// &#123;java enums.menu.TypeOfFood&#125;</span></span><br><span class="line"><span class="keyword">package</span> enums.menu;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> enums.menu.Food.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeOfFood</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Food food = Appetizer.SALAD;</span><br><span class="line">        food = MainCourse.LASAGNE;</span><br><span class="line">        food = Dessert.GELATO;</span><br><span class="line">        food = Coffee.CAPPUCCINO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 enum 类型实现了 Food 接口，那么我们就可以将其实例向上转型为 Food，所以上例中的所有东西都是 Food。</p><p>然而，当你需要与一大堆类型打交道时，接口就不如 enum 好用了。例如，如果你想创建一个“校举的枚举”，那么可以创建一个新的 enum，然后用其实例包装 Food 中的每一个 enum 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enums/menu/Course.java</span></span><br><span class="line"><span class="keyword">package</span> enums.menu;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Course &#123;</span><br><span class="line">    APPETIZER(Food.Appetizer.class),</span><br><span class="line">    MAINCOURSE(Food.MainCourse.class),</span><br><span class="line">    DESSERT(Food.Dessert.class),</span><br><span class="line">    COFFEE(Food.Coffee.class);</span><br><span class="line">    <span class="keyword">private</span> Food[] values;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Course</span><span class="params">(Class&lt;? extends Food&gt; kind)</span> </span>&#123;</span><br><span class="line">        values = kind.getEnumConstants();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">randomSelection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Enums.random(values);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个 Course 的实例都将其对应的 Class 对象作为构造器的参数。通过 getEnumConstants0 方法，可以从该 Class 对象中取得某个 Food 子类的所有 enum 实例。这些实例在 randomSelection() 中被用到。因此，通过从每一个 Course 实例中随机地选择一个 Food，我们便能够生成一份菜单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enums/menu/Meal.java</span></span><br><span class="line"><span class="comment">// &#123;java enums.menu.Meal&#125;</span></span><br><span class="line"><span class="keyword">package</span> enums.menu;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Meal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(Course course : Course.values()) &#123;</span><br><span class="line">                Food food = course.randomSelection();</span><br><span class="line">                System.out.println(food);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"***"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">SPRING_ROLLS</span><br><span class="line">VINDALOO</span><br><span class="line">FRUIT</span><br><span class="line">DECAF_COFFEE</span><br><span class="line">***</span><br><span class="line">SOUP</span><br><span class="line">VINDALOO</span><br><span class="line">FRUIT</span><br><span class="line">TEA</span><br><span class="line">***</span><br><span class="line">SALAD</span><br><span class="line">BURRITO</span><br><span class="line">FRUIT</span><br><span class="line">TEA</span><br><span class="line">***</span><br><span class="line">SALAD</span><br><span class="line">BURRITO</span><br><span class="line">CREME_CARAMEL</span><br><span class="line">LATTE</span><br><span class="line">***</span><br><span class="line">SOUP</span><br><span class="line">BURRITO</span><br><span class="line">TIRAMISU</span><br><span class="line">ESPRESSO</span><br><span class="line">***</span><br></pre></td></tr></table></figure><p>在这个例子中，我们通过遍历每一个 Course 实例来获得“枚举的枚举”的值。稍后，在 VendingMachine.java 中，我们会看到另一种组织枚举实例的方式，但其也有一些其他的限制。</p><p>此外，还有一种更简洁的管理枚举的办法，就是将一个 enum 嵌套在另一个 enum 内。就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enums/SecurityCategory.java</span></span><br><span class="line"><span class="comment">// More succinct subcategorization of enums</span></span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">enum</span> SecurityCategory &#123;</span><br><span class="line">    STOCK(Security.Stock.class),</span><br><span class="line">    BOND(Security.Bond.class);</span><br><span class="line">    Security[] values;</span><br><span class="line">    SecurityCategory(Class&lt;? extends Security&gt; kind) &#123;</span><br><span class="line">        values = kind.getEnumConstants();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Security</span> </span>&#123;</span><br><span class="line">        <span class="keyword">enum</span> Stock implements Security &#123;</span><br><span class="line">            SHORT, LONG, MARGIN</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">enum</span> Bond implements Security &#123;</span><br><span class="line">            MUNICIPAL, JUNK</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Security <span class="title">randomSelection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Enums.random(values);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            SecurityCategory category =</span><br><span class="line">                    Enums.random(SecurityCategory.class);</span><br><span class="line">            System.out.println(category + <span class="string">": "</span> +</span><br><span class="line">                    category.randomSelection());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BOND: MUNICIPAL</span><br><span class="line">BOND: MUNICIPAL</span><br><span class="line">STOCK: MARGIN</span><br><span class="line">STOCK: MARGIN</span><br><span class="line">BOND: JUNK</span><br><span class="line">STOCK: SHORT</span><br><span class="line">STOCK: LONG</span><br><span class="line">STOCK: LONG</span><br><span class="line">BOND: MUNICIPAL</span><br><span class="line">BOND: JUNK</span><br></pre></td></tr></table></figure><p>Security 接口的作用是将其所包含的 enum 组合成一个公共类型，这一点是有必要的。然后，SecurityCategory 才能将 Security 中的 enum 作为其构造器的参数使用，以起到组织的效果。</p><p>如果我们将这种方式应用于 Food 的例子，结果应该这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enums/menu/Meal2.java</span></span><br><span class="line"><span class="comment">// &#123;java enums.menu.Meal2&#125;</span></span><br><span class="line"><span class="keyword">package</span> enums.menu;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Meal2 &#123;</span><br><span class="line">    APPETIZER(Food.Appetizer.class),</span><br><span class="line">    MAINCOURSE(Food.MainCourse.class),</span><br><span class="line">    DESSERT(Food.Dessert.class),</span><br><span class="line">    COFFEE(Food.Coffee.class);</span><br><span class="line">    <span class="keyword">private</span> Food[] values;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Meal2</span><span class="params">(Class&lt;? extends Food&gt; kind)</span> </span>&#123;</span><br><span class="line">        values = kind.getEnumConstants();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">        <span class="keyword">enum</span> Appetizer implements Food &#123;</span><br><span class="line">            SALAD, SOUP, SPRING_ROLLS;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">enum</span> MainCourse implements Food &#123;</span><br><span class="line">            LASAGNE, BURRITO, PAD_THAI,</span><br><span class="line">            LENTILS, HUMMOUS, VINDALOO;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">enum</span> Dessert implements Food &#123;</span><br><span class="line">            TIRAMISU, GELATO, BLACK_FOREST_CAKE,</span><br><span class="line">            FRUIT, CREME_CARAMEL;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">enum</span> Coffee implements Food &#123;</span><br><span class="line">            BLACK_COFFEE, DECAF_COFFEE, ESPRESSO,</span><br><span class="line">            LATTE, CAPPUCCINO, TEA, HERB_TEA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">randomSelection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Enums.random(values);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(Meal2 meal : Meal2.values()) &#123;</span><br><span class="line">                Food food = meal.randomSelection();</span><br><span class="line">                System.out.println(food);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"***"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">SPRING_ROLLS</span><br><span class="line">VINDALOO</span><br><span class="line">FRUIT</span><br><span class="line">DECAF_COFFEE</span><br><span class="line">***</span><br><span class="line">SOUP</span><br><span class="line">VINDALOO</span><br><span class="line">FRUIT</span><br><span class="line">TEA</span><br><span class="line">***</span><br><span class="line">SALAD</span><br><span class="line">BURRITO</span><br><span class="line">FRUIT</span><br><span class="line">TEA</span><br><span class="line">***</span><br><span class="line">SALAD</span><br><span class="line">BURRITO</span><br><span class="line">CREME_CARAMEL</span><br><span class="line">LATTE</span><br><span class="line">***</span><br><span class="line">SOUP</span><br><span class="line">BURRITO</span><br><span class="line">TIRAMISU</span><br><span class="line">ESPRESSO</span><br><span class="line">***</span><br></pre></td></tr></table></figure><p>其实，这仅仅是重新组织了一下代码，不过多数情况下，这种方式使你的代码具有更清晰的结构。</p><!-- Using EnumSet Instead of Flags --><h2 id="使用-EnumSet-替代-Flags"><a href="#使用-EnumSet-替代-Flags" class="headerlink" title="使用 EnumSet 替代 Flags"></a>使用 EnumSet 替代 Flags</h2><p>Set 是一种集合，只能向其中添加不重复的对象。当然，enum 也要求其成员都是唯一的，所以 enumi 看起来也具有集合的行为。不过，由于不能从 enum 中删除或添加元素，所以它只能算是不太有用的集合。Java SE5 引入 EnumSet，是为了通过 enum 创建一种替代品，以替代传统的基于 int 的“位标志”。这种标志可以用来表示某种“开/关”信息，不过，使用这种标志，我们最终操作的只是一些 bit，而不是这些 bit 想要表达的概念，因此很容易写出令人难以理解的代码。</p><p>EnumSet 的设计充分考虑到了速度因素，因为它必须与非常高效的 bit 标志相竞争（其操作与 HashSet 相比，非常地快），就其内部而言，它（可能）就是将一个 long 值作为比特向量，所以 EnumSet 非常快速高效。使用 EnumSet 的优点是，它在说明一个二进制位是否存在时，具有更好的表达能力，并且无需担心性能。</p><p>EnumSet 中的元素必须来自一个 enum。下面的 enum 表示在一座大楼中，警报传感器的安放位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enums/AlarmPoints.java</span></span><br><span class="line"><span class="keyword">package</span> enums;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> AlarmPoints &#123;</span><br><span class="line">    STAIR1, STAIR2, LOBBY, OFFICE1, OFFICE2, OFFICE3,</span><br><span class="line">    OFFICE4, BATHROOM, UTILITY, KITCHEN</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们用 EnumSet 来跟踪报警器的状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enums/EnumSets.java</span></span><br><span class="line"><span class="comment">// Operations on EnumSets</span></span><br><span class="line"><span class="comment">// &#123;java enums.EnumSets&#125;</span></span><br><span class="line"><span class="keyword">package</span> enums;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> enums.AlarmPoints.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSets</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EnumSet&lt;AlarmPoints&gt; points =</span><br><span class="line">                EnumSet.noneOf(AlarmPoints.class); <span class="comment">// Empty</span></span><br><span class="line">        points.add(BATHROOM);</span><br><span class="line">        System.out.println(points);</span><br><span class="line">        points.addAll(</span><br><span class="line">                EnumSet.of(STAIR1, STAIR2, KITCHEN));</span><br><span class="line">        System.out.println(points);</span><br><span class="line">        points = EnumSet.allOf(AlarmPoints.class);</span><br><span class="line">        points.removeAll(</span><br><span class="line">                EnumSet.of(STAIR1, STAIR2, KITCHEN));</span><br><span class="line">        System.out.println(points);</span><br><span class="line">        points.removeAll(</span><br><span class="line">                EnumSet.range(OFFICE1, OFFICE4));</span><br><span class="line">        System.out.println(points);</span><br><span class="line">        points = EnumSet.complementOf(points);</span><br><span class="line">        System.out.println(points);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[BATHROOM]</span><br><span class="line">[STAIR1, STAIR2, BATHROOM, KITCHEN]</span><br><span class="line">[LOBBY, OFFICE1, OFFICE2, OFFICE3, OFFICE4, BATHROOM,</span><br><span class="line">UTILITY]</span><br><span class="line">[LOBBY, BATHROOM, UTILITY]</span><br><span class="line">[STAIR1, STAIR2, OFFICE1, OFFICE2, OFFICE3, OFFICE4,</span><br><span class="line">KITCHEN]</span><br></pre></td></tr></table></figure><p>使用 static import 可以简化 enum 常量的使用。EnumSet 的方法的名字都相当直观，你可以查阅 JDK 文档找到其完整详细的描述。如果仔细研究了 EnumSet 的文档，你还会发现 of() 方法被重载了很多次，不但为可变数量参数进行了重载，而且为接收 2 至 5 个显式的参数的情况都进行了重载。这也从侧面表现了 EnumSet 对性能的关注。因为，其实只使用单独的 of() 方法解决可变参数已经可以解决整个问题了，但是对比显式的参数，会有一点性能损失。采用现在这种设计，当你只使用 2 到 5 个参数调用 of() 方法时，你可以调用对应的重载过的方法（速度稍快一点），而当你使用一个参数或多过 5 个参数时，你调用的将是使用可变参数的 of() 方法。注意，如果你只使用一个参数，编译器并不会构造可变参数的数组，所以与调用只有一个参数的方法相比，也就不会有额外的性能损耗。</p><p>EnumSet 的基础是 long，一个 long 值有 64 位，而一个 enum 实例只需一位 bit 表示其是否存在。<br>也就是说，在不超过一个 long 的表达能力的情况下，你的 EnumSet 可以应用于最多不超过 64 个元素的 enum。如果 enum 超过了 64 个元素会发生什么呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enums/BigEnumSet.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigEnumSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> Big &#123; A0, A1, A2, A3, A4, A5, A6, A7, A8, A9,</span><br><span class="line">        A10, A11, A12, A13, A14, A15, A16, A17, A18, A19,</span><br><span class="line">        A20, A21, A22, A23, A24, A25, A26, A27, A28, A29,</span><br><span class="line">        A30, A31, A32, A33, A34, A35, A36, A37, A38, A39,</span><br><span class="line">        A40, A41, A42, A43, A44, A45, A46, A47, A48, A49,</span><br><span class="line">        A50, A51, A52, A53, A54, A55, A56, A57, A58, A59,</span><br><span class="line">        A60, A61, A62, A63, A64, A65, A66, A67, A68, A69,</span><br><span class="line">        A70, A71, A72, A73, A74, A75 &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EnumSet&lt;Big&gt; bigEnumSet = EnumSet.allOf(Big.class);</span><br><span class="line">        System.out.println(bigEnumSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12,</span><br><span class="line">A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23,</span><br><span class="line">A24, A25, A26, A27, A28, A29, A30, A31, A32, A33, A34,</span><br><span class="line">A35, A36, A37, A38, A39, A40, A41, A42, A43, A44, A45,</span><br><span class="line">A46, A47, A48, A49, A50, A51, A52, A53, A54, A55, A56,</span><br><span class="line">A57, A58, A59, A60, A61, A62, A63, A64, A65, A66, A67,</span><br><span class="line">A68, A69, A70, A71, A72, A73, A74, A75]</span><br></pre></td></tr></table></figure><p>显然，EnumSet 可以应用于多过 64 个元素的 enum，所以我猜测，Enum 会在必要的时候增加一个 long。</p><!-- Using EnumMap --><h2 id="使用-EnumMap"><a href="#使用-EnumMap" class="headerlink" title="使用 EnumMap"></a>使用 EnumMap</h2><p>EnumMap 是一种特殊的 Map，它要求其中的键（key）必须来自一个 enum，由于 enum 本身的限制，所以 EnumMap 在内部可由数组实现。因此 EnumMap 的速度很快，我们可以放心地使用 enum 实例在 EnumMap 中进行查找操作。不过，我们只能将 enum 的实例作为键来调用 put() 可方法，其他操作与使用一般的 Map 差不多。</p><p>下面的例子演示了<em>命令设计模式</em>的用法。一般来说，命令模式首先需要一个只有单一方法的接口，然后从该接口实现具有各自不同的行为的多个子类。接下来，程序员就可以构造命令对象，并在需要的时候使用它们了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enums/EnumMaps.java</span></span><br><span class="line"><span class="comment">// Basics of EnumMaps</span></span><br><span class="line"><span class="comment">// &#123;java enums.EnumMaps&#125;</span></span><br><span class="line"><span class="keyword">package</span> enums;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> enums.AlarmPoints.*;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumMaps</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EnumMap&lt;AlarmPoints,Command&gt; em =</span><br><span class="line">                <span class="keyword">new</span> EnumMap&lt;&gt;(AlarmPoints.class);</span><br><span class="line">        em.put(KITCHEN,</span><br><span class="line">                () -&gt; System.out.println(<span class="string">"Kitchen fire!"</span>));</span><br><span class="line">        em.put(BATHROOM,</span><br><span class="line">                () -&gt; System.out.println(<span class="string">"Bathroom alert!"</span>));</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;AlarmPoints,Command&gt; e:</span><br><span class="line">                em.entrySet()) &#123;</span><br><span class="line">            System.out.print(e.getKey() + <span class="string">": "</span>);</span><br><span class="line">            e.getValue().action();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123; <span class="comment">// If there's no value for a particular key:</span></span><br><span class="line">            em.get(UTILITY).action();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Expected: "</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BATHROOM: Bathroom alert!</span><br><span class="line">KITCHEN: Kitchen fire!</span><br><span class="line">Expected: java.lang.NullPointerException</span><br></pre></td></tr></table></figure><p>与 EnumSet 一样，enum 实例定义时的次序决定了其在 EnumMap 中的顺序。</p><p>main() 方法的最后部分说明，enum 的每个实例作为一个键，总是存在的。但是，如果你没有为这个键调用 put() 方法来存入相应的值的话，其对应的值就是 null。</p><p>与常量相关的方法（constant-specific methods 将在下一节中介绍）相比，EnumMap 有一个优点，那 EnumMap 允许程序员改变值对象，而常量相关的方法在编译期就被固定了。稍后你会看到，在你有多种类型的 enum，而且它们之间存在互操作的情况下，我们可以用 EnumMap 实现多路分发（multiple dispatching）。</p><!-- Constant-Specific Methods --><h2 id="常量特定方法"><a href="#常量特定方法" class="headerlink" title="常量特定方法"></a>常量特定方法</h2><p>Java 的 enum 有一个非常有趣的特性，即它允许程序员为 enum 实例编写方法，从而为每个 enum 实例赋予各自不同的行为。要实现常量相关的方法，你需要为 enum 定义一个或多个 abstract 方法，然后为每个 enum 实例实现该抽象方法。参考下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enums/ConstantSpecificMethod.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.text.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ConstantSpecificMethod &#123;</span><br><span class="line">    DATE_TIME &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function">String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">                    DateFormat.getDateInstance()</span><br><span class="line">                            .format(<span class="keyword">new</span> Date());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    CLASSPATH &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function">String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> System.getenv(<span class="string">"CLASSPATH"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    VERSION &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function">String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> System.getProperty(<span class="string">"java.version"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> String <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(ConstantSpecificMethod csm : values())</span><br><span class="line">            System.out.println(csm.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">May <span class="number">9</span>, <span class="number">2017</span></span><br><span class="line">C:\Users\Bruce\Documents\GitHub\on-</span><br><span class="line">java\ExtractedExamples\\gradle\wrapper\gradle-</span><br><span class="line">wrapper.jar</span><br><span class="line"><span class="number">1.8</span>.0_112</span><br></pre></td></tr></table></figure><p>通过相应的 enum 实例，我们可以调用其上的方法。这通常也称为表驱动的代码（table-driven code，请注意它与前面提到的命令模式的相似之处）。</p><p>在面向对象的程序设计中，不同的行为与不同的类关联。而通过常量相关的方法，每个 enum 实例可以具备自己独特的行为，这似乎说明每个 enum 实例就像一个独特的类。在上面的例子中，enum 实例似乎被当作其“超类”ConstantSpecificMethod 来使用，在调用 getInfo() 方法时，体现出多态的行为。</p><p>然而，enum 实例与类的相似之处也仅限于此了。我们并不能真的将 enum 实例作为一个类型来使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enums/NotClasses.java</span></span><br><span class="line"><span class="comment">// &#123;javap -c LikeClasses&#125;</span></span><br><span class="line"><span class="keyword">enum</span> LikeClasses &#123;</span><br><span class="line">    WINKEN &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">behavior</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Behavior1"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    BLINKEN &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">behavior</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Behavior2"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    NOD &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">behavior</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Behavior3"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">behavior</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotClasses</span> </span>&#123;</span><br><span class="line">    <span class="comment">// void f1(LikeClasses.WINKEN instance) &#123;&#125; // Nope</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为（前 12 行）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Compiled from &quot;NotClasses.java&quot;</span><br><span class="line">abstract class LikeClasses extends</span><br><span class="line">java.lang.Enum&lt;LikeClasses&gt; &#123;</span><br><span class="line">public static final LikeClasses WINKEN;</span><br><span class="line">public static final LikeClasses BLINKEN;</span><br><span class="line">public static final LikeClasses NOD;</span><br><span class="line">public static LikeClasses[] values();</span><br><span class="line">Code:</span><br><span class="line">0: getstatic #2 // Field</span><br><span class="line">$VALUES:[LLikeClasses;</span><br><span class="line">3: invokevirtual #3 // Method</span><br><span class="line">&quot;[LLikeClasses;&quot;.clone:()Ljava/lang/Object;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在方法 f1() 中，编译器不允许我们将一个 enum 实例当作 class 类型。如果我们分析一下编译器生成的代码，就知道这种行为也是很正常的。因为每个 enum 元素都是一个 LikeClasses 类型的 static final 实例。</p><p>同时，由于它们是 static 实例，无法访问外部类的非 static 元素或方法，所以对于内部的 enum 的实例而言，其行为与一般的内部类并不相同。</p><p>再看一个更有趣的关于洗车的例子。每个顾客在洗车时，都有一个选择菜单，每个选择对应一个不同的动作。可以将一个常量相关的方法关联到一个选择上，再使用一个 EnumSet 来保存客户的选择：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enums/CarWash.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarWash</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Cycle &#123;</span><br><span class="line">        UNDERBODY &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Spraying the underbody"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        WHEELWASH &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Washing the wheels"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        PREWASH &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Loosening the dirt"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        BASIC &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"The basic wash"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        HOTWAX &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Applying hot wax"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        RINSE &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Rinsing"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        BLOWDRY &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Blowing dry"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    EnumSet&lt;Cycle&gt; cycles =</span><br><span class="line">            EnumSet.of(Cycle.BASIC, Cycle.RINSE);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Cycle cycle)</span> </span>&#123;</span><br><span class="line">        cycles.add(cycle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">washCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Cycle c : cycles)</span><br><span class="line">            c.action();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cycles.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CarWash wash = <span class="keyword">new</span> CarWash();</span><br><span class="line">        System.out.println(wash);</span><br><span class="line">        wash.washCar();</span><br><span class="line"><span class="comment">// Order of addition is unimportant:</span></span><br><span class="line">        wash.add(Cycle.BLOWDRY);</span><br><span class="line">        wash.add(Cycle.BLOWDRY); <span class="comment">// Duplicates ignored</span></span><br><span class="line">        wash.add(Cycle.RINSE);</span><br><span class="line">        wash.add(Cycle.HOTWAX);</span><br><span class="line">        System.out.println(wash);</span><br><span class="line">        wash.washCar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[BASIC, RINSE]</span><br><span class="line">The basic wash</span><br><span class="line">Rinsing</span><br><span class="line">[BASIC, HOTWAX, RINSE, BLOWDRY]</span><br><span class="line">The basic wash</span><br><span class="line">Applying hot wax</span><br><span class="line">Rinsing</span><br><span class="line">Blowing dry</span><br></pre></td></tr></table></figure><p>与使用匿名内部类相比较，定义常量相关方法的语法更高效、简洁。</p><p>这个例子也展示了 EnumSet 了一些特性。因为它是一个集合，所以对于同一个元素而言，只能出现一次，因此对同一个参数重复地调用 add0 方法会被忽略掉（这是正确的行为，因为一个 bit 位开关只能“打开”一次），同样地，向 EnumSet 添加 enum 实例的顺序并不重要，因为其输出的次序决定于 enum 实例定义时的次序。</p><p>除了实现 abstract 方法以外，程序员是否可以覆盖常量相关的方法呢？答案是肯定的，参考下面的程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enums/OverrideConstantSpecific.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> OverrideConstantSpecific &#123;</span><br><span class="line">    NUT, BOLT,</span><br><span class="line">    WASHER &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Overridden method"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"default behavior"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(OverrideConstantSpecific ocs : values()) &#123;</span><br><span class="line">            System.out.print(ocs + <span class="string">": "</span>);</span><br><span class="line">            ocs.f();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NUT: default behavior</span><br><span class="line">BOLT: default behavior</span><br><span class="line">WASHER: Overridden method</span><br></pre></td></tr></table></figure><p>虽然 enum 有某些限制，但是一般而言，我们还是可以将其看作是类。</p><h3 id="使用-enum-的职责链"><a href="#使用-enum-的职责链" class="headerlink" title="使用 enum 的职责链"></a>使用 enum 的职责链</h3><p>在职责链（Chain of Responsibility）设计模式中，程序员以多种不同的方式来解决一个问题，然后将它们链接在一起。当一个请求到来时，它遍历这个链，直到链中的某个解决方案能够处理该请求。</p><p>通过常量相关的方法，我们可以很容易地实现一个简单的职责链。我们以一个邮局的模型为例。邮局需要以尽可能通用的方式来处理每一封邮件，并且要不断尝试处理邮件，直到该邮件最终被确定为一封死信。其中的每一次尝试可以看作为一个策略（也是一个设计模式），而完整的处理方式列表就是一个职责链。</p><p>我们先来描述一下邮件。邮件的每个关键特征都可以用 enum 来表示。程序将随机地生成 Mail 对象，如果要减小一封邮件的 GeneralDelivery 为 YES 的概率，那最简单的方法就是多创建几个不是 YES 的 enum 实例，所以 enum 的定义看起来有点古怪。</p><p>我们看到 Mail 中有一个 randomMail() 方法，它负责随机地创建用于测试的邮件。而 generator() 方法生成一个 Iterable 对象，该对象在你调用 next() 方法时，在其内部使用 randomMail() 来创建 Mail 对象。这样的结构使程序员可以通过调用 Mail.generator() 方法，很容易地构造出一个 foreach 循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enums/PostOffice.java</span></span><br><span class="line"><span class="comment">// Modeling a post office</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mail</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The NO's reduce probability of random selection:</span></span><br><span class="line">    <span class="keyword">enum</span> GeneralDelivery &#123;YES,NO1,NO2,NO3,NO4,NO5&#125;</span><br><span class="line">    <span class="keyword">enum</span> Scannability &#123;UNSCANNABLE,YES1,YES2,YES3,YES4&#125;</span><br><span class="line">    <span class="keyword">enum</span> Readability &#123;ILLEGIBLE,YES1,YES2,YES3,YES4&#125;</span><br><span class="line">    <span class="keyword">enum</span> Address &#123;INCORRECT,OK1,OK2,OK3,OK4,OK5,OK6&#125;</span><br><span class="line">    <span class="keyword">enum</span> ReturnAddress &#123;MISSING,OK1,OK2,OK3,OK4,OK5&#125;</span><br><span class="line">    GeneralDelivery generalDelivery;</span><br><span class="line">    Scannability scannability;</span><br><span class="line">    Readability readability;</span><br><span class="line">    Address address;</span><br><span class="line">    ReturnAddress returnAddress;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> id = counter++;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Mail "</span> + id; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">details</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toString() +</span><br><span class="line">                <span class="string">", General Delivery: "</span> + generalDelivery +</span><br><span class="line">                <span class="string">", Address Scanability: "</span> + scannability +</span><br><span class="line">                <span class="string">", Address Readability: "</span> + readability +</span><br><span class="line">                <span class="string">", Address Address: "</span> + address +</span><br><span class="line">                <span class="string">", Return address: "</span> + returnAddress;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Generate test Mail:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Mail <span class="title">randomMail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Mail m = <span class="keyword">new</span> Mail();</span><br><span class="line">        m.generalDelivery =</span><br><span class="line">                Enums.random(GeneralDelivery.class);</span><br><span class="line">        m.scannability =</span><br><span class="line">                Enums.random(Scannability.class);</span><br><span class="line">        m.readability =</span><br><span class="line">                Enums.random(Readability.class);</span><br><span class="line">        m.address = Enums.random(Address.class);</span><br><span class="line">        m.returnAddress =</span><br><span class="line">                Enums.random(ReturnAddress.class);</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span></span><br><span class="line">    <span class="function">Iterable&lt;Mail&gt; <span class="title">generator</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterable&lt;Mail&gt;() &#123;</span><br><span class="line">            <span class="keyword">int</span> n = count;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Iterator&lt;Mail&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;Mail&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> n-- &gt; <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Mail <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> randomMail();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123; <span class="comment">// Not implemented</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PostOffice</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> MailHandler &#123;</span><br><span class="line">        GENERAL_DELIVERY &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">boolean</span> <span class="title">handle</span><span class="params">(Mail m)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">switch</span>(m.generalDelivery) &#123;</span><br><span class="line">                    <span class="keyword">case</span> YES:</span><br><span class="line">                        System.out.println(</span><br><span class="line">                                <span class="string">"Using general delivery for "</span> + m);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">default</span>: <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        MACHINE_SCAN &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">boolean</span> <span class="title">handle</span><span class="params">(Mail m)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">switch</span>(m.scannability) &#123;</span><br><span class="line">                    <span class="keyword">case</span> UNSCANNABLE: <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">switch</span>(m.address) &#123;</span><br><span class="line">                            <span class="keyword">case</span> INCORRECT: <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">default</span>:</span><br><span class="line">                                System.out.println(</span><br><span class="line">                                        <span class="string">"Delivering "</span>+ m + <span class="string">" automatically"</span>);</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        VISUAL_INSPECTION &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">boolean</span> <span class="title">handle</span><span class="params">(Mail m)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">switch</span>(m.readability) &#123;</span><br><span class="line">                    <span class="keyword">case</span> ILLEGIBLE: <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">switch</span>(m.address) &#123;</span><br><span class="line">                            <span class="keyword">case</span> INCORRECT: <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">default</span>:</span><br><span class="line">                                System.out.println(</span><br><span class="line">                                        <span class="string">"Delivering "</span> + m + <span class="string">" normally"</span>);</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        RETURN_TO_SENDER &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">boolean</span> <span class="title">handle</span><span class="params">(Mail m)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">switch</span>(m.returnAddress) &#123;</span><br><span class="line">                    <span class="keyword">case</span> MISSING: <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        System.out.println(</span><br><span class="line">                                <span class="string">"Returning "</span> + m + <span class="string">" to sender"</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">handle</span><span class="params">(Mail m)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Mail m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(MailHandler handler : MailHandler.values())</span><br><span class="line">            <span class="keyword">if</span>(handler.handle(m))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        System.out.println(m + <span class="string">" is a dead letter"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Mail mail : Mail.generator(<span class="number">10</span>)) &#123;</span><br><span class="line">            System.out.println(mail.details());</span><br><span class="line">            handle(mail);</span><br><span class="line">            System.out.println(<span class="string">"*****"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Mail 0, General Delivery: NO2, Address Scanability:</span><br><span class="line">UNSCANNABLE, Address Readability: YES3, Address</span><br><span class="line">Address: OK1, Return address: OK1</span><br><span class="line">Delivering Mail 0 normally</span><br><span class="line">*****</span><br><span class="line">Mail 1, General Delivery: NO5, Address Scanability:</span><br><span class="line">YES3, Address Readability: ILLEGIBLE, Address Address:</span><br><span class="line">OK5, Return address: OK1</span><br><span class="line">Delivering Mail 1 automatically</span><br><span class="line">*****</span><br><span class="line">Mail 2, General Delivery: YES, Address Scanability:</span><br><span class="line">YES3, Address Readability: YES1, Address Address: OK1,</span><br><span class="line">Return address: OK5</span><br><span class="line">Using general delivery for Mail 2</span><br><span class="line">*****</span><br><span class="line">Mail 3, General Delivery: NO4, Address Scanability:</span><br><span class="line">YES3, Address Readability: YES1, Address Address:</span><br><span class="line">INCORRECT, Return address: OK4</span><br><span class="line">Returning Mail 3 to sender</span><br><span class="line">*****</span><br><span class="line">Mail 4, General Delivery: NO4, Address Scanability:</span><br><span class="line">UNSCANNABLE, Address Readability: YES1, Address</span><br><span class="line">Address: INCORRECT, Return address: OK2</span><br><span class="line">Returning Mail 4 to sender</span><br><span class="line">*****</span><br><span class="line">Mail 5, General Delivery: NO3, Address Scanability:</span><br><span class="line">YES1, Address Readability: ILLEGIBLE, Address Address:</span><br><span class="line">OK4, Return address: OK2</span><br><span class="line">Delivering Mail 5 automatically</span><br><span class="line">*****</span><br><span class="line">Mail 6, General Delivery: YES, Address Scanability:</span><br><span class="line">YES4, Address Readability: ILLEGIBLE, Address Address:</span><br><span class="line">OK4, Return address: OK4</span><br><span class="line">Using general delivery for Mail 6</span><br><span class="line">*****</span><br><span class="line">Mail 7, General Delivery: YES, Address Scanability:</span><br><span class="line">YES3, Address Readability: YES4, Address Address: OK2,</span><br><span class="line">Return address: MISSING</span><br><span class="line">Using general delivery for Mail 7</span><br><span class="line">*****</span><br><span class="line">Mail 8, General Delivery: NO3, Address Scanability:</span><br><span class="line">YES1, Address Readability: YES3, Address Address:</span><br><span class="line">INCORRECT, Return address: MISSING</span><br><span class="line">Mail 8 is a dead letter</span><br><span class="line">*****</span><br><span class="line">Mail 9, General Delivery: NO1, Address Scanability:</span><br><span class="line">UNSCANNABLE, Address Readability: YES2, Address</span><br><span class="line">Address: OK1, Return address: OK4</span><br><span class="line">Delivering Mail 9 normally</span><br><span class="line">*****</span><br></pre></td></tr></table></figure><p>职责链由 enum MailHandler 实现，而 enum 定义的次序决定了各个解决策略在应用时的次序。对每一封邮件，都要按此顺序尝试每个解决策略，直到其中一个能够成功地处理该邮件，如果所有的策略都失败了，那么该邮件将被判定为一封死信。</p><h3 id="使用-enum-的状态机"><a href="#使用-enum-的状态机" class="headerlink" title="使用 enum 的状态机"></a>使用 enum 的状态机</h3><p>枚举类型非常适合用来创建状态机。一个状态机可以具有有限个特定的状态，它通常根据输入，从一个状态转移到下一个状态，不过也可能存在瞬时状态（transient states），而一旦任务执行结束，状态机就会立刻离开瞬时状态。</p><p>每个状态都具有某些可接受的输入，不同的输入会使状态机从当前状态转移到不同的新状态。由于 enum 对其实例有严格限制，非常适合用来表现不同的状态和输入。一般而言，每个状态都具有一些相关的输出。</p><p>自动售贷机是一个很好的状态机的例子。首先，我们用一个 enum 定义各种输入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enums/Input.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Input &#123;</span><br><span class="line">    NICKEL(<span class="number">5</span>), DIME(<span class="number">10</span>), QUARTER(<span class="number">25</span>), DOLLAR(<span class="number">100</span>),</span><br><span class="line">    TOOTHPASTE(<span class="number">200</span>), CHIPS(<span class="number">75</span>), SODA(<span class="number">100</span>), SOAP(<span class="number">50</span>),</span><br><span class="line">    ABORT_TRANSACTION &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">amount</span><span class="params">()</span> </span>&#123; <span class="comment">// Disallow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"ABORT.amount()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    STOP &#123; <span class="comment">// This must be the last instance.</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">amount</span><span class="params">()</span> </span>&#123; <span class="comment">// Disallow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"SHUT_DOWN.amount()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> value; <span class="comment">// In cents</span></span><br><span class="line">    Input(<span class="keyword">int</span> value) &#123; <span class="keyword">this</span>.value = value; &#125;</span><br><span class="line">    Input() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">amount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;; <span class="comment">// In cents</span></span><br><span class="line">    <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Input <span class="title">randomSelection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Don't include STOP:</span></span><br><span class="line">        <span class="keyword">return</span> values()[rand.nextInt(values().length - <span class="number">1</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，除了两个特殊的 Input 实例之外，其他的 Input 都有相应的价格，因此在接口中定义了 amount（方法。然而，对那两个特殊 Input 实例而言，调用 amount（方法并不合适，所以如果程序员调用它们的 amount）方法就会有异常抛出（在接口内定义了一个方法，然后在你调用该方法的某个实现时就会抛出异常），这似乎有点奇怪，但由于 enum 的限制，我们不得不采用这种方式。</p><p>VendingMachine 对输入的第一个反应是将其归类为 Category enum 中的某一个 enum 实例，这可以通过 switch 实现。下面的例子演示了 enum 是如何使代码变得更加清晰且易于管理的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enums/VendingMachine.java</span></span><br><span class="line"><span class="comment">// &#123;java VendingMachine VendingMachineInput.txt&#125;</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">enum</span> Category &#123;</span><br><span class="line">    MONEY(Input.NICKEL, Input.DIME,</span><br><span class="line">            Input.QUARTER, Input.DOLLAR),</span><br><span class="line">    ITEM_SELECTION(Input.TOOTHPASTE, Input.CHIPS,</span><br><span class="line">            Input.SODA, Input.SOAP),</span><br><span class="line">    QUIT_TRANSACTION(Input.ABORT_TRANSACTION),</span><br><span class="line">    SHUT_DOWN(Input.STOP);</span><br><span class="line">    <span class="keyword">private</span> Input[] values;</span><br><span class="line">    Category(Input... types) &#123; values = types; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> EnumMap&lt;Input,Category&gt; categories =</span><br><span class="line">            <span class="keyword">new</span> EnumMap&lt;&gt;(Input.class);</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(Category c : Category.class.getEnumConstants())</span><br><span class="line">            <span class="keyword">for</span>(Input type : c.values)</span><br><span class="line">                categories.put(type, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Category <span class="title">categorize</span><span class="params">(Input input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> categories.get(input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VendingMachine</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> State state = State.RESTING;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> amount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Input selection = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">enum</span> StateDuration &#123; TRANSIENT &#125; <span class="comment">// Tagging enum</span></span><br><span class="line">    <span class="keyword">enum</span> State &#123;</span><br><span class="line">        RESTING &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">(Input input)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">switch</span>(Category.categorize(input)) &#123;</span><br><span class="line">                    <span class="keyword">case</span> MONEY:</span><br><span class="line">                        amount += input.amount();</span><br><span class="line">                        state = ADDING_MONEY;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> SHUT_DOWN:</span><br><span class="line">                        state = TERMINAL;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        ADDING_MONEY &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">(Input input)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">switch</span>(Category.categorize(input)) &#123;</span><br><span class="line">                    <span class="keyword">case</span> MONEY:</span><br><span class="line">                        amount += input.amount();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> ITEM_SELECTION:</span><br><span class="line">                        selection = input;</span><br><span class="line">                        <span class="keyword">if</span>(amount &lt; selection.amount())</span><br><span class="line">                            System.out.println(</span><br><span class="line">                                    <span class="string">"Insufficient money for "</span> + selection);</span><br><span class="line">                        <span class="keyword">else</span> state = DISPENSING;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> QUIT_TRANSACTION:</span><br><span class="line">                        state = GIVING_CHANGE;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> SHUT_DOWN:</span><br><span class="line">                        state = TERMINAL;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        DISPENSING(StateDuration.TRANSIENT) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"here is your "</span> + selection);</span><br><span class="line">                amount -= selection.amount();</span><br><span class="line">                state = GIVING_CHANGE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        GIVING_CHANGE(StateDuration.TRANSIENT) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(amount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"Your change: "</span> + amount);</span><br><span class="line">                    amount = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                state = RESTING;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        TERMINAL &#123;<span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Halted"</span>); &#125; &#125;;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> isTransient = <span class="keyword">false</span>;</span><br><span class="line">        State() &#123;&#125;</span><br><span class="line">        State(StateDuration trans) &#123; isTransient = <span class="keyword">true</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">(Input input)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only call "</span> +</span><br><span class="line">                    <span class="string">"next(Input input) for non-transient states"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"Only call next() for "</span> +</span><br><span class="line">                            <span class="string">"StateDuration.TRANSIENT states"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span> </span>&#123; System.out.println(amount); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Supplier&lt;Input&gt; gen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(state != State.TERMINAL) &#123;</span><br><span class="line">            state.next(gen.get());</span><br><span class="line">            <span class="keyword">while</span>(state.isTransient)</span><br><span class="line">                state.next();</span><br><span class="line">            state.output();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Supplier&lt;Input&gt; gen = <span class="keyword">new</span> RandomInputSupplier();</span><br><span class="line">        <span class="keyword">if</span>(args.length == <span class="number">1</span>)</span><br><span class="line">            gen = <span class="keyword">new</span> FileInputSupplier(args[<span class="number">0</span>]);</span><br><span class="line">        run(gen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// For a basic sanity check:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomInputSupplier</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">Input</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Input <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Input.randomSelection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create Inputs from a file of ';'-separated strings:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileInputSupplier</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">Input</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Iterator&lt;String&gt; input;</span><br><span class="line">    FileInputSupplier(String fileName) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            input = Files.lines(Paths.get(fileName))</span><br><span class="line">                    .skip(<span class="number">1</span>) <span class="comment">// Skip the comment line</span></span><br><span class="line">                    .flatMap(s -&gt; Arrays.stream(s.split(<span class="string">";"</span>)))</span><br><span class="line">                    .map(String::trim)</span><br><span class="line">                    .collect(Collectors.toList())</span><br><span class="line">                    .iterator();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Input <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!input.hasNext())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> Enum.valueOf(Input.class, input.next().trim());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">25</span><br><span class="line">50</span><br><span class="line">75</span><br><span class="line">here is your CHIPS</span><br><span class="line">0</span><br><span class="line">100</span><br><span class="line">200</span><br><span class="line">here is your TOOTHPASTE</span><br><span class="line">0</span><br><span class="line">25</span><br><span class="line">35</span><br><span class="line">Your change: 35</span><br><span class="line">0</span><br><span class="line">25</span><br><span class="line">35</span><br><span class="line">Insufficient money for SODA</span><br><span class="line">35</span><br><span class="line">60</span><br><span class="line">70</span><br><span class="line">75</span><br><span class="line">Insufficient money for SODA</span><br><span class="line">75</span><br><span class="line">Your change: 75</span><br><span class="line">0</span><br><span class="line">Halted</span><br></pre></td></tr></table></figure><p>由于用 switch 语句从 enum 实例中进行选择是最常见的一种方式（请注意，为了使 enum 在 switch 语句中的使用变得简单，我们是需要付出其他代价的），所以，我们经常遇到这样的问题：将多个 enum 进行分类时，“我们希望在什么 enum 中使用 switch 语句？”我们通过 VendingMachine 的例子来研究一下这个问题。对于每一个 State，我们都需要在输入动作的基本分类中进行查找：用户塞入钞票，选择了某个货物，操作被取消，以及机器停止。然而，在这些基本分类之下，我们又可以塞人不同类型的钞票，可以选择不同的货物。Category enum 将不同类型的 Input 进行分组，因而，可以使用 categorize0 方法为 switch 语句生成恰当的 Cateroy 实例。并且，该方法使用的 EnumMap 确保了在其中进行查询时的效率与安全。</p><p>如果读者仔细研究 VendingMachine 类，就会发现每种状态的不同之处，以及对于输入的不同响应，其中还有两个瞬时状态。在 run() 方法中，状态机等待着下一个 Input，并一直在各个状态中移动，直到它不再处于瞬时状态。</p><p>通过两种不同的 Generator 对象，我们可以使用不同的 Supplier 对象来测试 VendingMachine，首先是 RandomInputSupplier，它会不停地生成除了 SHUT-DOWN 之外的各种输入。通过长时间地运行 RandomInputSupplier，可以起到健全测试（sanity test）的作用，能够确保该状态机不会进入一个错误状态。另一个是 FileInputSupplier，使用文件以文本的方式来描述输入，然后将它们转换成 enum 实例，并创建对应的 Input 对象。上面的程序使用的正是如下的文本文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// enums/VendingMachineInput.txt</span><br><span class="line">QUARTER; QUARTER; QUARTER; CHIPS;</span><br><span class="line">DOLLAR; DOLLAR; TOOTHPASTE;</span><br><span class="line">QUARTER; DIME; ABORT_TRANSACTION;</span><br><span class="line">QUARTER; DIME; SODA;</span><br><span class="line">QUARTER; DIME; NICKEL; SODA;</span><br><span class="line">ABORT_TRANSACTION;</span><br><span class="line">STOP;</span><br></pre></td></tr></table></figure><p>FileInputSupplier 构造函数将此文件转换为流，并跳过注释行。然后它使用 String.split() 以分号进行分割。这会生成一个 String 数组，并可以通过将其转换为 Stream，然后应用 flatMap() 来将其输入到流中。其输出结果将去除所有空格空格，并转换为 List&lt;String&gt;，且从中获取 Iterator&lt;String&gt;。</p><p>这种设计有一个缺陷，它要求 enum State 实例访问的 VendingMachine 属性必须声明为 static，这意味着，你只能有一个 VendingMachine 实例。不过如果我们思考一下实际的（嵌入式 Java）应用，这也许并不是一个大问题，因为在一台机器上，我们可能只有一个应用程序。</p><!-- Multiple Dispatching --><h2 id="多路分发"><a href="#多路分发" class="headerlink" title="多路分发"></a>多路分发</h2><p>当你要处理多种交互类型时，程序可能会变得相当杂乱。举例来说，如果一个系统要分析和执行数学表达式。我们可能会声明 Number.plus(Number)，Number.multiple(Number) 等等，其中 Number 是各种数字对象的超类。然而，当你声明 a.plus(b) 时，你并不知道 a 或 b 的确切类型，那你如何能让它们正确地交互呢？</p><p>你可能从未思考过这个问题的答案.Java 只支持单路分发。也就是说，如果要执行的操作包含了不止一个类型未知的对象时，那么 Java 的动态绑定机制只能处理其中一个的类型。这就无法解决我们上面提到的问题。所以，你必须自己来判定其他的类型，从而实现自己的动态线定行为。</p><p>解决上面问题的办法就是多路分发（在那个例子中，只有两个分发，一般称之为两路分发）.多态只能发生在方法调用时，所以，如果你想使用两路分发，那么就必须有两个方法调用：第一个方法调用决定第一个未知类型，第二个方法调用决定第二个未知的类型。要利用多路分发，程序员必须为每一个类型提供一个实际的方法调用，如果你要处理两个不同的类型体系，就需要为每个类型体系执行一个方法调用。一般而言，程序员需要有设定好的某种配置，以便一个方法调用能够引出更多的方法调用，从而能够在这个过程中处理多种类型。为了达到这种效果，我们需要与多个方法一同工作：因为每个分发都需要一个方法调用。在下面的例子中（实现了 “石头、剪刀、布”游戏，也称为 RoShamBo）对应的方法是 compete() 和 eval()，二者都是同一个类型的成员，它们可以产生三种 Outcome 实例中的一个作为结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enums/Outcome.java</span></span><br><span class="line"><span class="keyword">package</span> enums;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Outcome &#123; WIN, LOSE, DRAW &#125;</span><br><span class="line"><span class="comment">// enums/RoShamBo1.java</span></span><br><span class="line"><span class="comment">// Demonstration of multiple dispatching</span></span><br><span class="line"><span class="comment">// &#123;java enums.RoShamBo1&#125;</span></span><br><span class="line"><span class="keyword">package</span> enums;</span><br><span class="line">        <span class="keyword">import</span> java.util.*;</span><br><span class="line">        <span class="keyword">import</span> <span class="keyword">static</span> enums.Outcome.*;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">    <span class="function">Outcome <span class="title">compete</span><span class="params">(Item it)</span></span>;</span><br><span class="line">    <span class="function">Outcome <span class="title">eval</span><span class="params">(Paper p)</span></span>;</span><br><span class="line">    <span class="function">Outcome <span class="title">eval</span><span class="params">(Scissors s)</span></span>;</span><br><span class="line">    <span class="function">Outcome <span class="title">eval</span><span class="params">(Rock r)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Paper</span> <span class="keyword">implements</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">compete</span><span class="params">(Item it)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> it.eval(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Paper p)</span> </span>&#123; <span class="keyword">return</span> DRAW; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Scissors s)</span> </span>&#123; <span class="keyword">return</span> WIN; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Rock r)</span> </span>&#123; <span class="keyword">return</span> LOSE; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Paper"</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scissors</span> <span class="keyword">implements</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">compete</span><span class="params">(Item it)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> it.eval(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Paper p)</span> </span>&#123; <span class="keyword">return</span> LOSE; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Scissors s)</span> </span>&#123; <span class="keyword">return</span> DRAW; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Rock r)</span> </span>&#123; <span class="keyword">return</span> WIN; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Scissors"</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rock</span> <span class="keyword">implements</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">compete</span><span class="params">(Item it)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> it.eval(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Paper p)</span> </span>&#123; <span class="keyword">return</span> WIN; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Scissors s)</span> </span>&#123; <span class="keyword">return</span> LOSE; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Rock r)</span> </span>&#123; <span class="keyword">return</span> DRAW; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Rock"</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoShamBo1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Item <span class="title">newItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(rand.nextInt(<span class="number">3</span>)) &#123;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> <span class="keyword">new</span> Scissors();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> <span class="keyword">new</span> Paper();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> <span class="keyword">new</span> Rock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">match</span><span class="params">(Item a, Item b)</span> </span>&#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">                a + <span class="string">" vs. "</span> + b + <span class="string">": "</span> + a.compete(b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; i++)</span><br><span class="line">            match(newItem(), newItem());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Rock vs. Rock: DRAW</span><br><span class="line">Paper vs. Rock: WIN</span><br><span class="line">Paper vs. Rock: WIN</span><br><span class="line">Paper vs. Rock: WIN</span><br><span class="line">Scissors vs. Paper: WIN</span><br><span class="line">Scissors vs. Scissors: DRAW</span><br><span class="line">Scissors vs. Paper: WIN</span><br><span class="line">Rock vs. Paper: LOSE</span><br><span class="line">Paper vs. Paper: DRAW</span><br><span class="line">Rock vs. Paper: LOSE</span><br><span class="line">Paper vs. Scissors: LOSE</span><br><span class="line">Paper vs. Scissors: LOSE</span><br><span class="line">Rock vs. Scissors: WIN</span><br><span class="line">Rock vs. Paper: LOSE</span><br><span class="line">Paper vs. Rock: WIN</span><br><span class="line">Scissors vs. Paper: WIN</span><br><span class="line">Paper vs. Scissors: LOSE</span><br><span class="line">Paper vs. Scissors: LOSE</span><br><span class="line">Paper vs. Scissors: LOSE</span><br><span class="line">Paper vs. Scissors: LOSE</span><br></pre></td></tr></table></figure><p>Item 是这几种类型的接口，将会被用作多路分发。RoShamBo1.match() 有两个 Item 参数，通过调用 Item.compete90) 方法开始两路分发。要判定 a 的类型，分发机制会在 a 的实际类型的 compete（内部起到分发的作用。compete() 方法通过调用 eval() 来为另一个类型实现第二次分法。</p><p>将自身（this）作为参数调用 evalo，能够调用重载过的 eval() 方法，这能够保留第一次分发的类型信息。当第二次分发完成时，你就能够知道两个 Item 对象的具体类型了。</p><p>要配置好多路分发需要很多的工序，不过要记住，它的好处在于方法调用时的优雅的话法，这避免了在一个方法中判定多个对象的类型的丑陋代码，你只需说，“嘿，你们两个，我不在乎你们是什么类型，请你们自己交流！”不过，在使用多路分发前，请先明确，这种优雅的代码对你确实有重要的意义。</p><h3 id="使用-enum-分发"><a href="#使用-enum-分发" class="headerlink" title="使用 enum 分发"></a>使用 enum 分发</h3><p>直接将 RoShamBol.java 翻译为基于 enum 的版本是有问题的，因为 enum 实例不是类型，不能将 enum 实例作为参数的类型，所以无法重载 eval() 方法。不过，还有很多方式可以实现多路分发，并从 enum 中获益。</p><p>一种方式是使用构造器来初始化每个 enum 实例，并以“一组”结果作为参数。这二者放在一块，形成了类似查询表的结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enums/RoShamBo2.java</span></span><br><span class="line"><span class="comment">// Switching one enum on another</span></span><br><span class="line"><span class="comment">// &#123;java enums.RoShamBo2&#125;</span></span><br><span class="line"><span class="keyword">package</span> enums;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> enums.Outcome.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RoShamBo2 implements Competitor&lt;RoShamBo2&gt; &#123;</span><br><span class="line">    PAPER(DRAW, LOSE, WIN),</span><br><span class="line">    SCISSORS(WIN, DRAW, LOSE),</span><br><span class="line">    ROCK(LOSE, WIN, DRAW);</span><br><span class="line">    <span class="keyword">private</span> Outcome vPAPER, vSCISSORS, vROCK;</span><br><span class="line">    RoShamBo2(Outcome paper,</span><br><span class="line">              Outcome scissors, Outcome rock) &#123;</span><br><span class="line">        <span class="keyword">this</span>.vPAPER = paper;</span><br><span class="line">        <span class="keyword">this</span>.vSCISSORS = scissors;</span><br><span class="line">        <span class="keyword">this</span>.vROCK = rock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">compete</span><span class="params">(RoShamBo2 it)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(it) &#123;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">case</span> PAPER: <span class="keyword">return</span> vPAPER;</span><br><span class="line">            <span class="keyword">case</span> SCISSORS: <span class="keyword">return</span> vSCISSORS;</span><br><span class="line">            <span class="keyword">case</span> ROCK: <span class="keyword">return</span> vROCK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RoShamBo.play(RoShamBo2.class, <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ROCK vs. ROCK: DRAW</span><br><span class="line">SCISSORS vs. ROCK: LOSE</span><br><span class="line">SCISSORS vs. ROCK: LOSE</span><br><span class="line">SCISSORS vs. ROCK: LOSE</span><br><span class="line">PAPER vs. SCISSORS: LOSE</span><br><span class="line">PAPER vs. PAPER: DRAW</span><br><span class="line">PAPER vs. SCISSORS: LOSE</span><br><span class="line">ROCK vs. SCISSORS: WIN</span><br><span class="line">SCISSORS vs. SCISSORS: DRAW</span><br><span class="line">ROCK vs. SCISSORS: WIN</span><br><span class="line">SCISSORS vs. PAPER: WIN</span><br><span class="line">SCISSORS vs. PAPER: WIN</span><br><span class="line">ROCK vs. PAPER: LOSE</span><br><span class="line">ROCK vs. SCISSORS: WIN</span><br><span class="line">SCISSORS vs. ROCK: LOSE</span><br><span class="line">PAPER vs. SCISSORS: LOSE</span><br><span class="line">SCISSORS vs. PAPER: WIN</span><br><span class="line">SCISSORS vs. PAPER: WIN</span><br><span class="line">SCISSORS vs. PAPER: WIN</span><br><span class="line">SCISSORS vs. PAPER: WIN</span><br></pre></td></tr></table></figure><p>在 compete() 方法中，一旦两种类型都被确定了，那么唯一的操作就是返回结果 Outcome 然而，你可能还需要调用其他的方法，（例如）甚至是调用在构造器中指定的某个命令对象上的方法。</p><p>RoShamBo2.javal 之前的例子短小得多，而且更直接，更易于理解。注意，我们仍然是使用两路分发来判定两个对象的类型。在 RoShamBol.java 中，两次分发都是通过实际的方法调用实现，而在这个例子中，只有第一次分发是实际的方法调用。第二个分发使用的是 switch，不过这样做是安全的，因为 enum 限制了 switch 语句的选择分支。</p><p>在代码中，enum 被单独抽取出来，因此它可以应用在其他例子中。首先，Competitor 接口定义了一种类型，该类型的对象可以与另一个 Competitor 相竞争：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enums/Competitor.java</span></span><br><span class="line"><span class="comment">// Switching one enum on another</span></span><br><span class="line"><span class="keyword">package</span> enums;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Competitor</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Competitor</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function">Outcome <span class="title">compete</span><span class="params">(T competitor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们定义两个 static 方法（static 可以避免显式地指明参数类型），第一个是 match() 方法，它会为一个 Competitor 对象调用 compete() 方法，并与另一个 Competitor 对象作比较。在这个例子中，我们看到，match()）方法的参数需要是 Competitor&lt;T&gt; 类型。但是在 play() 方法中，类型参数必须同时是 Enum&lt;T&gt; 类型（因为它将在 Enums.random() 中使用）和 Competitor&lt;T&gt; 类型因为它将被传递给 match() 方法）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enums/RoShamBo.java</span></span><br><span class="line"><span class="comment">// Common tools for RoShamBo examples</span></span><br><span class="line"><span class="keyword">package</span> enums;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoShamBo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Competitor&lt;T&gt;&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">match</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">                a + <span class="string">" vs. "</span> + b + <span class="string">": "</span> + a.compete(b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Enum&lt;T&gt; &amp; Competitor&lt;T&gt;&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(Class&lt;T&gt; rsbClass, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            match(Enums.random(rsbClass),Enums.random(rsbClass));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>play() 方法没有将类型参数 T 作为返回值类型，因此，似乎我们应该在 Class&lt;T&gt; 中使用通配符来代替上面的参数声明。然而，通配符不能扩展多个基类，所以我们必须采用以上的表达式。</p><h3 id="使用常量相关的方法"><a href="#使用常量相关的方法" class="headerlink" title="使用常量相关的方法"></a>使用常量相关的方法</h3><p>常量相关的方法允许我们为每个 enum 实例提供方法的不同实现，这使得常量相关的方法似乎是实现多路分发的完美解决方案。不过，通过这种方式，enum 实例虽然可以具有不同的行为，但它们仍然不是类型，不能将其作为方法签名中的参数类型来使用。最好的办法是将 enum 用在 switch 语句中，见下例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enums/RoShamBo3.java</span></span><br><span class="line"><span class="comment">// Using constant-specific methods</span></span><br><span class="line"><span class="comment">// &#123;java enums.RoShamBo3&#125;</span></span><br><span class="line"><span class="keyword">package</span> enums;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> enums.Outcome.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RoShamBo3 implements Competitor&lt;RoShamBo3&gt; &#123;</span><br><span class="line">    PAPER &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Outcome <span class="title">compete</span><span class="params">(RoShamBo3 it)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span>(it) &#123;</span><br><span class="line">                <span class="keyword">default</span>: <span class="comment">// To placate the compiler</span></span><br><span class="line">                <span class="keyword">case</span> PAPER: <span class="keyword">return</span> DRAW;</span><br><span class="line">                <span class="keyword">case</span> SCISSORS: <span class="keyword">return</span> LOSE;</span><br><span class="line">                <span class="keyword">case</span> ROCK: <span class="keyword">return</span> WIN;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SCISSORS &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Outcome <span class="title">compete</span><span class="params">(RoShamBo3 it)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span>(it) &#123;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">case</span> PAPER: <span class="keyword">return</span> WIN;</span><br><span class="line">                <span class="keyword">case</span> SCISSORS: <span class="keyword">return</span> DRAW;</span><br><span class="line">                <span class="keyword">case</span> ROCK: <span class="keyword">return</span> LOSE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ROCK &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Outcome <span class="title">compete</span><span class="params">(RoShamBo3 it)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span>(it) &#123;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">case</span> PAPER: <span class="keyword">return</span> LOSE;</span><br><span class="line">                <span class="keyword">case</span> SCISSORS: <span class="keyword">return</span> WIN;</span><br><span class="line">                <span class="keyword">case</span> ROCK: <span class="keyword">return</span> DRAW;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Outcome <span class="title">compete</span><span class="params">(RoShamBo3 it)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RoShamBo.play(RoShamBo3.class, <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ROCK vs. ROCK: DRAW</span><br><span class="line">SCISSORS vs. ROCK: LOSE</span><br><span class="line">SCISSORS vs. ROCK: LOSE</span><br><span class="line">SCISSORS vs. ROCK: LOSE</span><br><span class="line">PAPER vs. SCISSORS: LOSE</span><br><span class="line">PAPER vs. PAPER: DRAW</span><br><span class="line">PAPER vs. SCISSORS: LOSE</span><br><span class="line">ROCK vs. SCISSORS: WIN</span><br><span class="line">SCISSORS vs. SCISSORS: DRAW</span><br><span class="line">ROCK vs. SCISSORS: WIN</span><br><span class="line">SCISSORS vs. PAPER: WIN</span><br><span class="line">SCISSORS vs. PAPER: WIN</span><br><span class="line">ROCK vs. PAPER: LOSE</span><br><span class="line">ROCK vs. SCISSORS: WIN</span><br><span class="line">SCISSORS vs. ROCK: LOSE</span><br><span class="line">PAPER vs. SCISSORS: LOSE</span><br><span class="line">SCISSORS vs. PAPER: WIN</span><br><span class="line">SCISSORS vs. PAPER: WIN</span><br><span class="line">SCISSORS vs. PAPER: WIN</span><br><span class="line">SCISSORS vs. PAPER: WIN</span><br></pre></td></tr></table></figure><p>虽然这种方式可以工作，但是却不甚合理，如果采用 RoShamB02.java 的解决方案，那么在添加一个新的类型时，只需更少的代码，而且也更直接。</p><p>:然而，RoShamBo3.java 还可以压缩简化一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enums/RoShamBo4.java</span></span><br><span class="line"><span class="comment">// &#123;java enums.RoShamBo4&#125;</span></span><br><span class="line"><span class="keyword">package</span> enums;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RoShamBo4 implements Competitor&lt;RoShamBo4&gt; &#123;</span><br><span class="line">    ROCK &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Outcome <span class="title">compete</span><span class="params">(RoShamBo4 opponent)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> compete(SCISSORS, opponent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SCISSORS &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Outcome <span class="title">compete</span><span class="params">(RoShamBo4 opponent)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> compete(PAPER, opponent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    PAPER &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Outcome <span class="title">compete</span><span class="params">(RoShamBo4 opponent)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> compete(ROCK, opponent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">Outcome <span class="title">compete</span><span class="params">(RoShamBo4 loser, RoShamBo4 opponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((opponent == <span class="keyword">this</span>) ? Outcome.DRAW</span><br><span class="line">                : ((opponent == loser) ? Outcome.WIN</span><br><span class="line">                : Outcome.LOSE));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RoShamBo.play(RoShamBo4.class, <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">PAPER vs. PAPER: DRAW</span><br><span class="line">SCISSORS vs. PAPER: WIN</span><br><span class="line">SCISSORS vs. PAPER: WIN</span><br><span class="line">SCISSORS vs. PAPER: WIN</span><br><span class="line">ROCK vs. SCISSORS: WIN</span><br><span class="line">ROCK vs. ROCK: DRAW</span><br><span class="line">ROCK vs. SCISSORS: WIN</span><br><span class="line">PAPER vs. SCISSORS: LOSE</span><br><span class="line">SCISSORS vs. SCISSORS: DRAW</span><br><span class="line">PAPER vs. SCISSORS: LOSE</span><br><span class="line">SCISSORS vs. ROCK: LOSE</span><br><span class="line">SCISSORS vs. ROCK: LOSE</span><br><span class="line">PAPER vs. ROCK: WIN</span><br><span class="line">PAPER vs. SCISSORS: LOSE</span><br><span class="line">SCISSORS vs. PAPER: WIN</span><br><span class="line">ROCK vs. SCISSORS: WIN</span><br><span class="line">SCISSORS vs. ROCK: LOSE</span><br><span class="line">SCISSORS vs. ROCK: LOSE</span><br><span class="line">SCISSORS vs. ROCK: LOSE</span><br><span class="line">SCISSORS vs. ROCK: LOSE</span><br></pre></td></tr></table></figure><p>其中，具有两个参数的 compete() 方法执行第二个分发，该方法执行一系列的比较，其行为类似 switch 语句。这个版本的程序更简短，不过却比较难理解，对于一个大型系统而言，难以理解的代码将导致整个系统不够健壮。</p><h3 id="使用-EnumMap-进行分发"><a href="#使用-EnumMap-进行分发" class="headerlink" title="使用 EnumMap 进行分发"></a>使用 EnumMap 进行分发</h3><p>使用 EnumMap 能够实现“真正的”两路分发。EnumMap 是为 enum 专门设计的一种性能非常好的特殊 Map。由于我们的目的是摸索出两种未知的类型，所以可以用一个 EnumMap 的 EnumMap 来实现两路分发：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enums/RoShamBo5.java</span></span><br><span class="line"><span class="comment">// Multiple dispatching using an EnumMap of EnumMaps</span></span><br><span class="line"><span class="comment">// &#123;java enums.RoShamBo5&#125;</span></span><br><span class="line"><span class="keyword">package</span> enums;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> enums.Outcome.*;</span><br><span class="line"><span class="keyword">enum</span> RoShamBo5 implements Competitor&lt;RoShamBo5&gt; &#123;</span><br><span class="line">    PAPER, SCISSORS, ROCK;</span><br><span class="line">    <span class="keyword">static</span> EnumMap&lt;RoShamBo5,EnumMap&lt;RoShamBo5,Outcome&gt;&gt;</span><br><span class="line">            table = <span class="keyword">new</span> EnumMap&lt;&gt;(RoShamBo5.class);</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(RoShamBo5 it : RoShamBo5.values())</span><br><span class="line">            table.put(it, <span class="keyword">new</span> EnumMap&lt;&gt;(RoShamBo5.class));</span><br><span class="line">        initRow(PAPER, DRAW, LOSE, WIN);</span><br><span class="line">        initRow(SCISSORS, WIN, DRAW, LOSE);</span><br><span class="line">        initRow(ROCK, LOSE, WIN, DRAW);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initRow</span><span class="params">(RoShamBo5 it,</span></span></span><br><span class="line"><span class="function"><span class="params">                        Outcome vPAPER, Outcome vSCISSORS, Outcome vROCK)</span> </span>&#123;</span><br><span class="line">        EnumMap&lt;RoShamBo5,Outcome&gt; row =</span><br><span class="line">                RoShamBo5.table.get(it);</span><br><span class="line">        row.put(RoShamBo5.PAPER, vPAPER);</span><br><span class="line">        row.put(RoShamBo5.SCISSORS, vSCISSORS);</span><br><span class="line">        row.put(RoShamBo5.ROCK, vROCK);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">compete</span><span class="params">(RoShamBo5 it)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> table.get(<span class="keyword">this</span>).get(it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RoShamBo.play(RoShamBo5.class, <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ROCK vs. ROCK: DRAW</span><br><span class="line">SCISSORS vs. ROCK: LOSE</span><br><span class="line">SCISSORS vs. ROCK: LOSE</span><br><span class="line">SCISSORS vs. ROCK: LOSE</span><br><span class="line">PAPER vs. SCISSORS: LOSE</span><br><span class="line">PAPER vs. PAPER: DRAW</span><br><span class="line">PAPER vs. SCISSORS: LOSE</span><br><span class="line">ROCK vs. SCISSORS: WIN</span><br><span class="line">SCISSORS vs. SCISSORS: DRAW</span><br><span class="line">ROCK vs. SCISSORS: WIN</span><br><span class="line">SCISSORS vs. PAPER: WIN</span><br><span class="line">SCISSORS vs. PAPER: WIN</span><br><span class="line">ROCK vs. PAPER: LOSE</span><br><span class="line">ROCK vs. SCISSORS: WIN</span><br><span class="line">SCISSORS vs. ROCK: LOSE</span><br><span class="line">PAPER vs. SCISSORS: LOSE</span><br><span class="line">SCISSORS vs. PAPER: WIN</span><br><span class="line">SCISSORS vs. PAPER: WIN</span><br><span class="line">SCISSORS vs. PAPER: WIN</span><br><span class="line">SCISSORS vs. PAPER: WIN</span><br></pre></td></tr></table></figure><p>该程序在一个 static 子句中初始化 EnumMap 对象，具体见表格似的 initRow() 方法调用。请注意 compete() 方法，您可以看到，在一行语句中发生了两次分发。</p><h3 id="使用二维数组"><a href="#使用二维数组" class="headerlink" title="使用二维数组"></a>使用二维数组</h3><p>我们还可以进一步简化实现两路分发的解决方案。我们注意到，每个 enum 实例都有一个固定的值（基于其声明的次序），并且可以通过 ordinal() 方法取得该值。因此我们可以使用二维数组，将竞争者映射到竞争结果。采用这种方式能够获得最简洁、最直接的解决方案（很可能也是最快速的，虽然我们知道 EnumMap 内部其实也是使用数组实现的）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">We can simplify the solution even more by noting that each  <span class="keyword">enum</span> instance has a fixed</span><br><span class="line">        value (based on its declaration order) <span class="function">and that  <span class="title">ordinal</span><span class="params">()</span> produces <span class="keyword">this</span> value. A two-</span></span><br><span class="line"><span class="function">        dimensional array mapping the competitors onto the outcomes produces the smallest</span></span><br><span class="line"><span class="function">        and most straightforward <span class="title">solution</span> <span class="params">(and possibly the fastest, although remember that</span></span></span><br><span class="line"><span class="function"><span class="params">        EnumMap uses an internal array)</span>:</span></span><br><span class="line"><span class="function"><span class="comment">// enums/RoShamBo6.java</span></span></span><br><span class="line"><span class="function"><span class="comment">// Enums using "tables" instead of multiple dispatch</span></span></span><br><span class="line"><span class="function"><span class="comment">// &#123;java enums.RoShamBo6&#125;</span></span></span><br><span class="line"><span class="function">        <span class="keyword">package</span> enums</span>;</span><br><span class="line">        <span class="keyword">import</span> <span class="keyword">static</span> enums.Outcome.*;</span><br><span class="line"><span class="keyword">enum</span> RoShamBo6 implements Competitor&lt;RoShamBo6&gt; &#123;</span><br><span class="line">    PAPER, SCISSORS, ROCK;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Outcome[][] table = &#123;</span><br><span class="line">            &#123; DRAW, LOSE, WIN &#125;, <span class="comment">// PAPER</span></span><br><span class="line">            &#123; WIN, DRAW, LOSE &#125;, <span class="comment">// SCISSORS</span></span><br><span class="line">            &#123; LOSE, WIN, DRAW &#125;, <span class="comment">// ROCK</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">compete</span><span class="params">(RoShamBo6 other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> table[<span class="keyword">this</span>.ordinal()][other.ordinal()];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RoShamBo.play(RoShamBo6.class, <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ROCK vs. ROCK: DRAW</span><br><span class="line">SCISSORS vs. ROCK: LOSE</span><br><span class="line">SCISSORS vs. ROCK: LOSE</span><br><span class="line">SCISSORS vs. ROCK: LOSE</span><br><span class="line">PAPER vs. SCISSORS: LOSE</span><br><span class="line">PAPER vs. PAPER: DRAW</span><br><span class="line">PAPER vs. SCISSORS: LOSE</span><br><span class="line">ROCK vs. SCISSORS: WIN</span><br><span class="line">SCISSORS vs. SCISSORS: DRAW</span><br><span class="line">ROCK vs. SCISSORS: WIN</span><br><span class="line">SCISSORS vs. PAPER: WIN</span><br><span class="line">SCISSORS vs. PAPER: WIN</span><br><span class="line">ROCK vs. PAPER: LOSE</span><br><span class="line">ROCK vs. SCISSORS: WIN</span><br><span class="line">SCISSORS vs. ROCK: LOSE</span><br><span class="line">PAPER vs. SCISSORS: LOSE</span><br><span class="line">SCISSORS vs. PAPER: WIN</span><br><span class="line">SCISSORS vs. PAPER: WIN</span><br><span class="line">SCISSORS vs. PAPER: WIN</span><br><span class="line">SCISSORS vs. PAPER: WIN</span><br></pre></td></tr></table></figure><p>table 与前一个例子中 initRow() 方法的调用次序完全相同。</p><p>与前面一个例子相比，这个程序代码虽然简短，但表达能力却更强，部分原因是其代码更易于理解与修改，而且也更直接。不过，由于它使用的是数组，所以这种方式不太“安全”。如果使用一个大型数组，可能会不小心使用了错误的尺寸，而且，如果你的测试不能覆盖所有的可能性，有些错误可能会从你眼前溜过。</p><p>事实上，以上所有的解决方案只是各种不同类型的表罢了。不过，分析各种表的表现形式，找出最适合的那一种，还是很有价值的。注意，虽然上例是最简洁的一种解决方案，但它也是相当僵硬的方案，因为它只能针对给定的常量输入产生常量输出。然而，也没有什么特别的理由阻止你用 table 来生成功能对象。对于某类问题而言，“表驱动式编码”的概念具有非常强大的功能。</p><!-- Summary --><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>虽然枚举类型本身并不是特别复杂，但我还是将本章安排在全书比较靠后的位置，这是因为，程序员可以将 enum 与 Java 语言的其他功能结合使用，例如多态、泛型和反射。</p><p>虽然 Java 中的枚举比 C 或 C++中的 enum 更成熟，但它仍然是一个“小”功能，Java 没有它也已经（虽然有点笨拙）存在很多年了。而本章正好说明了一个“小”功能所能带来的价值。有时恰恰因为它，你才能够优雅而干净地解决问题。正如我在本书中一再强调的那样，优雅与清晰很重要，正是它们区别了成功的解决方案与失败的解决方案。而失败的解决方案就是因为其他人无法理解它。</p><p>关于清晰的话题，Java 1.0 对术语 enumeration 的选择正是一个不幸的反例。对于一个专门用于从序列中选择每一个元素的对象而言，Java 竟然没有使用更通用、更普遍接受的术语 iterator 来表示它（参见<a href>集合 </a> 章节），有些语言甚至将枚举的数据类型称为 “enumerators”！Java 修正了这个错误，但是 Enumeration 接口已经无法轻易地抹去了，因此它将一直存在于旧的（甚至有些新的）代码、类库以及文档中。</p><!-- 分页 --><div style="page-break-after: always;"></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年7月" scheme="http://yoursite.com/categories/2020%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
</feed>
