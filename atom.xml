<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-11T01:28:06.956Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据库学习笔记-MySQL安装</title>
    <link href="http://yoursite.com/2020/06/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-MySQL%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2020/06/10/数据库学习笔记-MySQL安装/</id>
    <published>2020-06-10T10:12:12.000Z</published>
    <updated>2020-06-11T01:28:06.956Z</updated>
    
    <content type="html"><![CDATA[<p>Mac上安装MySQL遇到的问题及解决方法</p><a id="more"></a><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>安装步骤参见<a href="https://juejin.im/post/5cc2a52ce51d456e7079f27f" target="_blank" rel="noopener">^1</a></p><p>安装完毕后，终端输入<code>myqsl -u root -p</code>启动MySQL</p><h2 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h2><p>登录遇到错误</p><pre><code>ERROR 1045 (28000): Access denied for user &apos;root&apos;@&apos;localhost&apos; (using password: YES)</code></pre><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>参见<a href="https://blog.csdn.net/qq_32786873/article/details/79225039" target="_blank" rel="noopener">^2</a><br>但是输入命令重启MySQL服务器：</p><pre><code>systemctl restart mysqld</code></pre><p>发现报错：</p><pre><code>bash: systemctl: command not found</code></pre><p>因为systemctl命令是用于Linux的，在MacOS上替代命令是launchctl，Apache的HTTP控制接口是apachectl。</p><p>先停止MySQL数据库：</p><pre><code>launchctl stop mysqlId</code></pre><p>然后再重置密码</p><p>因为我是用<a href="https://juejin.im/post/5cc2a52ce51d456e7079f27f" target="_blank" rel="noopener">^1</a>中的下载dmg包安装MySQL的，所以可以直接去系统偏好设置中找到MySQL服务，然后重置密码。</p><p>这样就可以登录了。</p><h1 id="建立数据库"><a href="#建立数据库" class="headerlink" title="建立数据库"></a>建立数据库</h1><p>首先建立数据库，再在其中建立数据表即可：</p><pre><code>create database （database name）;use （database name）;</code></pre><p>别忘记每句后加分号</p><pre><code>mysql&gt; create database mysql_practice;Query OK, 1 row affected (0.00 sec)mysql&gt; use mysql_practiceDatabase changed</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mac上安装MySQL遇到的问题及解决方法&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Database，MySQL" scheme="http://yoursite.com/tags/Database%EF%BC%8CMySQL/"/>
    
  </entry>
  
  <entry>
    <title>数据库学习笔记-SQL约束(Constraints)</title>
    <link href="http://yoursite.com/2020/06/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-SQL%E7%BA%A6%E6%9D%9F(Constraints)/"/>
    <id>http://yoursite.com/2020/06/09/数据库学习笔记-SQL约束(Constraints)/</id>
    <published>2020-06-09T12:24:12.000Z</published>
    <updated>2020-06-10T03:40:41.334Z</updated>
    
    <content type="html"><![CDATA[<p>SQL约束(Constraints)</p><a id="more"></a><h1 id="SQL-约束-1"><a href="#SQL-约束-1" class="headerlink" title="SQL 约束^1"></a>SQL 约束<a href="https://www.w3school.com.cn/sql/sql_constraints.asp" target="_blank" rel="noopener">^1</a></h1><p>约束用于限制加入表的数据的类型。</p><ol><li>按照约束对象分类:</li></ol><p>(1)域完整性约束条件: 施加在某一列上, 比如sage&lt;25 and sage&lt;40</p><p>(2)关系完整性约束条件: 施加在表上, 涉及多列, 2&lt;=hours/credit&lt;=16</p><ol start="2"><li>按照约束来源分类:</li></ol><p>(1)结构约束: 主键约束, 外键约束,是否允许空值等: primary key, foreign key, not null</p><p>(2) 内容约束:  取值范围, check(sage&lt;25 and sage&lt;40)</p><ol start="3"><li>按照约束状态分类:</li></ol><p>(1) 静态约束: 要求DB在任何时候都要满足的约束</p><p>(2) 动态约束: DB改变状态时要满足的约束, 例如salary 只能加不能减, 不能由1000改为500.—&gt; 触发器</p><p>SQL支持如下几种约束: </p><p>静态约束中的列完整性 与表完整性,  动态约束中的触发器</p><h1 id="静态约束"><a href="#静态约束" class="headerlink" title="静态约束"></a>静态约束</h1><p>可以在创建表时规定约束（通过 CREATE TABLE 语句），或者在表创建之后也可以（通过 ALTER TABLE 语句）。</p><p>注意: create table 中的约束条件 可以在后面根据需要进行撤销 ,也可以追加约束</p><pre><code>alter  table  tablename + add 追加约束,  也可以增加新的一列drop 删除一列的约束,或者删除一列,modify 修改</code></pre><p>我们将主要探讨以下几种约束：</p><pre><code>NOT NULLUNIQUEPRIMARY KEYFOREIGN KEYCHECKDEFAULT</code></pre><p>还有断言assertion</p><h2 id="SQL-NOT-NULL-约束"><a href="#SQL-NOT-NULL-约束" class="headerlink" title="SQL NOT NULL 约束"></a>SQL NOT NULL 约束</h2><p>NOT NULL 约束强制列不接受 NULL 值。</p><p>NOT NULL 约束强制字段始终包含值。这意味着，如果不向字段添加值，就无法插入新记录或者更新记录。</p><p>下面的 SQL 语句强制 “Id_P” 列和 “LastName” 列不接受 NULL 值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Persons</span><br><span class="line">(</span><br><span class="line">Id_P int NOT NULL,</span><br><span class="line">LastName varchar(255) NOT NULL,</span><br><span class="line">FirstName varchar(255),</span><br><span class="line">Address varchar(255),</span><br><span class="line">City varchar(255)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="SQL-UNIQUE-约束"><a href="#SQL-UNIQUE-约束" class="headerlink" title="SQL UNIQUE 约束"></a>SQL UNIQUE 约束</h2><p>UNIQUE 约束唯一标识数据库表中的每条记录。</p><p>UNIQUE 和 PRIMARY KEY 约束均为列或列集合提供了唯一性的保证。</p><p>PRIMARY KEY 拥有自动定义的 UNIQUE 约束。</p><p>请注意，每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束。</p><h3 id="SQL-UNIQUE-Constraint-on-CREATE-TABLE"><a href="#SQL-UNIQUE-Constraint-on-CREATE-TABLE" class="headerlink" title="SQL UNIQUE Constraint on CREATE TABLE"></a>SQL UNIQUE Constraint on CREATE TABLE</h3><p>下面的 SQL 在 “Persons” 表创建时在 “Id_P” 列创建 UNIQUE 约束：</p><p>MySQL:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Persons</span><br><span class="line">(</span><br><span class="line">Id_P int NOT NULL,</span><br><span class="line">LastName varchar(255) NOT NULL,</span><br><span class="line">FirstName varchar(255),</span><br><span class="line">Address varchar(255),</span><br><span class="line">City varchar(255),</span><br><span class="line">UNIQUE (Id_P)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>SQL Server / Oracle / MS Access:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Persons</span><br><span class="line">(</span><br><span class="line">Id_P int NOT NULL UNIQUE,</span><br><span class="line">LastName varchar(255) NOT NULL,</span><br><span class="line">FirstName varchar(255),</span><br><span class="line">Address varchar(255),</span><br><span class="line">City varchar(255)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果需要命名 UNIQUE 约束，以及为多个列定义 UNIQUE 约束，请使用下面的 SQL 语法：</p><p>MySQL / SQL Server / Oracle / MS Access:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Persons</span><br><span class="line">(</span><br><span class="line">Id_P int NOT NULL,</span><br><span class="line">LastName varchar(255) NOT NULL,</span><br><span class="line">FirstName varchar(255),</span><br><span class="line">Address varchar(255),</span><br><span class="line">City varchar(255),</span><br><span class="line">CONSTRAINT uc_PersonID UNIQUE (Id_P,LastName)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="SQL-UNIQUE-Constraint-on-ALTER-TABLE"><a href="#SQL-UNIQUE-Constraint-on-ALTER-TABLE" class="headerlink" title="SQL UNIQUE Constraint on ALTER TABLE"></a>SQL UNIQUE Constraint on ALTER TABLE</h3><p>当表已被创建时，如需在 “Id_P” 列创建 UNIQUE 约束，请使用下列 SQL：</p><p>MySQL / SQL Server / Oracle / MS Access:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE Persons</span><br><span class="line">ADD UNIQUE (Id_P)</span><br></pre></td></tr></table></figure><p>如需命名 UNIQUE 约束，并定义多个列的 UNIQUE 约束，请使用下面的 SQL 语法：</p><p>MySQL / SQL Server / Oracle / MS Access:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE Persons</span><br><span class="line">ADD CONSTRAINT uc_PersonID UNIQUE (Id_P,LastName)</span><br></pre></td></tr></table></figure><p>撤销 UNIQUE 约束<br>如需撤销 UNIQUE 约束，请使用下面的 SQL：</p><p>MySQL:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE Persons</span><br><span class="line">DROP INDEX uc_PersonID</span><br></pre></td></tr></table></figure><p>SQL Server / Oracle / MS Access:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE Persons</span><br><span class="line">DROP CONSTRAINT uc_PersonID</span><br></pre></td></tr></table></figure><h2 id="SQL-PRIMARY-KEY-约束"><a href="#SQL-PRIMARY-KEY-约束" class="headerlink" title="SQL PRIMARY KEY 约束"></a>SQL PRIMARY KEY 约束</h2><p>PRIMARY KEY 约束唯一标识数据库表中的每条记录。</p><p>主键必须包含唯一的值。</p><p>主键列不能包含 NULL 值。</p><p>每个表都应该有一个主键，并且每个表只能有一个主键。</p><h3 id="SQL-PRIMARY-KEY-Constraint-on-CREATE-TABLE"><a href="#SQL-PRIMARY-KEY-Constraint-on-CREATE-TABLE" class="headerlink" title="SQL PRIMARY KEY Constraint on CREATE TABLE"></a>SQL PRIMARY KEY Constraint on CREATE TABLE</h3><p>下面的 SQL 在 “Persons” 表创建时在 “Id_P” 列创建 PRIMARY KEY 约束：</p><p>MySQL:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Persons</span><br><span class="line">(</span><br><span class="line">Id_P int NOT NULL,</span><br><span class="line">LastName varchar(255) NOT NULL,</span><br><span class="line">FirstName varchar(255),</span><br><span class="line">Address varchar(255),</span><br><span class="line">City varchar(255),</span><br><span class="line">PRIMARY KEY (Id_P)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>SQL Server / Oracle / MS Access:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Persons</span><br><span class="line">(</span><br><span class="line">Id_P int NOT NULL PRIMARY KEY,</span><br><span class="line">LastName varchar(255) NOT NULL,</span><br><span class="line">FirstName varchar(255),</span><br><span class="line">Address varchar(255),</span><br><span class="line">City varchar(255)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果需要命名 PRIMARY KEY 约束，以及为多个列定义 PRIMARY KEY 约束，请使用下面的 SQL 语法：</p><p>MySQL / SQL Server / Oracle / MS Access:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Persons</span><br><span class="line">(</span><br><span class="line">Id_P int NOT NULL,</span><br><span class="line">LastName varchar(255) NOT NULL,</span><br><span class="line">FirstName varchar(255),</span><br><span class="line">Address varchar(255),</span><br><span class="line">City varchar(255),</span><br><span class="line">CONSTRAINT pk_PersonID PRIMARY KEY (Id_P,LastName)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="SQL-PRIMARY-KEY-Constraint-on-ALTER-TABLE"><a href="#SQL-PRIMARY-KEY-Constraint-on-ALTER-TABLE" class="headerlink" title="SQL PRIMARY KEY Constraint on ALTER TABLE"></a>SQL PRIMARY KEY Constraint on ALTER TABLE</h3><p>如果在表已存在的情况下为 “Id_P” 列创建 PRIMARY KEY 约束，请使用下面的 SQL：</p><p>MySQL / SQL Server / Oracle / MS Access:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE Persons</span><br><span class="line">ADD PRIMARY KEY (Id_P)</span><br></pre></td></tr></table></figure><p>如果需要命名 PRIMARY KEY 约束，以及为多个列定义 PRIMARY KEY 约束，请使用下面的 SQL 语法：</p><p>MySQL / SQL Server / Oracle / MS Access:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE Persons</span><br><span class="line">ADD CONSTRAINT pk_PersonID PRIMARY KEY (Id_P,LastName)</span><br></pre></td></tr></table></figure><p>注释：如果您使用 ALTER TABLE 语句添加主键，必须把主键列声明为不包含 NULL 值（在表首次创建时）。</p><h3 id="撤销-PRIMARY-KEY-约束"><a href="#撤销-PRIMARY-KEY-约束" class="headerlink" title="撤销 PRIMARY KEY 约束"></a>撤销 PRIMARY KEY 约束</h3><p>如需撤销 PRIMARY KEY 约束，请使用下面的 SQL：</p><p>MySQL:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE Persons</span><br><span class="line">DROP PRIMARY KEY</span><br></pre></td></tr></table></figure><p>SQL Server / Oracle / MS Access:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE Persons</span><br><span class="line">DROP CONSTRAINT pk_PersonID</span><br></pre></td></tr></table></figure><h2 id="SQL-FOREIGN-KEY-约束"><a href="#SQL-FOREIGN-KEY-约束" class="headerlink" title="SQL FOREIGN KEY 约束"></a>SQL FOREIGN KEY 约束</h2><p>一个表中的 FOREIGN KEY 指向另一个表中的 PRIMARY KEY。</p><p>让我们通过一个例子来解释外键。请看下面两个表：</p><p>“Persons” 表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Id_PLastNameFirstNameAddress        City</span><br><span class="line">1    Adams    John    Oxford StreetLondon</span><br><span class="line">2    Bush    George    Fifth AvenueNew York</span><br><span class="line">3    Carter    Thomas    Changan StreetBeijing</span><br></pre></td></tr></table></figure><p>“Orders” 表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Id_OOrderNoId_P</span><br><span class="line">1    778953</span><br><span class="line">2    446783</span><br><span class="line">3    224561</span><br><span class="line">4    245621</span><br></pre></td></tr></table></figure><p>请注意，”Orders” 中的 “Id_P” 列指向 “Persons” 表中的 “Id_P” 列。</p><p>“Persons” 表中的 “Id_P” 列是 “Persons” 表中的 PRIMARY KEY。</p><p>“Orders” 表中的 “Id_P” 列是 “Orders” 表中的 FOREIGN KEY。</p><p>FOREIGN KEY 约束用于预防破坏表之间连接的动作。</p><p>FOREIGN KEY 约束也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</p><h3 id="SQL-FOREIGN-KEY-Constraint-on-CREATE-TABLE"><a href="#SQL-FOREIGN-KEY-Constraint-on-CREATE-TABLE" class="headerlink" title="SQL FOREIGN KEY Constraint on CREATE TABLE"></a>SQL FOREIGN KEY Constraint on CREATE TABLE</h3><p>下面的 SQL 在 “Orders” 表创建时为 “Id_P” 列创建 FOREIGN KEY：</p><p>MySQL:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Orders</span><br><span class="line">(</span><br><span class="line">Id_O int NOT NULL,</span><br><span class="line">OrderNo int NOT NULL,</span><br><span class="line">Id_P int,</span><br><span class="line">PRIMARY KEY (Id_O),</span><br><span class="line">FOREIGN KEY (Id_P) REFERENCES Persons(Id_P)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>SQL Server / Oracle / MS Access:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Orders</span><br><span class="line">(</span><br><span class="line">Id_O int NOT NULL PRIMARY KEY,</span><br><span class="line">OrderNo int NOT NULL,</span><br><span class="line">Id_P int FOREIGN KEY REFERENCES Persons(Id_P)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果需要命名 FOREIGN KEY 约束，以及为多个列定义 FOREIGN KEY 约束，请使用下面的 SQL 语法：</p><p>MySQL / SQL Server / Oracle / MS Access:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Orders</span><br><span class="line">(</span><br><span class="line">Id_O int NOT NULL,</span><br><span class="line">OrderNo int NOT NULL,</span><br><span class="line">Id_P int,</span><br><span class="line">PRIMARY KEY (Id_O),</span><br><span class="line">CONSTRAINT fk_PerOrders FOREIGN KEY (Id_P)</span><br><span class="line">REFERENCES Persons(Id_P)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="SQL-FOREIGN-KEY-Constraint-on-ALTER-TABLE"><a href="#SQL-FOREIGN-KEY-Constraint-on-ALTER-TABLE" class="headerlink" title="SQL FOREIGN KEY Constraint on ALTER TABLE"></a>SQL FOREIGN KEY Constraint on ALTER TABLE</h3><p>如果在 “Orders” 表已存在的情况下为 “Id_P” 列创建 FOREIGN KEY 约束，请使用下面的 SQL：</p><p>MySQL / SQL Server / Oracle / MS Access:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE Orders</span><br><span class="line">ADD FOREIGN KEY (Id_P)</span><br><span class="line">REFERENCES Persons(Id_P)</span><br></pre></td></tr></table></figure><p>如果需要命名 FOREIGN KEY 约束，以及为多个列定义 FOREIGN KEY 约束，请使用下面的 SQL 语法：</p><p>MySQL / SQL Server / Oracle / MS Access:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE Orders</span><br><span class="line">ADD CONSTRAINT fk_PerOrders</span><br><span class="line">FOREIGN KEY (Id_P)</span><br><span class="line">REFERENCES Persons(Id_P)</span><br></pre></td></tr></table></figure><h3 id="撤销-FOREIGN-KEY-约束"><a href="#撤销-FOREIGN-KEY-约束" class="headerlink" title="撤销 FOREIGN KEY 约束"></a>撤销 FOREIGN KEY 约束</h3><p>如需撤销 FOREIGN KEY 约束，请使用下面的 SQL：</p><p>MySQL:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE Orders</span><br><span class="line">DROP FOREIGN KEY fk_PerOrders</span><br><span class="line">SQL Server / Oracle / MS Access:</span><br><span class="line">ALTER TABLE Orders</span><br><span class="line">DROP CONSTRAINT fk_PerOrderss</span><br></pre></td></tr></table></figure><h2 id="SQL-CHECK-约束"><a href="#SQL-CHECK-约束" class="headerlink" title="SQL CHECK 约束"></a>SQL CHECK 约束</h2><p>CHECK 约束用于限制列中的值的范围。</p><p>如果对单个列定义 CHECK 约束，那么该列只允许特定的值。</p><p>如果对一个表定义 CHECK 约束，那么此约束会在特定的列中对值进行限制。</p><h3 id="SQL-CHECK-Constraint-on-CREATE-TABLE"><a href="#SQL-CHECK-Constraint-on-CREATE-TABLE" class="headerlink" title="SQL CHECK Constraint on CREATE TABLE"></a>SQL CHECK Constraint on CREATE TABLE</h3><p>下面的 SQL 在 “Persons” 表创建时为 “Id_P” 列创建 CHECK 约束。CHECK 约束规定 “Id_P” 列必须只包含大于 0 的整数。</p><p>My SQL:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Persons</span><br><span class="line">(</span><br><span class="line">Id_P int NOT NULL,</span><br><span class="line">LastName varchar(255) NOT NULL,</span><br><span class="line">FirstName varchar(255),</span><br><span class="line">Address varchar(255),</span><br><span class="line">City varchar(255),</span><br><span class="line">CHECK (Id_P&gt;0)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>SQL Server / Oracle / MS Access:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Persons</span><br><span class="line">(</span><br><span class="line">Id_P int NOT NULL CHECK (Id_P&gt;0),</span><br><span class="line">LastName varchar(255) NOT NULL,</span><br><span class="line">FirstName varchar(255),</span><br><span class="line">Address varchar(255),</span><br><span class="line">City varchar(255)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果需要命名 CHECK 约束，以及为多个列定义 CHECK 约束，请使用下面的 SQL 语法：</p><p>MySQL / SQL Server / Oracle / MS Access:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Persons</span><br><span class="line">(</span><br><span class="line">Id_P int NOT NULL,</span><br><span class="line">LastName varchar(255) NOT NULL,</span><br><span class="line">FirstName varchar(255),</span><br><span class="line">Address varchar(255),</span><br><span class="line">City varchar(255),</span><br><span class="line">CONSTRAINT chk_Person CHECK (Id_P&gt;0 AND City=&apos;Sandnes&apos;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="SQL-CHECK-Constraint-on-ALTER-TABLE"><a href="#SQL-CHECK-Constraint-on-ALTER-TABLE" class="headerlink" title="SQL CHECK Constraint on ALTER TABLE"></a>SQL CHECK Constraint on ALTER TABLE</h3><p>如果在表已存在的情况下为 “Id_P” 列创建 CHECK 约束，请使用下面的 SQL：</p><p>MySQL / SQL Server / Oracle / MS Access:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE Persons</span><br><span class="line">ADD CHECK (Id_P&gt;0)</span><br></pre></td></tr></table></figure><p>如果需要命名 CHECK 约束，以及为多个列定义 CHECK 约束，请使用下面的 SQL 语法：</p><p>MySQL / SQL Server / Oracle / MS Access:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE Persons</span><br><span class="line">ADD CONSTRAINT chk_Person CHECK (Id_P&gt;0 AND City=&apos;Sandnes&apos;)</span><br></pre></td></tr></table></figure><h3 id="撤销-CHECK-约束"><a href="#撤销-CHECK-约束" class="headerlink" title="撤销 CHECK 约束"></a>撤销 CHECK 约束</h3><p>如需撤销 CHECK 约束，请使用下面的 SQL：</p><p>SQL Server / Oracle / MS Access:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE Persons</span><br><span class="line">DROP CONSTRAINT chk_Person</span><br></pre></td></tr></table></figure><p>MySQL:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE Persons</span><br><span class="line">DROP CHECK chk_Person</span><br></pre></td></tr></table></figure><h2 id="SQL-DEFAULT-约束"><a href="#SQL-DEFAULT-约束" class="headerlink" title="SQL DEFAULT 约束"></a>SQL DEFAULT 约束</h2><p>DEFAULT 约束用于向列中插入默认值。</p><p>如果没有规定其他的值，那么会将默认值添加到所有的新记录。</p><h3 id="SQL-DEFAULT-Constraint-on-CREATE-TABLE"><a href="#SQL-DEFAULT-Constraint-on-CREATE-TABLE" class="headerlink" title="SQL DEFAULT Constraint on CREATE TABLE"></a>SQL DEFAULT Constraint on CREATE TABLE</h3><p>下面的 SQL 在 “Persons” 表创建时为 “City” 列创建 DEFAULT 约束：</p><p>My SQL / SQL Server / Oracle / MS Access:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Persons</span><br><span class="line">(</span><br><span class="line">Id_P int NOT NULL,</span><br><span class="line">LastName varchar(255) NOT NULL,</span><br><span class="line">FirstName varchar(255),</span><br><span class="line">Address varchar(255),</span><br><span class="line">City varchar(255) DEFAULT &apos;Sandnes&apos;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>通过使用类似 GETDATE() 这样的函数，DEFAULT 约束也可以用于插入系统值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE Orders</span><br><span class="line">(</span><br><span class="line">Id_O int NOT NULL,</span><br><span class="line">OrderNo int NOT NULL,</span><br><span class="line">Id_P int,</span><br><span class="line">OrderDate date DEFAULT GETDATE()</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="SQL-DEFAULT-Constraint-on-ALTER-TABLE"><a href="#SQL-DEFAULT-Constraint-on-ALTER-TABLE" class="headerlink" title="SQL DEFAULT Constraint on ALTER TABLE"></a>SQL DEFAULT Constraint on ALTER TABLE</h3><p>如果在表已存在的情况下为 “City” 列创建 DEFAULT 约束，请使用下面的 SQL：</p><p>MySQL:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE Persons</span><br><span class="line">ALTER City SET DEFAULT &apos;SANDNES&apos;</span><br></pre></td></tr></table></figure><p>SQL Server / Oracle / MS Access:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE Persons</span><br><span class="line">ALTER COLUMN City SET DEFAULT &apos;SANDNES&apos;</span><br></pre></td></tr></table></figure><h3 id="撤销-DEFAULT-约束"><a href="#撤销-DEFAULT-约束" class="headerlink" title="撤销 DEFAULT 约束"></a>撤销 DEFAULT 约束</h3><p>如需撤销 DEFAULT 约束，请使用下面的 SQL：</p><p>MySQL:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE Persons</span><br><span class="line">ALTER City DROP DEFAULT</span><br></pre></td></tr></table></figure><p>SQL Server / Oracle / MS Access:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE Persons</span><br><span class="line">ALTER COLUMN City DROP DEFAULT</span><br></pre></td></tr></table></figure><h2 id="断言-assertion"><a href="#断言-assertion" class="headerlink" title="断言 assertion"></a>断言 assertion</h2><p>一个断言就是一个谓词表达式, 它表达了希望数据库总能满足的条件, 表约束与 列约束就是一些特殊的断言.</p><p>还有复杂的断言 </p><pre><code>create assertion [assertion name] check [predicate]</code></pre><p>那么之后数据库的每一次更新去判断是否违反该断言, 断言测试增加了数据库维护的负担, 非必需不要使用断言<br>使用例子：创建断言检查Person表中的有效期字段license_expiry是否都在1/JAN/2015之后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE ASSERTION AssertLicenses </span><br><span class="line">     CHECK ( </span><br><span class="line">         NOT EXISTS ( </span><br><span class="line">             SELECT license_expiry </span><br><span class="line">             FROM Person </span><br><span class="line">             WHERE license_expiry &lt; &apos;1/JAN/2015&apos; </span><br><span class="line">         ) </span><br><span class="line">    );</span><br></pre></td></tr></table></figure><h1 id="动态约束"><a href="#动态约束" class="headerlink" title="动态约束"></a>动态约束</h1><p>以上 create table 中的表约束与列约束 是静态约束, 下面介绍动态约束–&gt; 触发器 trigger</p><p>动态约束是一种过程完整性的约束, 相比之下, 之前的create table 的约束是非过程性约束</p><p>动态约束是一个程序, 该程序可以在特定的时刻被自动触发执行: 比如在一次更新之前, </p><p>或者一次更新之后的执行. </p><p>动态约束 intergrity constraint::=(O,P,A,R), O P A R 都需要定义, 再来回顾下 </p><pre><code>O : 数据集合, 约束的对象 ?: 列, 多列的元组集合P: 谓词条件: 什么样的约束?A: 触发条件: 什么时候检查?R: 响应动作: 不满足怎么办?</code></pre><h2 id="触发器-2"><a href="#触发器-2" class="headerlink" title="触发器^2"></a>触发器<a href="https://www.cnblogs.com/hoojo/archive/2011/07/20/2111316.html" target="_blank" rel="noopener">^2</a></h2><p>触发器是一种特殊类型的存储过程，它不同于之前的我们介绍的存储过程。触发器主要是通过事件进行触发被自动调用执行的。而存储过程可以通过存储过程的名称被调用。</p><p>触发器对表进行插入、更新、删除的时候会自动执行的特殊存储过程。触发器一般用在check约束更加复杂的约束上面。触发器和普通的存储过程的区别是：触发器是当对某一个表进行操作。诸如：update、insert、delete这些操作的时候，系统会自动调用执行该表上对应的触发器。SQL Server 2005中触发器可以分为两类：DML触发器和DDL触发器，其中DDL触发器它们会影响多种数据定义语言语句而激发，这些语句有create、alter、drop语句。</p><p>DML触发器分为：</p><p>1、 after触发器（之后触发）</p><pre><code>a、 insert触发器b、 update触发器c、 delete触发器</code></pre><p>2、 instead of 触发器 （之前触发）</p><p>其中after触发器要求只有执行某一操作insert、update、delete之后触发器才被触发，且只能定义在表上。而instead of触发器表示并不执行其定义的操作（insert、update、delete）而仅是执行触发器本身。既可以在表上定义instead of触发器，也可以在视图上定义。</p><p>触发器有两个特殊的表：插入表（instered表）和删除表（deleted表）。这两张是逻辑表也是虚表。有系统在内存中创建者两张表，不会存储在数据库中。而且两张表的都是只读的，只能读取数据而不能修改数据。这两张表的结果总是与被改触发器应用的表的结构相同。当触发器完成工作后，这两张表就会被删除。Inserted表的数据是插入或是修改后的数据，而deleted表的数据是更新前的或是删除的数据。</p><p>Update数据的时候就是先删除表记录，然后增加一条记录。这样在inserted和deleted表就都有update后的数据记录了。注意的是：触发器本身就是一个事务，所以在触发器里面可以对修改数据进行一些特殊的检查。如果不满足可以利用事务回滚，撤销操作。</p><p>创建触发器</p><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create trigger tgr_name</span><br><span class="line">on table_name</span><br><span class="line">with encrypion –加密触发器</span><br><span class="line">    for update...</span><br><span class="line">as</span><br><span class="line">    Transact-SQL</span><br></pre></td></tr></table></figure><p>SQLite 中创建触发器（Trigger）的基本语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE  TRIGGER trigger_name [BEFORE|AFTER] event_name </span><br><span class="line">ON table_name</span><br><span class="line">BEGIN</span><br><span class="line"> -- Trigger logic goes here....</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><p>更多实例参考<a href="https://wizardforcel.gitbooks.io/w3school-sql/92.html" target="_blank" rel="noopener">^3</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SQL约束(Constraints)&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Database，MySQL" scheme="http://yoursite.com/tags/Database%EF%BC%8CMySQL/"/>
    
  </entry>
  
  <entry>
    <title>Java编程思想-第九章 多态阅读笔记</title>
    <link href="http://yoursite.com/2020/06/06/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%A4%9A%E6%80%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/06/06/Java编程思想-第九章 多态阅读笔记/</id>
    <published>2020-06-06T14:12:12.000Z</published>
    <updated>2020-06-06T15:44:06.164Z</updated>
    
    <content type="html"><![CDATA[<p>第九章 多态</p><a id="more"></a><p>多态是面向对象编程语言中，继数据抽象和继承之外的第三个重要特性。</p><p>多态提供了另一个维度的接口与实现分离，以解耦做什么和怎么做。多态不仅能改善代码的组织，提高代码的可读性，而且能创建有扩展性的程序——无论在最初创建项目时还是在添加新特性时都可以“生长”的程序。</p><p>封装通过合并特征和行为来创建新的数据类型。隐藏实现通过将细节<strong>私有化</strong>把接口与实现分离。这种类型的组织机制对于有面向过程编程背景的人来说，更容易理解。而多态是消除类型之间的耦合。在上一章中，继承允许把一个对象视为它本身的类型或它的基类类型。这样就能把很多派生自一个基类的类型当作同一类型处理，因而一段代码就可以无差别地运行在所有不同的类型上了。多态方法调用允许一种类型表现出与相似类型的区别，只要这些类型派生自一个基类。这种区别是当你通过基类调用时，由方法的不同行为表现出来的。</p><p>在本章中，通过一些基本、简单的例子（这些例子中只保留程序中与多态有关的行为），逐步学习多态（也称为<em>动态绑定</em>或<em>后期绑定</em>或<em>运行时绑定</em>）。</p><!-- Upcasting Revisited --><h2 id="向上转型回顾"><a href="#向上转型回顾" class="headerlink" title="向上转型回顾"></a>向上转型回顾</h2><p>在上一章中，我们看到了如何把一个对象视作它的自身类型或它的基类类型。这种把一个对象引用当作它的基类引用的做法称为向上转型，因为继承图中基类一般都位于最上方。</p><p>同样我们也在下面的音乐乐器例子中发现了问题。既然几个例子都要演奏乐符（<strong>Note</strong>），首先我们先在包中单独创建一个 Note 枚举类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polymorphism/music/Note.java</span></span><br><span class="line"><span class="comment">// Notes to play on musical instruments</span></span><br><span class="line"><span class="keyword">package</span> polymorphism.music;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Note &#123;</span><br><span class="line">    MIDDLE_C, C_SHARP, B_FLAT; <span class="comment">// Etc.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举已经在”第 6 章初始化和清理“一章中介绍过了。</p><p>这里，<strong>Wind</strong> 是一种 <strong>Instrument</strong>；因此，<strong>Wind</strong> 继承 <strong>Instrument</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polymorphism/music/Instrument.java</span></span><br><span class="line"><span class="keyword">package</span> polymorphism.music;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Instrument.play()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// polymorphism/music/Wind.java</span></span><br><span class="line"><span class="keyword">package</span> polymorphism.music;</span><br><span class="line"><span class="comment">// Wind objects are instruments</span></span><br><span class="line"><span class="comment">// because they have the same interface:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wind</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Redefine interface method:</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Wind.play() "</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Music</strong> 的方法 <code>tune()</code> 接受一个 <strong>Instrument</strong> 引用，同时也接受任何派生自 <strong>Instrument</strong> 的类引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polymorphism/music/Music.java</span></span><br><span class="line"><span class="comment">// Inheritance &amp; upcasting</span></span><br><span class="line"><span class="comment">// &#123;java polymorphism.music.Music&#125;</span></span><br><span class="line"><span class="keyword">package</span> polymorphism.music;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Instrument i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        i.play(Note.MIDDLE_C);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Wind flute = <span class="keyword">new</span> Wind();</span><br><span class="line">        tune(flute); <span class="comment">// Upcasting</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Wind.play() MIDDLE_C</span><br></pre></td></tr></table></figure><p>在 <code>main()</code> 中看到了 <code>tune()</code> 方法传入了一个 <strong>Wind</strong> 引用，而没有做类型转换。这样做是允许的—— <strong>Instrument</strong> 的接口一定存在于 <strong>Wind</strong> 中，因此 <strong>Wind</strong> 继承了 <strong>Instrument</strong>。从 <strong>Wind</strong> 向上转型为 <strong>Instrument</strong> 可能“缩小”接口，但不会比 <strong>Instrument</strong> 的全部接口更少。</p><h3 id="忘掉对象类型"><a href="#忘掉对象类型" class="headerlink" title="忘掉对象类型"></a>忘掉对象类型</h3><p><strong>Music.java</strong> 看起来似乎有点奇怪。为什么所有人都故意忘记掉对象类型呢？当向上转型时，就会发生这种情况，而且看起来如果 <code>tune()</code> 接受的参数是一个 <strong>Wind</strong> 引用会更为直观。这会带来一个重要问题：如果你那么做，就要为系统内 <strong>Instrument</strong> 的每种类型都编写一个新的 <code>tune()</code> 方法。假设按照这种推理，再增加 <strong>Stringed</strong> 和 <strong>Brass</strong> 这两种 <strong>Instrument</strong> :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polymorphism/music/Music2.java</span></span><br><span class="line"><span class="comment">// Overloading instead of upcasting</span></span><br><span class="line"><span class="comment">// &#123;java polymorphism.music.Music2&#125;</span></span><br><span class="line"><span class="keyword">package</span> polymorphism.music;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stringed</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Stringed.play() "</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Brass</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Brass.play() "</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Wind i)</span> </span>&#123;</span><br><span class="line">        i.play(Note.MIDDLE_C);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Stringed i)</span> </span>&#123;</span><br><span class="line">        i.play(Note.MIDDLE_C);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Brass i)</span> </span>&#123;</span><br><span class="line">        i.play(Note.MIDDLE_C);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Wind flute = <span class="keyword">new</span> Wind();</span><br><span class="line">        Stringed violin = <span class="keyword">new</span> Stringed();</span><br><span class="line">        Brass frenchHorn = <span class="keyword">new</span> Brass();</span><br><span class="line">        tune(flute); <span class="comment">// No upcasting</span></span><br><span class="line">        tune(violin);</span><br><span class="line">        tune(frenchHorn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Wind.play() MIDDLE_C</span><br><span class="line">Stringed.play() MIDDLE_C</span><br><span class="line">Brass.play() MIDDLE_C</span><br></pre></td></tr></table></figure><p>这样行得通，但是有一个主要缺点：必须为添加的每个新 <strong>Instrument</strong> 类编写特定的方法。这意味着开始时就需要更多的编程，而且以后如果添加类似 <code>tune()</code> 的新方法或 <strong>Instrument</strong> 的新类型时，还有大量的工作要做。考虑到如果你忘记重载某个方法，编译器也不会提示你，这会造成类型的整个处理过程变得难以管理。</p><p>如果只写一个方法以基类作为参数，而不用管是哪个具体派生类，这样会变得更好吗？也就是说，如果忘掉派生类，编写的代码只与基类打交道，会不会更好呢？</p><p>这正是多态所允许的。但是大部分拥有面向过程编程背景的程序员会对多态的运作方式感到一些困惑。</p><!-- The Twist --><h2 id="转机"><a href="#转机" class="headerlink" title="转机"></a>转机</h2><p>运行程序后会看到 <strong>Music.java</strong> 的难点。<strong>Wind.play()</strong> 的输出结果正是我们期望的，然而它看起来似乎不应该得出这样的结果。观察 <code>tune()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Instrument i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    i.play(Note.MIDDLE_C);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它接受一个 <strong>Instrument</strong> 引用。那么编译器是如何知道这里的 <strong>Instrument</strong> 引用指向的是 <strong>Wind</strong>，而不是 <strong>Brass</strong> 或 <strong>Stringed</strong> 呢？编译器无法得知。为了深入理解这个问题，有必要研究一下<em>绑定</em>这个主题。</p><h3 id="方法调用绑定"><a href="#方法调用绑定" class="headerlink" title="方法调用绑定"></a>方法调用绑定</h3><p>将一个方法调用和一个方法主体关联起来称作<em>绑定</em>。若绑定发生在程序运行前（如果有的话，由编译器和链接器实现），叫做<em>前期绑定</em>。你可能从来没有听说这个术语，因为它是面向过程语言不需选择默认的绑定方式，例如在 C 语言中就只有<em>前期绑定</em>这一种方法调用。</p><p>上述程序让人困惑的地方就在于前期绑定，因为编译器只知道一个 <strong>Instrument</strong> 引用，它无法得知究竟会调用哪个方法。</p><p>解决方法就是<em>后期绑定</em>，意味着在运行时根据对象的类型进行绑定。后期绑定也称为<em>动态绑定</em>或<em>运行时绑定</em>。当一种语言实现了后期绑定，就必须具有某种机制在运行时能判断对象的类型，从而调用恰当的方法。也就是说，编译器仍然不知道对象的类型，但是方法调用机制能找到正确的方法体并调用。每种语言的后期绑定机制都不同，但是可以想到，对象中一定存在某种类型信息。</p><p>Java 中除了 <strong>static</strong> 和 <strong>final</strong> 方法（<strong>private</strong> 方法也是隐式的 <strong>final</strong>）外，其他所有方法都是后期绑定。这意味着通常情况下，我们不需要判断后期绑定是否会发生——它自动发生。</p><p>为什么将一个对象指明为 <strong>final</strong> ？正如前一章所述，它可以防止方法被重写。但更重要的一点可能是，它有效地”关闭了“动态绑定，或者说告诉编译器不需要对其进行动态绑定。这可以让编译器为 <strong>final</strong> 方法生成更高效的代码。然而，大部分情况下这样做不会对程序的整体性能带来什么改变，因此最好是为了设计使用 <strong>final</strong>，而不是为了提升性能而使用。</p><h3 id="产生正确的行为"><a href="#产生正确的行为" class="headerlink" title="产生正确的行为"></a>产生正确的行为</h3><p>一旦当你知道 Java 中所有方法都是通过后期绑定来实现多态时，就可以编写只与基类打交道的代码，而且代码对于派生类来说都能正常地工作。或者换种说法，你向对象发送一条消息，让对象自己做正确的事。</p><p>面向对象编程中的经典例子是形状 <strong>Shape</strong>。这个例子很直观，但不幸的是，它可能让初学者困惑，认为面向对象编程只适合图形化程序设计，实际上不是这样。</p><p>形状的例子中，有一个基类称为 <strong>Shape</strong> ，多个不同的派生类型分别是：<strong>Circle</strong>，<strong>Square</strong>，<strong>Triangle</strong> 等等。这个例子之所以好用，是因为我们可以直接说“圆(Circle)是一种形状(Shape)”，这很容易理解。</p><p>向上转型就像下面这么简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Shape s = <span class="keyword">new</span> Circle();</span><br></pre></td></tr></table></figure><p>这会创建一个 <strong>Circle</strong> 对象，引用被赋值给 <strong>Shape</strong> 类型的变量 s，这看似错误（将一种类型赋值给另一种类型），然而是没问题的，因此从继承上可认为圆(Circle)就是一个形状(Shape)。因此编译器认可了赋值语句，没有报错。</p><p>假设你调用了一个基类方法（在各个派生类中都被重写）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.draw()</span><br></pre></td></tr></table></figure><p>你可能再次认为 <strong>Shape</strong> 的 <code>draw()</code> 方法被调用，因为 s 是一个 <strong>Shape</strong> 引用——编译器怎么可能知道要做其他的事呢？然而，由于后期绑定（多态）被调用的是 <strong>Circle</strong> 的 <code>draw()</code> 方法，这是正确的。</p><p>下面的例子稍微有些不同。首先让我们创建一个可复用的 <strong>Shape</strong> 类库，基类 <strong>Shape</strong> 为它的所有子类建立了公共接口——所有的形状都可以被绘画和擦除：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polymorphism/shape/Shape.java</span></span><br><span class="line"><span class="keyword">package</span> polymorphism.shape;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>派生类通过重写这些方法为每个具体的形状提供独一无二的方法行为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polymorphism/shape/Circle.java</span></span><br><span class="line"><span class="keyword">package</span> polymorphism.shape;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Circle.draw()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Circle.erase()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// polymorphism/shape/Square.java</span></span><br><span class="line"><span class="keyword">package</span> polymorphism.shape;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Square.draw()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Square.erase()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// polymorphism/shape/Triangle.java</span></span><br><span class="line"><span class="keyword">package</span> polymorphism.shape;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Triangle.draw()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Triangle.erase()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>RandomShapes</strong> 是一种工厂，每当我们调用 <code>get()</code> 方法时，就会产生一个指向随机创建的 <strong>Shape</strong> 对象的引用。注意，向上转型发生在 <strong>return</strong> 语句中，每条 <strong>return</strong> 语句取得一个指向某个 <strong>Circle</strong>，<strong>Square</strong> 或 <strong>Triangle</strong> 的引用， 并将其以 <strong>Shape</strong> 类型从 <code>get()</code> 方法发送出去。因此无论何时调用 <code>get()</code> 方法，你都无法知道具体的类型是什么，因为你总是得到一个简单的 <strong>Shape</strong> 引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polymorphism/shape/RandomShapes.java</span></span><br><span class="line"><span class="comment">// A "factory" that randomly creates shapes</span></span><br><span class="line"><span class="keyword">package</span> polymorphism.shape;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomShapes</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Shape <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(rand.nextInt(<span class="number">3</span>)) &#123;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> <span class="keyword">new</span> Circle();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> <span class="keyword">new</span> Square();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> <span class="keyword">new</span> Triangle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Shape[] array(<span class="keyword">int</span> sz) &#123;</span><br><span class="line">        Shape[] shapes = <span class="keyword">new</span> Shape[sz];</span><br><span class="line">        <span class="comment">// Fill up the array with shapes:</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shapes.length; i++) &#123;</span><br><span class="line">            shapes[i] = get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> shapes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>array()</code> 方法分配并填充了 <strong>Shape</strong> 数组，这里使用了 for-in 表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polymorphism/Shapes.java</span></span><br><span class="line"><span class="comment">// Polymorphism in Java</span></span><br><span class="line"><span class="keyword">import</span> polymorphism.shape.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shapes</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RandomShapes gen = <span class="keyword">new</span> RandomShapes();</span><br><span class="line">        <span class="comment">// Make polymorphic method calls:</span></span><br><span class="line">        <span class="keyword">for</span> (Shape shape: gen.array(<span class="number">9</span>)) &#123;</span><br><span class="line">            shape.draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Triangle.draw()</span><br><span class="line">Triangle.draw()</span><br><span class="line">Square.draw()</span><br><span class="line">Triangle.draw()</span><br><span class="line">Square.draw()</span><br><span class="line">Triangle.draw()</span><br><span class="line">Square.draw()</span><br><span class="line">Triangle.draw()</span><br><span class="line">Circle.draw()</span><br></pre></td></tr></table></figure><p><code>main()</code> 方法中包含了一个 <strong>Shape</strong> 引用组成的数组，其中每个元素通过调用 <strong>RandomShapes</strong> 类的 <code>get()</code> 方法生成。现在你只知道拥有一些形状，但除此之外一无所知（编译器也是如此）。然而当遍历这个数组为每个元素调用 <code>draw()</code> 方法时，从运行程序的结果中可以看到，与类型有关的特定行为奇迹般地发生了。</p><p>随机生成形状是为了让大家理解：在编译时，编译器不需要知道任何具体信息以进行正确的调用。所有对方法 <code>draw()</code> 的调用都是通过动态绑定进行的。</p><h3 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h3><p>现在让我们回头看音乐乐器的例子。由于多态机制，你可以向系统中添加任意多的新类型，而不需要修改 <code>tune()</code> 方法。在一个设计良好的面向对象程序中，许多方法将会遵循 <code>tune()</code> 的模型，只与基类接口通信。这样的程序是可扩展的，因为可以从通用的基类派生出新的数据类型，从而添加新的功能。那些操纵基类接口的方法不需要改动就可以应用于新类。</p><p>考虑一下乐器的例子，如果在基类中添加更多的方法，并加入一些新类，将会发生什么呢：</p><p>所有的新类都可以和原有类正常运行，不需要改动 <code>tune()</code> 方法。即使 <code>tune()</code> 方法单独存放在某个文件中，而且向 <strong>Instrument</strong> 接口中添加了新的方法，<code>tune()</code> 方法也无需再编译就能正确运行。下面是类图的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polymorphism/music3/Music3.java</span></span><br><span class="line"><span class="comment">// An extensible program</span></span><br><span class="line"><span class="comment">// &#123;java polymorphism.music3.Music3&#125;</span></span><br><span class="line"><span class="keyword">package</span> polymorphism.music3;</span><br><span class="line"><span class="keyword">import</span> polymorphism.music.Note;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Instrument.play() "</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">String <span class="title">what</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Instrument"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Adjusting Instrument"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wind</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Wind.play() "</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">what</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Wind"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Adjusting Wind"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Percussion</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Percussion.play() "</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">what</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Percussion"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Adjusting Percussion"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stringed</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Stringed.play() "</span> + n);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">what</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Stringed"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Adjusting Stringed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Brass</span> <span class="keyword">extends</span> <span class="title">Wind</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Brass.play() "</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Adjusting Brass"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woodwind</span> <span class="keyword">extends</span> <span class="title">Wind</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Woodwind.play() "</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">what</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Woodwind"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music3</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Doesn't care about type, so new types</span></span><br><span class="line">    <span class="comment">// added to the system still work right:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Instrument i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        i.play(Note.MIDDLE_C);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tuneAll</span><span class="params">(Instrument[] e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Instrument i: e) &#123;</span><br><span class="line">            tune(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Upcasting during addition to the array:</span></span><br><span class="line">        Instrument[] orchestra = &#123;</span><br><span class="line">            <span class="keyword">new</span> Wind(),</span><br><span class="line">            <span class="keyword">new</span> Percussion(),</span><br><span class="line">            <span class="keyword">new</span> Stringed(),</span><br><span class="line">            <span class="keyword">new</span> Brass(),</span><br><span class="line">            <span class="keyword">new</span> Woodwind()</span><br><span class="line">        &#125;;</span><br><span class="line">        tuneAll(orchestra);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Wind.play() MIDDLE_C</span><br><span class="line">Percussion.play() MIDDLE_C</span><br><span class="line">Stringed.play() MIDDLE_C</span><br><span class="line">Brass.play() MIDDLE_C</span><br><span class="line">Woodwind.play() MIDDLE_C</span><br></pre></td></tr></table></figure><p>新方法 <code>what()</code> 返回一个带有类描述的 <strong>String</strong> 引用，<code>adjust()</code> 提供一些乐器调音的方法。</p><p>在 <code>main()</code> 方法中，当向 <strong>orchestra</strong> 数组添加元素时，元素会自动向上转型为 <strong>Instrument</strong>。</p><p><code>tune()</code> 方法可以忽略周围所有代码发生的变化，仍然可以正常运行。这正是我们期待多态能提供的特性。代码中的修改不会破坏程序中其他不应受到影响的部分。换句话说，多态是一项“将改变的事物与不变的事物分离”的重要技术。</p><h3 id="陷阱：“重写”私有方法"><a href="#陷阱：“重写”私有方法" class="headerlink" title="陷阱：“重写”私有方法"></a>陷阱：“重写”私有方法</h3><p>你可能天真地试图像下面这样做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polymorphism/PrivateOverride.java</span></span><br><span class="line"><span class="comment">// Trying to override a private method</span></span><br><span class="line"><span class="comment">// &#123;java polymorphism.PrivateOverride&#125;</span></span><br><span class="line"><span class="keyword">package</span> polymorphism;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateOverride</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"private f()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrivateOverride po = <span class="keyword">new</span> Derived();</span><br><span class="line">        po.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">PrivateOverride</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"public f()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private f()</span><br></pre></td></tr></table></figure><p>你可能期望输出是 <strong>public f()</strong>，然而 <strong>private</strong> 方法可以当作是 <strong>final</strong> 的，对于派生类来说是隐蔽的。因此，这里 <strong>Derived</strong> 的 <code>f()</code> 是一个全新的方法；因为基类版本的 <code>f()</code> 屏蔽了 <strong>Derived</strong> ，因此它都不算是重写方法。</p><p>结论是只有非 <strong>private</strong> 方法才能被重写，但是得小心重写 <strong>private</strong> 方法的现象，编译器不报错，但不会按我们所预期的执行。为了清晰起见，派生类中的方法名采用与基类中 <strong>private</strong> 方法名不同的命名。</p><p>如果使用了 <code>@Override</code> 注解，就能检测出问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polymorphism/PrivateOverride2.java</span></span><br><span class="line"><span class="comment">// Detecting a mistaken override using @Override</span></span><br><span class="line"><span class="comment">// &#123;WillNotCompile&#125;</span></span><br><span class="line"><span class="keyword">package</span> polymorphism;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateOverride2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"private f()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrivateOverride2 po = <span class="keyword">new</span> Derived2();</span><br><span class="line">        po.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived2</span> <span class="keyword">extends</span> <span class="title">PrivateOverride2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"public f()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器报错信息是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error: method does not override or</span><br><span class="line">implement a method from a supertype</span><br></pre></td></tr></table></figure><h3 id="陷阱：属性与静态方法"><a href="#陷阱：属性与静态方法" class="headerlink" title="陷阱：属性与静态方法"></a>陷阱：属性与静态方法</h3><p>一旦学会了多态，就可以以多态的思维方式考虑每件事。然而，只有普通的方法调用可以是多态的。例如，如果你直接访问一个属性，该访问会在编译时解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polymorphism/FieldAccess.java</span></span><br><span class="line"><span class="comment">// Direct field access is determined at compile time</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> field = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> field;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> field = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> field;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSuperField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.field;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldAccess</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Super sup = <span class="keyword">new</span> Sub(); <span class="comment">// Upcast</span></span><br><span class="line">        System.out.println(<span class="string">"sup.field = "</span> + sup.field + </span><br><span class="line">                          <span class="string">", sup.getField() = "</span> + sup.getField());</span><br><span class="line">        Sub sub = <span class="keyword">new</span> Sub();</span><br><span class="line">        System.out.println(<span class="string">"sub.field = "</span> + sub.field + </span><br><span class="line">                          <span class="string">", sub.getField() = "</span> + sub.getField()</span><br><span class="line">                          + <span class="string">", sub.getSuperField() = "</span> + sub.getSuperField())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sup.field = 0, sup.getField() = 1</span><br><span class="line">sub.field = 1, sub.getField() = 1, sub.getSuperField() = 0</span><br></pre></td></tr></table></figure><p>当 <strong>Sub</strong> 对象向上转型为 <strong>Super</strong> 引用时，任何属性访问都被编译器解析，因此不是多态的。在这个例子中，<strong>Super.field</strong> 和 <strong>Sub.field</strong> 被分配了不同的存储空间，因此，<strong>Sub</strong> 实际上包含了两个称为 <strong>field</strong> 的属性：它自己的和来自 <strong>Super</strong> 的。然而，在引用 <strong>Sub</strong> 的 <strong>field</strong> 时，默认的 <strong>field</strong> 属性并不是 <strong>Super</strong> 版本的 <strong>field</strong> 属性。为了获取 <strong>Super</strong> 的 <strong>field</strong> 属性，需要显式地指明 <strong>super.field</strong>。</p><p>尽管这看起来是个令人困惑的问题，实际上基本不会发生。首先，通常会将所有的属性都指明为 <strong>private</strong>，因此不能直接访问它们，只能通过方法来访问。此外，你可能也不会给基类属性和派生类属性起相同的名字，这样做会令人困惑。</p><p>如果一个方法是静态(<strong>static</strong>)的，它的行为就不具有多态性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polymorphism/StaticPolymorphism.java</span></span><br><span class="line"><span class="comment">// static methods are not polymorphic</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticSuper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">staticGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Base staticGet()"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dynamicGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Base dynamicGet()"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticSub</span> <span class="keyword">extends</span> <span class="title">StaticSuper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">staticGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Derived staticGet()"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dynamicGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Derived dynamicGet()"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticPolymorphism</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StaticSuper sup = <span class="keyword">new</span> StaticSub(); <span class="comment">// Upcast</span></span><br><span class="line">        System.out.println(StaticSuper.staticGet());</span><br><span class="line">        System.out.println(sup.dynamicGet());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base staticGet()</span><br><span class="line">Derived dynamicGet()</span><br></pre></td></tr></table></figure><p>静态的方法只与类关联，与单个的对象无关。</p><!-- Constructors and Polymorphism --><h2 id="构造器和多态"><a href="#构造器和多态" class="headerlink" title="构造器和多态"></a>构造器和多态</h2><p>通常，构造器不同于其他类型的方法。在涉及多态时也是如此。尽管构造器不具有多态性（事实上人们会把它看作是隐式声明的静态方法），但是理解构造器在复杂层次结构中运作多态还是非常重要的。这个理解可以帮助你避免一些不愉快的困扰。</p><h3 id="构造器调用顺序"><a href="#构造器调用顺序" class="headerlink" title="构造器调用顺序"></a>构造器调用顺序</h3><p>在“初始化和清理”和“复用”两章中已经简单地介绍过构造器的调用顺序，但那时还没有介绍多态。</p><p>在派生类的构造过程中总会调用基类的构造器。初始化会自动按继承层次结构上移，因此每个基类的构造器都会被调用到。这么做是有意义的，因为构造器有着特殊的任务：检查对象是否被正确地构造。由于属性通常声明为 <strong>private</strong>，你必须假定派生类只能访问自己的成员而不能访问基类的成员。只有基类的构造器拥有恰当的知识和权限来初始化自身的元素。因此，必须得调用所有构造器；否则就不能构造完整的对象。这就是为什么编译器会强制调用每个派生类中的构造器的原因。如果在派生类的构造器主体中没有显式地调用基类构造器，编译器就会默默地调用无参构造器。如果没有无参构造器，编译器就会报错（当类中不含构造器时，编译器会自动合成一个无参构造器）。</p><p>下面的例子展示了组合、继承和多态在构建顺序上的作用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polymorphism/Sandwich.java</span></span><br><span class="line"><span class="comment">// Order of constructor calls</span></span><br><span class="line"><span class="comment">// &#123;java polymorphism.Sandwich&#125;</span></span><br><span class="line"><span class="keyword">package</span> polymorphism;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meal</span> </span>&#123;</span><br><span class="line">    Meal() &#123;</span><br><span class="line">        System.out.println(<span class="string">"Meal()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bread</span> </span>&#123;</span><br><span class="line">    Bread() &#123;</span><br><span class="line">        System.out.println(<span class="string">"Bread()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cheese</span> </span>&#123;</span><br><span class="line">    Cheese() &#123;</span><br><span class="line">        System.out.println(<span class="string">"Cheese()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lettuce</span> </span>&#123;</span><br><span class="line">    Lettuce() &#123;</span><br><span class="line">        System.out.println(<span class="string">"Lettuce()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lunch</span> <span class="keyword">extends</span> <span class="title">Meal</span> </span>&#123;</span><br><span class="line">    Lunch() &#123;</span><br><span class="line">        System.out.println(<span class="string">"Lunch()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PortableLunch</span> <span class="keyword">extends</span> <span class="title">Lunch</span> </span>&#123;</span><br><span class="line">    PortableLunch() &#123;</span><br><span class="line">        System.out.println(<span class="string">"PortableLunch()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sandwich</span> <span class="keyword">extends</span> <span class="title">PortableLunch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Bread b = <span class="keyword">new</span> Bread();</span><br><span class="line">    <span class="keyword">private</span> Cheese c = <span class="keyword">new</span> Cheese();</span><br><span class="line">    <span class="keyword">private</span> Lettuce l = <span class="keyword">new</span> Lettuce();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sandwich</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sandwich()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Sandwich();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Meal()</span><br><span class="line">Lunch()</span><br><span class="line">PortableLunch()</span><br><span class="line">Bread()</span><br><span class="line">Cheese()</span><br><span class="line">Lettuce()</span><br><span class="line">Sandwich()</span><br></pre></td></tr></table></figure><p>这个例子用其他类创建了一个复杂的类。每个类都在构造器中声明自己。重要的类是 <strong>Sandwich</strong>，它反映了三层继承（如果算上 <strong>Object</strong> 的话，就是四层），包含了三个成员对象。</p><p>从创建 <strong>Sandwich</strong> 对象的输出中可以看出对象的构造器调用顺序如下：</p><ol><li>基类构造器被调用。这个步骤被递归地重复，这样一来类层次的顶级父类会被最先构造，然后是它的派生类，以此类推，直到最底层的派生类。</li><li>按声明顺序初始化成员。</li><li>调用派生类构造器的方法体。</li></ol><p>构造器的调用顺序很重要。当使用继承时，就已经知道了基类的一切，并可以访问基类中任意 <strong>public</strong> 和 <strong>protected</strong> 的成员。这意味着在派生类中可以假定所有的基类成员都是有效的。在一个标准方法中，构造动作已经发生过，对象其他部分的所有成员都已经创建好。</p><p>在构造器中必须确保所有的成员都已经构建完。唯一能保证这点的方法就是首先调用基类的构造器。接着，在派生类的构造器中，所有你可以访问的基类成员都已经初始化。另一个在构造器中能知道所有成员都是有效的理由是：无论何时有可能的话，你应该在所有成员对象（通过组合将对象置于类中）定义处初始化它们（例如，例子中的 <strong>b</strong>、<strong>c</strong> 和 <strong>l</strong>）。如果遵循这条实践，就可以帮助确保所有的基类成员和当前对象的成员对象都已经初始化。</p><p>不幸的是，这不能处理所有情况，在下一节会看到。</p><h3 id="继承和清理"><a href="#继承和清理" class="headerlink" title="继承和清理"></a>继承和清理</h3><p>在使用组合和继承创建新类时，大部分时候你无需关心清理。子对象通常会留给垃圾收集器处理。如果你存在清理问题，那么必须用心地为新类创建一个 <code>dispose()</code> 方法（这里用的是我选择的名称，你可以使用更好的名称）。由于继承，如果有其他特殊的清理工作的话，就必须在派生类中重写 <code>dispose()</code> 方法。当重写 <code>dispose()</code> 方法时，记得调用基类的 <code>dispose()</code> 方法，否则基类的清理工作不会发生：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polymorphism/Frog.java</span></span><br><span class="line"><span class="comment">// Cleanup and inheritance</span></span><br><span class="line"><span class="comment">// &#123;java polymorphism.Frog&#125;</span></span><br><span class="line"><span class="keyword">package</span> polymorphism;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Characteristic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line">    </span><br><span class="line">    Characteristic(String s) &#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        System.out.println(<span class="string">"Creating Characteristic "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"disposing Characteristic "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Description</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line">    </span><br><span class="line">    Description(String s) &#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        System.out.println(<span class="string">"Creating Description "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"disposing Description "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LivingCreature</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Characteristic p = <span class="keyword">new</span> Characteristic(<span class="string">"is alive"</span>);</span><br><span class="line">    <span class="keyword">private</span> Description t = <span class="keyword">new</span> Description(<span class="string">"Basic Living Creature"</span>);</span><br><span class="line">    </span><br><span class="line">    LivingCreature() &#123;</span><br><span class="line">        System.out.println(<span class="string">"LivingCreature()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"LivingCreature dispose"</span>);</span><br><span class="line">        t.dispose();</span><br><span class="line">        p.dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="keyword">extends</span> <span class="title">LivingCreature</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Characteristic p = <span class="keyword">new</span> Characteristic(<span class="string">"has heart"</span>);</span><br><span class="line">    <span class="keyword">private</span> Description t = <span class="keyword">new</span> Description(<span class="string">"Animal not Vegetable"</span>);</span><br><span class="line">    </span><br><span class="line">    Animal() &#123;</span><br><span class="line">        System.out.println(<span class="string">"Animal()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Animal dispose"</span>);</span><br><span class="line">        t.dispose();</span><br><span class="line">        p.dispose();</span><br><span class="line">        <span class="keyword">super</span>.dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Amphibian</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Characteristic p = <span class="keyword">new</span> Characteristic(<span class="string">"can live in water"</span>);</span><br><span class="line">    <span class="keyword">private</span> Description t = <span class="keyword">new</span> Description(<span class="string">"Both water and land"</span>);</span><br><span class="line">    </span><br><span class="line">    Amphibian() &#123;</span><br><span class="line">        System.out.println(<span class="string">"Amphibian()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Amphibian dispose"</span>);</span><br><span class="line">        t.dispose();</span><br><span class="line">        p.dispose();</span><br><span class="line">        <span class="keyword">super</span>.dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Frog</span> <span class="keyword">extends</span> <span class="title">Amphibian</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Characteristic p = <span class="keyword">new</span> Characteristic(<span class="string">"Croaks"</span>);</span><br><span class="line">    <span class="keyword">private</span> Description t = <span class="keyword">new</span> Description(<span class="string">"Eats Bugs"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Frog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Frog()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Frog dispose"</span>);</span><br><span class="line">        t.dispose();</span><br><span class="line">        p.dispose();</span><br><span class="line">        <span class="keyword">super</span>.dispose();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Frog frog = <span class="keyword">new</span> Frog();</span><br><span class="line">        System.out.println(<span class="string">"Bye!"</span>);</span><br><span class="line">        frog.dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Creating Characteristic is alive</span><br><span class="line">Creating Description Basic Living Creature</span><br><span class="line">LivingCreature()</span><br><span class="line">Creating Characteristiv has heart</span><br><span class="line">Creating Description Animal not Vegetable</span><br><span class="line">Animal()</span><br><span class="line">Creating Characteristic can live in water</span><br><span class="line">Creating Description Both water and land</span><br><span class="line">Amphibian()</span><br><span class="line">Creating Characteristic Croaks</span><br><span class="line">Creating Description Eats Bugs</span><br><span class="line">Frog()</span><br><span class="line">Bye!</span><br><span class="line">Frog dispose</span><br><span class="line">disposing Description Eats Bugs</span><br><span class="line">disposing Characteristic Croaks</span><br><span class="line">Amphibian dispose</span><br><span class="line">disposing Description Both wanter and land</span><br><span class="line">disposing Characteristic can live in water</span><br><span class="line">Animal dispose</span><br><span class="line">disposing Description Animal not Vegetable</span><br><span class="line">disposing Characteristic has heart</span><br><span class="line">LivingCreature dispose</span><br><span class="line">disposing Description Basic Living Creature</span><br><span class="line">disposing Characteristic is alive</span><br></pre></td></tr></table></figure><p>层级结构中的每个类都有 <strong>Characteristic</strong> 和 <strong>Description</strong> 两个类型的成员对象，它们必须得被销毁。销毁的顺序应该与初始化的顺序相反，以防一个对象依赖另一个对象。对于属性来说，就意味着与声明的顺序相反（因为属性是按照声明顺序初始化的）。对于基类（遵循 C++ 析构函数的形式），首先进行派生类的清理工作，然后才是基类的清理。这是因为派生类的清理可能调用基类的一些方法，所以基类组件这时得存活，不能过早地被销毁。输出显示了，<strong>Frog</strong> 对象的所有部分都是按照创建的逆序销毁的。</p><p>尽管通常不必进行清理工作，但万一需要时，就得谨慎小心地执行。</p><p><strong>Frog</strong> 对象拥有自己的成员对象，它创建了这些成员对象，并且知道它们能存活多久，所以它知道何时调用 <code>dispose()</code> 方法。然而，一旦某个成员对象被其它一个或多个对象共享时，问题就变得复杂了，不能只是简单地调用 <code>dispose()</code>。这里，也许就必须使用<em>引用计数</em>来跟踪仍然访问着共享对象的对象数量，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polymorphism/ReferenceCounting.java</span></span><br><span class="line"><span class="comment">// Cleaning up shared member objects</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shared</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> refcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line">    </span><br><span class="line">    Shared() &#123;</span><br><span class="line">        System.out.println(<span class="string">"Creating "</span> + <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        refcount++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (--refcount == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Disposing "</span> + <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Shared "</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Composing</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Shared shared;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line">    </span><br><span class="line">    Composing(Shared shared) &#123;</span><br><span class="line">        System.out.println(<span class="string">"Creating "</span> + <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.shared = shared;</span><br><span class="line">        <span class="keyword">this</span>.shared.addRef();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"disposing "</span> + <span class="keyword">this</span>);</span><br><span class="line">        shared.dispose();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Composing "</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCounting</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Shared shared = <span class="keyword">new</span> Shared();</span><br><span class="line">        Composing[] composing = &#123;</span><br><span class="line">            <span class="keyword">new</span> Composing(shared),</span><br><span class="line">            <span class="keyword">new</span> Composing(shared),</span><br><span class="line">            <span class="keyword">new</span> Composing(shared),</span><br><span class="line">            <span class="keyword">new</span> Composing(shared),</span><br><span class="line">            <span class="keyword">new</span> Composing(shared),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (Composing c: composing) &#123;</span><br><span class="line">            c.dispose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Creating Shared 0</span><br><span class="line">Creating Composing 0</span><br><span class="line">Creating Composing 1</span><br><span class="line">Creating Composing 2</span><br><span class="line">Creating Composing 3</span><br><span class="line">Creating Composing 4</span><br><span class="line">disposing Composing 0</span><br><span class="line">disposing Composing 1</span><br><span class="line">disposing Composing 2</span><br><span class="line">disposing Composing 3</span><br><span class="line">disposing Composing 4</span><br><span class="line">Disposing Shared 0</span><br></pre></td></tr></table></figure><p><strong>static long counter</strong> 跟踪所创建的 <strong>Shared</strong> 实例数量，还提供了 <strong>id</strong> 的值。<strong>counter</strong> 的类型是 <strong>long</strong> 而不是 <strong>int</strong>，以防溢出（这只是个良好实践，对于本书的所有示例，<strong>counter</strong> 不会溢出）。<strong>id</strong> 是 <strong>final</strong> 的，因为它的值在初始化时确定后不应该变化。</p><p>在将一个 <strong>shared</strong> 对象附着在类上时，必须记住调用 <code>addRef()</code>，而 <code>dispose()</code> 方法会跟踪引用数，以确定在何时真正地执行清理工作。使用这种技巧需要加倍细心，但是如果正在共享需要被清理的对象，就没有太多选择了。</p><h3 id="构造器内部多态方法的行为"><a href="#构造器内部多态方法的行为" class="headerlink" title="构造器内部多态方法的行为"></a>构造器内部多态方法的行为</h3><p>构造器调用的层次结构带来了一个困境。如果在构造器中调用了正在构造的对象的动态绑定方法，会发生什么呢？</p><p>在普通的方法中，动态绑定的调用是在运行时解析的，因为对象不知道它属于方法所在的类还是类的派生类。</p><p>如果在构造器中调用了动态绑定方法，就会用到那个方法的重写定义。然而，调用的结果难以预料因为被重写的方法在对象被完全构造出来之前已经被调用，这使得一些 bug 很隐蔽，难以发现。</p><p>从概念上讲，构造器的工作就是创建对象（这并非是平常的工作）。在构造器内部，整个对象可能只是部分形成——只知道基类对象已经初始化。如果构造器只是构造对象过程中的一个步骤，且构造的对象所属的类是从构造器所属的类派生出的，那么派生部分在当前构造器被调用时还没有初始化。然而，一个动态绑定的方法调用向外深入到继承层次结构中，它可以调用派生类的方法。如果你在构造器中这么做，就可能调用一个方法，该方法操纵的成员可能还没有初始化——这肯定会带来灾难。</p><p>下面例子展示了这个问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polymorphism/PolyConstructors.java</span></span><br><span class="line"><span class="comment">// Constructors and polymorphism</span></span><br><span class="line"><span class="comment">// don't produce what you might expect</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Glyph</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Glyph.draw()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Glyph() &#123;</span><br><span class="line">        System.out.println(<span class="string">"Glyph() before draw()"</span>);</span><br><span class="line">        draw();</span><br><span class="line">        System.out.println(<span class="string">"Glyph() after draw()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoundGlyph</span> <span class="keyword">extends</span> <span class="title">Glyph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> radius = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    RoundGlyph(<span class="keyword">int</span> r) &#123;</span><br><span class="line">        radius = r;</span><br><span class="line">        System.out.println(<span class="string">"RoundGlyph.RoundGlyph(), radius = "</span> + radius);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"RoundGlyph.draw(), radius = "</span> + radius);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolyConstructors</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> RoundGlyph(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Glyph() before draw()</span><br><span class="line">RoundGlyph.draw(), radius = 0</span><br><span class="line">Glyph() after draw()</span><br><span class="line">RoundGlyph.RoundGlyph(), radius = 5</span><br></pre></td></tr></table></figure><p><strong>Glyph</strong> 的 <code>draw()</code> 被设计为可重写，在 <strong>RoundGlyph</strong> 这个方法被重写。但是 <strong>Glyph</strong> 的构造器里调用了这个方法，结果调用了 <strong>RoundGlyph</strong> 的 <code>draw()</code> 方法，这看起来正是我们的目的。输出结果表明，当 <strong>Glyph</strong> 构造器调用了 <code>draw()</code> 时，<strong>radius</strong> 的值不是默认初始值 1 而是 0。这可能会导致在屏幕上只画了一个点或干脆什么都不画，于是我们只能干瞪眼，试图找到程序不工作的原因。</p><p>前一小节描述的初始化顺序并不十分完整，而这正是解决谜团的关键所在。初始化的实际过程是：</p><ol><li>在所有事发生前，分配给对象的存储空间会被初始化为二进制 0。</li><li>如前所述调用基类构造器。此时调用重写后的 <code>draw()</code> 方法（是的，在调用 <strong>RoundGraph</strong> 构造器之前调用），由步骤 1 可知，<strong>radius</strong> 的值为 0。</li><li>按声明顺序初始化成员。</li><li>最终调用派生类的构造器。</li></ol><p>这么做有个优点：所有事物至少初始化为 0（或某些特殊数据类型与 0 等价的值），而不是仅仅留作垃圾。这包括了通过组合嵌入类中的对象引用，被赋予 <strong>null</strong>。如果忘记初始化该引用，就会在运行时出现异常。观察输出结果，就会发现所有事物都是 0。</p><p>另一方面，应该震惊于输出结果。逻辑方面我们已经做得非常完美，然而行为仍不可思议的错了，编译器也没有报错（C++ 在这种情况下会产生更加合理的行为）。像这样的 bug 很容易被忽略，需要花很长时间才能发现。</p><p>因此，编写构造器有一条良好规范：做尽量少的事让对象进入良好状态。如果有可能的话，尽量不要调用类中的任何方法。在基类的构造器中能安全调用的只有基类的 <strong>final</strong> 方法（这也适用于可被看作是 <strong>final</strong> 的 <strong>private</strong> 方法）。这些方法不能被重写，因此不会产生意想不到的结果。你可能无法永远遵循这条规范，但应该朝着它努力。</p><!-- Covariant Return Types --><h2 id="协变返回类型"><a href="#协变返回类型" class="headerlink" title="协变返回类型"></a>协变返回类型</h2><p>Java 5 中引入了协变返回类型，这表示派生类的被重写方法可以返回基类方法返回类型的派生类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polymorphism/CovariantReturn.java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grain</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Grain"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wheat</span> <span class="keyword">extends</span> <span class="title">Grain</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Wheat"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mill</span> </span>&#123;</span><br><span class="line">    <span class="function">Grain <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Grain();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WheatMill</span> <span class="keyword">extends</span> <span class="title">Mill</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Wheat <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Wheat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantReturn</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mill m = <span class="keyword">new</span> Mill();</span><br><span class="line">        Grain g = m.process();</span><br><span class="line">        System.out.println(g);</span><br><span class="line">        m = <span class="keyword">new</span> WheatMill();</span><br><span class="line">        g = m.process();</span><br><span class="line">        System.out.println(g);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Grain</span><br><span class="line">Wheat</span><br></pre></td></tr></table></figure><p>关键区别在于 Java 5 之前的版本强制要求被重写的 <code>process()</code> 方法必须返回 <strong>Grain</strong> 而不是 <strong>Wheat</strong>，即使 <strong>Wheat</strong> 派生自 <strong>Grain</strong>，因而也应该是一种合法的返回类型。协变返回类型允许返回更具体的 <strong>Wheat</strong> 类型。</p><!-- Designing with Inheritance --><h2 id="使用继承设计"><a href="#使用继承设计" class="headerlink" title="使用继承设计"></a>使用继承设计</h2><p>学习过多态之后，一切看似都可以被继承，因为多态是如此巧妙的工具。这会给设计带来负担。事实上，如果利用已有类创建新类首先选择继承的话，事情会变得莫名的复杂。</p><p>更好的方法是首先选择组合，特别是不知道该使用哪种方法时。组合不会强制设计是继承层次结构，而且组合更加灵活，因为可以动态地选择类型（因而选择相应的行为），而继承要求必须在编译时知道确切类型。下面例子说明了这点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polymorphism/Transmogrify.java</span></span><br><span class="line"><span class="comment">// Dynamically changing the behavior of an object</span></span><br><span class="line"><span class="comment">// via composition (the "State" design pattern)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">act</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HappyActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">act</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HappyActor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SadActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">act</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SadActor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Actor actor = <span class="keyword">new</span> HappyActor();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        actor = <span class="keyword">new</span> SadActor();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        actor.act();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transmogrify</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stage stage = <span class="keyword">new</span> Stage();</span><br><span class="line">        stage.performPlay();</span><br><span class="line">        stage.change();</span><br><span class="line">        stage.performPlay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HappyActor</span><br><span class="line">SadActor</span><br></pre></td></tr></table></figure><p><strong>Stage</strong> 对象中包含了 <strong>Actor</strong> 引用，该引用被初始化为指向一个 <strong>HappyActor</strong> 对象，这意味着 <code>performPlay()</code> 会产生一个特殊行为。但是既然引用可以在运行时与其他不同的对象绑定，那么它就可以被替换成对 <strong>SadActor</strong> 的引用，<code>performPlay()</code> 的行为随之改变。这样你就获得了运行时的动态灵活性（这被称为状态模式）。与之相反，我们不能在运行时决定继承不同的对象，那在编译时就完全确定下来了。</p><p>有一条通用准则：使用继承表达行为的差异，使用属性表达状态的变化。在上个例子中，两者都用到了。通过继承得到的两个不同类在 <code>act()</code> 方法中表达了不同的行为，<strong>Stage</strong> 通过组合使自己的状态发生变化。这里状态的改变产生了行为的改变。</p><h3 id="替代-vs-扩展"><a href="#替代-vs-扩展" class="headerlink" title="替代 vs 扩展"></a>替代 vs 扩展</h3><p>采用“纯粹”的方式创建继承层次结构看上去是最清晰的方法。即只有基类的方法才能在派生类中被重写</p><p>这被称作纯粹的“is - a”关系，因为类的接口已经确定了它是什么。继承可以确保任何派生类都拥有基类的接口，绝对不会少。如果按图上这么做，派生类将只拥有基类的接口。</p><p>纯粹的替代意味着派生类可以完美地替代基类，当使用它们时，完全不需要知道这些子类的信息。也就是说，基类可以接收任意发送给派生类的消息，因为它们具有完全相同的接口。只需将派生类向上转型，不要关注对象的具体类型。所有一切都可以通过多态处理。</p><p>按这种方式思考，似乎只有纯粹的“is - a”关系才是唯一明智的做法，其他任何设计只会导致混乱且注定失败。这其实也是个陷阱。一旦按这种方式开始思考，就会转而发现继承扩展接口（遗憾的是，extends 关键字似乎怂恿我们这么做）才是解决特定问题的完美方案。这可以称为“is - like - a” 关系，因为派生类就像是基类——它有着相同的基本接口，但还具有需要额外方法实现的其他特性：</p><p>虽然这是一种有用且明智的方法（依赖具体情况），但是也存在缺点。派生类中接口的扩展部分在基类中不存在（不能通过基类访问到这些扩展接口），因此一旦向上转型，就不能通过基类调用这些新方法：</p><p>如果不向上转型，就不会遇到这个问题。但是通常情况下，我们需要重新查明对象的确切类型，从而能够访问该类型中的扩展方法。下一节说明如何做到这点。</p><h3 id="向下转型与运行时类型信息"><a href="#向下转型与运行时类型信息" class="headerlink" title="向下转型与运行时类型信息"></a>向下转型与运行时类型信息</h3><p>由于向上转型（在继承层次中向上移动）会丢失具体的类型信息，那么为了重新获取类型信息，就需要在继承层次中向下移动，使用<em>向下转型</em>。</p><p>向上转型永远是安全的，因为基类不会具有比派生类更多的接口。因此，每条发送给基类接口的消息都能被接收。但是对于向下转型，你无法知道一个形状是圆，它有可能是三角形、正方形或其他一些类型。</p><p>为了解决这个问题，必须得有某种方法确保向下转型是正确的，防止意外转型到一个错误类型，进而发送对象无法接收的消息。这么做是不安全的。</p><p>在某些语言中（如 C++），必须执行一个特殊的操作来获得安全的向下转型，但是在 Java 中，每次转型都会被检查！所以即使只是进行一次普通的加括号形式的类型转换，在运行时这个转换仍会被检查，以确保它的确是希望的那种类型。如果不是，就会得到 ClassCastException （类转型异常）。这种在运行时检查类型的行为称作运行时类型信息。下面例子展示了 RTTI 的行为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polymorphism/RTTI.java</span></span><br><span class="line"><span class="comment">// Downcasting &amp; Runtime type information (RTTI)</span></span><br><span class="line"><span class="comment">// &#123;ThrowsException&#125;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Useful</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MoreUseful</span> <span class="keyword">extends</span> <span class="title">Useful</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">u</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">v</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">w</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RTTI</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Useful[] x = &#123;</span><br><span class="line">            <span class="keyword">new</span> Useful(),</span><br><span class="line">            <span class="keyword">new</span> MoreUseful()</span><br><span class="line">        &#125;;</span><br><span class="line">        x[<span class="number">0</span>].f();</span><br><span class="line">        x[<span class="number">1</span>].g();</span><br><span class="line">        <span class="comment">// Compile time: method not found in Useful:</span></span><br><span class="line">        <span class="comment">//- x[1].u();</span></span><br><span class="line">        ((MoreUseful) x[<span class="number">1</span>]).u(); <span class="comment">// Downcast/RTTI</span></span><br><span class="line">        ((MoreUseful) x[<span class="number">0</span>]).u(); <span class="comment">// Exception thrown</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot;</span><br><span class="line">java.lang.ClassCastException: Useful cannot be cast to</span><br><span class="line">MoreUseful</span><br><span class="line">at RTTI.main</span><br></pre></td></tr></table></figure><p>正如前面类图所示，<strong>MoreUseful</strong> 扩展了 <strong>Useful</strong> 的接口。而 <strong>MoreUseful</strong> 也继承了 <strong>Useful</strong>，所以它可以向上转型为 <strong>Useful</strong>。在 <code>main()</code> 方法中可以看到这种情况的发生。因为两个对象都是 <strong>Useful</strong> 类型，所以对它们都可以调用 <code>f()</code> 和 <code>g()</code> 方法。如果试图调用 <code>u()</code> 方法（只存在于 <strong>MoreUseful</strong> 中），就会得到编译时错误信息。</p><p>为了访问 <strong>MoreUseful</strong> 对象的扩展接口，就得尝试向下转型。如果转型为正确的类型，就转型成功。否则，就会得到 ClassCastException 异常。你不必为这个异常编写任何特殊代码，因为它指出了程序员在程序的任何地方都可能犯的错误。<strong>{ThrowsException}</strong> 注释标签告知本书的构建系统：在运行程序时，预期抛出一个异常。</p><p>RTTI 不仅仅包括简单的转型。例如，它还提供了一种方法，使你可以在试图向下转型前检查所要处理的类型。“类型信息”一章中会详细阐述运行时类型信息的方方面面。</p><!-- Summary --><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>多态意味着“不同的形式”。在面向对象编程中，我们持有从基类继承而来的相同接口和使用该接口的不同形式：不同版本的动态绑定方法。</p><p>在本章中，你可以看到，如果不使用数据抽象和继承，就不可能理解甚至创建多态的例子。多态是一种不能单独看待的特性（比如像 <strong>switch</strong> 语句那样），它只能作为类关系全景中的一部分，与其他特性协同工作。</p><p>为了在程序中有效地使用多态乃至面向对象的技术，就必须扩展自己的编程视野，不能只看到单一类中的成员和消息，而要看到类之间的共同特性和它们之间的关系。尽管这需要很大的努力，但是这么做是值得的。它能带来更快的程序开发、更好的代码组织、扩展性更好的程序和更易维护的代码。</p><p>但是记住，多态可能被滥用。仔细分析代码以确保多态确实能带来好处。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://lingcoder.github.io/OnJava8/#/book/09-Polymorphism" target="_blank" rel="noopener">https://lingcoder.github.io/OnJava8/#/book/09-Polymorphism</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第九章 多态&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java编程思想-第二十四章 并发编程阅读笔记</title>
    <link href="http://yoursite.com/2020/06/06/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%9B%9B%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/06/06/Java编程思想-第二十四章 并发编程阅读笔记/</id>
    <published>2020-06-06T14:12:12.000Z</published>
    <updated>2020-06-06T15:43:53.542Z</updated>
    
    <content type="html"><![CDATA[<p>第二十四章 并发编程</p><a id="more"></a><p>在本章之前，我们惯用一种简单顺序的叙事方式来编程，有点类似文学中的意识流：第一件事发生了，然后是第二件，第三件……总之，我们完全掌握着事情发生的进展和顺序。如果将值设置为5，再看时它已变成47的话，结果就很匪夷所思了。</p><p>现在，我们来到了陌生的并发世界。这样的结果一点都不奇怪，因为你原来信赖的一切都不再可靠。它可能有效，也可能无效。更可能得是，它在某些情况下会起作用，而在另一些情况下则不会。只有了解了这些情况，我们才能正确地行事。</p><p>作为类比，我们正常生活是发生在经典牛顿力学中的。物体具有质量：会坠落并转移动量。电线有电阻，光直线传播。假如我们进入极小、极热、极冷、或是极大的世界（我们不能生存），这些现象就会发生变化。我们无法判断某物体是粒子还是波，光是否受到重力影响，一些物质还会变为超导体。</p><p>假设我们处在多条故事线并行的间谍小说里，非单一意识流地叙事：第一个间谍在岩石底留下了微缩胶片。当第二个间谍来取时，胶片可能已被第三个间谍拿走。小说并没有交代此处的细节。所以直到故事结尾，我们都没搞清楚到底发生了什么。</p><p>构建并发程序好比玩<a href="https://en.wikipedia.org/wiki/Jenga" target="_blank" rel="noopener">搭积木</a>游戏。每拉出一块放在塔顶时都有崩塌的可能。每个积木塔和应用程序都是独一无二的，有着自己的作用。你在某个系统构建中学到的知识并不一定适用于下一个系统。</p><p>本章是对并发概念最基本的介绍。虽然我们用到了现代的 Java 8 工具来演示原理，但还远未及全面论述并发。我的目标是为你提供足够的基础知识，使你能够把握问题的复杂性和危险性，从而安全地渡过这片鲨鱼肆虐的困难水域。</p><p>更多繁琐和底层的细节，请参阅《并发底层原理》。要进一步深入这个领域，你还必须阅读 <em>Brian Goetz</em> 等人的 《Java Concurrency in Practice》。在撰写本文时，该书已有十多年的历史了，但它仍包含我们必须要了解和明白的知识要点。理想情况下，本章和上述附录是阅读该书的良好前提。另外，<em>Bill Venner</em> 的 《Inside the Java Virtual Machine》也很值得一看。它详细描述了 JVM 的内部工作方式，包括线程。</p><!-- The Terminology Problem --><h2 id="术语问题"><a href="#术语问题" class="headerlink" title="术语问题"></a>术语问题</h2><p>术语“并发”，“并行”，“多任务”，“多处理”，“多线程”，分布式系统（可能还有其他）在整个编程文献中都以多种相互冲突的方式使用，并且经常被混为一谈。<br><em>Brian Goetz</em> 在他 2016 年《从并发到并行》的演讲中指出了这一点，之后提出了合理的二分法：</p><ul><li><p>并发是关于正确有效地控制对共享资源的访问。</p></li><li><p>并行是使用额外的资源来更快地产生结果。</p></li></ul><p>这些定义很好，但是我们已有几十年混乱使用和抗拒解决此问题的历史了。一般来说，当人们使用“并发”这个词时，他们的意思是“所有的一切”。事实上，我自己也经常陷入这样的想法。在大多数书籍中，包括 <em>Brian Goetz</em> 的 《Java Concurrency in Practice》，都在标题中使用这个词。</p><p>“并发”通常表示：不止一个任务正在执行。而“并行”几乎总是代表：不止一个任务同时执行。现在你能看到问题所在了吗？“并行”也有不止一个任务正在执行的语义在里面。区别就在于细节：究竟是怎么“执行”的。此外，还有一些场景重叠：为并行编写的程序有时在单处理器上运行，而一些并发编程系统可以利用多处理器。</p><p>还有另一种方法，在减速发生的地方写下定义（原文Here’s another approach, writing the definitions around where the<br>slowdown occurs）：</p><p><strong>并发</strong></p><p>同时完成多任务。无需等待当前任务完成即可执行其他任务。“并发”解决了程序因外部控制而无法进一步执行的阻塞问题。最常见的例子就是 I/O 操作，任务必须等待数据输入（在一些例子中也称阻塞）。这个问题常见于 I/O 密集型任务。</p><p><strong>并行</strong></p><p>同时在多个位置完成多任务。这解决了所谓的 CPU 密集型问题：将程序分为多部分，在多个处理器上同时处理不同部分来加快程序执行效率。</p><p>上面的定义告诉了我们术语令人困惑的原因：两者的核心是“同时完成多个任务”。并行增加了跨多个处理器的分布。更重要的是，这两种方法可以解决不同类型的问题：解决I / O绑定问题和并行化可能对您没有任何好处，因为该问题不是整体速度，而是阻塞。采取计算约束问题并尝试在单个处理器上使用并发性解决问题可能会浪费时间。两种方法都试图在更短的时间内完成更多工作，但是它们实现加速的方式却有所不同，并且取决于问题所施加的约束。</p><p>术语混淆的原因在上面的定义中显示：其中核心是“在同一时间完成多个任务。”并行性通过多个处理器增加分布。更重要的是，两者解决了不同类型的问题：解决I/O密集型问题，并行化可能对你没有任何好处，因为问题不是整体速度，而是阻塞。并且考虑到计算力限制问题并试图在单个处理器上使用并发来解决它可能会浪费时间。两种方法都试图在更短的时间内完成更多，但它们实现加速的方式是不同的，并且取决于问题所带来的约束。</p><p>这两个概念混合在一起的一个主要原因是包括Java在内的许多编程语言使用相同的机制<strong>线程</strong>来实现并发和并行。</p><p>我们甚至可以尝试添加细致的粒度去定义（但是，这不是标准化的术语）：</p><ul><li><strong>纯并发</strong>：任务仍然在单个CPU上运行。纯并发系统产生的结果比顺序系统更快，但如果有更多的处理器，则运行速度不会更快</li><li><strong>并发-并行</strong>：使用并发技术，结果程序利用更多处理器并更快地生成结果</li><li><strong>并行-并发</strong>：使用并行编程技术编写，如果只有一个处理器，结果程序仍然可以运行（Java 8 <strong>Streams</strong>就是一个很好的例子）。</li><li><strong>纯并行</strong>：除非有多个处理器，否则不会运行。</li></ul><p>在某些情况下，这可能是一个有用的分类法。</p><p>对并发性的语言和库支持似乎<a href="https://en.wikipedia.org/wiki/Leaky_abstraction" target="_blank" rel="noopener">Leaky Abstraction</a>是完美候选者。抽象的目标是“抽象出”那些对于手头想法不重要的东西，从不必要的细节中汲取灵感。如果抽象是漏洞，那些碎片和细节会不断重新声明自己是重要的，无论你试图隐藏它们多少</p><p>我开始怀疑是否真的有高度抽象。当编写这些类型的程序时，你永远不会被底层系统和工具屏蔽，甚至关于CPU缓存如何工作的细节。最后，如果你非常小心，你创作的东西在特定的情况下起作用，但它在其他情况下不起作用。有时，区别在于两台机器的配置方式，或者程序的估计负载。这不是Java特有的-它是并发和并行编程的本质。</p><p>你可能会认为<a href="https://en.wikipedia.org/wiki/Purely_functional" target="_blank" rel="noopener">纯函数式</a>语言没有这些限制。实际上，纯函数式语言解决了大量并发问题，所以如果你正在解决一个困难的并发问题，你可以考虑用纯函数语言编写这个部分。但最终，如果你编写一个使用队列的系统，例如，如果它没有正确调整并且输入速率要么没有被正确估计或被限制（并且限制意味着,在不同情况下不同的东西具有不同的影响），该队列将填满并阻塞或溢出。最后，你必须了解所有细节，任何问题都可能会破坏你的系统。这是一种非常不同的编程方式</p><!-- A New Definition ofConcurrencyFor --><h3 id="并发的新定义"><a href="#并发的新定义" class="headerlink" title="并发的新定义"></a>并发的新定义</h3><p>并发问，其中一个最大的挑战一直是简单地定义它。可以定义它：</p><blockquote><p><strong>并发性是一系列性能技术，专注于减少等待</strong></p></blockquote><p>这实际上是一个相当多的声明，所以将其分解：</p><ul><li>这是一个集合：有许多不同的方法来解决这个问题。这是使定义并发性如此具有挑战性的问题之一，因为技术差别很大</li><li>这些是性能技术：就是这样。并发的关键点在于让你的程序运行得更快。在Java中，并发是非常棘手和困难的，所以绝对不要使用它，除非你有一个重大的性能问题 - 即使这样，使用最简单的方法产生你需要的性能，因为并发很快变得无法管理。</li><li>“减少等待”部分很重要而且微妙。无论（例如）你运行多少个处理器，你只能在等待某个地方时产生结果。如果你发起I/O请求并立即获得结果，没有延迟，因此无需改进。如果你在多个处理器上运行多个任务，并且每个处理器都以满容量运行，并且任何其他任务都没有等待，那么尝试提高吞吐量是没有意义的。并发的唯一形式是如果程序的某些部分被迫等待。等待可以以多种形式出现 - 这解释了为什么存在如此不同的并发方法。</li></ul><p>值得强调的是，这个定义的有效性取决于等待这个词。如果没有什么可以等待，那就没有机会了。如果有什么东西在等待，那么就会有很多方法可以加快速度，这取决于多种因素，包括系统运行的配置，你要解决的问题类型以及其他许多问题。</p><!-- Concurrency Superpowers --><h2 id="并发的超能力"><a href="#并发的超能力" class="headerlink" title="并发的超能力"></a>并发的超能力</h2><p>想象一下，你置身于一部科幻电影。你必须在高层建筑中搜索一个精心巧妙地隐藏在建筑物的一千万个房间之一中的单个物品。你进入建筑物并沿着走廊向下移动。走廊分开了。</p><p>你自己完成这项任务需要一百个生命周期。</p><p>现在假设你有一个奇怪的超能力。你可以将自己一分为二，然后在继续前进的同时将另一半送到另一个走廊。每当你在走廊或楼梯上遇到分隔到下一层时，你都会重复这个分裂的技巧。最终，整个建筑中的每个走廊的终点都有一个你。</p><p>每个走廊都有一千个房间。你的超能力变得有点弱，所以你只能分裂出50个自己来搜索这间房间。</p><p>一旦克隆体进入房间，它必须搜索房间的每个角落。这时它切换到了第二种超能力。它分裂成了一百万个纳米机器人，每个机器人都会飞到或爬到房间里一些看不见的地方。你不需要了解这种功能 - 一旦你开启它就会自动工作。在他们自己的控制下，纳米机器人开始行动，搜索房间然后回来重新组装成你，突然间，你获得了寻找的物品是否在房间内的消息。</p><p>我很想说，“并发就是刚才描述的置身于科幻电影中的超能力“就像你自己可以一分为二然后解决更多的问题一样简单。但是问题在于，我们来描述这种现象的任何模型最终都是泄漏抽象的（leaky abstraction)。</p><p>以下是其中一个漏洞：在理想的世界中，每次克隆自己时，你还会复制硬件处理器来运行该克隆。但当然不会发生这种情况 - 你的机器上可能有四个或八个处理器（通常在写入时）。你可能还有更多，并且仍有许多情况只有一个处理器。在抽象的讨论中，物理处理器的分配方式不仅可以泄漏，甚至可以支配你的决策</p><p>让我们在科幻电影中改变一些东西。现在当每个克隆搜索者最终到达一扇门时，他们必须敲门并等到有人回答。如果我们每个搜索者有一个处理器，这没有问题 - 处理器只是空闲，直到门被回答。但是如果我们只有8个处理器和数千个搜索者，那么只是因为搜索者恰好是因为处理器闲置了被锁，等待一扇门被接听。相反，我们希望将处理器应用于搜索，在那里它可以做一些真正的工作，因此需要将处理器从一个任务切换到另一个任务的机制。</p><p>许多型号能够有效地隐藏处理器的数量，并允许你假装你的数量非常大。但是有些情况会发生故障的时候，你必须知道处理器的数量，以便你可以解决这个问题。</p><p>其中一个最大的影响取决于你是单个处理器还是多个处理器。如果你只有一个处理器，那么任务切换的成本也由该处理器承担，将并发技术应用于你的系统会使它运行得更慢。</p><p>这可能会让你决定，在单个处理器的情况下，编写并发代码时没有意义。然而，有些情况下，并发模型会产生更简单的代码，实际上值得让它运行得更慢以实现。</p><p>在克隆体敲门等待的情况下，即使单处理器系统也能从并发中受益，因为它可以从等待（阻塞）的任务切换到准备好的任务。但是如果所有任务都可以一直运行那么切换的成本会降低一切，在这种情况下，如果你有多个进程，并发通常只会有意义。</p><p>在接听电话的客户服务部门，你只有一定数量的人，但是你可以拨打很多电话。那些人（处理器）必须一次拨打一个电话，直到完成电话和额外的电话必须排队。</p><p>在“鞋匠和精灵”的童话故事中，鞋匠做了很多工作，当他睡着时，一群精灵来为他制作鞋子。这里的工作是分布式的，但即使使用大量的物理处理器，在制造鞋子的某些部件时会产生限制 - 例如，如果鞋底需要制作鞋子，这会限制制鞋的速度并改变你设计解决方案的方式。</p><p>因此，你尝试解决的问题驱动解决方案的设计。打破一个“独立运行”问题的高级[原文：lovely ]抽象，然后就是实际发生的现实。物理现实不断侵入和震撼，这种抽象。</p><p>这只是问题的一部分。考虑一个制作蛋糕的工厂。我们不知何故在工人中分发了蛋糕制作任务，但是现在是时候让工人把蛋糕放在盒子里了。那里有一个盒子，准备收到蛋糕。但是，在工人将蛋糕放入盒子之前，另一名工人投入并将蛋糕放入盒子中！我们的工人已经把蛋糕放进去了，然后就开始了！这两个蛋糕被砸碎并毁了。这是常见的“共享内存”问题，产生我们称之为竞争条件的问题，其结果取决于哪个工作人员可以首先在框中获取蛋糕（通常使用锁定机制来解决问题，因此一个工作人员可以先抓住框并防止蛋糕砸）。</p><p>当“同时”执行的任务相互干扰时，会出现问题。他可以以如此微妙和偶然的方式发生，可能公平地说，并发性“可以说是确定性的，但实际上是非确定性的。”也就是说，你可以假设编写通过维护和代码检查正常工作的并发程序。然而，在实践中，编写仅看起来可行的并发程序更为常见，但是在适当的条件下，将会失败。这些情况可能会发生，或者很少发生，你在测试期间从未看到它们。实际上，编写测试代码通常无法为并发程序生成故障条件。由此产生的失败只会偶尔发生，因此它们以客户投诉的形式出现。<br>这是推动并发的最强有力的论据之一：如果你忽略它，你可能会被咬。</p><p>因此，并发似乎充满了危险，如果这让你有点害怕，这可能是一件好事。尽管Java 8在并发性方面做出了很大改进，但仍然没有像编译时验证(compile-time verification)或受检查的异常(checked exceptions)那样的安全网来告诉你何时出现错误。通过并发，你只能依靠自己，只有知识渊博，保持怀疑和积极进取的人，才能用Java编写可靠的并发代码。</p><!-- Concurrency is for Speed --><!-- 不知道是否可以找到之前翻译的针对速度感觉太直了 --><h2 id="并发为速度而生"><a href="#并发为速度而生" class="headerlink" title="并发为速度而生"></a>并发为速度而生</h2><p>在听说并发编程的问题之后，你可能会想知道它是否值得这么麻烦。答案是“不，除非你的程序运行速度不够快。”并且在决定它没有之前你会想要仔细思考。不要随便跳进并发编程的悲痛之中。如果有一种方法可以在更快的机器上运行你的程序，或者如果你可以对其进行分析并发现瓶颈并在该位置交换更快的算法，那么请执行此操作。只有在显然没有其他选择时才开始使用并发，然后仅在孤立的地方。</p><p>速度问题一开始听起来很简单：如果你想要一个程序运行得更快，将其分解成碎片并在一个单独的处理器上运行每个部分。由于我们能够提高时钟速度流（至少对于传统芯片），速度的提高是出现在多核处理器的形式而不是更快的芯片。为了使你的程序运行得更快，你必须学习利用那些超级处理器，这是并发性给你的一个建议。</p><p>使用多处理器机器，可以在这些处理器之间分配多个任务，这可以显着提高吞吐量。强大的多处理器Web服务器通常就是这种情况，它可以在程序中为CPU分配大量用户请求，每个请求分配一个线程。</p><p>但是，并发性通常可以提高在单个处理器上运行的程序的性能。这听起来有点违反直觉。如果考虑一下，由于上下文切换的成本增加（从一个任务更改为另一个任务），在单个处理器上运行的并发程序实际上应该比程序的所有部分顺序运行具有更多的开销。在表面上，将程序的所有部分作为单个任务运行并节省上下文切换的成本似乎更便宜。</p><p>可以产生影响的问题是阻塞。如果你的程序中的一个任务由于程序控制之外的某些条件（通常是I/O）而无法继续，我们会说任务或线程阻塞（在我们的科幻故事中，克隆体已敲门而且是等待它打开）。如果没有并发性，整个程序就会停止，直到外部条件发生变化。但是，如果使用并发编写程序，则当一个任务被阻止时，程序中的其他任务可以继续执行，因此程序继续向前移动。实际上，从性能的角度来看，在单处理器机器上使用并发是没有意义的，除非其中一个任务可能阻塞。</p><p>单处理器系统中性能改进的一个常见例子是事件驱动编程，特别是用户界面编程。考虑一个程序执行一些长时间运行操作，从而最终忽略用户输入和无响应。如果你有一个“退出”按钮，你不想在你编写的每段代码中轮询它。这会产生笨拙的代码，无法保证程序员不会忘记执行检查。没有并发性，生成响应式用户界面的唯一方法是让所有任务定期检查用户输入。通过创建单独的执行线程来响应用户输入，该程序保证了一定程度的响应。</p><p>实现并发的直接方法是在操作系统级别，使用与线程不同的进程。进程是一个在自己的地址空间内运行的自包含程序。进程很有吸引力，因为操作系统通常将一个进程与另一个进程隔离，因此它们不会相互干扰，这使得进程编程相对容易。相比之下，线程共享内存和I/O等资源，因此编写多线程程序时遇到的困难是在不同的线程驱动的任务之间协调这些资源，一次不能通过多个任务访问它们。</p><!-- 文献引用未加，因为暂时没看到很好的解决办法 --><p>有些人甚至提倡将进程作为并发的唯一合理方法<a href="例如,Eric-Raymond在“Unix编程艺术”（Addison-Wesley，2004）中提出了一个很好的案例。">^1</a>，但不幸的是，通常存在数量和开销限制，以防止它们在并发频谱中的适用性（最终你习惯了标准的并发性克制，“这种方法适用于一些情况但不适用于其他情况”）</p><p>一些编程语言旨在将并发任务彼此隔离。这些通常被称为_函数式语言_，其中每个函数调用不产生其他影响（因此不能与其他函数干涉），因此可以作为独立的任务来驱动。Erlang就是这样一种语言，它包括一个任务与另一个任务进行通信的安全机制。如果你发现程序的一部分必须大量使用并发性并且你在尝试构建该部分时遇到了过多的问题，那么你可能会考虑使用专用并发语言创建程序的那一部分。</p><!-- 文献标记 --><p>Java采用了更传统的方法<a href="可以说，试图将并发性用于后续语言是一种注定要失败的方法，但你必须得出自己的结论">^2</a>，即在顺序语言之上添加对线程的支持而不是在多任务操作系统中分配外部进程，线程在执行程序所代表的单个进程中创建任务交换。</p><p>并发性会带来成本，包括复杂性成本，但可以通过程序设计，资源平衡和用户便利性的改进来抵消。通常，并发性使你能够创建更加松散耦合的设计;否则，你的代码部分将被迫明确标注通常由并发处理的操作。</p><!-- The Four Maxims of Java Concurrency --><h2 id="四句格言"><a href="#四句格言" class="headerlink" title="四句格言"></a>四句格言</h2><p>在经历了多年的Java并发之后，作者总结了以下四个格言：</p><blockquote><p>1.不要这样做</p><p>2.没有什么是真的，一切可能都有问题</p><p>3.它起作用,并不意味着它没有问题</p><p>4.你仍然必须理解它</p></blockquote><p>这些特别是关于Java设计中的问题，尽管它也可以应用于其他一些语言。但是，确实存在旨在防止这些问题的语言。</p><h3 id="1-不要这样做"><a href="#1-不要这样做" class="headerlink" title="1.不要这样做"></a>1.不要这样做</h3><p>（不要自己动手）</p><p>避免纠缠于并发产生的深层问题的最简单方法就是不要这样做。虽然它是诱人的，并且似乎足够安全，可以尝试做简单的事情，但它存在无数、微妙的陷阱。如果你可以避免它，你的生活会更容易。</p><p>证明并发性的唯一因素是速度。如果你的程序运行速度不够快 - 在这里要小心，因为只是希望它运行得更快是不合理的 - 首先应用一个分析器（参见代码校验章中分析和优化）来发现你是否可以执行其他一些优化。</p><p>如果你被迫进行并发，请采取最简单，最安全的方法来解决问题。使用众所周知的库并尽可能少地编写自己的代码。有了并发性，就没有“太简单了”。自负才是你的敌人。</p><h3 id="2-没有什么是真的，一切可能都有问题"><a href="#2-没有什么是真的，一切可能都有问题" class="headerlink" title="2.没有什么是真的，一切可能都有问题"></a>2.没有什么是真的，一切可能都有问题</h3><p>没有并发性的编程，你会发现你的世界有一定的顺序和一致性。通过简单地将变量赋值给某个值，很明显它应该始终正常工作。</p><p>在并发领域，有些事情可能是真的而有些事情却不是，你必须认为没有什么是真的。你必须质疑一切。即使将变量设置为某个值也可能或者可能不会按预期的方式工作，并且从那里开始走下坡路。我已经很熟悉的东西，认为它显然有效但实际上并没有。</p><p>在非并发程序中你可以忽略的各种事情突然变得非常重要。例如，你必须知道处理器缓存以及保持本地缓存与主内存一致的问题。你必须了解对象构造的深度复杂性，以便你的构造对象不会意外地将数据暴露给其他线程进行更改。问题还有很多。</p><p>虽然这些主题太复杂，无法为你提供本章的专业知识（再次参见Java Concurrency in Practice），但你必须了解它们。</p><h3 id="3-它起作用-并不意味着它没有问题"><a href="#3-它起作用-并不意味着它没有问题" class="headerlink" title="3.它起作用,并不意味着它没有问题"></a>3.它起作用,并不意味着它没有问题</h3><p>我们很容易编写出一个看似完美实则有问题的并发程序，并且往往问题直在极端情况下才暴露出来 - 在程序部署后不可避免地会出现用户问题。</p><ul><li>你不能证明并发程序是正确的，你只能（有时）证明它是不正确的。</li><li>大多数情况下你甚至不能这样做：如果它有问题，你可能无法检测到它。</li><li>你通常不能编写有用的测试，因此你必须依靠代码检查结合深入的并发知识来发现错误。</li><li>即使是有效的程序也只能在其设计参数下工作。当超出这些设计参数时，大多数并发程序会以某种方式失败。</li></ul><p>在其他 Java 主题中，我们培养了一种感觉-决定论。一切都按照语言的承诺（或隐含）进行，这是令人欣慰和期待的 - 毕竟，编程语言的目的是让机器做我们想要的。从确定性编程的世界进入并发编程领域，我们遇到了一种称为<a href="https://en.wikipedia.org/wiki/Dunning%E2%80%93Kruger_effect" target="_blank" rel="noopener">Dunning-Kruger</a>效应的认知偏差，可以概括为“无知者无畏。”这意味着“……相对不熟练的人拥有着虚幻的优越感，错误地评估他们的能力远高于实际。</p><p>我自己的经验是，无论你是多么确定你的代码是线程安全的，它可能已经无效了。你可以很容易地了解所有的问题，然后几个月或几年后你会发现一些概念让你意识到你编写的大多数内容实际上都容易受到并发错误的影响。当某些内容不正确时，编译器不会告诉你。为了使它正确，你必须在研究代码时掌握前脑的所有并发问题。</p><p>在Java的所有非并发领域，“没有明显的错误和没有明显的编译错误”似乎意味着一切都好。对于并发，它没有任何意义。你可以在这个情况下做的最糟糕的事情是“自信”。</p><h3 id="4-你必须仍然理解"><a href="#4-你必须仍然理解" class="headerlink" title="4.你必须仍然理解"></a>4.你必须仍然理解</h3><p>在格言1-3之后，你可能会对并发性感到害怕，并且认为，“到目前为止，我已经避免了它，也许我可以继续保留它。</p><p>这是一种理性的反应。你可能知道其他编程语言更好地设计用于构建并发程序 - 甚至是在JVM上运行的程序（从而提供与Java的轻松通信），例如Clojure或Scala。为什么不用这些语言编写并发部分并将Java用于其他所有部分呢？</p><p>唉，你不能轻易逃脱：</p><ul><li>即使你从未明确地创建一个线程，你可能使用的框架 - 例如，Swing图形用户界面（GUI）库，或者像<strong>Timer</strong> clas那样简单的东西。</li><li>这是最糟糕的事情：当你创建组件时，你必须假设这些组件可能在多线程环境中重用。即使你的解决方案是放弃并声明你的组件“不是线程安全的”，你仍然必须知道这样的声明是重要的，它是什么意思？</li></ul><p>人们有时会认为并发性太难，不能包含在介绍该语言的书中。他们认为并发是一个可以独立对待的独立主题，并且它在日常编程中出现的少数情况（例如图形用户界面）可以用特殊的习语来处理。如果你可以避免它，为什么要介绍这样的复杂的主题。</p><p>唉，如果只是这样的话，那就太好了。但不幸的是，你无法选择何时在Java程序中出现线程。仅仅你从未写过自己的线程，并不意味着你可以避免编写线程代码。例如，Web系统是最常见的Java应用程序之一，本质上是多线程的Web服务器通常包含多个处理器，而并行性是利用这些处理器的理想方式。就像这样的系统看起来那么简单，你必须理解并发才能正确地编写它。</p><p>Java是一种多线程语言，如果你了解它们是否存在并发问题。因此，有许多Java程序正在使用中，或者只是偶然工作，或者大部分时间工作并且不时地发生问题，因为。有时这种问题是相对良性的，但有时它意味着丢失有价值的数据，如果你没有意识到并发问题，你最终可能会把问题放在其他地方而不是你的代码中。如果将程序移动到多处理器系统，则可以暴露或放大这些类型的问题。基本上，了解并发性使你意识到正确的程序可能会表现出错误的行为。</p><!-- The Brutal Truth --><h2 id="残酷的真相"><a href="#残酷的真相" class="headerlink" title="残酷的真相"></a><span id="The-Brutal-Truth">残酷的真相</span></h2><p>当人类开始烹饪他们的食物时，他们大大减少了他们的身体分解和消化食物所需的能量。烹饪创造了一个“外化的胃”，从而释放出追去其他的的能力。火的使用促成了文明。</p><p>我们现在通过计算机和网络技术创造了一个“外化大脑”，开始了第二次基本转变。虽然我们只是触及表面，但已经引发了其他转变，例如设计生物机制的能力，并且已经看到文化演变的显着加速（过去，人们不得不前往混合文化，但现在他们开始混合互联网）。这些转变的影响和好处已经超出了科幻作家预测它们的能力（他们在预测文化和个人变化，甚至技术转变的次要影响方面都特别困难）。</p><p>有了这种根本性的人类变化，看到许多破坏和失败的实验并不令人惊讶。实际上，进化依赖于无数的实验，其中大多数都失败了。这些实验是向前发展的必要条件</p><p>Java是在充满自信，热情和睿智的氛围中创建的。在发明一种编程语言时，很容易就像语言的初始可塑性会持续存在一样，你可以把某些东西拿出来，如果不能解决问题，那么就修复它。编程语言以这种方式是独一无二的 - 它们经历了类似水的改变：气态，液态和最终的固态。在气体相位期间，灵活性似乎是无限的，并且很容易认为它总是那样。一旦人们开始使用你的语言，变化就会变得更加严重，环境变得更加粘稠。语言设计的过程本身就是一门艺术。</p><p>紧迫感来自互联网的最初兴起。它似乎是一场比赛，第一个通过起跑线的人将“获胜”（事实上，Java，JavaScript和PHP等语言的流行程度可以证明这一点）。唉，通过匆忙设计语言而产生的认知负荷和技术债务最终会赶上我们。</p><p><a href="https://en.wikipedia.org/wiki/Turing_completeness" target="_blank" rel="noopener">Turing completeness</a>是不足够的;语言需要更多的东西：它们必须能够创造性地表达，而不是用不必要的东西来衡量我们。解放我们的心理能力只是为了扭转并再次陷入困境，这是毫无意义的。我承认，尽管存在这些问题，我们已经完成了令人惊奇的事情，但我也知道如果没有这些问题我们能做得更多。</p><p>热情使原始Java设计师因为看起来有必要而投入功能。信心（以及原始语言的气味）让他们认为任何问题都可以解决。在时间轴的某个地方，有人认为任何加入Java的东西是固定的和永久性的 - 这是非常有信心，相信第一个决定永远是正确的，因此我们看到Java的体系中充斥着糟糕的决策。其中一些决定最终没有什么后果;例如，你可以告诉人们不要使用Vector，但保留了对之前版本的支持。</p><p>线程包含在Java 1.0中。当然，并发性是影响语言远角的基本语言设计决策，很难想象以后添加它。公平地说，当时并不清楚基本的并发性是多少。像C这样的其他语言能够将线程视为一个附加功能，因此Java设计师也纷纷效仿，包括一个Thread类和必要的JVM支持（这比你想象的要复杂得多）。</p><p>C语言是面向过程语言，这限制了它的野心。这些限制使附加线程库合理。当采用原始模型并将其粘贴到复杂语言中时，Java的大规模扩展迅速暴露了基本问题。在Thread类中的许多方法的弃用以及后续的高级库浪潮中，这种情况变得明显，这些库试图提供更好的并发抽象。</p><p>不幸的是，为了在更高级别的语言中获得并发性，所有语言功能都会受到影响，包括最基本的功能，例如标识符代表可变值。在函数和方法中，所有不变和防止副作用的方法都会导致简化并发编程（这些是纯函数式编程语言的基础）的变化，但当时对于主流语言的创建者来说似乎是奇怪的想法。最初的Java设计师要么对这些选择有所了解，要么认为它们太不同了，并且会抛弃许多潜在的语言采用者。我们可以慷慨地说，语言设计社区当时根本没有足够的经验来理解调整在线程库中的影响。</p><p>Java实验告诉我们，结果是悄然灾难性的。程序员很容易陷入认为Java 线程并不那么困难的陷阱。似乎工作的程序充满了微妙的并发bug。</p><p>为了获得正确的并发性，语言功能必须从头开始设计并考虑并发性。这艘船航行了;Java将不再是为并发而设计的语言，而只是一种允许它的语言。</p><p>尽管有这些基本的不可修复的缺陷，但令人印象深刻的是它还有多远。Java的后续版本添加了库，以便在使用并发时提升抽象级别。事实上，我根本不会想到有可能在Java 8中进行改进：并行流和<strong>CompletableFutures</strong> - 这是惊人的史诗般的变化，我会惊奇地重复的查看它<a href="有人谈论在Java——10中围绕泛型做一些类似的基本改进，这将是非常令人难以置信的。">^3</a>。</p><p>这些改进非常有用，我们将在本章重点介绍并行流和<strong>CompletableFutures</strong>。虽然它们可以大大简化你对并发和后续代码的思考方式，但基本问题仍然存在：由于Java的原始设计，代码的所有部分仍然容易受到攻击，你仍然必须理解这些复杂和微妙的问题。Java中的线程绝不是简单或安全的;那种经历必须降级为另一种更新的语言。</p><!-- The Rest of the Chapter --><h2 id="本章其余部分"><a href="#本章其余部分" class="headerlink" title="本章其余部分"></a>本章其余部分</h2><p>这是我们将在本章的其余部分介绍的内容。请记住，本章的重点是使用最新的高级Java并发结构。使用这些使得你的生活比旧的替代品更加轻松。但是，你仍会在遗留代码中遇到一些低级工具。有时，你可能会被迫自己使用其中的一些。附录并发底层原理包含一些更原始的Java并发元素的介绍。</p><ul><li>Parallel Streams（并行流）<br>到目前为止，我已经强调了Java 8 Streams提供的改进语法。现在你对该语法（作为一个粉丝，我希望）感到满意，你可以获得额外的好处：你可以通过简单地将parallel()添加到表达式来并行化流。这是一种简单，强大，坦率地说是利用多处理器的惊人方式</li></ul><p>添加parallel()来提高速度似乎是微不足道的，但是，唉，它就像你刚刚在<a href="#The-Brutal-Truth">残酷的真相</a>中学到的那样简单。我将演示并解释一些盲目添加parallel()到Stream表达式的缺陷。</p><ul><li>创建和运行任务<br>任务是一段可以独立运行的代码。为了解释创建和运行任务的一些基础知识，本节介绍了一种比并行流或CompletableFutures：Executor更复杂的机制。执行者管理一些低级Thread对象（Java中最原始的并发形式）。你创建一个任务，然后将其交给Executorto运行。</li></ul><p>有多种类型的Executor用于不同的目的。在这里，我们将展示规范形式，代表创建和运行任务的最简单和最佳方法。</p><ul><li>终止长时间运行的任务<br>任务独立运行，因此需要一种机制来关闭它们。典型的方法使用了一个标志，这引入了共享内存的问题，我们将使用Java的“Atomic”库来回避它。</li><li>Completable Futures<br>当你将衣服带到干洗店时，他们会给你一张收据。你继续完成其他任务，最终你的衣服很干净，你可以拿起它。收据是你与干洗店在后台执行的任务的连接。这是Java 5中引入的Future的方法。</li></ul><p>Future比以前的方法更方便，但你仍然必须出现并用收据取出干洗，等待任务没有完成。对于一系列操作，Futures并没有真正帮助那么多。</p><p>Java 8 CompletableFuture是一个更好的解决方案：它允许你将操作链接在一起，因此你不必将代码写入接口排序操作。有了CompletableFuture完美的结合，就可以更容易地做出“采购原料，组合成分，烹饪食物，提供食物，清理菜肴，储存菜肴”等一系列链式操作。</p><ul><li>死锁<br>某些任务必须去<strong>等待 - 阻塞</strong>来获得其他任务的结果。被阻止的任务有可能等待另一个被阻止的任务，等待另一个被阻止的任务，等等。如果被阻止的任务链循环到第一个，没有人可以取得任何进展，你就会陷入僵局。</li></ul><p>如果在运行程序时没有立即出现死锁，则会出现最大的问题。你的系统可能容易出现死锁，并且只会在某些条件下死锁。程序可能在某个平台上运行正常，例如你的开发机器，但是当你将其部署到不同的硬件时会开始死锁。</p><p>死锁通常源于细微的编程错误;一系列无辜的决定，最终意外地创建了一个依赖循环。本节包含一个经典示例，演示了死锁的特性。</p><p>我们将通过模拟创建披萨的过程完成本章，首先使用并行流实现它，然后是完成配置。这不仅仅是两种方法的比较，更重要的是探索你应该投入多少工作来加速计划。</p><ul><li>努力，复杂，成本<!-- Parallel Streams --><h2 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h2></li></ul><p>Java 8流的一个显着优点是，在某些情况下，它们可以很容易地并行化。这来自仔细的库设计，特别是流使用内部迭代的方式 - 也就是说，它们控制着自己的迭代器。特别是，他们使用一种特殊的迭代器，称为Spliterator，它被限制为易于自动分割。这产生了相当神奇的结果，即能够简单用parallel()然后流中的所有内容都作为一组并行任务运行。如果你的代码是使用Streams编写的，那么并行化以提高速度似乎是一种琐事</p><p>例如，考虑来自Streams的Prime.java。查找质数可能是一个耗时的过程，我们可以看到该程序的计时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/ParallelPrime.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.LongStream.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">import</span> onjava.Timer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParallelPrime</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT = <span class="number">100_000</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rangeClosed(<span class="number">2</span>, (<span class="keyword">long</span>)Math.sqrt(n)).noneMatch(i -&gt; n % i == <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        List&lt;String&gt; primes =</span><br><span class="line">            iterate(<span class="number">2</span>, i -&gt; i + <span class="number">1</span>)</span><br><span class="line">                .parallel()              <span class="comment">// [1]</span></span><br><span class="line">                .filter(ParallelPrime::isPrime)</span><br><span class="line">                .limit(COUNT)</span><br><span class="line">                .mapToObj(Long::toString)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        System.out.println(timer.duration());</span><br><span class="line">        Files.write(Paths.get(<span class="string">"primes.txt"</span>), primes, StandardOpenOption.CREATE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">1224</span><br></pre></td></tr></table></figure><p>请注意，这不是微基准测试，因为我们计时整个程序。我们将数据保存在磁盘上以防止过激的优化;如果我们没有对结果做任何事情，那么一个高级的编译器可能会观察到程序没有意义并且消除了计算（这不太可能，但并非不可能）。请注意使用nio2库编写文件的简单性（在<a href="./17-Files.md">文件</a>一章中有描述）。</p><p>当我注释掉[1] parallel()行时，我的结果大约是parallel()的三倍。</p><p>并行流似乎是一个甜蜜的交易。你所需要做的就是将编程问题转换为流，然后插入parallel()以加快速度。实际上，有时候这很容易。但遗憾的是，有许多陷阱。</p><ul><li>parallel()不是灵丹妙药</li></ul><p>作为对流和并行流的不确定性的探索，让我们看一个看似简单的问题：求和数字的增量序列。事实证明这是一个令人惊讶的数量，并且我将冒险将它们进行比较 - 试图小心，但承认我可能会在计时代码执行时遇到许多基本陷阱之一。结果可能有一些缺陷（例如JVM没有“升温”），但我认为它仍然提供了一些有用的指示。</p><p>我将从一个计时方法rigorously 开始，它采用<strong>LongSupplier</strong>，测量<strong>getAsLong()</strong>调用的长度，将结果与<strong>checkValue</strong>进行比较并显示结果。</p><p>请注意，一切都必须严格使用<strong>long</strong>;我花了一些时间发现隐蔽的溢出，然后才意识到在重要的地方错过了<strong>long</strong>。</p><p>所有关于时间和内存的数字和讨论都是指“我的机器”。你的经历可能会有所不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/Summing.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">import</span> onjava.Timer;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Summing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timeTest</span><span class="params">(String id, <span class="keyword">long</span> checkValue,    LongSupplier operation)</span></span>&#123;</span><br><span class="line">        System.out.print(id + <span class="string">": "</span>);</span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        <span class="keyword">long</span> result = operation.getAsLong();</span><br><span class="line">        <span class="keyword">if</span>(result == checkValue)</span><br><span class="line">            System.out.println(timer.duration() + <span class="string">"ms"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.format(<span class="string">"result: %d%ncheckValue: %d%n"</span>, result, checkValue);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SZ = <span class="number">100_000_000</span>;<span class="comment">// This even works://</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SZ = <span class="number">1_000_000_000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> CHECK = (<span class="keyword">long</span>)SZ * ((<span class="keyword">long</span>)SZ + <span class="number">1</span>)/<span class="number">2</span>; <span class="comment">// Gauss's formula</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(CHECK);</span><br><span class="line">        timeTest(<span class="string">"Sum Stream"</span>, CHECK, () -&gt;</span><br><span class="line">        LongStream.rangeClosed(<span class="number">0</span>, SZ).sum());</span><br><span class="line">        timeTest(<span class="string">"Sum Stream Parallel"</span>, CHECK, () -&gt;</span><br><span class="line">        LongStream.rangeClosed(<span class="number">0</span>, SZ).parallel().sum());</span><br><span class="line">        timeTest(<span class="string">"Sum Iterated"</span>, CHECK, () -&gt;</span><br><span class="line">        LongStream.iterate(<span class="number">0</span>, i -&gt; i + <span class="number">1</span>)</span><br><span class="line">        .limit(SZ+<span class="number">1</span>).sum());</span><br><span class="line">        <span class="comment">// Slower &amp; runs out of memory above 1_000_000:</span></span><br><span class="line">        <span class="comment">// timeTest("Sum Iterated Parallel", CHECK, () -&gt;</span></span><br><span class="line">        <span class="comment">//   LongStream.iterate(0, i -&gt; i + 1)</span></span><br><span class="line">        <span class="comment">//     .parallel()</span></span><br><span class="line">        <span class="comment">//     .limit(SZ+1).sum());</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5000000050000000</span><br><span class="line">Sum Stream: 167ms</span><br><span class="line">Sum Stream Parallel: 46ms</span><br><span class="line">Sum Iterated: 284ms</span><br></pre></td></tr></table></figure><p><strong>CHECK</strong>值是使用Carl Friedrich Gauss在1700年代后期仍在小学时创建的公式计算出来的.</p><p> <strong>main()</strong> 的第一个版本使用直接生成 <strong>Stream</strong> 并调用 <strong>sum()</strong> 的方法。我们看到流的好处在于十亿分之一的SZ在没有溢出的情况下处理（我使用较小的数字，因此程序运行时间不长）。使用 <strong>parallel()</strong> 的基本范围操跟快。</p><p>如果使用<strong>iterate()</strong>来生成序列，则减速是戏剧性的，可能是因为每次生成数字时都必须调用lambda。但是如果我们尝试并行化，那么结果通常比非并行版本花费的时间更长，但是当<strong>SZ</strong>超过一百万时，它也会耗尽内存（在某些机器上）。当然，当你可以使用<strong>range()</strong>时，你不会使用<strong>iterate()</strong>，但如果你生成的东西不是简单的序列，你必须使用<strong>iterate()</strong>。应用<strong>parallel()</strong>是一个合理的尝试，但会产生令人惊讶的结果。我们将在后面的部分中探讨内存限制的原因，但我们可以对流并行算法进行初步观察：</p><ul><li>流并行性将输入数据分成多个部分，因此算法可以应用于那些单独的部分。</li><li>阵列分割成本低廉，均匀且具有完美的分裂知识。</li><li>链接列表没有这些属性;“拆分”一个链表仅仅意味着把它分成“第一元素”和“其余列表”，这相对无用。</li><li>无状态生成器的行为类似于数组;使用上述范围是无可争议的。</li><li>迭代生成器的行为类似于链表; <strong>iterate()</strong> 是一个迭代生成器。</li></ul><p>现在让我们尝试通过在数组中填充值来填充数组来解决问题。因为数组只分配了一次，所以我们不太可能遇到垃圾收集时序问题。</p><p>首先我们将尝试一个充满原始<strong>long</strong>的数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/Summing2.java</span></span><br><span class="line"><span class="comment">// &#123;ExcludeFromTravisCI&#125;import java.util.*;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Summing2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">basicSum</span><span class="params">(<span class="keyword">long</span>[] ia)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> size = ia.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            sum += ia[i];<span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Approximate largest value of SZ before</span></span><br><span class="line">    <span class="comment">// running out of memory on mymachine:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SZ = <span class="number">20_000_000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> CHECK = (<span class="keyword">long</span>)SZ * ((<span class="keyword">long</span>)SZ + <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(CHECK);</span><br><span class="line">        <span class="keyword">long</span>[] la = newlong[SZ+<span class="number">1</span>];</span><br><span class="line">        Arrays.parallelSetAll(la, i -&gt; i);</span><br><span class="line">        Summing.timeTest(<span class="string">"Array Stream Sum"</span>, CHECK, () -&gt;</span><br><span class="line">        Arrays.stream(la).sum());</span><br><span class="line">        Summing.timeTest(<span class="string">"Parallel"</span>, CHECK, () -&gt;</span><br><span class="line">        Arrays.stream(la).parallel().sum());</span><br><span class="line">        Summing.timeTest(<span class="string">"Basic Sum"</span>, CHECK, () -&gt;</span><br><span class="line">        basicSum(la));<span class="comment">// Destructive summation:</span></span><br><span class="line">        Summing.timeTest(<span class="string">"parallelPrefix"</span>, CHECK, () -&gt; &#123;</span><br><span class="line">            Arrays.parallelPrefix(la, Long::sum);</span><br><span class="line">        <span class="keyword">return</span> la[la.length - <span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">200000010000000</span><br><span class="line">Array Stream</span><br><span class="line">Sum: 104ms</span><br><span class="line">Parallel: 81ms</span><br><span class="line">Basic Sum: 106ms</span><br><span class="line">parallelPrefix: 265ms</span><br></pre></td></tr></table></figure><p>第一个限制是内存大小;因为数组是预先分配的，所以我们不能创建几乎与以前版本一样大的任何东西。并行化可以加快速度，甚至比使用 <strong>basicSum()</strong> 循环更快。有趣的是， <strong>Arrays.parallelPrefix()</strong> 似乎实际上减慢了速度。但是，这些技术中的任何一种在其他条件下都可能更有用 - 这就是为什么你不能做出任何确定性的声明，除了“你必须尝试一下”。”</p><p>最后，考虑使用盒装<strong>Long</strong>的效果:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/Summing3.java</span></span><br><span class="line"><span class="comment">// &#123;ExcludeFromTravisCI&#125;</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Summing3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">basicSum</span><span class="params">(Long[] ia)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> size = ia.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            sum += ia[i];</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Approximate largest value of SZ before</span></span><br><span class="line">    <span class="comment">// running out of memory on my machine:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SZ = <span class="number">10_000_000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> CHECK = (<span class="keyword">long</span>)SZ * ((<span class="keyword">long</span>)SZ + <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(CHECK);</span><br><span class="line">        Long[] aL = newLong[SZ+<span class="number">1</span>];</span><br><span class="line">        Arrays.parallelSetAll(aL, i -&gt; (<span class="keyword">long</span>)i);</span><br><span class="line">        Summing.timeTest(<span class="string">"Long Array Stream Reduce"</span>, CHECK, () -&gt;</span><br><span class="line">        Arrays.stream(aL).reduce(<span class="number">0L</span>, Long::sum));</span><br><span class="line">        Summing.timeTest(<span class="string">"Long Basic Sum"</span>, CHECK, () -&gt;</span><br><span class="line">        basicSum(aL));</span><br><span class="line">        <span class="comment">// Destructive summation:</span></span><br><span class="line">        Summing.timeTest(<span class="string">"Long parallelPrefix"</span>,CHECK, ()-&gt; &#123;</span><br><span class="line">            Arrays.parallelPrefix(aL, Long::sum);</span><br><span class="line">            <span class="keyword">return</span> aL[aL.length - <span class="number">1</span>];</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">50000005000000</span><br><span class="line">Long Array</span><br><span class="line">Stream Reduce: 1038ms</span><br><span class="line">Long Basic</span><br><span class="line">Sum: 21ms</span><br><span class="line">Long parallelPrefix: 3616ms</span><br></pre></td></tr></table></figure><p>现在可用的内存量大约减半，并且所有情况下所需的时间都会很长，除了<strong>basicSum()</strong>，它只是循环遍历数组。令人惊讶的是， <strong>Arrays.parallelPrefix()</strong> 比任何其他方法都要花费更长的时间。</p><p>我将 <strong>parallel()</strong> 版本分开了，因为在上面的程序中运行它导致了一个冗长的垃圾收集，扭曲了结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/Summing4.java</span></span><br><span class="line"><span class="comment">// &#123;ExcludeFromTravisCI&#125;</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Summing4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Summing3.CHECK);</span><br><span class="line">        Long[] aL = newLong[Summing3.SZ+<span class="number">1</span>];</span><br><span class="line">        Arrays.parallelSetAll(aL, i -&gt; (<span class="keyword">long</span>)i);</span><br><span class="line">        Summing.timeTest(<span class="string">"Long Parallel"</span>,</span><br><span class="line">        Summing3.CHECK, () -&gt;</span><br><span class="line">        Arrays.stream(aL)</span><br><span class="line">        .parallel()</span><br><span class="line">        .reduce(<span class="number">0L</span>,Long::sum));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">50000005000000</span><br><span class="line">Long Parallel: 1014ms</span><br></pre></td></tr></table></figure><p>它比非parallel()版本略快，但并不显着。</p><p>这种时间增加的一个重要原因是处理器内存缓存。使用<strong>Summing2.java</strong>中的原始<strong>long</strong>，数组<strong>la</strong>是连续的内存。处理器可以更容易地预测该阵列的使用，并使缓存充满下一个需要的阵列元素。访问缓存比访问主内存快得多。似乎 <strong>Long parallelPrefix</strong> 计算受到影响，因为它为每个计算读取两个数组元素，并将结果写回到数组中，并且每个都为<strong>Long</strong>生成一个超出缓存的引用。</p><p>使用<strong>Summing3.java</strong>和<strong>Summing4.java</strong>，<strong>aL</strong>是一个<strong>Long</strong>数组，它不是一个连续的数据数组，而是一个连续的<strong>Long</strong>对象引用数组。尽管该数组可能会在缓存中出现，但指向的对象几乎总是超出缓存。</p><p>这些示例使用不同的SZ值来显示内存限制。</p><p>为了进行时间比较，以下是SZ设置为最小值1000万的结果：</p><p><strong>Sum Stream: 69msSum<br>Stream Parallel: 18msSum<br>Iterated: 277ms<br>Array Stream Sum: 57ms<br>Parallel: 14ms<br>Basic Sum: 16ms<br>parallelPrefix: 28ms<br>Long Array Stream Reduce: 1046ms<br>Long Basic Sum: 21ms<br>Long parallelPrefix: 3287ms<br>Long Parallel: 1008ms</strong></p><p>虽然Java 8的各种内置“并行”工具非常棒，但我认为它们被视为神奇的灵丹妙药：“只需添加parallel()并且它会更快！”我希望我已经开始表明情况并非所有都是如此，并且盲目地应用内置的“并行”操作有时甚至会使运行速度明显变慢。</p><ul><li>parallel()/limit()交点</li></ul><p>使用parallel()时会有更复杂的问题。从其他语言中吸取的流是围绕无限流模型设计的。如果你拥有有限数量的元素，则可以使用集合以及为有限大小的集合设计的关联算法。如果你使用无限流，则使用针对流优化的算法。</p><p>Java 8将两者合并起来。例如，<strong>Collections</strong>没有内置的<strong>map()</strong>操作。在Collection和Map中唯一类似流的批处理操作是<strong>forEach()</strong>。如果要执行<strong>map()</strong>和<strong>reduce()</strong>等操作，必须首先将Collection转换为存在这些操作的Stream:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/CollectionIntoStream.java</span></span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionIntoStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; strings = Stream.generate(<span class="keyword">new</span> Rand.String(<span class="number">5</span>))</span><br><span class="line">    .limit(<span class="number">10</span>)</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line">    strings.forEach(System.out::println);</span><br><span class="line">    <span class="comment">// Convert to a Stream for many more options:</span></span><br><span class="line">    String result = strings.stream()</span><br><span class="line">    .map(String::toUpperCase)</span><br><span class="line">    .map(s -&gt; s.substring(<span class="number">2</span>))</span><br><span class="line">    .reduce(<span class="string">":"</span>, (s1, s2) -&gt; s1 + s2);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pccux</span><br><span class="line">szgvg</span><br><span class="line">meinn</span><br><span class="line">eeloz</span><br><span class="line">tdvew</span><br><span class="line">cippc</span><br><span class="line">ygpoa</span><br><span class="line">lkljl</span><br><span class="line">bynxt</span><br><span class="line">:PENCUXGVGINNLOZVEWPPCPOALJLNXT</span><br></pre></td></tr></table></figure><p><strong>Collection</strong>确实有一些批处理操作，如<strong>removeAll()</strong>，<strong>removeIf()</strong>和<strong>retainAll()</strong>，但这些都是破坏性的操作.<strong>ConcurrentHashMap</strong>对<strong>forEachand</strong>和<strong>reduce</strong>操作有特别广泛的支持。</p><p>在许多情况下，只在集合上调用<strong>stream()</strong>或者<strong>parallelStream()</strong>没有问题。但是，有时将<strong>Stream</strong>与<strong>Collection</strong>混合会产生意外。这是一个有趣的难题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/ParallelStreamPuzzle.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParallelStreamPuzzle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntGenerator</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> current++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; x = Stream.generate(newIntGenerator())</span><br><span class="line">        .limit(<span class="number">10</span>)</span><br><span class="line">        .parallel()  <span class="comment">// [1]</span></span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>如果[1]注释运行它，它会产生预期的：<br><strong>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</strong><br>每次。但是包含了parallel()，它看起来像一个随机数生成器，带有输出（从一次运行到下一次运行不同），如：<br><strong>[0, 3, 6, 8, 11, 14, 17, 20, 23, 26]</strong><br>这样一个简单的程序怎么会这么破碎呢？让我们考虑一下我们在这里要实现的目标：“并行生成。”“那意味着什么？一堆线程都在拉动一个生成器，在某种程度上选择一组有限的结果？代码使它看起来很简单，但它转向是一个特别凌乱的问题。</p><p>为了看到它，我们将添加一些仪器。由于我们正在处理线程，因此我们必须将任何跟踪信息捕获到并发数据结构中。在这里我使用<strong>ConcurrentLinkedDeque</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/ParallelStreamPuzzle2.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParallelStreamPuzzle2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Deque&lt;String&gt; trace =</span><br><span class="line">    <span class="keyword">new</span> ConcurrentLinkedDeque&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="class">    <span class="title">IntGenerator</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> AtomicInteger current =</span><br><span class="line">        <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Integerget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            trace.add(current.get() + <span class="string">": "</span> +Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">return</span> current.getAndIncrement();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; x = Stream.generate(newIntGenerator())</span><br><span class="line">    .limit(<span class="number">10</span>)</span><br><span class="line">    .parallel()</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line">    System.out.println(x);</span><br><span class="line">    Files.write(Paths.get(<span class="string">"PSP2.txt"</span>), trace);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure><p>current是使用线程安全的 <strong>AtomicInteger</strong> 类定义的，可以防止竞争条件；<strong>parallel()</strong>允许多个线程调用<strong>get()</strong>。</p><p>在查看 <strong>PSP2.txt</strong>.<strong>IntGenerator.get()</strong> 被调用1024次时，你可能会感到惊讶。</p><p><strong>0: main<br>1: ForkJoinPool.commonPool-worker-1<br>2: ForkJoinPool.commonPool-worker-2<br>3: ForkJoinPool.commonPool-worker-2<br>4: ForkJoinPool.commonPool-worker-1<br>5: ForkJoinPool.commonPool-worker-1<br>6: ForkJoinPool.commonPool-worker-1<br>7: ForkJoinPool.commonPool-worker-1<br>8: ForkJoinPool.commonPool-worker-4<br>9: ForkJoinPool.commonPool-worker-4<br>10: ForkJoinPool.commonPool-worker-4<br>11: main<br>12: main<br>13: main<br>14: main<br>15: main…10<br>17: ForkJoinPool.commonPool-worker-110<br>18: ForkJoinPool.commonPool-worker-610<br>19: ForkJoinPool.commonPool-worker-610<br>20: ForkJoinPool.commonPool-worker-110<br>21: ForkJoinPool.commonPool-worker-110<br>22: ForkJoinPool.commonPool-worker-110<br>23: ForkJoinPool.commonPool-worker-1</strong></p><p>这个块大小似乎是内部实现的一部分（尝试使用<strong>limit()</strong>的不同参数来查看不同的块大小）。将<strong>parallel()</strong>与<strong>limit()</strong>结合使用可以预取一串值，作为流输出。</p><p>试着想象一下这里发生了什么：一个流抽象出无限序列，按需生成。当你要求它并行产生流时，你要求所有这些线程尽可能地调用get()。添加limit()，你说“只需要这些。”基本上，当你将parallel()与limit()结合使用时，你要求随机输出 - 这可能对你正在解决的问题很好。但是当你这样做时，你必须明白。这是一个仅限专家的功能，而不是要争辩说“Java弄错了”。</p><p>什么是更合理的方法来解决问题？好吧，如果你想生成一个int流，你可以使用IntStream.range()，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/ParallelStreamPuzzle3.java</span></span><br><span class="line"><span class="comment">// &#123;VisuallyInspectOutput&#125;</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParallelStreamPuzzle3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; x = IntStream.range(<span class="number">0</span>, <span class="number">30</span>)</span><br><span class="line">        .peek(e -&gt; System.out.println(e + <span class="string">": "</span> +Thread.currentThread()</span><br><span class="line">        .getName()))</span><br><span class="line">        .limit(<span class="number">10</span>)</span><br><span class="line">        .parallel()</span><br><span class="line">        .boxed()</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">8: main</span><br><span class="line">6: ForkJoinPool.commonPool-worker-5</span><br><span class="line">3: ForkJoinPool.commonPool-worker-7</span><br><span class="line">5: ForkJoinPool.commonPool-worker-5</span><br><span class="line">1: ForkJoinPool.commonPool-worker-3</span><br><span class="line">2: ForkJoinPool.commonPool-worker-6</span><br><span class="line">4: ForkJoinPool.commonPool-worker-1</span><br><span class="line">0: ForkJoinPool.commonPool-worker-4</span><br><span class="line">7: ForkJoinPool.commonPool-worker-1</span><br><span class="line">9: ForkJoinPool.commonPool-worker-2</span><br><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure><p>为了表明<strong>parallel()</strong>确实有效，我添加了一个对<strong>peek()</strong>的调用，这是一个主要用于调试的流函数：它从流中提取一个值并执行某些操作但不影响从流向下传递的元素。注意这会干扰线程行为，但我只是尝试在这里做一些事情，而不是实际调试任何东西。</p><p>你还可以看到boxed()的添加，它接受int流并将其转换为Integer流。</p><p>现在我们得到多个线程产生不同的值，但它只产生10个请求的值，而不是1024个产生10个值。</p><p>它更快吗？一个更好的问题是：什么时候开始有意义？当然不是这么小的一套;上下文切换的代价远远超过并行性的任何加速。当一个简单的数字序列并行生成时，有点难以想象。如果你使用昂贵的产品，它可能有意义 - 但这都是猜测。唯一知道的是通过测试。记住这句格言：“首先制作它，然后快速制作 - 但只有你必须这样做。”<strong>parallel()</strong>和<strong>limit()</strong>仅供专家使用（并且要清楚，我不认为自己是这里的专家）。</p><ul><li>并行流只看起来很容易</li></ul><p>实际上，在许多情况下，并行流确实可以毫不费力地更快地产生结果。但正如你所见，只需将<strong>parallel()</strong>打到你的Stream操作上并不一定是安全的事情。在使用<strong>parallel()</strong>之前，你必须了解并行性如何帮助或损害你的操作。有个错误认识是认为并行性总是一个好主意。事实上并不是。Stream意味着你不需要重写所有代码以便并行运行它。流什么都不做的是取代理解并行性如何工作的需要，以及它是否有助于实现你的目标。</p><h2 id="创建和运行任务"><a href="#创建和运行任务" class="headerlink" title="创建和运行任务"></a>创建和运行任务</h2><p>如果无法通过并行流实现并发，则必须创建并运行自己的任务。稍后你将看到运行任务的理想Java 8方法是CompletableFuture，但我们将使用更基本的工具介绍概念。</p><p>Java并发的历史始于非常原始和有问题的机制，并且充满了各种尝试的改进。这些主要归入附录：<a href="./Appendix-Low-Level-Concurrency.md">低级并发(Appendix: Low-Level Concurrency)</a>。在这里，我们将展示一个规范形式，表示创建和运行任务的最简单，最好的方法。与并发中的所有内容一样，存在各种变体，但这些变体要么降级到该附录，要么超出本书的范围。</p><ul><li>Tasks and Executors</li></ul><p>在Java的早期版本中，你通过直接创建自己的Thread对象来使用线程，甚至将它们子类化以创建你自己的特定“任务线程”对象。你手动调用了构造函数并自己启动了线程。</p><p>创建所有这些线程的开销变得非常重要，现在不鼓励采用实际操作方法。在Java 5中，添加了类来为你处理线程池。你可以将任务创建为单独的类型，然后将其交给ExecutorService以运行该任务，而不是为每种不同类型的任务创建新的Thread子类型。ExecutorService为你管理线程，并且在运行任务后重新循环线程而不是丢弃线程。</p><p>首先，我们将创建一个几乎不执行任务的任务。它“sleep”（暂停执行）100毫秒，显示其标识符和正在执行任务的线程的名称，然后完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/NapTask.java</span></span><br><span class="line"><span class="keyword">import</span> onjava.Nap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NapTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    finalint id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NapTask</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Nap(<span class="number">0.1</span>);<span class="comment">// Seconds</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span> + <span class="string">" "</span>+</span><br><span class="line">            Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span><span class="string">"NapTask["</span> + id + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这只是一个<strong>Runnable</strong>：一个包含<strong>run()</strong>方法的类。它没有包含实际运行任务的机制。我们使用<strong>Nap</strong>类中的“sleep”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/Nap.java</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Nap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Nap</span><span class="params">(<span class="keyword">double</span> t)</span> </span>&#123; <span class="comment">// Seconds</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep((<span class="keyword">int</span>)(<span class="number">1000</span> * t));</span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Nap</span><span class="params">(<span class="keyword">double</span> t, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(t);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了消除异常处理的视觉噪声，这被定义为实用程序。第二个构造函数在超时时显示一条消息</p><p>对<strong>TimeUnit.MILLISECONDS.sleep()</strong>的调用获取“当前线程”并在参数中将其置于休眠状态，这意味着该线程被挂起。这并不意味着底层处理器停止。操作系统将其切换到其他任务，例如在你的计算机上运行另一个窗口。OS任务管理器定期检查<strong>sleep()</strong>是否超时。当它执行时，线程被“唤醒”并给予更多处理时间。</p><p>你可以看到<strong>sleep()</strong>抛出一个已检查的<strong>InterruptedException</strong>;这是原始Java设计中的一个工件，它通过突然断开它们来终止任务。因为它往往会产生不稳定的状态，所以后来不鼓励终止。但是，我们必须在需要或仍然发生终止的情况下捕获异常。</p><p>要执行任务，我们将从最简单的方法–SingleThreadExecutor开始:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//concurrent/SingleThreadExecutor.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleThreadExecutor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec =</span><br><span class="line">            Executors.newSingleThreadExecutor();</span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">            .mapToObj(NapTask::<span class="keyword">new</span>)</span><br><span class="line">            .forEach(exec::execute);</span><br><span class="line">        System.out.println(<span class="string">"All tasks submitted"</span>);</span><br><span class="line">        exec.shutdown();</span><br><span class="line">        <span class="keyword">while</span>(!exec.isTerminated()) &#123;</span><br><span class="line">            System.out.println(</span><br><span class="line">            Thread.currentThread().getName()+</span><br><span class="line">            <span class="string">" awaiting termination"</span>);</span><br><span class="line">            <span class="keyword">new</span> Nap(<span class="number">0.1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">All tasks submitted</span><br><span class="line">main awaiting termination</span><br><span class="line">main awaiting termination</span><br><span class="line">NapTask[0] pool-1-thread-1</span><br><span class="line">main awaiting termination</span><br><span class="line">NapTask[1] pool-1-thread-1</span><br><span class="line">main awaiting termination</span><br><span class="line">NapTask[2] pool-1-thread-1</span><br><span class="line">main awaiting termination</span><br><span class="line">NapTask[3] pool-1-thread-1</span><br><span class="line">main awaiting termination</span><br><span class="line">NapTask[4] pool-1-thread-1</span><br><span class="line">main awaiting termination</span><br><span class="line">NapTask[5] pool-1-thread-1</span><br><span class="line">main awaiting termination</span><br><span class="line">NapTask[6] pool-1-thread-1</span><br><span class="line">main awaiting termination</span><br><span class="line">NapTask[7] pool-1-thread-1</span><br><span class="line">main awaiting termination</span><br><span class="line">NapTask[8] pool-1-thread-1</span><br><span class="line">main awaiting termination</span><br><span class="line">NapTask[9] pool-1-thread-1</span><br></pre></td></tr></table></figure><p>首先请注意，没有<strong>SingleThreadExecutor</strong>类。<strong>newSingleThreadExecutor()</strong>是<strong>Executors</strong>中的工厂，它创建特定类型的<a href="这是一种有趣的，虽然不一致的方法。通常，我们期望在公共接口上使用显式类表示不同的行为">^4</a></p><p>我创建了十个NapTasks并将它们提交给ExecutorService，这意味着它们开始自己运行。然而，在此期间，main()继续做事。当我运行callexec.shutdown()时，它告诉ExecutorService完成已经提交的任务，但不接受任何新任务。此时，这些任务仍然在运行，因此我们必须等到它们在退出main()之前完成。这是通过检查exec.isTerminated()来实现的，这在所有任务完成后变为true。</p><p>请注意，main()中线程的名称是main，并且只有一个其他线程pool-1-thread-1。此外，交错输出显示两个线程确实同时运行。</p><p>如果你只是调用exec.shutdown()，程序将完成所有任务。也就是说，虽然不需要（！exec.isTerminated()）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/SingleThreadExecutor2.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleThreadExecutor2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService exec</span><br><span class="line">        =Executors.newSingleThreadExecutor();</span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">            .mapToObj(NapTask::<span class="keyword">new</span>)</span><br><span class="line">            .forEach(exec::execute);</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NapTask[0] pool-1-thread-1</span><br><span class="line">NapTask[1] pool-1-thread-1</span><br><span class="line">NapTask[2] pool-1-thread-1</span><br><span class="line">NapTask[3] pool-1-thread-1</span><br><span class="line">NapTask[4] pool-1-thread-1</span><br><span class="line">NapTask[5] pool-1-thread-1</span><br><span class="line">NapTask[6] pool-1-thread-1</span><br><span class="line">NapTask[7] pool-1-thread-1</span><br><span class="line">NapTask[8] pool-1-thread-1</span><br><span class="line">NapTask[9] pool-1-thread-1</span><br></pre></td></tr></table></figure><p>一旦你callexec.shutdown()，尝试提交新任务将抛出RejectedExecutionException。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/MoreTasksAfterShutdown.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoreTasksAfterShutdown</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec</span><br><span class="line">        =Executors.newSingleThreadExecutor();</span><br><span class="line">        exec.execute(newNapTask(<span class="number">1</span>));</span><br><span class="line">        exec.shutdown();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            exec.execute(newNapTask(<span class="number">99</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span>(RejectedExecutionException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.RejectedExecutionException: TaskNapTask[99] rejected from java.util.concurrent.ThreadPoolExecutor@4e25154f[Shutting down, pool size = 1,active threads = 1, queued tasks = 0, completed tasks =0]NapTask[1] pool-1-thread-1</span><br></pre></td></tr></table></figure><p><strong>exec.shutdown()</strong>的替代方法是<strong>exec.shutdownNow()</strong>，它除了不接受新任务外，还会尝试通过中断任务来停止任何当前正在运行的任务。同样，中断是错误的，容易出错并且不鼓励。</p><ul><li>使用更多线程</li></ul><p>使用线程的重点是（几乎总是）更快地完成任务，那么我们为什么要限制自己使用SingleThreadExecutor呢？查看执行<strong>Executors</strong>的Javadoc，你将看到更多选项。例如CachedThreadPool：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/CachedThreadPool.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachedThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec</span><br><span class="line">        =Executors.newCachedThreadPool();</span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">        .mapToObj(NapTask::<span class="keyword">new</span>)</span><br><span class="line">        .forEach(exec::execute);</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NapTask[7] pool-1-thread-8</span><br><span class="line">NapTask[4] pool-1-thread-5</span><br><span class="line">NapTask[1] pool-1-thread-2</span><br><span class="line">NapTask[3] pool-1-thread-4</span><br><span class="line">NapTask[0] pool-1-thread-1</span><br><span class="line">NapTask[8] pool-1-thread-9</span><br><span class="line">NapTask[2] pool-1-thread-3</span><br><span class="line">NapTask[9] pool-1-thread-10</span><br><span class="line">NapTask[6] pool-1-thread-7</span><br><span class="line">NapTask[5] pool-1-thread-6</span><br></pre></td></tr></table></figure><p>当你运行这个程序时，你会发现它完成得更快。这是有道理的，而不是使用相同的线程来顺序运行每个任务，每个任务都有自己的线程，所以它们都并行运行。似乎没有缺点，很难看出为什么有人会使用SingleThreadExecutor。</p><p>要理解这个问题，我们需要一个更复杂的任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/InterferingTask.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterferingTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer val = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InterferingTask</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        val++;</span><br><span class="line">    System.out.println(id + <span class="string">" "</span>+</span><br><span class="line">        Thread.currentThread().getName() + <span class="string">" "</span> + val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个任务增加val一百次。这似乎很简单。让我们用CachedThreadPool尝试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/CachedThreadPool2.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachedThreadPool2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService exec</span><br><span class="line">    =Executors.newCachedThreadPool();</span><br><span class="line">    IntStream.range(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">    .mapToObj(InterferingTask::<span class="keyword">new</span>)</span><br><span class="line">    .forEach(exec::execute);</span><br><span class="line">    exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0 pool-1-thread-1 200</span><br><span class="line">1 pool-1-thread-2 200</span><br><span class="line">4 pool-1-thread-5 300</span><br><span class="line">5 pool-1-thread-6 400</span><br><span class="line">8 pool-1-thread-9 500</span><br><span class="line">9 pool-1-thread-10 600</span><br><span class="line">2 pool-1-thread-3 700</span><br><span class="line">7 pool-1-thread-8 800</span><br><span class="line">3 pool-1-thread-4 900</span><br><span class="line">6 pool-1-thread-7 1000</span><br></pre></td></tr></table></figure><p>输出不是我们所期望的，并且从一次运行到下一次运行会有所不同。问题是所有的任务都试图写入val的单个实例，并且他们正在踩着彼此的脚趾。我们说这样的类不是线程安全的。让我们看看SingleThreadExecutor会发生什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/SingleThreadExecutor3.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleThreadExecutor3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService exec</span><br><span class="line">        =Executors.newSingleThreadExecutor();</span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">        .mapToObj(InterferingTask::<span class="keyword">new</span>)</span><br><span class="line">        .forEach(exec::execute);</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0 pool-1-thread-1 100</span><br><span class="line">1 pool-1-thread-1 200</span><br><span class="line">2 pool-1-thread-1 300</span><br><span class="line">3 pool-1-thread-1 400</span><br><span class="line">4 pool-1-thread-1 500</span><br><span class="line">5 pool-1-thread-1 600</span><br><span class="line">6 pool-1-thread-1 700</span><br><span class="line">7 pool-1-thread-1 800</span><br><span class="line">8 pool-1-thread-1 900</span><br><span class="line">9 pool-1-thread-1 1000</span><br></pre></td></tr></table></figure><p>现在我们每次都得到一致的结果，尽管<strong>InterferingTask</strong>缺乏线程安全性。这是SingleThreadExecutor的主要好处 - 因为它一次运行一个任务，这些任务不会相互干扰，因此强加了线程安全性。这种现象称为线程限制，因为在单线程上运行任务限制了它们的影响。线程限制限制了加速，但可以节省很多困难的调试和重写。</p><ul><li>产生结果</li></ul><p>因为<strong>InterferingTask</strong>是一个<strong>Runnable</strong>，它没有返回值，因此只能使用副作用产生结果 - 操纵缓冲值而不是返回结果。副作用是并发编程中的主要问题之一，因为我们看到了<strong>CachedThreadPool2.java</strong>。<strong>InterferingTask</strong>中的<strong>val</strong>被称为可变共享状态，这就是问题所在：多个任务同时修改同一个变量会产生竞争。结果取决于首先在终点线上执行哪个任务，并修改变量（以及其他可能性的各种变化）。</p><p>避免竞争条件的最好方法是避免可变的共享状态。我们可以称之为自私的孩子原则：什么都不分享。</p><p>使用<strong>InterferingTask</strong>，最好删除副作用并返回任务结果。为此，我们创建<strong>Callable</strong>而不是<strong>Runnable</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/CountingTask.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountingTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountingTask</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123; <span class="keyword">this</span>.id = id; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Integer val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        val++;</span><br><span class="line">    System.out.println(id + <span class="string">" "</span> +</span><br><span class="line">        Thread.currentThread().getName() + <span class="string">" "</span> + val);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>call()完全独立于所有其他CountingTasks生成其结果</strong>，这意味着没有可变的共享状态</p><p><strong>ExecutorService</strong>允许你使用<strong>invokeAll()</strong>启动集合中的每个Callable：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/CachedThreadPool3.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachedThreadPool3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">extractResult</span><span class="params">(Future&lt;Integer&gt; f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> f.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ExecutorService exec =</span><br><span class="line">    Executors.newCachedThreadPool();</span><br><span class="line">    List&lt;CountingTask&gt; tasks =</span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">            .mapToObj(CountingTask::<span class="keyword">new</span>)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">        List&lt;Future&lt;Integer&gt;&gt; futures =</span><br><span class="line">            exec.invokeAll(tasks);</span><br><span class="line">        Integer sum = futures.stream()</span><br><span class="line">            .map(CachedThreadPool3::extractResult)</span><br><span class="line">            .reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">        System.out.println(<span class="string">"sum = "</span> + sum);</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1 pool-1-thread-2 100</span><br><span class="line">0 pool-1-thread-1 100</span><br><span class="line">4 pool-1-thread-5 100</span><br><span class="line">5 pool-1-thread-6 100</span><br><span class="line">8 pool-1-thread-9 100</span><br><span class="line">9 pool-1-thread-10 100</span><br><span class="line">2 pool-1-thread-3 100</span><br><span class="line">3 pool-1-thread-4 100</span><br><span class="line">6 pool-1-thread-7 100</span><br><span class="line">7 pool-1-thread-8 100</span><br><span class="line">sum = 1000</span><br></pre></td></tr></table></figure><p>只有在所有任务完成后，<strong>invokeAll()</strong>才会返回一个<strong>Future</strong>列表，每个任务一个<strong>Future</strong>。<strong>Future</strong>是Java 5中引入的机制，允许你提交任务而无需等待它完成。在这里，我们使用<strong>ExecutorService.submit()</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/Futures.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Futures</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    ExecutorService exec</span><br><span class="line">        =Executors.newSingleThreadExecutor();</span><br><span class="line">    Future&lt;Integer&gt; f =</span><br><span class="line">        exec.submit(newCountingTask(<span class="number">99</span>));</span><br><span class="line">    System.out.println(f.get()); <span class="comment">// [1]</span></span><br><span class="line">    exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">99 pool-1-thread-1 100</span><br><span class="line">100</span><br></pre></td></tr></table></figure><ul><li>[1] 当你的任务尚未完成的<strong>Future</strong>上调用<strong>get()</strong>时，调用会阻塞（等待）直到结果可用。</li></ul><p>但这意味着，在<strong>CachedThreadPool3.java</strong>中，<strong>Future</strong>似乎是多余的，因为<strong>invokeAll()</strong>甚至在所有任务完成之前都不会返回。但是，这里的Future并不用于延迟结果，而是用于捕获任何可能发生的异常。</p><p>还要注意在<strong>CachedThreadPool3.java.get()</strong>中抛出异常，因此<strong>extractResult()</strong>在Stream中执行此提取。</p><p>因为当你调用<strong>get()</strong>时，<strong>Future</strong>会阻塞，所以它只能解决等待任务完成的问题。最终，<strong>Futures</strong>被认为是一种无效的解决方案，现在不鼓励，支持Java 8的<strong>CompletableFuture</strong>，我们将在本章后面探讨。当然，你仍会在遗留库中遇到Futures</p><p>我们可以使用并行Stream以更简单，更优雅的方式解决这个问题:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/CountingStream.java</span></span><br><span class="line"><span class="comment">// &#123;VisuallyInspectOutput&#125;</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountingStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">            IntStream.range(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">                .parallel()</span><br><span class="line">                .mapToObj(CountingTask::<span class="keyword">new</span>)</span><br><span class="line">                .map(ct -&gt; ct.call())</span><br><span class="line">                .reduce(<span class="number">0</span>, Integer::sum));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1 ForkJoinPool.commonPool-worker-3 100</span><br><span class="line">8 ForkJoinPool.commonPool-worker-2 100</span><br><span class="line">0 ForkJoinPool.commonPool-worker-6 100</span><br><span class="line">2 ForkJoinPool.commonPool-worker-1 100</span><br><span class="line">4 ForkJoinPool.commonPool-worker-5 100</span><br><span class="line">9 ForkJoinPool.commonPool-worker-7 100</span><br><span class="line">6 main 100</span><br><span class="line">7 ForkJoinPool.commonPool-worker-4 100</span><br><span class="line">5 ForkJoinPool.commonPool-worker-2 100</span><br><span class="line">3 ForkJoinPool.commonPool-worker-3 100</span><br><span class="line">1000</span><br></pre></td></tr></table></figure><p>这不仅更容易理解，我们需要做的就是将<strong>parallel()</strong>插入到其他顺序操作中，然后一切都在同时运行。</p><ul><li>Lambda和方法引用作为任务</li></ul><p>在 <code>java8</code> , 你不需要受限于在  <code>Runnables</code> 和 <code>Callables</code> 时，使用<code>lambdas</code> 和方法引用， 同样也可以通过匹配签名来引用（即，它支持结构一致性）。 所以我们可以将 <code>notRunnables</code> 或 <code>Callables</code> 的参数传递给<code>ExecutorService</code> : </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/LambdasAndMethodReferences.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotRunnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"NotRunnable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotCallable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"NotCallable"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdasAndMethodReferences</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ExecutorService exec =</span><br><span class="line">        Executors.newCachedThreadPool();</span><br><span class="line">    exec.submit(() -&gt; System.out.println(<span class="string">"Lambda1"</span>));</span><br><span class="line">    exec.submit(<span class="keyword">new</span> NotRunnable()::go);</span><br><span class="line">    exec.submit(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"Lambda2"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    exec.submit(<span class="keyword">new</span> NotCallable()::get);</span><br><span class="line">    exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Lambda1</span><br><span class="line">NotCallable</span><br><span class="line">NotRunnable</span><br><span class="line">Lambda2</span><br></pre></td></tr></table></figure><p>这里，前两个<strong>submit()</strong>调用可以改为调用<strong>execute()</strong>。所有<strong>submit()</strong>调用都返回<strong>Futures</strong>，你可以在后两次调用的情况下提取结果。</p><!-- Terminating Long-Running Tasks --><h2 id="终止耗时任务"><a href="#终止耗时任务" class="headerlink" title="终止耗时任务"></a>终止耗时任务</h2><p>并发程序通常使用长时间运行的任务。可调用任务在完成时返回值;虽然这给它一个有限的寿命，但仍然可能很长。可运行的任务有时被设置为永远运行的后台进程。你经常需要一种方法在正常完成之前停止<strong>Runnable</strong>和<strong>Callable</strong>任务，例如当你关闭程序时。</p><p>最初的Java设计提供了中断运行任务的机制（为了向后兼容，仍然存在）;中断机制包括阻塞问题。中断任务既乱又复杂，因为你必须了解可能发生中断的所有可能状态，以及可能导致的数据丢失。使用中断被视为反对模式，但我们仍然被迫接受。</p><p>InterruptedException，因为设计的向后兼容性残留。</p><p>任务终止的最佳方法是设置任务周期性检查的标志。然后任务可以通过自己的shutdown进程并正常终止。不是在任务中随机关闭线程，而是要求任务在到达了一个较好时自行终止。这总是产生比中断更好的结果，以及更容易理解的更合理的代码。</p><p>以这种方式终止任务听起来很简单：设置任务可以看到的<strong>boolean</strong> flag。编写任务，以便定期检查标志并执行正常终止。这实际上就是你所做的，但是有一个复杂的问题：我们的旧克星，共同的可变状态。如果该标志可以被另一个任务操纵，则存在碰撞可能性。</p><p>在研究Java文献时，你会发现很多解决这个问题的方法，经常使用<strong>volatile</strong>关键字。我们将使用更简单的技术并避免所有易变的参数，这些都在<a href="./Appendix-Low-Level-Concurrency.md">附录：低级并发</a>中有所涉及。</p><p>Java 5引入了<strong>Atomic</strong>类，它提供了一组可以使用的类型，而不必担心并发问题。我们将添加<strong>AtomicBoolean</strong>标志，告诉任务清理自己并退出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/QuittableTask.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;<span class="keyword">import</span> onjava.Nap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuittableTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QuittableTask</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> AtomicBoolean running =</span><br><span class="line">        <span class="keyword">new</span> AtomicBoolean(<span class="keyword">true</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        running.set(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(running.get())         <span class="comment">// [1]</span></span><br><span class="line">            <span class="keyword">new</span> Nap(<span class="number">0.1</span>);</span><br><span class="line">        System.out.print(id + <span class="string">" "</span>);  <span class="comment">// [2]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然多个任务可以在同一个实例上成功调用<strong>quit()</strong>，但是<strong>AtomicBoolean</strong>可以防止多个任务同时实际修改<strong>running</strong>，从而使<strong>quit()</strong>方法成为线程安全的。</p><ul><li>[1]:只要运行标志为true，此任务的run()方法将继续。</li><li>[2]: 显示仅在任务退出时发生。</li></ul><p>需要<strong>running AtomicBoolean</strong>证明编写Java program并发时最基本的困难之一是，如果<strong>running</strong>是一个普通的布尔值，你可能无法在执行程序中看到问题。实际上，在这个例子中，你可能永远不会有任何问题 - 但是代码仍然是不安全的。编写表明该问题的测试可能很困难或不可能。因此，你没有任何反馈来告诉你已经做错了。通常，你编写线程安全代码的唯一方法就是通过了解事情可能出错的所有细微之处。</p><p>作为测试，我们将启动很多QuittableTasks然后关闭它们。尝试使用较大的COUNT值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/QuittingTasks.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> onjava.Nap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuittingTasks</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT = <span class="number">150</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService es =</span><br><span class="line">    Executors.newCachedThreadPool();</span><br><span class="line">    List&lt;QuittableTask&gt; tasks =</span><br><span class="line">    IntStream.range(<span class="number">1</span>, COUNT)</span><br><span class="line">        .mapToObj(QuittableTask::<span class="keyword">new</span>)</span><br><span class="line">        .peek(qt -&gt; es.execute(qt))</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">new</span> Nap(<span class="number">1</span>);</span><br><span class="line">    tasks.forEach(QuittableTask::quit);    es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">24 27 31 8 11 7 19 12 16 4 23 3 28 32 15 20 63 60 68 6764 39 47 52 51 55 40 43 48 59 44 56 36 35 71 72 83 10396 92 88 99 100 87 91 79 75 84 76 115 108 112 104 107111 95 80 147 120 127 119 123 144 143 116 132 124 128</span><br><span class="line">136 131 135 139 148 140 2 126 6 5 1 18 129 17 14 13 2122 9 10 30 33 58 37 125 26 34 133 145 78 137 141 138 6274 142 86 65 73 146 70 42 149 121 110 134 105 82 117106 113 122 45 114 118 38 50 29 90 101 89 57 53 94 4161 66 130 69 77 81 85 93 25 102 54 109 98 49 46 97</span><br></pre></td></tr></table></figure><p>我使用<strong>peek()</strong>将<strong>QuittableTasks</strong>传递给<strong>ExecutorService</strong>，然后将这些任务收集到<strong>List.main()</strong>中，只要任何任务仍在运行，就会阻止程序退出。即使为每个任务按顺序调用quit()方法，任务也不会按照它们创建的顺序关闭。独立运行的任务不会确定性地响应信号。</p><h2 id="CompletableFuture类"><a href="#CompletableFuture类" class="headerlink" title="CompletableFuture类"></a>CompletableFuture类</h2><p>作为介绍，这里是使用CompletableFutures在QuittingTasks.java中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/QuittingCompletable.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> onjava.Nap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuittingCompletable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;QuittableTask&gt; tasks =</span><br><span class="line">        IntStream.range(<span class="number">1</span>, QuittingTasks.COUNT)</span><br><span class="line">            .mapToObj(QuittableTask::<span class="keyword">new</span>)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">        List&lt;CompletableFuture&lt;Void&gt;&gt; cfutures =</span><br><span class="line">        tasks.stream()</span><br><span class="line">            .map(CompletableFuture::runAsync)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">new</span> Nap(<span class="number">1</span>);</span><br><span class="line">        tasks.forEach(QuittableTask::quit);</span><br><span class="line">        cfutures.forEach(CompletableFuture::join);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 2526 27 28 29 30 31 32 33 34 6 35 4 38 39 40 41 42 43 4445 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 6263 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 8081 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 9899 100 101 102 103 104 105 106 107 108 109 110 111 1121 113 114 116 117 118 119 120 121 122 123 124 125 126127 128 129 130 131 132 133 134 135 136 137 138 139 140141 142 143 144 145 146 147 148 149 5 115 37 36 2 3</span><br></pre></td></tr></table></figure><p>任务是一个 <code>List&lt;QuittableTask&gt;</code>，就像在 <code>QuittingTasks.java</code> 中一样，但是在这个例子中，没有 <code>peek()</code> 将每个 <code>QuittableTask</code> 提交给 <code>ExecutorService</code>。相反，在创建 <code>cfutures</code> 期间，每个任务都交给 <code>CompletableFuture::runAsync</code>。这执行 <code>VerifyTask.run()</code> 并返回 <code>CompletableFuture&lt;Void&gt;</code> 。因为 <code>run()</code> 不返回任何内容，所以在这种情况下我只使用 <code>CompletableFuture</code> 调用 <code>join()</code> 来等待它完成。</p><p>在本例中需要注意的重要一点是，运行任务不需要使用 <code>ExecutorService</code>。而是直接交给 <code>CompletableFuture</code> 管理 (不过你可以向它提供自己定义的 <code>ExectorService</code>)。您也不需要调用 <code>shutdown()</code>;事实上，除非你像我在这里所做的那样显式地调用 <code>join()</code>，否则程序将尽快退出，而不必等待任务完成。</p><p>这个例子只是一个起点。你很快就会看到 <code>ComplempleFuture</code> 能够做得更多。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>这是一个带有静态方法<strong>work()</strong>的类，它对该类的对象执行某些工作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/Machina.java</span></span><br><span class="line"><span class="keyword">import</span> onjava.Nap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Machina</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">        START, ONE, TWO, THREE, END;</span><br><span class="line">        <span class="function">State <span class="title">step</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(equals(END))</span><br><span class="line">            <span class="keyword">return</span> END;</span><br><span class="line">          <span class="keyword">return</span> values()[ordinal() + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> State state = State.START;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Machina</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Machina <span class="title">work</span><span class="params">(Machina m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!m.state.equals(State.END))&#123;</span><br><span class="line">            <span class="keyword">new</span> Nap(<span class="number">0.1</span>);</span><br><span class="line">            m.state = m.state.step();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(m);</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span><span class="string">"Machina"</span> + id + <span class="string">": "</span> + (state.equals(State.END)? <span class="string">"complete"</span> : state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个有限状态机，一个微不足道的机器，因为它没有分支……它只是从头到尾遍历一条路径。<strong>work()</strong>方法将机器从一个状态移动到下一个状态，并且需要100毫秒才能完成“工作”。</p><p><strong>CompletableFuture</strong>可以被用来做的一件事是, 使用<strong>completedFuture()</strong>将它感兴趣的对象进行包装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/CompletedMachina.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletedMachina</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CompletableFuture&lt;Machina&gt; cf =</span><br><span class="line">        CompletableFuture.completedFuture(</span><br><span class="line">            <span class="keyword">new</span> Machina(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Machina m = cf.get();  <span class="comment">// Doesn't block</span></span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterruptedException |</span><br><span class="line">            ExecutionException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>completedFuture()</strong>创建一个“已经完成”的<strong>CompletableFuture</strong>。对这样一个未来做的唯一有用的事情是<strong>get()</strong>里面的对象，所以这看起来似乎没有用。注意<strong>CompletableFuture</strong>被输入到它包含的对象。这个很重要。</p><p>通常，<strong>get()</strong>在等待结果时阻塞调用线程。此块可以通过<strong>InterruptedException</strong>或<strong>ExecutionException</strong>中断。在这种情况下，阻止永远不会发生，因为CompletableFutureis已经完成，所以答案立即可用。</p><p>当我们将<strong>handle()</strong>包装在<strong>CompletableFuture</strong>中时，发现我们可以在<strong>CompletableFuture</strong>上添加操作来处理所包含的对象，使得事情变得更加有趣：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/CompletableApply.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableApply</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CompletableFuture&lt;Machina&gt; cf =</span><br><span class="line">        CompletableFuture.completedFuture(</span><br><span class="line">            <span class="keyword">new</span> Machina(<span class="number">0</span>));</span><br><span class="line">        CompletableFuture&lt;Machina&gt; cf2 =</span><br><span class="line">            cf.thenApply(Machina::work);</span><br><span class="line">        CompletableFuture&lt;Machina&gt; cf3 =</span><br><span class="line">            cf2.thenApply(Machina::work);</span><br><span class="line">        CompletableFuture&lt;Machina&gt; cf4 =</span><br><span class="line">            cf3.thenApply(Machina::work);</span><br><span class="line">        CompletableFuture&lt;Machina&gt; cf5 =</span><br><span class="line">            cf4.thenApply(Machina::work);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Machina0: ONE</span><br><span class="line">Machina0: TWO</span><br><span class="line">Machina0: THREE</span><br><span class="line">Machina0: complete</span><br></pre></td></tr></table></figure><p><code>thenApply()</code> 应用一个接收输入并产生输出的函数。在本例中，<code>work()</code> 函数产生的类型与它所接收的类型相同 （<code>Machina</code>），因此每个 <code>CompletableFuture</code>添加的操作的返回类型都为 <code>Machina</code>，但是(类似于流中的 <code>map()</code> )函数也可以返回不同的类型，这将体现在返回类型上。</p><p>你可以在此处看到有关<strong>CompletableFutures</strong>的重要信息：它们会在你执行操作时自动解包并重新包装它们所携带的对象。这使得编写和理解代码变得更加简单， 而不会在陷入在麻烦的细节中。</p><p>我们可以消除中间变量并将操作链接在一起，就像我们使用Streams一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/CompletableApplyChained.javaimport java.util.concurrent.*;</span></span><br><span class="line"><span class="keyword">import</span> onjava.Timer;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableApplyChained</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        CompletableFuture&lt;Machina&gt; cf =</span><br><span class="line">        CompletableFuture.completedFuture(</span><br><span class="line">            <span class="keyword">new</span> Machina(<span class="number">0</span>))</span><br><span class="line">                  .thenApply(Machina::work)</span><br><span class="line">                  .thenApply(Machina::work)</span><br><span class="line">                  .thenApply(Machina::work)</span><br><span class="line">                  .thenApply(Machina::work);</span><br><span class="line">        System.out.println(timer.duration());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Machina0: ONE</span><br><span class="line">Machina0: TWO</span><br><span class="line">Machina0: THREE</span><br><span class="line">Machina0: complete</span><br><span class="line">514</span><br></pre></td></tr></table></figure><p>这里我们还添加了一个 <code>Timer</code>，它的功能在每一步都显性地增加 100ms 等待时间之外，还将 <code>CompletableFuture</code> 内部 <code>thenApply</code> 带来的额外开销给体现出来了。<br><strong>CompletableFutures</strong> 的一个重要好处是它们鼓励使用私有子类原则（不共享任何东西）。默认情况下，使用 <strong>thenApply()</strong> 来应用一个不对外通信的函数 - 它只需要一个参数并返回一个结果。这是函数式编程的基础，并且它在并发特性方面非常有效<a href="不，永远不会有纯粹的功能性Java。我们所能期望的最好的是一种在JVM上运行的全新语言。">^5</a>。并行流和 <code>ComplempleFutures</code> 旨在支持这些原则。只要你不决定共享数据（共享非常容易导致意外发生）你就可以编写出相对安全的并发程序。</p><p>回调 <code>thenApply()</code> 一旦开始一个操作，在完成所有任务之前，不会完成 <strong>CompletableFuture</strong> 的构建。虽然这有时很有用，但是开始所有任务通常更有价值，这样就可以运行继续前进并执行其他操作。我们可通过<code>thenApplyAsync()</code> 来实现此目的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/CompletableApplyAsync.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableApplyAsync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        CompletableFuture&lt;Machina&gt; cf =</span><br><span class="line">            CompletableFuture.completedFuture(</span><br><span class="line">                <span class="keyword">new</span> Machina(<span class="number">0</span>))</span><br><span class="line">                .thenApplyAsync(Machina::work)</span><br><span class="line">                .thenApplyAsync(Machina::work)</span><br><span class="line">                .thenApplyAsync(Machina::work)</span><br><span class="line">                .thenApplyAsync(Machina::work);</span><br><span class="line">            System.out.println(timer.duration());</span><br><span class="line">            System.out.println(cf.join());</span><br><span class="line">            System.out.println(timer.duration());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">116</span><br><span class="line">Machina0: ONE</span><br><span class="line">Machina0: TWO</span><br><span class="line">Machina0:THREE</span><br><span class="line">Machina0: complete</span><br><span class="line">Machina0: complete</span><br><span class="line">552</span><br></pre></td></tr></table></figure><p>同步调用(我们通常使用的那种)意味着：“当你完成工作时，才返回”，而异步调用以意味着： “立刻返回并继续后续工作”。 正如你所看到的，<code>cf</code> 的创建现在发生的更快。每次调用 <code>thenApplyAsync()</code> 都会立刻返回，因此可以进行下一次调用，整个调用链路完成速度比以前快得多。</p><p>事实上，如果没有回调 <code>cf.join()</code> 方法，程序会在完成其工作之前退出。而 <code>cf.join()</code> 直到cf操作完成之前，阻止 <code>main()</code> 进程结束。我们还可以看出本示例大部分时间消耗在 <code>cf.join()</code> 这。</p><p>这种“立即返回”的异步能力需要 <code>CompletableFuture</code> 库进行一些秘密（<code>client</code> 无感）工作。特别是，它将你需要的操作链存储为一组回调。当操作的第一个链路（后台操作）完成并返回时，第二个链路（后台操作）必须获取生成的 <code>Machina</code> 并开始工作，以此类推！ 但这种异步机制没有我们可以通过程序调用栈控制的普通函数调用序列，它的调用链路顺序会丢失，因此它使用一个函数地址来存储的回调来解决这个问题。</p><p>幸运的是，这就是你需要了解的有关回调的全部信息。程序员将这种人为制造的混乱称为 callback hell(回调地狱)。通过异步调用，<code>CompletableFuture</code> 帮你管理所有回调。 除非你知道系统的一些具体的变化，否则你更想使用异步调用来实现程序。</p><ul><li>其他操作</li></ul><p>当你查看<code>CompletableFuture</code>的 <code>Javadoc</code> 时，你会看到它有很多方法，但这个方法的大部分来自不同操作的变体。例如，有 <code>thenApply()</code>，<code>thenApplyAsync()</code> 和第二种形式的 <code>thenApplyAsync()</code>，它们使用 <code>Executor</code> 来运行任务(在本书中，我们忽略了 <code>Executor</code> 选项)。</p><p>下面的示例展示了所有”基本”操作，这些操作既不涉及组合两个 <code>CompletableFuture</code>，也不涉及异常(我们将在后面介绍)。首先，为了提供简洁性和方便性，我们应该重用以下两个实用程序:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableUtilities</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Get and show value stored in a CF:</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showr</span><span class="params">(CompletableFuture&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.println(c.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException</span><br><span class="line">            | ExecutionException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// For CF operations that have no value:</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">voidr</span><span class="params">(CompletableFuture&lt;Void&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      c.get(); <span class="comment">// Returns void</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException</span><br><span class="line">            | ExecutionException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>showr()</code> 在 <code>CompletableFuture&lt;Integer&gt;</code> 上调用 <code>get()</code>，并显示结果，<code>try/catch</code> 两个可能会出现的异常。</p><p><code>voidr()</code> 是 <code>CompletableFuture&lt;Void&gt;</code> 的 <code>showr()</code> 版本，也就是说，<code>CompletableFutures</code> 只为任务完成或失败时显示信息。</p><p>为简单起见，下面的 <code>CompletableFutures</code> 只包装整数。<code>cfi()</code> 是一个便利的方法，它把一个整数包装在一个完整的 <code>CompletableFuture&lt;Integer&gt;</code> :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/CompletableOperations.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> onjava.CompletableUtilities.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableOperations</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> CompletableFuture&lt;Integer&gt; <span class="title">cfi</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">                CompletableFuture.completedFuture(</span><br><span class="line">                        Integer.valueOf(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        showr(cfi(<span class="number">1</span>)); <span class="comment">// Basic test</span></span><br><span class="line">        voidr(cfi(<span class="number">2</span>).runAsync(() -&gt;</span><br><span class="line">                System.out.println(<span class="string">"runAsync"</span>)));</span><br><span class="line">        voidr(cfi(<span class="number">3</span>).thenRunAsync(() -&gt;</span><br><span class="line">                System.out.println(<span class="string">"thenRunAsync"</span>)));</span><br><span class="line">        voidr(CompletableFuture.runAsync(() -&gt;</span><br><span class="line">                System.out.println(<span class="string">"runAsync is static"</span>)));</span><br><span class="line">        showr(CompletableFuture.supplyAsync(() -&gt; <span class="number">99</span>));</span><br><span class="line">        voidr(cfi(<span class="number">4</span>).thenAcceptAsync(i -&gt;</span><br><span class="line">                System.out.println(<span class="string">"thenAcceptAsync: "</span> + i)));</span><br><span class="line">        showr(cfi(<span class="number">5</span>).thenApplyAsync(i -&gt; i + <span class="number">42</span>));</span><br><span class="line">        showr(cfi(<span class="number">6</span>).thenComposeAsync(i -&gt; cfi(i + <span class="number">99</span>)));</span><br><span class="line">        CompletableFuture&lt;Integer&gt; c = cfi(<span class="number">7</span>);</span><br><span class="line">        c.obtrudeValue(<span class="number">111</span>);</span><br><span class="line">        showr(c);</span><br><span class="line">        showr(cfi(<span class="number">8</span>).toCompletableFuture());</span><br><span class="line">        c = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        c.complete(<span class="number">9</span>);</span><br><span class="line">        showr(c);</span><br><span class="line">        c = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        c.cancel(<span class="keyword">true</span>);</span><br><span class="line">        System.out.println(<span class="string">"cancelled: "</span> +</span><br><span class="line">                c.isCancelled());</span><br><span class="line">        System.out.println(<span class="string">"completed exceptionally: "</span> +</span><br><span class="line">                c.isCompletedExceptionally());</span><br><span class="line">        System.out.println(<span class="string">"done: "</span> + c.isDone());</span><br><span class="line">        System.out.println(c);</span><br><span class="line">        c = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        System.out.println(c.getNow(<span class="number">777</span>));</span><br><span class="line">        c = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        c.thenApplyAsync(i -&gt; i + <span class="number">42</span>)</span><br><span class="line">                .thenApplyAsync(i -&gt; i * <span class="number">12</span>);</span><br><span class="line">        System.out.println(<span class="string">"dependents: "</span> +</span><br><span class="line">                c.getNumberOfDependents());</span><br><span class="line">        c.thenApplyAsync(i -&gt; i / <span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">"dependents: "</span> +</span><br><span class="line">                c.getNumberOfDependents());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">runAsync</span><br><span class="line">thenRunAsync</span><br><span class="line">runAsync is static</span><br><span class="line">99</span><br><span class="line">thenAcceptAsync: 4</span><br><span class="line">47</span><br><span class="line">105</span><br><span class="line">111</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">cancelled: true</span><br><span class="line">completed exceptionally: true</span><br><span class="line">done: true</span><br><span class="line">java.util.concurrent.CompletableFuture@6d311334[Complet ed exceptionally]</span><br><span class="line">777</span><br><span class="line">dependents: 1</span><br><span class="line">dependents: 2</span><br></pre></td></tr></table></figure><ul><li><code>main()</code> 包含一系列可由其 <code>int</code> 值引用的测试。<ul><li><code>cfi(1)</code> 演示了 <code>showr()</code> 正常工作。</li><li><code>cfi(2)</code> 是调用 <code>runAsync()</code> 的示例。由于 <code>Runnable</code> 不产生返回值，因此使用了返回 <code>CompletableFuture &lt;Void&gt;</code> 的<code>voidr()</code> 方法。</li><li>注意使用 <code>cfi(3)</code>,<code>thenRunAsync()</code> 效果似乎与 上例 <code>cfi(2)</code> 使用的 <code>runAsync()</code>相同，差异在后续的测试中体现：<ul><li><code>runAsync()</code> 是一个 <code>static</code> 方法，所以你通常不会像<code>cfi(2)</code>一样调用它。相反你可以在 <code>QuittingCompletable.java</code> 中使用它。</li><li>后续测试中表明 <code>supplyAsync()</code> 也是静态方法，区别在于它需要一个 <code>Supplier</code> 而不是<code>Runnable</code>, 并产生一个<code>CompletableFuture&lt;Integer&gt;</code> 而不是 <code>CompletableFuture&lt;Void&gt;</code>。</li></ul></li><li><code>then</code> 系列方法将对现有的 <code>CompletableFuture&lt;Integer&gt;</code> 进一步操作。<ul><li>与 <code>thenRunAsync()</code> 不同，<code>cfi(4)</code>，<code>cfi(5)</code> 和<code>cfi(6)</code> “then” 方法的参数是未包装的 <code>Integer</code>。</li><li>通过使用 <code>voidr()</code>方法可以看到: <ul><li><code>AcceptAsync()</code>接收了一个 <code>Consumer</code>，因此不会产生结果。</li><li><code>thenApplyAsync()</code> 接收一个<code>Function</code>, 并生成一个结果（该结果的类型可以不同于其输入类型）。</li><li><code>thenComposeAsync()</code> 与 <code>thenApplyAsync()</code>非常相似，唯一区别在于其 <code>Function</code> 必须产生已经包装在<code>CompletableFuture</code>中的结果。</li></ul></li></ul></li><li><code>cfi(7)</code> 示例演示了 <code>obtrudeValue()</code>，它强制将值作为结果。</li><li><code>cfi(8)</code> 使用 <code>toCompletableFuture()</code> 从 <code>CompletionStage</code> 生成一个<code>CompletableFuture</code>。</li><li><code>c.complete(9)</code> 显示了如何通过给它一个结果来完成一个<code>task</code>（<code>future</code>）（与 <code>obtrudeValue()</code> 相对，后者可能会迫使其结果替换该结果）。</li><li>如果你调用 <code>CompletableFuture</code>中的 <code>cancel()</code>方法，如果已经完成此任务，则正常结束。 如果尚未完成，则使用 <code>CancellationException</code> 完成此 <code>CompletableFuture</code>。</li><li>如果任务（<code>future</code>）完成，则<strong>getNow()</strong>方法返回<code>CompletableFuture</code>的完成值，否则返回<code>getNow()</code>的替换参数。</li><li>最后，我们看一下依赖(<code>dependents</code>)的概念。如果我们将两个<code>thenApplyAsync()</code>调用链路到<code>CompletableFuture</code>上，则依赖项的数量不会增加，保持为1。但是，如果我们另外将另一个<code>thenApplyAsync()</code>直接附加到<code>c</code>，则现在有两个依赖项：两个一起的链路和另一个单独附加的链路。<ul><li>这表明你可以使用一个<code>CompletionStage</code>，当它完成时，可以根据其结果派生多个新任务。</li></ul></li></ul></li></ul><h3 id="结合-CompletableFuture"><a href="#结合-CompletableFuture" class="headerlink" title="结合 CompletableFuture"></a>结合 CompletableFuture</h3><p>第二种类型的 <code>CompletableFuture</code> 方法采用两种 <code>CompletableFuture</code> 并以各异方式将它们组合在一起。就像两个人在比赛一样, 一个<code>CompletableFuture</code>通常比另一个更早地到达终点。这些方法允许你以不同的方式处理结果。<br>为了测试这一点，我们将创建一个任务，它有一个我们可以控制的定义了完成任务所需要的时间量的参数。<br>CompletableFuture 先完成:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/Workable.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> onjava.Nap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Workable</span> </span>&#123;</span><br><span class="line">    String id;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> duration;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Workable</span><span class="params">(String id, <span class="keyword">double</span> duration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.duration = duration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Workable["</span> + id + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Workable <span class="title">work</span><span class="params">(Workable tt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Nap(tt.duration); <span class="comment">// Seconds</span></span><br><span class="line">        tt.id = tt.id + <span class="string">"W"</span>;</span><br><span class="line">        System.out.println(tt);</span><br><span class="line">        <span class="keyword">return</span> tt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Workable&gt; <span class="title">make</span><span class="params">(String id, <span class="keyword">double</span> duration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture</span><br><span class="line">                .completedFuture(</span><br><span class="line">                        <span class="keyword">new</span> Workable(id, duration)</span><br><span class="line">                )</span><br><span class="line">                .thenApplyAsync(Workable::work);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>make()</code>中，<code>work()</code>方法应用于<code>CompletableFuture</code>。<code>work()</code>需要一定的时间才能完成，然后它将字母W附加到id上，表示工作已经完成。</p><p>现在我们可以创建多个竞争的 <code>CompletableFuture</code>，并使用 <code>CompletableFuture</code> 库中的各种方法来进行操作:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/DualCompletableOperations.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> onjava.CompletableUtilities.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DualCompletableOperations</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> CompletableFuture&lt;Workable&gt; cfA, cfB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cfA = Workable.make(<span class="string">"A"</span>, <span class="number">0.15</span>);</span><br><span class="line">        cfB = Workable.make(<span class="string">"B"</span>, <span class="number">0.10</span>); <span class="comment">// Always wins</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cfA.join();</span><br><span class="line">        cfB.join();</span><br><span class="line">        System.out.println(<span class="string">"*****************"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        voidr(cfA.runAfterEitherAsync(cfB, () -&gt;</span><br><span class="line">                System.out.println(<span class="string">"runAfterEither"</span>)));</span><br><span class="line">        join();</span><br><span class="line"></span><br><span class="line">        init();</span><br><span class="line">        voidr(cfA.runAfterBothAsync(cfB, () -&gt;</span><br><span class="line">                System.out.println(<span class="string">"runAfterBoth"</span>)));</span><br><span class="line">        join();</span><br><span class="line"></span><br><span class="line">        init();</span><br><span class="line">        showr(cfA.applyToEitherAsync(cfB, w -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"applyToEither: "</span> + w);</span><br><span class="line">            <span class="keyword">return</span> w;</span><br><span class="line">        &#125;));</span><br><span class="line">        join();</span><br><span class="line"></span><br><span class="line">        init();</span><br><span class="line">        voidr(cfA.acceptEitherAsync(cfB, w -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"acceptEither: "</span> + w);</span><br><span class="line">        &#125;));</span><br><span class="line">        join();</span><br><span class="line"></span><br><span class="line">        init();</span><br><span class="line">        voidr(cfA.thenAcceptBothAsync(cfB, (w1, w2) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"thenAcceptBoth: "</span></span><br><span class="line">                    + w1 + <span class="string">", "</span> + w2);</span><br><span class="line">        &#125;));</span><br><span class="line">        join();</span><br><span class="line"></span><br><span class="line">        init();</span><br><span class="line">        showr(cfA.thenCombineAsync(cfB, (w1, w2) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"thenCombine: "</span></span><br><span class="line">                    + w1 + <span class="string">", "</span> + w2);</span><br><span class="line">            <span class="keyword">return</span> w1;</span><br><span class="line">        &#125;));</span><br><span class="line">        join();</span><br><span class="line"></span><br><span class="line">        init();</span><br><span class="line">        CompletableFuture&lt;Workable&gt;</span><br><span class="line">                cfC = Workable.make(<span class="string">"C"</span>, <span class="number">0.08</span>),</span><br><span class="line">                cfD = Workable.make(<span class="string">"D"</span>, <span class="number">0.09</span>);</span><br><span class="line">        CompletableFuture.anyOf(cfA, cfB, cfC, cfD)</span><br><span class="line">                .thenRunAsync(() -&gt;</span><br><span class="line">                        System.out.println(<span class="string">"anyOf"</span>));</span><br><span class="line">        join();</span><br><span class="line"></span><br><span class="line">        init();</span><br><span class="line">        cfC = Workable.make(<span class="string">"C"</span>, <span class="number">0.08</span>);</span><br><span class="line">        cfD = Workable.make(<span class="string">"D"</span>, <span class="number">0.09</span>);</span><br><span class="line">        CompletableFuture.allOf(cfA, cfB, cfC, cfD)</span><br><span class="line">                .thenRunAsync(() -&gt;</span><br><span class="line">                        System.out.println(<span class="string">"allOf"</span>));</span><br><span class="line">        join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Workable[BW]</span><br><span class="line">runAfterEither</span><br><span class="line">Workable[AW]</span><br><span class="line">*****************</span><br><span class="line">Workable[BW]</span><br><span class="line">Workable[AW]</span><br><span class="line">runAfterBoth</span><br><span class="line">*****************</span><br><span class="line">Workable[BW]</span><br><span class="line">applyToEither: Workable[BW]</span><br><span class="line">Workable[BW]</span><br><span class="line">Workable[AW]</span><br><span class="line">*****************</span><br><span class="line">Workable[BW]</span><br><span class="line">acceptEither: Workable[BW]</span><br><span class="line">Workable[AW]</span><br><span class="line">*****************</span><br><span class="line">Workable[BW]</span><br><span class="line">Workable[AW]</span><br><span class="line">thenAcceptBoth: Workable[AW], Workable[BW]</span><br><span class="line">****************</span><br><span class="line"> Workable[BW]</span><br><span class="line"> Workable[AW]</span><br><span class="line"> thenCombine: Workable[AW], Workable[BW]</span><br><span class="line"> Workable[AW]</span><br><span class="line"> *****************</span><br><span class="line"> Workable[CW]</span><br><span class="line"> anyOf</span><br><span class="line"> Workable[DW]</span><br><span class="line"> Workable[BW]</span><br><span class="line"> Workable[AW]</span><br><span class="line"> *****************</span><br><span class="line"> Workable[CW]</span><br><span class="line"> Workable[DW]</span><br><span class="line"> Workable[BW]</span><br><span class="line"> Workable[AW]</span><br><span class="line"> *****************</span><br><span class="line"> allOf</span><br></pre></td></tr></table></figure><ul><li>为了方便访问， 将 <code>cfA</code> 和 <code>cfB</code> 定义为 <code>static</code>的。 <ul><li><code>init()</code>方法用于 <code>A</code>, <code>B</code> 初始化这两个变量，因为 <code>B</code> 总是给出比<code>A</code>较短的延迟，所以总是 <code>win</code> 的一方。</li><li><code>join()</code> 是在两个方法上调用 <code>join()</code> 并显示边框的另一个便利方法。</li></ul></li><li>所有这些 “<code>dual</code>” 方法都以一个 <code>CompletableFuture</code> 作为调用该方法的对象，第二个 <code>CompletableFuture</code> 作为第一个参数，然后是要执行的操作。</li><li>通过使用 <code>showr()</code> 和 <code>voidr()</code> 可以看到，“<code>run</code>”和“<code>accept</code>”是终端操作，而“<code>apply</code>”和“<code>combine</code>”则生成新的 <code>payload-bearing</code> (承载负载)的 <code>CompletableFuture</code>。</li><li>方法的名称不言自明，你可以通过查看输出来验证这一点。一个特别有趣的方法是 <code>combineAsync()</code>，它等待两个 <code>CompletableFuture</code> 完成，然后将它们都交给一个 <code>BiFunction</code>，这个 <code>BiFunction</code> 可以将结果加入到最终的 <code>CompletableFuture</code> 的有效负载中。</li></ul><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><p>作为使用 <code>CompletableFuture</code> 将一系列操作组合的示例，让我们模拟一下制作蛋糕的过程。在第一阶段，我们准备并将原料混合成面糊:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/Batter.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> onjava.Nap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Batter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Eggs</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Milk</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sugar</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Flour</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">prepare</span><span class="params">(T ingredient)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Nap(<span class="number">0.1</span>);</span><br><span class="line">        <span class="keyword">return</span> ingredient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">CompletableFuture&lt;T&gt; <span class="title">prep</span><span class="params">(T ingredient)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture</span><br><span class="line">                .completedFuture(ingredient)</span><br><span class="line">                .thenApplyAsync(Batter::prepare);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Batter&gt; <span class="title">mix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CompletableFuture&lt;Eggs&gt; eggs = prep(<span class="keyword">new</span> Eggs());</span><br><span class="line">        CompletableFuture&lt;Milk&gt; milk = prep(<span class="keyword">new</span> Milk());</span><br><span class="line">        CompletableFuture&lt;Sugar&gt; sugar = prep(<span class="keyword">new</span> Sugar());</span><br><span class="line">        CompletableFuture&lt;Flour&gt; flour = prep(<span class="keyword">new</span> Flour());</span><br><span class="line">        CompletableFuture</span><br><span class="line">                .allOf(eggs, milk, sugar, flour)</span><br><span class="line">                .join();</span><br><span class="line">        <span class="keyword">new</span> Nap(<span class="number">0.1</span>); <span class="comment">// Mixing time</span></span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="keyword">new</span> Batter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每种原料都需要一些时间来准备。<code>allOf()</code> 等待所有的配料都准备好，然后使用更多些的时间将其混合成面糊。接下来，我们把单批面糊放入四个平底锅中烘烤。产品作为 <code>CompletableFutures</code>  流返回：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/Baked.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">import</span> onjava.Nap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Baked</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pan</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Pan <span class="title">pan</span><span class="params">(Batter b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Nap(<span class="number">0.1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pan();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Baked <span class="title">heat</span><span class="params">(Pan p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Nap(<span class="number">0.1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Baked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> CompletableFuture&lt;Baked&gt; <span class="title">bake</span><span class="params">(CompletableFuture&lt;Batter&gt; cfb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cfb</span><br><span class="line">                .thenApplyAsync(Baked::pan)</span><br><span class="line">                .thenApplyAsync(Baked::heat);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;CompletableFuture&lt;Baked&gt;&gt; batch() &#123;</span><br><span class="line">        CompletableFuture&lt;Batter&gt; batter = Batter.mix();</span><br><span class="line">        <span class="keyword">return</span> Stream.of(</span><br><span class="line">                bake(batter),</span><br><span class="line">                bake(batter),</span><br><span class="line">                bake(batter),</span><br><span class="line">                bake(batter)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们制作了一批糖，并用它对蛋糕进行糖化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/FrostedCake.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">import</span> onjava.Nap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Frosting</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Frosting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> CompletableFuture&lt;Frosting&gt; <span class="title">make</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Nap(<span class="number">0.1</span>);</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture</span><br><span class="line">                .completedFuture(<span class="keyword">new</span> Frosting());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FrostedCake</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FrostedCake</span><span class="params">(Baked baked, Frosting frosting)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Nap(<span class="number">0.1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"FrostedCake"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Baked.batch().forEach(</span><br><span class="line">                baked -&gt; baked</span><br><span class="line">                        .thenCombineAsync(Frosting.make(),</span><br><span class="line">                                (cake, frosting) -&gt;</span><br><span class="line">                                        <span class="keyword">new</span> FrostedCake(cake, frosting))</span><br><span class="line">                        .thenAcceptAsync(System.out::println)</span><br><span class="line">                        .join());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦你习惯了这种背后的想法, <code>CompletableFuture</code> 它们相对易于使用。</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>与 <code>CompletableFuture</code> 在处理链中包装对象的方式相同，它也会缓冲异常。这些在处理时调用者是无感的，但仅当你尝试提取结果时才会被告知。为了说明它们是如何工作的，我们首先创建一个类，它在特定的条件下抛出一个异常:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/Breakable.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Breakable</span> </span>&#123;</span><br><span class="line">    String id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> failcount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Breakable</span><span class="params">(String id, <span class="keyword">int</span> failcount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.failcount = failcount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Breakable_"</span> + id + <span class="string">" ["</span> + failcount + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Breakable <span class="title">work</span><span class="params">(Breakable b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (--b.failcount == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(</span><br><span class="line">                    <span class="string">"Throwing Exception for "</span> + b.id + <span class="string">""</span></span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"Breakable_"</span> + b.id + <span class="string">" failed"</span></span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(b);</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>failcount</code> &gt; 0，且每次将对象传递给 <code>work()</code> 方法时， <code>failcount - 1</code> 。当<code>failcount - 1 = 0</code> 时，<code>work()</code> 将抛出一个异常。如果传给 <code>work()</code> 的 <code>failcount = 0</code> ，<code>work()</code> 永远不会抛出异常。</p><p>注意，异常信息此示例中被抛出（ <code>RuntimeException</code> )</p><p>在下面示例  <code>test()</code> 方法中，<code>work()</code> 多次应用于 <code>Breakable</code>，因此如果 <code>failcount</code> 在范围内，就会抛出异常。然而，在测试<code>A</code>到<code>E</code>中，你可以从输出中看到抛出了异常，但它们从未出现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/CompletableExceptions.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableExceptions</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> CompletableFuture&lt;Breakable&gt; <span class="title">test</span><span class="params">(String id, <span class="keyword">int</span> failcount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.completedFuture(</span><br><span class="line">                <span class="keyword">new</span> Breakable(id, failcount))</span><br><span class="line">                .thenApply(Breakable::work)</span><br><span class="line">                .thenApply(Breakable::work)</span><br><span class="line">                .thenApply(Breakable::work)</span><br><span class="line">                .thenApply(Breakable::work);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Exceptions don't appear ...</span></span><br><span class="line">        test(<span class="string">"A"</span>, <span class="number">1</span>);</span><br><span class="line">        test(<span class="string">"B"</span>, <span class="number">2</span>);</span><br><span class="line">        test(<span class="string">"C"</span>, <span class="number">3</span>);</span><br><span class="line">        test(<span class="string">"D"</span>, <span class="number">4</span>);</span><br><span class="line">        test(<span class="string">"E"</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="comment">// ... until you try to fetch the value:</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test(<span class="string">"F"</span>, <span class="number">2</span>).get(); <span class="comment">// or join()</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Test for exceptions:</span></span><br><span class="line">        System.out.println(</span><br><span class="line">                test(<span class="string">"G"</span>, <span class="number">2</span>).isCompletedExceptionally()</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// Counts as "done":</span></span><br><span class="line">        System.out.println(test(<span class="string">"H"</span>, <span class="number">2</span>).isDone());</span><br><span class="line">        <span class="comment">// Force an exception:</span></span><br><span class="line">        CompletableFuture&lt;Integer&gt; cfi =</span><br><span class="line">                <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        System.out.println(<span class="string">"done? "</span> + cfi.isDone());</span><br><span class="line">        cfi.completeExceptionally(</span><br><span class="line">                <span class="keyword">new</span> RuntimeException(<span class="string">"forced"</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cfi.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Throwing Exception for A</span><br><span class="line">Breakable_B [1]</span><br><span class="line">Throwing Exception for B</span><br><span class="line">Breakable_C [2]</span><br><span class="line">Breakable_C [1]</span><br><span class="line">Throwing Exception for C</span><br><span class="line">Breakable_D [3]</span><br><span class="line">Breakable_D [2]</span><br><span class="line">Breakable_D [1]</span><br><span class="line">Throwing Exception for D</span><br><span class="line">Breakable_E [4]</span><br><span class="line">Breakable_E [3]</span><br><span class="line">Breakable_E [2]</span><br><span class="line">Breakable_E [1]</span><br><span class="line">Breakable_F [1]</span><br><span class="line">Throwing Exception for F</span><br><span class="line">java.lang.RuntimeException: Breakable_F failed</span><br><span class="line">Breakable_G [1]</span><br><span class="line">Throwing Exception for G</span><br><span class="line">true</span><br><span class="line">Breakable_H [1]</span><br><span class="line">Throwing Exception for H</span><br><span class="line">true</span><br><span class="line">done? false</span><br><span class="line">java.lang.RuntimeException: forced</span><br></pre></td></tr></table></figure><p>测试 <code>A</code> 到 <code>E</code> 运行到抛出异常，然后…并没有将抛出的异常暴露给调用方。只有在测试F中调用 <code>get()</code> 时，我们才会看到抛出的异常。<br>测试 <code>G</code> 表明，你可以首先检查在处理期间是否抛出异常，而不抛出该异常。然而，test <code>H</code> 告诉我们，不管异常是否成功，它仍然被视为已“完成”。<br>代码的最后一部分展示了如何将异常插入到 <code>CompletableFuture</code> 中，而不管是否存在任何失败。<br>在连接或获取结果时，我们使用 <code>CompletableFuture</code> 提供的更复杂的机制来自动响应异常，而不是使用粗糙的 <code>try-catch</code>。<br>你可以使用与我们看到的所有 <code>CompletableFuture</code>  相同的表单来完成此操作:在链中插入一个  <code>CompletableFuture</code> 调用。有三个选项 <code>exceptionally()</code>，<code>handle()</code>， <code>whenComplete()</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/CatchCompletableExceptions.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CatchCompletableExceptions</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleException</span><span class="params">(<span class="keyword">int</span> failcount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Call the Function only if there's an</span></span><br><span class="line">        <span class="comment">// exception, must produce same type as came in:</span></span><br><span class="line">        CompletableExceptions</span><br><span class="line">                .test(<span class="string">"exceptionally"</span>, failcount)</span><br><span class="line">                .exceptionally((ex) -&gt; &#123; <span class="comment">// Function</span></span><br><span class="line">                    <span class="keyword">if</span> (ex == <span class="keyword">null</span>)</span><br><span class="line">                        System.out.println(<span class="string">"I don't get it yet"</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> Breakable(ex.getMessage(), <span class="number">0</span>);</span><br><span class="line">                &#125;)</span><br><span class="line">                .thenAccept(str -&gt;</span><br><span class="line">                        System.out.println(<span class="string">"result: "</span> + str));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a new result (recover):</span></span><br><span class="line">        CompletableExceptions</span><br><span class="line">                .test(<span class="string">"handle"</span>, failcount)</span><br><span class="line">                .handle((result, fail) -&gt; &#123; <span class="comment">// BiFunction</span></span><br><span class="line">                    <span class="keyword">if</span> (fail != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">"Failure recovery object"</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span> result + <span class="string">" is good"</span>;</span><br><span class="line">                &#125;)</span><br><span class="line">                .thenAccept(str -&gt;</span><br><span class="line">                        System.out.println(<span class="string">"result: "</span> + str));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do something but pass the same result through:</span></span><br><span class="line">        CompletableExceptions</span><br><span class="line">                .test(<span class="string">"whenComplete"</span>, failcount)</span><br><span class="line">                .whenComplete((result, fail) -&gt; &#123; <span class="comment">// BiConsumer</span></span><br><span class="line">                    <span class="keyword">if</span> (fail != <span class="keyword">null</span>)</span><br><span class="line">                        System.out.println(<span class="string">"It failed"</span>);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        System.out.println(result + <span class="string">" OK"</span>);</span><br><span class="line">                &#125;)</span><br><span class="line">                .thenAccept(r -&gt;</span><br><span class="line">                        System.out.println(<span class="string">"result: "</span> + r));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"**** Failure Mode ****"</span>);</span><br><span class="line">        handleException(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">"**** Success Mode ****"</span>);</span><br><span class="line">        handleException(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">**** Failure Mode ****</span><br><span class="line">Breakable_exceptionally [1]</span><br><span class="line">Throwing Exception for exceptionally</span><br><span class="line">result: Breakable_java.lang.RuntimeException:</span><br><span class="line">Breakable_exceptionally failed [0]</span><br><span class="line">Breakable_handle [1]</span><br><span class="line">Throwing Exception for handle</span><br><span class="line">result: Failure recovery object</span><br><span class="line">Breakable_whenComplete [1]</span><br><span class="line">Throwing Exception for whenComplete</span><br><span class="line">It failed</span><br><span class="line">**** Success Mode ****</span><br><span class="line">Breakable_exceptionally [-1]</span><br><span class="line">Breakable_exceptionally [-2]</span><br><span class="line">Breakable_exceptionally [-3]</span><br><span class="line">Breakable_exceptionally [-4]</span><br><span class="line">result: Breakable_exceptionally [-4]</span><br><span class="line">Breakable_handle [-1]</span><br><span class="line">Breakable_handle [-2]</span><br><span class="line">Breakable_handle [-3]</span><br><span class="line">Breakable_handle [-4]</span><br><span class="line">result: Breakable_handle [-4] is good</span><br><span class="line">Breakable_whenComplete [-1]</span><br><span class="line">Breakable_whenComplete [-2]</span><br><span class="line">Breakable_whenComplete [-3]</span><br><span class="line">Breakable_whenComplete [-4]</span><br><span class="line">Breakable_whenComplete [-4] OK</span><br><span class="line">result: Breakable_whenComplete [-4]</span><br></pre></td></tr></table></figure><ul><li><p><code>exceptionally()</code>  参数仅在出现异常时才运行。<code>exceptionally()</code>  局限性在于，该函数只能返回输入类型相同的值。</p></li><li><p><code>exceptionally()</code> 通过将一个好的对象插入到流中来恢复到一个可行的状态。</p></li><li><p><code>handle()</code> 一致被调用来查看是否发生异常（必须检查fail是否为true）。</p><ul><li><p>但是 <code>handle()</code> 可以生成任何新类型，所以它允许执行处理，而不是像使用 <code>exceptionally()</code>那样简单地恢复。</p></li><li><p><code>whenComplete()</code> 类似于handle()，同样必须测试它是否失败，但是参数是一个消费者，并且不修改传递给它的结果对象。</p></li></ul></li></ul><h3 id="流异常（Stream-Exception）"><a href="#流异常（Stream-Exception）" class="headerlink" title="流异常（Stream Exception）"></a>流异常（Stream Exception）</h3><p>通过修改<strong>CompletableExceptions.java</strong>，看看 <strong>CompletableFuture</strong>异常与流异常有何不同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/StreamExceptions.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamExceptions</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> Stream&lt;Breakable&gt; <span class="title">test</span><span class="params">(String id, <span class="keyword">int</span> failcount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Stream.of(<span class="keyword">new</span> Breakable(id, failcount))</span><br><span class="line">                .map(Breakable::work)</span><br><span class="line">                .map(Breakable::work)</span><br><span class="line">                .map(Breakable::work)</span><br><span class="line">                .map(Breakable::work);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// No operations are even applied ...</span></span><br><span class="line">        test(<span class="string">"A"</span>, <span class="number">1</span>);</span><br><span class="line">        test(<span class="string">"B"</span>, <span class="number">2</span>);</span><br><span class="line">        Stream&lt;Breakable&gt; c = test(<span class="string">"C"</span>, <span class="number">3</span>);</span><br><span class="line">        test(<span class="string">"D"</span>, <span class="number">4</span>);</span><br><span class="line">        test(<span class="string">"E"</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="comment">// ... until there's a terminal operation:</span></span><br><span class="line">        System.out.println(<span class="string">"Entering try"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.forEach(System.out::println);   <span class="comment">// [1]</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Entering try</span><br><span class="line">Breakable_C [2]</span><br><span class="line">Breakable_C [1]</span><br><span class="line">Throwing Exception for C</span><br><span class="line">Breakable_C failed</span><br></pre></td></tr></table></figure><p>使用 <code>CompletableFuture</code>，我们可以看到测试A到E的进展，但是使用流，在你应用一个终端操作之前（e.g. <code>forEach()</code>），什么都不会暴露给 Client </p><p><code>CompletableFuture</code> 执行工作并捕获任何异常供以后检索。比较这两者并不容易，因为 <code>Stream</code> 在没有终端操作的情况下根本不做任何事情——但是流绝对不会存储它的异常。</p><h3 id="检查性异常"><a href="#检查性异常" class="headerlink" title="检查性异常"></a>检查性异常</h3><p><code>CompletableFuture</code> 和 <code>parallel Stream</code> 都不支持包含检查性异常的操作。相反，你必须在调用操作时处理检查到的异常，这会产生不太优雅的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/ThrowsChecked.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowsChecked</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Checked</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> ThrowsChecked <span class="title">nochecked</span><span class="params">(ThrowsChecked tc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> ThrowsChecked <span class="title">withchecked</span><span class="params">(ThrowsChecked tc)</span> <span class="keyword">throws</span> Checked </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Stream.of(<span class="keyword">new</span> ThrowsChecked())</span><br><span class="line">                .map(ThrowsChecked::nochecked)</span><br><span class="line">                <span class="comment">// .map(ThrowsChecked::withchecked); // [1]</span></span><br><span class="line">                .map(</span><br><span class="line">                        tc -&gt; &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="keyword">return</span> withchecked(tc);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Checked e) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testCompletableFuture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CompletableFuture</span><br><span class="line">                .completedFuture(<span class="keyword">new</span> ThrowsChecked())</span><br><span class="line">                .thenApply(ThrowsChecked::nochecked)</span><br><span class="line">                <span class="comment">// .thenApply(ThrowsChecked::withchecked); // [2]</span></span><br><span class="line">                .thenApply(</span><br><span class="line">                        tc -&gt; &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="keyword">return</span> withchecked(tc);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Checked e) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你试图像使用 <code>nochecked()</code> 那样使用<code>withchecked()</code> 的方法引用，编译器会在 <code>[1]</code> 和 <code>[2]</code> 中报错。相反，你必须写出lambda表达式(或者编写一个不会抛出异常的包装器方法)。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>由于任务可以被阻塞，因此一个任务有可能卡在等待另一个任务上，而后者又在等待别的任务，这样一直下去，知道这个链条上的任务又在等待第一个任务释放锁。这得到了一个任务之间相互等待的连续循环， 没有哪个线程能继续， 这称之为死锁<a href="当两个任务能够更改其状态以使它们不会被阻止但它们从未取得任何有用的进展时，你也可以使用活动锁。">^6</a><br>如果你运行一个程序，而它马上就死锁了， 你可以立即跟踪下去。真正的问题在于，程序看起来工作良好， 但是具有潜在的死锁危险。这时， 死锁可能发生，而事先却没有任何征兆， 所以 <code>bug</code> 会潜伏在你的程序例，直到客户发现它出乎意料的发生（以一种几乎肯定是很难重现的方式发生）。因此在编写并发程序的时候，进行仔细的程序设计以防止死锁是关键部分。<br>埃德斯·迪克斯特拉（<code>Essger Dijkstra</code>）发明的“哲学家进餐”问题是经典的死锁例证。基本描述指定了五位哲学家（此处显示的示例允许任何数目）。这些哲学家将花部分时间思考，花部分时间就餐。他们在思考的时候并不需要任何共享资源；但是他们使用的餐具数量有限。在最初的问题描述中，餐具是叉子，需要两个叉子才能从桌子中间的碗里取出意大利面。常见的版本是使用筷子， 显然，每个哲学家都需要两根筷子才能吃饭。<br>引入了一个困难：作为哲学家，他们的钱很少，所以他们只能买五根筷子（更一般地讲，筷子的数量与哲学家相同）。他们围在桌子周围，每人之间放一根筷子。 当一个哲学家要就餐时，该哲学家必须同时持有左边和右边的筷子。如果任一侧的哲学家都在使用所需的筷子，则我们的哲学家必须等待，直到可得到必须的筷子。</p><p><strong>StickHolder</strong> 类通过将单根筷子保持在大小为1的<strong>BlockingQueue</strong>中来管理它。<strong>BlockingQueue</strong>是一个设计用于在并发程序中安全使用的集合，如果你调用take()并且队列为空，则它将阻塞（等待）。将新元素放入队列后，将释放该块并返回该值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/StickHolder.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StickHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Chopstick</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Chopstick stick = <span class="keyword">new</span> Chopstick();</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Chopstick&gt; holder =</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StickHolder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        putDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pickUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            holder.take(); <span class="comment">// Blocks if unavailable</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            holder.put(stick);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为简单起见，<code>Chopstick</code>(<code>static</code>) 实际上不是由 <code>StickHolder</code> 生产的，而是在其类中保持私有的。</p><p>如果您调用了<code>pickUp()</code>，而 <code>stick</code> 不可用，那么<code>pickUp()</code>将阻塞该 <code>stick</code>，直到另一个哲学家调用<code>putDown()</code> 将 <code>stick</code> 返回。 </p><p>注意，该类中的所有线程安全都是通过 <code>BlockingQueue</code> 实现的。</p><p>每个哲学家都是一项任务，他们试图把筷子分别 <code>pickUp()</code> 在左手和右手上，这样筷子才能吃东西，然后通过 <code>putDown()</code> 放下 <code>stick</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/Philosopher.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Philosopher</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> seat;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StickHolder left, right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Philosopher</span><span class="params">(<span class="keyword">int</span> seat, StickHolder left, StickHolder right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seat = seat;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"P"</span> + seat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// System.out.println("Thinking");   // [1]</span></span><br><span class="line">            right.pickUp();</span><br><span class="line">            left.pickUp();</span><br><span class="line">            System.out.println(<span class="keyword">this</span> + <span class="string">" eating"</span>);</span><br><span class="line">            right.putDown();</span><br><span class="line">            left.putDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有两个哲学家可以同时成功调用take()同一只筷子。另外，如果一个哲学家已经拿过筷子，那么下一个试图拿起同一根筷子的哲学家将阻塞，等待其被释放。</p><p>结果是一个看似无辜的程序陷入了死锁。我在这里使用数组而不是集合，只是因为这种语法更简洁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/DiningPhilosophers.java</span></span><br><span class="line"><span class="comment">// Hidden deadlock</span></span><br><span class="line"><span class="comment">// &#123;ExcludeFromGradle&#125; Gradle has trouble</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> onjava.Nap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiningPhilosophers</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> StickHolder[] sticks;</span><br><span class="line">    <span class="keyword">private</span> Philosopher[] philosophers;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiningPhilosophers</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        sticks = <span class="keyword">new</span> StickHolder[n];</span><br><span class="line">        Arrays.setAll(sticks, i -&gt; <span class="keyword">new</span> StickHolder());</span><br><span class="line">        philosophers = <span class="keyword">new</span> Philosopher[n];</span><br><span class="line">        Arrays.setAll(philosophers, i -&gt;</span><br><span class="line">                <span class="keyword">new</span> Philosopher(i,</span><br><span class="line">                        sticks[i], sticks[(i + <span class="number">1</span>) % n]));    <span class="comment">// [1]</span></span><br><span class="line">        <span class="comment">// Fix by reversing stick order for this one:</span></span><br><span class="line">        <span class="comment">// philosophers[1] =                     // [2]</span></span><br><span class="line">        <span class="comment">//   new Philosopher(0, sticks[0], sticks[1]);</span></span><br><span class="line">        Arrays.stream(philosophers)</span><br><span class="line">                .forEach(CompletableFuture::runAsync); <span class="comment">// [3]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Returns right away:</span></span><br><span class="line">        <span class="keyword">new</span> DiningPhilosophers(<span class="number">5</span>);               <span class="comment">// [4]</span></span><br><span class="line">        <span class="comment">// Keeps main() from exiting:</span></span><br><span class="line">        <span class="keyword">new</span> Nap(<span class="number">3</span>, <span class="string">"Shutdown"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当你停止查看输出时，该程序将死锁。但是，根据你的计算机配置，你可能不会看到死锁。看来这取决于计算机上的内核数[^7]。两个核心不会产生死锁，但两核以上却很容易产生死锁。</li><li>此行为使该示例更好地说明了死锁，因为你可能正在具有2核的计算机上编写程序（如果确实是导致问题的原因），并且确信该程序可以正常工作，只能启动它将其安装在另一台计算机上时出现死锁。请注意，不能因为你没或不容易看到死锁，这并不意味着此程序不会在2核机器上发生死锁。 该程序仍然有死锁倾向，只是很少发生——可以说是最糟糕的情况，因为问题不容易出现。</li><li>在 <code>DiningPhilosophers</code> 的构造方法中，每个哲学家都获得一个左右筷子的引用。除最后一个哲学家外，都是通过把哲学家放在下一双空闲筷子之间来初始化： <ul><li>最后一位哲学家得到了第0根筷子作为他的右筷子，所以圆桌就完成。</li><li>那是因为最后一位哲学家正坐在第一个哲学家的旁边，而且他们俩都共用零筷子。[1]显示了以n为模数选择的右筷子，将最后一个哲学家绕到第一个哲学家的旁边。</li></ul></li><li>现在，所有哲学家都可以尝试吃饭，每个哲学家都在旁边等待哲学家放下筷子。<ul><li>为了让每个哲学家在[3]上运行，调用 <code>runAsync()</code>，这意味着DiningPhilosophers的构造函数立即返回到[4]。</li><li>如果没有任何东西阻止 <code>main()</code> 完成，程序就会退出，不会做太多事情。</li><li><code>Nap</code> 对象阻止 <code>main()</code> 退出，然后在三秒后强制退出(假设/可能是)死锁程序。</li><li>在给定的配置中，哲学家几乎不花时间思考。因此，他们在吃东西的时候都争着用筷子，而且往往很快就会陷入僵局。你可以改变这个:</li></ul></li></ul><ol><li><p>通过增加[4]的值来添加更多哲学家。</p></li><li><p>在Philosopher.java中取消注释行[1]。</p></li></ol><p>任一种方法都会减少死锁的可能性，这表明编写并发程序并认为它是安全的危险，因为它似乎“在我的机器上运行正常”。你可以轻松地说服自己该程序没有死锁，即使它不是。这个示例相当有趣，因为它演示了看起来可以正确运行，但实际上会可能发生死锁的程序。</p><p>要修正死锁问题，你必须明白，当以下四个条件同时满足时，就会发生死锁：</p><p>1) 互斥条件。任务使用的资源中至少有一个不能共享的。 这里，一根筷子一次就只能被一个哲学家使用。<br>2) 至少有一个任务它必须持有一个资源且正在等待获取一个被当前别的任务持有的资源。也就是说，要发生死锁，哲学家必须拿着一根筷子并且等待另一根。<br>3) 资源不能被任务抢占， 任务必须把资源释放当作普通事件。哲学家很有礼貌，他们不会从其它哲学家那里抢筷子。<br>4) 必须有循环等待， 这时，一个任务等待其它任务所持有的资源， 后者又在等待另一个任务所持有的资源， 这样一直下去，知道有一个任务在等待第一个任务所持有的资源， 使得大家都被锁住。 在 <code>DiningPhilosophers.java</code> 中， 因为每个哲学家都试图先得到右边的 筷子, 然后得到左边的 筷子, 所以发生了循环等待。</p><p>因为必须满足所有条件才能导致死锁，所以要阻止死锁的话，只需要破坏其中一个即可。在此程序中，防止死锁的一种简单方法是打破第四个条件。之所以会发生这种情况，是因为每个哲学家都尝试按照特定的顺序拾起自己的筷子：先右后左。因此，每个哲学家都有可能在等待左手的同时握住右手的筷子，从而导致循环等待状态。但是，如果其中一位哲学家尝试首先拿起左筷子，则该哲学家决不会阻止紧邻右方的哲学家拿起筷子，从而排除了循环等待。</p><p>在<strong>DiningPhilosophers.java</strong>中，取消注释[1]和其后的一行。这将原来的哲学家[1]替换为筷子颠倒的哲学家。通过确保第二位哲学家拾起并在右手之前放下左筷子，我们消除了死锁的可能性。<br>这只是解决问题的一种方法。你也可以通过防止其他情况之一来解决它。<br>没有语言支持可以帮助防止死锁；你有责任通过精心设计来避免这种情况。对于试图调试死锁程序的人来说，这些都不是安慰。当然，避免并发问题的最简单，最好的方法是永远不要共享资源-不幸的是，这并不总是可能的。</p><h2 id="构造方法非线程安全"><a href="#构造方法非线程安全" class="headerlink" title="构造方法非线程安全"></a>构造方法非线程安全</h2><p>当你在脑子里想象一个对象构造的过程，你会很容易认为这个过程是线程安全的。毕竟，在对象初始化完成前对外不可见，所以又怎会对此产生争议呢？确实，<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.8.3" target="_blank" rel="noopener">Java 语言规范</a> (JLS)自信满满地陈述道：“<em>没必要使构造器的线程同步，因为它会锁定正在构造的对象，直到构造器完成初始化后才对其他线程可见。</em>”</p><p>不幸的是，对象的构造过程如其他操作一样，也会受到共享内存并发问题的影响，只是作用机制可能更微妙罢了。</p><p>设想下使用一个 <strong>static</strong> 字段为每个对象自动创建唯一标识符的过程。为了测试其不同的实现过程，我们从一个接口开始。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//concurrent/HasID.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HasID</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getID</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后 <strong>StaticIDField</strong> 类显式地实现该接口。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/StaticIDField.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticIDField</span> <span class="keyword">implements</span> <span class="title">HasID</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id = counter++;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getID</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> id; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如你所想，该类是个简单无害的类，它甚至都没一个显式的构造器来引发问题。当我们运行多个用于创建此类对象的线程时，究竟会发生什么？为了搞清楚这点，我们做了以下测试。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/IDChecker.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Sets;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IDChecker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">100_000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MakeObjects</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">        <span class="title">Supplier</span>&lt;<span class="title">List</span>&lt;<span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Supplier&lt;HasID&gt; gen;</span><br><span class="line"></span><br><span class="line">        MakeObjects(Supplier&lt;HasID&gt; gen) &#123;</span><br><span class="line">            <span class="keyword">this</span>.gen = gen;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Stream.generate(gen)</span><br><span class="line">            .limit(SIZE)</span><br><span class="line">            .map(HasID::getID)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Supplier&lt;HasID&gt; gen)</span> </span>&#123;</span><br><span class="line">        CompletableFuture&lt;List&lt;Integer&gt;&gt;</span><br><span class="line">        groupA = CompletableFuture.supplyAsync(<span class="keyword">new</span></span><br><span class="line">            MakeObjects(gen)),</span><br><span class="line">        groupB = CompletableFuture.supplyAsync(<span class="keyword">new</span></span><br><span class="line">            MakeObjects(gen));</span><br><span class="line"></span><br><span class="line">        groupA.thenAcceptBoth(groupB, (a, b) -&gt; &#123;</span><br><span class="line">            System.out.println(</span><br><span class="line">                Sets.intersection(</span><br><span class="line">                Sets.newHashSet(a),</span><br><span class="line">                Sets.newHashSet(b)).size());</span><br><span class="line">            &#125;).join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>MakeObjects</strong> 类是一个生产者类，包含一个能够产生 List&lt;Integer&gt; 类型的列表对象的 <code>get()</code> 方法。通过从每个 <code>HasID</code> 对象提取 <code>ID</code> 并放入列表中来生成这个列表对象，而 <code>test()</code> 方法则创建了两个并行的 <strong>CompletableFuture</strong> 对象，用于运行 <strong>MakeObjects</strong> 生产者类，然后获取运行结果。</p><p>使用 Guava 库中的 **Sets.<code>intersection()</code> 方法，计算出这两个返回的 List&lt;Integer&gt; 对象中有多少相同的 <code>ID</code>（使用谷歌 Guava 库里的方法比使用官方的 <code>retainAll()</code> 方法速度快得多）。</p><p>现在我们可以测试上面的 <strong>StaticIDField</strong> 类了。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/TestStaticIDField.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStaticIDField</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IDChecker.test(StaticIDField::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">13287</span><br></pre></td></tr></table></figure><p>结果中出现了很多重复项。很显然，纯静态 <code>int</code> 用于构造过程并不是线程安全的。让我们使用 <strong>AtomicInteger</strong> 来使其变为线程安全的。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/GuardedIDField.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuardedIDField</span> <span class="keyword">implements</span> <span class="title">HasID</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger counter = <span class="keyword">new</span></span><br><span class="line">        AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id = counter.getAndIncrement();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getID</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> id; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;                IDChecker.test(GuardedIDField::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><p>构造器有一种更微妙的状态共享方式：通过构造器参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/SharedConstructorArgument.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.*;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SharedArg</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Unsafe</span> <span class="keyword">implements</span> <span class="title">SharedArg</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Safe</span> <span class="keyword">implements</span> <span class="title">SharedArg</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger counter = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> counter.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharedUser</span> <span class="keyword">implements</span> <span class="title">HasID</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    SharedUser(SharedArg sa)&#123;</span><br><span class="line">        id = sa.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getID</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SharedConstructorArgument</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Unsafe unsafe = <span class="keyword">new</span> Unsafe();</span><br><span class="line">        IDChecker.test(() -&gt; <span class="keyword">new</span> SharedUser(unsafe));</span><br><span class="line"></span><br><span class="line">        Safe safe = <span class="keyword">new</span> Safe();</span><br><span class="line">        IDChecker.test(() -&gt; <span class="keyword">new</span> SharedUser(safe));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">24838</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>在这里，<strong>SharedUser</strong> 构造器实际上共享了相同的参数。即使 <strong>SharedUser</strong> 以完全无害且合理的方式使用其自己的参数，其构造器的调用方式也会引起冲突。<strong>SharedUser</strong> 甚至不知道它是以这种方式调用的，更不必说控制它了。</p><p>同步构造器并不被java语言所支持，但是通过使用同步语块来创建你自己的同步构造器是可能的（请参阅附录：<a href="./Appendix-Low-Level-Concurrency.md">并发底层原理</a>，来进一步了解同步关键字—— <code>synchronized</code>）。尽管JLS（java语言规范）这样陈述道：“……它会锁定正在构造的对象”，但这并不是真的——构造器实际上只是一个静态方法，因此同步构造器实际上会锁定该类的Class对象。我们可以通过创建自己的静态对象并锁定它，来达到与同步构造器相同的效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/SynchronizedConstructor.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncConstructor</span> <span class="keyword">implements</span> <span class="title">HasID</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object constructorLock =</span><br><span class="line">        <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    SyncConstructor(SharedArg sa)&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (constructorLock)&#123;</span><br><span class="line">            id = sa.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getID</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedConstructor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Unsafe unsafe = <span class="keyword">new</span> Unsafe();</span><br><span class="line">        IDChecker.test(() -&gt; <span class="keyword">new</span> SyncConstructor(unsafe));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><p><strong>Unsafe</strong>类的共享使用现在就变得安全了。另一种方法是将构造器设为私有（因此可以防止继承），并提供一个静态Factory方法来生成新对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/SynchronizedFactory.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncFactory</span> <span class="keyword">implements</span> <span class="title">HasID</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SyncFactory</span><span class="params">(SharedArg sa)</span></span>&#123;</span><br><span class="line">        id = sa.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getID</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SyncFactory <span class="title">factory</span><span class="params">(SharedArg sa)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SyncFactory(sa);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Unsafe unsafe = <span class="keyword">new</span> Unsafe();</span><br><span class="line">        IDChecker.test(() -&gt; SyncFactory.factory(unsafe));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><p>通过同步静态工厂方法，可以在构造过程中锁定 <strong>Class</strong> 对象。</p><p>这些示例充分表明了在并发Java程序中检测和管理共享状态有多困难。即使你采取“不共享任何内容”的策略，也很容易产生意外的共享事件。</p><h2 id="复杂性和代价"><a href="#复杂性和代价" class="headerlink" title="复杂性和代价"></a>复杂性和代价</h2><p>假设你正在做披萨，我们把从整个流程的当前步骤到下一个步骤所需的工作量，在这里一一表示为枚举变量的一部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/Pizza.java import java.util.function.*;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> onjava.Nap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pizza</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Step&#123;</span><br><span class="line">        DOUGH(<span class="number">4</span>), ROLLED(<span class="number">1</span>), SAUCED(<span class="number">1</span>), CHEESED(<span class="number">2</span>),</span><br><span class="line">        TOPPED(<span class="number">5</span>), BAKED(<span class="number">2</span>), SLICED(<span class="number">1</span>), BOXED(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> effort;<span class="comment">// Needed to get to the next step </span></span><br><span class="line"></span><br><span class="line">        Step(<span class="keyword">int</span> effort)&#123;</span><br><span class="line">            <span class="keyword">this</span>.effort = effort;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Step <span class="title">forward</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (equals(BOXED)) <span class="keyword">return</span> BOXED;</span><br><span class="line">            <span class="keyword">new</span> Nap(effort * <span class="number">0.1</span>);</span><br><span class="line">            <span class="keyword">return</span> values()[ordinal() + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Step step = Step.DOUGH;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pizza</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">        step = step.forward();</span><br><span class="line">        System.out.println(<span class="string">"Pizza "</span> + id + <span class="string">": "</span> + step);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">next</span><span class="params">(Step previousStep)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!step.equals(previousStep))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Expected "</span> +</span><br><span class="line">                      previousStep + <span class="string">" but found "</span> + step);</span><br><span class="line">        <span class="keyword">return</span> next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">roll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next(Step.DOUGH);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">sauce</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next(Step.ROLLED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">cheese</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next(Step.SAUCED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">toppings</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next(Step.CHEESED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">bake</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next(Step.TOPPED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">slice</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next(Step.BAKED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">box</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next(Step.SLICED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">complete</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> step.equals(Step.BOXED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Pizza"</span> + id + <span class="string">": "</span> + (step.equals(Step.BOXED) ? <span class="string">"complete"</span> : step);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这只算得上是一个平凡的状态机，就像<strong>Machina</strong>类一样。 </p><p>制作一个披萨，当披萨饼最终被放在盒子中时，就算完成最终任务了。 如果一个人在做一个披萨饼，那么所有步骤都是线性进行的，即一个接一个地进行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/OnePizza.java </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> onjava.Timer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnePizza</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Pizza za = <span class="keyword">new</span> Pizza(<span class="number">0</span>);</span><br><span class="line">        System.out.println(Timer.duration(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (!za.complete()) za.next();</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Pizza 0: ROLLED </span><br><span class="line">Pizza 0: SAUCED </span><br><span class="line">Pizza 0: CHEESED </span><br><span class="line">Pizza 0: TOPPED </span><br><span class="line">Pizza 0: BAKED </span><br><span class="line">Pizza 0: SLICED </span><br><span class="line">Pizza 0: BOXED </span><br><span class="line">1622</span><br></pre></td></tr></table></figure><p>时间以毫秒为单位，加总所有步骤的工作量，会得出与我们的期望值相符的数字。 如果你以这种方式制作了五个披萨，那么你会认为它花费的时间是原来的五倍。 但是，如果这还不够快怎么办？ 我们可以从尝试并行流方法开始：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/PizzaStreams.java</span></span><br><span class="line"><span class="comment">// import java.util.*; import java.util.stream.*;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> onjava.Timer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStreams</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QUANTITY = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        IntStream.range(<span class="number">0</span>, QUANTITY)</span><br><span class="line">            .mapToObj(Pizza::<span class="keyword">new</span>)</span><br><span class="line">            .parallel()<span class="comment">//[1]</span></span><br><span class="line">        .forEach(za -&gt; &#123; <span class="keyword">while</span>(!za.complete()) za.next(); &#125;); System.out.println(timer.duration());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Pizza 2: ROLLED</span><br><span class="line">Pizza 0: ROLLED</span><br><span class="line">Pizza 1: ROLLED</span><br><span class="line">Pizza 4: ROLLED</span><br><span class="line">Pizza 3:ROLLED</span><br><span class="line">Pizza 2:SAUCED</span><br><span class="line">Pizza 1:SAUCED</span><br><span class="line">Pizza 0:SAUCED</span><br><span class="line">Pizza 4:SAUCED</span><br><span class="line">Pizza 3:SAUCED</span><br><span class="line">Pizza 2:CHEESED</span><br><span class="line">Pizza 1:CHEESED</span><br><span class="line">Pizza 0:CHEESED</span><br><span class="line">Pizza 4:CHEESED</span><br><span class="line">Pizza 3:CHEESED</span><br><span class="line">Pizza 2:TOPPED</span><br><span class="line">Pizza 1:TOPPED</span><br><span class="line">Pizza 0:TOPPED</span><br><span class="line">Pizza 4:TOPPED</span><br><span class="line">Pizza 3:TOPPED</span><br><span class="line">Pizza 2:BAKED</span><br><span class="line">Pizza 1:BAKED</span><br><span class="line">Pizza 0:BAKED</span><br><span class="line">Pizza 4:BAKED</span><br><span class="line">Pizza 3:BAKED</span><br><span class="line">Pizza 2:SLICED</span><br><span class="line">Pizza 1:SLICED</span><br><span class="line">Pizza 0:SLICED</span><br><span class="line">Pizza 4:SLICED</span><br><span class="line">Pizza 3:SLICED</span><br><span class="line">Pizza 2:BOXED</span><br><span class="line">Pizza 1:BOXED</span><br><span class="line">Pizza 0:BOXED</span><br><span class="line">Pizza 4:BOXED</span><br><span class="line">Pizza 3:BOXED</span><br><span class="line">1739</span><br></pre></td></tr></table></figure><p>现在，我们制作五个披萨的时间与制作单个披萨的时间就差不多了。 尝试删除标记为[1]的行后，你会发现它花费的时间是原来的五倍。 你还可以尝试将<strong>QUANTITY</strong>更改为4、8、10、16和17，看看会有什么不同，并猜猜看为什么会这样。</p><p><strong>PizzaStreams</strong> 类产生的每个并行流在它的<code>forEach()</code>内完成所有工作，如果我们将其各个步骤用映射的方式一步一步处理，情况会有所不同吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/PizzaParallelSteps.java </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">import</span> onjava.Timer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaParallelSteps</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QUANTITY = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        IntStream.range(<span class="number">0</span>, QUANTITY)</span><br><span class="line">            .mapToObj(Pizza::<span class="keyword">new</span>)</span><br><span class="line">            .parallel()</span><br><span class="line">            .map(Pizza::roll)</span><br><span class="line">            .map(Pizza::sauce)</span><br><span class="line">            .map(Pizza::cheese)</span><br><span class="line">            .map(Pizza::toppings)</span><br><span class="line">            .map(Pizza::bake)</span><br><span class="line">            .map(Pizza::slice)</span><br><span class="line">            .map(Pizza::box)</span><br><span class="line">            .forEach(za -&gt; System.out.println(za));</span><br><span class="line">        System.out.println(timer.duration());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Pizza 2: ROLLED </span><br><span class="line">Pizza 0: ROLLED </span><br><span class="line">Pizza 1: ROLLED </span><br><span class="line">Pizza 4: ROLLED </span><br><span class="line">Pizza 3: ROLLED </span><br><span class="line">Pizza 1: SAUCED </span><br><span class="line">Pizza 0: SAUCED </span><br><span class="line">Pizza 2: SAUCED </span><br><span class="line">Pizza 3: SAUCED </span><br><span class="line">Pizza 4: SAUCED </span><br><span class="line">Pizza 1: CHEESED </span><br><span class="line">Pizza 0: CHEESED </span><br><span class="line">Pizza 2: CHEESED </span><br><span class="line">Pizza 3: CHEESED </span><br><span class="line">Pizza 4: CHEESED </span><br><span class="line">Pizza 0: TOPPED </span><br><span class="line">Pizza 2: TOPPED</span><br><span class="line">Pizza 1: TOPPED </span><br><span class="line">Pizza 3: TOPPED </span><br><span class="line">Pizza 4: TOPPED </span><br><span class="line">Pizza 1: BAKED </span><br><span class="line">Pizza 2: BAKED </span><br><span class="line">Pizza 0: BAKED </span><br><span class="line">Pizza 4: BAKED </span><br><span class="line">Pizza 3: BAKED </span><br><span class="line">Pizza 0: SLICED </span><br><span class="line">Pizza 2: SLICED </span><br><span class="line">Pizza 1: SLICED </span><br><span class="line">Pizza 3: SLICED </span><br><span class="line">Pizza 4: SLICED </span><br><span class="line">Pizza 1: BOXED </span><br><span class="line">Pizza1: complete </span><br><span class="line">Pizza 2: BOXED </span><br><span class="line">Pizza 0: BOXED </span><br><span class="line">Pizza2: complete </span><br><span class="line">Pizza0: complete </span><br><span class="line">Pizza 3: BOXED</span><br><span class="line">Pizza 4: BOXED </span><br><span class="line">Pizza4: complete </span><br><span class="line">Pizza3: complete </span><br><span class="line">1738</span><br></pre></td></tr></table></figure><p>答案是“否”，事后看来这并不奇怪，因为每个披萨都需要按顺序执行步骤。因此，没法通过分步执行操作来进一步提高速度，就像上文的 <code>PizzaParallelSteps.java</code> 里面展示的一样。</p><p>我们可以使用 <strong>CompletableFutures</strong> 重写这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrent/CompletablePizza.java </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">import</span> onjava.Timer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletablePizza</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QUANTITY = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Pizza&gt; <span class="title">makeCF</span><span class="params">(Pizza za)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture</span><br><span class="line">                .completedFuture(za)</span><br><span class="line">            .thenApplyAsync(Pizza::roll)</span><br><span class="line">            .thenApplyAsync(Pizza::sauce)</span><br><span class="line">            .thenApplyAsync(Pizza::cheese)</span><br><span class="line">            .thenApplyAsync(Pizza::toppings)</span><br><span class="line">            .thenApplyAsync(Pizza::bake)</span><br><span class="line">            .thenApplyAsync(Pizza::slice)</span><br><span class="line">            .thenApplyAsync(Pizza::box);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(CompletableFuture&lt;Pizza&gt; cf)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(cf.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        List&lt;CompletableFuture&lt;Pizza&gt;&gt; pizzas =</span><br><span class="line">                IntStream.range(<span class="number">0</span>, QUANTITY)</span><br><span class="line">            .mapToObj(Pizza::<span class="keyword">new</span>)</span><br><span class="line">            .map(CompletablePizza::makeCF)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">        System.out.println(timer.duration());</span><br><span class="line">        pizzas.forEach(CompletablePizza::show);</span><br><span class="line">        System.out.println(timer.duration());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">169 </span><br><span class="line">Pizza 0: ROLLED </span><br><span class="line">Pizza 1: ROLLED </span><br><span class="line">Pizza 2: ROLLED </span><br><span class="line">Pizza 4: ROLLED </span><br><span class="line">Pizza 3: ROLLED </span><br><span class="line">Pizza 1: SAUCED </span><br><span class="line">Pizza 0: SAUCED </span><br><span class="line">Pizza 2: SAUCED </span><br><span class="line">Pizza 4: SAUCED</span><br><span class="line">Pizza 3: SAUCED </span><br><span class="line">Pizza 0: CHEESED </span><br><span class="line">Pizza 4: CHEESED </span><br><span class="line">Pizza 1: CHEESED </span><br><span class="line">Pizza 2: CHEESED </span><br><span class="line">Pizza 3: CHEESED </span><br><span class="line">Pizza 0: TOPPED </span><br><span class="line">Pizza 4: TOPPED </span><br><span class="line">Pizza 1: TOPPED </span><br><span class="line">Pizza 2: TOPPED </span><br><span class="line">Pizza 3: TOPPED </span><br><span class="line">Pizza 0: BAKED </span><br><span class="line">Pizza 4: BAKED </span><br><span class="line">Pizza 1: BAKED </span><br><span class="line">Pizza 3: BAKED </span><br><span class="line">Pizza 2: BAKED </span><br><span class="line">Pizza 0: SLICED </span><br><span class="line">Pizza 4: SLICED </span><br><span class="line">Pizza 1: SLICED </span><br><span class="line">Pizza 3: SLICED</span><br><span class="line">Pizza 2: SLICED </span><br><span class="line">Pizza 4: BOXED </span><br><span class="line">Pizza 0: BOXED </span><br><span class="line">Pizza0: complete </span><br><span class="line">Pizza 1: BOXED </span><br><span class="line">Pizza1: complete </span><br><span class="line">Pizza 3: BOXED </span><br><span class="line">Pizza 2: BOXED </span><br><span class="line">Pizza2: complete </span><br><span class="line">Pizza3: complete </span><br><span class="line">Pizza4: complete </span><br><span class="line">1797</span><br></pre></td></tr></table></figure><p>并行流和 <strong>CompletableFutures</strong> 是 Java 并发工具箱中最先进发达的技术。 你应该始终首先选择其中之一。 当一个问题很容易并行处理时，或者说，很容易把数据分解成相同的、易于处理的各个部分时，使用并行流方法处理最为合适（而如果你决定不借助它而由自己完成，你就必须撸起袖子，深入研究<strong>Spliterator</strong>的文档）。</p><p>而当工作的各个部分内容各不相同时，使用 <strong>CompletableFutures</strong> 是最好的选择。比起面向数据，<strong>CompletableFutures</strong> 更像是面向任务的。</p><p>对于披萨问题，结果似乎也没有什么不同。实际上，并行流方法看起来更简洁，仅出于这个原因，我认为并行流作为解决问题的首次尝试方法更具吸引力。</p><p>由于制作披萨总需要一定的时间，无论你使用哪种并发方法，你能做到的最好情况，是在制作一个披萨的相同时间内制作n个披萨。 在这里当然很容易看出来，但是当你处理更复杂的问题时，你就可能忘记这一点。 通常，在项目开始时进行粗略的计算，就能很快弄清楚最大可能的并行吞吐量，这可以防止你因为采取无用的加快运行速度的举措而忙得团团转。</p><p>使用 <strong>CompletableFutures</strong> 或许可以轻易地带来重大收益，但是在尝试更进一步时需要倍加小心，因为额外增加的成本和工作量会非常容易远远超出你之前拼命挤出的那一点点收益。</p><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>需要并发的唯一理由是“等待太多”。这也可以包括用户界面的响应速度，但是由于Java用于构建用户界面时并不高效，因此[^8]这仅仅意味着“你的程序运行速度还不够快”。</p><p>如果并发很容易，则没有理由拒绝并发。 正因为并发实际上很难，所以你应该仔细考虑是否值得为此付出努力，并考虑你能否以其他方式提升速度。</p><p>例如，迁移到更快的硬件（这可能比消耗程序员的时间要便宜得多）或者将程序分解成多个部分，然后在不同的机器上运行这些部分。</p><p>奥卡姆剃刀是一个经常被误解的原则。 我看过至少一部电影，他们将其定义为”最简单的解决方案是正确的解决方案“，就好像这是某种毋庸置疑的法律。实际上，这是一个准则：面对多种方法时，请先尝试需要最少假设的方法。 在编程世界中，这已演变为“尝试可能可行的最简单的方法”。当你了解了特定工具的知识时——就像你现在了解了有关并发性的知识一样，你可能会很想使用它，或者提前规定你的解决方案必须能够“速度飞快”，从而来证明从一开始就进行并发设计是合理的。但是，我们的奥卡姆剃刀编程版本表示你应该首先尝试最简单的方法（这种方法开发起来也更便宜），然后看看它是否足够好。</p><p>由于我出身于底层学术背景（物理学和计算机工程），所以我很容易想到所有小轮子转动的成本。我确定使用最简单的方法不够快的场景出现的次数已经数不过来了，但是尝试后却发现它实际上绰绰有余。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>并发编程的主要缺点是：</p><ol><li><p>在线程等待共享资源时会降低速度。 </p></li><li><p>线程管理产生额外CPU开销。</p></li><li><p>糟糕的设计决策带来无法弥补的复杂性。</p></li><li><p>诸如饥饿，竞速，死锁和活锁（多线程各自处理单个任务而整体却无法完成）之类的问题。</p></li><li><p>跨平台的不一致。 通过一些示例，我发现了某些计算机上很快出现的竞争状况，而在其他计算机上却没有。 如果你在后者上开发程序，则在分发程序时可能会感到非常惊讶。</p></li></ol><p>另外，并发的应用是一门艺术。 Java旨在允许你创建尽可能多的所需要的对象来解决问题——至少在理论上是这样。[^9]但是，线程不是典型的对象：每个线程都有其自己的执行环境，包括堆栈和其他必要的元素，使其比普通对象大得多。 在大多数环境中，只能在内存用光之前创建数千个<strong>Thread</strong>对象。通常，你只需要几个线程即可解决问题，因此一般来说创建线程没有什么限制，但是对于某些设计而言，它会成为一种约束，可能迫使你使用完全不同的方案。</p><h3 id="共享内存陷阱"><a href="#共享内存陷阱" class="headerlink" title="共享内存陷阱"></a>共享内存陷阱</h3><p>并发性的主要困难之一是因为可能有多个任务共享一个资源（例如对象中的内存），并且你必须确保多个任务不会同时读取和更改该资源。</p><p>我花了多年的时间研究并发并发。 我了解到你永远无法相信使用共享内存并发的程序可以正常工作。 你可以轻易发现它是错误的，但永远无法证明它是正确的。 这是众所周知的并发原则之一。[^10]</p><p>我遇到了许多人，他们对编写正确的线程程序的能力充满信心。 我偶尔开始认为我也可以做好。 对于一个特定的程序，我最初是在只有单个CPU的机器上编写的。 那时我能够说服自己该程序是正确的，因为我以为我对Java工具很了解。 而且在我的单CPU计算机上也没有失败。而到了具有多个CPU的计算机，程序出现问题不能运行后，我感到很惊讶，但这还只是众多问题中的一个而已。 这不是Java的错； “写一次，到处运行”，在单核与多核计算机间无法扩展到并发编程领域。这是并发编程的基本问题。 实际上你可以在单CPU机器上发现一些并发问题，但是在多线程实际上真的在并行运行的多CPU机器上，就会出现一些其他问题。</p><p>再举一个例子，哲学家就餐的问题可以很容易地进行调整，因此几乎不会产生死锁，这会给你一种一切都棒极了的印象。当涉及到共享内存并发编程时，你永远不应该对自己的编程能力变得过于自信。</p><h3 id="This-Albatross-is-Big"><a href="#This-Albatross-is-Big" class="headerlink" title="This Albatross is Big"></a>This Albatross is Big</h3><p>如果你对Java并发感到不知所措，那说明你身处在一家出色的公司里。你可以访问<strong>Thread</strong>类的<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html" target="_blank" rel="noopener">Javadoc</a>页面， 看一下哪些方法现在是<strong>Deprecated</strong>（废弃的）。这些是Java语言设计者犯过错的地方，因为他们在设计语言时对并发性了解不足。</p><p>事实证明，在Java的后续版本中添加的许多库解决方案都是无效的，甚至是无用的。 幸运的是，Java 8中的并行<strong>Streams</strong>和<strong>CompletableFutures</strong>都非常有价值。但是当你使用旧代码时，仍然会遇到旧的解决方案。</p><p>在本书的其他地方，我谈到了Java的一个基本问题：每个失败的实验都永远嵌入在语言或库中。 Java并发强调了这个问题。尽管有不少错误，但错误并不是那么多，因为有很多不同的尝试方法来解决问题。 好的方面是，这些尝试产生了更好，更简单的设计。 不利之处在于，在找到好的方法之前，你很容易迷失于旧的设计中。</p><h3 id="其他类库"><a href="#其他类库" class="headerlink" title="其他类库"></a>其他类库</h3><p>本章重点介绍了相对安全易用的并行工具流和<strong>CompletableFutures</strong>，并且仅涉及Java标准库中一些更细粒度的工具。 为避免你不知所措，我没有介绍你可能实际在实践中使用的某些库。我们使用了几个<strong>Atomic</strong>（原子）类，<strong>ConcurrentLinkedDeque</strong>，<strong>ExecutorService</strong>和<strong>ArrayBlockingQueue</strong>。附录：<a href="./Appendix-Low-Level-Concurrency.md">并发底层原理</a>涵盖了其他一些内容，但是你还想探索<strong>java.util.concurrent</strong>的Javadocs。 但是要小心，因为某些库组件已被新的更好的组件所取代。</p><h3 id="考虑为并发设计的语言"><a href="#考虑为并发设计的语言" class="headerlink" title="考虑为并发设计的语言"></a>考虑为并发设计的语言</h3><p>通常，请谨慎地使用并发。 如果需要使用它，请尝试使用最现代的方法：并行流或<strong>CompletableFutures</strong>。 这些功能旨在（假设你不尝试共享内存）使你摆脱麻烦（在Java的世界范围内）。</p><p>如果你的并发问题变得比高级Java构造所支持的问题更大且更复杂，请考虑使用专为并发设计的语言，仅在需要并发的程序部分中使用这种语言是有可能的。 在撰写本文时，JVM上最纯粹的功能语言是Clojure（Lisp的一种版本）和Frege（Haskell的一种实现）。这些使你可以在其中编写应用程序的并发部分语言，并通过JVM轻松地与你的主要Java代码进行交互。 或者，你可以选择更复杂的方法，即通过外部功能接口（FFI）将JVM之外的语言与另一种为并发设计的语言进行通信。[^11]</p><p>你很容易被一种语言绑定，迫使自己尝试使用该语言来做所有事情。 一个常见的示例是构建HTML / JavaScript用户界面。 这些工具确实很难使用，令人讨厌，并且有许多库允许你通过使用自己喜欢的语言编写代码来生成这些工具（例如，<strong>Scala.js</strong>允许你在Scala中完成代码）。</p><p>心理上的便利是一个合理的考虑因素。 但是，我希望我在本章（以及附录：<a href="./Appendix-Low-Level-Concurrency.md">并发底层原理</a>）中已经表明Java并发是一个你可能无法逃离很深的洞。 与Java语言的任何其他部分相比，在视觉上检查代码同时记住所有陷阱所需要的的知识要困难得多。</p><p>无论使用特定的语言、库使得并发看起来多么简单，都要将其视为一种妖术，因为总是有东西会在你最不期望出现的时候咬你。</p><h3 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><p>《Java Concurrency in Practice》，出自Brian Goetz，Tim Peierls， Joshua Bloch，Joseph Bowbeer，David Holmes和 Doug Lea (Addison Wesley，2006年)——这些基本上就是Java并发世界中的名人名单了《Java Concurrency in Practice》第二版，出自 Doug Lea (Addison-Wesley，2000年)。尽管这本书出版时间远远早于Java 5发布，但Doug的大部分工作都写入了<strong>java.util.concurrent</strong>库。因此，这本书对于全面理解并发问题至关重要。 它超越了Java，讨论了跨语言和技术的并发编程。 尽管它在某些地方可能很钝，但值得多次重读（最好是在两个月之间进行消化）。 道格（Doug）是世界上为数不多的真正了解并发编程的人之一，因此这是值得的。<a href="https://lingcoder.github.io/OnJava8/#/book/24-Concurrent-Programming" target="_blank" rel="noopener">^12</a></p><p>[^7]: 而不是超线程；通常每个内核有两个超线程，并且在询问内核数量时，本书所使用的Java版本会报告超线程的数量。超线程产生了更快的上下文切换，但是只有实际的内核才真的工作，而不是超线程。 ↩<br>[^8]: 库就在那里用于调用，而语言本身就被设计用于此目的，但实际上它很少发生，以至于可以说”没有“。↩<br>[^9]: 举例来说，如果没有Flyweight设计模式，在工程中创建数百万个对象用于有限元分析可能在Java中不可行。↩<br>[^10]: 在科学中，虽然从来没有一种理论被证实过，但是一种理论必须是可证伪的才有意义。而对于并发性，我们大部分时间甚至都无法得到这种可证伪性。↩<br>[^11]: 尽管<strong>Go</strong>语言显示了FFI的前景，但在撰写本文时，它并未提供跨所有平台的解决方案。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二十四章 并发编程&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Maven快照机制（SNAPSHOT）</title>
    <link href="http://yoursite.com/2020/06/05/Maven%E5%BF%AB%E7%85%A7%E6%9C%BA%E5%88%B6(SNAPSHOT)/"/>
    <id>http://yoursite.com/2020/06/05/Maven快照机制(SNAPSHOT)/</id>
    <published>2020-06-05T09:10:12.000Z</published>
    <updated>2020-06-10T08:25:12.176Z</updated>
    
    <content type="html"><![CDATA[<p>介绍Maven快照机制（SNAPSHOT）</p><a id="more"></a><h1 id="📖场景"><a href="#📖场景" class="headerlink" title="📖场景"></a>📖场景</h1><p>一个大型的软件应用通常包含多个模块，并且通常的场景是多个团队开发同一应用的不同模块。举个例子，设想一个团队开发应用的前端，项目为app-ui（app-ui.jar:1.0），而另一个团队开发应用的后台，使用的项目是data-service（data-service.jar:1.0）。</p><p>现在可能出现的情况是开发data-service的团队正在进行快节奏的bug修复或者项目改进，并且他们几乎每隔一天就要发布库到远程仓库。</p><p>现在如果data-service团队每隔一天上传一个新版本，那么将会出现下面的问题：</p><p>data-service团队每次发布更新的代码时都要告知app-ui团队。<br>app-ui团队需要经常地更新他们pom.xml文件到最新版本。<br>为了解决这种情况， 快照（SNAPSHOT）的概念派上了用场。</p><h1 id="📖什么是快照（SNAPSHOT）？"><a href="#📖什么是快照（SNAPSHOT）？" class="headerlink" title="📖什么是快照（SNAPSHOT）？"></a>📖什么是快照（SNAPSHOT）？</h1><p>快照（SNAPSHOT）是一种特殊的版本，指定了某个当前的开发进度的副本。不同于常规的版本，Maven每次构建都会在远程仓库中检查新的快照。</p><p>现在data-service团队会每次发布更新代码的快照到仓库中，比如说data-service:1.0-SNAPSHOT来替代旧的快照jar包。</p><p>注意：每次更新jar包时，版本号不变，且后缀必须带上-SNAPSHOT。</p><h1 id="📖项目快照（Snapshot）-VS-版本（Version）"><a href="#📖项目快照（Snapshot）-VS-版本（Version）" class="headerlink" title="📖项目快照（Snapshot） VS 版本（Version）"></a>📖项目快照（Snapshot） VS 版本（Version）</h1><p>版本（Version）的情况下，如果Maven以前下载过指定的版本文件，比如说data-service:1.0，Maven将不会再从仓库下载新的可用的1.0文件。若要下载更新的代码，data-service的版本需要升到1.1。</p><p>快照（Snapshot）的情况下，每次app-ui团队构建他们的项目时，Maven将自动获取最新的快照(data-service:1.0-SNAPSHOT)。</p><h2 id="备注："><a href="#备注：" class="headerlink" title="备注："></a>备注：</h2><p>版本（Version）存放在Release发布仓库。快照（Snapshot）存放在Snapshot快照仓库。</p><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>版本（Version）的概念，只要不带有-SNAPSHOT的关键字时，都会认为这是一个在Release发布仓库的jar包。其中在Release发布仓库的jar包命名除了具体的版本号之后还可以带上比如：1.0-Release、1.0-rc1等等的字样。</p><h1 id="📖原理详解"><a href="#📖原理详解" class="headerlink" title="📖原理详解"></a>📖原理详解</h1><p>Maven中的仓库分为两种，Snapshot快照仓库和Release发布仓库。Snapshot快照仓库用于保存开发过程中的不稳定版本，Release正式仓库则是用来保存稳定的发行版本。定义一个组件/模块为快照版本，只需要在pom.xml文件中在该模块的版本号后加上-SNAPSHOT即可（注意这里必须是大写），如下所示：</p><pre><code>&lt;groupId&gt;com.jsoft.test&lt;/groupId&gt;&lt;artifactId&gt;testcommon&lt;/artifactId&gt;&lt;version&gt;0.1-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;jar&lt;/packaging&gt;</code></pre><p>Maven会根据模块的版本号（pom.xml文件中的version）中是否带有-SNAPSHOT来判断是快照版本还是正式版本。</p><p>如果是快照版本，那么在mvn deploy时会自动发布到快照版本库中，而使用快照版本的模块，在不更改版本号的情况下，直接编译打包时，Maven会自动从镜像服务器上下载最新的快照版本。如果是正式发布版本，那么在mvn deploy时会自动发布到正式版本库中，而使用正式版本的模块，在不更改版本号的情况下，编译打包时如果本地已经存在该版本的模块则不会主动去镜像服务器上下载。</p><p>所以，我们在开发阶段，可以将公用库的版本设置为快照版本，而被依赖组件则引用快照版本进行开发，在公用库的快照版本更新后，我们也不需要修改pom.xml文件提示版本号来下载新的版本，直接Maven执行相关编译、打包命令即可重新下载最新的快照库了，从而也方便了我们进行开发。</p><p>虽然，快照的情况下，Maven在日常工作中会自动获取最新的快照，你也可以在任何Maven命令中使用-U参数强制Maven下载最新的快照构建。命令如下：</p><pre><code>mvn clean package -U</code></pre><h1 id="📖实际使用时遇到的问题1"><a href="#📖实际使用时遇到的问题1" class="headerlink" title="📖实际使用时遇到的问题1"></a>📖实际使用时遇到的问题1</h1><p>例如引用快照的项目app-ui中无法导入data-service中的DTO，报错：</p><pre><code>ERROR] -&gt; [Help 1][ERROR] [ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.[ERROR] Re-run Maven using the -X switch to enable full debug logging.[ERROR] [ERROR] For more information about the errors and possible solutions, please read the following articles:[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoFailureException</code></pre><p>搜索了相关信息找到的可能的错误原因：</p><ol><li><p>setting.xml 中的localRepository标签中的地址不正确</p></li><li><p>计算机当前用户对localRepository中地址所在的文件夹权限不够（我碰到的就是这个问题）</p></li></ol><p>解决方法如下：</p><ol><li><p>确认setting.xml文件中localRepository中的地址是否存在</p></li><li><p>修改仓库文件夹的权限为完全控制即可，打开IDEA-》Preference-》Maven，勾选Local repository</p></li></ol><h1 id="📖实际使用时遇到问题2"><a href="#📖实际使用时遇到问题2" class="headerlink" title="📖实际使用时遇到问题2"></a>📖实际使用时遇到问题2</h1><p>假设自己在external-services项目中使用了external-services-api项目中的快照，</p><p>那么在external-services-api项目中不要轻易将自己的开发分支合并到master上，因为有可能其他人在同时开发，刚才部署测试环境时将自己的分支合并到了master上，改api版本号为0.2.3，但在使用external-services的时候发现出错了，因为某分支的代码已经合并到external-services里，但是没有合并到external-services-api的master中，所以在external-services使用的api里没有某分支目的相关DTO，而且某分支要先上线，所以api的master中版本暂时不能带有我这个分支的代码。</p><h2 id="解决方法1"><a href="#解决方法1" class="headerlink" title="解决方法1"></a>解决方法1</h2><p>首先想在external-services-api的master中强行回滚代码 ，但是发现</p><p>回滚到 master 的某一个 commit 版本：</p><pre><code>git rest --hard xxxx</code></pre><p>这时候就将这个分支回滚到之前的某一个 commit 了。 但是这时候直接</p><pre><code>git push origin</code></pre><p>是不行的。 会显示远端的版本比当前版本高，所以只能用 -f 来强制 push 上去。</p><pre><code>git push -u origin master -f</code></pre><p>但是发现还是报错：</p><pre><code>You are not allowed to force push code to a protected branch on this project</code></pre><p>信息提示我无法强制 push 代码到一个受保护的分支？？ 哪怕我已经是 master 了，还是强推不了</p><p>去 gitlab 的该项目的配置项看了一下(在 Settings 的 Repository 设置项的 Protected Branches)， 原来这个项目中有对 master 分支做了 protected 保护， 不允许强制推送，这个好像是项目创建的时候就默认的设置：</p><p>所以如果要强制推送到 master 的话，这边要先取消掉 protected 分支。所以点击 Unprotect 按钮</p><p>这时候就没有保护分支了， 然后这时候强制推送就成功了。 然后为了安全，我们再重新设置为保护分支</p><p>理论上可以改保护分支设置解决，但是我在external-services-api项目的gitlab网页中怎么也找不到Settings这个选项，所以此方法失败了。</p><h2 id="解决方法2"><a href="#解决方法2" class="headerlink" title="解决方法2"></a>解决方法2</h2><p>切换到external-services-api的master中，打开Version Control-》log，选择相应的commit记录右键-》Revert Commit，即可退回提交记录，再push。</p><p>然后再将某分支的api项目分支合并到master中，并将某分支的api分支也合并到我的开发分支中，暂时不用在master上操作了，在我的开发分支上feature-preloanContract把版本号改为0.2.3-SNAPSHOT，deploy一下就可以在external-services中使用了。</p><h2 id="又遇到问题"><a href="#又遇到问题" class="headerlink" title="又遇到问题"></a>又遇到问题</h2><p>external-services中的develop中合并了开发分支后仍然显示有错，在其他人电脑上就没错，这是因为本地仍有原来api包的缓存，可以重新导入一下maven就恢复正常了。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://www.cnblogs.com/EasonJim/p/6852840.html" target="_blank" rel="noopener">https://www.cnblogs.com/EasonJim/p/6852840.html</a></p><p>【2】<a href="https://ayayui.gitbooks.io/tutorialspoint-maven/content/book/maven_snapshots.html" target="_blank" rel="noopener">https://ayayui.gitbooks.io/tutorialspoint-maven/content/book/maven_snapshots.html</a></p><p>【3】<a href="https://blog.csdn.net/w13342233769/article/details/103484005" target="_blank" rel="noopener">https://blog.csdn.net/w13342233769/article/details/103484005</a></p><p>【4】<a href="https://blog.csdn.net/Vicky128/article/details/81285610" target="_blank" rel="noopener">https://blog.csdn.net/Vicky128/article/details/81285610</a></p><p>【5】<a href="https://kebingzao.com/2019/04/18/git-protected/" target="_blank" rel="noopener">https://kebingzao.com/2019/04/18/git-protected/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍Maven快照机制（SNAPSHOT）&lt;/p&gt;
    
    </summary>
    
      <category term="2020年5月" scheme="http://yoursite.com/categories/2020%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Maven" scheme="http://yoursite.com/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>140. 单词拆分II</title>
    <link href="http://yoursite.com/2020/05/29/140.%20%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86II/"/>
    <id>http://yoursite.com/2020/05/29/140. 单词拆分II/</id>
    <published>2020-05-29T03:23:12.000Z</published>
    <updated>2020-06-06T15:44:25.057Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。</p><a id="more"></a><h1 id="📖题目描述："><a href="#📖题目描述：" class="headerlink" title="📖题目描述："></a>📖题目描述：</h1><p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。</p><p>说明：</p><p>分隔时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。</p><p>示例 1：</p><pre><code>输入:s = &quot;catsanddog&quot;wordDict = [&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;]输出:[  &quot;cats and dog&quot;,  &quot;cat sand dog&quot;]</code></pre><p>示例 2：</p><pre><code>输入:s = &quot;pineapplepenapple&quot;wordDict = [&quot;apple&quot;, &quot;pen&quot;, &quot;applepen&quot;, &quot;pine&quot;, &quot;pineapple&quot;]输出:[  &quot;pine apple pen apple&quot;,  &quot;pineapple pen apple&quot;,  &quot;pine applepen apple&quot;]解释: 注意你可以重复使用字典中的单词。</code></pre><p>示例 3：</p><pre><code>输入:s = &quot;catsandog&quot;wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]输出:[]</code></pre><h1 id="📖方法-1：暴力求解"><a href="#📖方法-1：暴力求解" class="headerlink" title="📖方法 1：暴力求解"></a>📖方法 1：暴力求解</h1><p><strong>算法</strong></p><p>解决此题最简单的方法是使用回溯。为了找到解，我们检查字符串（<em>s</em>）的所有可能前缀是否在字典中，如果在（比方说 <em>s1</em> ），那么调用回溯函数并检查剩余部分的字符串。<br>如果剩余部分可以形成有效拆分，这个函数返回前缀 <em>s1</em> ，并将回溯调用的剩余结果（即 <em>s-s1*）跟在 *s1</em> 的后面。否则，返回空列表。</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, Set&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> word_Break(s, wordDict, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">word_Break</span><span class="params">(String s, Set&lt;String&gt; wordDict, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (start == s.length()) &#123;</span><br><span class="line">            res.add(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> end = start + <span class="number">1</span>; end &lt;= s.length(); end++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (wordDict.contains(s.substring(start, end))) &#123;</span><br><span class="line">                List&lt;String&gt; list = word_Break(s, wordDict, end);</span><br><span class="line">                <span class="keyword">for</span> (String l : list) &#123;</span><br><span class="line">                    res.add(s.substring(start, end) + (l.equals(<span class="string">""</span>) ? <span class="string">""</span> : <span class="string">" "</span>) + l);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n^n)*，考虑最坏情况 *s</em> = “aaaaaaa “，<em>s</em> 的每一个前缀都在字典中，回溯树的大小会达到  <em>n^n</em> 。</p></li><li><p>空间复杂度：<em>O(n^3)*，最坏情况下，回溯的深度可以达到 *n</em> 层，每层可能包含 <em>n</em> 个字符串，且每个字符串的长度都为 <em>n</em> 。</p></li></ul><h1 id="📖方法-2：记忆化回溯"><a href="#📖方法-2：记忆化回溯" class="headerlink" title="📖方法 2：记忆化回溯"></a>📖方法 2：记忆化回溯</h1><p><strong>算法</strong></p><p>在之前的方法中，我们可以看出许多子问题的求解都是冗余的，也就是我们对于相同的子串调用了函数多次。</p><p>为了避免这种情况，我们使用记忆化的方法，我们使用一个 <em>key:value</em> 这样的哈希表来进行优化。在哈希表中， <em>key</em> 是当前考虑字符串的开始下标， <em>value</em> 包含了所有从头开始的所有可行句子。下次我们遇到相同位置开始的调用时，我们可以直接从哈希表里返回结果，而不需要重新计算结果。</p><p>通过记忆化的方法，许多冗余的子问题都可以被省去，回溯树得到了剪枝，所以极大程度降低了时间复杂度。</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, Set&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> word_Break(s, wordDict, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    HashMap&lt;Integer, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">word_Break</span><span class="params">(String s, Set&lt;String&gt; wordDict, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(start)) &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(start);</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;String&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (start == s.length()) &#123;</span><br><span class="line">            res.add(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> end = start + <span class="number">1</span>; end &lt;= s.length(); end++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (wordDict.contains(s.substring(start, end))) &#123;</span><br><span class="line">                List&lt;String&gt; list = word_Break(s, wordDict, end);</span><br><span class="line">                <span class="keyword">for</span> (String l : list) &#123;</span><br><span class="line">                    res.add(s.substring(start, end) + (l.equals(<span class="string">""</span>) ? <span class="string">""</span> : <span class="string">" "</span>) + l);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(start, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(n^3)</em> 。回溯树的大小最多 <em>n^2</em> 。创建列表需要 <em>n</em> 的时间。</li></ul><h1 id="📖方法-3：使用动态规划"><a href="#📖方法-3：使用动态规划" class="headerlink" title="📖方法 3：使用动态规划"></a>📖方法 3：使用动态规划</h1><p><strong>算法</strong></p><p>本题是<a href="https://leetcode-cn.com/problems/word-break/" target="_blank" rel="noopener">「力扣」第 139 题：单词拆分</a>的后序问题，本题解基于该问题的题解<a href="https://leetcode-cn.com/problems/word-break/solution/dong-tai-gui-hua-python-dai-ma-by-liweiwei1419-2/" target="_blank" rel="noopener">《动态规划（Python 代码、Java 代码）》</a>编写而成，需要先阅读该题解，才能理解本题解的内容。</p><p>我们就接着使用上一题的到的动态规划的状态数组来解答这个问题。</p><p>  <a href="https://pic.leetcode-cn.com/b9af083076b82e1aba5c68b586dd7f6ef10104b7e6d9f4c94d94eb7af16bc382-140-1.png" target="_blank" rel="noopener">140-1.png</a>  <a href="https://pic.leetcode-cn.com/9ac605be599eb7281d4ba34367fe9d2c7c10afc3a29ef21b9a80c888a13e4810-140-2.png" target="_blank" rel="noopener">140-2.png</a>  <a href="https://pic.leetcode-cn.com/7ea186fae0e865fe0b151ac245c117d24c20b949f86bbc9f1dcb4a59e0c12c5f-140-3.png" target="_blank" rel="noopener">140-3.png</a>  <a href="https://pic.leetcode-cn.com/82422fb7edf8c3316920534f76b06212758a955dfe9d43484d3273a6ef84acff-140-4.png" target="_blank" rel="noopener">140-4.png</a> </p><p><strong>参考代码 1</strong>：状态的定义为：以 <code>s[i]</code> 结尾的子字符串是否可以被空格拆分为一个或多个在字典中出现的单词。</p><p>其中的dfs写的十分精妙，非常经典，我初看代码很难理解，在IDEA中打了断点逐行运行才理解，对最早写出这种解法的人真是钦佩不已。<br>不过有些代码可以更简化一些，例如初始化Set<string> 可以直接赋值。</string></p><pre><code>Set&lt;String&gt; wordSet=new HashSet&lt;&gt;(wordDict);</code></pre><p>拼接句子时不一定非要用StringBuilder，直接用 StringUtils.join()函数即可。</p><pre><code>StringUtils.join(stringlist, &quot; &quot;);</code></pre><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span><span class="params">(self, s: str, wordDict: List[str])</span> -&gt; List[str]:</span></span><br><span class="line">        size = len(s)</span><br><span class="line">        <span class="comment"># 题目中说非空字符串，以下 assert 一定通过</span></span><br><span class="line">        <span class="keyword">assert</span> size &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 预处理，把 wordDict 放进一个哈希表中</span></span><br><span class="line">        word_set = &#123;word <span class="keyword">for</span> word <span class="keyword">in</span> wordDict&#125;</span><br><span class="line">        <span class="comment"># print(word_set)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 状态：以 s[i] 结尾</span></span><br><span class="line">        <span class="comment"># 这种状态定义很常见</span></span><br><span class="line">        dp = [<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(size)]</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = s[<span class="number">0</span>] <span class="keyword">in</span> word_set</span><br><span class="line"></span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用 r 表示右边界，可以取到</span></span><br><span class="line">        <span class="comment"># 使用 l 表示左边界，也可以取到</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(<span class="number">1</span>, size):</span><br><span class="line">            <span class="comment"># Python 的语法，在切片的时候不包括右边界</span></span><br><span class="line">            <span class="comment"># 如果整个单词就直接在 word_set 中，直接返回就好了</span></span><br><span class="line">            <span class="comment"># 否则把单词做分割，挨个去判断</span></span><br><span class="line">            <span class="keyword">if</span> s[:r + <span class="number">1</span>] <span class="keyword">in</span> word_set:</span><br><span class="line">                dp[r] = <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> l <span class="keyword">in</span> range(r):</span><br><span class="line">                <span class="comment"># dp[l] 写在前面会更快一点，否则还要去切片，然后再放入 hash 表判重</span></span><br><span class="line">                <span class="keyword">if</span> dp[l] <span class="keyword">and</span> s[l + <span class="number">1</span>: r + <span class="number">1</span>] <span class="keyword">in</span> word_set:</span><br><span class="line">                    dp[r] = <span class="keyword">True</span></span><br><span class="line">                    <span class="comment"># 这个 break 很重要，一旦得到 dp[r] = True ，循环不必再继续</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 如果有解，才有必要回溯</span></span><br><span class="line">        <span class="keyword">if</span> dp[<span class="number">-1</span>]:</span><br><span class="line">            queue = deque()</span><br><span class="line"></span><br><span class="line">            self.__dfs(s, size - <span class="number">1</span>, wordDict, res, queue, dp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__dfs</span><span class="params">(self, s, end, word_set, res, path, dp)</span>:</span></span><br><span class="line">        <span class="comment"># print('刚开始', s[:end + 1])</span></span><br><span class="line">        <span class="comment"># 如果不用拆分，整个单词就在 word_set 中就可以结算了</span></span><br><span class="line">        <span class="keyword">if</span> s[:end + <span class="number">1</span>] <span class="keyword">in</span> word_set:</span><br><span class="line">            path.appendleft(s[:end + <span class="number">1</span>])</span><br><span class="line">            res.append(<span class="string">' '</span>.join(path))</span><br><span class="line">            path.popleft()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(end):</span><br><span class="line">            <span class="keyword">if</span> dp[i]:</span><br><span class="line">                suffix = s[i + <span class="number">1</span>:end + <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> suffix <span class="keyword">in</span> word_set:</span><br><span class="line">                    path.appendleft(suffix)</span><br><span class="line">                    self.__dfs(s, i, word_set, res, path, dp)</span><br><span class="line">                    path.popleft()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># s = "leetcode"</span></span><br><span class="line">    <span class="comment"># wordDict = ["leet", "code"]</span></span><br><span class="line">    s = <span class="string">"pineapplepenapple"</span></span><br><span class="line">    wordDict = [<span class="string">"apple"</span>, <span class="string">"pen"</span>, <span class="string">"applepen"</span>, <span class="string">"pine"</span>, <span class="string">"pineapple"</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># s = "a"</span></span><br><span class="line">    <span class="comment"># wordDict = ["a"]</span></span><br><span class="line">    solution = Solution()</span><br><span class="line">    result = solution.wordBreak(s, wordDict)</span><br><span class="line">    print(result)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ["pine apple pen apple","pineapple pen apple","pine applepen apple"]</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="comment">// 状态定义：以 s[i] 结尾的子字符串是否符合题意</span></span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 预处理</span></span><br><span class="line">        Set&lt;String&gt; wordSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String word : wordDict) &#123;</span><br><span class="line">            wordSet.add(word);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态规划问题一般都有起点，起点也相对好判断一些</span></span><br><span class="line">        <span class="comment">// dp[0] = wordSet.contains(s.charAt(0));</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; len; r++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (wordSet.contains(s.substring(<span class="number">0</span>, r + <span class="number">1</span>))) &#123;</span><br><span class="line">                dp[r] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; r; l++) &#123;</span><br><span class="line">                <span class="comment">// dp[l] 写在前面会更快一点，否则还要去切片，然后再放入 hash 表判重</span></span><br><span class="line">                <span class="keyword">if</span> (dp[l] &amp;&amp; wordSet.contains(s.substring(l + <span class="number">1</span>, r + <span class="number">1</span>)) ) &#123;</span><br><span class="line">                    dp[r] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">// 这个 break 很重要，一旦得到 dp[r] = True ，循环不必再继续</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (dp[len - <span class="number">1</span>]) &#123;</span><br><span class="line">            LinkedList&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            dfs(s, len - <span class="number">1</span>, wordSet, res, queue, dp);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String s, <span class="keyword">int</span> end, Set&lt;String&gt; wordSet, List&lt;String&gt; res, LinkedList&lt;String&gt; queue, <span class="keyword">boolean</span>[] dp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (wordSet.contains(s.substring(<span class="number">0</span>, end + <span class="number">1</span>))) &#123;</span><br><span class="line">            queue.addFirst(s.substring(<span class="number">0</span>, end + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">            StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (String word : queue) &#123;</span><br><span class="line">                stringBuilder.append(word);</span><br><span class="line">                stringBuilder.append(<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            stringBuilder.deleteCharAt(stringBuilder.length() - <span class="number">1</span>);</span><br><span class="line">            res.add(stringBuilder.toString());</span><br><span class="line"></span><br><span class="line">            queue.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; end; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dp[i]) &#123;</span><br><span class="line">                String suffix = s.substring(i + <span class="number">1</span>, end + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (wordSet.contains(suffix)) &#123;</span><br><span class="line">                    queue.addFirst(suffix);</span><br><span class="line">                    dfs(s, i, wordSet, res, queue, dp);</span><br><span class="line">                    queue.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"pineapplepenapple"</span>;</span><br><span class="line">        List&lt;String&gt; wordDict = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        wordDict.add(<span class="string">"apple"</span>);</span><br><span class="line">        wordDict.add(<span class="string">"pen"</span>);</span><br><span class="line">        wordDict.add(<span class="string">"applepen"</span>);</span><br><span class="line">        wordDict.add(<span class="string">"pine"</span>);</span><br><span class="line">        wordDict.add(<span class="string">"pineapple"</span>);</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        List&lt;String&gt; res = solution.wordBreak(s, wordDict);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参考代码 2</strong>：状态：dp[i] 表示子串 s[0:i] （即长度为 i 的子串，其实就是前缀）可以被空格拆分，并且拆分以后的单词是否落在 wordDict 中。</p><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span><span class="params">(self, s: str, wordDict: List[str])</span> -&gt; List[str]:</span></span><br><span class="line">        size = len(s)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 题目中说非空字符串，以下 assert 一定通过</span></span><br><span class="line">        <span class="keyword">assert</span> size &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 预处理，把 wordDict 放进一个哈希表中</span></span><br><span class="line">        word_set = &#123;word <span class="keyword">for</span> word <span class="keyword">in</span> wordDict&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># dp[i] 表示长度为 i 的 s，满足题意</span></span><br><span class="line">        <span class="comment"># 0 表示 False ，1 表示 True</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(size + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, size + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># i 表示 s 子串的长度</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="comment"># j 表示后子串的起始位置，最多到 i-1</span></span><br><span class="line">                <span class="comment"># j 也正正好表示前子串的长度</span></span><br><span class="line">                <span class="comment"># dp[j] 写在前面会更快一点，否则还要去切片，然后再放入 hash 表判重</span></span><br><span class="line">                <span class="keyword">if</span> dp[j] <span class="keyword">and</span> s[j:i] <span class="keyword">in</span> word_set:</span><br><span class="line">                    dp[i] = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 如果有解，才有必要回溯</span></span><br><span class="line">        <span class="keyword">if</span> dp[<span class="number">-1</span>]:</span><br><span class="line">            queue = deque()</span><br><span class="line">            self.__dfs(s, size, word_set, res, queue, dp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__dfs</span><span class="params">(self, s, length, word_set, res, path, dp)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> length == <span class="number">0</span>:</span><br><span class="line">            res.append(<span class="string">' '</span>.join(path))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">            <span class="keyword">if</span> dp[i]:</span><br><span class="line">                suffix = s[i:length]</span><br><span class="line">                <span class="keyword">if</span> suffix <span class="keyword">in</span> word_set:</span><br><span class="line">                    path.appendleft(suffix)</span><br><span class="line">                    self.__dfs(s, i, word_set, res, path, dp)</span><br><span class="line">                    path.popleft()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = <span class="string">"pineapplepenapple"</span></span><br><span class="line">    wordDict = [<span class="string">"apple"</span>, <span class="string">"pen"</span>, <span class="string">"applepen"</span>, <span class="string">"pine"</span>, <span class="string">"pineapple"</span>]</span><br><span class="line">    solution = Solution()</span><br><span class="line">    result = solution.wordBreak(s, wordDict)</span><br><span class="line">    print(result)</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="comment">// 状态定义：长度为 i 的子字符串是否符合题意</span></span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 预处理</span></span><br><span class="line">        Set&lt;String&gt; wordSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String word : wordDict) &#123;</span><br><span class="line">            wordSet.add(word);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个状态的设置非常关键，说明前部分的字符串已经在 wordSet 中</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">1</span>; r &lt; len + <span class="number">1</span>; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; r; l++) &#123;</span><br><span class="line">                <span class="comment">// dp[l] 写在前面会更快一点，否则还要去切片，然后再放入 hash 表判重</span></span><br><span class="line">                <span class="keyword">if</span> (dp[l] &amp;&amp; wordSet.contains(s.substring(l, r))  ) &#123;</span><br><span class="line">                    dp[r] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">// 这个 break 很重要，一旦得到 dp[r] = True ，循环不必再继续</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (dp[len]) &#123;</span><br><span class="line">            LinkedList&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            dfs(s, len, wordSet, res, queue, dp);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String s, <span class="keyword">int</span> end, Set&lt;String&gt; wordSet, List&lt;String&gt; res, LinkedList&lt;String&gt; queue, <span class="keyword">boolean</span>[] dp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end == <span class="number">0</span>) &#123;</span><br><span class="line">            StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (String word : queue) &#123;</span><br><span class="line">                stringBuilder.append(word);</span><br><span class="line">                stringBuilder.append(<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            stringBuilder.deleteCharAt(stringBuilder.length() - <span class="number">1</span>);</span><br><span class="line">            res.add(stringBuilder.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i]) &#123;</span><br><span class="line">                String suffix = s.substring(i, end);</span><br><span class="line">                <span class="keyword">if</span> (wordSet.contains(suffix)) &#123;</span><br><span class="line">                    queue.addFirst(suffix);</span><br><span class="line">                    dfs(s, i, wordSet, res, queue, dp);</span><br><span class="line">                    queue.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"pineapplepenapple"</span>;</span><br><span class="line">        List&lt;String&gt; wordDict = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        wordDict.add(<span class="string">"apple"</span>);</span><br><span class="line">        wordDict.add(<span class="string">"pen"</span>);</span><br><span class="line">        wordDict.add(<span class="string">"applepen"</span>);</span><br><span class="line">        wordDict.add(<span class="string">"pine"</span>);</span><br><span class="line">        wordDict.add(<span class="string">"pineapple"</span>);</span><br><span class="line">        Solution2 solution2 = <span class="keyword">new</span> Solution2();</span><br><span class="line">        List&lt;String&gt; res = solution2.wordBreak(s, wordDict);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://leetcode-cn.com/problems/word-break-ii/solution/dong-tai-gui-hua-hui-su-qiu-jie-ju-ti-zhi-python-d/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/word-break-ii/solution/dong-tai-gui-hua-hui-su-qiu-jie-ju-ti-zhi-python-d/</a></p><p>【2】<a href="https://leetcode-cn.com/problems/word-break/solution/dong-tai-gui-hua-python-dai-ma-by-liweiwei1419-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/word-break/solution/dong-tai-gui-hua-python-dai-ma-by-liweiwei1419-2/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年5月" scheme="http://yoursite.com/categories/2020%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>139. 单词拆分</title>
    <link href="http://yoursite.com/2020/05/28/139.%20%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/"/>
    <id>http://yoursite.com/2020/05/28/139. 单词拆分/</id>
    <published>2020-05-28T15:39:12.000Z</published>
    <updated>2020-05-28T15:59:54.966Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词</p><a id="more"></a><h1 id="📖题目描述："><a href="#📖题目描述：" class="headerlink" title="📖题目描述："></a>📖题目描述：</h1><p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p><p>说明：</p><p>拆分时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。<br>示例 1：</p><pre><code>输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]输出: true解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</code></pre><p>示例 2：</p><pre><code>输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]输出: true解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。     注意你可以重复使用字典中的单词。</code></pre><p>示例 3：</p><pre><code>输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]输出: false</code></pre><h1 id="📖方法一：暴力求解"><a href="#📖方法一：暴力求解" class="headerlink" title="📖方法一：暴力求解"></a>📖方法一：暴力求解</h1><p><strong>算法</strong></p><p>最简单的实现方法是用递归和回溯。为了找到解，我们可以检查字典单词中每一个单词的可能前缀，如果在字典中出现过，那么去掉这个前缀后剩余部分回归调用。同时，如果某次函数调用中发现整个字符串都已经被拆分且在字典中出现过了，函数就返回 <code>true</code> 。</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> word_Break(s, <span class="keyword">new</span> HashSet(wordDict), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">word_Break</span><span class="params">(String s, Set&lt;String&gt; wordDict, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == s.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> end = start + <span class="number">1</span>; end &lt;= s.length(); end++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (wordDict.contains(s.substring(start, end)) &amp;&amp; word_Break(s, wordDict, end)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(n^n)</em> 。考虑最坏情况 <em>s</em> = aaaaaaa 。每一个前缀都在字典中，此时回溯树的复杂度会达到 <em>n^n</em> 。</li><li>空间复杂度：<em>O(n)</em> 。回溯树的深度最深达到 <em>n</em> 。</li></ul><h1 id="📖方法二：记忆化回溯"><a href="#📖方法二：记忆化回溯" class="headerlink" title="📖方法二：记忆化回溯"></a>📖方法二：记忆化回溯</h1><p><strong>算法</strong></p><p>在先前的方法中，我们看到许多函数调用都是冗余的，也就是我们会对相同的字符串调用多次回溯函数。为了避免这种情况，我们可以使用记忆化的方法，其中一个 <em>memo</em> 数组会被用来保存子问题的结果。每当访问到已经访问过的后缀串，直接用 <em>memo</em> 数组中的值返回而不需要继续调用函数。</p><p>通过记忆化，许多冗余的子问题可以极大被优化，回溯树得到了剪枝，因此极大减小了时间复杂度。</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> word_Break(s, <span class="keyword">new</span> HashSet(wordDict), <span class="number">0</span>, <span class="keyword">new</span> Boolean[s.length()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">word_Break</span><span class="params">(String s, Set&lt;String&gt; wordDict, <span class="keyword">int</span> start, Boolean[] memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == s.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo[start] != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[start];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> end = start + <span class="number">1</span>; end &lt;= s.length(); end++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (wordDict.contains(s.substring(start, end)) &amp;&amp; word_Break(s, wordDict, end, memo)) &#123;</span><br><span class="line">                <span class="keyword">return</span> memo[start] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[start] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n^2)</em> 。回溯树的大小最多达到 <em>n^2</em> 。</p></li><li><p>空间复杂度：<em>O(n)</em> 。回溯树的深度可以达到 <em>n</em> 级别。</p></li></ul><h1 id="📖方法-3：使用宽度优先搜索"><a href="#📖方法-3：使用宽度优先搜索" class="headerlink" title="📖方法 3：使用宽度优先搜索"></a>📖方法 3：使用宽度优先搜索</h1><p><strong>算法</strong></p><p>另一个方法是使用宽度优先搜索。将字符串可视化成一棵树，每一个节点是用 <em>end</em> 为结尾的前缀字符串。当两个节点之间的所有节点都对应了字典中一个有效字符串时，两个节点可以被连接。</p><p>为了形成这样的一棵树，我们从给定字符串的第一个字符开始（比方说 <em>s</em> ），将它作为树的根部，开始找所有可行的以该字符为首字符的可行子串。进一步的，将每一个子字符串的结束字符的下标（比方说 <em>i</em>）放在队列的尾部供宽搜后续使用。</p><p>每次我们从队列最前面弹出一个元素，并考虑字符串 <em>s(i+1,end)</em> 作为原始字符串，并将当前节点作为树的根。这个过程会一直重复，直到队列中没有元素。如果字符串最后的元素可以作为树的一个节点，这意味着初始字符串可以被拆分成多个给定字典中的子字符串。</p><p>树的生成过程可以参考这个例子：</p><p>  <a href="https://pic.leetcode-cn.com/b874378afb2d9bc171a396e778cfeb25a6ee1368a374124de3d9990b820e80e6-image.png" target="_blank" rel="noopener">1</a>  <a href="https://pic.leetcode-cn.com/3bcb1c59ef2489c034310c76c86b2cfd707beed96f629d8be51e2ae96287d2c5-image.png" target="_blank" rel="noopener">2</a>  <a href="https://pic.leetcode-cn.com/cb9b4a35d26b71346da25f9f6cab1926dfb7cb9d3cb8171a750f8d012f081fff-image.png" target="_blank" rel="noopener">3</a>  <a href="https://pic.leetcode-cn.com/bd128522a7fc7b3426c1411cbc4c729018b53f814f74eb97fc25003bfe282eb4-image.png" target="_blank" rel="noopener">4</a>  <a href="https://pic.leetcode-cn.com/89989e53118ece2da9f0fd79c56b1beff07a6bdabd8ee9c1b0492f93d8eec000-image.png" target="_blank" rel="noopener">5</a>  <a href="https://pic.leetcode-cn.com/7e338635849ebb3ee872bcf8ddc14a56ece8bc2d4486cef984980fa8d53b7571-image.png" target="_blank" rel="noopener">6</a>  <a href="https://pic.leetcode-cn.com/13748edb1a2cab3f7636a0af409de256aa1048ff976dff44627c118b9f9b5fbb-image.png" target="_blank" rel="noopener">7</a> </p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; wordDictSet=<span class="keyword">new</span> HashSet(wordDict);</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line">        queue.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> start = queue.remove();</span><br><span class="line">            <span class="keyword">if</span> (visited[start] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> end = start + <span class="number">1</span>; end &lt;= s.length(); end++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (wordDictSet.contains(s.substring(start, end))) &#123;</span><br><span class="line">                        queue.add(end);</span><br><span class="line">                        <span class="keyword">if</span> (end == s.length()) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                visited[start] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n^2)</em> 。对于每个开始的位置，搜索会直到给定字符串的尾部结束。</p></li><li><p>空间复杂度：<em>O(n)</em> 。队列的大小最多 <em>n</em> 。</p></li></ul><h1 id="📖方法-4：使用动态规划"><a href="#📖方法-4：使用动态规划" class="headerlink" title="📖方法 4：使用动态规划"></a>📖方法 4：使用动态规划</h1><p><strong>算法</strong></p><p>这个方法的想法是对于给定的字符串（<em>s</em>）可以被拆分成子问题 <em>s1</em> 和 <em>s2</em> 。如果这些子问题都可以独立地被拆分成符合要求的子问题，那么整个问题 <em>s</em> 也可以满足。也就是，如果 “catsanddog” 可以拆分成两个子字符串 “catsand” 和 “dog” 。子问题 “catsand” 可以进一步拆分成 “cats” 和 “and” ，这两个独立的部分都是字典的一部分，所以 “catsand” 满足题意条件，再往前， “catsand” 和 “dog” 也分别满足条件，所以整个字符串 “catsanddog” 也满足条件。</p><p>现在，我们考虑 dp 数组求解的过程。我们使用 <em>n+1</em> 大小数组的dp ，其中 <em>n</em> 是给定字符串的长度。我们也使用 2 个下标指针 <em>i</em> 和 <em>j</em> ，其中 <em>i</em> 是当前字符串从头开始的子字符串（<em>s’*）的长度， *j</em> 是当前子字符串（<em>s’*）的拆分位置，拆分成 *s’(0,j)</em> 和 <em>s’(j+1,i)</em> 。</p><p>为了求出 dp 数组，我们初始化dp[0] 为 true  ，这是因为空字符串总是字典的一部分。 dp数组剩余的元素都初始化为false。</p><p>我们用下标 <em>i</em> 来考虑所有从当前字符串开始的可能的子字符串。对于每一个子字符串，我们通过下标 <em>j</em> 将它拆分成 <em>s1’</em> 和 <em>s2’</em> （注意 <em>i</em> 现在指向 <em>s2’</em> 的结尾）。为了将dp[i]数组求出来，我们依次检查每个dp[j]是否为 true ，也就是子字符串 <em>s1’</em> 是否满足题目要求。如果满足，我们接下来检查 <em>s2’</em> 是否在字典中。如果包含，我们接下来检查 <em>s2’</em> 是否在字典中，如果两个字符串都满足要求，我们让 true 为true，否则令其为false。</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; wordDictSet=<span class="keyword">new</span> HashSet(wordDict);</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &amp;&amp; wordDictSet.contains(s.substring(j, i))) &#123;</span><br><span class="line">                    dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n^2)</em> 。求出 dp 数组需要两重循环。</p></li><li><p>空间复杂度：<em>O(n)</em> 。 <em>dp</em> 数组的长度是 <em>n+1</em> 。</p></li></ul><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://leetcode-cn.com/problems/word-break/solution/dan-ci-chai-fen-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/word-break/solution/dan-ci-chai-fen-by-leetcode/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词&lt;/p&gt;
    
    </summary>
    
      <category term="2020年5月" scheme="http://yoursite.com/categories/2020%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>5. 最长回文子串</title>
    <link href="http://yoursite.com/2020/05/28/5.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/2020/05/28/5. 最长回文子串/</id>
    <published>2020-05-28T11:50:12.000Z</published>
    <updated>2020-05-28T15:18:56.865Z</updated>
    
    <content type="html"><![CDATA[<p>找到字符串中最长的回文子串，提供了「动态规划』问题的思考路径</p><a id="more"></a><h1 id="📖题目描述："><a href="#📖题目描述：" class="headerlink" title="📖题目描述："></a>📖题目描述：</h1><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><p>示例 1：</p><pre><code>输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。</code></pre><p>示例 2：</p><pre><code>输入: &quot;cbbd&quot;输出: &quot;bb&quot;</code></pre><p>这道题上次做还是2017年8月1日，今天重刷感觉还是没吃透，下面的方法和思路借鉴自牛人的题解，写的非常漂亮，比官方题解还好，这是他的博客推荐多学习一个：<a href="https://liweiwei1419.gitee.io/leetcode-algo/#indexCard" target="_blank" rel="noopener">https://liweiwei1419.gitee.io/leetcode-algo/#indexCard</a></p><h1 id="📖解题思路"><a href="#📖解题思路" class="headerlink" title="📖解题思路"></a>📖解题思路</h1><ul><li>以下解法中「暴力算法」是基础，「动态规划」必须掌握，「中心扩散」方法要会写；</li><li>「Manacher 算法」仅用于扩宽视野，绝大多数的算法面试中，面试官都不会要求写这个方法（除非面试者是竞赛选手）。</li></ul><h1 id="📖方法一：暴力匹配-（Brute-Force）"><a href="#📖方法一：暴力匹配-（Brute-Force）" class="headerlink" title="📖方法一：暴力匹配 （Brute Force）"></a>📖方法一：暴力匹配 （Brute Force）</h1><ul><li>根据回文子串的定义，枚举所有长度大于等于 <em>2</em> 的子串，依次判断它们是否是回文；</li><li>在具体实现时，可以只针对大于“当前得到的最长回文子串长度”的子串进行“回文验证”；</li><li>在记录最长回文子串的时候，可以只记录“当前子串的起始位置”和“子串长度”，不必做截取。这一步我们放在后面的方法中实现。</li></ul><p>说明：暴力解法时间复杂度高，但是思路清晰、编写简单。由于编写正确性的可能性很大，<strong>可以使用暴力匹配算法检验我们编写的其它算法是否正确</strong>。优化的解法在很多时候，是基于“暴力解法”，以空间换时间得到的，因此思考清楚暴力解法，分析其缺点，很多时候能为我们打开思路。</p><p><strong>参考代码 1</strong>：Java 代码正常运行，C++ 代码超出内存限制，Python 代码超时。</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// s.charAt(i) 每次都会检查数组下标越界，因此先转换成字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] charArray = s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举所有长度大于 1 的子串 charArray[i..j]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - i + <span class="number">1</span> &gt; maxLen &amp;&amp; validPalindromic(charArray, i, j)) &#123;</span><br><span class="line">                    maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                    begin = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(begin, begin + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证子串 s[left..right] 是否为回文串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validPalindromic</span><span class="params">(<span class="keyword">char</span>[] charArray, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (charArray[left] != charArray[right]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 暴力匹配（超时）</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="comment"># 特判</span></span><br><span class="line">        size = len(s)</span><br><span class="line">        <span class="keyword">if</span> size &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">        max_len = <span class="number">1</span></span><br><span class="line">        res = s[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 枚举所有长度大于等于 2 的子串</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(size - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, size):</span><br><span class="line">                <span class="keyword">if</span> j - i + <span class="number">1</span> &gt; max_len <span class="keyword">and</span> self.__valid(s, i, j):</span><br><span class="line">                    max_len = j - i + <span class="number">1</span></span><br><span class="line">                    res = s[i:j + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__valid</span><span class="params">(self, s, left, right)</span>:</span></span><br><span class="line">        <span class="comment"># 验证子串 s[left, right] 是否为回文串</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">if</span> s[left] != s[right]:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 超时测试用例</span></span><br><span class="line"><span class="comment"># "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 验证子串 s[left, right] 是否为回文串</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[left] != s[right]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特判</span></span><br><span class="line">        <span class="keyword">int</span> size = s.size();</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">string</span> res = s.substr(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举所有长度大于等于 2 的子串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; size; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - i + <span class="number">1</span> &gt; maxLen &amp;&amp; valid(s, i, j)) &#123;</span><br><span class="line">                    maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                    res = s.substr(i, maxLen);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 超出内存限制，测试用例</span></span><br><span class="line"><span class="comment">// "zudfweormatjycujjirzjpyrmaxurectxrtqedmmgergwdvjmjtstdhcihacqnothgttgqfywcpgnuvwglvfiuxteopoyizgehkwuvvkqxbnufkcbodlhdmbqyghkojrgokpwdhtdrwmvdegwycecrgjvuexlguayzcammupgeskrvpthrmwqaqsdcgycdupykppiyhwzwcplivjnnvwhqkkxildtyjltklcokcrgqnnwzzeuqioyahqpuskkpbxhvzvqyhlegmoviogzwuiqahiouhnecjwysmtarjjdjqdrkljawzasriouuiqkcwwqsxifbndjmyprdozhwaoibpqrthpcjphgsfbeqrqqoqiqqdicvybzxhklehzzapbvcyleljawowluqgxxwlrymzojshlwkmzwpixgfjljkmwdtjeabgyrpbqyyykmoaqdambpkyyvukalbrzoyoufjqeftniddsfqnilxlplselqatdgjziphvrbokofvuerpsvqmzakbyzxtxvyanvjpfyvyiivqusfrsufjanmfibgrkwtiuoykiavpbqeyfsuteuxxjiyxvlvgmehycdvxdorpepmsinvmyzeqeiikajopqedyopirmhymozernxzaueljjrhcsofwyddkpnvcvzixdjknikyhzmstvbducjcoyoeoaqruuewclzqqqxzpgykrkygxnmlsrjudoaejxkipkgmcoqtxhelvsizgdwdyjwuumazxfstoaxeqqxoqezakdqjwpkrbldpcbbxexquqrznavcrprnydufsidakvrpuzgfisdxreldbqfizngtrilnbqboxwmwienlkmmiuifrvytukcqcpeqdwwucymgvyrektsnfijdcdoawbcwkkjkqwzffnuqituihjaklvthulmcjrhqcyzvekzqlxgddjoir"</span></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<em>O(N^3)*，这里 *N</em> 是字符串的长度，枚举字符串的左边界、右边界，然后继续验证子串是否是回文子串，这三种操作都与 <em>N</em> 相关；</li><li>空间复杂度：<em>O(1)</em>，只使用到常数个临时变量，与字符串长度无关。</li></ul><h1 id="📖方法二：动态规划"><a href="#📖方法二：动态规划" class="headerlink" title="📖方法二：动态规划"></a>📖方法二：动态规划</h1><p>下面是「动态规划』问题的思考路径，供大家参考。</p><p><strong>特别说明</strong>：</p><ul><li>以下「动态规划」的解释只帮助大家了解「动态规划」问题的基本思想；</li><li>「动态规划」问题可以难到非常难，在学习的时候建议不要钻到特别难的问题中去；</li><li>掌握经典的动态规划问题的解法，理解状态的定义的由来、会列出状态转移方程；</li><li>然后再配合适当难度的问题的练习；</li><li>有时间和感兴趣的话可以做一些不太常见的类型的问题，拓宽视野；</li><li>「动态规划」讲得比较好的经典书籍是《算法导论》。</li></ul><p> <a href="https://pic.leetcode-cn.com/1f95da43d1bdeebdd1213bb804034ddc5f906dc61451cd63f2b5ab5d0eb33b33-%E3%80%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%8D%E9%97%AE%E9%A2%98%E6%80%9D%E8%80%83%E6%96%B9%E5%90%91.png" target="_blank" rel="noopener">「动态规划」问题思考方向.png</a></p><p>1、思考状态（重点）</p><ul><li>状态的定义，先尝试「题目问什么，就把什么设置为状态」；</li><li>然后思考「状态如何转移」，如果「状态转移方程」不容易得到，尝试修改定义，目的依然是为了方便得到「状态转移方程」。</li></ul><blockquote><p>「状态转移方程」是原始问题的不同规模的子问题的联系。即大问题的最优解如何由小问题的最优解得到。</p></blockquote><p>2、思考状态转移方程（核心、难点）</p><ul><li><p>状态转移方程是非常重要的，是动态规划的核心，也是难点；</p></li><li><p>常见的推导技巧是：分类讨论。即：对状态空间进行分类；</p></li><li><p>归纳「状态转移方程」是一个很灵活的事情，通常是具体问题具体分析；</p></li><li><p>除了掌握经典的动态规划问题以外，还需要多做题；</p></li><li><p>如果是针对面试，请自行把握难度。掌握常见问题的动态规划解法，理解动态规划解决问题，是从一个小规模问题出发，逐步得到大问题的解，并记录中间过程；</p></li><li><p>「动态规划」方法依然是「空间换时间」思想的体现，常见的解决问题的过程很像在「填表」。</p></li></ul><p>3、思考初始化</p><p>初始化是非常重要的，一步错，步步错。初始化状态一定要设置对，才可能得到正确的结果。</p><ul><li><p>角度 1：直接从状态的语义出发；</p></li><li><p>角度 2：如果状态的语义不好思考，就考虑「状态转移方程」的边界需要什么样初始化的条件；</p></li><li><p>角度 3：从「状态转移方程」方程的下标看是否需要多设置一行、一列表示「哨兵」（sentinel），这样可以避免一些特殊情况的讨论。</p></li></ul><p>4、思考输出</p><p>有些时候是最后一个状态，有些时候可能会综合之前所有计算过的状态。</p><p>5、思考优化空间（也可以叫做表格复用）</p><ul><li>「优化空间」会使得代码难于理解，且是的「状态」丢失原来的语义，初学的时候可以不一步到位。先把代码写正确是更重要；</li><li>「优化空间」在有一种情况下是很有必要的，那就是状态空间非常庞大的时候（处理海量数据），此时空间不够用，就必须「优化空间」；</li><li>非常经典的「优化空间」的典型问题是「0-1 背包」问题和「完全背包」问题。</li></ul><hr><p>（下面是这道问题「动态规划」方法的分析）</p><p>这道题比较烦人的是判断回文子串。因此需要一种能够快速判断原字符串的所有子串是否是回文子串的方法，于是想到了「动态规划」。</p><p>「动态规划」的一个关键的步骤是想清楚「状态如何转移」。事实上，「回文」天然具有「状态转移」性质。</p><ul><li>一个回文去掉两头以后，剩下的部分依然是回文（这里暂不讨论边界情况）；</li></ul><p>依然从回文串的定义展开讨论：</p><ul><li>如果一个字符串的头尾两个字符都不相等，那么这个字符串一定不是回文串；</li><li>如果一个字符串的头尾两个字符相等，才有必要继续判断下去。<ul><li>如果里面的子串是回文，整体就是回文串；</li><li>如果里面的子串不是回文串，整体就不是回文串。</li></ul></li></ul><p>即：<strong>在头尾字符相等的情况下，里面子串的回文性质据定了整个子串的回文性质</strong>，这就是状态转移。因此可以把「状态」定义为原字符串的一个子串是否为回文子串。</p><h4 id="第-1-步：定义状态"><a href="#第-1-步：定义状态" class="headerlink" title="第 1 步：定义状态"></a>第 1 步：定义状态</h4><p><code>dp[i][j]</code> 表示子串 <code>s[i..j]</code> 是否为回文子串，这里子串 <code>s[i..j]</code> 定义为左闭右闭区间，可以取到 <code>s[i]</code> 和 <code>s[j]</code>。</p><h4 id="第-2-步：思考状态转移方程"><a href="#第-2-步：思考状态转移方程" class="headerlink" title="第 2 步：思考状态转移方程"></a>第 2 步：思考状态转移方程</h4><p>在这一步分类讨论（根据头尾字符是否相等），根据上面的分析得到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><p>「动态规划」事实上是在填一张二维表格，由于构成子串，因此 <code>i</code> 和 <code>j</code> 的关系是 <code>i &lt;= j</code> ，因此，只需要填这张表格对角线以上的部分。</p></li><li><p>看到 <code>dp[i + 1][j - 1]</code> 就得考虑边界情况。</p></li></ul><p>边界条件是：表达式 <code>[i + 1, j - 1]</code> 不构成区间，即长度严格小于 <code>2</code>，即 <code>j - 1 - (i + 1) + 1 &lt; 2</code> ，整理得 <code>j - i &lt; 3</code>。</p><p>这个结论很显然：<code>j - i &lt; 3</code> 等价于 <code>j - i + 1 &lt; 4</code>，即当子串 <code>s[i..j]</code> 的长度等于 <code>2</code> 或者等于 <code>3</code> 的时候，其实只需要判断一下头尾两个字符是否相等就可以直接下结论了。</p><ul><li>如果子串 <code>s[i + 1..j - 1]</code> 只有 1 个字符，即去掉两头，剩下中间部分只有 <em>1</em> 个字符，显然是回文；</li><li>如果子串 <code>s[i + 1..j - 1]</code> 为空串，那么子串 <code>s[i, j]</code> 一定是回文子串。</li></ul><p>因此，在 <code>s[i] == s[j]</code> 成立和 <code>j - i &lt; 3</code> 的前提下，直接可以下结论，<code>dp[i][j] = true</code>，否则才执行状态转移。</p><h4 id="第-3-步：考虑初始化"><a href="#第-3-步：考虑初始化" class="headerlink" title="第 3 步：考虑初始化"></a>第 3 步：考虑初始化</h4><p>初始化的时候，单个字符一定是回文串，因此把对角线先初始化为 <code>true</code>，即 <code>dp[i][i] = true</code> 。</p><p>事实上，初始化的部分都可以省去。因为只有一个字符的时候一定是回文，<code>dp[i][i]</code> 根本不会被其它状态值所参考。</p><h4 id="第-4-步：考虑输出"><a href="#第-4-步：考虑输出" class="headerlink" title="第 4 步：考虑输出"></a>第 4 步：考虑输出</h4><p>只要一得到 <code>dp[i][j] = true</code>，就记录子串的长度和起始位置，没有必要截取，这是因为截取字符串也要消耗性能，记录此时的回文子串的「起始位置」和「回文长度」即可。</p><h4 id="第-5-步：考虑优化空间"><a href="#第-5-步：考虑优化空间" class="headerlink" title="第 5 步：考虑优化空间"></a>第 5 步：考虑优化空间</h4><p>因为在填表的过程中，只参考了左下方的数值。事实上可以优化，但是增加了代码编写和理解的难度，丢失可读和可解释性。在这里不优化空间。</p><p>注意事项：总是先得到小子串的回文判定，然后大子串才能参考小子串的判断结果，即填表顺序很重要。</p><p>大家能够可以自己动手，画一下表格，相信会对「动态规划」作为一种「表格法」有一个更好的理解。</p><p><strong>参考代码 2</strong>：</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特判</span></span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i][j] 表示 s[i, j] 是否是回文串</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">        <span class="keyword">char</span>[] charArray = s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意开始位置，只需要填这张表格对角线以上的部分，而且扫描的顺序要满足「无后效性」</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (charArray[i] != charArray[j]) &#123;</span><br><span class="line">                    dp[i][j] = <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 只要 dp[i][j] == true 成立，就表示子串 s[i..j] 是回文，此时记录回文长度和起始位置</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxLen) &#123;</span><br><span class="line">                    maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                    begin = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(begin, begin + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        size = len(s)</span><br><span class="line">        <span class="keyword">if</span> size &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">        dp = [[<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(size)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(size)]</span><br><span class="line"></span><br><span class="line">        max_len = <span class="number">1</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">            dp[i][i] = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, size):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, j):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                    <span class="keyword">if</span> j - i &lt; <span class="number">3</span>:</span><br><span class="line">                        dp[i][j] = <span class="keyword">True</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> dp[i][j]:</span><br><span class="line">                    cur_len = j - i + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> cur_len &gt; max_len:</span><br><span class="line">                        max_len = cur_len</span><br><span class="line">                        start = i</span><br><span class="line">        <span class="keyword">return</span> s[start:start + max_len]</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<em>O(N^{2})</em>。</li><li>空间复杂度：<em>O(N^{2})</em>，二维 dp 问题，一个状态得用二维有序数对表示，因此空间复杂度是 <em>O(N^{2})</em>。</li></ul><p>写完代码以后，可以纸上写下代码运行的流程，以字符串 <code>&#39;babad&#39;</code> 为例：</p><p> <a href="https://pic.leetcode-cn.com/b95575c883a4fc025e4e8816d4db1f35579d5bd945bfd9128154f882406bfce7-image.png" target="_blank" rel="noopener">‘babad’</a></p><p>可以发现：</p><p>1、<strong>当 <code>i</code> 和 <code>j</code> (图中是 <code>l</code> 和 <code>r</code>) 的差距等于小于 <code>3</code> 的时候，<code>dp</code> 值可以直接判断，不用参考以前的 <code>dp</code> 值；</strong></p><p>2、<strong>其它情况，每当计算新 <code>dp</code> 值的时候，都一定会参考「左下角」的 <code>dp</code> 值，即 <code>dp[i + 1][j - 1]</code>（<code>i + 1</code> 表示在下边，<code>j - 1</code> 表示在左边）。</strong></p><p>因此，从上到下写，或者从下到上写，都是可以的。</p><p>下面分别展示了错误的填表顺序和正确的填表顺序，以便大家理解动态规划要满足「无后效性」的意思。</p><p><strong>说明：表格中的数字表示「填表顺序」，从 1 开始</strong>。表格外的箭头和数字也表示「填表顺序」，与表格中的数字含义一致。</p><p> <a href="https://pic.leetcode-cn.com/4a24bbe4e55421f4f7d199b14e961eff792146092dd9a0c18cf06c824728407c-image.png" target="_blank" rel="noopener">错误的填表顺序</a></p><p> <a href="https://pic.leetcode-cn.com/7e9d1f1dbe2095b0609233faa03b224ab32adf832515de1ce15b496f2cbdf0ab-image.png" target="_blank" rel="noopener">正确的填表顺序</a></p><p><strong>参考代码 3</strong>：下面这段代码只有内层循环和「参考代码 2」不同，已经标注在注释中。</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] charArray = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="comment">// 只有下面这一行和「参考代码 2」不同，i 正着写、倒过来写都行，因为子串都有参考值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = j - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (charArray[i] == charArray[j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 只要 dp[i][j] == true 成立，就表示子串 s[i, j] 是回文，此时记录回文长度和起始位置</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> curLen = j - i + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (curLen &gt; maxLen) &#123;</span><br><span class="line">                        maxLen = curLen;</span><br><span class="line">                        start = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start, start + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        size = len(s)</span><br><span class="line">        <span class="keyword">if</span> size &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">        dp = [[<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(size)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(size)]</span><br><span class="line"></span><br><span class="line">        max_len = <span class="number">1</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">            dp[i][i] = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, size):</span><br><span class="line">            <span class="comment"># 只有下面这一行代码不一样</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(j - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                    <span class="keyword">if</span> j - i &lt; <span class="number">3</span>:</span><br><span class="line">                        dp[i][j] = <span class="keyword">True</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> dp[i][j]:</span><br><span class="line">                    cur_len = j - i + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> cur_len &gt; max_len:</span><br><span class="line">                        max_len = cur_len</span><br><span class="line">                        start = i</span><br><span class="line">        <span class="keyword">return</span> s[start:start + max_len]</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong>（同上）</p><p>「状态转移方程」其实可以写得更酷一点：借用 <code>or</code> 的短路功能，如果 <code>j - i &lt; 3</code> 成立，其实后面就不用计算了，状态转移方程可以写成如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = (s[i] == s[j]) and (j - i &lt; <span class="number">3</span> or dp[i + <span class="number">1</span>][j - <span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>以下代码虽然看起来短了一些，但是丢失了可读性，逻辑运算符混用，虽然加上了括号表示优先级，但如果没有前文铺垫，很难读懂是什么意思。不太推荐大家这么写。</p><p><strong>参考代码 4</strong>：</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] charArray = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j; i++) &#123;</span><br><span class="line"></span><br><span class="line">                dp[i][j] = charArray[i] == charArray[j] &amp;&amp; (j - i &lt; <span class="number">3</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 只要 dp[i][j] == true 成立，就表示子串 s[i, j] 是回文，此时记录回文长度和起始位置</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> curLen = j - i + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (curLen &gt; maxLen) &#123;</span><br><span class="line">                        maxLen = curLen;</span><br><span class="line">                        start = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start, start + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        size = len(s)</span><br><span class="line">        <span class="keyword">if</span> size &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">        dp = [[<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(size)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(size)]</span><br><span class="line"></span><br><span class="line">        max_len = <span class="number">1</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, size):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, j):</span><br><span class="line">                </span><br><span class="line">                dp[i][j] = (s[i] == s[j]) <span class="keyword">and</span> (j - i &lt; <span class="number">3</span> <span class="keyword">or</span> dp[i + <span class="number">1</span>][j - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> dp[i][j]:</span><br><span class="line">                    cur_len = j - i + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> cur_len &gt; max_len:</span><br><span class="line">                        max_len = cur_len</span><br><span class="line">                        start = i</span><br><span class="line">        <span class="keyword">return</span> s[start:start + max_len]</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong>（同上）</p><p>总结：</p><ul><li>我们看到，用「动态规划」方法解决问题，有的时候并不是直接面向问题的。</li><li>「动态规划」依然是「空间换时间」思想的体现，并且本身「动态规划」作为一种打表格法，就是在用「空间」换「时间」。</li></ul><p>关于「动态规划」方法执行时间慢的说明：</p><ul><li>动态规划本质上还是「暴力解法」，因为需要枚举左右边界，有 <em>O(N^2)</em> 这么多；</li><li>以下提供的「中心扩散法」枚举了所有可能的回文子串的中心，有 <em>O(2N)</em> 这么多，不在一个级别上。</li></ul><p>上面采用了时间复杂度估算的表示，<em>O(N^2)</em> 表示最高项是 <em>aN^2</em> 的多项式。</p><p>从这个问题我们也可以看出，虽然时间复杂度一样，但是实际执行时间有可能是有差距的，并且时间复杂度是一个估算，没有必要计算得很清楚，这是因为真正的运行时间还和很多因素有关：例如所运行机器的环境，测试用例等。</p><hr><h3 id="方法三：中心扩散法"><a href="#方法三：中心扩散法" class="headerlink" title="方法三：中心扩散法"></a>方法三：中心扩散法</h3><p>暴力法采用双指针两边夹，验证是否是回文子串。</p><p>除了枚举字符串的左右边界以外，比较容易想到的是<strong>枚举可能出现的回文子串的“中心位置”，从“中心位置”尝试尽可能扩散出去，得到一个回文串</strong>。</p><p>因此中心扩散法的思路是：遍历每一个索引，以这个索引为中心，利用“回文串”中心对称的特点，往两边扩散，看最多能扩散多远。</p><p>枚举“中心位置”时间复杂度为 <em>O(N)</em>，从“中心位置”扩散得到“回文子串”的时间复杂度为 <em>O(N)</em>，因此时间复杂度可以降到 <em>O(N^2)</em>。</p><p>在这里要注意一个细节：回文串在长度为奇数和偶数的时候，“回文中心”的形式是不一样的。</p><ul><li><p>奇数回文串的“中心”是一个具体的字符，例如：回文串 <code>&quot;aba&quot;</code> 的中心是字符 <code>&quot;b&quot;</code>；</p></li><li><p>偶数回文串的“中心”是位于中间的两个字符的“空隙”，例如：回文串串 <code>&quot;abba&quot;</code> 的中心是两个 <code>&quot;b&quot;</code> 中间的那个“空隙”。</p><p><a href="https://pic.leetcode-cn.com/572db4731d6a0e32ee9c14773ed476068bebb88883335bc7415cb0b43762303a.jpg" target="_blank" rel="noopener">图 1 ：奇数回文串与偶数回文串</a></p></li></ul><p>我们看一下一个字符串可能的回文子串的中心在哪里？</p><p> <a href="https://pic.leetcode-cn.com/3c4ca880f2dd7463e15ddf7bbd59e2f7d11434b7dbc69b55893660012726ee88.jpg" target="_blank" rel="noopener">图 2：枚举可能的所有回文中心</a></p><p>我们可以设计一个方法，兼容以上两种情况：</p><p>1、如果传入重合的索引编码，进行中心扩散，此时得到的回文子串的长度是奇数；</p><p>2、如果传入相邻的索引编码，进行中心扩散，此时得到的回文子串的长度是偶数。</p><p>具体编码细节在以下的代码的注释中体现。</p><p><strong>参考代码 5</strong>：</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        String res = s.substring(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 中心位置枚举到 len - 2 即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            String oddStr = centerSpread(s, i, i);</span><br><span class="line">            String evenStr = centerSpread(s, i, i + <span class="number">1</span>);</span><br><span class="line">            String maxLenStr = oddStr.length() &gt; evenStr.length() ? oddStr : evenStr;</span><br><span class="line">            <span class="keyword">if</span> (maxLenStr.length() &gt; maxLen) &#123;</span><br><span class="line">                maxLen = maxLenStr.length();</span><br><span class="line">                res = maxLenStr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">centerSpread</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// left = right 的时候，此时回文中心是一个字符，回文串的长度是奇数</span></span><br><span class="line">        <span class="comment">// right = left + 1 的时候，此时回文中心是一个空隙，回文串的长度是偶数</span></span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = right;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                i--;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里要小心，跳出 while 循环时，恰好满足 s.charAt(i) != s.charAt(j)，因此不能取 i，不能取 j</span></span><br><span class="line">        <span class="keyword">return</span> s.substring(i + <span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        size = len(s)</span><br><span class="line">        <span class="keyword">if</span> size &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 至少是 1</span></span><br><span class="line">        max_len = <span class="number">1</span></span><br><span class="line">        res = s[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">            palindrome_odd, odd_len = self.__center_spread(s, size, i, i)</span><br><span class="line">            palindrome_even, even_len = self.__center_spread(s, size, i, i + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 当前找到的最长回文子串</span></span><br><span class="line">            cur_max_sub = palindrome_odd <span class="keyword">if</span> odd_len &gt;= even_len <span class="keyword">else</span> palindrome_even</span><br><span class="line">            <span class="keyword">if</span> len(cur_max_sub) &gt; max_len:</span><br><span class="line">                max_len = len(cur_max_sub)</span><br><span class="line">                res = cur_max_sub</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__center_spread</span><span class="params">(self, s, size, left, right)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        left = right 的时候，此时回文中心是一个字符，回文串的长度是奇数</span></span><br><span class="line"><span class="string">        right = left + 1 的时候，此时回文中心是一个空隙，回文串的长度是偶数</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i = left</span><br><span class="line">        j = right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt; size <span class="keyword">and</span> s[i] == s[j]:</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[i + <span class="number">1</span>:j], j - i - <span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">centerSpread</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// left = right 的时候，此时回文中心是一个空隙，向两边扩散得到的回文子串的长度是奇数</span></span><br><span class="line">        <span class="comment">// right = left + 1 的时候，此时回文中心是一个字符，向两边扩散得到的回文子串的长度是偶数</span></span><br><span class="line">        <span class="keyword">int</span> size = s.size();</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = right;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                i--;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里要小心，跳出 while 循环时，恰好满足 s.charAt(i) != s.charAt(j)，因此不能取 i，不能取 j</span></span><br><span class="line">        <span class="keyword">return</span> s.substr(i + <span class="number">1</span>, j - i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特判</span></span><br><span class="line">        <span class="keyword">int</span> size = s.size();</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">string</span> res = s.substr(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 中心位置枚举到 len - 2 即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">string</span> oddStr = centerSpread(s, i, i);</span><br><span class="line">            <span class="built_in">string</span> evenStr = centerSpread(s, i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">string</span> maxLenStr = oddStr.size() &gt; evenStr.size() ? oddStr : evenStr;</span><br><span class="line">            <span class="keyword">if</span> (maxLenStr.length() &gt; maxLen) &#123;</span><br><span class="line">                maxLen = maxLenStr.size();</span><br><span class="line">                res = maxLenStr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<em>O(N^{2})</em>，理由已经叙述。</li><li>空间复杂度：<em>O(1)</em>，只使用到常数个临时变量，与字符串长度无关。</li></ul><p>事实上，还有时间复杂度更优的算法，是由计算机科学家 Manacher 发明的，下面介绍这种算法。</p><h3 id="方法四：Manacher-算法（不用掌握，面试的时候绝大多数情况下不会要求写这个算法，了解思想即可）"><a href="#方法四：Manacher-算法（不用掌握，面试的时候绝大多数情况下不会要求写这个算法，了解思想即可）" class="headerlink" title="方法四：Manacher 算法（不用掌握，面试的时候绝大多数情况下不会要求写这个算法，了解思想即可）"></a>方法四：Manacher 算法（不用掌握，面试的时候绝大多数情况下不会要求写这个算法，了解思想即可）</h3><blockquote><p>说明：以下题解中有一些细节我当时做的时候，没有仔细推敲，已经有朋友指出有错误，请大家根据自己的理解去思考科学家的做法和思想，我暂时没有时间修改这个部分的内容，大家也可以参考其他朋友的题解，给大家造成不便，我很抱歉。</p></blockquote><p>个人觉得知道 Manacher 算法是基于“中心扩散法”，采用和 kmp 算法类似的思想，依然是“以空间换时间”。</p><p>Manacher 算法，被中国程序员戏称为“马拉车”算法。它专门用于解决“最长回文子串”问题，时间复杂度为 <em>O(N)</em>。</p><p>维基百科中对于 Manacher 算法是这样描述的：</p><blockquote><p>[Manacher(1975)] 发现了一种线性时间算法，可以在列出给定字符串中从字符串头部开始的所有回文。并且，Apostolico, Breslauer &amp; Galil (1995) 发现，同样的算法也可以在任意位置查找全部最大回文子串，并且时间复杂度是线性的。因此，他们提供了一种时间复杂度为线性的最长回文子串解法。替代性的线性时间解决 Jeuring (1994), Gusfield (1997)提供的，基于后缀树(suffix trees)。也存在已知的高效并行算法。</p></blockquote><p>Manacher 算法本质上还是中心扩散法，只不过它使用了类似 KMP 算法的技巧，充分挖掘了已经进行回文判定的子串的特点，在遍历的过程中，记录了已经遍历过的子串的信息，也是典型的以空间换时间思想的体现。</p><p>下面介绍 Manacher 算法的具体流程。</p><h4 id="第-1-步：对原始字符串进行预处理（添加分隔符）"><a href="#第-1-步：对原始字符串进行预处理（添加分隔符）" class="headerlink" title="第 1 步：对原始字符串进行预处理（添加分隔符）"></a>第 1 步：对原始字符串进行预处理（添加分隔符）</h4><p>首先在字符串的首尾、相邻的字符中插入分隔符，例如 <code>&quot;babad&quot;</code> 添加分隔符 <code>&quot;#&quot;</code> 以后得到 <code>&quot;#b#a#b#a#d#&quot;</code>。</p><p>对这一点有如下说明：</p><p>1、分隔符是一个字符，种类也只有一个，并且这个字符一定不能是原始字符串中出现过的字符；</p><p>2、加入了分隔符以后，使得“间隙”有了具体的位置，方便后续的讨论，并且<strong>新字符串中的任意一个回文子串在原始字符串中的一定能找到唯一的一个回文子串与之对应</strong>，因此对新字符串的回文子串的研究就能得到原始字符串的回文子串；</p><p>3、新字符串的回文子串的长度一定是奇数；</p><p>4、新字符串的回文子串一定以分隔符作为两边的边界，因此分隔符起到“哨兵”的作用。</p><p> <a href="https://pic.leetcode-cn.com/d9546795e5c73d06b7c77645aef92413f794b3850a62492682a46eb00c9ee711.jpg" target="_blank" rel="noopener">图 3：原始字符串与新字符串的对应关系</a></p><h4 id="第-2-步：计算辅助数组-p"><a href="#第-2-步：计算辅助数组-p" class="headerlink" title="第 2 步：计算辅助数组 p"></a>第 2 步：计算辅助数组 p</h4><p>辅助数组 <code>p</code> 记录了新字符串中以每个字符为中心的回文子串的信息。</p><p>手动的计算方法仍然是“中心扩散法”，此时记录以当前字符为中心，向左右两边同时扩散，记录能够扩散的最大步数。</p><p>以字符串 <code>&quot;abbabb&quot;</code> 为例，说明如何手动计算得到辅助数组 <code>p</code> ，我们要填的就是下面这张表。</p><table><thead><tr><th><strong>char</strong></th><th><strong>#</strong></th><th><strong>a</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th><th><strong>a</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th></tr></thead><tbody><tr><td><strong>index</strong></td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td></tr><tr><td><strong>p</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>第 1 行数组 <code>char</code> ：原始字符串<strong>加上分隔符以后</strong>的每个字符。</p><p>第 2 行数组 <code>index</code> ：这个数组是新字符串的索引数组，它的值是从 <em>0</em> 开始的索引编号。</p><ul><li>我们首先填 <code>p[0]</code>。</li></ul><p>以 <code>char[0] = &#39;#&#39;</code> 为中心，同时向左边向右扩散，走 <em>1</em> 步就碰到边界了，因此能扩散的步数为 <em>0</em>，因此 <code>p[0] = 0</code>；</p><table><thead><tr><th><strong>char</strong></th><th><strong>#</strong></th><th><strong>a</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th><th><strong>a</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th></tr></thead><tbody><tr><td><strong>index</strong></td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td></tr><tr><td><strong>p</strong></td><td><strong>0</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><ul><li>下面填写 <code>p[1]</code> 。</li></ul><p>以 <code>char[1] = &#39;a&#39;</code> 为中心，同时向左边向右扩散，走 <em>1</em> 步，左右都是 <code>&quot;#&quot;</code>，构成回文子串，于是再继续同时向左边向右边扩散，左边就碰到边界了，最多能扩散的步数”为 <em>1</em>，因此 <code>p[1] = 1</code>；</p><table><thead><tr><th><strong>char</strong></th><th><strong>#</strong></th><th><strong>a</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th><th><strong>a</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th></tr></thead><tbody><tr><td><strong>index</strong></td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td></tr><tr><td><strong>p</strong></td><td>0</td><td><strong>1</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><ul><li>下面填写 <code>p[2]</code> 。</li></ul><p>以 <code>char[2] = &#39;#&#39;</code> 为中心，同时向左边向右扩散，走 <em>1</em> 步，左边是 <code>&quot;a&quot;</code>，右边是 <code>&quot;b&quot;</code>，不匹配，最多能扩散的步数为 <em>0</em>，因此 <code>p[2] = 0</code>；</p><table><thead><tr><th><strong>char</strong></th><th><strong>#</strong></th><th><strong>a</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th><th><strong>a</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th></tr></thead><tbody><tr><td><strong>index</strong></td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td></tr><tr><td><strong>p</strong></td><td>0</td><td>1</td><td><strong>0</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><ul><li>下面填写 <code>p[3]</code>。</li></ul><p>以 <code>char[3] = &#39;b&#39;</code> 为中心，同时向左边向右扩散，走 <em>1</em> 步，左右两边都是 <code>“#”</code>，构成回文子串，继续同时向左边向右扩散，左边是 <code>&quot;a&quot;</code>，右边是 <code>&quot;b&quot;</code>，不匹配，最多能扩散的步数为 <em>1</em> ，因此 <code>p[3] = 1</code>；</p><table><thead><tr><th><strong>char</strong></th><th><strong>#</strong></th><th><strong>a</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th><th><strong>a</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th></tr></thead><tbody><tr><td><strong>index</strong></td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td></tr><tr><td><strong>p</strong></td><td>0</td><td>1</td><td>0</td><td><strong>1</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><ul><li>下面填写 <code>p[4]</code>。</li></ul><p>以 <code>char[4] = &#39;#&#39;</code> 为中心，同时向左边向右扩散，最多可以走 <em>4</em> 步，左边到达左边界，因此 <code>p[4] = 4</code>。</p><table><thead><tr><th><strong>char</strong></th><th><strong>#</strong></th><th><strong>a</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th><th><strong>a</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th></tr></thead><tbody><tr><td><strong>index</strong></td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td></tr><tr><td><strong>p</strong></td><td>0</td><td>1</td><td>0</td><td>1</td><td><strong>4</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><ul><li>继续填完 p 数组剩下的部分。</li></ul><p>分析到这里，后面的数字不难填出，最后写成如下表格：</p><table><thead><tr><th><strong>char</strong></th><th><strong>#</strong></th><th><strong>a</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th><th><strong>a</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th><th><strong>b</strong></th><th><strong>#</strong></th></tr></thead><tbody><tr><td><strong>index</strong></td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td></tr><tr><td><strong>p</strong></td><td>0</td><td>1</td><td>0</td><td>1</td><td>4</td><td>1</td><td>0</td><td>5</td><td>0</td><td>1</td><td>2</td><td>1</td><td>0</td></tr></tbody></table><p><strong>说明</strong>：有些资料将辅助数组 <code>p</code> 定义为回文半径数组，即 <code>p[i]</code> 记录了以新字符串第 <code>i</code> 个字符为中心的回文字符串的半径（包括第 <code>i</code> 个字符），与我们这里定义的辅助数组 <code>p</code> 有一个字符的偏差，本质上是一样的。</p><p>下面是辅助数组 <code>p</code> 的结论：辅助数组 <code>p</code> 的最大值是 <em>5</em>，对应了原字符串 <code>&quot;abbabb&quot;</code> 的  “最长回文子串” ：<code>&quot;bbabb&quot;</code>。这个结论具有一般性，即：</p><blockquote><p>辅助数组 <code>p</code> 的最大值就是“最长回文子串”的长度。</p></blockquote><p>因此，我们可以在计算辅助数组 <code>p</code> 的过程中记录这个最大值，并且记录最长回文子串。</p><p>简单说明一下这是为什么：</p><ol><li><p>如果新回文子串的中心是一个字符，那么原始回文子串的中心也是一个字符，在新回文子串中，向两边扩散的特点是：“先分隔符，后字符”，同样扩散的步数因为有分隔符 <code>#</code> 的作用，在新字符串中每扩散两步，虽然实际上只扫到一个有效字符，但是相当于在原始字符串中相当于计算了两个字符。<strong>因为最后一定以分隔符结尾，还要计算一个，正好这个就可以把原始回文子串的中心算进去</strong>；</p><p><a href="https://pic.leetcode-cn.com/4ba4319f13bee429bb95ba119dcaefe71c9644bcf9e9be3ba2637d13fcccd3d6.jpg" target="_blank" rel="noopener">图 4：理解辅助数组的数值与原始字符串回文子串的等价性-1</a></p></li></ol><ol start="2"><li>如果新回文子串的中心是 <code>#</code>，那么原始回文子串的中心就是一个“空隙”。在新回文子串中，向两边扩散的特点是：“先字符，后分隔符”，扩散的步数因为有分隔符  <code>#</code> 的作用，在新字符串中每扩散两步，虽然实际上只扫到一个有效字符，但是相当于在原始字符串中相当于计算了两个字符。</li></ol><p>因此，“辅助数组 <code>p</code> 的最大值就是“最长回文子串”的长度”这个结论是成立的，可以看下面的图理解上面说的 <em>2</em> 点。</p><p> <a href="https://pic.leetcode-cn.com/05e76869add71c1cbf396bb89ee5ad7f560cc6c5e60926ceaef00a3bbc32c9e4.jpg" target="_blank" rel="noopener">图 4：理解辅助数组的数值与原始字符串回文子串的等价性-2</a></p><p>写到这里，其实已经能写出一版代码，把这一版代码提交到 LeetCode 是可以通过的，这同样也可以验证我们上面的结论是正确的。</p><p><strong>参考代码 6</strong>：</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        String str = addBoundaries(s, <span class="string">'#'</span>);</span><br><span class="line">        <span class="keyword">int</span> sLen = <span class="number">2</span> * len + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sLen; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> curLen = centerSpread(str, i);</span><br><span class="line">            <span class="keyword">if</span> (curLen &gt; maxLen) &#123;</span><br><span class="line">                maxLen = curLen;</span><br><span class="line">                start = (i - maxLen) / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start, start + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">centerSpread</span><span class="params">(String s, <span class="keyword">int</span> center)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> i = center - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = center + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; len &amp;&amp; s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">            i--;</span><br><span class="line">            j++;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建预处理字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s      原始字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> divide 分隔字符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 使用分隔字符处理以后得到的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">addBoundaries</span><span class="params">(String s, <span class="keyword">char</span> divide)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s.indexOf(divide) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误，您传递的分割字符，在输入字符串中存在！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            stringBuilder.append(divide);</span><br><span class="line">            stringBuilder.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        stringBuilder.append(divide);</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># Manacher 算法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="comment"># 特判</span></span><br><span class="line">        size = len(s)</span><br><span class="line">        <span class="keyword">if</span> size &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 得到预处理字符串</span></span><br><span class="line">        t = <span class="string">"#"</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">            t += s[i]</span><br><span class="line">            t += <span class="string">"#"</span></span><br><span class="line">        <span class="comment"># 新字符串的长度</span></span><br><span class="line">        t_len = <span class="number">2</span> * size + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 当前遍历的中心最大扩散步数，其值等于原始字符串的最长回文子串的长度</span></span><br><span class="line">        max_len = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 原始字符串的最长回文子串的起始位置，与 max_len 必须同时更新</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(t_len):</span><br><span class="line">            cur_len = self.__center_spread(t, i)</span><br><span class="line">            <span class="keyword">if</span> cur_len &gt; max_len:</span><br><span class="line">                max_len = cur_len</span><br><span class="line">                start = (i - max_len) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> s[start: start + max_len]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__center_spread</span><span class="params">(self, s, center)</span>:</span></span><br><span class="line">        size = len(s)</span><br><span class="line">        i = center - <span class="number">1</span></span><br><span class="line">        j = center + <span class="number">1</span></span><br><span class="line">        step = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt; size <span class="keyword">and</span> s[i] == s[j]:</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            step += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> step</span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">centerSpread</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> center)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.size();</span><br><span class="line">        <span class="keyword">int</span> i = center - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = center + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; len &amp;&amp; s[i] == s[j]) &#123;</span><br><span class="line">            i--;</span><br><span class="line">            j++;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特判</span></span><br><span class="line">        <span class="keyword">int</span> size = s.size();</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到预处理字符串</span></span><br><span class="line">        <span class="built_in">string</span> str = <span class="string">"#"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            str += s[i];</span><br><span class="line">            str += <span class="string">"#"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sSize = <span class="number">2</span> * size + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sSize; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> curLen = centerSpread(str, i);</span><br><span class="line">            <span class="keyword">if</span> (curLen &gt; maxLen) &#123;</span><br><span class="line">                maxLen = curLen;</span><br><span class="line">                start = (i - maxLen) / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<em>O(N^2)*，这里 *N</em> 是原始字符串的长度。新字符串的长度是 2<em>N+1 ，不计系数与常数项，因此时间复杂度仍为 *O(N^2)</em>。</li><li>空间复杂度：<em>O(N)</em>。</li></ul><blockquote><p><strong>科学家的工作：充分利用新字符串的回文性质，计算辅助数组 <code>p</code>。</strong></p></blockquote><p>上面的代码不太智能的地方是，对新字符串每一个位置进行中心扩散，会导致原始字符串的每一个字符被访问多次，一个比较极端的情况就是：<code>#a#a#a#a#a#a#a#a#</code>。事实上，计算机科学家 Manacher 就改进了这种算法，使得在填写新的辅助数组 <code>p</code> 的值的时候，能够参考已经填写过的辅助数组 <code>p</code> 的值，使得新字符串每个字符只访问了一次，整体时间复杂度由 <em>O(N^2)</em> 改进到 <em>O(N)</em>。</p><p>具体做法是：在遍历的过程中，除了循环变量 <code>i</code> 以外，我们还需要记录两个变量，它们是 <code>maxRight</code> 和 <code>center</code> ，它们分别的含义如下：</p><ul><li><code>maxRight</code>：记录当前向右扩展的最远边界，即从开始到现在使用“中心扩散法”能得到的回文子串，它能延伸到的最右端的位置 。对于 <code>maxRight</code> 我们说明 3 点：</li></ul><ol><li><p>“向右最远”是在计算辅助数组 <code>p</code> 的过程中，向右边扩散能走的索引最大的位置，注意：得到一个 <code>maxRight</code> 所对应的回文子串，并不一定是当前得到的“最长回文子串”，很可能的一种情况是，某个回文子串可能比较短，但是它正好在整个字符串比较靠后的位置；</p></li><li><p><code>maxRight</code> 的下一个位置可能是被程序看到的，停止的原因有 2 点：（1）左边界不能扩散，导致右边界受限制也不能扩散，<code>maxRight</code> 的下一个位置看不到；（2）正是因为看到了 <code>maxRight</code> 的下一个位置，导致 <code>maxRight</code> 不能继续扩散。</p></li><li><p>为什么 <code>maxRight</code> 很重要？因为扫描是从左向右进行的， <code>maxRight</code> 能够提供的信息最多，它是一个重要的分类讨论的标准，因此我们需要一个变量记录它。</p></li></ol><ul><li><code>center</code>：<code>center</code> 是与 <code>maxRight</code> 相关的一个变量，它是上述 <code>maxRight</code> 的回文中心的索引值。对于 <code>center</code> 的说明如下：</li></ul><ol><li><p><code>center</code> 的形式化定义：</p><pre><code>center=argmax{x+p[x]∣0≤x&lt;i}</code></pre><p>说明：<code>x + p[x]</code> 的最大值就是我们定义的 <code>maxRight</code>，<code>i</code> 是循环变量，<code>0&lt;= x&lt; i</code> 表示是在 <code>i</code> 之前的所有索引里得到的最大值  <code>maxRight</code>，它对应的回文中心索引就是上述式子。</p></li><li><p><code>maxRight</code> 与 <code>center</code> 是一一对应的关系，即一个  <code>center</code> 的值唯一对应了一个 <code>maxRight</code> 的值；因此 <strong><code>maxRight</code> 与 <code>center</code> 必须要同时更新</strong>。</p></li></ol><p>下面的讨论就根据循环变量 <code>i</code> 与 <code>maxRight</code> 的关系展开讨论：</p><p>情况 1：当 <code>i &gt;= maxRight</code> 的时候，这就是一开始，以及刚刚把一个回文子串扫描完的情况，此时只能够根据“中心扩散法”一个一个扫描，逐渐扩大 <code>maxRight</code>；</p><p>情况 2：当 <code>i &lt; maxRight</code> 的时候，根据新字符的回文子串的性质，循环变量关于 <code>center</code> 对称的那个索引（记为 <code>mirror</code>）的 <code>p</code> 值就很重要。</p><p>我们先看 <code>mirror</code> 的值是多少，因为 <code>center</code> 是中心，<code>i</code> 和 <code>mirror</code> 关于 <code>center</code> 中心对称，因此 <code>(mirror + i) / 2 = center</code> ，所以 <code>mirror = 2 * center - i</code>。</p><p>根据 <code>p[mirror]</code> 的数值从小到大，具体可以分为如下 3 种情况：</p><p>情况 2（1）：<code>p[mirror]</code> 的数值比较小，不超过 <code>maxRight - i</code>。</p><p>说明：<code>maxRight - i</code> 的值，就是从 <code>i</code> 关于 <code>center</code> 的镜像点开始向左走（不包括它自己），到 <code>maxRight</code> 关于 <code>center</code> 的镜像点的步数</p><p> <a href="https://pic.leetcode-cn.com/aadfb3cfee9715c7d0a8fb8e8938ede16203226710909e093a27e2e2791b9233-image.png" target="_blank" rel="noopener">图 5：Manacher 算法分类讨论情况 2（1）</a></p><p>从图上可以看出，由于“以 <code>center</code> 为中心的回文子串”的对称性，导致了“以 <code>i</code> 为中心的回文子串”与“以 <code>center</code> 为中心的回文子串”也具有对称性，“以 <code>i</code> 为中心的回文子串”与“以 <code>center</code> 为中心的回文子串”不能再扩散了，此时，直接把数值抄过来即可，即 <code>p[i] = p[mirror]</code>。</p><p>情况 2（2）：<code>p[mirror]</code> 的数值恰好等于 <code>maxRight - i</code>。</p><p> <a href="https://pic.leetcode-cn.com/2f25bb6f215a3caba05738cb0be4cdb0b0c380fa9fe0b7e80ee00a1f1840b088-image.png" target="_blank" rel="noopener">图 5：Manacher 算法分类讨论情况 2（2）</a></p><p>说明：仍然是依据“以 <code>center</code> 为中心的回文子串”的对称性，导致了“以 <code>i</code> 为中心的回文子串”与“以 <code>center</code> 为中心的回文子串”也具有对称性。</p><ol><li>因为靠左边的 <code>f</code> 与靠右边的 <code>g</code> 的原因，导致“以 <code>center</code> 为中心的回文子串”不能继续扩散；</li><li>但是“以 <code>i</code> 为中心的回文子串” 还可以继续扩散。</li></ol><p>因此，可以先把 <code>p[mirror]</code> 的值抄过来，然后继续“中心扩散法”，继续增加 <code>maxRight</code>。</p><p>情况 2（3）：<code>p[mirror]</code> 的数值大于 <code>maxRight - i</code>。</p><p> <a href="https://pic.leetcode-cn.com/dac4d98cd3c3963eb5b48a851dd4988c5f998158bf66a77feb134255522838d7-image.png" target="_blank" rel="noopener">图 5：Manacher 算法分类讨论情况 2（3）</a></p><p>说明：仍然是依据“以 <code>center</code> 为中心的回文子串”的对称性，导致了“以 <code>i</code> 为中心的回文子串”与“以 <code>center</code> 为中心的回文子串”也具有对称性。<br>下面证明，<code>p[i] = maxRight - i</code> ，证明的方法还是利用三个回文子串的对称性。</p><p> <a href="https://pic.leetcode-cn.com/d404aff63ecd764aaa70e6bb961a7e4286b8b2afdb6b4ce4bf696fb8eeb55086.jpg" target="_blank" rel="noopener">图 5：Manacher 算法分类讨论情况 2（3）的证明</a></p><p>① 由于“以 <code>center</code> 为中心的回文子串”的对称性， 黄色箭头对应的字符 <code>c</code> 和 <code>e</code> 一定不相等；</p><p>② 由于“以 <code>mirror</code> 为中心的回文子串”的对称性， 绿色箭头对应的字符 <code>c</code> 和 <code>c</code> 一定相等；</p><p>③ 又由于“以 <code>center</code> 为中心的回文子串”的对称性， 蓝色箭头对应的字符 <code>c</code> 和 <code>c</code> 一定相等；</p><p>推出“以 <code>i</code> 为中心的回文子串”的对称性，  红色箭头对应的字符 <code>c</code> 和 <code>e</code> 一定不相等。</p><p>因此，<code>p[i] = maxRight - i</code>，不可能再大。上面是因为我画的图，可能看的朋友会觉得理所当然。事实上，可以使用反证法证明：</p><p>如果“以 <code>i</code> 为中心的回文子串” 再向两边扩散的两个字符 <code>c</code> 和 <code>e</code> 相等，就能够推出黄色、绿色、蓝色、红色箭头所指向的 8 个变量的值都相等，此时“以 <code>center</code> 为中心的回文子串” 就可以再同时向左边和右边扩散 <em>1</em> 格，与 <code>maxRight</code> 的最大性矛盾。</p><p>综合以上 3 种情况，当 <code>i &lt; maxRight</code> 的时候，<code>p[i]</code> 可以参考 <code>p[mirror]</code> 的信息，以 <code>maxRight - i</code> 作为参考标准，<code>p[i]</code> 的值应该是保守的，即二者之中较小的那个值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p[i] = min(maxRight - i, p[mirror]);</span><br></pre></td></tr></table></figure><p><strong>参考代码 7</strong>：</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特判</span></span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到预处理字符串</span></span><br><span class="line">        String str = addBoundaries(s, <span class="string">'#'</span>);</span><br><span class="line">        <span class="comment">// 新字符串的长度</span></span><br><span class="line">        <span class="keyword">int</span> sLen = <span class="number">2</span> * len + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数组 p 记录了扫描过的回文子串的信息</span></span><br><span class="line">        <span class="keyword">int</span>[] p = <span class="keyword">new</span> <span class="keyword">int</span>[sLen];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 双指针，它们是一一对应的，须同时更新</span></span><br><span class="line">        <span class="keyword">int</span> maxRight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> center = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前遍历的中心最大扩散步数，其值等于原始字符串的最长回文子串的长度</span></span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 原始字符串的最长回文子串的起始位置，与 maxLen 必须同时更新        </span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sLen; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; maxRight) &#123;</span><br><span class="line">                <span class="keyword">int</span> mirror = <span class="number">2</span> * center - i;</span><br><span class="line">                <span class="comment">// 这一行代码是 Manacher 算法的关键所在，要结合图形来理解</span></span><br><span class="line">                p[i] = Math.min(maxRight - i, p[mirror]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下一次尝试扩散的左右起点，能扩散的步数直接加到 p[i] 中</span></span><br><span class="line">            <span class="keyword">int</span> left = i - (<span class="number">1</span> + p[i]);</span><br><span class="line">            <span class="keyword">int</span> right = i + (<span class="number">1</span> + p[i]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// left &gt;= 0 &amp;&amp; right &lt; sLen 保证不越界</span></span><br><span class="line">            <span class="comment">// str.charAt(left) == str.charAt(right) 表示可以扩散 1 次</span></span><br><span class="line">            <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; sLen &amp;&amp; str.charAt(left) == str.charAt(right)) &#123;</span><br><span class="line">                p[i]++;</span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 根据 maxRight 的定义，它是遍历过的 i 的 i + p[i] 的最大者</span></span><br><span class="line">            <span class="comment">// 如果 maxRight 的值越大，进入上面 i &lt; maxRight 的判断的可能性就越大，这样就可以重复利用之前判断过的回文信息了</span></span><br><span class="line">            <span class="keyword">if</span> (i + p[i] &gt; maxRight) &#123;</span><br><span class="line">                <span class="comment">// maxRight 和 center 需要同时更新</span></span><br><span class="line">                maxRight = i + p[i];</span><br><span class="line">                center = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p[i] &gt; maxLen) &#123;</span><br><span class="line">                <span class="comment">// 记录最长回文子串的长度和相应它在原始字符串中的起点</span></span><br><span class="line">                maxLen = p[i];</span><br><span class="line">                start = (i - maxLen) / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start, start + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建预处理字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s      原始字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> divide 分隔字符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 使用分隔字符处理以后得到的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">addBoundaries</span><span class="params">(String s, <span class="keyword">char</span> divide)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s.indexOf(divide) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误，您传递的分割字符，在输入字符串中存在！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            stringBuilder.append(divide);</span><br><span class="line">            stringBuilder.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        stringBuilder.append(divide);</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># Manacher 算法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="comment"># 特判</span></span><br><span class="line">        size = len(s)</span><br><span class="line">        <span class="keyword">if</span> size &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 得到预处理字符串</span></span><br><span class="line">        t = <span class="string">"#"</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">            t += s[i]</span><br><span class="line">            t += <span class="string">"#"</span></span><br><span class="line">        <span class="comment"># 新字符串的长度</span></span><br><span class="line">        t_len = <span class="number">2</span> * size + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 数组 p 记录了扫描过的回文子串的信息</span></span><br><span class="line">        p = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(t_len)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 双指针，它们是一一对应的，须同时更新</span></span><br><span class="line">        max_right = <span class="number">0</span></span><br><span class="line">        center = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当前遍历的中心最大扩散步数，其值等于原始字符串的最长回文子串的长度</span></span><br><span class="line">        max_len = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 原始字符串的最长回文子串的起始位置，与 max_len 必须同时更新</span></span><br><span class="line">        start = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(t_len):</span><br><span class="line">            <span class="keyword">if</span> i &lt; max_right:</span><br><span class="line">                mirror = <span class="number">2</span> * center - i</span><br><span class="line">                <span class="comment"># 这一行代码是 Manacher 算法的关键所在，要结合图形来理解</span></span><br><span class="line">                p[i] = min(max_right - i, p[mirror])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 下一次尝试扩散的左右起点，能扩散的步数直接加到 p[i] 中</span></span><br><span class="line">            left = i - (<span class="number">1</span> + p[i])</span><br><span class="line">            right = i + (<span class="number">1</span> + p[i])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># left &gt;= 0 and right &lt; t_len 保证不越界</span></span><br><span class="line">            <span class="comment"># t[left] == t[right] 表示可以扩散 1 次</span></span><br><span class="line">            <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; t_len <span class="keyword">and</span> t[left] == t[right]:</span><br><span class="line">                p[i] += <span class="number">1</span></span><br><span class="line">                left -= <span class="number">1</span></span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 根据 max_right 的定义，它是遍历过的 i 的 i + p[i] 的最大者</span></span><br><span class="line">            <span class="comment"># 如果 max_right 的值越大，进入上面 i &lt; max_right 的判断的可能性就越大，这样就可以重复利用之前判断过的回文信息了</span></span><br><span class="line">            <span class="keyword">if</span> i + p[i] &gt; max_right:</span><br><span class="line">                <span class="comment"># max_right 和 center 需要同时更新</span></span><br><span class="line">                max_right = i + p[i]</span><br><span class="line">                center = i</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> p[i] &gt; max_len:</span><br><span class="line">                <span class="comment"># 记录最长回文子串的长度和相应它在原始字符串中的起点</span></span><br><span class="line">                max_len = p[i]</span><br><span class="line">                start = (i - max_len) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> s[start: start + max_len]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特判</span></span><br><span class="line">        <span class="keyword">int</span> size = s.size();</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到预处理字符串</span></span><br><span class="line">        <span class="built_in">string</span> str = <span class="string">"#"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            str += s[i];</span><br><span class="line">            str += <span class="string">"#"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 新字符串的长度</span></span><br><span class="line">        <span class="keyword">int</span> strSize = <span class="number">2</span> * size + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 数组 p 记录了扫描过的回文子串的信息</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p(strSize, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 双指针，它们是一一对应的，须同时更新</span></span><br><span class="line">        <span class="keyword">int</span> maxRight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> center = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前遍历的中心最大扩散步数，其值等于原始字符串的最长回文子串的长度</span></span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 原始字符串的最长回文子串的起始位置，与 maxLen 必须同时更新</span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strSize; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; maxRight) &#123;</span><br><span class="line">                <span class="keyword">int</span> mirror = (<span class="number">2</span> * center) - i;</span><br><span class="line">                <span class="comment">// 这一行代码是 Manacher 算法的关键所在，要结合图形来理解</span></span><br><span class="line">                p[i] = min(maxRight - i, p[mirror]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下一次尝试扩散的左右起点，能扩散的步数直接加到 p[i] 中</span></span><br><span class="line">            <span class="keyword">int</span> left = i - (<span class="number">1</span> + p[i]);</span><br><span class="line">            <span class="keyword">int</span> right = i + (<span class="number">1</span> + p[i]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// left &gt;= 0 &amp;&amp; right &lt; sLen 保证不越界</span></span><br><span class="line">            <span class="comment">// str.charAt(left) == str.charAt(right) 表示可以扩散 1 次</span></span><br><span class="line">            <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; strSize &amp;&amp; str[left] == str[right]) &#123;</span><br><span class="line">                p[i]++;</span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据 maxRight 的定义，它是遍历过的 i 的 i + p[i] 的最大者</span></span><br><span class="line">            <span class="comment">// 如果 maxRight 的值越大，进入上面 i &lt; maxRight 的判断的可能性就越大，这样就可以重复利用之前判断过的回文信息了</span></span><br><span class="line">            <span class="keyword">if</span> (i + p[i] &gt; maxRight) &#123;</span><br><span class="line">                <span class="comment">// maxRight 和 center 需要同时更新</span></span><br><span class="line">                maxRight = i + p[i];</span><br><span class="line">                center = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p[i] &gt; maxLen) &#123;</span><br><span class="line">                <span class="comment">// 记录最长回文子串的长度和相应它在原始字符串中的起点</span></span><br><span class="line">                maxLen = p[i];</span><br><span class="line">                start = (i - maxLen) / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<em>O(N)</em>，Manacher 算法只有在遇到还未匹配的位置时才进行匹配，已经匹配过的位置不再匹配，因此对于字符串 <code>S</code> 的每一个位置，都只进行一次匹配，算法的复杂度为 <em>O(N)</em>。</li><li>空间复杂度：<em>O(N)</em>。</li></ul><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/</a></p><p>【2】<a href="https://liweiwei1419.gitee.io/leetcode-algo/#indexCard" target="_blank" rel="noopener">https://liweiwei1419.gitee.io/leetcode-algo/#indexCard</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;找到字符串中最长的回文子串，提供了「动态规划』问题的思考路径&lt;/p&gt;
    
    </summary>
    
      <category term="2020年5月" scheme="http://yoursite.com/categories/2020%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>131. 分割回文串</title>
    <link href="http://yoursite.com/2020/05/28/131.%20%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    <id>http://yoursite.com/2020/05/28/131. 分割回文串/</id>
    <published>2020-05-27T16:12:12.000Z</published>
    <updated>2020-05-28T11:46:20.618Z</updated>
    
    <content type="html"><![CDATA[<p>分割成一些子串，使每个子串都是回文串。返回 s 所有可能的分割方案</p><a id="more"></a><h1 id="📖题目描述："><a href="#📖题目描述：" class="headerlink" title="📖题目描述："></a>📖题目描述：</h1><p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。</p><p>返回 s 所有可能的分割方案。</p><p>示例:</p><pre><code>输入: &quot;aab&quot;输出:[  [&quot;aa&quot;,&quot;b&quot;],  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]]</code></pre><h1 id="📖解题思路"><a href="#📖解题思路" class="headerlink" title="📖解题思路"></a>📖解题思路</h1><p>搜索问题主要使用回溯法。</p><p>回溯法思考的步骤：</p><p>1、画递归树；</p><p>2、根据自己画的递归树编码。</p><p> <a href="https://pic.leetcode-cn.com/298a80282ac3505fec3710abdc1e656c591cf7acaa3ba976151480729244b649-image.png" target="_blank" rel="noopener">递归树</a></p><p>思考如何根据这棵递归树编码：</p><p>1、每一个结点表示剩余没有扫描到的字符串，产生分支是截取了剩余字符串的前缀；</p><p>2、产生前缀字符串的时候，判断前缀字符串是否是回文。</p><ul><li>如果前缀字符串是回文，则可以产生分支和结点；</li><li>如果前缀字符串不是回文，则不产生分支和结点，这一步是剪枝操作。</li></ul><p>3、在叶子结点是空字符串的时候结算，此时<strong>从根结点到叶子结点的路径，就是结果集里的一个结果，使用深度优先遍历，记录下所有可能的结果</strong>。</p><ul><li>采用一个路径变量 <code>path</code> 搜索，<code>path</code> 全局使用一个（注意结算的时候，需要生成一个拷贝），因此在递归执行方法结束以后需要回溯，即将递归之前添加进来的元素拿出去；</li><li><code>path</code> 的操作只在列表的末端，因此合适的数据结构是栈。</li></ul><h1 id="📖方法一：回溯"><a href="#📖方法一：回溯" class="headerlink" title="📖方法一：回溯"></a>📖方法一：回溯</h1><p><strong>参考代码 1</strong>：</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Stack 这个类 Java 的文档里推荐写成 Deque&lt;Integer&gt; stack = new ArrayDeque&lt;Integer&gt;();</span></span><br><span class="line">        <span class="comment">// 注意：只使用 stack 相关的接口</span></span><br><span class="line">        Deque&lt;String&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        backtracking(s, <span class="number">0</span>, len, stack, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 起始字符的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len   字符串 s 的长度，可以设置为全局变量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path  记录从根结点到叶子结点的路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> res   记录所有的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> len, Deque&lt;String&gt; path, List&lt;List&lt;String&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == len) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 因为截取字符串是消耗性能的，因此，采用传子串索引的方式判断一个子串是否是回文子串</span></span><br><span class="line">            <span class="comment">// 不是的话，剪枝</span></span><br><span class="line">            <span class="keyword">if</span> (!checkPalindrome(s, start, i)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            path.addLast(s.substring(start, i + <span class="number">1</span>));</span><br><span class="line">            backtracking(s, i + <span class="number">1</span>, len, path, res);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这一步的时间复杂度是 O(N)，因此，可以采用动态规划先把回文子串的结果记录在一个表格里</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left  子串的左边界，可以取到</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 子串的右边界，可以取到</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkPalindrome</span><span class="params">(String str, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 严格小于即可</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(left) != str.charAt(right)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="📖方法二：回溯的优化（加了动态规划）"><a href="#📖方法二：回溯的优化（加了动态规划）" class="headerlink" title="📖方法二：回溯的优化（加了动态规划）"></a>📖方法二：回溯的优化（加了动态规划）</h1><p>在上一步，验证回文串那里，每一次都得使用“两边夹”的方式验证子串是否是回文子串。于是“用空间换时间”，利用「力扣」第 5 题：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring" target="_blank" rel="noopener">最长回文子串</a> 的思路，利用动态规划把结果先算出来，这样就可以以 <em>O(1)</em> 的时间复杂度直接得到一个子串是否是回文。</p><p><strong>参考代码 2</strong>：</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 预处理</span></span><br><span class="line">        <span class="comment">// 状态：dp[i][j] 表示 s[i][j] 是否是回文</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">        <span class="comment">// 状态转移方程：在 s[i] == s[j] 的时候，dp[i][j] 参考 dp[i + 1][j - 1]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> right = <span class="number">0</span>; right &lt; len; right++) &#123;</span><br><span class="line">            <span class="comment">// 注意：left &lt;= right 取等号表示 1 个字符的时候也需要判断</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>; left &lt;= right; left++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(left) == s.charAt(right) &amp;&amp; (right - left &lt;= <span class="number">2</span> || dp[left + <span class="number">1</span>][right - <span class="number">1</span>])) &#123;</span><br><span class="line">                    dp[left][right] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Deque&lt;String&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        backtracking(s, <span class="number">0</span>, len, dp, stack, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(String s,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> start,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">boolean</span>[][] dp,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Deque&lt;String&gt; path,</span></span></span><br><span class="line"><span class="function"><span class="params">                              List&lt;List&lt;String&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == len) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 剪枝</span></span><br><span class="line">            <span class="keyword">if</span> (!dp[start][i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.addLast(s.substring(start, i + <span class="number">1</span>));</span><br><span class="line">            backtracking(s, i + <span class="number">1</span>, len, dp, path, res);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://leetcode-cn.com/problems/palindrome-partitioning/solution/hui-su-you-hua-jia-liao-dong-tai-gui-hua-by-liweiw/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/palindrome-partitioning/solution/hui-su-you-hua-jia-liao-dong-tai-gui-hua-by-liweiw/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分割成一些子串，使每个子串都是回文串。返回 s 所有可能的分割方案&lt;/p&gt;
    
    </summary>
    
      <category term="2020年5月" scheme="http://yoursite.com/categories/2020%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>887. 鸡蛋掉落</title>
    <link href="http://yoursite.com/2020/05/28/887.%20%E9%B8%A1%E8%9B%8B%E6%8E%89%E8%90%BD/"/>
    <id>http://yoursite.com/2020/05/28/887. 鸡蛋掉落/</id>
    <published>2020-05-27T16:12:12.000Z</published>
    <updated>2020-05-28T07:39:15.598Z</updated>
    
    <content type="html"><![CDATA[<p>确定不摔碎鸡蛋的临界楼层的最小移动次数</p><a id="more"></a><h1 id="📖题目描述："><a href="#📖题目描述：" class="headerlink" title="📖题目描述："></a>📖题目描述：</h1><p>你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。</p><p>每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。</p><p>你知道存在楼层 F ，满足 0 &lt;= F &lt;= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。</p><p>每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 &lt;= X &lt;= N）。</p><p>你的目标是确切地知道 F 的值是多少。</p><p>无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？</p><p>示例 1：</p><pre><code>输入：K = 1, N = 2输出：2解释：鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。如果它没碎，那么我们肯定知道 F = 2 。因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。</code></pre><p>示例 2：</p><pre><code>输入：K = 2, N = 6输出：3</code></pre><p>示例 3：</p><pre><code>输入：K = 3, N = 14输出：4</code></pre><p>提示：</p><pre><code>1 &lt;= K &lt;= 1001 &lt;= N &lt;= 10000</code></pre><h1 id="📖文字题解"><a href="#📖文字题解" class="headerlink" title="📖文字题解"></a>📖文字题解</h1><p>本题是谷歌的一道经典面试题。由于本题过于经典，谷歌公司已经不再将这题作为面试的候选题目了。</p><p>本题还没出现在Leetcode上时我曾经做过一遍，当时只想到用二分法来寻找临界楼层，但没有和动态规划结合，其实一般涉及到“最多”，“最少”之类的字眼多数都会和动态规划沾边。</p><p>本题难度较高，要想通过本题，需要一定的动态规划优化或数学功底。本题的标准解法为动态规划，由于篇幅有限，不会叙述 <strong>动态规划的边界条件</strong>、<strong>自底向上的动态规划和自顶向下的动态规划分别怎么实现</strong> 等较为基础的知识，而是把重点放在推导动态规划状态转移方程的过程，以及优化的思路、证明以及方法。</p><p>读者应当期望在阅读完本题解后，能够对方法一有一个大致的思路，并且可以在尝试中编写出代码。方法一已经是很优秀的解法，本题解也着重于此。而对于方法二和方法三，已经超过了面试难度，是竞赛中的考点，仅供读者挑战自我的极限。</p><h2 id="方法一：动态规划-二分搜索"><a href="#方法一：动态规划-二分搜索" class="headerlink" title="方法一：动态规划 + 二分搜索"></a>方法一：动态规划 + 二分搜索</h2><p><strong>思路和算法</strong></p><p>我们可以考虑使用动态规划来做这道题，状态可以表示成 <em>(K, N)*，其中 *K</em> 为鸡蛋数，<em>N</em> 为楼层数。当我们从第 <em>X</em> 楼扔鸡蛋的时候：</p><ul><li><p>如果鸡蛋不碎，那么状态变成 <em>(K, N-X)*，即我们鸡蛋的数目不变，但答案只可能在上方的 *N-X</em> 层楼了。也就是说，我们把原问题缩小成了一个规模为 <em>(K, N-X)</em> 的子问题；</p></li><li><p>如果鸡蛋碎了，那么状态变成 <em>(K-1, X-1)*，即我们少了一个鸡蛋，但我们知道答案只可能在第 *X</em> 楼下方的 <em>X-1</em> 层楼中了。也就是说，我们把原问题缩小成了一个规模为 <em>(K-1, X-1)</em> 的子问题。</p></li></ul><p>这样一来，我们定义 <em>dp(K, N)</em> 为在状态 <em>(K, N)</em> 下最少需要的步数。根据以上分析我们可以列出状态转移方程：</p><pre><code>dp(K,N)=1+ min(max(dp(K−1,X−1),dp(K,N−X)))  1≤X≤N</code></pre><p>这个状态转移方程是如何得来的呢？对于 <em>dp(K, N)</em> 而言，我们像上面分析的那样，枚举第一个鸡蛋扔在的楼层数 <em>X</em>。由于我们并不知道真正的 <em>F</em> 值，因此我们必须保证 <strong>鸡蛋碎了之后接下来需要的步数</strong> 和 <strong>鸡蛋没碎之后接下来需要的步数</strong> 二者的 <strong>最大值</strong> 最小，这样就保证了在 <strong>最坏情况下（也就是无论 <em>F</em> 的值如何）</strong> <em>dp(K, N)</em> 的值最小。如果能理解这一点，也就能理解上面的状态转移方程，即 </p><pre><code>最小化max(dp(K-1, X-1), dp(K, N-X))</code></pre><p>如果我们直接暴力转移求解每个状态的 <em>dp</em> 值，时间复杂度是为 <em>O(KN^2)*，即一共有 *O(KN)</em> 个状态，对于每个状态枚举扔鸡蛋的楼层 <em>X</em>，需要 <em>O(N)</em> 的时间。这无疑在当前数据范围下是会超出时间限制的，因此我们需要想办法优化枚举的时间复杂度。</p><p>我们观察到 <em>dp(K, N)</em> 是一个关于 <em>N</em> 的单调递增函数，也就是说在鸡蛋数 <em>K</em> 固定的情况下，楼层数 <em>N</em> 越多，需要的步数一定不会变少。在上述的状态转移方程中，第一项</p><pre><code>T1 (X)=dp(K−1,X−1)</code></pre><p>是一个随 <em>X</em> 的增加而单调递增的函数，第二项</p><pre><code>T2(X)=dp(K,N−X)</code></pre><p>是一个随着 <em>X</em> 的增加而单调递减的函数。</p><p>这如何帮助我们来优化这个问题呢？当 <em>X</em> 增加时，T1 (X) 单调递增而 T2(X) 单调递减，我们可以想象在一个直角坐标系中，横坐标为 <em>X</em>，纵坐标为T1(X) 和 T2(X)。当一个函数单调递增而另一个函数单调递减时，我们如何找到一个位置使得它们的最大值最小呢？</p><p> <a href="https://assets.leetcode-cn.com/solution-static/887_fig1.jpg" target="_blank" rel="noopener">fig1</a></p><p>如上图所示，如果这两个函数都是连续函数，那么我们只需要找出这两个函数的交点，在交点处就能保证这两个函数的最大值最小。但在本题中，T1​(X) 和 T2​ (X) 都是离散函数，也就是说，<em>X</em> 的值只能取 <em>1, 2, 3</em> 等等。在这种情况下，我们需要找到</p><pre><code>最大的满足 T1​(X)&lt;T2​(X)的X_0，以及最小的满足T1​ (X)≥T2​(X)的X_1，</code></pre><p>对应到上图中，就是离这两个函数（想象中的）交点左右两侧最近的整数。</p><p>我们只需要比较在 <em>X_0</em> 和 <em>X_1*处两个函数的最大值，取一个最小的作为 *X</em> 即可。在数学上，我们可以证明出 <em>X_0</em> 和 <em>X_1</em> 相差 <em>1</em>，这也是比较显然的，因为它们正好夹住了那个想象中的交点，并且相距尽可能地近。因此我们就可以使用二分查找的方法找出 <em>X_0</em>，再得到 <em>X_1</em>：</p><p>我们在所有满足条件的 <em>X</em> 上进行二分查找。对于状态 <em>(K, N)</em> 而言，<em>X</em> 即为 <em>[1, N]</em> 中的任一整数； 在二分查找的过程中，假设当前这一步我们查找到了Xmid ，如果</p><pre><code>T1​(Xmid​)&gt;T2​(Xmid​)，</code></pre><p>那么真正的 <em>X_0</em> 一定在 Xmid的左侧，否则真正的 <em>X_0</em> 在Xmid的右侧。</p><p>二分查找的写法因人而异，本质上我们就是需要找到最大的满足</p><pre><code>T1​(X)&lt;T2​(X)</code></pre><p>的 <em>X_0*，根据 Xmid 进行二分边界的调整。在得到了 *X_0</em> 后，我们可以知道 <em>X_1</em> 即为 <em>X_0 + 1*，此时我们只需要比较max(T1​(X0​),T2​(X0​))和 max(T1​(X1​),T2​(X1​)) ，取较小的那个对应的位置作为 *X</em> 即可。</p><p>这样一来，对于给定的状态 <em>(K, N)<em>，我们只需要 O(logN)的时间，通过二分查找就能得到最优的那个 *X</em>，因此时间复杂度从 *O(KN^2)</em> 降低至O(KN\logN) ，可以通过本题。</p><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dp(K, N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, Integer&gt; memo = <span class="keyword">new</span> HashMap();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!memo.containsKey(N * <span class="number">100</span> + K)) &#123;</span><br><span class="line">            <span class="keyword">int</span> ans;</span><br><span class="line">            <span class="keyword">if</span> (N == <span class="number">0</span>)</span><br><span class="line">                ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (K == <span class="number">1</span>)</span><br><span class="line">                ans = N;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> lo = <span class="number">1</span>, hi = N;</span><br><span class="line">                <span class="keyword">while</span> (lo + <span class="number">1</span> &lt; hi) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">int</span> t1 = dp(K-<span class="number">1</span>, x-<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">int</span> t2 = dp(K, N-x);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (t1 &lt; t2)</span><br><span class="line">                        lo = x;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (t1 &gt; t2)</span><br><span class="line">                        hi = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        lo = hi = x;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ans = <span class="number">1</span> + Math.min(Math.max(dp(K-<span class="number">1</span>, lo-<span class="number">1</span>), dp(K, N-lo)),</span><br><span class="line">                                   Math.max(dp(K-<span class="number">1</span>, hi-<span class="number">1</span>), dp(K, N-hi)));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            memo.put(N * <span class="number">100</span> + K, ans);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> memo.get(N * <span class="number">100</span> + K);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[solution1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">superEggDrop</span><span class="params">(self, K: int, N: int)</span> -&gt; int:</span></span><br><span class="line">        memo = &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(k, n)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> (k, n) <span class="keyword">not</span> <span class="keyword">in</span> memo:</span><br><span class="line">                <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">                    ans = <span class="number">0</span></span><br><span class="line">                <span class="keyword">elif</span> k == <span class="number">1</span>:</span><br><span class="line">                    ans = n</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    lo, hi = <span class="number">1</span>, n</span><br><span class="line">                    <span class="comment"># keep a gap of 2 X values to manually check later</span></span><br><span class="line">                    <span class="keyword">while</span> lo + <span class="number">1</span> &lt; hi:</span><br><span class="line">                        x = (lo + hi) // <span class="number">2</span></span><br><span class="line">                        t1 = dp(k<span class="number">-1</span>, x<span class="number">-1</span>)</span><br><span class="line">                        t2 = dp(k, n-x)</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> t1 &lt; t2:</span><br><span class="line">                            lo = x</span><br><span class="line">                        <span class="keyword">elif</span> t1 &gt; t2:</span><br><span class="line">                            hi = x</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            lo = hi = x</span><br><span class="line"></span><br><span class="line">                    ans = <span class="number">1</span> + min(max(dp(k<span class="number">-1</span>, x<span class="number">-1</span>), dp(k, n-x))</span><br><span class="line">                                  <span class="keyword">for</span> x <span class="keyword">in</span> (lo, hi))</span><br><span class="line"></span><br><span class="line">                memo[k, n] = ans</span><br><span class="line">            <span class="keyword">return</span> memo[k, n]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp(K, N)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>[solution1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; memo;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (memo.find(N * <span class="number">100</span> + K) == memo.end()) &#123;</span><br><span class="line">            <span class="keyword">int</span> ans;</span><br><span class="line">            <span class="keyword">if</span> (N == <span class="number">0</span>) ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (K == <span class="number">1</span>) ans = N;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> lo = <span class="number">1</span>, hi = N;</span><br><span class="line">                <span class="keyword">while</span> (lo + <span class="number">1</span> &lt; hi) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">int</span> t1 = dp(K<span class="number">-1</span>, x<span class="number">-1</span>);</span><br><span class="line">                    <span class="keyword">int</span> t2 = dp(K, N-x);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (t1 &lt; t2) lo = x;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (t1 &gt; t2) hi = x;</span><br><span class="line">                    <span class="keyword">else</span> lo = hi = x;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ans = <span class="number">1</span> + min(max(dp(K<span class="number">-1</span>, lo<span class="number">-1</span>), dp(K, N-lo)),</span><br><span class="line">                                   max(dp(K<span class="number">-1</span>, hi<span class="number">-1</span>), dp(K, N-hi)));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            memo[N * <span class="number">100</span> + K] = ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> memo[N * <span class="number">100</span> + K];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dp(K, N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(K * N\logN)  。我们需要计算 <em>O(K * N)</em> 个状态，每个状态计算时需要O(logN)的时间进行二分搜索。</p></li><li><p>空间复杂度：<em>O(K * N)*。我们需要 *O(K * N)</em> 的空间存储每个状态的解。</p></li></ul><h2 id="方法二：决策单调性"><a href="#方法二：决策单调性" class="headerlink" title="方法二：决策单调性"></a>方法二：决策单调性</h2><p><strong>说明</strong></p><p>方法二涉及决策单调性，是竞赛中的考点。这里我们不会叙述 <strong>何为决策单调性</strong> 以及 <strong>如何根据决策单调性写出优化的动态规划</strong>，而是仅指出决策单调性的存在性。</p><p><strong>思路</strong></p><p>我们重新写下方法一中的状态转移方程：</p><pre><code>dp(K,N)=1+min​(max(dp(K−1,X−1),dp(K,N−X))) 1≤X≤N</code></pre><p>并且假设Xopt​是使得 <em>dp(K, N)</em> 取到最优值的最小决策点 <em>X_0</em>。</p><pre><code>Xopt​=argmin​(max(dp(K−1,X−1),dp(K,N−X))) 1≤X≤N</code></pre><p>在方法一中，我们是通过二分查找的方法，找到 <em>X_0</em> 和 <em>X_1</em> 中最优的作为 Xopt​= 的，那么还有什么更好的方法吗？</p><p>我们固定 <em>K</em>，随着 <em>N</em> 的增加，对于状态转移方程中 <em>dp(K-1, X-1)</em> 这一项，它的值是不变的，因为它和 <em>N</em> 无关。而对于状态转移方程中 <em>dp(K, N-X)</em> 这一项，随着 <em>N</em> 的增加，它的值也会增加。在方法一中，我们知道 <em>dp(K-1, X-1)</em> 随着 <em>X</em> 单调递增，而 <em>dp(K, N-X)</em> 随着 <em>X</em> 单调递减，那么当 <em>N</em> 增加时，<em>dp(K, N-X)</em> 对应的函数折线图在每个整数点上都是增加的，因此在 <em>dp(K-1, X-1)</em> 不变的情况下， Xopt​ 是单调递增的。</p><p>我们可以想象一条斜率为负的直线和一条斜率为正的直线，当斜率为负的直线（类比 <em>dp(K, N-X)*）向上平移（类比 *N</em> 的增加）时，它和斜率为正的直线（类比 <em>dp(K-1, X-1)</em>）的交点会一直向右移动，这个交点就确定了 Xopt​ ，这与方法一也是一致的。</p><p>因此当我们固定 <em>K</em> 时，随着 <em>N</em> 的增加，<em>dp(K, N)</em> 对应的最优解的坐标Xopt​单调递增，这样一来每个 <em>dp(K, N)</em> 的均摊时间复杂度为 <em>O(1)</em>。</p><figure class="highlight java"><figcaption><span>[solution2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Right now, dp[i] represents dp(1, i)</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; ++i)</span><br><span class="line">            dp[i] = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= K; ++k) &#123;</span><br><span class="line">            <span class="comment">// Now, we will develop dp2[i] = dp(k, i)</span></span><br><span class="line">            <span class="keyword">int</span>[] dp2 = <span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">1</span>; n &lt;= N; ++n) &#123;</span><br><span class="line">                <span class="comment">// Let's find dp2[n] = dp(k, n)</span></span><br><span class="line">                <span class="comment">// Increase our optimal x while we can make our answer better.</span></span><br><span class="line">                <span class="comment">// Notice max(dp[x-1], dp2[n-x]) &gt; max(dp[x], dp2[n-x-1])</span></span><br><span class="line">                <span class="comment">// is simply max(T1(x-1), T2(x-1)) &gt; max(T1(x), T2(x)).</span></span><br><span class="line">                <span class="keyword">while</span> (x &lt; n &amp;&amp; Math.max(dp[x-<span class="number">1</span>], dp2[n-x]) &gt; Math.max(dp[x], dp2[n-x-<span class="number">1</span>]))</span><br><span class="line">                    x++;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// The final answer happens at this x.</span></span><br><span class="line">                dp2[n] = <span class="number">1</span> + Math.max(dp[x-<span class="number">1</span>], dp2[n-x]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dp = dp2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[N];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[solution2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">superEggDrop</span><span class="params">(self, K: int, N: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># Right now, dp[i] represents dp(1, i)</span></span><br><span class="line">        dp = list(range(N+<span class="number">1</span>))</span><br><span class="line">        dp2 = [<span class="number">0</span>] * (N+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">2</span>, K+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># Now, we will develop dp2[i] = dp(k, i)</span></span><br><span class="line">            x = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">1</span>, N+<span class="number">1</span>):</span><br><span class="line">                <span class="comment"># Let's find dp2[n] = dp(k, n)</span></span><br><span class="line">                <span class="comment"># Increase our optimal x while we can make our answer better.</span></span><br><span class="line">                <span class="comment"># Notice max(dp[x-1], dp2[n-x]) &gt; max(dp[x], dp2[n-x-1])</span></span><br><span class="line">                <span class="comment"># is simply max(T1(x-1), T2(x-1)) &gt; max(T1(x), T2(x)).</span></span><br><span class="line">                <span class="keyword">while</span> x &lt; n <span class="keyword">and</span> max(dp[x<span class="number">-1</span>], dp2[n-x]) &gt;= max(dp[x], dp2[n-x<span class="number">-1</span>]):</span><br><span class="line">                    x += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># The final answer happens at this x.</span></span><br><span class="line">                dp2[n] = <span class="number">1</span> + max(dp[x<span class="number">-1</span>], dp2[n-x])</span><br><span class="line"></span><br><span class="line">            dp = dp2[:]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>[solution2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[N + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; ++i) dp[i] = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= K; ++k) &#123;</span><br><span class="line">            <span class="keyword">int</span> dp2[N + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">1</span>; </span><br><span class="line">            dp2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">1</span>; n &lt;= N; ++n) &#123;</span><br><span class="line">                <span class="keyword">while</span> (x &lt; n &amp;&amp; max(dp[x<span class="number">-1</span>], dp2[n-x]) &gt;= max(dp[x], dp2[n-x<span class="number">-1</span>])) x++;</span><br><span class="line">                dp2[n] = <span class="number">1</span> + max(dp[x<span class="number">-1</span>], dp2[n-x]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">1</span>; n &lt;= N; ++n) dp[n] = dp2[n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[N];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(K * N)*。我们需要计算 *O(K * N)</em> 个状态，同时对于每个 <em>K</em>，最优解指针只会从 <em>0</em> 到 <em>N</em> 走一次，复杂度也是 <em>O(K * N)</em>。因此总体复杂度为 <em>O(K * N)</em>。</p></li><li><p>空间复杂度：<em>O(N)*。因为 *dp</em> 每一层的解只依赖于上一层的解，因此我们每次只保留一层的解，需要的空间复杂度为 <em>O(N)</em>。</p></li></ul><h2 id="方法三：数学法"><a href="#方法三：数学法" class="headerlink" title="方法三：数学法"></a>方法三：数学法</h2><p><strong>说明</strong></p><p>方法三涉及逆向思维，是一种没见过就不太可能想出来，读过题解也很容易忘记的方法。</p><p><strong>思路</strong></p><p>反过来想这个问题：如果我们可以做 <em>T</em> 次操作，而且有 <em>K</em> 个鸡蛋，那么我们能找到答案的最高的 <em>N</em> 是多少？我们设 <em>f(T, K)</em> 为在上述条件下的 <em>N</em>。如果我们求出了所有的 <em>f(T, K)</em>，那么只需要找出最小的满足  f(T,K)≥N  的 <em>T</em>。</p><p>那么我们如何求出 <em>f(T, K)</em> 呢？我们还是使用动态规划。因为我们需要找出最高的 <em>N</em>，因此我们不必思考到底在哪里扔这个鸡蛋，我们只需要扔出一个鸡蛋，看看到底发生了什么：</p><ul><li><p>如果鸡蛋没有碎，那么对应的是 <em>f(T - 1, K)*，也就是说在这一层的上方可以有 *f(T - 1, K)</em> 层；</p></li><li><p>如果鸡蛋碎了，那么对应的是 <em>f(T - 1, K - 1)*，也就是说在这一层的下方可以有 *f(T - 1， K - 1)</em> 层。</p></li></ul><p>因此我们就可以写出状态转移方程：</p><pre><code>f(T, K) = 1 + f(T-1, K-1) + f(T-1, K)</code></pre><p>边界条件为：当 T≥1 的时候 f(T, 1) = T，当K≥1 时，<em>f(1, K) = 1</em>。</p><p>那么问题来了：<strong><em>T</em> 最大可以达到多少</strong>？由于我们在进行动态规划时，<em>T</em> 在题目中并没有给出，那么我们需要进行到动态规划的哪一步呢？可以发现，操作次数是一定不会超过楼层数的，因此 T≤N，我们只要算出在 <em>f(N, K)</em> 内的所有 <em>f</em> 值即可。</p><figure class="highlight java"><figcaption><span>[solution3-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] f = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][K + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; ++i) &#123;</span><br><span class="line">            f[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= K; ++j) &#123;</span><br><span class="line">                f[i][j] = <span class="number">1</span> + f[i - <span class="number">1</span>][j - <span class="number">1</span>] + f[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (f[i][K] &gt;= N) &#123;</span><br><span class="line">                ans = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[solution3-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">superEggDrop</span><span class="params">(self, K: int, N: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        f = [[<span class="number">0</span>] * (K + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(N + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, K + <span class="number">1</span>):</span><br><span class="line">            f[<span class="number">1</span>][i] = <span class="number">1</span></span><br><span class="line">        ans = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, N + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, K + <span class="number">1</span>):</span><br><span class="line">                f[i][j] = <span class="number">1</span> + f[i - <span class="number">1</span>][j - <span class="number">1</span>] + f[i - <span class="number">1</span>][j]</span><br><span class="line">            <span class="keyword">if</span> f[i][K] &gt;= N:</span><br><span class="line">                ans = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>[solution3-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(K + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; ++i) &#123;</span><br><span class="line">            f[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= K; ++j) &#123;</span><br><span class="line">                f[i][j] = <span class="number">1</span> + f[i - <span class="number">1</span>][j - <span class="number">1</span>] + f[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (f[i][K] &gt;= N) &#123;</span><br><span class="line">                ans = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(K<em>N)</em>。事实上，更准确的时间复杂度应当为 <em>O(K * T)</em>，我们不加证明地给出 <em>N = O(T^K)</em>，因此有 ![O(K<em>T)=O(K</em>\sqrt[K]{N}) ](./p__O_K_</em><em>T__=<em>O</em>K</em>*<em>sqrt_K</em>{N}__.png) 。</p></li><li><p>空间复杂度：<em>O(K</em>N)*。</p></li></ul><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://leetcode-cn.com/problems/super-egg-drop/solution/ji-dan-diao-luo-by-leetcode-solution-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/super-egg-drop/solution/ji-dan-diao-luo-by-leetcode-solution-2/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;确定不摔碎鸡蛋的临界楼层的最小移动次数&lt;/p&gt;
    
    </summary>
    
      <category term="2020年5月" scheme="http://yoursite.com/categories/2020%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>21. 合并两个有序链表</title>
    <link href="http://yoursite.com/2020/05/27/21.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/05/27/21. 合并两个有序链表/</id>
    <published>2020-05-27T15:20:12.000Z</published>
    <updated>2020-05-27T16:01:03.665Z</updated>
    
    <content type="html"><![CDATA[<p>将两个升序链表合并为一个新的升序链表并返回</p><a id="more"></a><h1 id="📖题目描述："><a href="#📖题目描述：" class="headerlink" title="📖题目描述："></a>📖题目描述：</h1><p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例：</p><pre><code>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</code></pre><h1 id="📖方法一：递归"><a href="#📖方法一：递归" class="headerlink" title="📖方法一：递归"></a>📖方法一：递归</h1><p><strong>思路</strong></p><p>我们可以如下递归地定义两个链表里的 <code>merge</code> 操作（忽略边界情况，比如空链表等）：</p><pre><code>list1[0]+merge(list1[1:],list2)​    list1[0]&lt;list2[0]list2[0]+merge(list1,list2[1:])​    otherwise</code></pre><p>也就是说，两个链表头部值较小的一个节点与剩下元素的 <code>merge</code> 操作结果合并。</p><p><strong>算法</strong></p><p>我们直接将以上递归过程建模，同时需要考虑边界情况。</p><p>如果 <code>l1</code> 或者 <code>l2</code> 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 <code>l1</code> 和 <code>l2</code> 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束。</p><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[sol1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">elif</span> l2 <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        <span class="keyword">elif</span> l1.val &lt; l2.val:</span><br><span class="line">            l1.next = self.mergeTwoLists(l1.next, l2)</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l2.next = self.mergeTwoLists(l1, l2.next)</span><br><span class="line">            <span class="keyword">return</span> l2</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">        l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n + m)*，其中 *n</em> 和 <em>m</em> 分别为两个链表的长度。因为每次调用递归都会去掉 <code>l1</code> 或者 <code>l2</code> 的头节点（直到至少有一个链表为空），函数 <code>mergeTwoList</code> 至多只会递归调用每个节点一次。因此，时间复杂度取决于合并后的链表长度，即 <em>O(n+m)</em>。</p></li><li><p>空间复杂度：<em>O(n + m)*，其中 *n</em> 和 <em>m</em> 分别为两个链表的长度。递归调用 <code>mergeTwoLists</code> 函数时需要消耗栈空间，栈空间的大小取决于递归调用的深度。结束递归调用时 <code>mergeTwoLists</code> 函数最多调用 <em>n+m</em> 次，因此空间复杂度为 <em>O(n+m)</em>。</p></li></ul><h1 id="📖-方法二：迭代"><a href="#📖-方法二：迭代" class="headerlink" title="📖 方法二：迭代"></a>📖 方法二：迭代</h1><p><strong>思路</strong></p><p>我们可以用迭代的方法来实现上述算法。当 <code>l1</code> 和 <code>l2</code> 都不是空链表时，判断 <code>l1</code> 和 <code>l2</code> 哪一个链表的头节点的值更小，将较小值的节点添加到结果里，当一个节点被添加到结果里之后，将对应链表中的节点向后移一位。</p><p>这种暴力求解方法是首先想到的，但是在实现过程中忽略了使用伪节点，在while循环中判断的都是</p><pre><code>l1.next != null &amp;&amp; l2.next != null</code></pre><p>所以代码写的过于复杂都把自己绕晕了。</p><p><strong>算法</strong></p><p>首先，我们设定一个哨兵节点 <code>prehead</code> ，这可以在最后让我们比较容易地返回合并后的链表。我们维护一个 <code>prev</code> 指针，我们需要做的是调整它的 <code>next</code> 指针。然后，我们重复以下过程，直到 <code>l1</code> 或者 <code>l2</code> 指向了 <code>null</code> ：如果 <code>l1</code> 当前节点的值小于等于 <code>l2</code> ，我们就把 <code>l1</code> 当前的节点接在 <code>prev</code> 节点的后面同时将 <code>l1</code> 指针往后移一位。否则，我们对 <code>l2</code> 做同样的操作。不管我们将哪一个元素接在了后面，我们都需要把 <code>prev</code> 向后移一位。</p><p>在循环终止的时候， <code>l1</code> 和 <code>l2</code> 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表即可。</p><p> <code>1-&gt;4-&gt;5</code> 和 <code>1-&gt;2-&gt;3-&gt;6</code> 两个链表迭代合并的过程见参考资料【2】：</p><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode prehead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        ListNode prev = prehead;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">                prev.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span></span><br><span class="line">        prev.next = l1 == <span class="keyword">null</span> ? l2 : l1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prehead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[sol2-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        prehead = ListNode(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        prev = prehead</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">                prev.next = l1</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prev.next = l2</span><br><span class="line">                l2 = l2.next            </span><br><span class="line">            prev = prev.next</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span></span><br><span class="line">        prev.next = l1 <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">else</span> l2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prehead.next</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><figcaption><span>[sol2-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> prehead = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> prev = prehead;</span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">            prev.next = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev.next = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = prev.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span></span><br><span class="line">    prev.next = l1 === <span class="literal">null</span> ? l2 : l1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prehead.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* preHead = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        ListNode* prev = preHead;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                prev-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span></span><br><span class="line">        prev-&gt;next = l1 == <span class="literal">nullptr</span> ? l2 : l1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> preHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n + m)</em> ，其中 <em>n</em> 和 <em>m</em> 分别为两个链表的长度。因为每次循环迭代中，<code>l1</code> 和 <code>l2</code> 只有一个元素会被放进合并链表中， 因此 <code>while</code> 循环的次数不会超过两个链表的长度之和。所有其他操作的时间复杂度都是常数级别的，因此总的时间复杂度为 <em>O(n+m)</em>。</p></li><li><p>空间复杂度：<em>O(1)</em> 。我们只需要常数的空间存放若干变量。</p></li></ul><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-sorted-lists</a></p><p>【2】<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;将两个升序链表合并为一个新的升序链表并返回&lt;/p&gt;
    
    </summary>
    
      <category term="2020年5月" scheme="http://yoursite.com/categories/2020%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>685.冗余链接II</title>
    <link href="http://yoursite.com/2020/05/26/685.%E5%86%97%E4%BD%99%E9%93%BE%E6%8E%A5II/"/>
    <id>http://yoursite.com/2020/05/26/685.冗余链接II/</id>
    <published>2020-05-26T12:26:12.000Z</published>
    <updated>2020-05-27T16:00:57.870Z</updated>
    
    <content type="html"><![CDATA[<p>使用并查集找到一条可以删去的边。</p><a id="more"></a><h1 id="📖题目描述："><a href="#📖题目描述：" class="headerlink" title="📖题目描述："></a>📖题目描述：</h1><p>在本问题中，有根树指满足以下条件的有向图。该树只有一个根节点，所有其他节点都是该根节点的后继。每一个节点只有一个父节点，除了根节点没有父节点。</p><p>输入一个有向图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。</p><p>结果图是一个以边组成的二维数组。 每一个边 的元素是一对 [u, v]，用以表示有向图中连接顶点 u and v和顶点的边，其中父节点u是子节点v的一个父节点。</p><p>返回一条能删除的边，使得剩下的图是有N个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。</p><p>示例 1:</p><pre><code>输入: [[1,2], [1,3], [2,3]]输出: [2,3]解释: 给定的有向图如下:  1 / \v   v2--&gt;3</code></pre><p>示例 2:</p><pre><code>输入: [[1,2], [2,3], [3,4], [4,1], [1,5]]输出: [4,1]解释: 给定的有向图如下:5 &lt;- 1 -&gt; 2     ^    |     |    v     4 &lt;- 3</code></pre><p>注意:</p><pre><code>二维数组大小的在3到1000范围内。二维数组中的每个整数在1到N之间，其中 N 是二维数组的大小。</code></pre><h1 id="📖解题思路："><a href="#📖解题思路：" class="headerlink" title="📖解题思路："></a>📖解题思路：</h1><p>通过分情况讨论，把hard题分为3个medium题来做。</p><ol><li><p>情况1是多出的边指向某个非root的结点，该结点记为end，它的入度为2，出度不为0，此时答案只可能为指向end的两条边之一，注意这时候答案唯一，删错边可能导致图不联通，无法构成树:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2 -&gt; 1</span><br><span class="line">^  / ^</span><br><span class="line">| v  |</span><br><span class="line">4    3</span><br></pre></td></tr></table></figure></li><li><p>情况2与情况1类似，存在入度为2但出度为0的end结点，此时答案不唯一，删掉指向end的哪条边都能使得图变成树，按照题目要求返回最后环内最后出现的边即可:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5 &lt;- 1 -&gt; 2</span><br><span class="line">     |    |</span><br><span class="line">     v    v</span><br><span class="line">     4 &lt;- 3</span><br></pre></td></tr></table></figure></li><li><p>情况3是多出的边指向root，所有结点的入度都是1，此时答案不唯一，删除环内任意边都可以，按照题目要求返回最后环内最后出现的边即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5 &lt;- 1 -&gt; 2</span><br><span class="line">     ^    |</span><br><span class="line">     |    v</span><br><span class="line">     4 &lt;- 3</span><br></pre></td></tr></table></figure></li></ol><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>根据以上分析，代码可以通过分情况讨论，把这道hard题分为多个medium题来做。（这里假设你已经懂了并查集，若不懂，可以先做一下这题<a href="https://leetcode-cn.com/problems/redundant-connection/" target="_blank" rel="noopener">684.冗余链接I</a>，把并查集学一下）</p><ul><li>情况1和2可以合并处理，并查集合并所有边，对于指向end的边只合并第一条，若最后联通分量合并为1，则可以把指向end的第二条边删除，否则只能删除第一条边。</li><li>情况3时,这时候题目退化为<a href="https://leetcode-cn.com/problems/redundant-connection/" target="_blank" rel="noopener">684.冗余链接I</a>，解法相同，即用并查集不断合并结点，直到将要合并的顶点已经联通了，则当前边是多余的，可删掉。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test case:</span></span><br><span class="line"><span class="comment">// [[1,2],[1,3],[2,3]]</span></span><br><span class="line"><span class="comment">// [[1,2], [2,3], [3,4], [4,1], [1,5]]</span></span><br><span class="line"><span class="comment">// [[2,1],[3,1],[4,2],[1,4]]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parents;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">MyFind</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(a != parents[a])&#123;</span><br><span class="line">            parents[a] = parents[parents[a]];<span class="comment">// 稍微压缩一下路径</span></span><br><span class="line">            a = parents[a];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsConnect</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = MyFind(a);</span><br><span class="line">        <span class="keyword">int</span> p2 = MyFind(b);</span><br><span class="line">        <span class="keyword">return</span> p1 == p2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MyUnion</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = MyFind(a);</span><br><span class="line">        <span class="keyword">int</span> p2 = MyFind(b);</span><br><span class="line">        <span class="keyword">if</span>(p1 == p2) <span class="keyword">return</span>;</span><br><span class="line">        parents[p1] = p2;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findRedundantDirectedConnection(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges) &#123;</span><br><span class="line">        <span class="comment">// 统计大家出入度，并找到入度为2的终点（若有的话）</span></span><br><span class="line">        <span class="keyword">int</span> n = edges.size(); <span class="comment">// n个顶点，注意顶点从1开始</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inDegree(n); <span class="comment">// 入度</span></span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;e : edges)&#123;</span><br><span class="line">            inDegree[e[<span class="number">1</span>]<span class="number">-1</span>]++; <span class="comment">// 入度+1</span></span><br><span class="line">            <span class="keyword">if</span>(inDegree[e[<span class="number">1</span>]<span class="number">-1</span>] &gt; <span class="number">1</span>) end = e[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 并查集初始化</span></span><br><span class="line">        count = edges.size();</span><br><span class="line">        parents.resize(count);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;count; ++i)&#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若有end，则为情况1、2，答案为指向end的两条边之一</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span> != end)&#123;</span><br><span class="line">            <span class="keyword">bool</span> is_first = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge_first;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge_second;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;e : edges)&#123;</span><br><span class="line">                <span class="comment">// 对于指向end的两条边，只合并第一条，看最后是否能联通</span></span><br><span class="line">                <span class="keyword">if</span>(e[<span class="number">1</span>] == end)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(is_first)&#123;</span><br><span class="line">                        is_first = <span class="literal">false</span>;</span><br><span class="line">                        MyUnion(e[<span class="number">0</span>]<span class="number">-1</span>, e[<span class="number">1</span>]<span class="number">-1</span>);</span><br><span class="line">                        edge_first = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        edge_second = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    MyUnion(e[<span class="number">0</span>]<span class="number">-1</span>, e[<span class="number">1</span>]<span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 有可能删掉任意边都行，这时优先返回靠后的边，即second</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="number">1</span> == count) <span class="keyword">return</span> edge_second;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> edge_first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若无end，则删除环路中任意一条边都行，按照题意，删除环路中最后出现的那条边</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;e : edges)&#123;</span><br><span class="line">                <span class="comment">// 若将添加的边已经有连接了，则该边可删除</span></span><br><span class="line">                <span class="keyword">if</span>(IsConnect(e[<span class="number">0</span>]<span class="number">-1</span>, e[<span class="number">1</span>]<span class="number">-1</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">                MyUnion(e[<span class="number">0</span>]<span class="number">-1</span>, e[<span class="number">1</span>]<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不会运行到这里</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://leetcode-cn.com/problems/redundant-connection-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/redundant-connection-ii</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用并查集找到一条可以删去的边。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年5月" scheme="http://yoursite.com/categories/2020%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
      <category term="Union Find" scheme="http://yoursite.com/tags/Union-Find/"/>
    
      <category term="Graph" scheme="http://yoursite.com/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>1226. 哲学家进餐</title>
    <link href="http://yoursite.com/2020/05/26/1226.%20%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90/"/>
    <id>http://yoursite.com/2020/05/26/1226. 哲学家进餐/</id>
    <published>2020-05-25T16:05:12.000Z</published>
    <updated>2020-05-26T14:17:26.445Z</updated>
    
    <content type="html"><![CDATA[<p>哲学家就餐问题</p><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>5 个沉默寡言的哲学家围坐在圆桌前，每人面前一盘意面。叉子放在哲学家之间的桌面上。（5 个哲学家，5 根叉子）</p><p>所有的哲学家都只会在思考和进餐两种行为间交替。哲学家只有同时拿到左边和右边的叉子才能吃到面，而同一根叉子在同一时间只能被一个哲学家使用。每个哲学家吃完面后都需要把叉子放回桌面以供其他哲学家吃面。只要条件允许，哲学家可以拿起左边或者右边的叉子，但在没有同时拿到左右叉子时不能进食。</p><p>假设面的数量没有限制，哲学家也能随便吃，不需要考虑吃不吃得下。</p><p>设计一个进餐规则（并行算法）使得每个哲学家都不会挨饿；也就是说，在没有人知道别人什么时候想吃东西或思考的情况下，每个哲学家都可以在吃饭和思考之间一直交替下去。</p><p>哲学家从 0 到 4 按 顺时针 编号。请实现函数</p><pre><code>void wantsToEat(philosopher, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork)：philosopher 哲学家的编号。pickLeftFork 和 pickRightFork 表示拿起左边或右边的叉子。eat 表示吃面。putLeftFork 和 putRightFork 表示放下左边或右边的叉子。</code></pre><p>由于哲学家不是在吃面就是在想着啥时候吃面，所以思考这个方法没有对应的回调。<br>给你 5 个线程，每个都代表一个哲学家，请你使用类的同一个对象来模拟这个过程。在最后一次调用结束之前，可能会为同一个哲学家多次调用该函数。</p><p>示例：</p><pre><code>输入：n = 1输出：[[4,2,1],[4,1,1],[0,1,1],[2,2,1],[2,1,1],[2,0,3],[2,1,2],[2,2,2],[4,0,3],[4,1,2],[0,2,1],[4,2,2],[3,2,1],[3,1,1],[0,0,3],[0,1,2],[0,2,2],[1,2,1],[1,1,1],[3,0,3],[3,1,2],[3,2,2],[1,0,3],[1,1,2],[1,2,2]]</code></pre><p>解释:</p><pre><code>n 表示每个哲学家需要进餐的次数。输出数组描述了叉子的控制和进餐的调用，它的格式如下：output[i] = [a, b, c] (3个整数)- a 哲学家编号。- b 指定叉子：{1 : 左边, 2 : 右边}.- c 指定行为：{1 : 拿起, 2 : 放下, 3 : 吃面}。如 [4,2,1] 表示 4 号哲学家拿起了右边的叉子。</code></pre><p>提示：</p><pre><code>1 &lt;= n &lt;= 60</code></pre><h1 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h1><p>这道题本质上其实是想考察<strong>如何避免死锁</strong>。<br>易知：当 <em>5</em> 个哲学家都拿着其左边(或右边)的叉子时，会进入死锁。</p><p>PS：死锁的 <em>4</em> 个必要条件：</p><ol><li>互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</li><li>请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</li><li>不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。</li><li>循环等待条件: 若干进程间形成首尾相接循环等待资源的关系。</li></ol><p>故<strong>最多</strong>只允许 <em>4</em> 个哲学家去持有叉子，可保证至少有 <em>1</em> 个哲学家能吃上意大利面（即获得到 <em>2</em> 个叉子）。<br>因为最差情况下是：<em>4</em> 个哲学家都各自持有1个叉子，此时还 <strong>剩余 <em>1</em> 个叉子</strong> 可供使用，这 <em>4</em> 个哲学家中必然有1人能获取到这个 <strong>剩余的 <em>1</em> 个叉子</strong>，从而手持 <em>2</em> 个叉子，可以吃意大利面。<br>即：<em>4</em> 个人中，<em>1</em> 个人有 <em>2</em> 个叉子，<em>3</em> 个人各持 <em>1</em> 个叉子，共计 <em>5</em> 个叉子。</p><p>既然<strong>最多</strong>只允许4个哲学家去持有叉子，那么如果只允许3个哲学家去持有叉子是否可行呢？</p><p>当然可行，<em>3</em>个哲学家可以先都各自持有<em>1</em>把叉子，此时还剩余<em>2</em>把叉子；</p><p>当这<em>3</em>个哲学家刚好都相邻(比如：编号为图中的<code>0, 1, 2</code>)，可能会造成只有<em>1</em>个哲学家能吃到意面的情况，具体而言即<code>0</code>号哲学家拿到了其左侧的叉子(编号为<code>1</code>)，<code>1</code>号哲学家也拿到了其左侧的叉子(编号为<code>2</code>)，<code>2</code>号哲学家也拿到了其左侧的叉子(编号为<code>3</code>)，此时只有<code>0</code>号哲学家能拿到其右侧的叉子(编号为<code>0</code>)，因此只有<code>0</code>号哲学家能吃到意面。<br>而其余情况下，<code>3</code>个哲学家中都能有<code>2</code>人吃到意面。<br>即：<em>3</em> 个人中，<em>2</em> 个人各自持有 <em>2</em> 个叉子，<em>1</em> 个人持有 <em>1</em> 个叉子，共计 <em>5</em> 个叉子。</p><p>并且仔细想想，叉子的数目是<strong>固定</strong>的(个数为<code>5</code>)，直觉上来讲<code>3</code>个人去抢<code>5</code>个叉子 比 <code>4</code>个人去抢<code>5</code>个叉子效率高。</p><h1 id="方法一：信号量"><a href="#方法一：信号量" class="headerlink" title="方法一：信号量"></a>方法一：信号量</h1><p>用<code>Semaphore</code>去实现上述的限制：<code>Semaphore eatLimit = new Semaphore(4);</code><br>一共有5个叉子，视为5个<code>ReentrantLock</code>，并将它们全放入1个数组中。</p><p><code>ReentrantLock</code>的使用方法和介绍见我的博文《<strong>1115. 交替打印FooBar</strong>》</p><p>给叉子编号 <em>0, 1, 2, 3, 4</em>（对应数组下标）。<br>具体编号如下图这般设计的：</p><p> <a href="https://pic.leetcode-cn.com/30159b01ce754904bbc76bb81e52cfb5751b074f811ba88919bb3a0b861e02d8-%E5%93%B2%E5%AD%A6%E5%AE%B6%E9%97%AE%E9%A2%98%E5%9B%BE.png" target="_blank" rel="noopener">哲学家问题图.png</a></p><p>有了这些思路，代码实现就变得清晰起来。</p><p>代码具体实现：</p><figure class="highlight java"><figcaption><span>[-方法1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiningPhilosophers</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1个Fork视为1个ReentrantLock，5个叉子即5个ReentrantLock，将其都放入数组中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock[] lockList = &#123;<span class="keyword">new</span> ReentrantLock(),</span><br><span class="line">            <span class="keyword">new</span> ReentrantLock(),</span><br><span class="line">            <span class="keyword">new</span> ReentrantLock(),</span><br><span class="line">            <span class="keyword">new</span> ReentrantLock(),</span><br><span class="line">            <span class="keyword">new</span> ReentrantLock()&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//限制 最多只有4个哲学家去持有叉子</span></span><br><span class="line">    <span class="keyword">private</span> Semaphore eatLimit = <span class="keyword">new</span> Semaphore(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiningPhilosophers</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call the run() method of any runnable to execute its code</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wantsToEat</span><span class="params">(<span class="keyword">int</span> philosopher,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickRightFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable eat,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putRightFork)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftFork = (philosopher + <span class="number">1</span>) % <span class="number">5</span>;    <span class="comment">//左边的叉子 的编号</span></span><br><span class="line">        <span class="keyword">int</span> rightFork = philosopher;    <span class="comment">//右边的叉子 的编号</span></span><br><span class="line"></span><br><span class="line">        eatLimit.acquire();    <span class="comment">//限制的人数 -1</span></span><br><span class="line"></span><br><span class="line">        lockList[leftFork].lock();    <span class="comment">//拿起左边的叉子</span></span><br><span class="line">        lockList[rightFork].lock();    <span class="comment">//拿起右边的叉子</span></span><br><span class="line"></span><br><span class="line">        pickLeftFork.run();    <span class="comment">//拿起左边的叉子 的具体执行</span></span><br><span class="line">        pickRightFork.run();    <span class="comment">//拿起右边的叉子 的具体执行</span></span><br><span class="line"></span><br><span class="line">        eat.run();    <span class="comment">//吃意大利面 的具体执行</span></span><br><span class="line"></span><br><span class="line">        putLeftFork.run();    <span class="comment">//放下左边的叉子 的具体执行</span></span><br><span class="line">        putRightFork.run();    <span class="comment">//放下右边的叉子 的具体执行</span></span><br><span class="line"></span><br><span class="line">        lockList[leftFork].unlock();    <span class="comment">//放下左边的叉子</span></span><br><span class="line">        lockList[rightFork].unlock();    <span class="comment">//放下右边的叉子</span></span><br><span class="line"></span><br><span class="line">        eatLimit.release();<span class="comment">//限制的人数 +1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最多</strong>只允许4个哲学家去持有叉子时</p><pre><code>执行耗时:15 ms,击败了78.39% 的Java用户</code></pre><p>而改为<strong>最多</strong>只允许4，3，2，1个哲学家去持有叉子时</p><pre><code>执行耗时都是14 ms,击败了94.24% 的Java用户</code></pre><p>接下来的2个方法来自作者mike-meng，链接见参考资料【2】，他是用C++实现的，将其转为Java代码如下：</p><h1 id="方法-2："><a href="#方法-2：" class="headerlink" title="方法 2："></a><strong>方法 <em>2</em>：</strong></h1><p>设置 <em>1</em> 个临界区以实现 <em>1</em> 个哲学家 “<strong>同时</strong>”拿起左右  <strong><em>2</em> 把叉子</strong>的效果。<br>即进入临界区之后，保证<strong>成功获取</strong>到左右 <strong><em>2</em> 把叉子</strong> 并 执行相关代码后，才退出临界区。</p><p>评论区看到有题友说方法2就是“只让1个哲学家就餐”的思路，无需将叉子视为<code>ReentrantLock</code>。</p><p>下面也给出了“只允许1个哲学家就餐”的代码。</p><p>但是2者之间还是有<strong>细微</strong>的<strong>差别</strong>：<br>方法2是在成功<strong>拿起左右叉子之后</strong>就退出临界区，而“只让1个哲学家就餐”是在<strong>拿起左右叉子 + 吃意面 + 放下左右叉子</strong> 一套流程走完之后才退出临界区。</p><p>前者的情况可大概分为2种，举具体例子说明(可参照上面给出的图片)：</p><ol><li><code>1</code>号哲学家拿起左右叉子(<code>1</code>号叉子 + <code>2</code>号叉子)后就退出临界区，此时<code>4</code>号哲学家成功挤进临界区，他也成功拿起了左右叉子(<code>0</code>号叉子和<code>4</code>号叉子)，然后就退出临界区。</li><li><code>1</code>号哲学家拿起左右叉子(<code>1</code>号叉子 + <code>2</code>号叉子)后就退出临界区，此时<code>2</code>号哲学家成功挤进临界区，他需要拿起<code>2</code>号叉子和<code>3</code>号叉子，但<code>2</code>号叉子有一定的概率还被<code>1</code>号哲学家持有(<code>1</code>号哲学家意面还没吃完)，因此<code>2</code>号哲学家进入临界区后还需要等待<code>2</code>号叉子。至于<code>3</code>号叉子，根本没其他人跟<code>2</code>号哲学家争夺，因此可以将该种情况视为“<code>2</code>号哲学家只拿起了1只叉子，在等待另1只叉子”的情况。</li></ol><p>总之，第1种情况即<strong>先后进入临界区</strong>的<strong>2位哲学家</strong>的左右叉子不存在竞争情况，因此先后进入临界区的2位哲学家进入临界区后都不用等待叉子，直接就餐。此时可视为2个哲学家在同时就餐(当然前1个哲学家有可能已经吃完了，但姑且当作是2个人同时就餐)。</p><p>第2种情况即先后进入临界区的2位哲学家的左右叉子存在竞争情况(说明这2位哲学家的<strong>编号相邻</strong>)，因此<strong>后进入临界区</strong>的哲学家还需要等待1只叉子，才能就餐。此时可视为只有1个哲学家在就餐。</p><p>至于“只允许1个哲学家就餐”的代码，很好理解，每次严格地只让1个哲学家就餐，由于过于严格，以至于都不需要将叉子视为<code>ReentrantLock</code>。</p><p>方法<code>2</code>有一定的概率是“并行”，“只允许1个哲学家就餐”是严格的“串行”。</p><p>代码如下：</p><figure class="highlight java"><figcaption><span>[-方法2]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiningPhilosophers</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1个Fork视为1个ReentrantLock，5个叉子即5个ReentrantLock，将其都放入数组中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock[] lockList = &#123;<span class="keyword">new</span> ReentrantLock(),</span><br><span class="line">            <span class="keyword">new</span> ReentrantLock(),</span><br><span class="line">            <span class="keyword">new</span> ReentrantLock(),</span><br><span class="line">            <span class="keyword">new</span> ReentrantLock(),</span><br><span class="line">            <span class="keyword">new</span> ReentrantLock()&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//让 1个哲学家可以 “同时”拿起2个叉子(搞个临界区)</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock pickBothForks = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiningPhilosophers</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call the run() method of any runnable to execute its code</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wantsToEat</span><span class="params">(<span class="keyword">int</span> philosopher,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickRightFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable eat,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putRightFork)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftFork = (philosopher + <span class="number">1</span>) % <span class="number">5</span>;    <span class="comment">//左边的叉子 的编号</span></span><br><span class="line">        <span class="keyword">int</span> rightFork = philosopher;    <span class="comment">//右边的叉子 的编号</span></span><br><span class="line"></span><br><span class="line">        pickBothForks.lock();    <span class="comment">//进入临界区</span></span><br><span class="line"></span><br><span class="line">        lockList[leftFork].lock();    <span class="comment">//拿起左边的叉子</span></span><br><span class="line">        lockList[rightFork].lock();    <span class="comment">//拿起右边的叉子</span></span><br><span class="line"></span><br><span class="line">        pickLeftFork.run();    <span class="comment">//拿起左边的叉子 的具体执行</span></span><br><span class="line">        pickRightFork.run();    <span class="comment">//拿起右边的叉子 的具体执行</span></span><br><span class="line"></span><br><span class="line">        pickBothForks.unlock();    <span class="comment">//退出临界区</span></span><br><span class="line"></span><br><span class="line">        eat.run();    <span class="comment">//吃意大利面 的具体执行</span></span><br><span class="line"></span><br><span class="line">        putLeftFork.run();    <span class="comment">//放下左边的叉子 的具体执行</span></span><br><span class="line">        putRightFork.run();    <span class="comment">//放下右边的叉子 的具体执行</span></span><br><span class="line"></span><br><span class="line">        lockList[leftFork].unlock();    <span class="comment">//放下左边的叉子</span></span><br><span class="line">        lockList[rightFork].unlock();    <span class="comment">//放下右边的叉子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[-只允许1个哲学家就餐]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiningPhilosophers</span> </span>&#123;</span><br><span class="line">    <span class="comment">//只允许1个哲学家就餐</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock pickBothForks = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiningPhilosophers</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call the run() method of any runnable to execute its code</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wantsToEat</span><span class="params">(<span class="keyword">int</span> philosopher,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickRightFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable eat,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putRightFork)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftFork = (philosopher + <span class="number">1</span>) % <span class="number">5</span>;    <span class="comment">//左边的叉子 的编号</span></span><br><span class="line">        <span class="keyword">int</span> rightFork = philosopher;    <span class="comment">//右边的叉子 的编号</span></span><br><span class="line"></span><br><span class="line">        pickBothForks.lock();    <span class="comment">//进入临界区</span></span><br><span class="line"></span><br><span class="line">        pickLeftFork.run();    <span class="comment">//拿起左边的叉子 的具体执行</span></span><br><span class="line">        pickRightFork.run();    <span class="comment">//拿起右边的叉子 的具体执行</span></span><br><span class="line"></span><br><span class="line">        eat.run();    <span class="comment">//吃意大利面 的具体执行</span></span><br><span class="line"></span><br><span class="line">        putLeftFork.run();    <span class="comment">//放下左边的叉子 的具体执行</span></span><br><span class="line">        putRightFork.run();    <span class="comment">//放下右边的叉子 的具体执行</span></span><br><span class="line"></span><br><span class="line">        pickBothForks.unlock();    <span class="comment">//退出临界区</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h2><p>  临界资源是一次仅允许一个进程使用的共享资源。各进程采取互斥的方式，实现共享的资源称作临界资源。属于临界资源的硬件有，打印机，磁带机等；软件有消息队列，变量，数组，缓冲区等。诸进程间采取互斥方式，实现对这种资源的共享。</p><h2 id="临界区："><a href="#临界区：" class="headerlink" title="临界区："></a>临界区：</h2><p>  每个进程中访问临界资源的那段代码称为临界区（criticalsection），每次只允许一个进程进入临界区，进入后，不允许其他进程进入。不论是硬件临界资源还是软件临界资源，多个进程必须互斥的对它进行访问。多个进程涉及到同一个临界资源的的临界区称为相关临界区。使用临界区时，一般不允许其运行时间过长，只要运行在临界区的线程还没有离开，其他所有进入此临界区的线程都会被挂起而进入等待状态，并在一定程度上影响程序的运行性能。</p><h1 id="方法-3："><a href="#方法-3：" class="headerlink" title="方法 3："></a><strong>方法 <em>3</em>：</strong></h1><p>前面说过，该题的本质是考察 <strong>如何避免死锁</strong>。<br>而当5个哲学家都<strong>左手持有</strong>其<strong>左边的叉子</strong> 或 当5个哲学家都<strong>右手持有</strong>其<strong>右边的叉子</strong>时，会发生<strong>死锁</strong>。<br>故只需设计1个避免发生上述情况发生的策略即可。</p><p>即可以让<strong>一部分哲学家</strong>优先去获取其左边的叉子，再去获取其右边的叉子；再让<strong>剩余哲学家</strong>优先去获取其右边的叉子，再去获取其左边的叉子。</p><p>代码如下：</p><figure class="highlight java"><figcaption><span>[-方法3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiningPhilosophers</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1个Fork视为1个ReentrantLock，5个叉子即5个ReentrantLock，将其都放入数组中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock[] lockList = &#123;<span class="keyword">new</span> ReentrantLock(),</span><br><span class="line">            <span class="keyword">new</span> ReentrantLock(),</span><br><span class="line">            <span class="keyword">new</span> ReentrantLock(),</span><br><span class="line">            <span class="keyword">new</span> ReentrantLock(),</span><br><span class="line">            <span class="keyword">new</span> ReentrantLock()&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiningPhilosophers</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call the run() method of any runnable to execute its code</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wantsToEat</span><span class="params">(<span class="keyword">int</span> philosopher,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickRightFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable eat,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putRightFork)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftFork = (philosopher + <span class="number">1</span>) % <span class="number">5</span>;    <span class="comment">//左边的叉子 的编号</span></span><br><span class="line">        <span class="keyword">int</span> rightFork = philosopher;    <span class="comment">//右边的叉子 的编号</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//编号为偶数的哲学家，优先拿起左边的叉子，再拿起右边的叉子</span></span><br><span class="line">        <span class="keyword">if</span> (philosopher % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            lockList[leftFork].lock();    <span class="comment">//拿起左边的叉子</span></span><br><span class="line">            lockList[rightFork].lock();    <span class="comment">//拿起右边的叉子</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//编号为奇数的哲学家，优先拿起右边的叉子，再拿起左边的叉子</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            lockList[rightFork].lock();    <span class="comment">//拿起右边的叉子</span></span><br><span class="line">            lockList[leftFork].lock();    <span class="comment">//拿起左边的叉子</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pickLeftFork.run();    <span class="comment">//拿起左边的叉子 的具体执行</span></span><br><span class="line">        pickRightFork.run();    <span class="comment">//拿起右边的叉子 的具体执行</span></span><br><span class="line"></span><br><span class="line">        eat.run();    <span class="comment">//吃意大利面 的具体执行</span></span><br><span class="line"></span><br><span class="line">        putLeftFork.run();    <span class="comment">//放下左边的叉子 的具体执行</span></span><br><span class="line">        putRightFork.run();    <span class="comment">//放下右边的叉子 的具体执行</span></span><br><span class="line"></span><br><span class="line">        lockList[leftFork].unlock();    <span class="comment">//放下左边的叉子</span></span><br><span class="line">        lockList[rightFork].unlock();    <span class="comment">//放下右边的叉子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="改进"><a href="#改进" class="headerlink" title="改进:"></a>改进:</h1><p><strong>位运算</strong>就可以表示<code>5</code>个叉子的<strong>使用状态</strong>，只需用1个<code>volatile</code>修饰的<code>int</code>变量即可 + <code>CAS</code>操作即可。<br>而<code>volatile</code>修饰的<code>int</code>变量 + <code>CAS</code>操作 <code>-&gt;</code> <code>AtomicInteger</code>类</p><figure class="highlight java"><figcaption><span>[-改进的方法1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiningPhilosophers</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化为0, 二进制表示则为00000, 说明当前所有叉子都未被使用</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger fork = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//每个叉子的int值(即二进制的00001, 00010, 00100, 01000, 10000)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] forkMask = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>&#125;;</span><br><span class="line">    <span class="comment">//限制 最多只有4个哲学家去持有叉子</span></span><br><span class="line">    <span class="keyword">private</span> Semaphore eatLimit = <span class="keyword">new</span> Semaphore(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiningPhilosophers</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call the run() method of any runnable to execute its code</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wantsToEat</span><span class="params">(<span class="keyword">int</span> philosopher,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickRightFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable eat,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putRightFork)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftMask = forkMask[(philosopher + <span class="number">1</span>) % <span class="number">5</span>], rightMask = forkMask[philosopher];</span><br><span class="line">        eatLimit.acquire();    <span class="comment">//限制的人数 -1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!pickFork(leftMask)) Thread.sleep(<span class="number">1</span>);    <span class="comment">//拿起左边的叉子</span></span><br><span class="line">        <span class="keyword">while</span> (!pickFork(rightMask)) Thread.sleep(<span class="number">1</span>);   <span class="comment">//拿起右边的叉子</span></span><br><span class="line"></span><br><span class="line">        pickLeftFork.run();    <span class="comment">//拿起左边的叉子 的具体执行</span></span><br><span class="line">        pickRightFork.run();    <span class="comment">//拿起右边的叉子 的具体执行</span></span><br><span class="line"></span><br><span class="line">        eat.run();    <span class="comment">//吃意大利面 的具体执行</span></span><br><span class="line"></span><br><span class="line">        putLeftFork.run();    <span class="comment">//放下左边的叉子 的具体执行</span></span><br><span class="line">        putRightFork.run();    <span class="comment">//放下右边的叉子 的具体执行</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!putFork(leftMask)) Thread.sleep(<span class="number">1</span>);     <span class="comment">//放下左边的叉子</span></span><br><span class="line">        <span class="keyword">while</span> (!putFork(rightMask)) Thread.sleep(<span class="number">1</span>);    <span class="comment">//放下右边的叉子</span></span><br><span class="line"></span><br><span class="line">        eatLimit.release(); <span class="comment">//限制的人数 +1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">pickFork</span><span class="params">(<span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> expect = fork.get();</span><br><span class="line">        <span class="keyword">return</span> (expect &amp; mask) &gt; <span class="number">0</span> ? <span class="keyword">false</span> : fork.compareAndSet(expect, expect ^ mask);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">putFork</span><span class="params">(<span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> expect = fork.get();</span><br><span class="line">        <span class="keyword">return</span> fork.compareAndSet(expect, expect ^ mask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[-改进的方法2]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiningPhilosophers</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化为0, 二进制表示则为00000, 说明当前所有叉子都未被使用</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger fork = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>), both = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//每个叉子的int值(即二进制的00001, 00010, 00100, 01000, 10000)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] forkMask = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiningPhilosophers</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call the run() method of any runnable to execute its code</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wantsToEat</span><span class="params">(<span class="keyword">int</span> philosopher,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickRightFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable eat,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putRightFork)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftMask = forkMask[(philosopher + <span class="number">1</span>) % <span class="number">5</span>], rightMask = forkMask[philosopher];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!both.compareAndSet(<span class="number">0</span>, <span class="number">1</span>)) Thread.sleep(<span class="number">1</span>);     <span class="comment">//进入临界区</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!pickFork(leftMask)) Thread.sleep(<span class="number">1</span>);    <span class="comment">//拿起左边的叉子</span></span><br><span class="line">        <span class="keyword">while</span> (!pickFork(rightMask)) Thread.sleep(<span class="number">1</span>);   <span class="comment">//拿起右边的叉子</span></span><br><span class="line"></span><br><span class="line">        pickLeftFork.run();    <span class="comment">//拿起左边的叉子 的具体执行</span></span><br><span class="line">        pickRightFork.run();    <span class="comment">//拿起右边的叉子 的具体执行</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!both.compareAndSet(<span class="number">1</span>, <span class="number">0</span>)) Thread.sleep(<span class="number">1</span>);    <span class="comment">//退出临界区</span></span><br><span class="line"></span><br><span class="line">        eat.run();    <span class="comment">//吃意大利面 的具体执行</span></span><br><span class="line"></span><br><span class="line">        putLeftFork.run();    <span class="comment">//放下左边的叉子 的具体执行</span></span><br><span class="line">        putRightFork.run();    <span class="comment">//放下右边的叉子 的具体执行</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!putFork(rightMask)) Thread.sleep(<span class="number">1</span>);   <span class="comment">//放下右边的叉子</span></span><br><span class="line">        <span class="keyword">while</span> (!putFork(leftMask)) Thread.sleep(<span class="number">1</span>);    <span class="comment">//放下左边的叉子</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">pickFork</span><span class="params">(<span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> expect = fork.get();</span><br><span class="line">        <span class="keyword">return</span> (expect &amp; mask) &gt; <span class="number">0</span> ? <span class="keyword">false</span> : fork.compareAndSet(expect, expect ^ mask);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">putFork</span><span class="params">(<span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> expect = fork.get();</span><br><span class="line">        <span class="keyword">return</span> fork.compareAndSet(expect, expect ^ mask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[-改进的方法3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiningPhilosophers</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化为0, 二进制表示则为00000, 说明当前所有叉子都未被使用</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger fork = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//每个叉子的int值(即二进制的00001, 00010, 00100, 01000, 10000)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] forkMask = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiningPhilosophers</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call the run() method of any runnable to execute its code</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wantsToEat</span><span class="params">(<span class="keyword">int</span> philosopher,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickRightFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable eat,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putRightFork)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftMask = forkMask[(philosopher + <span class="number">1</span>) % <span class="number">5</span>], rightMask = forkMask[philosopher];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//编号为偶数的哲学家，优先拿起左边的叉子，再拿起右边的叉子</span></span><br><span class="line">        <span class="keyword">if</span> (philosopher % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!pickFork(leftMask)) Thread.sleep(<span class="number">1</span>);     <span class="comment">//拿起左边的叉子</span></span><br><span class="line">            <span class="keyword">while</span> (!pickFork(rightMask)) Thread.sleep(<span class="number">1</span>);    <span class="comment">//拿起右边的叉子</span></span><br><span class="line">        &#125;<span class="comment">//编号为奇数的哲学家，优先拿起右边的叉子，再拿起左边的叉子</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!pickFork(rightMask)) Thread.sleep(<span class="number">1</span>);    <span class="comment">//拿起右边的叉子</span></span><br><span class="line">            <span class="keyword">while</span> (!pickFork(leftMask)) Thread.sleep(<span class="number">1</span>);     <span class="comment">//拿起左边的叉子</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pickLeftFork.run();    <span class="comment">//拿起左边的叉子 的具体执行</span></span><br><span class="line">        pickRightFork.run();    <span class="comment">//拿起右边的叉子 的具体执行</span></span><br><span class="line"></span><br><span class="line">        eat.run();    <span class="comment">//吃意大利面 的具体执行</span></span><br><span class="line"></span><br><span class="line">        putLeftFork.run();    <span class="comment">//放下左边的叉子 的具体执行</span></span><br><span class="line">        putRightFork.run();    <span class="comment">//放下右边的叉子 的具体执行</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!putFork(rightMask)) Thread.sleep(<span class="number">1</span>);    <span class="comment">//放下右边的叉子</span></span><br><span class="line">        <span class="keyword">while</span> (!putFork(leftMask)) Thread.sleep(<span class="number">1</span>);     <span class="comment">//放下左边的叉子</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">pickFork</span><span class="params">(<span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> expect = fork.get();</span><br><span class="line">        <span class="keyword">return</span> (expect &amp; mask) &gt; <span class="number">0</span> ? <span class="keyword">false</span> : fork.compareAndSet(expect, expect ^ mask);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">putFork</span><span class="params">(<span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> expect = fork.get();</span><br><span class="line">        <span class="keyword">return</span> fork.compareAndSet(expect, expect ^ mask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://leetcode-cn.com/problems/the-dining-philosophers" target="_blank" rel="noopener">https://leetcode-cn.com/problems/the-dining-philosophers</a></p><p>【2】<a href="https://leetcode-cn.com/problems/the-dining-philosophers/solution/zhe-xue-jia-jiu-can-wen-ti-by-mike-meng" target="_blank" rel="noopener">https://leetcode-cn.com/problems/the-dining-philosophers/solution/zhe-xue-jia-jiu-can-wen-ti-by-mike-meng</a></p><p>【3】<a href="https://blog.csdn.net/u013272948/java/article/details/53929572" target="_blank" rel="noopener">https://blog.csdn.net/u013272948/java/article/details/53929572</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;哲学家就餐问题&lt;/p&gt;
    
    </summary>
    
      <category term="2020年5月" scheme="http://yoursite.com/categories/2020%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Concurrency" scheme="http://yoursite.com/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>1195. 交替打印字符串</title>
    <link href="http://yoursite.com/2020/05/24/1195.%20%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://yoursite.com/2020/05/24/1195. 交替打印字符串/</id>
    <published>2020-05-24T15:23:12.000Z</published>
    <updated>2020-05-25T15:49:04.282Z</updated>
    
    <content type="html"><![CDATA[<p>编写一个可以从 1 到 n 输出代表这个数字的字符串的程序</p><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>编写一个可以从 1 到 n 输出代表这个数字的字符串的程序，但是：</p><pre><code>如果这个数字可以被 3 整除，输出 &quot;fizz&quot;。如果这个数字可以被 5 整除，输出 &quot;buzz&quot;。如果这个数字可以同时被 3 和 5 整除，输出 &quot;fizzbuzz&quot;。</code></pre><p>例如，当 n = 15，输出：</p><pre><code>1, 2, fizz, 4, buzz, fizz, 7, 8, fizz, buzz, 11, fizz, 13, 14, fizzbuzz。</code></pre><p>假设有这么一个类：</p><pre><code>class FizzBuzz {  public FizzBuzz(int n) { ... }               // constructor  public void fizz(printFizz) { ... }          // only output &quot;fizz&quot;  public void buzz(printBuzz) { ... }          // only output &quot;buzz&quot;  public void fizzbuzz(printFizzBuzz) { ... }  // only output &quot;fizzbuzz&quot;  public void number(printNumber) { ... }      // only output the numbers}</code></pre><p>请你实现一个有四个线程的多线程版  FizzBuzz， 同一个 FizzBuzz 实例会被如下四个线程使用：</p><pre><code>线程A将调用 fizz() 来判断是否能被 3 整除，如果可以，则输出 fizz。线程B将调用 buzz() 来判断是否能被 5 整除，如果可以，则输出 buzz。线程C将调用 fizzbuzz() 来判断是否同时能被 3 和 5 整除，如果可以，则输出 fizzbuzz。线程D将调用 number() 来实现输出既不能被 3 整除也不能被 5 整除的数字。</code></pre><h1 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h1><ol><li>凡是可以用semaphore解决的问题，大多都可以使用管程（也就是lock）来解决，但使用lock需要增加一个变量来标记起始条件</li><li>凡是可以使用多个condition可以解决的问题，都可以使用一个condition和一个volatile变量来解决</li></ol><h1 id="方法一：信号量Semaphore"><a href="#方法一：信号量Semaphore" class="headerlink" title="方法一：信号量Semaphore"></a>方法一：信号量Semaphore</h1><p>很容易可以想到使用信号量的方法来解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintFizzBuzz</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrintFizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Semaphore fSema = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> Semaphore bSema = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> Semaphore fbSema = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> Semaphore nSema = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * use semaphore</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> printFizz</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// printFizz.run() outputs "fizz".</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizz</span><span class="params">(Runnable printFizz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i = i + <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">5</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                fSema.acquire();</span><br><span class="line">                printFizz.run();</span><br><span class="line">                nSema.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printBuzz.run() outputs "buzz".</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buzz</span><span class="params">(Runnable printBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &lt;= n; i = i + <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">3</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                bSema.acquire();</span><br><span class="line">                printBuzz.run();</span><br><span class="line">                nSema.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printFizzBuzz.run() outputs "fizzbuzz".</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizzbuzz</span><span class="params">(Runnable printFizzBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">15</span>; i &lt;= n; i = i + <span class="number">15</span>) &#123;</span><br><span class="line">            fbSema.acquire();</span><br><span class="line">            printFizzBuzz.run();</span><br><span class="line">            nSema.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printNumber.accept(x) outputs "x", where x is an integer.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">number</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            nSema.acquire();</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; i % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                fbSema.release();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                fSema.release();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                bSema.release();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                printNumber.accept(i);</span><br><span class="line">                nSema.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的一点是<strong>如果不在fizz和buzz方法中加入对15的余数判断就会使得线程执行混乱</strong>，本地运行结果：Time Limit Exceeded</p><p>只需将n改到30即可打印看到执行情况，即使在else if中已经做了情况区分仍然会出错。这其中的原因可以本地调试来深究。</p><h1 id="方案二：Lock"><a href="#方案二：Lock" class="headerlink" title="方案二：Lock"></a>方案二：Lock</h1><p>lock的方案使用了多个condition，这其实也是可以使用一个condition外加一个volatile变量来实现的</p><h2 id="Condition的用法"><a href="#Condition的用法" class="headerlink" title="Condition的用法"></a>Condition的用法</h2><p>Condition是在java 1.5中才出现的，它用来替代传统的Object的wait()、notify()实现线程间的协作，相比使用Object的wait()、notify()，使用Condition的await()、signal()这种方式实现线程间协作更加安全和高效。因此通常来说比较推荐使用Condition，阻塞队列实际上是使用了Condition来模拟线程间协作。</p><p>Condition是个接口，基本的方法就是await()和signal()方法；</p><p>Condition依赖于Lock接口，生成一个Condition的基本代码是lock.newCondition() </p><p> 调用Condition的await()和signal()方法，都必须在lock保护之内，就是说必须在lock.lock()和lock.unlock之间才可以使用</p><pre><code>Conditon中的await()对应Object的wait()；Condition中的signal()对应Object的notify()；Condition中的signalAll()对应Object的notifyAll()。</code></pre><p> condition可以通俗的理解为条件队列。当一个线程在调用了await方法以后，直到线程等待的某个条件为真的时候才会被唤醒。这种方式为线程提供了更加简单的等待/通知模式。Condition必须要配合锁一起使用，因为对共享状态变量的访问发生在多线程环境下。一个Condition的实例必须与一个Lock绑定，因此Condition一般都是作为Lock的内部实现。</p><pre><code>await() ：造成当前线程在接到信号或被中断之前一直处于等待状态。await(long time, TimeUnit unit) ：造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态awaitNanos(long nanosTimeout) ：造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。返回值表示剩余时间，如果在nanosTimesout之前唤醒，那么返回值 = nanosTimeout - 消耗时间，如果返回值 &lt;= 0 ,则可以认定它已经超时了。awaitUninterruptibly() ：造成当前线程在接到信号之前一直处于等待状态。【注意：该方法对中断不敏感】。awaitUntil(Date deadline) ：造成当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态。如果没有到指定时间就被通知，则返回true，否则表示到了指定时间，返回返回false。signal() ：唤醒一个等待线程。该线程从等待方法返回前必须获得与Condition相关的锁。signal()All ：唤醒所有等待线程。能够从等待方法返回的线程必须获得与Condition相关的锁。</code></pre><p>更多源码分析详见<a href="https://blog.csdn.net/bohu83/java/article/details/51098106" target="_blank" rel="noopener">java condition使用及分析</a></p><p>使用Lock和Condition来解决本题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintFizzBuzz</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrintFizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition fCond = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition bCond = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition fbCond = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition nCond = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Boolean state = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * use lock</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> printFizz</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// printFizz.run() outputs "fizz".</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizz</span><span class="params">(Runnable printFizz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i = i + <span class="number">3</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">5</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (!state) &#123;</span><br><span class="line">                        fCond.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    printFizz.run();</span><br><span class="line">                    state = <span class="keyword">false</span>;</span><br><span class="line">                    nCond.signal();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printBuzz.run() outputs "buzz".</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buzz</span><span class="params">(Runnable printBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &lt;= n; i = i + <span class="number">5</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">3</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (!state) &#123;</span><br><span class="line">                        bCond.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    printBuzz.run();</span><br><span class="line">                    state = <span class="keyword">false</span>;</span><br><span class="line">                    nCond.signal();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printFizzBuzz.run() outputs "fizzbuzz".</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizzbuzz</span><span class="params">(Runnable printFizzBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">15</span>; i &lt;= n; i = i + <span class="number">15</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!state) &#123;</span><br><span class="line">                    fbCond.await();</span><br><span class="line">                &#125;</span><br><span class="line">                printFizzBuzz.run();</span><br><span class="line">                state = <span class="keyword">false</span>;</span><br><span class="line">                nCond.signal();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printNumber.accept(x) outputs "x", where x is an integer.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">number</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (state) &#123;</span><br><span class="line">                    nCond.await();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; i % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    fbCond.signal();</span><br><span class="line">                    state = <span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    fCond.signal();</span><br><span class="line">                    state = <span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    bCond.signal();</span><br><span class="line">                    state = <span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    printNumber.accept(i);</span><br><span class="line">                    nCond.signal();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrintFizzBuzz pfb = <span class="keyword">new</span> PrintFizzBuzz(<span class="number">15</span>);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pfb.fizz(() -&gt; System.out.print(<span class="string">"fizz"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pfb.buzz(() -&gt; System.out.print(<span class="string">"buzz"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pfb.fizzbuzz(() -&gt; System.out.print(<span class="string">"fizzbuzz"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t4 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pfb.number(value -&gt; System.out.print(value));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方案三：AtomicInteger"><a href="#方案三：AtomicInteger" class="headerlink" title="方案三：AtomicInteger"></a>方案三：AtomicInteger</h1><p>使用AtomicInteger时，使用了while及LockSupport来完成线程等待。</p><h2 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h2><p>LockSupport是一个线程阻塞工具类，所有的方法都是静态方法，可以让线程在任意位置阻塞。</p><pre><code>public static void park(Object blocker); // 暂停当前线程public static void parkNanos(Object blocker, long nanos); // 暂停当前线程，不过有超时时间的限制public static void parkUntil(Object blocker, long deadline); // 暂停当前线程，直到某个时间public static void park(); // 无期限暂停当前线程public static void parkNanos(long nanos); // 暂停当前线程，不过有超时时间的限制public static void parkUntil(long deadline); // 暂停当前线程，直到某个时间public static void unpark(Thread thread); // 恢复当前线程public static Object getBlocker(Thread t);</code></pre><p>park和unpark可以实现类似wait和notify的功能，但是并不和wait和notify交叉，也就是说unpark不会对wait起作用，notify也不会对park起作用。</p><p>park和unpark的使用不会出现死锁的情况</p><p>更多用法参见<a href="https://www.jianshu.com/p/f1f2cd289205" target="_blank" rel="noopener">LockSupport的用法及原理</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FizzBuzz</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Initialize the flag.</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger state = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// The current number.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> curNum = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printFizz.run() outputs "fizz".</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizz</span><span class="params">(Runnable printFizz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">            <span class="comment">// Update the current state using CAS in orde to run the logic exclusively.</span></span><br><span class="line">            <span class="keyword">while</span> (!<span class="keyword">this</span>.state.compareAndSet(<span class="number">1</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="comment">// Alleviate the busy spin.</span></span><br><span class="line">                LockSupport.parkNanos(<span class="number">1L</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.curNum &gt; n) &#123;</span><br><span class="line">                <span class="comment">// Reset the state before return, then other waiting threads can terminate.</span></span><br><span class="line">                <span class="keyword">this</span>.state.set(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">this</span>.curNum % <span class="number">3</span> == <span class="number">0</span>) &amp;&amp; (<span class="keyword">this</span>.curNum % <span class="number">5</span> != <span class="number">0</span>)) &#123;</span><br><span class="line">                printFizz.run();    </span><br><span class="line">                <span class="keyword">this</span>.curNum++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">this</span>.state.set(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printBuzz.run() outputs "buzz".</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buzz</span><span class="params">(Runnable printBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;            </span><br><span class="line">            <span class="keyword">while</span> (!<span class="keyword">this</span>.state.compareAndSet(<span class="number">1</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">                LockSupport.parkNanos(<span class="number">1L</span>);</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.curNum &gt; n) &#123;    </span><br><span class="line">                <span class="keyword">this</span>.state.set(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">this</span>.curNum % <span class="number">3</span> != <span class="number">0</span>) &amp;&amp; (<span class="keyword">this</span>.curNum % <span class="number">5</span> == <span class="number">0</span>)) &#123;</span><br><span class="line">                printBuzz.run();</span><br><span class="line">                <span class="keyword">this</span>.curNum++;    </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">this</span>.state.set(<span class="number">1</span>);   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printFizzBuzz.run() outputs "fizzbuzz".</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizzbuzz</span><span class="params">(Runnable printFizzBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!<span class="keyword">this</span>.state.compareAndSet(<span class="number">1</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">                LockSupport.parkNanos(<span class="number">1L</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.curNum &gt; n) &#123;</span><br><span class="line">                <span class="keyword">this</span>.state.set(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">this</span>.curNum % <span class="number">3</span> == <span class="number">0</span>) &amp;&amp; (<span class="keyword">this</span>.curNum % <span class="number">5</span> == <span class="number">0</span>)) &#123;    </span><br><span class="line">                printFizzBuzz.run();    </span><br><span class="line">                <span class="keyword">this</span>.curNum++;    </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">this</span>.state.set(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printNumber.accept(x) outputs "x", where x is an integer.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">number</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!<span class="keyword">this</span>.state.compareAndSet(<span class="number">1</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">                LockSupport.parkNanos(<span class="number">1L</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.curNum &gt; n) &#123;    </span><br><span class="line">                <span class="keyword">this</span>.state.set(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                    </span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">this</span>.curNum % <span class="number">3</span> != <span class="number">0</span>) &amp;&amp; (<span class="keyword">this</span>.curNum % <span class="number">5</span> != <span class="number">0</span>)) &#123;    </span><br><span class="line">                printNumber.accept(<span class="keyword">this</span>.curNum);  </span><br><span class="line">                <span class="keyword">this</span>.curNum++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">this</span>.state.set(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://leetcode-cn.com/problems/fizz-buzz-multithreaded" target="_blank" rel="noopener">https://leetcode-cn.com/problems/fizz-buzz-multithreaded</a></p><p>【2】<a href="https://blog.csdn.net/bohu83/java/article/details/51098106" target="_blank" rel="noopener">https://blog.csdn.net/bohu83/java/article/details/51098106</a></p><p>【3】<a href="https://www.jianshu.com/p/f1f2cd289205" target="_blank" rel="noopener">https://www.jianshu.com/p/f1f2cd289205</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写一个可以从 1 到 n 输出代表这个数字的字符串的程序&lt;/p&gt;
    
    </summary>
    
      <category term="2020年5月" scheme="http://yoursite.com/categories/2020%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Concurrency" scheme="http://yoursite.com/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>1117. H2O 生成</title>
    <link href="http://yoursite.com/2020/05/24/1117.%20H2O%20%E7%94%9F%E6%88%90/"/>
    <id>http://yoursite.com/2020/05/24/1117. H2O 生成/</id>
    <published>2020-05-24T14:16:12.000Z</published>
    <updated>2020-05-24T15:07:36.341Z</updated>
    
    <content type="html"><![CDATA[<p>使线程三三成组突破屏障并能立即组合产生一个水分子</p><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>现在有两种线程，氢 oxygen 和氧 hydrogen，你的目标是组织这两种线程来产生水分子。</p><p>存在一个屏障（barrier）使得每个线程必须等候直到一个完整水分子能够被产生出来。</p><p>氢和氧线程会被分别给予 releaseHydrogen 和 releaseOxygen 方法来允许它们突破屏障。</p><p>这些线程应该三三成组突破屏障并能立即组合产生一个水分子。</p><p>你必须保证产生一个水分子所需线程的结合必须发生在下一个水分子产生之前。</p><p>换句话说:</p><p>如果一个氧线程到达屏障时没有氢线程到达，它必须等候直到两个氢线程到达。<br>如果一个氢线程到达屏障时没有其它线程到达，它必须等候直到一个氧线程和另一个氢线程到达。<br>书写满足这些限制条件的氢、氧线程同步代码。</p><p>示例 1:</p><pre><code>输入: &quot;HOH&quot;输出: &quot;HHO&quot;解释: &quot;HOH&quot; 和 &quot;OHH&quot; 依然都是有效解。</code></pre><p>示例 2:</p><pre><code>输入: &quot;OOHHHH&quot;输出: &quot;HHOHHO&quot;解释: &quot;HOHHHO&quot;, &quot;OHHHHO&quot;, &quot;HHOHOH&quot;, &quot;HOHHOH&quot;, &quot;OHHHOH&quot;, &quot;HHOOHH&quot;, &quot;HOHOHH&quot; 和 &quot;OHHOHH&quot; 依然都是有效解。</code></pre><p>限制条件:</p><pre><code>输入字符串的总长将会是 3n, 1 ≤ n ≤ 50；输入字符串中的 “H” 总数将会是 2n；输入字符串中的 “O” 总数将会是 n。</code></pre><h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><p>h每获取一次释放一个o许可，o每次获取两个许可（即2次h后执行一次o）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">H2O</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Semaphore h = <span class="keyword">new</span> Semaphore(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">private</span> Semaphore o = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">H2O</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hydrogen</span><span class="params">(Runnable releaseHydrogen)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">h.acquire();</span><br><span class="line">        <span class="comment">// releaseHydrogen.run() outputs "H". Do not change or remove this line.</span></span><br><span class="line">        releaseHydrogen.run();</span><br><span class="line">        o.release();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oxygen</span><span class="params">(Runnable releaseOxygen)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        o.acquire(<span class="number">2</span>); <span class="comment">//2次h后执行一次o</span></span><br><span class="line">        <span class="comment">// releaseOxygen.run() outputs "O". Do not change or remove this line.</span></span><br><span class="line">releaseOxygen.run();</span><br><span class="line">h.release(<span class="number">2</span>);<span class="comment">//一次o后执行2次h</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ReentrantLock-Condition"><a href="#ReentrantLock-Condition" class="headerlink" title="ReentrantLock+Condition"></a>ReentrantLock+Condition</h1><p>Condition用法参见<a href="https://www.jianshu.com/p/be2dc7c878dc" target="_blank" rel="noopener">java并发编程之Condition</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">H2O</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition hCondition = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition oCondition = lock.newCondition();</span><br><span class="line">    <span class="comment">//前2位代表氢元素的个数,第3位代表氧元素的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> h2o = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">H2O</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hydrogen</span><span class="params">(Runnable releaseHydrogen)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="comment">//00(0个H元素) 01(1个H元素) 11(2个H元素)</span></span><br><span class="line">        <span class="comment">//((h2o &amp; 3) == 3)表示H元素已经到了2个</span></span><br><span class="line">        <span class="keyword">while</span>((h2o &amp; <span class="number">3</span>) == <span class="number">3</span>) &#123;</span><br><span class="line">            hCondition.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// releaseHydrogen.run() outputs "H". Do not change or remove this line.</span></span><br><span class="line">        releaseHydrogen.run();</span><br><span class="line">        <span class="comment">//==0代表没有1个氢元素,否则一定会有1个氢元素</span></span><br><span class="line">        h2o += ((h2o &amp; <span class="number">3</span>) == <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//水分子已经生成</span></span><br><span class="line">        <span class="keyword">if</span>(h2o == <span class="number">7</span>)&#123;</span><br><span class="line">            h2o = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//唤醒一个氧线程</span></span><br><span class="line">        oCondition.signal();</span><br><span class="line">        <span class="comment">//如果((h2o &amp; 3) == 3)表示氢线程不需要再唤醒了</span></span><br><span class="line">        <span class="keyword">if</span>((h2o &amp; <span class="number">3</span>) != <span class="number">3</span>)&#123;</span><br><span class="line">            hCondition.signal();</span><br><span class="line">        &#125;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oxygen</span><span class="params">(Runnable releaseOxygen)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="comment">//((h2o &amp; 4) == 4)表示O元素已经到了1个</span></span><br><span class="line">        <span class="keyword">while</span>((h2o &amp; <span class="number">4</span>)==<span class="number">4</span>)&#123;</span><br><span class="line">            oCondition.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// releaseOxygen.run() outputs "O". Do not change or remove this line.</span></span><br><span class="line">releaseOxygen.run();</span><br><span class="line">        h2o += <span class="number">4</span>;</span><br><span class="line">        <span class="comment">//水分子已经生成</span></span><br><span class="line">        <span class="keyword">if</span>(h2o == <span class="number">7</span>)&#123;</span><br><span class="line">            h2o = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为只需要1个氧元素,所以这里只需要唤醒氢线程就可以了</span></span><br><span class="line">        hCondition.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Semaphore-CyclicBarrier"><a href="#Semaphore-CyclicBarrier" class="headerlink" title="Semaphore+CyclicBarrier"></a>Semaphore+CyclicBarrier</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">H2O</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore hSem = <span class="keyword">new</span> Semaphore(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore oSem = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">H2O</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hydrogen</span><span class="params">(Runnable releaseHydrogen)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        hSem.acquire();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            barrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// releaseHydrogen.run() outputs "H". Do not change or remove this line.</span></span><br><span class="line">        releaseHydrogen.run();</span><br><span class="line">        hSem.release();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oxygen</span><span class="params">(Runnable releaseOxygen)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        oSem.acquire();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            barrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// releaseOxygen.run() outputs "H". Do not change or remove this line.</span></span><br><span class="line">        releaseOxygen.run();</span><br><span class="line">        oSem.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://leetcode-cn.com/problems/building-h2o" target="_blank" rel="noopener">https://leetcode-cn.com/problems/building-h2o</a></p><p>【2】<a href="https://www.jianshu.com/p/be2dc7c878dc" target="_blank" rel="noopener">https://www.jianshu.com/p/be2dc7c878dc</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使线程三三成组突破屏障并能立即组合产生一个水分子&lt;/p&gt;
    
    </summary>
    
      <category term="2020年5月" scheme="http://yoursite.com/categories/2020%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Concurrency" scheme="http://yoursite.com/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>1116. 打印零与奇偶数</title>
    <link href="http://yoursite.com/2020/05/24/1116.%20%E6%89%93%E5%8D%B0%E9%9B%B6%E4%B8%8E%E5%A5%87%E5%81%B6%E6%95%B0/"/>
    <id>http://yoursite.com/2020/05/24/1116. 打印零与奇偶数/</id>
    <published>2020-05-24T14:01:12.000Z</published>
    <updated>2020-05-24T14:31:09.699Z</updated>
    
    <content type="html"><![CDATA[<p>按顺序交替调用三个线程</p><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>假设有这么一个类：</p><pre><code>class ZeroEvenOdd {  public ZeroEvenOdd(int n) { ... }      // 构造函数  public void zero(printNumber) { ... }  // 仅打印出 0  public void even(printNumber) { ... }  // 仅打印出 偶数  public void odd(printNumber) { ... }   // 仅打印出 奇数}</code></pre><p>相同的一个 ZeroEvenOdd 类实例将会传递给三个不同的线程：</p><pre><code>线程 A 将调用 zero()，它只输出 0 。线程 B 将调用 even()，它只输出偶数。线程 C 将调用 odd()，它只输出奇数。</code></pre><p>每个线程都有一个 printNumber 方法来输出一个整数。请修改给出的代码以输出整数序列 010203040506… ，其中序列的长度必须为 2n。</p><p>示例 1：</p><pre><code>输入：n = 2输出：&quot;0102&quot;说明：三条线程异步执行，其中一个调用 zero()，另一个线程调用 even()，最后一个线程调用odd()。正确的输出为 &quot;0102&quot;。</code></pre><p>示例 2：</p><pre><code>输入：n = 5输出：&quot;0102030405&quot;</code></pre><h1 id="方法一：信号量"><a href="#方法一：信号量" class="headerlink" title="方法一：信号量"></a>方法一：信号量</h1><p>由1115. 交替打印FooBar中的方法很容易想到<br>通过三个信号量来控制。</p><p>zero方法中的for表示要输出的0个次数，同时用来控制要唤醒偶数还是奇数方法</p><p>even方法用来输出偶数同时唤醒zero方法。</p><p>odd方法用来输出奇数同时唤醒zero方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.function.IntConsumer;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZeroEvenOdd</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    Semaphore zero = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">    Semaphore even = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    Semaphore odd = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZeroEvenOdd</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printNumber.accept(x) outputs "x", where x is an integer.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zero</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            zero.acquire();</span><br><span class="line">            printNumber.accept(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                odd.release();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                even.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">even</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i=i+<span class="number">2</span>) &#123;</span><br><span class="line">            even.acquire();</span><br><span class="line">            printNumber.accept(i);</span><br><span class="line">            zero.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">odd</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n ; i=i+<span class="number">2</span>) &#123;</span><br><span class="line">            odd.acquire();</span><br><span class="line">            printNumber.accept(i);</span><br><span class="line">            zero.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ZeroEvenOdd zeroEvenOdd = <span class="keyword">new</span> ZeroEvenOdd(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zeroEvenOdd.zero(System.out::print);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zeroEvenOdd.even(System.out::print);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zeroEvenOdd.odd(System.out::print);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法二：Lock"><a href="#方法二：Lock" class="headerlink" title="方法二：Lock"></a>方法二：Lock</h1><p>“凡是可以用信号量解决的问题，都可以用管程模型来解决”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZeroEvenOdd</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZeroEvenOdd</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Condition z = lock.newCondition();</span><br><span class="line">    Condition num = lock.newCondition();</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> zTurn = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> zIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zero</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;zIndex&lt;n;) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(!zTurn) &#123;</span><br><span class="line">        z.await();</span><br><span class="line">        &#125;</span><br><span class="line">        printNumber.accept(<span class="number">0</span>);</span><br><span class="line">        zTurn = <span class="keyword">false</span>;</span><br><span class="line">        num.signalAll();</span><br><span class="line">                zIndex++;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">even</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i+=<span class="number">2</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(zTurn || (zIndex&amp;<span class="number">1</span>)==<span class="number">1</span>) &#123;</span><br><span class="line">        num.await();</span><br><span class="line">        &#125;</span><br><span class="line">        printNumber.accept(i);</span><br><span class="line">        zTurn = <span class="keyword">true</span>;</span><br><span class="line">        z.signal();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">odd</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i+=<span class="number">2</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(zTurn || (zIndex&amp;<span class="number">1</span>)==<span class="number">0</span>) &#123;</span><br><span class="line">        num.await();</span><br><span class="line">        &#125;</span><br><span class="line">        printNumber.accept(i);</span><br><span class="line">        zTurn = <span class="keyword">true</span>;</span><br><span class="line">        z.signal();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法三：无锁"><a href="#方法三：无锁" class="headerlink" title="方法三：无锁"></a>方法三：无锁</h1><p>凡是用了锁的，都来试试可否变成无锁的（本机测试是可行的，但测评平台报超时）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZeroEvenOdd</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZeroEvenOdd</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> stage = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zero</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(stage&gt;<span class="number">0</span>);</span><br><span class="line">    printNumber.accept(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>((i&amp;<span class="number">1</span>)==<span class="number">0</span>) &#123;</span><br><span class="line">    stage = <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    stage = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">even</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i+=<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(stage!=<span class="number">2</span>);</span><br><span class="line">    printNumber.accept(i);</span><br><span class="line">    stage = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">odd</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i+=<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(stage!=<span class="number">1</span>);</span><br><span class="line">    printNumber.accept(i);</span><br><span class="line">    stage = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://leetcode-cn.com/problems/print-zero-even-odd/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/print-zero-even-odd/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;按顺序交替调用三个线程&lt;/p&gt;
    
    </summary>
    
      <category term="2020年5月" scheme="http://yoursite.com/categories/2020%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Concurrency" scheme="http://yoursite.com/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>1115. 交替打印FooBar</title>
    <link href="http://yoursite.com/2020/05/22/1115.%20%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0FooBar/"/>
    <id>http://yoursite.com/2020/05/22/1115. 交替打印FooBar/</id>
    <published>2020-05-22T14:32:12.000Z</published>
    <updated>2020-05-23T04:30:31.185Z</updated>
    
    <content type="html"><![CDATA[<p>两个不同的线程将会共用一个 FooBar 实例。其中一个线程将会调用 foo() 方法，另一个线程将会调用 bar() 方法.设计修改程序交替调用这两个方法。</p><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>我们提供一个类：</p><pre><code>class FooBar {  public void foo() {    for (int i = 0; i &lt; n; i++) {      print(&quot;foo&quot;);    }  }  public void bar() {    for (int i = 0; i &lt; n; i++) {      print(&quot;bar&quot;);    }  }}</code></pre><p>两个不同的线程将会共用一个 FooBar 实例。其中一个线程将会调用 foo() 方法，另一个线程将会调用 bar() 方法。</p><p>请设计修改程序，以确保 “foobar” 被输出 n 次。</p><p>示例 1:</p><pre><code>输入: n = 1输出: &quot;foobar&quot;解释: 这里有两个线程被异步启动。其中一个调用 foo() 方法, 另一个调用 bar() 方法，&quot;foobar&quot; 将被输出一次。</code></pre><p>示例 2:</p><pre><code>输入: n = 2输出: &quot;foobarfoobar&quot;解释: &quot;foobar&quot; 将被输出两次。</code></pre><h1 id="方案一：Semaphore"><a href="#方案一：Semaphore" class="headerlink" title="方案一：Semaphore"></a>方案一：Semaphore</h1><p>很容易想到这种类似红绿灯交替变换的情境，一开始尝试用两个AtomicBoolean值来控制两个方法轮流调用，但发现难以在循环情况下运行，因此考虑使用信号量：</p><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>为了防止出现因多个程序同时访问一个共享资源而引发的一系列问题，我们需要一种方法，它可以通过生成并使用令牌来授权，在任一时刻只能有一个执行线程访问代码的临界区域。临界区域是指执行数据更新的代码需要独占式地执行。而信号量就可以提供这样的一种访问机制，让一个临界区同一时间只有一个线程在访问它，也就是说信号量是用来调协进程对共享资源的访问的。</p><p>信号量是一个特殊的变量，程序对其访问都是原子操作，且只允许对它进行等待（即P(信号变量))和发送（即V(信号变量))信息操作。</p><p>最简单的信号量是只能取0和1的变量，这也是信号量最常见的一种形式，叫做二进制信号量。而可以取多个正整数的信号量被称为通用信号量。这里主要讨论二进制信号量。</p><h2 id="信号量的工作原理"><a href="#信号量的工作原理" class="headerlink" title="信号量的工作原理"></a>信号量的工作原理</h2><p>由于信号量只能进行两种操作等待和发送信号，即P(sv)和V(sv),他们的行为是这样的：</p><p>P(sv)：如果sv的值大于零，就给它减1；如果它的值为零，就挂起该进程的执行</p><p>V(sv)：如果有其他进程因等待sv而被挂起，就让它恢复运行，如果没有进程因等待sv而挂起，就给它加1.</p><p>举个例子，就是两个进程共享信号量sv，一旦其中一个进程执行了P(sv)操作，它将得到信号量，并可以进入临界区，使sv减1。</p><p>而第二个进程将被阻止进入临界区，因为当它试图执行P(sv)时，sv为0，它会被挂起以等待第一个进程离开临界区域并执行V(sv)释放信号量，这时第二个进程就可以恢复执行。</p><h2 id="Semaphore使用初探："><a href="#Semaphore使用初探：" class="headerlink" title="Semaphore使用初探："></a>Semaphore使用初探：</h2><p>Semaphore是用来保护一个或者多个共享资源的访问，Semaphore内部维护了一个计数器，其值为可以访问的共享资源的个数。一个线程要访问共享资源，先获得信号量，如果信号量的计数器值大于1，意味着有共享资源可以访问，则使其计数器值减去1，再访问共享资源。</p><p>如果计数器值为0,线程进入休眠。当某个线程使用完共享资源后，释放信号量，并将信号量内部的计数器加1，之前进入休眠的线程将被唤醒并再次试图获得信号量。</p><p>就好比一个图书馆管理员，站在门口，只有图书馆有空位，就开门允许与空位数量等量的人进入图书馆。多个人进入图书馆后，相当于N个人来分配使用N个空位。为避免多个人来同时竞争同一个空位，在内部仍然使用锁来控制资源的同步访问。</p><h3 id="Semaphore的使用："><a href="#Semaphore的使用：" class="headerlink" title="Semaphore的使用："></a>Semaphore的使用：</h3><p>Semaphore使用时需要先构建一个参数来指定共享资源的数量，Semaphore构造完成后即是获取Semaphore、共享资源使用完毕后释放Semaphore。</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooBar</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Semaphore foo = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);<span class="comment">//foo方法可以访问的共享资源为1</span></span><br><span class="line">    Semaphore bar = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);<span class="comment">//bar方法可以访问的共享资源为0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            foo.acquire();<span class="comment">//foo方法获得信号量，并将信号量内部的计数器减1，计数器值为0后,线程进入休眠。</span></span><br><span class="line">            printFoo.run();</span><br><span class="line">            bar.release();<span class="comment">//bar方法释放信号量，并将信号量内部的计数器加1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            bar.acquire();<span class="comment">//bar方法获得信号量，并将信号量内部的计数器减1，计数器值为0后,线程进入休眠。</span></span><br><span class="line">            printBar.run();</span><br><span class="line">            foo.release();<span class="comment">//foo方法释放信号量，并将信号量内部的计数器加1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方案二：Lock（公平锁）"><a href="#方案二：Lock（公平锁）" class="headerlink" title="方案二：Lock（公平锁）"></a>方案二：Lock（公平锁）</h1><h2 id="公平锁："><a href="#公平锁：" class="headerlink" title="公平锁："></a>公平锁：</h2><p>每个线程抢占锁的顺序为先后调用lock方法的顺序依次获取锁，类似于排队吃饭。</p><h2 id="非公平锁："><a href="#非公平锁：" class="headerlink" title="非公平锁："></a>非公平锁：</h2><p>每个线程抢占锁的顺序不定，谁运气好，谁就获取到锁，和调用lock方法的先后顺序无关</p><h2 id="ReentrantLock（可重入锁）及其优点"><a href="#ReentrantLock（可重入锁）及其优点" class="headerlink" title="ReentrantLock（可重入锁）及其优点"></a>ReentrantLock（可重入锁）及其优点</h2><p>java中已经有了内置锁：synchronized,synchronized的特点是使用简单，一切交给JVM去处理,不需要显示释放。</p><p>从用法上可以看出，与synchronized相比， ReentrantLock就稍微复杂一点。因为必须在finally中进行解锁操作，<br>如果不在 finally解锁，有可能代码出现异常锁没被释放，那么为什么要引入ReentrantLock呢？</p><p>在jdk1.5里面，ReentrantLock的性能是明显优于synchronized的，但是在jdk1.6里面，synchronized做了优化，他们之间的性能差别已经不明显了。</p><p>ReentrantLock并不是一种替代内置加锁的方法，而是作为一种可选择的高级功能。<br>相比于synchronized，ReentrantLock在功能上更加丰富，它具有可重入、可中断、可限时、公平锁等特点。</p><h3 id="可重入（其实synchronized-也是可重入的）"><a href="#可重入（其实synchronized-也是可重入的）" class="headerlink" title="可重入（其实synchronized 也是可重入的）"></a>可重入（其实synchronized 也是可重入的）</h3><pre><code>lock.lock();lock.lock();try{    i++;}           finally{    lock.unlock();    lock.unlock();}</code></pre><p>由于ReentrantLock是重入锁，所以可以反复得到相同的一把锁，它有一个与锁相关的获取计数器，如果拥有锁的某个线程再次得到锁，那么获取计数器就加1，然后锁需要被释放两次才能获得真正释放(重入锁)。</p><h3 id="可中断"><a href="#可中断" class="headerlink" title="可中断"></a>可中断</h3><p>与synchronized不同的是，ReentrantLock对中断是有响应的.synchronized一旦尝试获取锁就会一直等待直到获取到锁。<br>构造一个死锁的例子，然后用中断来处理死锁</p><p>此处示例见<a href="https://www.jianshu.com/p/155260c8af6c" target="_blank" rel="noopener">ReentrantLock的使用</a></p><h3 id="可限时"><a href="#可限时" class="headerlink" title="可限时"></a>可限时</h3><p>超时不能获得锁，就返回false，不会永久等待构成死锁</p><p>使用lock.tryLock(long timeout, TimeUnit unit)来实现可限时锁，参数为时间和单位。</p><h3 id="公平锁的使用方法"><a href="#公平锁的使用方法" class="headerlink" title="公平锁的使用方法"></a>公平锁的使用方法</h3><p>一般意义上的锁是不公平的，不一定先来的线程能先得到锁，后来的线程就后得到锁。不公平的锁可能会产生饥饿现象。</p><p>公平锁的意思就是，这个锁能保证线程是先来的先得到锁。虽然公平锁不会产生饥饿现象，但是公平锁的性能会比非公平锁差很多。</p><pre><code>public ReentrantLock(boolean fair) public static ReentrantLock fairLock = new ReentrantLock(true);</code></pre><h2 id="Volatile关键字"><a href="#Volatile关键字" class="headerlink" title="Volatile关键字"></a>Volatile关键字</h2><p>Java的volatile关键字用于标记一个变量“应当存储在主存”。更确切地说，每次读取volatile变量，都应该从主存读取，而不是从CPU缓存读取。每次写入一个volatile变量，应该写到主存中，而不是仅仅写到CPU缓存。</p><p>Java的volatile关键字能保证变量修改后，对各个线程是可见的。更多详细内容参见<a href="http://ifeve.com/java-volatile%e5%85%b3%e9%94%ae%e5%ad%97/" target="_blank" rel="noopener">Java Volatile关键字</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooBar</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> permitFoo = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(permitFoo) &#123;</span><br><span class="line">                printFoo.run();</span><br><span class="line">                    i++;</span><br><span class="line">                    permitFoo = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(!permitFoo) &#123;</span><br><span class="line">                printBar.run();</span><br><span class="line">                i++;</span><br><span class="line">                permitFoo = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此种方法可以跑通但是超时了。</p><h1 id="方案三：无锁"><a href="#方案三：无锁" class="headerlink" title="方案三：无锁"></a>方案三：无锁</h1><p>以上的公平锁方案完全可以改造成无锁方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooBar</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> permitFoo = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;     </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(permitFoo) &#123;</span><br><span class="line">        printFoo.run();</span><br><span class="line">            i++;</span><br><span class="line">            permitFoo = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;       </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!permitFoo) &#123;</span><br><span class="line">        printBar.run();</span><br><span class="line">        i++;</span><br><span class="line">        permitFoo = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此种方法可以跑通但是也超时了。</p><h1 id="方案四：CyclicBarrier"><a href="#方案四：CyclicBarrier" class="headerlink" title="方案四：CyclicBarrier"></a>方案四：CyclicBarrier</h1><p>字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用。我们暂且把这个状态就叫做barrier，当调用await()方法之后，线程就处于barrier了。</p><p>CyclicBarrier更适合用在循环场景中，那么我们来试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    CyclicBarrier cyclicBarrier= <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> fin = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooBar</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!fin);</span><br><span class="line">            <span class="comment">// printFoo.run() outputs "foo". Do not change or remove this line.</span></span><br><span class="line">            printFoo.run();</span><br><span class="line">            fin = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (BrokenBarrierException e)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (BrokenBarrierException e)&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// printBar.run() outputs "bar". Do not change or remove this line.</span></span><br><span class="line">                printBar.run();</span><br><span class="line">                fin = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法可以提交成功。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://leetcode-cn.com/problems/print-foobar-alternately/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/print-foobar-alternately/</a></p><p>【2】<a href="https://zhuanlan.zhihu.com/p/81626432" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/81626432</a></p><p>【3】<a href="https://blog.csdn.net/ljianhui/java/article/details/10243617" target="_blank" rel="noopener">https://blog.csdn.net/ljianhui/java/article/details/10243617</a></p><p>【4】<a href="https://blog.csdn.net/zbc1090549839/java/article/details/53389602" target="_blank" rel="noopener">https://blog.csdn.net/zbc1090549839/java/article/details/53389602</a></p><p>【5】<a href="https://www.jianshu.com/p/155260c8af6c" target="_blank" rel="noopener">https://www.jianshu.com/p/155260c8af6c</a></p><p>【6】<a href="http://ifeve.com/java-volatile%e5%85%b3%e9%94%ae%e5%ad%97/" target="_blank" rel="noopener">http://ifeve.com/java-volatile%e5%85%b3%e9%94%ae%e5%ad%97/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;两个不同的线程将会共用一个 FooBar 实例。其中一个线程将会调用 foo() 方法，另一个线程将会调用 bar() 方法.设计修改程序交替调用这两个方法。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年5月" scheme="http://yoursite.com/categories/2020%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Concurrency" scheme="http://yoursite.com/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程</title>
    <link href="http://yoursite.com/2020/05/21/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/05/21/Java并发编程/</id>
    <published>2020-05-21T14:20:12.000Z</published>
    <updated>2020-05-23T04:30:25.861Z</updated>
    
    <content type="html"><![CDATA[<p>介绍Java并发编程中的常用方法，如AtomicInteger，信号量Semaphore，这些方法的实现原理和源码值得深究。</p><a id="more"></a><h1 id="Java原子操作AtomicInteger"><a href="#Java原子操作AtomicInteger" class="headerlink" title="Java原子操作AtomicInteger"></a>Java原子操作AtomicInteger</h1><p>JDK1.5之后的java.util.concurrent.atomic包里，多了一批原子处理类。AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference。主要用于在高并发环境下的高效程序处理,来帮助我们简化同步处理.</p><p>AtomicInteger，一个提供原子操作的Integer的类。在Java语言中，++i和i++操作并不是线程安全的，在使用的时候，不可避免的会用到synchronized关键字。而AtomicInteger则通过一种线程安全的加减操作接口。</p><p>我们先来看看AtomicInteger给我们提供了什么接口:</p><pre><code>    public final int get() //获取当前的值public final int getAndSet(int newValue)//获取当前的值，并设置新的值public final int getAndIncrement()//获取当前的值，并自增public final int getAndDecrement() //获取当前的值，并自减public final int getAndAdd(int delta) //获取当前的值，并加上预期的值</code></pre><p>下面通过两个简单的例子来看一下 AtomicInteger 的优势在哪:</p><p>普通线程同步:</p><pre><code>class Test2 {        private volatile int count = 0;        public synchronized void increment() {                  count++; //若要线程安全执行执行count++，需要加锁        }        public int getCount() {                  return count;        }}</code></pre><p>使用AtomicInteger:</p><pre><code>class Test2 {        private AtomicInteger count = new AtomicInteger();        public void increment() {                  count.incrementAndGet();        }   //使用AtomicInteger之后，不需要加锁，也可以实现线程安全。       public int getCount() {                return count.get();        }}</code></pre><p>使用AtomicInteger是非常的安全的.而且因为AtomicInteger由硬件提供原子操作指令实现的。在非激烈竞争的情况下，开销更小，速度更快。</p><p>我们来看看AtomicInteger是如何使用非阻塞算法来实现并发控制的:<br>AtomicInteger的关键域只有一下3个：</p><pre><code>// setup to use Unsafe.compareAndSwapInt for updatesprivate static final Unsafe unsafe = Unsafe.getUnsafe();private static final long valueOffset;static {             try {                        valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField(&quot;value&quot;));           } catch (Exception ex) {                throw new Error(ex);         }    }private volatile int value;</code></pre><p>这里， unsafe是java提供的获得对对象内存地址访问的类，注释已经清楚的写出了，它的作用就是在更新操作时提供“比较并替换”的作用。实际上就是AtomicInteger中的一个工具。<br>valueOffset是用来记录value本身在内存的便宜地址的，这个记录，也主要是为了在更新操作在内存中找到value的位置，方便比较。<br>注意：value是用来存储整数的时间变量，这里被声明为volatile，就是为了保证在更新操作时，当前线程可以拿到value最新的值（并发环境下，value可能已经被其他线程更新了）。<br>这里，我们以自增的代码为例，可以看到这个并发控制的核心算法：</p><pre><code>/***Atomicallyincrementsbyonethecurrentvalue.**@returntheupdatedvalue*/publicfinalintincrementAndGet(){for(;;){    //这里可以拿到value的最新值    intcurrent=get();    intnext=current+1;if(compareAndSet(current,next))    returnnext;    }}publicfinalbooleancompareAndSet(intexpect,intupdate){//使用unsafe的native方法，实现高效的硬件级别CAS        returnunsafe.compareAndSwapInt(this,valueOffset,expect,update);}</code></pre><p>优点总结:<br>最大的好处就是可以避免多线程的优先级倒置和死锁情况的发生，提升在高并发处理下的性能。</p><h1 id="信号量Semaphore"><a href="#信号量Semaphore" class="headerlink" title="信号量Semaphore"></a>信号量Semaphore</h1><p>Semaphore也叫信号量，在JDK1.5被引入，可以用来控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用资源。</p><p>Semaphore内部维护了一组虚拟的许可，许可的数量可以通过构造函数的参数指定。</p><p>访问特定资源前，必须使用acquire方法获得许可，如果许可数量为0，该线程则一直阻塞，直到有可用许可。</p><p>访问资源后，使用release释放许可。</p><p>Semaphore和ReentrantLock类似，获取许可有公平策略和非公平许可策略，默认情况下使用非公平策略。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>Semaphore可以用来做流量分流，特别是对公共资源有限的场景，比如数据库连接。</p><p>假设有这个的需求，读取几万个文件的数据到数据库中，由于文件读取是IO密集型任务，可以启动几十个线程并发读取，但是数据库连接数只有10个，这时就必须控制最多只有10个线程能够拿到数据库连接进行操作。这个时候，就可以使用Semaphore做流量控制。</p><pre><code>public class SemaphoreTest {    private static final int COUNT = 40;    private static Executor executor = Executors.newFixedThreadPool(COUNT);    private static Semaphore semaphore = new Semaphore(10);    public static void main(String[] args) {        for (int i=0; i&lt; COUNT; i++) {            executor.execute(new ThreadTest.Task());        }    }    static class Task implements Runnable {        @Override        public void run() {            try {                //读取文件操作                semaphore.acquire();                // 存数据过程                semaphore.release();            } catch (InterruptedException e) {                e.printStackTrace();            } finally {            }        }    }}</code></pre><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>代码源于JDK1.8<br>Semaphore实现主要基于java同步器AQS，不熟悉的可以移步 <a href="https://www.jianshu.com/p/d8eeb31bee5c" target="_blank" rel="noopener">深入浅出java同步器</a>。</p><p>内部使用state表示许可数量。</p><h3 id="非公平策略"><a href="#非公平策略" class="headerlink" title="非公平策略"></a>非公平策略</h3><p>acquire实现，核心代码如下：</p><pre><code>final int nonfairTryAcquireShared(int acquires) {    for (;;) {        int available = getState();        int remaining = available - acquires;        if (remaining &lt; 0 ||            compareAndSetState(available, remaining))            return remaining;    }}</code></pre><p>acquires值默认为1，表示尝试获取1个许可，remaining代表剩余的许可数。</p><p>如果remaining &lt; 0，表示目前没有剩余的许可。</p><p>当前线程进入AQS中的doAcquireSharedInterruptibly方法等待可用许可并挂起，直到被唤醒。</p><p>release实现，核心代码如下：</p><pre><code>protected final boolean tryReleaseShared(int releases) {    for (;;) {        int current = getState();        int next = current + releases;        if (next &lt; current) // overflow            throw new Error(&quot;Maximum permit count exceeded&quot;);        if (compareAndSetState(current, next))            return true;    }}</code></pre><p>releases值默认为1，表示尝试释放1个许可，next代表如果许可释放成功，可用许可的数量。</p><p>通过unsafe.compareAndSwapInt修改state的值，确保同一时刻只有一个线程可以释放成功。</p><p>许可释放成功，当前线程进入到AQS的doReleaseShared方法，唤醒队列中等待许可的线程。</p><p>也许有人会有疑问，非公平性体现在哪里？</p><p>当一个线程A执行acquire方法时，会直接尝试获取许可，而不管同一时刻阻塞队列中是否有线程也在等待许可，如果恰好有线程C执行release释放许可，并唤醒阻塞队列中第一个等待的线程B，这个时候，线程A和线程B是共同竞争可用许可，不公平性就是这么体现出来的，线程A一点时间都没等待就和线程B同等对待。</p><h3 id="公平策略"><a href="#公平策略" class="headerlink" title="公平策略"></a>公平策略</h3><p>acquire实现，核心代码如下：</p><pre><code>protected int tryAcquireShared(int acquires) {    for (;;) {        if (hasQueuedPredecessors())            return -1;        int available = getState();        int remaining = available - acquires;        if (remaining &lt; 0 ||            compareAndSetState(available, remaining))            return remaining;    }}</code></pre><p>acquires值默认为1，表示尝试获取1个许可，remaining代表剩余的许可数。<br>可以看到和非公平策略相比，就多了一个对阻塞队列的检查。</p><p>如果阻塞队列没有等待的线程，则参与许可的竞争。<br>否则直接插入到阻塞队列尾节点并挂起，等待被唤醒。</p><p>release实现，和非公平策略一样。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="https://www.jianshu.com/p/509aca840f6d" target="_blank" rel="noopener">https://www.jianshu.com/p/509aca840f6d</a></p><p>【2】<a href="https://www.ibm.com/developerworks/cn/java/j-jtp11234/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-jtp11234/</a></p><p>【3】<a href="https://www.jianshu.com/p/0090341c6b80" target="_blank" rel="noopener">https://www.jianshu.com/p/0090341c6b80</a></p><p>【4】<a href="https://www.jianshu.com/p/d8eeb31bee5c" target="_blank" rel="noopener">https://www.jianshu.com/p/d8eeb31bee5c</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍Java并发编程中的常用方法，如AtomicInteger，信号量Semaphore，这些方法的实现原理和源码值得深究。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年5月" scheme="http://yoursite.com/categories/2020%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="Concurrency" scheme="http://yoursite.com/tags/Concurrency/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>1114.按序打印</title>
    <link href="http://yoursite.com/2020/05/21/1114.%E6%8C%89%E5%BA%8F%E6%89%93%E5%8D%B0/"/>
    <id>http://yoursite.com/2020/05/21/1114.按序打印/</id>
    <published>2020-05-21T12:56:12.000Z</published>
    <updated>2020-05-23T04:30:38.629Z</updated>
    
    <content type="html"><![CDATA[<p>请设计修改程序，以确保三个线程中的 two() 方法在 one() 方法之后被执行，three() 方法在 two() 方法之后被执行。</p><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>我们提供了一个类：</p><pre><code>public class Foo {  public void one() { print(&quot;one&quot;); }  public void two() { print(&quot;two&quot;); }  public void three() { print(&quot;three&quot;); }}</code></pre><p>三个不同的线程将会共用一个 Foo 实例。</p><pre><code>线程 A 将会调用 one() 方法线程 B 将会调用 two() 方法线程 C 将会调用 three() 方法</code></pre><p>请设计修改程序，以确保 two() 方法在 one() 方法之后被执行，three() 方法在 two() 方法之后被执行。</p><p>示例 1:</p><pre><code>输入: [1,2,3]输出: &quot;onetwothree&quot;</code></pre><p>解释: </p><p>有三个线程会被异步启动。<br>输入 [1,2,3] 表示线程 A 将会调用 one() 方法，线程 B 将会调用 two() 方法，线程 C 将会调用 three() 方法。<br>正确的输出是 “onetwothree”。<br>示例 2:</p><pre><code>输入: [1,3,2]输出: &quot;onetwothree&quot;</code></pre><p>解释: </p><p>输入 [1,3,2] 表示线程 A 将会调用 one() 方法，线程 B 将会调用 three() 方法，线程 C 将会调用 two() 方法。<br>正确的输出是 “onetwothree”。</p><p>注意:</p><p>尽管输入中的数字似乎暗示了顺序，但是我们并不保证线程在操作系统中的调度顺序。</p><p>你看到的输入格式主要是为了确保测试的全面性。</p><h1 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h1><p>来自<a href="https://baike.baidu.com/item/%E5%B9%B6%E5%8F%91%E8%AE%A1%E7%AE%97/9939802?fr=aladdin" target="_blank" rel="noopener">并发计算</a>的场景，该场景下，程序在多线程（或多进程）中 <em>同时</em> 执行。</p><p>同时进行并不是完全指进程或线程在不同的物理 CPU 上独立运行，更多情况下，是在一个物理 CPU 上交替执行多个线程或进程。<em>并发既可在线程中，也可在进程中。</em></p><p>并发主要为多任务情况设计。但如果应用不当，可能会引发一些漏洞。按照情况不同，可以分为三种：</p><ul><li><p><strong>竞态条件</strong>：由于多进程之间的竞争执行，导致程序未按照期望的顺序输出。</p></li><li><p><strong>死锁</strong>：并发程序等待一些必要资源，导致没有程序可以执行。</p></li><li><p><strong>资源不足</strong>：进程被永久剥夺了运行所需的资源。</p></li></ul><p>此题中存在竞态条件。下面展示一个竞态条件的例子。</p><p>假设有一个方法 <code>withdraw(amount)</code>，如果请求量小于当前余额，则从当前余额中减去请求量，然后返回余额。方法定义如下：</p><figure class="highlight python"><figcaption><span>[snippet1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">balance = <span class="number">500</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">withdraw</span><span class="params">(amount)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> (amount &lt; balance):</span><br><span class="line">        balance -= amount</span><br><span class="line">    <span class="keyword">return</span> balance</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[snippet1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> balance = <span class="number">500</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (amount &lt; balance) &#123;</span><br><span class="line">    balance -= amount;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> balance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们 <em>期望</em> 该方法执行后余额永远不会为负。</p><p>但是有可能出现竞态条件，使得余额变为负数。假设两个线程同时使用不同的参数执行该方法。例如：线程 1 执行 <code>withdraw(amount=400)</code>，线程 2 执行 <code>withdraw(amount=200)</code>。这两个线程的执行顺序如下图所示。在每个时刻只执行一条语句。</p><p><img src="https://pic.leetcode-cn.com/Figures/1114/1114_race_condition.png" alt="image"></p><p>上述流程执行结束后，余额变成负数，这并不是期望的输出。</p><h1 id="无竞争并发"><a href="#无竞争并发" class="headerlink" title="无竞争并发"></a>无竞争并发</h1><p>并发问题有一个共同特征：多个线程/进程之间共享一些资源（例如：余额）。由于无法消除资源共享的约束，防止并发问题就变成了 <strong>资源共享的协调</strong> 问题。</p><p>根据这个思路，如果可以确保程序中 <strong>关键部分代码的独占性</strong>（例如：检查和减少余额），就可以防止程序进入不一致的状态。</p><blockquote><p>竞争条件的解决方案为：需要某些关键部分代码具有排他性，即在给定的时间内，只有一个线程可以进入关键部分代码。</p></blockquote><p>可以将这种机制看做限制关键部分代码访问的锁。在前面示例的关键部分代码加锁，即检查余额和减少余额的语句。然后重新运行两个线程，会有下图的执行顺序：</p><p><img src="https://pic.leetcode-cn.com/Figures/1114/1114_lock.png" alt="image"></p><p>在该机制下，一旦一个线程进入关键部分，它就可以阻止其他线程进入该关键部分。例如，在时间点 3，<code>线程 2</code> 进入关键部分，那么在时间点 4，如果没有锁保护，<code>线程 1</code> 就可能进入关键部分。最后两个线程同时运行，保证系统的一致性，并确保余额正确。</p><p>如果该线程未被授权进入关键代码，可以认为该线程被阻塞或进入睡眠状态。例如，<code>线程 1</code> 在时间点 4 被阻塞，之后关键部分被释放，可以通知其他等待线程。<code>线程 2</code> 在时间点 5 释放了关键部分，就可以通知 <code>线程 1</code> 进入。</p><blockquote><p>这种机制还具有唤醒其他等待线程的功能。</p></blockquote><p>总之，为了防止出现并发竞争状态，需要一种具有两种功能的机制：1）关键部分的访问控制；2）通知阻塞线程。</p><h1 id="方法一：使用-synchronization"><a href="#方法一：使用-synchronization" class="headerlink" title="方法一：使用 synchronization"></a>方法一：使用 synchronization</h1><p><strong>思路</strong></p><p>题目要求按顺序依次执行三个方法，且每个方法都在单独的线程中运行。为了保证线程的执行顺序，可以在方法之间创建一些依赖关系，即第二个方法必须在第一个方法之后执行，第三个方法必须在第二个方法之后执行。</p><blockquote><p>方法对之间的依赖关系形成了所有方法的特定的执行顺序。例如 <code>A &lt; B</code>, <code>B &lt; C</code>，则所有方法的执行顺序为 <code>A &lt; B &lt; C</code>。</p></blockquote><p><img src="https://pic.leetcode-cn.com/Figures/1114/1114_partial_order.png" alt="image"></p><p>依赖关系可以通过并发机制实现。使用一个共享变量 <code>firstJobDone</code> 协调第一个方法与第二个方法的执行顺序，使用另一个共享变量 <code>secondJobDone</code> 协调第二个方法与第三个方法的执行顺序。</p><p><strong>算法</strong></p><ul><li><p>首先初始化共享变量 <code>firstJobDone</code> 和 <code>secondJobDone</code>，初始值表示所有方法未执行。</p></li><li><p>方法 <code>first()</code> 没有依赖关系，可以直接执行。在方法最后更新变量 <code>firstJobDone</code> 表示该方法执行完成。</p></li><li><p>方法 <code>second()</code> 中，检查 <code>firstJobDone</code> 的状态。如果未更新则进入等待状态，否则执行方法 <code>second()</code>。在方法末尾，更新变量 <code>secondJobDone</code> 表示方法 <code>second()</code> 执行完成。</p></li><li><p>方法 <code>third()</code> 中，检查 <code>secondJobDone</code> 的状态。与方法 <code>second()</code> 类似，执行 <code>third()</code> 之前，需要先等待 <code>secondJobDone</code> 的状态。</p></li></ul><p><img src="https://pic.leetcode-cn.com/Figures/1114/1114_flow.png" alt="image"></p><p><strong>实现</strong></p><p>上述算法的实现在很大程度上取决于选择的编程语言。尽管在 Java，C++ 和 Python 中都存在<a href="https://baike.baidu.com/item/%E4%BA%92%E6%96%A5%E4%BA%8B%E4%BB%B6/9980508?fr=aladdin" target="_blank" rel="noopener">互斥</a>与<a href="https://baike.baidu.com/item/%E4%BF%A1%E5%8F%B7%E9%87%8F/9807501?fr=aladdin" target="_blank" rel="noopener">信号量</a>，但不同语言对并发机制有不同实现。</p><figure class="highlight python"><figcaption><span>[solution1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.firstJobDone = Lock()</span><br><span class="line">        self.secondJobDone = Lock()</span><br><span class="line">        self.firstJobDone.acquire()</span><br><span class="line">        self.secondJobDone.acquire()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">first</span><span class="params">(self, printFirst: <span class="string">'Callable[[], None]'</span>)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="comment"># printFirst() outputs "first".</span></span><br><span class="line">        printFirst()</span><br><span class="line">        <span class="comment"># Notify the thread that is waiting for the first job to be done.</span></span><br><span class="line">        self.firstJobDone.release()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">second</span><span class="params">(self, printSecond: <span class="string">'Callable[[], None]'</span>)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="comment"># Wait for the first job to be done</span></span><br><span class="line">        <span class="keyword">with</span> self.firstJobDone:</span><br><span class="line">            <span class="comment"># printSecond() outputs "second".</span></span><br><span class="line">            printSecond()</span><br><span class="line">            <span class="comment"># Notify the thread that is waiting for the second job to be done.</span></span><br><span class="line">            self.secondJobDone.release()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">third</span><span class="params">(self, printThird: <span class="string">'Callable[[], None]'</span>)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Wait for the second job to be done.</span></span><br><span class="line">        <span class="keyword">with</span> self.secondJobDone:</span><br><span class="line">            <span class="comment"># printThird() outputs "third".</span></span><br><span class="line">            printThird()</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption><span>[solution1-Cpp]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">sem_t</span> firstJobDone;</span><br><span class="line">    <span class="keyword">sem_t</span> secondJobDone;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    Foo() &#123;</span><br><span class="line">        sem_init(&amp;firstJobDone, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        sem_init(&amp;secondJobDone, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void first(function&lt;void()&gt; printFirst) &#123;</span><br><span class="line">        <span class="comment">// printFirst() outputs "first".</span></span><br><span class="line">        printFirst();</span><br><span class="line">        sem_post(&amp;firstJobDone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void second(function&lt;void()&gt; printSecond) &#123;</span><br><span class="line">        sem_wait(&amp;firstJobDone);</span><br><span class="line">        <span class="comment">// printSecond() outputs "second".</span></span><br><span class="line">        printSecond();</span><br><span class="line">        sem_post(&amp;secondJobDone);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void third(function&lt;void()&gt; printThird) &#123;</span><br><span class="line">        sem_wait(&amp;secondJobDone);</span><br><span class="line">        <span class="comment">// printThird() outputs "third".</span></span><br><span class="line">        printThird();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> AtomicInteger firstJobDone = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">private</span> AtomicInteger secondJobDone = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">(Runnable printFirst)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// printFirst.run() outputs "first".</span></span><br><span class="line">    printFirst.run();</span><br><span class="line">    <span class="comment">// mark the first job as done, by increasing its count.</span></span><br><span class="line">    firstJobDone.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(Runnable printSecond)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (firstJobDone.get() != <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// waiting for the first job to be done.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printSecond.run() outputs "second".</span></span><br><span class="line">    printSecond.run();</span><br><span class="line">    <span class="comment">// mark the second as done, by increasing its count.</span></span><br><span class="line">    secondJobDone.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">third</span><span class="params">(Runnable printThird)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (secondJobDone.get() != <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// waiting for the second job to be done.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printThird.run() outputs "third".</span></span><br><span class="line">    printThird.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="扩展思考"><a href="#扩展思考" class="headerlink" title="扩展思考"></a>扩展思考</h1><p>按序打印中只使用一个AtomicInteger做共享变量会增加耗时，可以深入探究其中的原因。</p><h1 id="方法二：通过synchronized构造屏障"><a href="#方法二：通过synchronized构造屏障" class="headerlink" title="方法二：通过synchronized构造屏障"></a>方法二：通过synchronized构造屏障</h1><p>这是一个典型的执行屏障的问题，可以通过构造屏障来实现。</p><p>如下图，我们需要构造 <em>2</em> 道屏障，<code>second</code> 线程等待 <code>first</code> 屏障，<code>third</code> 线程等待 <code>second</code> 屏障。：</p><p><img src="https://pic.leetcode-cn.com/879c5abd22c2dbc2618a1433dfbeb02a34b9586a10425986fafdc90eef978cc1-image.png" alt="image"></p><p><code>first</code> 线程会释放 <code>first</code> 屏障，而 <code>second</code> 线程会释放 <code>second</code> 屏障。</p><p>Java 中，我们使用线程等待的方式实现执行屏障，使用释放线程等待的方式实现屏障消除。具体代码如下：</p><figure class="highlight java"><figcaption><span>[-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> firstFinished;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> secondFinished;</span><br><span class="line">    <span class="keyword">private</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">(Runnable printFirst)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// printFirst.run() outputs "first". Do not change or remove this line.</span></span><br><span class="line">            printFirst.run();</span><br><span class="line">            firstFinished = <span class="keyword">true</span>;</span><br><span class="line">            lock.notifyAll(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(Runnable printSecond)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!firstFinished) &#123;</span><br><span class="line">                lock.wait();</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// printSecond.run() outputs "second". Do not change or remove this line.</span></span><br><span class="line">            printSecond.run();</span><br><span class="line">            secondFinished = <span class="keyword">true</span>;</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">third</span><span class="params">(Runnable printThird)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">           <span class="keyword">while</span> (!secondFinished) &#123;</span><br><span class="line">                lock.wait();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printThird.run() outputs "third". Do not change or remove this line.</span></span><br><span class="line">            printThird.run();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="https://leetcode-cn.com/problems/print-in-order/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/print-in-order/</a></p><p>【2】<a href="https://baike.baidu.com/item/%E5%B9%B6%E5%8F%91%E8%AE%A1%E7%AE%97/9939802?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/%E5%B9%B6%E5%8F%91%E8%AE%A1%E7%AE%97/9939802?fr=aladdin</a></p><p>【3】<a href="https://leetcode-cn.com/problems/print-in-order/solution/an-xu-da-yin-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/print-in-order/solution/an-xu-da-yin-by-leetcode/</a></p><p>【4】<a href="https://www.jianshu.com/p/509aca840f6d" target="_blank" rel="noopener">https://www.jianshu.com/p/509aca840f6d</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;请设计修改程序，以确保三个线程中的 two() 方法在 one() 方法之后被执行，three() 方法在 two() 方法之后被执行。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年5月" scheme="http://yoursite.com/categories/2020%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Concurrency" scheme="http://yoursite.com/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>684.冗余链接</title>
    <link href="http://yoursite.com/2020/05/19/684.%E5%86%97%E4%BD%99%E9%93%BE%E6%8E%A5/"/>
    <id>http://yoursite.com/2020/05/19/684.冗余链接/</id>
    <published>2020-05-19T02:26:12.000Z</published>
    <updated>2020-05-19T15:51:25.460Z</updated>
    
    <content type="html"><![CDATA[<p>使用并查集找到一条可以删去的边。</p><a id="more"></a><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>在计算机科学中，并查集是一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题。有一个联合-查找算法（Union-find Algorithm）定义了两个用于此数据结构的操作：</p><p>Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。<br>Union：将两个子集合并成同一个集合。</p><p>由于支持这两种操作，一个不相交集也常被称为联合-查找数据结构（Union-find Data Structure）或合并-查找集合（Merge-find Set）。<br>为了更加精确的定义这些方法，需要定义如何表示集合。一种常用的策略是为每个集合选定一个固定的元素，称为代表，以表示整个集合。接着，Find(x) 返回 x 所属集合的代表，而 Union 使用两个集合的代表作为参数。</p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>本问题中, 树指的是一个连通且无环的无向图。</p><p>输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。</p><p>结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u &lt; v，表示连接顶点u 和v的无向图的边。</p><p>返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u &lt; v。</p><p>示例 1：</p><p>输入: [[1,2], [1,3], [2,3]]<br>输出: [2,3]<br>解释: 给定的无向图为:<br>  1<br> / <br>2 - 3<br>示例 2：</p><p>输入: [[1,2], [2,3], [3,4], [1,4], [1,5]]<br>输出: [1,4]<br>解释: 给定的无向图为:<br>5 - 1 - 2<br>    |   |<br>    4 - 3</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="方法一：DFS"><a href="#方法一：DFS" class="headerlink" title="方法一：DFS"></a>方法一：DFS</h2><p><strong>算法：</strong><br>对于每个边 <code>(u, v)</code>，用深度优先搜索遍历图，以查看是否可以将 <code>u</code> 连接到 <code>v</code>。如果可以，则它是重复边。</p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(N^2)*。其中 *N</em> 是图中的结点数（以及边数）。在最坏的情况下，对于我们包含的每一条边，我们必须搜索图中出现的每一条边。</li><li>空间复杂度：<em>O(N)*，图的当前构造最多有 *N</em> 个结点。</li></ul><h2 id="方法二：并查集"><a href="#方法二：并查集" class="headerlink" title="方法二：并查集"></a>方法二：并查集</h2><p><strong>算法：</strong><br>如果我们熟悉并查集（DSU）数据结构，我们可以直接使用它来解决这个问题：我们只需找到已经连接的图中出现的第一条边。本解释的其余部分将重点介绍实现 DSU 的细节。</p><p>一个 DSU 数据结构可以用来维护图形连接组件的数据，并快速查询它们。有两种操作：</p><ul><li><code>dsu.find(node x)</code>，找到元素 <code>x</code> 所在的集合的代表，该操作也可以用于判断两个元素是否位于同一个集合。</li><li><code>dsu.union(node x, node y)</code>，把元素 <code>x</code> 和元素 <code>y</code> 所在的集合合并，要求 <code>x</code>和 <code>y</code> 所在的集合不相交，如果相交则不合并。</li></ul><p>为了实现这一点，我们跟踪父结点，它会记录同一连接节点中较小结点的所在的集合。如果结点是它自己的父结点，我们将其称为连接结点的领导者。</p><p>DSU 结构的简单实现如下所示：<br>伪代码 ：<br>我们使用两种技术来提高运行时的复杂性：路径压缩和按秩合并。</p><ul><li>路径压缩涉及将 <code>find</code> 函数中的 <code>x=parent[x]</code> 更改为<code>parent[x]=find(parent[x])</code>。</li><li>按秩合并涉及到将发现的工作量平均分配给领导者。每当 <code>dsu.union(x, y)</code> 时，我们都有两个领导者 <code>xr，yr</code>，并且我们要选择是要 <code>parent[x]=yr</code> 还是 <code>parent[y]=xr</code>。我们选择有更多子节点的领导者作为领导者。</li><li>具体地说，<code>rank</code> 的含义是 <code>x</code> 的跟随者少于 <code>2 ^ rank[x]</code>，这个策略可以作为 <code>dsu.find</code> 中的递归循环可中的界限。</li></ul><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<img src="./p__O_Nalpha_N___approx_O_N__.png" alt="O(N\alpha(N))\approxO(N) "> 。其中， <em>N</em> 是图中顶点的数目（以及边的数目），<img src="./p__alpha_.png" alt="\alpha ">  是 <code>Inverse-Ackermann</code> 函数。我们对 <code>dsu.union</code> 进行了多达 <em>N</em> 次查询，这需要花费 <img src="./p__O_alpha_N___.png" alt="O(\alpha(N)) ">  时间。可以去查阅资料为什么 <code>dsu.union</code> 具有 <img src="./p__O_alpha_N___.png" alt="O(\alpha(N)) ">  复杂性、<code>Inverse-Ackermann</code> 函数是什么以及为什么 <img src="./p__O_alpha_N___.png" alt="O(\alpha(N)) ">  大约是 <em>O(1)</em> 的原因。</li><li>空间复杂度：<em>O(N)*，图的当前构造（嵌入在我们的 DSU 结构中）最多有 *N</em> 个结点。</li></ul><h1 id="并查集的实现"><a href="#并查集的实现" class="headerlink" title="并查集的实现"></a>并查集的实现</h1><h2 id="集合树："><a href="#集合树：" class="headerlink" title="集合树："></a>集合树：</h2><p>所有节点以代表节点为父节点构成的多叉树</p><h2 id="节点的代表节点："><a href="#节点的代表节点：" class="headerlink" title="节点的代表节点："></a>节点的代表节点：</h2><p>可以理解为节点的父节点，从当前节点出发，可以向上找到的第一个节点</p><h2 id="集合的代表节点："><a href="#集合的代表节点：" class="headerlink" title="集合的代表节点："></a>集合的代表节点：</h2><p>可以理解为根节点，意味着该集合内所有节点向上走，最终都能到达的节点</p><p>体到这个题上：<br>我们以这个边集合为例子[[1,2], [3,4], [3,2], [1,4], [1,5]]</p><p>一、首先，对于边集合edges的每个元素，我们将其看作两个节点集合</p><p>比如边[2, 3],我们将其看作节点集合2，和节点集合3</p><p>二、在没有添加边的时候，各个节点集合独立，我们需要初始化各个节点集合的代表节点为其自身</p><p>所以，我们先初始化一个容器vector，使得vector[i]=i。</p><p>这里两个i意思不同，作为索引的i是指当前节点，作为值的i是指当前节点所在集合的代表节点。</p><p>比如vector[2] = 2，意味着2这个节点所在集合的代表节点就是2，没有添加边的情况下，所有节点单独成集合，自身就是代表节点</p><p>三、然后我们开始遍历边集合，将边转化为集合的关系</p><p>这里有一点很重要：边[a,b]意味着a所在集合可以和b所在集合合并。</p><p>合并方法很多，这里我们简单地将a集合的代表节点戳到b集合的代表节点上。<br>这意味着，将b集合代表节点作为合并后大集合的代表节点。</p><p>对于一个集合的代表节点s，一定有s-&gt;s，意思是s如果是代表节点，那么它本身不存在代表节点</p><p>假设我们的读取顺序为[[1,2], [3,4], [3,2], [1,4], [1,5]]</p><p>初始化vector[0, 1, 2, 3, 4, 5]</p><p>对应的index [0, 1, 2, 3, 4, 5]</p><p>##########################################################################</p><p>1.读取[1,2]：</p><p>读取顺序为[[1,2], [3,4], [3,2], [1,4], [1,5]]</p><p>当前vector[0, 1, 2, 3, 4, 5]</p><p>当前index [0, 1, 2, 3, 4, 5]</p><p>原本1-&gt;1，2-&gt;2，</p><p>由1节点出发，vector[1]=1, 找到1所在集合的代表节点1</p><p>由2节点出发，vector[2]=2, 找到2所在集合的代表节点2</p><p>于是，将1的代表置为2，vector[1]=2, vector[2]=2</p><p>对应的vector[0, 2, 2, 3, 4, 5]</p><p>对应的index [0, 1, 2, 3, 4, 5]</p><p>##########################################################################</p><p>2.读取[3, 4]</p><p>读取顺序为[[1,2], [3,4], [3,2], [1,4], [1,5]]</p><p>当前vector[0, 2, 2, 3, 4, 5]</p><p>当前index [0, 1, 2, 3, 4, 5]</p><p>同理，将3所在集合的的代表节点3的代表节点置为4</p><p>对应的vector[0, 2, 2, 4, 4, 5]</p><p>对应的index [0, 1, 2, 3, 4, 5]</p><p>##########################################################################<br>3.读取[3, 2]</p><p>读取顺序为[[1,2], [3,4], [3,2], [1,4], [1,5]]</p><p>当前vector[0, 1, 2, 4, 4, 5]</p><p>当前index [0, 1, 2, 3, 4, 5]</p><p>从节点3出发，vector[3]=4, vector[4]=4,于是找到节点3所在集合的代表节点为4</p><p>从节点2出发，vector[2]=2, 找到节点2所在集合的代表节点为2</p><p>于是，将4的代表置为2，vector[4]=2, vector[2]=2</p><p>对应的vector[0, 2, 2, 4, 2, 5]</p><p>对应的index [0, 1, 2, 3, 4, 5]</p><p>##########################################################################<br>4.读取[1, 4]</p><p>读取顺序为[[1,2], [3,4], [3,2], [1,4], [1,5]]</p><p>当前vector[0, 2, 2, 4, 2, 5]</p><p>当前index [0, 1, 2, 3, 4, 5]</p><p>从节点1出发，vector[1]=2, vector[2]=2, 找到节点1所在集合代表节点为2</p><p>从节点4出发，vector[4]=2, vector[2]=2, 找到节点4所在集合代表节点为2</p><p>由于1和4的代表节点相同，说明这两个节点本身就在同一个集合中</p><p>由于原图是无向图，路径是双向可达的，1能够到达2,而且2能够到达4，再加上1能够到达4</p><p>说明1能通过两条路径到达4，,这也意味着这条边出现的时候，原图中一定出现了环</p><p>至于题中要求的，返回最后一条边，其实这就是返回添加过后会构成环的那一条边<br>直白解释就是，在这条边出现之前，图中没有环</p><p>这条边出现，图中也出现环。包括这条边在内，构成环的边都是满足破圈条件的边<br>然而谁是最后一条出现在边集合里的？当然，就是这条构成环的最后一条边<br>##########################################################################</p><pre><code>class Solution {public:    vector&lt;int&gt; findRedundantConnection(vector&lt;vector&lt;int&gt;&gt;&amp; edges) {        vector&lt;int&gt; rp(1001);        int sz = edges.size();        // 初始化各元素为单独的集合，代表节点就是其本身        for(int i=0;i&lt;sz;i++)            rp[i] = i;        for(int j=0;j&lt;sz;j++){            // 找到边上两个节点所在集合的代表节点            int set1 = find(edges[j][0], rp);            int set2 = find(edges[j][1], rp);            if(set1 == set2)  // 两个集合代表节点相同，说明出现环，返回答案                return edges[j];            else    // 两个集合独立，合并集合。将前一个集合代表节点戳到后一个集合代表节点上                rp[set1] = set2;        }        return {0, 0};    }    // 查找路径并返回代表节点，实际上就是给定当前节点，返回该节点所在集合的代表节点    // 之前这里写的压缩路径，引起歧义，因为结果没更新到vector里，所以这里改成路径查找比较合适    int find(int n, vector&lt;int&gt; &amp;rp){        int num = n;        while(rp[num] != num)            num = rp[num];        return num;    }};</code></pre><h1 id="Java实现并查集"><a href="#Java实现并查集" class="headerlink" title="Java实现并查集"></a>Java实现并查集</h1><p>对于同一棵树的所有节点来说，都拥有共同的祖先节点。</p><p>因此，判断冗余连接的条件即为，判断新加入的边，两个节点是否有共同的祖先。</p><p>（1）如果有共同的祖先，则说明这条边是冗余的边；</p><p>（2）如果没有共同的祖先，则说明这两条边并未加入树中，因此进行合并操作。<br>循环边的记录，获取最后出现的冗余边，就是答案。</p><pre><code>public static class UnionFind {    int[] parent;    int[] rank;    public UnionFind(int total) {        parent = new int[total];        rank = new int[total];        for (int i = 0; i &lt; total; i++) {            parent[i] = i;            rank[i] = 1;        }    }    public int find(int x) {        while (x != parent[x]) {            parent[x] = parent[parent[x]];            x = parent[x];        }        return x;    }    public void unionElements(int p, int q) {        int pRoot = find(p);        int qRoot = find(q);        if (pRoot == qRoot) {            return;        }        if (rank[pRoot] &lt; rank[qRoot]) {            parent[pRoot] = qRoot;        } else if (rank[pRoot] &gt; rank[qRoot]) {            parent[qRoot] = pRoot;        } else {            parent[pRoot] = qRoot;            rank[qRoot] += 1;        }    }}public int[] findRedundantConnection(int[][] edges) {    int[] res = new int[2];    UnionFind unionFind = new UnionFind(edges.length);    // 第一条边肯定未记录至树中，可直接合并节点    unionFind.unionElements(edges[0][0] - 1, edges[0][1] - 1);    for (int i = 1; i &lt; edges.length; i++) {        if (unionFind.find(edges[i][0] - 1) == unionFind.find(edges[i][1] - 1)) {            res[0] = edges[i][0];            res[1] = edges[i][1];        } else {            unionFind.unionElements(edges[i][0] - 1, edges[i][1] - 1);        }    }    return res;}</code></pre><h1 id="Map实现并查集（Java）"><a href="#Map实现并查集（Java）" class="headerlink" title="Map实现并查集（Java）"></a>Map实现并查集（Java）</h1><p>逻辑很简单，对每一条边：<br>1、如果两个顶点在不同的树上，则合并两个树<br>2、如果两个顶点在相同的树上，那么他们一定构成了闭环</p><p>为了提升效率，getRoot(并查集中的find)方法中对树进行了压缩</p><pre><code>class Solution {public int[] findRedundantConnection(int[][] edges) {    Map&lt;Integer, Integer&gt; cMap = new HashMap&lt;&gt;();    for (int i = 0; i &lt; edges.length; i++) {        int pi0 = getRoot(cMap, edges[i][0]);        int pi1 = getRoot(cMap, edges[i][1]);        if(pi0 != pi1){            cMap.put(pi0,pi1);        } else {            return edges[i];        }    }    return null;}private int getRoot(Map&lt;Integer, Integer&gt; parents, int i){    if(parents.get(i) == null){        parents.put(i, i);        return i;    }    if(parents.get(i) == i){        return i;    }    return getRoot(parents,parents.get(i));}}</code></pre><h1 id="证明-：给定一条新的边，两头节点在同一个集合，就意味着出现了环"><a href="#证明-：给定一条新的边，两头节点在同一个集合，就意味着出现了环" class="headerlink" title="证明    ：给定一条新的边，两头节点在同一个集合，就意味着出现了环"></a>证明    ：给定一条新的边，两头节点在同一个集合，就意味着出现了环</h1><p>#####################################################################<br>下面是增加的一部分证明，</p><p>证明一下为什么给定一条新的边，两头节点在同一个集合，就意味着出现了环</p><p>这里有个大前提，因为是无向图，集合里不会同时出现[1,2]和[2,1]这种重合边</p><p>上面的代码遇到集合里有重合边的情况是会出现误判的</p><p>就拿这个[1,2]和[2,1]来举例</p><p>给定[1,2]后，再读取[2,1]，两个节点在同一个集合，然而并没有出现环。</p><p>所以，这里代码工作的前提是不出现重合边<br>#####################################################################</p><p>下面回到最初的问题，为什么给定新边的两个节点在同一集合就意味着出现了环</p><p>假设给定新边的两个节点分别为5,6，新边为[5,6]</p><p>对于一条新出现的边，总共有两种情况，两个节点之一单独成集合，两个节点均不单独成集合</p><p>第一种情况，两个节点之一单独成集合</p><p>假设5单独成集合。这种情况下，两个节点不可能在一个集合里</p><p>因为有一个独立集合（只有节点5），6所在的集合和这个集合必然没有交集</p><p>之后这两个集合进行合并操作</p><p>直观点理解就是，5单独成集合，意味着5第一次出现在图里</p><p>这里只有新边和5相关，所以当前只给定一条和5相关的边，对5而言，就像只举起了一只手</p><p>要形成环，环上每个节点都必须是举起两只手的</p><p>所以这种情况下是不可能出现环的，程序中也是这样判定的</p><p>第二种情况，两个节点均不单独成集合</p><p>这里也可以细分为5和6是否作为该集合的代表节点</p><p>假设5所在集合代表节点为a</p><p>6所在集合代表节点也为a</p><p>2.1第一个分支，如果a不为5和6本身，那么就有5-&gt;…-&gt;a，6-&gt;…-&gt;a，路径双向可达</p><p>可以得到5-&gt;…-&gt;a-&gt;…-&gt;6,对于给定边[5,6]可得5-&gt;6</p><p>所以5到达6有两条路径，出现了环。</p><p>2.2第二个分支，a为5和6之一</p><p>假设，a为5</p><p>2.2.1 首先考虑，6直接指向5这种情况</p><p>出现这种情况，只能是在已经存在集合x-&gt;…-&gt;6时，出现[…,5]这样的边</p><p>其中，…为x-&gt;…-&gt;6路径上除6以外任意节点</p><p>此时…的代表节点为6，5的代表节点为5，合并，6戳到5上，于是出现了6直接指向5</p><p>这种情况下，已经存在6-&gt;…-&gt;5一条路径，再读取到[5,6]，环出现了</p><p>2.2.2 再考虑6不直接指向5的情况，就简单很多了，6-&gt;x-&gt;5</p><p>再读取到[5,6]，6可以通过两条路径到达5，出现环</p><p>综上，在边集合没有重合边的情况下，如果给定新边的两个节点在同一集合中，说明图中出现了环</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://leetcode-cn.com/problems/redundant-connection/solution/tong-su-jiang-jie-bing-cha-ji-bang-zhu-xiao-bai-ku/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/redundant-connection/solution/tong-su-jiang-jie-bing-cha-ji-bang-zhu-xiao-bai-ku/</a></p><p>【2】<a href="https://leetcode-cn.com/problems/redundant-connection/solution/bing-cha-ji-jie-jue-rong-yu-lian-jie-i-by-jxd134/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/redundant-connection/solution/bing-cha-ji-jie-jue-rong-yu-lian-jie-i-by-jxd134/</a></p><p>【3】<a href="https://leetcode-cn.com/problems/redundant-connection/solution/bing-cha-ji-mapshi-xian-de-ling-lei-bing-cha-ji-by/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/redundant-connection/solution/bing-cha-ji-mapshi-xian-de-ling-lei-bing-cha-ji-by/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用并查集找到一条可以删去的边。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年5月" scheme="http://yoursite.com/categories/2020%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Union Find" scheme="http://yoursite.com/tags/Union-Find/"/>
    
      <category term="Graph" scheme="http://yoursite.com/tags/Graph/"/>
    
  </entry>
  
</feed>
