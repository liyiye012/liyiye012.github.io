<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-12-31T09:32:19.163Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Effctive-Java阅读笔记III</title>
    <link href="http://yoursite.com/2019/12/31/Effctive-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0III/"/>
    <id>http://yoursite.com/2019/12/31/Effctive-Java阅读笔记III/</id>
    <published>2019-12-31T07:06:12.000Z</published>
    <updated>2019-12-31T09:32:19.163Z</updated>
    
    <content type="html"><![CDATA[<p>第二章阅读：创建和销毁对象<br>05.依赖注入优于硬连接资源（hardwiring resources）<br>06.避免创建不必要的对象</p><a id="more"></a><h1 id="依赖注入优于硬连接资源（hardwiring-resources）"><a href="#依赖注入优于硬连接资源（hardwiring-resources）" class="headerlink" title="依赖注入优于硬连接资源（hardwiring resources）"></a>依赖注入优于硬连接资源（hardwiring resources）</h1><p>　许多类依赖于一个或多个底层资源。例如，拼写检查器依赖于字典。将此类类实现为静态工具类并不少见 （详见第 4 条）:</p><pre><code>// Inappropriate use of static utility - inflexible &amp; untestable!public class SpellChecker {    private static final Lexicon dictionary = ...;    private SpellChecker() {} // Noninstantiable    public static boolean isValid(String word) { ... }    public static List&lt;String&gt; suggestions(String typo) { ... }}</code></pre><p>同样地，将它们实现为单例的做法也并不少见（详见第 3 条）：</p><pre><code>// Inappropriate use of singleton - inflexible &amp; untestable!public class SpellChecker {    private final Lexicon dictionary = ...;    private SpellChecker(...) {}    public static INSTANCE = new SpellChecker(...);    public boolean isValid(String word) { ... }    public List&lt;String&gt; suggestions(String typo) { ... }}</code></pre><p>这两种方法都不令人满意，因为他们都是假设只有一本字典可用。实际上，每种语言都有自己的字典，特殊的字典被用于特殊的词汇表。另外，可能还需要用特殊的词典进行测试。想当然地认为一本字典就足够了，这是一厢情愿的想法。</p><p>　　可以通过使 dictionary 属性设置为非final，final关键字修饰的成员变量是常量，修饰的类不能被继承。修饰的成员方法是不能被子类重写的。并添加一个方法来更改现有拼写检查器中的字典，从而让SpellChecker 支持多个字典，但是这样的设置显得非常笨拙、容易出错、并且无法并行工作。静态工具类和单例类不适合与需要引用底层资源的类。</p><p>　　这里所需要的是能够支持类的多个实例 （在我们的示例中是指 SpellChecker），每个实例都使用客户端所期望的资源（在我们的例子中是 dictionary）。满足这一需求的简单模式是，在创建新实例时将资源传递到构造器中。 这是依赖项注入（dependency injection）的一种形式：字典是拼写检查器的一个依赖项，当它创建时被注入到拼写检查器中。</p><pre><code>// Dependency injection provides flexibility and testabilitypublic class SpellChecker {    private final Lexicon dictionary;    public SpellChecker(Lexicon dictionary) {        this.dictionary = Objects.requireNonNull(dictionary);    }    public boolean isValid(String word) { ... }    public List&lt;String&gt; suggestions(String typo) { ... }}</code></pre><p>　　依赖注入模式非常简单，许多程序员使用它多年而不知道它有一个名字。 虽然我们的拼写检查器的例子只有一个资源（字典），但是依赖项注入可以使用任意数量的资源和任意依赖图。 它保持了不变性（详见第 17 条），因此多个客户端可以共享依赖对象（假设客户需要相同的底层资源）。 依赖注入同样适用于构造器、静态工厂（详见第 1 条）和 builder 模式（详见第 2 条）。</p><p>　　该模式的一个有用的变体是将资源工厂传递给构造器。 工厂是可以重复调用以创建类型实例的对象。 这种工厂体现了工厂方法模式（Factory Method pattern）[Gamma95]。 Java 8 中引入的 Supplier<t> 接口非常适合代表工厂。 在输入上采用 Supplier<t> 的方法通常应该使用有界的通配符类型（bounded wildcard type）（详见第 31 条）约束工厂的类型参数，以便客户端能够传入一个工厂，来创建指定类型的任意子类型。例如，下面是一个生产马赛克的方法，它利用客户端提供的工厂来生产每一片马赛克：</t></t></p><pre><code>Mosaic create(Supplier&lt;? extends Tile&gt; tileFactory) { ... }</code></pre><p>　　尽管依赖注入极大地提高了灵活性和可测试性，但它可能使大型项目变得混乱，这些项目通常包含数千个依赖项。使用依赖注入框架（如 Dagger [Dagger]、Guice [Guice] 或 Spring [Spring]）可以消除这些混乱。这些框架的使用超出了本书的范围，但是请注意，为手动依赖注入而设计的 API 非常适合这些框架的使用。</p><p>　　总而言之，不要用单例和静态工具类来实现依赖一个或多个底层资源的类，且该资源的行为会影响到该类的行为；也不要直接用这个类来创建这些资源。而应该将这些资源或者工厂传给构造器（或者静态工厂，或者构建器），通过它们来创建类。这个实践就被称作依赖注人，它极大地提升了类的灵活性、可重用性和可测试性。</p><h1 id="避免创建不必要的对象"><a href="#避免创建不必要的对象" class="headerlink" title="避免创建不必要的对象"></a>避免创建不必要的对象</h1><p>　通过使用静态工厂方法（详见第 1 条）和构造器，可以避免创建不需要的对象。例如，工厂方法 Boolean.valueOf(String) 比构造方法 Boolean(String) 更可取，后者在 Java 9 中被弃用。构造方法每次调用时都必须创建一个新对象，而工厂方法永远不需要这样做，在实践中也不需要。除了重用不可变对象，如果知道它们不会被修改，还可以重用可变对象。<br>一些对象的创建比其他对象的创建要昂贵得多。 如果要重复使用这样一个「昂贵的对象」，建议将其缓存起来以便重复使用。 不幸的是，当创建这样一个对象时并不总是很直观明显的。 假设你想写一个方法来确定一个字符串是否是一个有效的罗马数字。 以下是使用正则表达式完成此操作时最简单方法：</p><pre><code>// Performance can be greatly improved!static boolean isRomanNumeral(String s) {    return s.matches(&quot;^(?=.)M*(C[MD]|D?C{0,3})&quot;            + &quot;(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$&quot;);}</code></pre><p>这个实现的问题在于它依赖于 String.matches 方法。 虽然 String.matches 是检查字符串是否与正则表达式匹配的最简单方法，但它不适合在性能临界的情况下重复使用。 问题是它在内部为正则表达式创建一个 Pattern 实例，并且只使用它一次，之后它就有资格进行垃圾收集。 创建 Pattern 实例是昂贵的，因为它需要将正则表达式编译成有限状态机（finite state machine）。</p><p>　　为了提高性能，作为类初始化的一部分，将正则表达式显式编译为一个 Pattern 实例（不可变），缓存它，并在 isRomanNumeral 方法的每个调用中重复使用相同的实例：</p><pre><code>// Reusing expensive object for improved performancepublic class RomanNumerals {    private static final Pattern ROMAN = Pattern.compile(            &quot;^(?=.)M*(C[MD]|D?C{0,3})&quot;            + &quot;(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$&quot;);    static boolean isRomanNumeral(String s) {        return ROMAN.matcher(s).matches();    }}</code></pre><p>如果经常调用，isRomanNumeral 的改进版本的性能会显著提升。</p><p>　　如果包含 isRomanNumeral 方法的改进版本的类被初始化，但该方法从未被调用，则 ROMAN 属性则没必要初始化。 在第一次调用 isRomanNumeral 方法时，可以通过延迟初始化（ lazily initializing）属性（详见第 83 条）来排除初始化，但一般不建议这样做。 延迟初始化常常会导致实现复杂化，而性能没有可衡量的改进（详见第 67 条）。</p><p>　　当一个对象是不可变的时，很明显它可以被安全地重用，但是在其他情况下，它远没有那么明显，甚至是违反直觉的。考虑适配器（adapters）的情况[Gamma95]，也称为视图（views）。一个适配器是一个对象，它委托一个支持对象（backing object），提供一个可替代的接口。由于适配器没有超出其支持对象的状态，因此不需要为给定对象创建多个给定适配器的实例。</p><p>例如，Map 接口的 keySet 方法返回 Map 对象的 Set 视图，包含 Map 中的所有 key。 天真地说，似乎每次调用 keySet 都必须创建一个新的 Set 实例，但是对给定 Map 对象的 keySet 的每次调用都返回相同的 Set 实例。 尽管返回的 Set 实例通常是可变的，但是所有返回的对象在功能上都是相同的：当其中一个返回的对象发生变化时，所有其他对象也都变化，因为它们全部由相同的 Map 实例支持。 虽然创建 keySet 视图对象的多个实例基本上是无害的，但这是没有必要的，也没有任何好处。</p><p>　　另一种创建不必要的对象的方法是自动装箱（auto boxing），它允许程序员混用基本类型和包装的基本类型，根据需要自动装箱和拆箱。 自动装箱模糊不清，但不会消除基本类型和装箱基本类型之间的区别。 有微妙的语义区别和不那么细微的性能差异（详见第 61 条）。 考虑下面的方法，它计算所有正整数的总和。 要做到这一点，程序必须使用 long 类型，因为 int 类型不足以保存所有正整数的总和：</p><pre><code>// Hideously slow! Can you spot the object creation?private static long sum() {    Long sum = 0L;    for (long i = 0; i &lt;= Integer.MAX_VALUE; i++)        sum += i;    return sum;}</code></pre><p>这个程序的结果是正确的，但由于写错了一个字符，运行的结果要比实际慢很多。变量 sum 被声明成了 Long 而不是 long，这意味着程序构造了大约 231 不必要的 Long 实例（大约每次往 Long 类型的 sum 变量中增加一个 long 类型构造的实例），把 sum 变量的类型由 Long 改为 long。这个教训很明显：优先使用基本类型而不是装箱的基本类型，也要注意无意识的自动装箱。</p><p>　　这个条目不应该被误解为暗示对象创建是昂贵的，应该避免创建对象。 相反，使用构造方法创建和回收小的对象是非常廉价，构造方法只会做很少的显示工作，尤其是在现代 JVM 实现上。 创建额外的对象以增强程序的清晰度，简单性或功能性通常是件好事。</p><p>　　相反，除非池中的对象非常重量级，否则通过维护自己的对象池来避免对象创建是一个坏主意。对象池的典型例子就是数据库连接。建立连接的成本非常高，因此重用这些对象是有意义的。但是，一般来说，维护自己的对象池会使代码混乱，增加内存占用，并损害性能。现代 JVM 实现具有高度优化的垃圾收集器，它们在轻量级对象上轻松胜过此类对象池。</p><p>　　这个条目的对应点是针对条目 50 的防御性复制（defensive copying）。 目前的条目说：「当你应该重用一个现有的对象时，不要创建一个新的对象」，而条目 50 说：「不要重复使用现有的对象，当你应该创建一个新的对象时。」请注意，重用防御性复制所要求的对象所付出的代价，要远远大于不必要地创建重复的对象。 未能在需要的情况下防御性复制会导致潜在的错误和安全漏洞；而不必要地创建对象只会影响程序的风格和性能。</p><p>#参考资料<br>[1] <a href="https://sjsdfg.github.io/effective-java-3rd-chinese/#/notes/05.%20%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E4%BC%98%E4%BA%8E%E7%A1%AC%E8%BF%9E%E6%8E%A5%E8%B5%84%E6%BA%90(hardwiring%20resources)" target="_blank" rel="noopener">https://sjsdfg.github.io/effective-java-3rd-chinese/#/notes/05.%20%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E4%BC%98%E4%BA%8E%E7%A1%AC%E8%BF%9E%E6%8E%A5%E8%B5%84%E6%BA%90(hardwiring%20resources)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二章阅读：创建和销毁对象&lt;br&gt;05.依赖注入优于硬连接资源（hardwiring resources）&lt;br&gt;06.避免创建不必要的对象&lt;/p&gt;
    
    </summary>
    
      <category term="2019年12月" scheme="http://yoursite.com/categories/2019%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Design Pattern，Java" scheme="http://yoursite.com/tags/Design-Pattern%EF%BC%8CJava/"/>
    
  </entry>
  
  <entry>
    <title>Effctive-Java阅读笔记IV</title>
    <link href="http://yoursite.com/2019/12/31/Effctive-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0IV/"/>
    <id>http://yoursite.com/2019/12/31/Effctive-Java阅读笔记IV/</id>
    <published>2019-12-31T07:06:12.000Z</published>
    <updated>2020-01-02T02:02:08.943Z</updated>
    
    <content type="html"><![CDATA[<p>第二章阅读：创建和销毁对象<br>07.消除过期的对象引用<br>08.避免使用 Finalizer 和 Cleaner 机制<br><a id="more"></a></p><h1 id="消除过期的对象引用"><a href="#消除过期的对象引用" class="headerlink" title="消除过期的对象引用"></a>消除过期的对象引用</h1><p>如果你从使用手动内存管理的语言（如 C 或 C++）切换到像 Java 这样的带有垃圾收集机制的语言，那么作为程序员的工作就会变得容易多了，因为你的对象在使用完毕以后就自动回收了。当你第一次体验它的时候，它就像魔法一样。这很容易让人觉得你不需要考虑内存管理，但这并不完全正确。</p><pre><code>// Can you spot the &quot;memory leak&quot;?public class Stack {    private Object[] elements;    private int size = 0;    private static final int DEFAULT_INITIAL_CAPACITY = 16;    public Stack() {        elements = new Object[DEFAULT_INITIAL_CAPACITY];    }    public void push(Object e) {        ensureCapacity();        elements[size++] = e;    }    public Object pop() {        if (size == 0)            throw new EmptyStackException();        return elements[--size];    }    /**     * Ensure space for at least one more element, roughly     * doubling the capacity each time the array needs to grow.     ** /    private void ensureCapacity() {        if (elements.length == size)            elements = Arrays.copyOf(elements, 2 * size + 1);    }}</code></pre><p>这个程序没有什么明显的错误（但是对于泛型版本，请参阅条目 29）。 你可以对它进行详尽的测试，它都会成功地通过每一项测试，但有一个潜在的问题。 笼统地说，程序有一个「内存泄漏」，由于垃圾回收器的活动的增加，或内存占用的增加，静默地表现为性能下降。 在极端的情况下，这样的内存泄漏可能会导致磁盘分页（disk paging），甚至导致内存溢出（OutOfMemoryError）的失败，但是这样的故障相对较少。</p><p>　　那么哪里发生了内存泄漏？ 如果一个栈增长后收缩，那么从栈弹出的对象不会被垃圾收集，即使使用栈的程序不再引用这些对象。 这是因为栈维护对这些对象的过期引用（obsolete references）。 过期引用简单来说就是永远不会解除的引用。 在这种情况下，元素数组「活动部分（active portion）」之外的任何引用都是过期的。 活动部分是由索引下标小于 size 的元素组成。</p><p>　　垃圾收集语言中的内存泄漏（更适当地称为无意的对象保留 unintentional object retentions）是隐蔽的。 如果无意中保留了对象引用，那么不仅这个对象排除在垃圾回收之外，而且该对象引用的任何对象也是如此。 即使只有少数对象引用被无意地保留下来，也可以阻止垃圾回收机制对许多对象的回收，这对性能产生很大的影响。</p><p>　　这类问题的解决方法很简单：一旦对象引用过期，将它们设置为 null。 在我们的 Stack 类的情景下，只要从栈中弹出，元素的引用就设置为过期。 pop 方法的修正版本如下所示：</p><pre><code>public Object pop() {    if (size == 0)        throw new EmptyStackException();    Object result = elements[--size];    elements[size] = null; // Eliminate obsolete reference    return result;}</code></pre><p>取消过期引用的另一个好处是，如果它们随后被错误地引用，程序立即抛出 NullPointerException 异常，而不是悄悄地做继续做错误的事情。尽可能快地发现程序中的错误是有好处的。</p><p>　　当程序员第一次被这个问题困扰时，他们可能会在程序结束后立即清空所有对象引用。这既不是必要的，也不是可取的；它不必要地搞乱了程序。清空对象引用应该是例外而不是规范。消除过期引用的最好方法是让包含引用的变量超出范围。如果在最近的作用域范围内定义每个变量 （详见第 57 条），这种自然就会出现这种情况。</p><p>　　那么什么时候应该清空一个引用呢？Stack 类的哪个方面使它容易受到内存泄漏的影响？简单地说，它管理自己的内存。存储池（storage pool）由 elements 数组的元素组成（对象引用单元，而不是对象本身）。数组中活动部分的元素 (如前面定义的) 被分配，其余的元素都是空闲的。垃圾收集器没有办法知道这些；对于垃圾收集器来说，elements 数组中的所有对象引用都同样有效。只有程序员知道数组的非活动部分不重要。程序员可以向垃圾收集器传达这样一个事实，一旦数组中的元素变成非活动的一部分，就可以手动清空这些元素的引用。</p><p>　　一般来说，当一个类自己管理内存时，程序员应该警惕内存泄漏问题。 每当一个元素被释放时，元素中包含的任何对象引用都应该被清除。</p><p>　　另一个常见的内存泄漏来源是缓存。 一旦将对象引用放入缓存中，很容易忘记它的存在，并且在它变得无关紧要之后，仍然保留在缓存中。对于这个问题有几种解决方案。如果你正好想实现了一个缓存：只要在缓存之外存在对某个项（entry）的键（key）引用，那么这项就是明确有关联的，就可以用 WeakHashMap 来表示缓存；这些项在过期之后自动删除。记住，只有当缓存中某个项的生命周期是由外部引用到键（key）而不是值（value）决定时，WeakHashMap 才有用。</p><p>　　更常见的情况是，缓存项有用的生命周期不太明确，随着时间的推移一些项变得越来越没有价值。在这种情况下，缓存应该偶尔清理掉已经废弃的项。这可以通过一个后台线程 (也许是 ScheduledThreadPoolExecutor) 或将新的项添加到缓存时顺便清理。LinkedHashMap 类使用它的 removeEldestEntry 方法实现了后一种方案。对于更复杂的缓存，可能直接需要使用 java.lang.ref。</p><p>　　第三个常见的内存泄漏来源是监听器和其他回调。如果你实现了一个 API，其客户端注册回调，但是没有显式地撤销注册回调，除非采取一些操作，否则它们将会累积。确保回调是垃圾收集的一种方法是只存储弱引用（weak references），例如，仅将它们保存在 WeakHashMap 的键（key）中。</p><p>　　因为内存泄漏通常不会表现为明显的故障，所以它们可能会在系统中保持多年。 通常仅在仔细的代码检查或借助堆分析器（heap profiler）的调试工具才会被发现。 因此，学习如何预见这些问题，并防止这些问题发生，是非常值得的。</p><h1 id="避免使用-Finalizer-和-Cleaner-机制"><a href="#避免使用-Finalizer-和-Cleaner-机制" class="headerlink" title="避免使用 Finalizer 和 Cleaner 机制"></a>避免使用 Finalizer 和 Cleaner 机制</h1><p>Finalizer 机制是不可预知的，往往是危险的，而且通常是不必要的。 它们的使用会导致不稳定的行为，糟糕的性能和移植性问题。 Finalizer 机制有一些特殊的用途，我们稍后会在这个条目中介绍，但是通常应该避免它们。 从 Java 9 开始，Finalizer 机制已被弃用，但仍被 Java 类库所使用。 Java 9 中 Cleaner 机制代替了 Finalizer 机制。 Cleaner 机制不如 Finalizer 机制那样危险，但仍然是不可预测，运行缓慢并且通常是不必要的。</p><p>　　提醒 C++程序员不要把 Java 中的 Finalizer 或 Cleaner 机制当成的 C++ 析构函数的等价物。 在 C++ 中，析构函数是回收对象相关资源的正常方式，是与构造方法相对应的。 在 Java 中，当一个对象变得不可达时，垃圾收集器回收与对象相关联的存储空间，不需要开发人员做额外的工作。 C++ 析构函数也被用来回收其他非内存资源。 在 Java 中，try-with-resources 或 try-finally 块用于此目的（详见第 9 条）。</p><p>　　Finalizer 和 Cleaner 机制的一个缺点是不能保证他们能够及时执行[JLS，12.6]。 在一个对象变得无法访问时，到 Finalizer 和 Cleaner 机制开始运行时，这期间的时间是任意长的。 这意味着你永远不应该 Finalizer 和 Cleaner 机制做任何时间敏感（time-critical）的事情。 例如，依赖于 Finalizer 和 Cleaner 机制来关闭文件是严重的错误，因为打开的文件描述符是有限的资源。 如果由于系统迟迟没有运行 Finalizer 和 Cleaner 机制而导致许多文件被打开，程序可能会失败，因为它不能再打开文件了。</p><p>　　及时执行 Finalizer 和 Cleaner 机制是垃圾收集算法的一个功能，这种算法在不同的实现中有很大的不同。程序的行为依赖于 Finalizer 和 Cleaner 机制的及时执行，其行为也可能大不不同。 这样的程序完全可以在你测试的 JVM 上完美运行，然而在你最重要的客户的机器上可能运行就会失败。</p><p>　　延迟终结（finalization）不只是一个理论问题。为一个类提供一个 Finalizer 机制可以任意拖延它的实例的回收。一位同事调试了一个长时间运行的 GUI 应用程序，这个应用程序正在被一个 OutOfMemoryError 错误神秘地死掉。分析显示，在它死亡的时候，应用程序的 Finalizer 机制队列上有成千上万的图形对象正在等待被终结和回收。不幸的是，Finalizer 机制线程的运行优先级低于其他应用程序线程，所以对象被回收的速度低于进入队列的速度。语言规范并不保证哪个线程执行 Finalizer 机制，因此除了避免使用 Finalizer 机制之外，没有轻便的方法来防止这类问题。在这方面， Cleaner 机制比 Finalizer 机制要好一些，因为 Java 类的创建者可以控制自己 cleaner 机制的线程，但 cleaner 机制仍然在后台运行，在垃圾回收器的控制下运行，但不能保证及时清理。</p><p>　　Java 规范不能保证 Finalizer 和 Cleaner 机制能及时运行；它甚至不能能保证它们是否会运行。当一个程序结束后，一些不可达对象上的 Finalizer 和 Cleaner 机制仍然没有运行。因此，不应该依赖于 Finalizer 和 Cleaner 机制来更新持久化状态。例如，依赖于 Finalizer 和 Cleaner 机制来释放对共享资源（如数据库）的持久锁，这是一个使整个分布式系统陷入停滞的好方法。</p><p>　　不要相信 System.gc 和 System.runFinalization 方法。 他们可能会增加 Finalizer 和 Cleaner 机制被执行的几率，但不能保证一定会执行。 曾经声称做出这种保证的两个方法：System.runFinalizersOnExit 和它的孪生兄弟 Runtime.runFinalizersOnExit，包含致命的缺陷，并已被弃用了几十年[ThreadStop]。</p><p>　　Finalizer 机制的另一个问题是在执行 Finalizer 机制过程中，未捕获的异常会被忽略，并且该对象的 Finalizer 机制也会终止 [JLS, 12.6]。未捕获的异常会使其他对象陷入一种损坏的状态（corrupt state）。如果另一个线程试图使用这样一个损坏的对象，可能会导致任意不确定的行为。通常情况下，未捕获的异常将终止线程并打印堆栈跟踪（ stacktrace），但如果发生在 Finalizer 机制中，则不会发出警告。Cleaner 机制没有这个问题，因为使用 Cleaner 机制的类库可以控制其线程。</p><p>　　使用 finalizer 和 cleaner 机制会导致严重的性能损失。 在我的机器上，创建一个简单的 AutoCloseable 对象，使用 try-with-resources 关闭它，并让垃圾回收器回收它的时间大约是 12 纳秒。 使用 finalizer 机制，而时间增加到 550 纳秒。 换句话说，使用 finalizer 机制创建和销毁对象的速度要慢 50 倍。 这主要是因为 finalizer 机制会阻碍有效的垃圾收集。 如果使用它们来清理类的所有实例（在我的机器上的每个实例大约是 500 纳秒），那么 cleaner 机制的速度与 finalizer 机制的速度相当，但是如果仅将它们用作安全网（safety net），则 cleaner 机制要快得多，如下所述。 在这种环境下，创建，清理和销毁一个对象在我的机器上需要大约 66 纳秒，这意味着如果你不使用安全网的话，需要支付 5 倍（而不是 50 倍）的保险。</p><p>　　finalizer 机制有一个严重的安全问题：它们会打开你的类来进行 finalizer 机制攻击。finalizer 机制攻击的想法很简单：如果一个异常是从构造方法或它的序列化中抛出的——readObject 和 readResolve 方法 （第 12 章）——恶意子类的 finalizer 机制可以运行在本应该「中途夭折（died on the vine）」的部分构造对象上。finalizer 机制可以在静态字属性记录对对象的引用，防止其被垃圾收集。一旦记录了有缺陷的对象，就可以简单地调用该对象上的任意方法，而这些方法本来就不应该允许存在。从构造方法中抛出异常应该足以防止对象出现；而在 finalizer 机制存在下，则不是。这样的攻击会带来可怕的后果。Final 类不受 finalizer 机制攻击的影响，因为没有人可以编写一个 final 类的恶意子类。为了保护非 final 类不受 finalizer 机制攻击，编写一个 final 的 finalize 方法，它什么都不做。</p><p>　　那么，你应该怎样做呢？为对象封装需要结束的资源（如文件或线程），而不是为该类编写 Finalizer 和 Cleaner 机制？让你的类实现 AutoCloseable 接口即可，并要求客户在在不再需要时调用每个实例 close 方法，通常使用 try-with-resources 确保终止，即使面对有异常抛出情况（详见第 9 条）。一个值得一提的细节是实例必须跟踪是否已经关闭：close 方法必须记录在对象里不再有效的属性，其他方法必须检查该属性，如果在对象关闭后调用它们，则抛出 IllegalStateException 异常。</p><p>　　那么，Finalizer 和 Cleaner 机制有什么好处呢？它们可能有两个合法用途。一个是作为一个安全网（safety net），以防资源的拥有者忽略了它的 close 方法。虽然不能保证 Finalizer 和 Cleaner 机制会迅速运行 (或者根本就没有运行)，最好是把资源释放晚点出来，也要好过客户端没有这样做。如果你正在考虑编写这样的安全网 Finalizer 机制，请仔细考虑一下这样保护是否值得付出对应的代价。一些 Java 库类，如 FileInputStream、FileOutputStream、ThreadPoolExecutor 和 java.sql.Connection，都有作为安全网的 Finalizer 机制。</p><p>　　第二种合理使用 Cleaner 机制的方法与本地对等类（native peers）有关。本地对等类是一个由普通对象委托的本地 (非 Java) 对象。由于本地对等类不是普通的 Java 对象，所以垃圾收集器并不知道它，当它的 Java 对等对象被回收时，本地对等类也不会回收。假设性能是可以接受的，并且本地对等类没有关键的资源，那么 Finalizer 和 Cleaner 机制可能是这项任务的合适的工具。但如果性能是不可接受的，或者本地对等类持有必须迅速回收的资源，那么类应该有一个 close 方法，正如前面所述。</p><p>　　Cleaner 机制使用起来有点棘手。下面是演示该功能的一个简单的 Room 类。假设 Room 对象必须在被回收前清理干净。Room 类实现 AutoCloseable 接口；它的自动清理安全网使用的是一个 Cleaner 机制，这仅仅是一个实现细节。与 Finalizer 机制不同，Cleaner 机制不污染一个类的公共 API：</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二章阅读：创建和销毁对象&lt;br&gt;07.消除过期的对象引用&lt;br&gt;08.避免使用 Finalizer 和 Cleaner 机制&lt;br&gt;
    
    </summary>
    
      <category term="2019年12月" scheme="http://yoursite.com/categories/2019%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Design Pattern，Java" scheme="http://yoursite.com/tags/Design-Pattern%EF%BC%8CJava/"/>
    
  </entry>
  
  <entry>
    <title>Java开发规范</title>
    <link href="http://yoursite.com/2019/12/31/Java%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    <id>http://yoursite.com/2019/12/31/Java开发规范/</id>
    <published>2019-12-31T07:06:12.000Z</published>
    <updated>2020-01-02T09:41:13.703Z</updated>
    
    <content type="html"><![CDATA[<p>常见的开发规范</p><a id="more"></a><h1 id="编程规约"><a href="#编程规约" class="headerlink" title="编程规约"></a>编程规约</h1><h2 id="【强制】-代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。"><a href="#【强制】-代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。" class="headerlink" title="【强制】 代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。"></a>【强制】 代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。</h2><p>反例： <em>name / __name / $Object / name</em> / name$ / Object$</p><h2 id="【强制】-代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。"><a href="#【强制】-代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。" class="headerlink" title="【强制】 代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。"></a>【强制】 代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。</h2><p>说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式<br>也要避免采用。</p><p>反例： DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3<br>正例： alibaba / taobao / youku / hangzhou 等国际通用的名称，可视同英文。</p><h2 id="【强制】类名使用-UpperCamelCase-风格，必须遵从驼峰形式，但以下情形例外：（领域模型的相关命名）DO-BO-DTO-VO-等。"><a href="#【强制】类名使用-UpperCamelCase-风格，必须遵从驼峰形式，但以下情形例外：（领域模型的相关命名）DO-BO-DTO-VO-等。" class="headerlink" title="【强制】类名使用 UpperCamelCase 风格，必须遵从驼峰形式，但以下情形例外：（领域模型的相关命名）DO / BO / DTO / VO 等。"></a>【强制】类名使用 UpperCamelCase 风格，必须遵从驼峰形式，但以下情形例外：（领域模型的相关命名）DO / BO / DTO / VO 等。</h2><p>正例：MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion<br>反例：macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion</p><h2 id="【强制】方法名、参数名、成员变量、局部变量都统一使用-lowerCamelCase-风格，必须遵从驼峰形式。"><a href="#【强制】方法名、参数名、成员变量、局部变量都统一使用-lowerCamelCase-风格，必须遵从驼峰形式。" class="headerlink" title="【强制】方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。"></a>【强制】方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。</h2><p>正例： localValue / getHttpMessage() / inputUserId</p><h2 id="【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。"><a href="#【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。" class="headerlink" title="【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。"></a>【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。</h2><p>正例： MAX_STOCK_COUNT<br>反例： MAX_COUNT</p><h2 id="【强制】抽象类命名使用-Abstract-或-Base-开头；异常类命名使用-Exception-结尾；测试类命名以它要测试的类的名称开始，以-Test-结尾。"><a href="#【强制】抽象类命名使用-Abstract-或-Base-开头；异常类命名使用-Exception-结尾；测试类命名以它要测试的类的名称开始，以-Test-结尾。" class="headerlink" title="【强制】抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾。"></a>【强制】抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾。</h2><h2 id="【强制】中括号是数组类型的一部分，数组定义如下：String-args"><a href="#【强制】中括号是数组类型的一部分，数组定义如下：String-args" class="headerlink" title="【强制】中括号是数组类型的一部分，数组定义如下：String[] args;"></a>【强制】中括号是数组类型的一部分，数组定义如下：String[] args;</h2><p>反例：请勿使用 String args[]的方式来定义。</p><h2 id="【强制】POJO-类中布尔类型的变量，都不要加-is，否则部分框架解析会引起序列化错误。"><a href="#【强制】POJO-类中布尔类型的变量，都不要加-is，否则部分框架解析会引起序列化错误。" class="headerlink" title="【强制】POJO 类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。"></a>【强制】POJO 类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。</h2><p>反例：定义为基本数据类型 boolean isSuccess；的属性，它的方法也是 isSuccess()，RPC<br>框架在反向解析的时候，“以为”对应的属性名称是 success，导致属性获取不到，进而抛出异<br>常。</p><h2 id="【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。"><a href="#【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。" class="headerlink" title="【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。"></a>【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。</h2><p>正例： 应用工具类包名为 com.alibaba.open.util、类名为 MessageUtils（此规则参考<br>spring 的框架结构）</p><h2 id="【强制】杜绝完全不规范的缩写，避免望文不知义。"><a href="#【强制】杜绝完全不规范的缩写，避免望文不知义。" class="headerlink" title="【强制】杜绝完全不规范的缩写，避免望文不知义。"></a>【强制】杜绝完全不规范的缩写，避免望文不知义。</h2><p>反例： AbstractClass“缩写”命名成 AbsClass；condition“缩写”命名成 condi，此类<br>随意缩写严重降低了代码的可阅读性。</p><h2 id="【推荐】如果使用到了设计模式，建议在类名中体现出具体模式。"><a href="#【推荐】如果使用到了设计模式，建议在类名中体现出具体模式。" class="headerlink" title="【推荐】如果使用到了设计模式，建议在类名中体现出具体模式。"></a>【推荐】如果使用到了设计模式，建议在类名中体现出具体模式。</h2><p>说明：将设计模式体现在名字中，有利于阅读者快速理解架构设计思想。<br>正例：public class OrderFactory;<br>public class LoginProxy;<br>public class ResourceObserver;</p><h2 id="【推荐】接口类中的方法和属性不要加任何修饰符号（public-也不要加），保持代码的简洁性，并加上有效的-Javadoc-注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。"><a href="#【推荐】接口类中的方法和属性不要加任何修饰符号（public-也不要加），保持代码的简洁性，并加上有效的-Javadoc-注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。" class="headerlink" title="【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。"></a>【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。</h2><p>正例：接口方法签名：void f();<br>接口基础常量表示：String COMPANY = “alibaba”;<br>反例：接口方法定义：public abstract void f();<br>说明：JDK8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默<br>认实现。</p><h2 id="接口和实现类的命名有两套规则："><a href="#接口和实现类的命名有两套规则：" class="headerlink" title="接口和实现类的命名有两套规则："></a>接口和实现类的命名有两套规则：</h2><h3 id="【强制】对于-Service-和-DAO-类，基于-SOA-的理念，暴露出来的服务一定是接口，内部的实现类用-Impl-的后缀与接口区别。"><a href="#【强制】对于-Service-和-DAO-类，基于-SOA-的理念，暴露出来的服务一定是接口，内部的实现类用-Impl-的后缀与接口区别。" class="headerlink" title="【强制】对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部的实现类用 Impl 的后缀与接口区别。"></a>【强制】对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部的实现类用 Impl 的后缀与接口区别。</h3><p>正例：CacheServiceImpl 实现 CacheService 接口。</p><h3 id="【推荐】如果是形容能力的接口名称，取对应的形容词做接口名（通常是–able-的形式）。"><a href="#【推荐】如果是形容能力的接口名称，取对应的形容词做接口名（通常是–able-的形式）。" class="headerlink" title="【推荐】如果是形容能力的接口名称，取对应的形容词做接口名（通常是–able 的形式）。"></a>【推荐】如果是形容能力的接口名称，取对应的形容词做接口名（通常是–able 的形式）。</h3><p>正例：AbstractTranslator 实现 Translatable。</p><h2 id="【参考】枚举类名建议带上-Enum-后缀，枚举成员名称需要全大写，单词间用下划线隔开。"><a href="#【参考】枚举类名建议带上-Enum-后缀，枚举成员名称需要全大写，单词间用下划线隔开。" class="headerlink" title="【参考】枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。"></a>【参考】枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。</h2><p>说明：枚举其实就是特殊的常量类，且构造方法被默认强制是私有。<br>正例：枚举名字：DealStatusEnum，成员名称：SUCCESS / UNKOWN_REASON。</p><p>##【参考】各层命名规约：</p><h3 id="Service-DAO-层方法命名规约"><a href="#Service-DAO-层方法命名规约" class="headerlink" title="Service/DAO 层方法命名规约"></a>Service/DAO 层方法命名规约</h3><p>1） 获取单个对象的方法用 get 做前缀。<br>2） 获取多个对象的方法用 list 做前缀。<br>3） 获取统计值的方法用 count 做前缀。<br>4） 插入的方法用 save（推荐）或 insert 做前缀。<br>5） 删除的方法用 remove（推荐）或 delete 做前缀。<br>6） 修改的方法用 update 做前缀。</p><h3 id="领域模型命名规约"><a href="#领域模型命名规约" class="headerlink" title="领域模型命名规约"></a>领域模型命名规约</h3><p>1） 数据对象：xxxDO，xxx 即为数据表名。<br>2） 数据传输对象：xxxDTO，xxx 为业务领域相关的名称。<br>3） 展示对象：xxxVO，xxx 一般为网页名称。<br>4） POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO</p><h1 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h1><h2 id="【强制】不允许出现任何魔法值（即未经定义的常量）直接出现在代码中。"><a href="#【强制】不允许出现任何魔法值（即未经定义的常量）直接出现在代码中。" class="headerlink" title="【强制】不允许出现任何魔法值（即未经定义的常量）直接出现在代码中。"></a>【强制】不允许出现任何魔法值（即未经定义的常量）直接出现在代码中。</h2><p>反例： String key=”Id#taobao_”+tradeId；<br>cache.put(key, value);</p><h2 id="【强制】long-或者-Long-初始赋值时，必须使用大写的-L，不能是小写的-l，小写容易跟数字1-混淆，造成误解。"><a href="#【强制】long-或者-Long-初始赋值时，必须使用大写的-L，不能是小写的-l，小写容易跟数字1-混淆，造成误解。" class="headerlink" title="【强制】long 或者 Long 初始赋值时，必须使用大写的 L，不能是小写的 l，小写容易跟数字1 混淆，造成误解。"></a>【强制】long 或者 Long 初始赋值时，必须使用大写的 L，不能是小写的 l，小写容易跟数字1 混淆，造成误解。</h2><p>说明：Long a = 2l; 写的是数字的 21，还是 Long 型的 2?</p><h2 id="【推荐】不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。"><a href="#【推荐】不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。" class="headerlink" title="【推荐】不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。"></a>【推荐】不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。</h2><p>如：缓存相关的常量放在类：CacheConsts 下；系统配置相关的常量放在类：ConfigConsts 下。<br>说明：大而全的常量类，非得使用查找功能才能定位到修改的常量，不利于理解和维护。</p><h2 id="【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。"><a href="#【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。" class="headerlink" title="【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。"></a>【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。</h2><p>1） 跨应用共享常量：放置在二方库中，通常是 client.jar 中的 constant 目录下。<br>2） 应用内共享常量：放置在一方库的 modules 中的 constant 目录下。<br>反例：易懂变量也要统一定义成应用内共享常量，两位攻城师在两个类中分别定义了表示“是”的变量：<br>类 A 中：public static final String YES = “yes”; 类 B 中：public static final String YES = “y”; A.YES.equals(B.YES)，预期是 true，但实际返回为 false，导致产生线上问题。<br>3） 子工程内部共享常量：即在当前子工程的 constant 目录下。<br>4） 包内共享常量：即在当前包下单独的 constant 目录下。<br>5） 类内共享常量：直接在类内部 private static final 定义。</p><h2 id="【推荐】如果变量值仅在一个范围内变化用-Enum-类。如果还带有名称之外的延伸属性，必须使用-Enum-类"><a href="#【推荐】如果变量值仅在一个范围内变化用-Enum-类。如果还带有名称之外的延伸属性，必须使用-Enum-类" class="headerlink" title="【推荐】如果变量值仅在一个范围内变化用 Enum 类。如果还带有名称之外的延伸属性，必须使用 Enum 类"></a>【推荐】如果变量值仅在一个范围内变化用 Enum 类。如果还带有名称之外的延伸属性，必须使用 Enum 类</h2><p>下面正例中的数字就是延伸信息，表示星期几。<br>正例：</p><pre><code>public Enum{  MONDAY(1), TUESDAY(2), WEDNESDAY(3), THURSDAY(4), FRIDAY(5),SATURDAY(6),SUNDAY(7);}</code></pre><h1 id="格式规约"><a href="#格式规约" class="headerlink" title="格式规约"></a>格式规约</h1><h2 id="【强制】大括号的使用约定。"><a href="#【强制】大括号的使用约定。" class="headerlink" title="【强制】大括号的使用约定。"></a>【强制】大括号的使用约定。</h2><p>如果是大括号内为空，则简洁地写成{}即可，不需要换行；<br>如果是非空代码块则：<br>1） 左大括号前不换行。<br>2） 左大括号后换行。<br>3） 右大括号前换行。<br>4） 右大括号后还有 else 等代码则不换行；表示终止右大括号后必须换行。</p><h2 id="【强制】-左括号和后一个字符之间不出现空格；同样，右括号和前一个字符之间也不出现空"><a href="#【强制】-左括号和后一个字符之间不出现空格；同样，右括号和前一个字符之间也不出现空" class="headerlink" title="【强制】 左括号和后一个字符之间不出现空格；同样，右括号和前一个字符之间也不出现空"></a>【强制】 左括号和后一个字符之间不出现空格；同样，右括号和前一个字符之间也不出现空</h2><p>格。详见第 5 条下方正例ᨀ示。</p><h2 id="【强制】if-for-while-switch-do-等保留字与左右括号之间都必须加空格。"><a href="#【强制】if-for-while-switch-do-等保留字与左右括号之间都必须加空格。" class="headerlink" title="【强制】if/for/while/switch/do 等保留字与左右括号之间都必须加空格。"></a>【强制】if/for/while/switch/do 等保留字与左右括号之间都必须加空格。</h2><h2 id="【强制】任何运算符左右必须加一个空格。"><a href="#【强制】任何运算符左右必须加一个空格。" class="headerlink" title="【强制】任何运算符左右必须加一个空格。"></a>【强制】任何运算符左右必须加一个空格。</h2><p>说明：运算符包括赋值运算符=、逻辑运算符&amp;&amp;、加减乘除符号、三目运行符等。</p><h2 id="【强制】缩进采用-4-个空格，禁止使用-tab-字符。"><a href="#【强制】缩进采用-4-个空格，禁止使用-tab-字符。" class="headerlink" title="【强制】缩进采用 4 个空格，禁止使用 tab 字符。"></a>【强制】缩进采用 4 个空格，禁止使用 tab 字符。</h2><p>说明：如果使用 tab 缩进，必须设置 1 个 tab 为 4 个空格。IDEA 设置 tab 为 4 个空格时，<br>请勿勾选 Use tab character；而在 eclipse 中，必须勾选 insert spaces for tabs。<br>正例： （涉及 1-5 点）<br>    public static void main(String args[]) {<br>        // 缩进 4 个空格<br>        String say = “hello”;<br>        // 运算符的左右必须有一个空格<br>        int flag = 0;<br>        // 关键词 if 与括号之间必须有一个空格，括号内的 f 与左括号，0 与右括号不需要空格<br>        if (flag == 0) {<br>        System.out.println(say);<br>        }<br>        // 左大括号前加空格且不换行；左大括号后换行<br>        if (flag == 1) {<br>        System.out.println(“world”);<br>        // 右大括号前换行，右大括号后有 else，不用换行<br>        } else {<br>        System.out.println(“ok”);<br>        // 在右大括号后直接结束，则必须换行<br>        }<br>    }</p><h2 id="【强制】单行字符数限制不超过-120-个，超出需要换行，换行时遵循如下原则："><a href="#【强制】单行字符数限制不超过-120-个，超出需要换行，换行时遵循如下原则：" class="headerlink" title="【强制】单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则："></a>【强制】单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则：</h2><p>1） 第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。<br>2） 运算符与下文一起换行。<br>3） 方法调用的点符号与下文一起换行。<br>4） 在多个参数超长，逗号后进行换行。<br>5） 在括号前不要换行，见反例。<br>正例：<br>    StringBuffer sb = new StringBuffer();<br>    //超过 120 个字符的情况下，换行缩进 4 个空格，并且方法前的点符号一起换行<br>    sb.append(“zi”).append(“xin”)…<br>    .append(“huang”)…<br>    .append(“huang”)…<br>    .append(“huang”);<br>反例：<br>    StringBuffer sb = new StringBuffer();<br>    //超过 120 个字符的情况下，不要在括号前换行<br>    sb.append(“zi”).append(“xin”)…append<br>    (“huang”);<br>    //参数很多的方法调用可能超过 120 个字符，不要在逗号前换行<br>    method(args1, args2, args3, …<br>    , argsX);</p><h2 id="【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。"><a href="#【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。" class="headerlink" title="【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。"></a>【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。</h2><p>正例：下例中实参的”a”,后边必须要有一个空格。<br>method(“a”, “b”, “c”);</p><h2 id="【强制】IDE-的-text-file-encoding-设置为-UTF-8-IDE-中文件的换行符使用-Unix-格式，不要使用-windows-格式。"><a href="#【强制】IDE-的-text-file-encoding-设置为-UTF-8-IDE-中文件的换行符使用-Unix-格式，不要使用-windows-格式。" class="headerlink" title="【强制】IDE 的 text file encoding 设置为 UTF-8; IDE 中文件的换行符使用 Unix 格式，不要使用 windows 格式。"></a>【强制】IDE 的 text file encoding 设置为 UTF-8; IDE 中文件的换行符使用 Unix 格式，不要使用 windows 格式。</h2><h2 id="【推荐】没有必要增加若干空格来使某一行的字符与上一行的相应字符对齐。"><a href="#【推荐】没有必要增加若干空格来使某一行的字符与上一行的相应字符对齐。" class="headerlink" title="【推荐】没有必要增加若干空格来使某一行的字符与上一行的相应字符对齐。"></a>【推荐】没有必要增加若干空格来使某一行的字符与上一行的相应字符对齐。</h2><p>正例：<br>    int a = 3;<br>    long b = 4L;<br>    float c = 5F;<br>    StringBuffer sb = new StringBuffer();<br>说明：增加 sb 这个变量，如果需要对齐，则给 a、b、c 都要增加几个空格，在变量比较多的<br>情况下，是一种累赘的事情。</p><h2 id="【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义"><a href="#【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义" class="headerlink" title="【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义"></a>【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义</h2><p>之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。<br>说明：没有必要插入多行空格进行隔开。</p><h1 id="OOP-规约"><a href="#OOP-规约" class="headerlink" title="OOP 规约"></a>OOP 规约</h1><h2 id="【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。"><a href="#【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。" class="headerlink" title="【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。"></a>【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。</h2><h2 id="【强制】所有的覆写方法，必须加-Override-注解。"><a href="#【强制】所有的覆写方法，必须加-Override-注解。" class="headerlink" title="【强制】所有的覆写方法，必须加@Override 注解。"></a>【强制】所有的覆写方法，必须加@Override 注解。</h2><p>反例：getObject()与 get0bject()的问题。一个是字母的 O，一个是数字的 0，加@Override<br>可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错。</p><h2 id="【强制】相同参数类型，相同业务含义，才可以使用-Java-的可变参数，避免使用-Object。"><a href="#【强制】相同参数类型，相同业务含义，才可以使用-Java-的可变参数，避免使用-Object。" class="headerlink" title="【强制】相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object。"></a>【强制】相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object。</h2><p>说明：可变参数必须放置在参数列表的最后。（提倡同学们尽量不用可变参数编程）<br>正例：public User getUsers(String type, Integer… ids)</p><h2 id="【强制】对外暴露的接口签名，原则上不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加-Deprecated-注解，并清晰地说明采用的新接口或者新服务是什么。"><a href="#【强制】对外暴露的接口签名，原则上不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加-Deprecated-注解，并清晰地说明采用的新接口或者新服务是什么。" class="headerlink" title="【强制】对外暴露的接口签名，原则上不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加@Deprecated 注解，并清晰地说明采用的新接口或者新服务是什么。"></a>【强制】对外暴露的接口签名，原则上不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加@Deprecated 注解，并清晰地说明采用的新接口或者新服务是什么。</h2><h2 id="【强制】不能使用过时的类或方法。"><a href="#【强制】不能使用过时的类或方法。" class="headerlink" title="【强制】不能使用过时的类或方法。"></a>【强制】不能使用过时的类或方法。</h2><p>说明：java.net.URLDecoder 中的方法 decode(String encodeStr) 这个方法已经过时，应该使用双参数 decode(String source, String encode)。接口提供方既然明确是过时接口，<br>那么有义务同时ᨀ供新的接口；作为调用方来说，有义务去考证过时方法的新实现是什么。</p><h2 id="【强制】Object-的-equals-方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。"><a href="#【强制】Object-的-equals-方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。" class="headerlink" title="【强制】Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。"></a>【强制】Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。</h2><p>正例： “test”.equals(object);<br>反例： object.equals(“test”);<br>说明：推荐使用 java.util.Objects#equals （JDK7 引入的工具类）</p><h2 id="【强制】所有的相同类型的包装类对象之间值的比较，全部使用-equals-方法比较。"><a href="#【强制】所有的相同类型的包装类对象之间值的比较，全部使用-equals-方法比较。" class="headerlink" title="【强制】所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较。"></a>【强制】所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较。</h2><p><strong><em>说明：对于 Integer var=?在-128 至 127 之间的赋值，Integer 对象是在IntegerCache.cache 产生，会复用已有对象，这个区间内的 Integer 值可以直接使用==进行<br>判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，<br>推荐使用 equals 方法进行判断。</em></strong></p><h2 id="【强制】关于基本数据类型与包装数据类型的使用标准如下："><a href="#【强制】关于基本数据类型与包装数据类型的使用标准如下：" class="headerlink" title="【强制】关于基本数据类型与包装数据类型的使用标准如下："></a>【强制】关于基本数据类型与包装数据类型的使用标准如下：</h2><p>1） 所有的 POJO 类属性必须使用包装数据类型。<br>2） RPC 方法的返回值和参数必须使用包装数据类型。<br>3） 所有的局部变量【推荐】使用基本数据类型。<br>说明：POJO 类属性没有初值是ᨀ醒使用者在需要使用时，必须自己显式地进行赋值，任何<br>NPE 问题，或者入库检查，都由使用者来保证。<br>正例：数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。<br>反例：比如显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 RPC 服务，调用<br>不成功时，返回的是默认值，页面显示：0%，这是不合理的，应该显示成中划线-。所以包装<br>数据类型的 null 值，能够表示额外的信息，如：远程调用失败，异常退出。</p><h2 id="【强制】定义-DO-DTO-VO-等-POJO-类时，不要设定任何属性默认值。"><a href="#【强制】定义-DO-DTO-VO-等-POJO-类时，不要设定任何属性默认值。" class="headerlink" title="【强制】定义 DO/DTO/VO 等 POJO 类时，不要设定任何属性默认值。"></a>【强制】定义 DO/DTO/VO 等 POJO 类时，不要设定任何属性默认值。</h2><p>反例：POJO 类的 gmtCreate 默认值为 new Date();但是这个属性在数据ᨀ取时并没有置入具<br>体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。</p><h2 id="【强制】序列化类新增属性时，请不要修改-serialVersionUID-字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改-serialVersionUID-值。"><a href="#【强制】序列化类新增属性时，请不要修改-serialVersionUID-字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改-serialVersionUID-值。" class="headerlink" title="【强制】序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值。"></a>【强制】序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值。</h2><p>说明：注意 serialVersionUID 不一致会抛出序列化运行时异常。</p><h2 id="【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在-init-方法中。"><a href="#【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在-init-方法中。" class="headerlink" title="【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。"></a>【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。</h2><h2 id="【强制】POJO-类必须写-toString-方法。"><a href="#【强制】POJO-类必须写-toString-方法。" class="headerlink" title="【强制】POJO 类必须写 toString 方法。"></a>【强制】POJO 类必须写 toString 方法。</h2><p>使用 IDE 的中工具：source&gt; generate toString时，如果继承了另一个 POJO 类，注意在前面加一下 super.toString。<br>说明：在方法执行抛出异常时，可以直接调用 POJO 的 toString()方法打印其属性值，便于排<br>查问题。</p><h2 id="【推荐】使用索引访问用-String-的-split-方法得到的数组时，需做最后一个分隔符后有无-内容的检查，否则会有抛-IndexOutOfBoundsException-的风险。"><a href="#【推荐】使用索引访问用-String-的-split-方法得到的数组时，需做最后一个分隔符后有无-内容的检查，否则会有抛-IndexOutOfBoundsException-的风险。" class="headerlink" title="【推荐】使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无 内容的检查，否则会有抛 IndexOutOfBoundsException 的风险。"></a>【推荐】使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无 内容的检查，否则会有抛 IndexOutOfBoundsException 的风险。</h2><p>说明：<br>    String str = “a,b,c,,”;<br>    String[] ary = str.split(“,”);<br>    //预期大于 3，结果是 3<br>    System.out.println(ary.length);</p><h2 id="【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读。"><a href="#【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读。" class="headerlink" title="【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读。"></a>【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读。</h2><h2 id="【推荐】-类内方法定义顺序依次是：公有方法或保护方法-gt-私有方法-gt-getter-setter"><a href="#【推荐】-类内方法定义顺序依次是：公有方法或保护方法-gt-私有方法-gt-getter-setter" class="headerlink" title="【推荐】 类内方法定义顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter/setter"></a>【推荐】 类内方法定义顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter/setter</h2><p>方法。<br>说明：公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类<br>关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个<br>黑盒实现；因为方法信息价值较低，所有 Service 和 DAO 的 getter/setter 方法放在类体最<br>后。</p><h2 id="【推荐】setter-方法中，参数名称与类成员变量名称一致，this-成员名-参数名。在getter-setter-方法中，尽量不要增加业务逻辑，增加排查问题的难度。"><a href="#【推荐】setter-方法中，参数名称与类成员变量名称一致，this-成员名-参数名。在getter-setter-方法中，尽量不要增加业务逻辑，增加排查问题的难度。" class="headerlink" title="【推荐】setter 方法中，参数名称与类成员变量名称一致，this.成员名=参数名。在getter/setter 方法中，尽量不要增加业务逻辑，增加排查问题的难度。"></a>【推荐】setter 方法中，参数名称与类成员变量名称一致，this.成员名=参数名。在getter/setter 方法中，尽量不要增加业务逻辑，增加排查问题的难度。</h2><p>反例：<br>  public Integer getData(){<br>    if(true) {<br>    return data + 100;<br>    } else {<br>    return data - 100;<br>    }<br>  }</p><h2 id="【推荐】循环体内，字符串的联接方式，使用-StringBuilder-的-append-方法进行扩展。"><a href="#【推荐】循环体内，字符串的联接方式，使用-StringBuilder-的-append-方法进行扩展。" class="headerlink" title="【推荐】循环体内，字符串的联接方式，使用 StringBuilder 的 append 方法进行扩展。"></a>【推荐】循环体内，字符串的联接方式，使用 StringBuilder 的 append 方法进行扩展。</h2><p>反例：<br>  String str = “start”;<br>    for(int i=0; i&lt;100; i++){<br>      str = str + “hello”;<br>  }<br>说明：反编译出的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象，然后进行<br>append 操作，最后通过 toString 方法返回 String 对象，造成内存资源浪费。</p><h2 id="【推荐】final-可提高程序响应效率，声明成-final-的情况："><a href="#【推荐】final-可提高程序响应效率，声明成-final-的情况：" class="headerlink" title="【推荐】final 可提高程序响应效率，声明成 final 的情况："></a>【推荐】final 可提高程序响应效率，声明成 final 的情况：</h2><p>1） 不需要重新赋值的变量，包括类属性、局部变量。<br>2） 对象参数前加 final，表示不允许修改引用的指向。<br>3） 类方法确定不允许被重写。</p><h2 id="【推荐】慎用-Object-的-clone-方法来拷贝对象。"><a href="#【推荐】慎用-Object-的-clone-方法来拷贝对象。" class="headerlink" title="【推荐】慎用 Object 的 clone 方法来拷贝对象。"></a>【推荐】慎用 Object 的 clone 方法来拷贝对象。</h2><p>说明：对象的 clone 方法默认是浅拷贝，若想实现深拷贝需要重写 clone 方法实现属性对象的拷贝。</p><h2 id="【推荐】类成员与方法访问控制从严："><a href="#【推荐】类成员与方法访问控制从严：" class="headerlink" title="【推荐】类成员与方法访问控制从严："></a>【推荐】类成员与方法访问控制从严：</h2><p>1） 如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 private。<br>2） 工具类不允许有 public 或 default 构造方法。<br>3） 类非 static 成员变量并且与子类共享，必须是 protected。<br>4） 类非 static 成员变量并且仅在本类使用，必须是 private。<br>5） 类 static 成员变量如果仅在本类使用，必须是 private。<br>6） 若是 static 成员变量，必须考虑是否为 final。<br>7） 类成员方法只供类内部调用，必须是 private。<br>8） 类成员方法只对继承类公开，那么限制为 protected。<br>说明：任何类、方法、参数、变量，严控访问范围。过宽泛的访问范围，不利于模块解耦。思考：如果是一个 private 的方法，想删除就删除，可是一个 public 的 Service 方法，或者一<br>个 public 的成员变量，删除一下，不得手心冒点汗吗？变量像自己的小孩，尽量在自己的视线内，变量作用域太大，如果无限制的到处跑，那么你会担心的。</p><h1 id="集合处理"><a href="#集合处理" class="headerlink" title="集合处理"></a>集合处理</h1><h2 id="【强制】关于-hashCode-和-equals-的处理，遵循如下规则："><a href="#【强制】关于-hashCode-和-equals-的处理，遵循如下规则：" class="headerlink" title="【强制】关于 hashCode 和 equals 的处理，遵循如下规则："></a>【强制】关于 hashCode 和 equals 的处理，遵循如下规则：</h2><p>1） 只要重写 equals，就必须重写 hashCode。<br>2） 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的<br>对象必须重写这两个方法。<br>3） 如果自定义对象做为 Map 的键，那么必须重写 hashCode 和 equals。<br>正例：String 重写了 hashCode 和 equals 方法，所以我们可以非常愉快地使用 String 对象<br>作为 key 来使用。</p><h2 id="【强制】ArrayList的subList结果不可强转成ArrayList，否则会抛出ClassCastException"><a href="#【强制】ArrayList的subList结果不可强转成ArrayList，否则会抛出ClassCastException" class="headerlink" title="【强制】ArrayList的subList结果不可强转成ArrayList，否则会抛出ClassCastException"></a>【强制】ArrayList的subList结果不可强转成ArrayList，否则会抛出ClassCastException</h2><p>异常：java.util.RandomAccessSubList cannot be cast to java.util.ArrayList ;<br>说明：subList 返回的是 ArrayList 的内部类 SubList，并不是 ArrayList ，而是<br>ArrayList 的一个视图，对于 SubList 子列表的所有操作最终会反映到原列表上。</p><h2 id="【强制】-在-subList-场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增"><a href="#【强制】-在-subList-场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增" class="headerlink" title="【强制】 在 subList 场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增"></a>【强制】 在 subList 场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增</h2><p>加、删除均产生 ConcurrentModificationException 异常。</p><p>##【强制】使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全<br>一样的数组，大小就是 list.size()。<br>反例：直接使用 toArray 无参方法存在问题，此方法返回值只能是 Object[]类，若强转其它<br>类型数组将出现 ClassCastException 错误。<br>正例：<br>    List<string> list = new ArrayList<string>(2);<br>    list.add(“guan”);<br>    list.add(“bao”);<br>    String[] array = new String[list.size()];<br>    array = list.toArray(array);<br>说明：使用 toArray 带参方法，入参分配的数组空间不够大时，toArray 方法内部将重新分配<br>内存空间，并返回新数组地址；如果数组元素大于实际所需，下标为[ list.size() ]的数组<br>元素将被置为 null，其它数组元素保持原值，因此最好将方法入参数组大小定义与集合元素<br>个数一致。</string></string></p><h2 id="【强制】使用工具类-Arrays-asList-把数组转换成集合时，不能使用其修改集合相关的方法，它的-add-remove-clear-方法会抛出-UnsupportedOperationException-异常。"><a href="#【强制】使用工具类-Arrays-asList-把数组转换成集合时，不能使用其修改集合相关的方法，它的-add-remove-clear-方法会抛出-UnsupportedOperationException-异常。" class="headerlink" title="【强制】使用工具类 Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。"></a>【强制】使用工具类 Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。</h2><p>说明：asList 的返回对象是一个 Arrays 内部类，并没有实现集合的修改方法。Arrays.asList<br>体现的是适配器模式，只是转换接口，后台的数据仍是数组。<br>    String[] str = new String[] { “a”, “b” };<br>    List list = Arrays.asList(str);<br>第一种情况：list.add(“c”); 运行时异常。<br>第二种情况：str[0]= “gujin”; 那么 list.get(0)也会随之修改。</p><h2 id="【强制】泛型通配符-lt-extends-T-gt-来接收返回的数据，此写法的泛型集合不能使用-add-方法。"><a href="#【强制】泛型通配符-lt-extends-T-gt-来接收返回的数据，此写法的泛型集合不能使用-add-方法。" class="headerlink" title="【强制】泛型通配符&lt;? extends T&gt;来接收返回的数据，此写法的泛型集合不能使用 add 方法。"></a>【强制】泛型通配符&lt;? extends T&gt;来接收返回的数据，此写法的泛型集合不能使用 add 方法。</h2><p>说明：苹果装箱后返回一个&lt;? extends Fruits&gt;对象，此对象就不能往里加任何水果，包括苹果。</p><h2 id="【强制】不要在-foreach-循环里进行元素的-remove-add-操作。remove-元素请使用-Iterator"><a href="#【强制】不要在-foreach-循环里进行元素的-remove-add-操作。remove-元素请使用-Iterator" class="headerlink" title="【强制】不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator"></a>【强制】不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator</h2><p>方式，如果并发操作，需要对 Iterator 对象加锁。<br>反例：<br>    List<string> a = new ArrayList<string>();<br>        a.add(“1”);<br>        a.add(“2”);<br>        for (String temp : a) {<br>        if(“1”.equals(temp)){<br>        a.remove(temp);<br>        }<br>    }<br>说明：以上代码的执行结果肯定会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的<br>结果吗？<br>正例：<br>    Iterator<string> it = a.iterator();<br>        while(it.hasNext()){<br>        String temp = it.next();<br>        if(删除元素的条件){<br>        it.remove();<br>        }<br>    }</string></string></string></p><p>##【强制】在 JDK7 版本以上，Comparator 要满足自反性，传递性，对称性，不然 Arrays.sort，Collections.sort 会报 IllegalArgumentException 异常。<br>说明：<br>1） 自反性：x，y 的比较结果和 y，x 的比较结果相反。<br>2） 传递性：x&gt;y,y&gt;z,则 x&gt;z。 3） 对称性：x=y,则 x,z 比较结果和 y，z 比较结果相同。<br>反例：下例中没有处理相等的情况，实际使用中可能会出现异常：<br>    new Comparator<student>() {<br>        @Override<br>        public int compare(Student o1, Student o2) {<br>        return o1.getId() &gt; o2.getId() ? 1 : -1;<br>        }<br>    }</student></p><h2 id="【推荐】集合初始化时，尽量指定集合初始值大小。"><a href="#【推荐】集合初始化时，尽量指定集合初始值大小。" class="headerlink" title="【推荐】集合初始化时，尽量指定集合初始值大小。"></a>【推荐】集合初始化时，尽量指定集合初始值大小。</h2><p>说明：ArrayList 尽量使用 ArrayList(int initialCapacity) 初始化。</p><h2 id="【推荐】使用-entrySet-遍历-Map-类集合-KV，而不是-keySet-方式进行遍历。"><a href="#【推荐】使用-entrySet-遍历-Map-类集合-KV，而不是-keySet-方式进行遍历。" class="headerlink" title="【推荐】使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。"></a>【推荐】使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。</h2><p>说明：keySet 其实是遍历了 2 次，一次是转为 Iterator 对象，另一次是从 hashMap 中取出<br>key 所对应的 value。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中，效<br>率更高。如果是 JDK8，使用 Map.foreach 方法。<br>正例：values()返回的是 V 值集合，是一个 list 集合对象；keySet()返回的是 K 值集合，是<br>一个 Set 集合对象；entrySet()返回的是 K-V 值组合集合。</p><p>##【推荐】高度注意 Map 类集合 K/V 能不能存储 null 值的情况，如下表格：<br>集合类     Key           Value        Super      说明<br>Hashtable 不允许为 null 不允许为 null Dictionary 线程安全<br>ConcurrentHashMap 不允许为 null 不允许为 null AbstractMap 分段锁技术<br>TreeMap 不允许为 null 允许为 null AbstractMap 线程不安全<br>HashMap 允许为 null 允许为 null AbstractMap 线程不安全<br>反例： 由于 HashMap 的干扰，很多人认为 ConcurrentHashMap 是可以置入 null 值，注意存储<br>null 值时会抛出 NPE 异常。</p><h2 id="【参考】合理利用好集合的有序性-sort-和稳定性-order-，避免集合的无序性-unsort-和不稳定性-unorder-带来的负面影响。"><a href="#【参考】合理利用好集合的有序性-sort-和稳定性-order-，避免集合的无序性-unsort-和不稳定性-unorder-带来的负面影响。" class="headerlink" title="【参考】合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳定性(unorder)带来的负面影响。"></a>【参考】合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳定性(unorder)带来的负面影响。</h2><p>说明：稳定性指集合每次遍历的元素次序是一定的。有序性是指遍历的结果是按某种比较规则<br>依次排列的。如：ArrayList 是 order/unsort；HashMap 是 unorder/unsort；TreeSet 是<br>order/sort。</p><h2 id="【参考】利用-Set-元素唯一的特性，可以快速对一个集合进行去重操作，避免使用-List-的contains-方法进行遍历、对比、去重操作。"><a href="#【参考】利用-Set-元素唯一的特性，可以快速对一个集合进行去重操作，避免使用-List-的contains-方法进行遍历、对比、去重操作。" class="headerlink" title="【参考】利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的contains 方法进行遍历、对比、去重操作。"></a>【参考】利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的contains 方法进行遍历、对比、去重操作。</h2><h1 id="并发处理"><a href="#并发处理" class="headerlink" title="并发处理"></a>并发处理</h1><h2 id="【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。"><a href="#【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。" class="headerlink" title="【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。"></a>【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。</h2><p>说明：资源驱动类、工具类、单例工厂类都需要注意。</p><h2 id="【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。"><a href="#【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。" class="headerlink" title="【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。"></a>【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。</h2><p>正例：<br>    public class TimerTaskThread extends Thread {<br>        public TimerTaskThread(){<br>        super.setName(“TimerTaskThread”); …<br>    }</p><h2 id="【强制】线程资源必须通过线程池ᨀ供，不允许在应用中自行显式创建线程。"><a href="#【强制】线程资源必须通过线程池ᨀ供，不允许在应用中自行显式创建线程。" class="headerlink" title="【强制】线程资源必须通过线程池ᨀ供，不允许在应用中自行显式创建线程。"></a>【强制】线程资源必须通过线程池ᨀ供，不允许在应用中自行显式创建线程。</h2><p>说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资<br>源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者<br>“过度切换”的问题。</p><h2 id="【强制】线程池不允许使用-Executors-去创建，而是通过-ThreadPoolExecutor-的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。"><a href="#【强制】线程池不允许使用-Executors-去创建，而是通过-ThreadPoolExecutor-的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。" class="headerlink" title="【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。"></a>【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</h2><p>说明：Executors 返回的线程池对象的弊端如下： 1）FixedThreadPool 和 SingleThreadPool:<br>允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。 2）CachedThreadPool 和 ScheduledThreadPool:<br>允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</p><h2 id="【强制】SimpleDateFormat-是线程不安全的类，一般不要定义为-static-变量，如果定义为static，必须加锁，或者使用-DateUtils-工具类。"><a href="#【强制】SimpleDateFormat-是线程不安全的类，一般不要定义为-static-变量，如果定义为static，必须加锁，或者使用-DateUtils-工具类。" class="headerlink" title="【强制】SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为static，必须加锁，或者使用 DateUtils 工具类。"></a>【强制】SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为static，必须加锁，或者使用 DateUtils 工具类。</h2><p>正例：注意线程安全，使用 DateUtils。亦推荐如下处理：<br>    private static final ThreadLocal<dateformat> df = new ThreadLocal<dateformat>() {<br>        @Override<br>        protected DateFormat initialValue() {<br>        return new SimpleDateFormat(“yyyy-MM-dd”);<br>        }<br>    };<br>说明：如果是 JDK8 的应用，可以使用 Instant 代替 Date，LocalDateTime 代替 Calendar，<br>DateTimeFormatter代替Simpledateformatter，官方给出的解释：simple beautiful strong<br>immutable thread-safe。</dateformat></dateformat></p><h2 id="【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。"><a href="#【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。" class="headerlink" title="【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。"></a>【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。</h2><h2 id="【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。"><a href="#【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。" class="headerlink" title="【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。"></a>【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。</h2><p>说明：线程一需要对表 A、B、C 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序<br>也必须是 A、B、C，否则可能出现死锁。</p><h2 id="【强制】并发修改同一记录时，避免更新丢失，要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用-version-作为更新依据。"><a href="#【强制】并发修改同一记录时，避免更新丢失，要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用-version-作为更新依据。" class="headerlink" title="【强制】并发修改同一记录时，避免更新丢失，要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。"></a>【强制】并发修改同一记录时，避免更新丢失，要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。</h2><p>说明：如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次<br>数不得小于 3 次。</p><h2 id="【强制】多线程并行处理定时任务时，Timer-运行多个-TimeTask-时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用-ScheduledExecutorService-则没有这个问题。"><a href="#【强制】多线程并行处理定时任务时，Timer-运行多个-TimeTask-时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用-ScheduledExecutorService-则没有这个问题。" class="headerlink" title="【强制】多线程并行处理定时任务时，Timer 运行多个 TimeTask 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题。"></a>【强制】多线程并行处理定时任务时，Timer 运行多个 TimeTask 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题。</h2><h2 id="【推荐】使用-CountDownLatch-进行异步转同步操作，每个线程退出前必须调用-countDown方法，线程执行代码注意-catch-异常，确保-countDown-方法可以执行，避免主线程无法执行至-countDown-方法，直到超时才返回结果。"><a href="#【推荐】使用-CountDownLatch-进行异步转同步操作，每个线程退出前必须调用-countDown方法，线程执行代码注意-catch-异常，确保-countDown-方法可以执行，避免主线程无法执行至-countDown-方法，直到超时才返回结果。" class="headerlink" title="【推荐】使用 CountDownLatch 进行异步转同步操作，每个线程退出前必须调用 countDown方法，线程执行代码注意 catch 异常，确保 countDown 方法可以执行，避免主线程无法执行至 countDown 方法，直到超时才返回结果。"></a>【推荐】使用 CountDownLatch 进行异步转同步操作，每个线程退出前必须调用 countDown方法，线程执行代码注意 catch 异常，确保 countDown 方法可以执行，避免主线程无法执行至 countDown 方法，直到超时才返回结果。</h2><p>说明：注意，子线程抛出异常堆栈，不能在主线程 try-catch 到。</p><h2 id="【推荐】避免-Random-实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed-导致的性能下降。"><a href="#【推荐】避免-Random-实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed-导致的性能下降。" class="headerlink" title="【推荐】避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed 导致的性能下降。"></a>【推荐】避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed 导致的性能下降。</h2><p>说明：Random 实例包括 java.util.Random 的实例或者 Math.random()实例。<br>正例：在 JDK7 之后，可以直接使用 API ThreadLocalRandom，在 JDK7 之前，可以做到每个<br>线程一个实例。</p><h2 id="【推荐】通过双重检查锁（double-checked-locking）（在并发场景）实现延迟初始化的优化问题隐患-可参考-The-“Double-Checked-Locking-is-Broken”-Declaration-推荐问题解决方案中较为简单一种（适用于-JDK5-及以上版本），将目标属性声明为-volatile-型。"><a href="#【推荐】通过双重检查锁（double-checked-locking）（在并发场景）实现延迟初始化的优化问题隐患-可参考-The-“Double-Checked-Locking-is-Broken”-Declaration-推荐问题解决方案中较为简单一种（适用于-JDK5-及以上版本），将目标属性声明为-volatile-型。" class="headerlink" title="【推荐】通过双重检查锁（double-checked locking）（在并发场景）实现延迟初始化的优化问题隐患(可参考 The “Double-Checked Locking is Broken” Declaration),推荐问题解决方案中较为简单一种（适用于 JDK5 及以上版本），将目标属性声明为 volatile 型。"></a>【推荐】通过双重检查锁（double-checked locking）（在并发场景）实现延迟初始化的优化问题隐患(可参考 The “Double-Checked Locking is Broken” Declaration),推荐问题解决方案中较为简单一种（适用于 JDK5 及以上版本），将目标属性声明为 volatile 型。</h2><p>反例：<br>    class Foo {<br>        private Helper helper = null;<br>        public Helper getHelper() {<br>            if (helper == null) synchronized(this) {<br>            if (helper == null)<br>            helper = new Helper();<br>            }<br>            return helper;<br>        }<br>        // other functions and members…<br>    }</p><h2 id="【参考】volatile-解决多线程内存不可见问题。"><a href="#【参考】volatile-解决多线程内存不可见问题。" class="headerlink" title="【参考】volatile 解决多线程内存不可见问题。"></a>【参考】volatile 解决多线程内存不可见问题。</h2><p>对于一写多读，是可以解决变量同步问题，<br>但是如果多写，同样无法解决线程安全问题。如果是 count++操作，使用如下类实现：<br>AtomicInteger count = new AtomicInteger(); count.addAndGet(1); 如果是 JDK8，推<br>荐使用 LongAdder 对象，比 AtomicLong 性能更好（减少乐观锁的重试次数）。</p><h2 id="【参考】-HashMap-在容量不够进行-resize-时由于高并发可能出现死链，导致-CPU-飙升，在开发过程中注意规避此风险。"><a href="#【参考】-HashMap-在容量不够进行-resize-时由于高并发可能出现死链，导致-CPU-飙升，在开发过程中注意规避此风险。" class="headerlink" title="【参考】 HashMap 在容量不够进行 resize 时由于高并发可能出现死链，导致 CPU 飙升，在开发过程中注意规避此风险。"></a>【参考】 HashMap 在容量不够进行 resize 时由于高并发可能出现死链，导致 CPU 飙升，在开发过程中注意规避此风险。</h2><h2 id="【参考】ThreadLocal-无法解决共享对象的更新问题，ThreadLocal-对象建议使用-static修饰。"><a href="#【参考】ThreadLocal-无法解决共享对象的更新问题，ThreadLocal-对象建议使用-static修饰。" class="headerlink" title="【参考】ThreadLocal 无法解决共享对象的更新问题，ThreadLocal 对象建议使用 static修饰。"></a>【参考】ThreadLocal 无法解决共享对象的更新问题，ThreadLocal 对象建议使用 static修饰。</h2><p>这个变量是针对一个线程内所有操作共有的，所以设置为静态变量，所有此类实例共享<br>此静态变量 ，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只<br>要是这个线程内定义的)都可以操控这个变量。</p><h1 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h1><h2 id="【强制】在一个-switch-块内，每个-case-要么通过-break-return-等来终止，要么注释说明程序将继续执行到哪一个-case-为止；"><a href="#【强制】在一个-switch-块内，每个-case-要么通过-break-return-等来终止，要么注释说明程序将继续执行到哪一个-case-为止；" class="headerlink" title="【强制】在一个 switch 块内，每个 case 要么通过 break/return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止；"></a>【强制】在一个 switch 块内，每个 case 要么通过 break/return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止；</h2><p>在一个 switch 块内，都必须包含一个 default 语句并且<br>放在最后，即使它什么代码也没有。</p><h2 id="【强制】在-if-else-for-while-do-语句中必须使用大括号，即使只有一行代码，"><a href="#【强制】在-if-else-for-while-do-语句中必须使用大括号，即使只有一行代码，" class="headerlink" title="【强制】在 if/else/for/while/do 语句中必须使用大括号，即使只有一行代码，"></a>【强制】在 if/else/for/while/do 语句中必须使用大括号，即使只有一行代码，</h2><p>避免使用下面的形式：if (condition) statements;</p><h2 id="【推荐】推荐尽量少用-else，-if-else-的方式可以改写成："><a href="#【推荐】推荐尽量少用-else，-if-else-的方式可以改写成：" class="headerlink" title="【推荐】推荐尽量少用 else， if-else 的方式可以改写成："></a>【推荐】推荐尽量少用 else， if-else 的方式可以改写成：</h2><pre><code>if(condition){    ...    return obj;}// 接着写 else 的业务逻辑代码;</code></pre><p>说明：如果非得使用 if()…else if()…else…方式表达逻辑，<strong><em>【强制】请勿超过 3 层，<br>超过请使用状态设计模式。</em></strong><br>正例：逻辑上超过 3 层的 if-else 代码可以使用卫语句，或者状态模式来实现。</p><h2 id="【推荐】除常用方法（如-getXxx-isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。"><a href="#【推荐】除常用方法（如-getXxx-isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。" class="headerlink" title="【推荐】除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。"></a>【推荐】除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。</h2><p>说明：很多 if 语句内的逻辑相当复杂，阅读者需要分析条件表达式的最终结果，才能明确什么<br>样的条件执行什么样的语句，那么，如果阅读者分析逻辑表达式错误呢？<br>正例：<br>    //伪代码如下<br>    boolean existed = (file.open(fileName, “w”) != null) &amp;&amp; (…) || (…);<br>        if (existed) {<br>        …<br>    }<br>反例：<br>    if ((file.open(fileName, “w”) != null) &amp;&amp; (…) || (…)) {<br>    …<br>    }</p><h2 id="【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理"><a href="#【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理" class="headerlink" title="【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理"></a>【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理</h2><p>如定义对象、变量、获取数据库连接，进行不必要的 try-catch 操作（这个 try-catch 是否可以移至循环体外）。</p><h2 id="【推荐】接口入参保护，这种场景常见的是用于做批量操作的接口。"><a href="#【推荐】接口入参保护，这种场景常见的是用于做批量操作的接口。" class="headerlink" title="【推荐】接口入参保护，这种场景常见的是用于做批量操作的接口。"></a>【推荐】接口入参保护，这种场景常见的是用于做批量操作的接口。</h2><h2 id="【参考】方法中需要进行参数校验的场景："><a href="#【参考】方法中需要进行参数校验的场景：" class="headerlink" title="【参考】方法中需要进行参数校验的场景："></a>【参考】方法中需要进行参数校验的场景：</h2><p>1） 调用频次低的方法。<br>2） 执行时间开销很大的方法，参数校验时间几乎可以忽略不计，但如果因为参数错误导致<br>中间执行回退，或者错误，那得不偿失。<br>3） 需要极高稳定性和可用性的方法。<br>4） 对外提供的开放接口，不管是 RPC/API/HTTP 接口。<br>5） 敏感权限入口。</p><h2 id="【参考】方法中不需要参数校验的场景："><a href="#【参考】方法中不需要参数校验的场景：" class="headerlink" title="【参考】方法中不需要参数校验的场景："></a>【参考】方法中不需要参数校验的场景：</h2><p>1） 极有可能被循环调用的方法，不建议对参数进行校验。但在方法说明里必须注明外部参<br>数检查。<br>2） 底层的方法调用频度都比较高，一般不校验。毕竟是像纯净水过滤的最后一道，参数错<br>误不太可能到底层才会暴露问题。一般 DAO 层与 Service 层都在同一个应用中，部署在同一<br>台服务器中，所以 DAO 的参数校验，可以省略。<br>3） 被声明成 private 只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参<br>数已经做过检查或者肯定不会有问题，此时可以不校验参数。</p><h1 id="注释规约"><a href="#注释规约" class="headerlink" title="注释规约"></a>注释规约</h1><h2 id="【强制】类、类属性、类方法的注释必须使用-Javadoc-规范，使用-内容-格式，不得使用-xxx-方式。"><a href="#【强制】类、类属性、类方法的注释必须使用-Javadoc-规范，使用-内容-格式，不得使用-xxx-方式。" class="headerlink" title="【强制】类、类属性、类方法的注释必须使用 Javadoc 规范，使用 /* 内容  / 格式，不得使用//xxx 方式。"></a>【强制】类、类属性、类方法的注释必须使用 Javadoc 规范，使用 /*<em> 内容 </em> / 格式，不得使用//xxx 方式。</h2><p>说明：在 IDE 编辑窗口中，Javadoc 方式会提示相关注释，生成 Javadoc 可以正确输出相应注<br>释；在 IDE 中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高<br>阅读效率。</p><h2 id="【强制】所有的抽象方法（包括接口中的方法）必须要用-Javadoc-注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。"><a href="#【强制】所有的抽象方法（包括接口中的方法）必须要用-Javadoc-注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。" class="headerlink" title="【强制】所有的抽象方法（包括接口中的方法）必须要用 Javadoc 注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。"></a>【强制】所有的抽象方法（包括接口中的方法）必须要用 Javadoc 注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。</h2><p>说明：对子类的实现要求，或者调用注意事项，请一并说明。</p><h2 id="【强制】所有的类都必须添加创建者信息。"><a href="#【强制】所有的类都必须添加创建者信息。" class="headerlink" title="【强制】所有的类都必须添加创建者信息。"></a>【强制】所有的类都必须添加创建者信息。</h2><h2 id="【强制】方法内部单行注释，在被注释语句上方另起一行，使用-注释。方法内部多行注释"><a href="#【强制】方法内部单行注释，在被注释语句上方另起一行，使用-注释。方法内部多行注释" class="headerlink" title="【强制】方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释"></a>【强制】方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释</h2><p>使用/<em> </em>/注释，注意与代码对齐。</p><h2 id="【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。"><a href="#【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。" class="headerlink" title="【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。"></a>【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。</h2><h2 id="【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。"><a href="#【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。" class="headerlink" title="【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。"></a>【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。</h2><p>反例：“TCP 连接超时”解释成“传输控制协议连接超时”，理解反而费脑筋。</p><h2 id="【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。"><a href="#【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。" class="headerlink" title="【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。"></a>【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。</h2><p>说明：代码与注释更新不同步，就像路网与导航软件更新不同步一样，如果导航软件严重滞后，<br>就失去了导航的意义。</p><h2 id="【参考】注释掉的代码尽量要配合说明，而不是简单的注释掉。"><a href="#【参考】注释掉的代码尽量要配合说明，而不是简单的注释掉。" class="headerlink" title="【参考】注释掉的代码尽量要配合说明，而不是简单的注释掉。"></a>【参考】注释掉的代码尽量要配合说明，而不是简单的注释掉。</h2><p>说明：代码被注释掉有两种可能性：1）后续会恢复此段代码逻辑。2）永久不用。前者如果没<br>有备注信息，难以知晓注释动机。后者建议直接删掉（代码仓库保存了历史代码）。</p><h2 id="【参考】对于注释的要求："><a href="#【参考】对于注释的要求：" class="headerlink" title="【参考】对于注释的要求："></a>【参考】对于注释的要求：</h2><p>第一、能够准确反应设计思想和代码逻辑；<br>第二、能够阐述业务含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同<br>天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看<br>的，使其能够快速接替自己的工作。</p><h2 id="【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。"><a href="#【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。" class="headerlink" title="【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。"></a>【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。</h2><p>（这条对我来说要注意，因为我总倾向于把注释写的很详细，有时出现过度注释）<br>避免出现注释的一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。<br>反例：<br>    // put elephant into fridge<br>    put(elephant, fridge);</p><p>方法名 put，加上两个有意义的变量名 elephant 和 fridge，已经说明了这是在干什么，语<br>义清晰的代码不需要额外的注释。</p><h2 id="【参考】特殊注释标记，请注明标记人与标记时间。"><a href="#【参考】特殊注释标记，请注明标记人与标记时间。" class="headerlink" title="【参考】特殊注释标记，请注明标记人与标记时间。"></a>【参考】特殊注释标记，请注明标记人与标记时间。</h2><p>注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。<br>1） 待办事宜（TODO）:（ 标记人，标记时间，[预计处理时间]）<br>表示需要实现，但目前还未实现的功能。这实际上是一个 Javadoc 的标签，目前的 Javadoc<br>还没有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个 Javadoc 标签）。<br>2） 错误，不能工作（FIXME）:（标记人，标记时间，[预计处理时间]）<br>在注释中用 FIXME 标记某代码是错误的，而且不能工作，需要及时纠正的情况。</p><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><h2 id="【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。"><a href="#【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。" class="headerlink" title="【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。"></a>【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。</h2><p>说明：不要在方法体内定义：Pattern pattern = Pattern.compile(规则);</p><h2 id="【强制】velocity-调用-POJO-类的属性时，建议直接使用属性名取值即可，"><a href="#【强制】velocity-调用-POJO-类的属性时，建议直接使用属性名取值即可，" class="headerlink" title="【强制】velocity 调用 POJO 类的属性时，建议直接使用属性名取值即可，"></a>【强制】velocity 调用 POJO 类的属性时，建议直接使用属性名取值即可，</h2><p>模板引擎会自动按规范调用 POJO 的 getXxx()，如果是 boolean 基本数据类型变量（boolean 命名不需要加 is前缀），会自动调用 isXxx()方法。<br>说明：注意如果是 Boolean 包装类对象，优先调用 getXxx()的方法。</p><h2 id="【强制】后台输送给页面的变量必须加-var-——中间的感叹号。"><a href="#【强制】后台输送给页面的变量必须加-var-——中间的感叹号。" class="headerlink" title="【强制】后台输送给页面的变量必须加$!{var}——中间的感叹号。"></a>【强制】后台输送给页面的变量必须加$!{var}——中间的感叹号。</h2><p>说明：如果 var=null 或者不存在，那么${var}会直接显示在页面上。</p><h2 id="【强制】注意-Math-random-这个方法返回是-double-类型，"><a href="#【强制】注意-Math-random-这个方法返回是-double-类型，" class="headerlink" title="【强制】注意 Math.random() 这个方法返回是 double 类型，"></a>【强制】注意 Math.random() 这个方法返回是 double 类型，</h2><p>注意取值的范围 0≤x&lt;1（能够取到零值，注意除零异常），如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后<br>取整，直接使用 Random 对象的 nextInt 或者 nextLong 方法。</p><h2 id="【强制】获取当前毫秒数-System-currentTimeMillis-而不是-new-Date-getTime"><a href="#【强制】获取当前毫秒数-System-currentTimeMillis-而不是-new-Date-getTime" class="headerlink" title="【强制】获取当前毫秒数 System.currentTimeMillis(); 而不是 new Date().getTime();"></a>【强制】获取当前毫秒数 System.currentTimeMillis(); 而不是 new Date().getTime();</h2><p>说明：如果想获取更加精确的纳秒级时间值，用 System.nanoTime()。在 JDK8 中，针对统计时间等场景，推荐使用 Instant 类。</p><h2 id="【推荐】尽量不要在-vm-中加入变量声明、逻辑运算符，更不要在-vm-模板中加入任何复杂的逻辑。"><a href="#【推荐】尽量不要在-vm-中加入变量声明、逻辑运算符，更不要在-vm-模板中加入任何复杂的逻辑。" class="headerlink" title="【推荐】尽量不要在 vm 中加入变量声明、逻辑运算符，更不要在 vm 模板中加入任何复杂的逻辑。"></a>【推荐】尽量不要在 vm 中加入变量声明、逻辑运算符，更不要在 vm 模板中加入任何复杂的逻辑。</h2><h2 id="【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。"><a href="#【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。" class="headerlink" title="【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。"></a>【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。</h2><h2 id="【推荐】对于“明确停止使用的代码和配置”，如方法、变量、类、配置文件、动态配置属性等要坚决从程序中清理出去，避免造成过多垃圾。"><a href="#【推荐】对于“明确停止使用的代码和配置”，如方法、变量、类、配置文件、动态配置属性等要坚决从程序中清理出去，避免造成过多垃圾。" class="headerlink" title="【推荐】对于“明确停止使用的代码和配置”，如方法、变量、类、配置文件、动态配置属性等要坚决从程序中清理出去，避免造成过多垃圾。"></a>【推荐】对于“明确停止使用的代码和配置”，如方法、变量、类、配置文件、动态配置属性等要坚决从程序中清理出去，避免造成过多垃圾。</h2><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://kangroo.gitee.io/ajcg/#/?id=%e5%89%8d%e8%a8%80" target="_blank" rel="noopener">https://kangroo.gitee.io/ajcg/#/?id=%e5%89%8d%e8%a8%80</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常见的开发规范&lt;/p&gt;
    
    </summary>
    
      <category term="2019年12月" scheme="http://yoursite.com/categories/2019%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Effctive-Java阅读笔记II</title>
    <link href="http://yoursite.com/2019/12/31/Effctive-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0II/"/>
    <id>http://yoursite.com/2019/12/31/Effctive-Java阅读笔记II/</id>
    <published>2019-12-31T03:30:12.000Z</published>
    <updated>2019-12-31T07:07:10.561Z</updated>
    
    <content type="html"><![CDATA[<p>第二章阅读：创建和销毁对象<br>03.使用私有构造方法或枚类实现 Singleton 属性<br>04.使用私有构造器执行非实例化<br>（这两部分理解有困难，需要再查阅相关资料）<br><a id="more"></a></p><h1 id="使用私有构造方法或枚类实现-Singleton-属性"><a href="#使用私有构造方法或枚类实现-Singleton-属性" class="headerlink" title="使用私有构造方法或枚类实现 Singleton 属性"></a>使用私有构造方法或枚类实现 Singleton 属性</h1><p>单例是一个仅实例化一次的类，详细描述参见笔记：《设计模式面试高频题》。单例对象通常表示无状态对象，如函数 (条目 24) 或一个本质上唯一的系统组件。让一个类成为单例会使测试它的客户变得困难，因为除非实现一个作为它类型的接口，否则不可能用一个模拟实现替代单例。</p><p>　有两种常见的方法来实现单例。两者都基于保持构造方法私有和导出公共静态成员以提供对唯一实例的访问。在第一种方法中，成员是 final 修饰的属性：</p><pre><code>// Singleton with public final fieldpublic class Elvis {    public static final Elvis INSTANCE = new Elvis();    private Elvis() { ... }    public void leaveTheBuilding() { ... }}</code></pre><p>私有构造方法只调用一次，来初始化公共静态 final Elvis.INSTANCE 属性。缺少一个公共的或受保护的构造方法，保证了全局的唯一性：一旦 Elvis 类被初始化，一个 Elvis 的实例就会存在——不多也不少。客户端所做的任何事情都不能改变这一点，但需要注意的是：特权客户端可以使用 AccessibleObject.setAccessible 方法，以反射方式调用私有构造方法（详见第 65 条）。如果需要防御此攻击，请修改构造函数，使其在请求创建第二个实例时抛出异常。<br>　在第二个实现单例的方法中，公共成员是一个静态的工厂方法：</p><pre><code>// Singleton with static factorypublic class Elvis {    private static final Elvis INSTANCE = new Elvis();    private Elvis() { ... }    public static Elvis getInstance() { return INSTANCE; }    public void leaveTheBuilding() { ... }}</code></pre><p>所有对 Elvis.getInstance 的调用都返回相同的对象引用，并且不会创建其他的 Elvis 实例（与前面提到的警告相同）。</p><p>　　公共属性方法的主要优点是 API 明确表示该类是一个单例：公共静态属性是 final 的，所以它总是包含相同的对象引用。 第二个好处是它更简单。</p><p>　　静态工厂方法的优势之一在于，它提供了灵活性：在不改变其 API 的前提下，我们可以改变该类是否应该为单例的想法。工厂方法返回该类的唯一实例，但是，它很容易被修改，比如，改为每个调用该方法的线程返回一个唯一的实例。 第二个好处是，如果你的应用程序需要它，可以编写一个泛型单例工厂（generic singleton factory ）（详见第30 条）。 使用静态工厂的最后一个优点是，可以通过方法引用（method reference）作为提供者，例如 Elvis::instance 等同于 Supplier<elvis>。 除非满足以上任意一种优势，否则还是优先考虑公有域（public-field）的方法。</elvis></p><p>　　为了将上述方法中实现的单例类变成是可序列化的 （第 12 章），仅仅将 implements Serializable 添加到声明中是不够的。为了保证单例模式不被破坏，必须声明所有的实例字段为 transient，并提供一个 readResolve 方法（详见第 89 条）。否则，每当序列化的实例被反序列化时，就会创建一个新的实例，在我们的例子中，导致出现新的 Elvis 实例。为了防止这种情况发生，将如下的 readResolve 方法添加到 Elvis 类：</p><pre><code>// readResolve method to preserve singleton propertyprivate Object readResolve() {     // Return the one true Elvis and let the garbage collector     // take care of the Elvis impersonator.    return INSTANCE;}</code></pre><p>实现一个单例的第三种方法是声明单一元素的枚举类：</p><pre><code>// Enum singleton - the preferred approachpublic enum Elvis {    INSTANCE;    public void leaveTheBuilding() { ... }}</code></pre><p>　这种方式类似于公共属性方法，但更简洁，无偿地提供了序列化机制，并提供了防止多个实例化的坚固保证，即使是在复杂的序列化或反射攻击的情况下。这种方法可能感觉有点不自然，但是 单一元素枚举类通常是实现单例的最佳方式。注意，如果单例必须继承 Enum 以外的父类 (尽管可以声明一个 Enum 来实现接口)，那么就不能使用这种方法。</p><h1 id="使用私有构造器执行非实例化"><a href="#使用私有构造器执行非实例化" class="headerlink" title="使用私有构造器执行非实例化"></a>使用私有构造器执行非实例化</h1><p>试图通过创建抽象类来强制执行非实例化是行不通的。 该类可以被子类化，并且子类可以被实例化。此外，它误导用户认为该类是为继承而设计的（详见第 19 条）。不过，有一个简单的方法来确保非实例化。只有当类不包含显式构造器时，才会生成一个默认构造器，因此可以通过包含一个私有构造器来实现类的非实例化：</p><pre><code>// Noninstantiable utility classpublic class UtilityClass {    // Suppress default constructor for noninstantiability    private UtilityClass() {        throw new AssertionError();    }    ... // Remainder omitted}</code></pre><p>因为显式构造器是私有的，所以不可以在类的外部访问它。AssertionError 异常不是严格要求的，但是它可以避免不小心在类的内部调用构造器。它保证类在任何情况下都不会被实例化。这个习惯用法有点违反直觉，好像构造器就是设计成不能调用的一样。因此，如前面所示，添加注释是种明智的做法。</p><p>　　这种习惯有一个副作用，就是使得一个类不能子类化。所有的构造器都必须显式或隐式地调用父类构造器，而在这群情况下子类则没有可访问的父类构造器来调用。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二章阅读：创建和销毁对象&lt;br&gt;03.使用私有构造方法或枚类实现 Singleton 属性&lt;br&gt;04.使用私有构造器执行非实例化&lt;br&gt;（这两部分理解有困难，需要再查阅相关资料）&lt;br&gt;
    
    </summary>
    
      <category term="2019年12月" scheme="http://yoursite.com/categories/2019%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Design Pattern，Java" scheme="http://yoursite.com/tags/Design-Pattern%EF%BC%8CJava/"/>
    
  </entry>
  
  <entry>
    <title>设计模式学习笔记III</title>
    <link href="http://yoursite.com/2019/12/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0III/"/>
    <id>http://yoursite.com/2019/12/30/设计模式学习笔记III/</id>
    <published>2019-12-30T08:55:12.000Z</published>
    <updated>2019-12-30T10:12:54.670Z</updated>
    
    <content type="html"><![CDATA[<p>静态静态工厂方法</p><a id="more"></a><h1 id="序：什么是静态工厂方法"><a href="#序：什么是静态工厂方法" class="headerlink" title="序：什么是静态工厂方法"></a>序：什么是静态工厂方法</h1><p>在 Java 中，获得一个类实例最简单的方法就是使用 new 关键字，通过构造函数来实现对象的创建。<br>就像这样：</p><pre><code>Fragment fragment = new MyFragment();// orDate date = new Date();</code></pre><p>不过在实际的开发中，我们经常还会见到另外一种获取类实例的方法：</p><pre><code>Fragment fragment = MyFragment.newIntance();// orCalendar calendar = Calendar.getInstance();// orInteger number = Integer.valueOf(&quot;3&quot;);</code></pre><p> <strong><em>像这样的：不通过 new，而是用一个静态方法来对外提供自身实例的方法，即为我们所说的静态工厂方法(Static factory method)。</em></strong></p><h2 id="知识点：new-究竟做了什么"><a href="#知识点：new-究竟做了什么" class="headerlink" title="知识点：new 究竟做了什么?"></a>知识点：new 究竟做了什么?</h2><p>简单来说：当我们使用 new 来构造一个新的类实例时，其实是告诉了 JVM 我需要一个新的实例。JVM 就会自动在内存中开辟一片空间，然后调用构造函数来初始化成员变量，最终把引用返回给调用方。</p><h1 id="Effective-Java"><a href="#Effective-Java" class="headerlink" title="Effective Java"></a>Effective Java</h1><p>在关于 Java 中书籍中，《Effective Java》绝对是最负盛名几本的之一，在此书中，作者总结了几十条改善 Java 程序设计的金玉良言。其中开篇第一条就是『考虑使用静态工厂方法代替构造器』，关于其原因，作者总结了几条，我们先来逐个看一下。</p><h2 id="静态工厂方法与构造器不同的第一优势在于，它们有名字"><a href="#静态工厂方法与构造器不同的第一优势在于，它们有名字" class="headerlink" title="静态工厂方法与构造器不同的第一优势在于，它们有名字"></a>静态工厂方法与构造器不同的第一优势在于，它们有名字</h2><p>由于语言的特性，Java 的构造函数都是跟类名一样的。这导致的一个问题是构造函数的名称不够灵活，经常不能准确地描述返回值，在有多个重载的构造函数时尤甚，如果参数类型、数目又比较相似的话，那更是很容易出错。</p><p>比如，如下的一段代码 ：</p><pre><code>Date date0 = new Date();Date date1 = new Date(0L);Date date2 = new Date(&quot;0&quot;);Date date3 = new Date(1,2,1);Date date4 = new Date(1,2,1,1,1);Date date5 = new Date(1,2,1,1,1,1);</code></pre><p>Date 类有很多重载函数，对于开发者来说，假如不是特别熟悉的话，恐怕是需要犹豫一下，才能找到合适的构造函数的。而对于其他的代码阅读者来说，估计更是需要查看文档，才能明白每个参数的含义了。</p><p>（当然，Date 类在目前的 Java 版本中，只保留了一个无参和一个有参的构造函数，其他的都已经标记为 @Deprecated 了）</p><p>而如果使用静态工厂方法，就可以给方法起更多有意义的名字，比如前面的 valueOf、newInstance、getInstance 等，对于代码的编写和阅读都能够更清晰。</p><h2 id="第二个优势，不用每次被调用时都创建新对象"><a href="#第二个优势，不用每次被调用时都创建新对象" class="headerlink" title="第二个优势，不用每次被调用时都创建新对象"></a>第二个优势，不用每次被调用时都创建新对象</h2><p>这个很容易理解了，有时候外部调用者只需要拿到一个实例，而不关心是否是新的实例；又或者我们想对外提供一个单例时如果使用工厂方法，就可以很容易的在内部控制，防止创建不必要的对象，减少开销。</p><p>在实际的场景中，单例的写法也大都是用静态工厂方法来实现的。</p><p>如果你想对单例有更多了解，可以看一下这里：☞《Hi，我们再来聊一聊Java的单例吧》[2]</p><h2 id="第三个优势，可以返回原返回类型的子类"><a href="#第三个优势，可以返回原返回类型的子类" class="headerlink" title="第三个优势，可以返回原返回类型的子类"></a>第三个优势，可以返回原返回类型的子类</h2><p>这条不用多说，设计模式中的基本的原则之一——『里氏替换』原则，就是说子类应该能替换父类。<br>显然，构造方法只能返回确切的自身类型，而静态工厂方法则能够更加灵活，可以根据需要方便地返回任何它的子类型的实例。</p><pre><code>Class Person {    public static Person getInstance(){        return new Person();        // 这里可以改为 return new Player() / Cooker()    }}Class Player extends Person{}Class Cooker extends Person{}</code></pre><p>比如上面这段代码，Person 类的静态工厂方法可以返回 Person 的实例，也可以根据需要返回它的子类 Player 或者 Cooker。（当然，这只是为了演示，在实际的项目中，一个类是不应该依赖于它的子类的。但如果这里的 getInstance () 方法位于其他的类中，就更具有的实际操作意义了）</p><h2 id="静态工厂的第四个优点是返回对象的类可以根据输入参数的不同而不同"><a href="#静态工厂的第四个优点是返回对象的类可以根据输入参数的不同而不同" class="headerlink" title="静态工厂的第四个优点是返回对象的类可以根据输入参数的不同而不同"></a>静态工厂的第四个优点是返回对象的类可以根据输入参数的不同而不同</h2><p>EnumSet 类（详见第 36 条）没有公共构造方法，只有静态工厂。 在 OpenJDK 实现中，它们根据底层枚举类型的大小返回两个子类中的一个的实例：大多数枚举类型具有 64 个或更少的元素，静态工厂将返回一个 RegularEnumSet 实例， 底层是long 类型；如果枚举类型具有六十五个或更多元素，则工厂将返回一个 JumboEnumSet 实例，底层是long 类型的数组。</p><pre><code>/**     * Creates an empty enum set with the specified element type.     *     * @param &lt;E&gt; The class of the elements in the set     * @param elementType the class object of the element type for this enum     *     set     * @return An empty enum set of the specified type.     * @throws NullPointerException if &lt;tt&gt;elementType&lt;/tt&gt; is null     ** /    public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; noneOf(Class&lt;E&gt; elementType) {        Enum&lt;?&gt;[] universe = getUniverse(elementType);        if (universe == null)            throw new ClassCastException(elementType + &quot; not an enum&quot;);        if (universe.length &lt;= 64)            return new RegularEnumSet&lt;&gt;(elementType, universe);        else            return new JumboEnumSet&lt;&gt;(elementType, universe);    }</code></pre><p>　　这两个实现类的存在对于客户端而言是不可见的。 如果 RegularEnumSet 对于小的枚举类型不再具有性能优势，则可以在未来版本中将其淘汰，且不会产生任何不良影响。 同样，如果可以证明添加 EnumSet 的更多的实现可以提高性能，那么在未来的版本可能就会这样做。 客户既不知道也不关心他们从工厂返回的对象的类别; 他们只需要知道它是 EnumSet 的子类。</p><h2 id="第五个优势是，在编写包含该方法的类时，返回的对象的类不需要存在。"><a href="#第五个优势是，在编写包含该方法的类时，返回的对象的类不需要存在。" class="headerlink" title="第五个优势是，在编写包含该方法的类时，返回的对象的类不需要存在。"></a>第五个优势是，在编写包含该方法的类时，返回的对象的类不需要存在。</h2><p>这种灵活的静态工厂方法构成了服务提供者框架的基础，比如 Java 数据库连接 AP（JDBC）。服务提供者框架是提供者实现服务的系统，并且系统使得实现对客户端可用，从而将客户端从实现中分离出来。</p><p>书中这段读起来比较晦涩，对服务提供者框架在参考资料[3]中有解释，<br>　　<br><img src="assets/markdown-img-paste-20191230175836971.png" alt=""></p><p>服务提供者框架中有三个基本组：服务接口，它表示实现；提供者注册 API，提供者用来注册实现；以及服务访问 API，客户端使用该 API 获取服务的实例。服务访问 API 允许客户指定选择实现的标准。在缺少这样的标准的情况下，API 返回一个默认实现的实例，或者允许客户通过所有可用的实现进行遍历。服务访问 API 是灵活的静态工厂，它构成了服务提供者框架的基础。</p><p>  Class.forName(“com.mysql.jdbc.Driver”);</p><p>这样一个语句会实例化一个Driver类（提供服务者实现类），并将这个类的实例注册到DriverManager（服务提供者注册类）。</p><p>  DriverManager.getConnection(“jdbc:mysql://…”,”…”,”…”);<br>这里通过建立连接的URL等信息来获取数据库连接。DriverManager通过传进来的url信息判断出你是要获取那个服务提供者提供的服务。因为前面已经将提供服务者实现类注册到DriverManager了，DriverManager获取到这个服务提供者实现类对象之后，通过调用它的getService（mysql里面是connect方法）方法获取到服务具体实现类对象，返回的却是java.sql.Connection接口对象（因为服务具体实现类实现了Connection接口），这样把服务具体实现类对象隐藏了。提供了很好的扩展性。</p><p>　　服务提供者框架的一个可选的第四个组件是一个服务提供者接口，它描述了一个生成服务接口实例的工厂对象。在没有服务提供者接口的情况下，必须对实现进行反射实例化（详见第 65 条）。在 JDBC 的情况下，Connection 扮演服务接口的一部分，DriverManager.registerDriver 提供程序注册 API、DriverManager.getConnection 是服务访问 API，Driver 是服务提供者接口。</p><p>服务提供者框架模式有许多变种。 例如，服务访问 API 可以向客户端返回比提供者提供的更丰富的服务接口。 这是桥接模式。 依赖注入框架（详见第 5 条）可以被看作是强大的服务提供者。 从 Java 6 开始，平台包含一个通用的服务提供者框架 java.util.ServiceLoader，所以你不需要，一般也不应该自己编写（详见第 59 条）。 JDBC 不使用 ServiceLoader，因为前者早于后者。</p><h2 id="另一个优势，在创建带泛型的实例时，能使代码变得简洁"><a href="#另一个优势，在创建带泛型的实例时，能使代码变得简洁" class="headerlink" title="另一个优势，在创建带泛型的实例时，能使代码变得简洁"></a>另一个优势，在创建带泛型的实例时，能使代码变得简洁</h2><p>这条主要是针对带泛型类的繁琐声明而说的，需要重复书写两次泛型参数：</p><p>Map&lt;String,Date&gt; map = new HashMap&lt;String,Date&gt;();<br>不过自从 java7 开始，这种方式已经被优化过了 —— 对于一个已知类型的变量进行赋值时，由于泛型参数是可以被推导出，所以可以在创建实例时省略掉泛型参数。</p><p>Map&lt;String,Date&gt; map = new HashMap&lt;&gt;();</p><h1 id="除此之外"><a href="#除此之外" class="headerlink" title="除此之外"></a>除此之外</h1><p>以上是《Effective Java》中总结的几条应该使用静态工厂方法代替构造器的原因，除了上面总结的几条之外，静态工厂方法实际上还有更多的优势。</p><h2 id="可以有多个参数相同但名称不同的工厂方法"><a href="#可以有多个参数相同但名称不同的工厂方法" class="headerlink" title="可以有多个参数相同但名称不同的工厂方法"></a>可以有多个参数相同但名称不同的工厂方法</h2><p>构造函数虽然也可以有多个，但是由于函数名已经被固定，所以就要求参数必须有差异时（类型、数量或者顺序）才能够重载了。<br>举例来说：</p><pre><code>class Child{    int age = 10;    int weight = 30;    public Child(int age, int weight) {        this.age = age;        this.weight = weight;    }    public Child(int age) {        this.age = age;    }}</code></pre><p>Child 类有 age 和 weight 两个属性，如代码所示，它已经有了两个构造函数：Child(int age, int weight) 和 Child(int age)，这时候如果我们想再添加一个指定 wegiht 但不关心 age 的构造函数，一般是这样：</p><pre><code>public Child( int weight) {    this.weight = weight;}</code></pre><p>但要把这个构造函数添加到 Child 类中，我们都知道是行不通的，因为 java 的函数签名是忽略参数名称的，所以 Child(int age) 跟 Child(int weight) 会冲突。</p><p>这时候，静态工厂方法就可以登场了。</p><pre><code>class Child{    int age = 10;    int weight = 30;    public static Child newChild(int age, int weight) {        Child child = new Child();        child.weight = weight;        child.age = age;        return child;    }    public static Child newChildWithWeight(int weight) {        Child child = new Child();        child.weight = weight;        return child;    }    public static Child newChildWithAge(int age) {        Child child = new Child();        child.age = age;        return child;    }}</code></pre><p>其中的 newChildWithWeight 和 newChildWithAge，就是两个参数类型相同的的方法，但是作用不同，如此，就能够满足上面所说的类似Child(int age) 跟 Child(int weight)同时存在的需求。<br>（另外，这两个函数名字也是自描述的，相对于一成不变的构造函数更能表达自身的含义，这也是上面所说的第一条优势 —— 『它们有名字』）</p><h2 id="可以减少对外暴露的属性"><a href="#可以减少对外暴露的属性" class="headerlink" title="可以减少对外暴露的属性"></a>可以减少对外暴露的属性</h2><p>软件开发中有一条很重要的经验：对外暴露的属性越多，调用者就越容易出错。所以对于类的提供者，一般来说，应该努力减少对外暴露属性，从而降低调用者出错的机会。</p><p>考虑一下有如下一个 Player 类：</p><pre><code>// Player : Version 1class Player {    public static final int TYPE_RUNNER = 1;    public static final int TYPE_SWIMMER = 2;    public static final int TYPE_RACER = 3;    protected int type;    public Player(int type) {        this.type = type;    }}</code></pre><p>Player 对外提供了一个构造方法，让使用者传入一个 type 来表示类型。那么这个类期望的调用方式就是这样的：</p><pre><code>Player player1 = new Player(Player.TYPE_RUNNER);Player player2 = new Player(Player.TYPE_SWEIMMER);</code></pre><p>但是，我们知道，提供者是无法控制调用方的行为的，实际中调用方式可能是这样的：</p><pre><code>Player player3 = new Player(0);Player player4 = new Player(-1);Player player5 = new Player(10086);</code></pre><p>提供者期望的构造函数传入的值是事先定义好的几个常量之一，但如果不是，就很容易导致程序错误。</p><p>—— 要避免这种错误，使用枚举来代替常量值是常见的方法之一，当然如果不想用枚举的话，使用我们今天所说的主角静态工厂方法也是一个很好的办法。</p><p>插一句：<br>实际上，使用枚举也有一些缺点，比如增大了调用方的成本；如果枚举类成员增加，会导致一些需要完备覆盖所有枚举的调用场景出错等。<br>如果把以上需求用静态工厂方法来实现，代码大致是这样的：</p><pre><code>// Player : Version 2class Player {    public static final int TYPE_RUNNER = 1;    public static final int TYPE_SWIMMER = 2;    public static final int TYPE_RACER = 3;    int type;    private Player(int type) {        this.type = type;    }    public static Player newRunner() {        return new Player(TYPE_RUNNER);    }    public static Player newSwimmer() {        return new Player(TYPE_SWIMMER);    }    public static Player newRacer() {        return new Player(TYPE_RACER);    }}</code></pre><p>注意其中的构造方法被声明为了 private，这样可以防止它被外部调用，于是调用方在使用 Player 实例的时候，基本上就必须通过 newRunner、newSwimmer、newRacer 这几个静态工厂方法来创建，调用方无须知道也无须指定 type 值 —— 这样就能把 type 的赋值的范围控制住，防止前面所说的异常值的情况。</p><p>插一句：<br>严谨一些的话，通过反射仍能够绕过静态工厂方法直接调用构造函数，甚至直接修改一个已创建的 Player 实例的 type 值，但本文暂时不讨论这种非常规情况。</p><h2 id="多了一层控制，方便统一修改"><a href="#多了一层控制，方便统一修改" class="headerlink" title="多了一层控制，方便统一修改"></a>多了一层控制，方便统一修改</h2><p>我们在开发中一定遇到过很多次这样的场景：在写一个界面时，服务端的数据还没准备好，这时候我们经常就需要自己在客户端编写一个测试的数据，来进行界面的测试，像这样：</p><pre><code>// 创建一个测试数据User tester = new User();tester.setName(&quot;隔壁老王&quot;);tester.setAge(25);tester.setDescription(&quot;我住隔壁我姓王！&quot;);// use testerbindUI(tester);……</code></pre><p>要写一连串的测试代码，如果需要测试的界面有多个，那么这一连串的代码可能还会被复制多次到项目的多个位置。</p><p>这种写法的缺点呢，首先是代码臃肿、混乱；其次是万一上线的时候漏掉了某一处，忘记修改，那就可以说是灾难了……</p><p>但是如果你像我一样，习惯了用静态工厂方法代替构造器的话，则会很自然地这么写，先在 User 中定义一个 newTestInstance 方法：</p><pre><code>static class User{    String name ;    int age ;    String description;    public static User newTestInstance() {        User tester = new User();        tester.setName(&quot;隔壁老王&quot;);        tester.setAge(25);        tester.setDescription(&quot;我住隔壁我姓王！&quot;);        return tester;    }}</code></pre><p>然后调用的地方就可以这样写了：</p><pre><code>// 创建一个测试数据User tester = User.newTestInstance();// use testerbindUI(tester);</code></pre><p>是不是瞬间就觉得优雅了很多？！</p><p>而且不只是代码简洁优雅，由于所有测试实例的创建都是在这一个地方，所以在需要正式数据的时候，也只需把这个方法随意删除或者修改一下，所有调用者都会编译不通过，彻底杜绝了由于疏忽导致线上还有测试代码的情况。</p><h1 id="缺点：没有公共或受保护构造方法的类不能被子类化"><a href="#缺点：没有公共或受保护构造方法的类不能被子类化" class="headerlink" title="缺点：没有公共或受保护构造方法的类不能被子类化"></a>缺点：没有公共或受保护构造方法的类不能被子类化</h1><p>例如，要想将 Collections 框架中任何遍历的实现类进行子类化，是不可能的。但是这样也会因祸得福，因为它鼓励程序员使用组合（composition）而不是继承（详见第 18 条），并且是不可变类型锁需要的（详见第 17 条）。</p><h1 id="静态工厂方法的第二个缺点是，程序员很难找到它们"><a href="#静态工厂方法的第二个缺点是，程序员很难找到它们" class="headerlink" title="静态工厂方法的第二个缺点是，程序员很难找到它们"></a>静态工厂方法的第二个缺点是，程序员很难找到它们</h1><p>它们不像构造方法那样在 API 文档中明确的标注出来。因此，对于提供了静态方法而不是构造器的类来说，想要查明如何实例化一个类是十分困难的。</p><p>通过关注类或者接口的文档中静态方法，并且遵守标准的命名习惯，也可以弥补这一劣势。下面是一些静态工厂方法的常用名称。以下清单这是列出了其中的一小部分：</p><p>from —— 类型转换方法，它接受单个参数并返回此类型的相应实例，例如：</p><pre><code>Date d = Date.from(instant);</code></pre><p>of —— 聚合方法，接受多个参数并返回该类型的实例，并把他们合并在一起，例如：</p><pre><code>Set faceCards = EnumSet.of(JACK, QUEEN, KING);</code></pre><p>valueOf —— from 和 to 更为详细的替代 方式，例如：</p><pre><code>BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);</code></pre><p>instance 或 getinstance —— 返回一个由其参数 (如果有的话) 描述的实例，但不能说它具有相同的值，例如：</p><pre><code>StackWalker luke = StackWalker.getInstance(options);</code></pre><p>create 或 newInstance —— 与 instance 或 getInstance 类似，除此之外该方法保证每次调用返回一个新的实例，例如：</p><pre><code>Object newArray = Array.newInstance(classObject, arrayLen);</code></pre><p>getType —— 与 getInstance 类似，但是在工厂方法处于不同的类中的时候使用。getType 中的 Type 是工厂方法返回的对象类型，例如：</p><pre><code>FileStore fs = Files.getFileStore(path);</code></pre><p>newType —— 与 newInstance 类似，但是在工厂方法处于不同的类中的时候使用。newType中的 Type 是工厂方法返回的对象类型，例如：</p><pre><code>BufferedReader br = Files.newBufferedReader(path);</code></pre><p>type —— getType 和 newType 简洁的替代方式，例如：</p><pre><code>List litany = Collections.list(legacyLitany);</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>静态工厂方法和公共构造方法都有它们的用途，并且了解它们的相对优点是值得的。通常，静态工厂更可取，因此避免在没有考虑静态工厂的情况下直接选择使用公共构造方法</p><p>总体来说，『考虑使用静态工厂方法代替构造器』这点，除了有名字、可以用子类等这些语法层面上的优势之外，更多的是在工程学上的意义，它实质上的最主要作用是：能够增大类的提供者对自己所提供的类的控制力。</p><p>作为一个开发者，当我们作为调用方，使用别人提供的类时，如果要使用 new 关键字来为其创建一个类实例，如果对类不是特别熟悉，那么一定是要特别慎重的 —— new 实在是太好用了，以致于它经常被滥用，随时随地的 new 是有很大风险的，除了可能导致性能、内存方面的问题外，也经常会使得代码结构变得混乱。</p><p>而当我们在作为类的提供方时，无法控制调用者的具体行为，但是我们可以尝试使用一些方法来增大自己对类的控制力，减少调用方犯错误的机会，这也是对代码更负责的具体体现。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】 <a href="https://www.diycode.cc/topics/1027" target="_blank" rel="noopener">https://www.diycode.cc/topics/1027</a><br>【2】 <a href="https://www.jianshu.com/p/eb30a388c5fc" target="_blank" rel="noopener">https://www.jianshu.com/p/eb30a388c5fc</a><br>【3】 <a href="https://juejin.im/post/5d6a0652f265da03df5f285d" target="_blank" rel="noopener">https://juejin.im/post/5d6a0652f265da03df5f285d</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;静态静态工厂方法&lt;/p&gt;
    
    </summary>
    
      <category term="2019年12月" scheme="http://yoursite.com/categories/2019%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Design Pattern，Java" scheme="http://yoursite.com/tags/Design-Pattern%EF%BC%8CJava/"/>
    
  </entry>
  
  <entry>
    <title>Effctive-Java阅读笔记I</title>
    <link href="http://yoursite.com/2019/12/30/Effctive-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0I/"/>
    <id>http://yoursite.com/2019/12/30/Effctive-Java阅读笔记I/</id>
    <published>2019-12-30T08:30:12.000Z</published>
    <updated>2019-12-31T03:50:26.601Z</updated>
    
    <content type="html"><![CDATA[<p>第二章阅读：创建和销毁对象：<br>01.考虑使用静态工厂方法替代构造方法<br>02.当构造方法参数过多时使用 builder 模式</p><a id="more"></a><h1 id="考虑使用静态工厂方法替代构造方法"><a href="#考虑使用静态工厂方法替代构造方法" class="headerlink" title="考虑使用静态工厂方法替代构造方法"></a>考虑使用静态工厂方法替代构造方法</h1><p>此处详见设计模式学习笔记III-静态工厂方法。</p><h1 id="当构造方法参数过多时使用-builder-模式"><a href="#当构造方法参数过多时使用-builder-模式" class="headerlink" title="当构造方法参数过多时使用 builder 模式"></a>当构造方法参数过多时使用 builder 模式</h1><p>静态工厂和构造方法都有一个限制：它们不能很好地扩展到很多可选参数的情景。传统上，程序员使用了可伸缩（telescoping constructor）构造方法模式。<br>在这种模式中，首先提供一个只有必需参数的构造方法，接着提供增加了一个可选参数的构造函数，然后提供增加了两个可选参数的构造函数，等等，最终在构造函数中包含所有必需和可选参数。以下就是它在实践中的样子。为了简便起见，只显示了四个可选属性：</p><pre><code>// Telescoping constructor pattern - does not scale well!public class NutritionFacts {    private final int servingSize;  // (mL)            required    private final int servings;     // (per container) required    private final int calories;     // (per serving)   optional    private final int fat;          // (g/serving)     optional    private final int sodium;       // (mg/serving)    optional    private final int carbohydrate; // (g/serving)     optional    public NutritionFacts(int servingSize, int servings) {        this(servingSize, servings, 0);    }    public NutritionFacts(int servingSize, int servings,            int calories) {        this(servingSize, servings, calories, 0);    }    public NutritionFacts(int servingSize, int servings,            int calories, int fat) {        this(servingSize, servings, calories, fat, 0);    }    public NutritionFacts(int servingSize, int servings,            int calories, int fat, int sodium) {        this(servingSize, servings, calories, fat, sodium, 0);    }    public NutritionFacts(int servingSize, int servings,           int calories, int fat, int sodium, int carbohydrate) {        this.servingSize  = servingSize;        this.servings     = servings;        this.calories     = calories;        this.fat          = fat;        this.sodium       = sodium;        this.carbohydrate = carbohydrate;    }}</code></pre><p>当想要创建一个实例时，可以使用包含所有要设置的参数的最短参数列表的构造方法：</p><pre><code>NutritionFacts cocaCola = new NutritionFacts(240, 8, 100, 0, 35, 27);</code></pre><p>通常情况下，这个构造方法的调用需要许多你不想设置的参数，但是你不得不为它们传递一个值。 在这种情况下，我们为 fat 属性传递了 0 值。「只有」六个参数可能看起来并不那么糟糕，但随着参数数量的增加，它很快就会失控。</p><p>　　简而言之，可伸缩构造方法模式是有效的，但是当有很多参数时，很难编写客户端代码，而且很难读懂它。</p><p>当在构造方法中遇到许多可选参数时，另一种选择是 JavaBeans 模式，在这种模式中，调用一个无参的构造方法来创建对象，然后调用 setter 方法来设置每个必需的参数和可选参数：</p><pre><code>// JavaBeans Pattern - allows inconsistency, mandates mutabilitypublic class NutritionFacts {// Parameters initialized to default values (if any)private int servingSize  = -1; // Required; no default valueprivate int servings     = -1; // Required; no default valueprivate int calories     = 0;private int fat          = 0;private int sodium       = 0;private int carbohydrate = 0;public NutritionFacts() { }// Setterspublic void setServingSize(int val)  { servingSize = val; }public void setServings(int val)    { servings = val; }public void setCalories(int val)    { calories = val; }public void setFat(int val)         { fat = val; }public void setSodium(int val)      { sodium = val; }public void setCarbohydrate(int val) { carbohydrate = val; }}</code></pre><p>这种模式没有伸缩构造方法模式的缺点。有点冗长，但创建实例很容易，并且易于阅读所生成的代码:</p><pre><code>NutritionFacts cocaCola = new NutritionFacts();cocaCola.setServingSize(240);cocaCola.setServings(8);cocaCola.setCalories(100);cocaCola.setSodium(35);cocaCola.setCarbohydrate(27);</code></pre><p>JavaBeans 模式本身有严重的缺陷。由于构造方法被分割成了多次调用，所以在构造过程中 JavaBean 可能处于不一致的状态。该类没有通过检查构造参数参数的有效性来强制一致性的选项。在不一致的状态下尝试使用对象可能会导致一些错误，这些错误与平常代码的BUG很是不同，因此很难调试。一个相关的缺点是，JavaBeans 模式排除了让类不可变的可能性（详见第 17 条），并且需要程序员增加工作以确保线程安全。</p><p>　　通过在对象构建完成时手动「冻结」对象，并且不允许它在解冻之前使用，可以减少这些缺点，但是这种变体在实践中很难使用并且很少使用。 而且，在运行时会导致错误，因为编译器无法确保程序员会在使用对象之前调用 freeze 方法。</p><p>　　幸运的是，还有第三种选择，它结合了可伸缩构造方法模式的安全性和 JavaBean 模式的可读性。 它是 Builder 模式[Gamma95] 的一种形式。客户端不直接构造所需的对象，而是调用一个包含所有必需参数的构造方法 (或静态工厂)得到获得一个 builder 对象。以下是它在实践中的示例：</p><pre><code>// Builder Patternpublic class NutritionFacts {    private final int servingSize;    private final int servings;    private final int calories;    private final int fat;    private final int sodium;    private final int carbohydrate;    public static class Builder {        // Required parameters        private final int servingSize;        private final int servings;        // Optional parameters - initialized to default values        private int calories      = 0;        private int fat           = 0;        private int sodium        = 0;        private int carbohydrate  = 0;        public Builder(int servingSize, int servings) {            this.servingSize = servingSize;            this.servings    = servings;        }        public Builder calories(int val) {            calories = val;                  return this;        }        public Builder fat(int val) {           fat = val;                      return this;        }        public Builder sodium(int val) {           sodium = val;                   return this;        }        public Builder carbohydrate(int val) {           carbohydrate = val;             return this;        }        public NutritionFacts build() {            return new NutritionFacts(this);        }    }    private NutritionFacts(Builder builder) {        servingSize  = builder.servingSize;        servings     = builder.servings;        calories     = builder.calories;        fat          = builder.fat;        sodium       = builder.sodium;        carbohydrate = builder.carbohydrate;    }}</code></pre><p>然后，客户端调用 builder 对象的与 setter 相似方法来设置你想设置的可选参数。最后，客户端调用builder对象的一个无参的 build 方法来生成对象，该对象通常是不可变的。Builder 通常是它所构建的类的一个静态成员类（详见第 24 条）。<br>　　NutritionFacts 类是不可变的，所有的参数默认值都在一个地方。builder 的 setter 方法返回 builder 本身，这样就可以进行链式调用，从而生成一个流畅的 API。下面是客户端代码的示例：</p><pre><code>NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8).calories(100).sodium(35).carbohydrate(27).build();</code></pre><p>为了简洁起见，省略了有效性检查。 要尽快检测无效参数，检查 builder 的构造方法和方法中的参数有效性。 在 build 方法调用的构造方法中检查包含多个参数的不变性。为了确保这些不变性不受攻击，在从 builder 复制参数后对对象属性进行检查（详见第 50 条）。 如果检查失败，则抛出 IllegalArgumentException 异常（详见第 72 条），其详细消息指示哪些参数无效（详见第 75 条）。</p><p>Builder 模式非常适合类层次结构。 使用平行层次的 builder，每个builder嵌套在相应的类中。 抽象类有抽象的 builder；具体的类有具体的 builder。 例如，考虑代表各种比萨饼的根层次结构的抽象类：</p><pre><code>// Builder pattern for class hierarchiesimport java.util.EnumSet;import java.util.Objects;import java.util.Set;public abstract class Pizza {  //配料枚举：火腿，蘑菇，洋葱，辣椒，香肠    public enum Topping {HAM, MUSHROOM, ONION, PEPPER, SAUSAGE}    final Set&lt;Topping&gt; toppings;    abstract static class Builder&lt;T extends Builder&lt;T&gt;&gt; {        EnumSet&lt;Topping&gt; toppings = EnumSet.noneOf(Topping.class);        public T addTopping(Topping topping) {            toppings.add(Objects.requireNonNull(topping));            return self();        }        abstract Pizza build();        // Subclasses must override this method to return &quot;this&quot;        protected abstract T self();    }    Pizza(Builder&lt;?&gt; builder) {        toppings = builder.toppings.clone(); // See Item 50    }}</code></pre><p>请注意，Pizza.Builder 是一个带有递归类型参数（ recursive type parameter）（详见第 30 条）的泛型类型。 这与抽象的 self 方法一起，允许方法链在子类中正常工作，而不需要强制转换。 Java 缺乏自我类型的这种变通解决方法被称为模拟自我类型（simulated self-type）。</p><p>　　这里有两个具体的 Pizza 的子类，其中一个代表标准的纽约风格的披萨，另一个是半圆形烤乳酪馅饼。前者有一个所需的尺寸参数，而后者则允许指定酱汁是否应该在里面或在外面：</p><pre><code>import java.util.Objects;public class NyPizza extends Pizza {    public enum Size { SMALL, MEDIUM, LARGE }    private final Size size;    public static class Builder extends Pizza.Builder&lt;Builder&gt; {        private final Size size;        public Builder(Size size) {            this.size = Objects.requireNonNull(size);        }        @Override public NyPizza build() {            return new NyPizza(this);        }        @Override protected Builder self() {            return this;        }    }    private NyPizza(Builder builder) {        super(builder);        size = builder.size;    }}public class Calzone extends Pizza {    private final boolean sauceInside; //内部的酱料    public static class Builder extends Pizza.Builder&lt;Builder&gt; {        private boolean sauceInside = false; // Default        public Builder sauceInside() {            sauceInside = true;            return this;        }        @Override public Calzone build() {            return new Calzone(this);        }        @Override protected Builder self() {            return this;        }    }    private Calzone(Builder builder) {        super(builder);        sauceInside = builder.sauceInside;    }}</code></pre><p>请注意，每个子类 builder 中的 build 方法被声明为返回正确的子类：NyPizza.Builder 的 build 方法返回 NyPizza，而 Calzone.Builder 中的 build 方法返回 Calzone。 这种技术，其一个子类的方法被声明为返回在超类中声明的返回类型的子类型，称为协变返回类型（covariant return typing）。 它允许客户端使用这些 builder，而不需要强制转换。</p><p>　　这些「分层 builder（hierarchical builders）」的客户端代码基本上与简单的 NutritionFacts builder 的代码相同。为了简洁起见，下面显示的示例客户端代码假设枚举常量的静态导入：</p><pre><code>NyPizza pizza = new NyPizza.Builder(SMALL)        .addTopping(SAUSAGE).addTopping(ONION).build();Calzone calzone = new Calzone.Builder()        .addTopping(HAM).sauceInside().build();</code></pre><p>builder 对构造方法的一个微小的优势是，builder 可以有多个可变参数，因为每个参数都是在它自己的方法中指定的。或者，builder 可以将传递给多个调用的参数聚合到单个属性中，如前面的 addTopping 方法所演示的那样。</p><p>　　Builder 模式非常灵活。 单个 builder 可以重复使用来构建多个对象。 builder 的参数可以在构建方法的调用之间进行调整，以改变创建的对象。 builder 可以在创建对象时自动填充一些属性，例如每次创建对象时增加的序列号。</p><p>　　Builder 模式也有缺点。为了创建对象，首先必须创建它的 builder。虽然创建这个 builder 的成本在实践中不太可能被注意到，但在看中性能的场合下这可能就是一个问题。而且，builder 模式比伸缩构造方法模式更冗长，因此只有在有足够的参数时才值得使用它，比如四个或更多。但是请记住，你可能在以后会想要添加更多的参数。但是，如果你一开始是使用的构造方法或静态工厂，当类演化到参数数量失控的时候再转到Builder模式，过时的构造方法或静态工厂就会面临尴尬的处境。因此，通常最好从一开始就创建一个 builder。</p><p>　　总而言之，当设计类的构造方法或静态工厂的参数超过几个时，Builder 模式是一个不错的选择，特别是如果许多参数是可选的或相同类型的。builder模式客户端代码比使用伸缩构造方法（telescoping constructors）更容易读写，并且builder模式比 JavaBeans 更安全。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="https://sjsdfg.github.io/effective-java-3rd-chinese/#/" target="_blank" rel="noopener">https://sjsdfg.github.io/effective-java-3rd-chinese/#/</a><br>【2】<a href="https://lingcoder.github.io/OnJava8/#/" target="_blank" rel="noopener">https://lingcoder.github.io/OnJava8/#/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二章阅读：创建和销毁对象：&lt;br&gt;01.考虑使用静态工厂方法替代构造方法&lt;br&gt;02.当构造方法参数过多时使用 builder 模式&lt;/p&gt;
    
    </summary>
    
      <category term="2019年12月" scheme="http://yoursite.com/categories/2019%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Design Pattern，Java" scheme="http://yoursite.com/tags/Design-Pattern%EF%BC%8CJava/"/>
    
  </entry>
  
  <entry>
    <title>Scala学习笔记V</title>
    <link href="http://yoursite.com/2019/12/27/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0V/"/>
    <id>http://yoursite.com/2019/12/27/Scala学习笔记V/</id>
    <published>2019-12-27T06:08:12.000Z</published>
    <updated>2019-12-27T06:29:21.578Z</updated>
    
    <content type="html"><![CDATA[<p>scala中下划线_的用途</p><a id="more"></a><h1 id="初始化。"><a href="#初始化。" class="headerlink" title="初始化。"></a>初始化。</h1><pre><code>object Sample { var name:String=_ def main (args: Array[String]){ name=&quot;hello world&quot;  println(name) }</code></pre><p>在这里，name也可以声明为null，例：var name:String=null。这里的下划线和null的作用是一样的。</p><h1 id="引入时"><a href="#引入时" class="headerlink" title="引入时"></a>引入时</h1><pre><code>import math._object Sample {   def main (args: Array[String]){    println(BigInt(123))   }}</code></pre><p>这里的math._就相当于Java中的math.*; 即“引用包中的所有内容”。</p><h1 id="集合中使用。（最典型，最常用）"><a href="#集合中使用。（最典型，最常用）" class="headerlink" title="集合中使用。（最典型，最常用）"></a>集合中使用。（最典型，最常用）</h1><pre><code> object Sample {   def main (args: Array[String]){    val newArry= (1 to 10).map(_*2)   println(newArry)   }}</code></pre><p>这里的下划线代表了集合中的“某（this）”一个元素。这个用法很常见，在foreach等语句中也可以使用。</p><h1 id="模式匹配。"><a href="#模式匹配。" class="headerlink" title="模式匹配。"></a>模式匹配。</h1><pre><code> object Sample {   def main (args: Array[String]){     val value=&quot;a&quot;  val result=  value match{       case &quot;a&quot; =&gt; 1       case &quot;b&quot; =&gt; 2       case _ =&gt;&quot;result&quot;     }     println(result)   }}</code></pre><p>在这里的下划线相当于“others”的意思，就像Java  switch语句中的“default”。</p><p>还有一种写法，是被Some“包”起来的，说明Some里面是有值的，而不是None。<br>    object Sample {<br>      def main (args: Array[String]){<br>        val value=Some(“a”)<br>        val result=  value match{<br>          case Some(_) =&gt; 1<br>          case _ =&gt;”result”<br>        }<br>        println(result)<br>      }</p><p>还有一种表示队列</p><pre><code>object Sample {  def main (args: Array[String]){    val value=1 to 5    val result=  value match{      case Seq(_,_*) =&gt; 1      case _ =&gt;&quot;result&quot;    }    println(result)  }}</code></pre><h1 id="函数中使用。"><a href="#函数中使用。" class="headerlink" title="函数中使用。"></a>函数中使用。</h1><pre><code>object Sample {   def main (args: Array[String]){    val set=setFunction(3.0,_:Double)     println(set(7.1))   }  def setFunction(parm1:Double,parm2:Double): Double = parm1+parm2}</code></pre><p>这是Scala特有的“偏函数”用法。</p><h1 id="元组Tuple。（如果这也算是的话）"><a href="#元组Tuple。（如果这也算是的话）" class="headerlink" title="元组Tuple。（如果这也算是的话）"></a>元组Tuple。（如果这也算是的话）</h1><pre><code>object Sample {   def main (args: Array[String])={     val value=(1,2)     print(value._1)   }}</code></pre><h1 id="传参。"><a href="#传参。" class="headerlink" title="传参。"></a>传参。</h1><pre><code>object Sample {   def main (args: Array[String])={    val result=sum(1 to 5:_*)     println(result)   }  def sum(parms:Int*)={    var result=0    for(parm &lt;- parms)result+=parm    result  }}</code></pre><p>当函数接收的参数不定长的时候，假如你想输入一个队列，可以在一个队列后加入“:_*”，因此，这里的“1 to 5”也可以改写为：“Seq(1,2,3,4,5)”。这算是一个小的用法吧</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://blog.csdn.net/i6448038/article/details/50017427" target="_blank" rel="noopener">https://blog.csdn.net/i6448038/article/details/50017427</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;scala中下划线_的用途&lt;/p&gt;
    
    </summary>
    
      <category term="2019年12月" scheme="http://yoursite.com/categories/2019%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记XII</title>
    <link href="http://yoursite.com/2019/12/24/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0XII/"/>
    <id>http://yoursite.com/2019/12/24/Java学习笔记XII/</id>
    <published>2019-12-24T03:21:12.000Z</published>
    <updated>2019-12-25T08:52:45.588Z</updated>
    
    <content type="html"><![CDATA[<p>使用Java批量转换文件夹中的文件编码格式，删除文件中的代码</p><a id="more"></a><p>用Java将某个文件夹中UTF-8格式的文件批量转换为GBK格式的文件，代码如下：</p><p>   private static String sourcePath = “/Users/liyiye/Documents/课程代码”;// 文件夹源路径<br>   private static String destPath = “/Users/liyiye/Documents/ANSI格式课程代码”;<br>   private static void utf8ToANSI(){<br>       try {<br>           File sourceDirectory = new File(sourcePath);<br>           File destDirectory = new File(destPath);<br>           if (!sourceDirectory.isDirectory()) {<br>               return;<br>           }<br>           // 获取文件夹中的所有.cpp文件，包括所有子级文件夹中的文件<br>           Collection<file> files = FileUtils.listFiles(sourceDirectory, new String[] { “cpp”, “CPP” }, true);<br>           for (File file : files) {<br>               String absolutePath = file.getAbsolutePath();<br>               String newDir = absolutePath.replace(sourceDirectory.getName(), destDirectory.getName());<br>               // 把单个文件从utf-8编码转化到gbk编码，生成新文件，可以自动创建父级目录<br>               FileUtils.writeLines(new File(newDir), “GBK”, FileUtils.readLines(file, “UTF-8”));<br>           }<br>           // 删除源目录,子文件都删除<br>           // FileUtils.deleteQuietly(sourceDirectory);<br>           // 把生成文件目录重命名成源目录名<br>           destDirectory.renameTo(new File(sourceDirectory.getAbsolutePath()));<br>           System.out.println(“success”);<br>       } catch (IOException e) {<br>           e.printStackTrace();<br>       }<br>   }</file></p><p>批量删除代码中的注释</p><pre><code>private static int count = 0;/** * 删除文件中的各种注释，包含//、/* * /等 * * @param charset *            文件编码 * @param file *            文件 */public static void clearComment(File file, String charset) {    try {        // 递归处理文件夹        if (!file.exists()) {            return;        }        if (file.isDirectory()) {            File[] files = file.listFiles();            for (File f : files) {                clearComment(f, charset); // 递归调用            }            return;        } else if (!file.getName().endsWith(&quot;.cpp&quot;)) {            // 非java文件直接返回            return;        }        System.out.println(&quot;-----开始处理文件：&quot; + file.getAbsolutePath());        // 根据对应的编码格式读取        BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(file), charset));        StringBuffer content = new StringBuffer();        String tmp = null;        while ((tmp = reader.readLine()) != null) {            content.append(tmp);            content.append(&quot;\n&quot;);        }        reader.close();        String target = content.toString();        // String s =        // target.replaceAll(&quot;\\/\\/[^\\n]*|\\/\\*([^\\*^\\/]*|[\\*^\\/*]*|[^\\**\\/]*)*\\*\\/&quot;,        // &quot;&quot;); //本段正则摘自网上，有一种情况无法满足（/* ...**/），略作修改        String s = target.replaceAll(&quot;\\/\\/[^\\n]*|\\/\\*([^\\*^\\/]*|[\\*^\\/*]*|[^\\**\\/]*)*\\*+\\/&quot;, &quot;&quot;);        // System.out.println(s);        // 使用对应的编码格式输出        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), charset));        out.write(s);        out.flush();        out.close();        count++;        System.out.println(&quot;-----文件处理完成---&quot; + count);    } catch (Exception e) {        e.printStackTrace();    }}public static void clearComment(String filePath, String charset) {    clearComment(new File(filePath), charset);}public static void clearComment(String filePath) {    clearComment(new File(filePath), &quot;GBK&quot;);}public static void clearComment(File file) {    clearComment(file, &quot;GBK&quot;);}public  static   void  main(String[] args){    clearComment(destPath);}</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="https://blog.csdn.net/qq1032355091/article/details/51803496" target="_blank" rel="noopener">https://blog.csdn.net/qq1032355091/article/details/51803496</a><br>【2】<a href="https://www.cnblogs.com/hfultrastrong/p/7689630.html" target="_blank" rel="noopener">https://www.cnblogs.com/hfultrastrong/p/7689630.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Java批量转换文件夹中的文件编码格式，删除文件中的代码&lt;/p&gt;
    
    </summary>
    
      <category term="2019年12月" scheme="http://yoursite.com/categories/2019%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Scala学习笔记IV</title>
    <link href="http://yoursite.com/2019/12/23/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0IV/"/>
    <id>http://yoursite.com/2019/12/23/Scala学习笔记IV/</id>
    <published>2019-12-23T10:08:12.000Z</published>
    <updated>2019-12-23T10:19:25.471Z</updated>
    
    <content type="html"><![CDATA[<p>数据库连接和事务处理</p><a id="more"></a><h1 id="Session-管理"><a href="#Session-管理" class="headerlink" title="Session 管理"></a>Session 管理</h1><p>现在有了一个数据库对象可以打开一个数据库（Slick 函数库封装了一个 Session 对象）</p><p>Database 的 withSession 方法，创建一个 Session 对象，它可以传递给一个函数，函数返回时自动关闭这个 Session 对象，如果你使用连接池，关闭 Session 对象，自动将连接退回连接池。</p><pre><code>val query = for (c &lt;- coffees) yield c.nameval result = db.withSession {    session =&gt;    query.list()( session )}</code></pre><p>可以看到，我们可以在 withSession 之外定义查询，只有在实际执行查询时才需要一个 Session 对象，要注意的是 Session 的缺省模式为自动提交（auto-commit )模式。每个数据库指令（比如 insert )都自动提交给数据库。 如果需要将几个指令作为一个整体，那么就需要使用事务处理（Transaction） 上面的例子，我们在执行查询时，明确指明了 session 对象，你可以使用隐含对象来避免这种情况，比如：</p><pre><code>val query = for (c &lt;- coffees) yield c.nameval result = db.withSession {    implicit session =&gt;    query.list // &lt;- takes session implicitly}// query.list // &lt;- would not compile, no implicit value of type Session</code></pre><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="http://wiki.jikexueyuan.com/project/slick-guide/database-and-transaction-processing.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/slick-guide/database-and-transaction-processing.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据库连接和事务处理&lt;/p&gt;
    
    </summary>
    
      <category term="2019年12月" scheme="http://yoursite.com/categories/2019%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记XI</title>
    <link href="http://yoursite.com/2019/12/23/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0XI/"/>
    <id>http://yoursite.com/2019/12/23/Java学习笔记XI/</id>
    <published>2019-12-23T07:41:12.000Z</published>
    <updated>2019-12-23T08:22:59.724Z</updated>
    
    <content type="html"><![CDATA[<p>Java中静态方法和实例方法的异同</p><a id="more"></a><h1 id="类方法（静态方法）："><a href="#类方法（静态方法）：" class="headerlink" title="类方法（静态方法）："></a>类方法（静态方法）：</h1><p>用static修饰的方法，也称为静态方法，类方法属类本身的方法，不属于类的某一个实例（对象）。类方法中不可直接使用实例变量。其调用方式有三种：可直接调用、类名.方法名、对象名.方法名。</p><p>类方法体有如下限制：</p><p>1.类方法中不能引用对象变量；</p><p>2.类方法中不能调用类的对象方法；</p><p>3.在类方法中不能调使用super，this关键字；</p><p>4.类方法不能被覆盖。</p><h1 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h1><p>指的是不用static关键字修饰的方法。每个实例对象都有自身的实例方法，互相独立，不共享一个。其调用方式只能是对象名.方法名。</p><p>用修饰符static声明的方法为静态方法，不用修饰符static声明的方法为实例方法。</p><p>不管类生成或未生成对象，类的静态方法都可以被使用，使用格式为：类名.静态方法名。静态方法只能使用该静态方法所在类的静态数据成员和静态方法。这是因为使用静态方法时，该静态方法所在类可能还没有对象，即使有对象，由于用类名.静态方法名方式调用静态方法，静态方法没有this指针来存放对象的地址，无法判定应访问哪个对象的数据成员。在类创建对象后，实例方法才能被使用，使用格式为：对象名.实例方法名。实例方法可以使用该方法所在类的所有静态成员和实例成员。 </p><p>1.实例方法中可以引用对象变量，也可以引用类变量；</p><p>2.实例方法中可以调用类方法；</p><p>3.对象方法中可以使用super，this关键字。</p><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>当类的字节码文件被加载到内存时，类的实例方法不会被分配入口地址，当该类创建对象后，类中的实例方法才分配入口地址，从而实例方法可以被类创建的任何对象调用执行。需要注意的是，当我们创建第一个对象时，类中的实例方法就分配了入口地址，当再创建对象时，不再分配入口地址，也就是说，方法的入口地址被所有的对象共享，当所有的对象都不存在时，方法的入口地址才被取消。</p><p>对于类中的类方法，在该类被加载到内存时，就分配了相应的入口地址。从而类方法不仅可以被类创建的任何对象调用执行，也可以直接通过类名调用。类方法的入口地址直到程序退出时才被取消。</p><p>类方法在类的字节码加载到内存时就分配了入口地址。因此，Java语言允许通过类名直接调用类方法，而实例方法不能通过类名调用。在Java语言中，类中的类方法不可以操作实例变量，也不可以调用实例方法，这是因为在类创建对象之前，实例成员变量还没有分配内存，而且实例方法也没有入口地址。</p><h1 id="何时用静态方法，何时用实例方法？"><a href="#何时用静态方法，何时用实例方法？" class="headerlink" title="何时用静态方法，何时用实例方法？"></a>何时用静态方法，何时用实例方法？</h1><p>先说实例方法，当给一个类写一个方法，如果该方法需要访问某个实例的成员变量时，那么就将该方法定义成实例方法。一类的实例通常有一些成员变量，其中含有该实例的状态信息。而该方法需要改变这些状态。那么该方法需要声明成实例方法。</p><p>静态方法正好相反，它不需要访问某个实例的成员变量，它不需要去改变某个实例的状态。我们把该方法定义成静态方法。</p><h1 id="关于静态方法和实例方法的一些误区。"><a href="#关于静态方法和实例方法的一些误区。" class="headerlink" title="关于静态方法和实例方法的一些误区。"></a>关于静态方法和实例方法的一些误区。</h1><p>误区一、静态方法常驻内存，实例方法不是，所以静态方法效率高但占内存。</p><p>事实上，方法都是一样的，在加载时机和占用内存上，静态方法和实例方法是一样的，在类型第一次被使用时加载。调用的速度基本上没有差别。 </p><p>误区二、静态方法在堆上分配内存，实例方法在堆栈上。 </p><p>事实上所有的方法都不可能在堆或者堆栈上分配内存，方法作为代码是被加载到特殊的代码内存区域，这个内存区域是不可写的。 </p><p>误区三、实例方法需要先创建实例才可以调用，比较麻烦，静态方法不用，比较简单。 </p><pre><code>事实上如果一个方法与他所在类型的实例无关，那么它就应该是静态的，决不会有人把它写成实例方法。所以所有的实例方法都与实例有关，既然与实例有关，那么创建实例就是必然的步骤，没有麻烦简单一说。实际上上你可以把所有的实例方法都写成静态的，将实例作为参数传入即可。 </code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="https://blog.csdn.net/klyz1314/article/details/16845679" target="_blank" rel="noopener">https://blog.csdn.net/klyz1314/article/details/16845679</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java中静态方法和实例方法的异同&lt;/p&gt;
    
    </summary>
    
      <category term="2019年12月" scheme="http://yoursite.com/categories/2019%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Scala学习笔记III</title>
    <link href="http://yoursite.com/2019/12/23/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0III/"/>
    <id>http://yoursite.com/2019/12/23/Scala学习笔记III/</id>
    <published>2019-12-23T07:08:12.000Z</published>
    <updated>2019-12-23T09:39:43.100Z</updated>
    
    <content type="html"><![CDATA[<p>Scala学习：伴生对象中的apply方法</p><a id="more"></a><h1 id="单例对象"><a href="#单例对象" class="headerlink" title="单例对象"></a>单例对象</h1><p>Scala没有静态方法或字段，可以用object语法定义结构，对象定义了类的单个实例。<br>对象的构造器在该对象第一次使用时被调用。<br>不能提供构造器参数。<br>作为存放工具函数或常量的地方。<br>高效地共享单个不可变实例。</p><h1 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h1><p>在Scala中，可通过类和类同名的“伴生”对象来达到静态方法的目的。<br>类和它的伴生对象可以相互访问私有特性，它们必须存在于同一个源文件中</p><p>示例：</p><p>  class Account {</p><pre><code>val id = Account.newUniqueNumber()private var balance = 0.0def deposit(amount: Double): Double = {  balance += amount  balance}def nowBalance = balance;</code></pre><p>  }</p><p>  object Account {<br>    private var lastNumber = 0</p><pre><code>private def newUniqueNumber() = {  lastNumber += 1  lastNumber}</code></pre><p>  }</p><p>  object Main {<br>    def main(args: Array[String]): Unit = {<br>      val account = new Account<br>      println(account.deposit(1))<br>      println(“=” * 10)</p><pre><code>  val account1 = new Account  println(account1.id)  println(account1.deposit(10))  println(&quot;=&quot; * 10)  println(&quot;a &quot; + account.nowBalance + &quot;; b &quot; + account1.nowBalance)}</code></pre><p>  }</p><p>执行结果</p><p>  1</p><h1 id="1-0"><a href="#1-0" class="headerlink" title="  1.0"></a>  1.0</h1><p>  2</p><h1 id="10-0"><a href="#10-0" class="headerlink" title="  10.0"></a>  10.0</h1><p>  a 1.0; b 10.0</p><h1 id="apply方法"><a href="#apply方法" class="headerlink" title="apply方法"></a>apply方法</h1><p>一般在伴生对象中定义apply方法<br>常用于初始化操作或创建单例对象<br>在生成这个类的对象时，就省去了new关键字<br>在遇到Object(参数1，参数2，……，参数n)时就会自动调用apply()方法<br>    class Student private (val studentID: Int, val name: String){</p><pre><code>  override def toString: String = {    &quot;studentID &quot; + studentID + &quot; name &quot; + name  }}object Student {  private var studentID = 0  private def newSno = {    studentID += 1    studentID  }  def apply(name: String): Student = {    println(&quot;call apply method...&quot;)    new Student(newSno, name)  }}object StudentMain extends App {  // no new  val student1 = Student(&quot;YiyeLi&quot;)  println(student1.toString)  println(&quot;*&quot; * 10)  val student2 = Student(&quot;YiyeLi&quot;)  println(student2.toString)}</code></pre><p>执行结果：</p><pre><code>call apply method...studentID 1 name YiyeLi**********call apply method...studentID 2 name YiyeLi</code></pre><p>再举一个例子，一个trait可以看作是一个Java接口。我们使用一个伴生类Shape和一个伴生对象Shape，作为一个工厂。</p><pre><code>trait Shape {  def area :Double}object Shape {  private class Circle(radius: Double) extends Shape{    override val area = 3.14*radius*radius  }  private class Rectangle (height: Double, length: Double)extends Shape{    override val area = height * length  }  private class cube (x:Double,y:Double,z:Double) extends Shape{    override val area= x * y * z  }  def apply(height :Double , length :Double ) : Shape = new Rectangle(height,length)  def apply(radius :Double) : Shape = new Circle(radius)  def apply(x:Double,y:Double,z:Double): Shape = new cube(x,y,z)}object Main extends App {  val circle = Shape(2)  println(circle.area)  val rectangle = Shape(2,3)  println(rectangle.area)  val cube=Shape(3,4,5)  println(cube.area)}</code></pre><p>执行结果：</p><p>  12.56<br>  6.0<br>  60.0</p><h1 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h1><p>Scala程序必须从一个对象的main方法开始<br>有两种方法定义<br>  // 执行println语句<br>  object Main {<br>    def main(args: Array[String]): Unit = {</p><pre><code>  println(&quot;=&quot; * 10)}</code></pre><p>  }</p><p>  // 扩展App特质<br>  object Main extends App {<br>    println(“=” * 10)<br>  }</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://zhuanlan.zhihu.com/p/32834063" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32834063</a><br>【2】<a href="https://www.w3cschool.cn/scala/scala-companion-objects.html" target="_blank" rel="noopener">https://www.w3cschool.cn/scala/scala-companion-objects.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Scala学习：伴生对象中的apply方法&lt;/p&gt;
    
    </summary>
    
      <category term="2019年12月" scheme="http://yoursite.com/categories/2019%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记X</title>
    <link href="http://yoursite.com/2019/12/17/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0X/"/>
    <id>http://yoursite.com/2019/12/17/Java学习笔记X/</id>
    <published>2019-12-17T10:05:12.000Z</published>
    <updated>2019-12-19T10:25:15.159Z</updated>
    
    <content type="html"><![CDATA[<p>Java中前后端交互例如使用ajax异步传值。</p><a id="more"></a><p>AJAX（Asynchronous JavaScript and XML）意思就是用JavaScript执行异步网络请求。如果仔细观察一个Form的提交，你就会发现，一旦用户点击“Submit”按钮，表单开始提交，浏览器就会刷新页面，然后在新页面里告诉你操作是成功了还是失败了。如果不幸由于网络太慢或者其他原因，就会得到一个404页面。</p><p>这就是Web的运作原理：一次HTTP请求对应一个页面。</p><p>如果要让用户留在当前页面中，同时发出新的HTTP请求，就必须用JavaScript发送这个新请求，接收到数据后，再用JavaScript更新页面，这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断地更新。</p><p>前端代码：</p><p>  function sendMessage(tokenType){<br>     console.log(tokenType);<br>     var serverURL=”[[${serverURL}]]”;//从后端的map中获取<br>     //token服务地址<br>     var url = “/getToken”;<br>     $.ajax({<br>         type : “post”,<br>         data :{<br>         “tokenType”:tokenType<br>         },<br>         dataType:”json”,<br>         async : true,<br>         url : url,<br>         success:function(token){<br>               console.log(token)<br>               window.frames[0].postMessage(token.data,serverURL);<br>         },<br>         error: function() {<br>            alert(“获取token失败，请稍后再试！”);<br>          }<br>       });<br>后端代码：</p><pre><code>@Value(&quot;${cm.bussinessName}&quot;)//从application.yml中获取private String bussinessName;@Value(&quot;${cm.bussinessID}&quot;)private String bussinessID;@Value(&quot;${cm.sysID}&quot;)private String sysID;@Value(&quot;${cm.userName}&quot;)private String userName;@Value(&quot;${cm.serverURL}&quot;)private String serverURL;@ApiOperation(value = &quot;cm5页面接入接口&quot;)@GetMapping(&quot;/cm5&quot;)public String getCm5(ModelMap map) { String scanTargetUrl= String.format(&quot;%s/interaction/queryFile?clientId=$$$&amp;batchId=###&amp;bussinessId=%s&amp;bussTableName=%s&amp;userID=%s&amp;sysid=%s&quot;,serverURL,bussinessID,bussinessName,userName,sysID); String uploadTargetUrl=String.format(&quot;%s/interaction/operateParam?clientId=$$$&amp;batchId=###&amp;bussinessId=%s&amp;bussTableName=%s&amp;userID=longruntest&amp;sysid=%s&quot;,serverURL,bussinessID,bussinessName,sysID); map.put(&quot;scanTargetUrl&quot;,scanTargetUrl); map.put(&quot;uploadTargetUrl&quot;,uploadTargetUrl); map.put(&quot;serverURL&quot;,serverURL); return &quot;/cm5/cm5&quot;;}@PostMapping(&quot;/getToken&quot;)@ResponseBodypublic String getToken( String tokenType){    CMPlusClient cmclient = cm5UtilService.getCmPlusClient();    return cmclient.getToken(tokenType);}</code></pre><p>由于后端传递的targetUrl中的&amp;会被转义为&amp;，所以添加过滤函数</p><pre><code> function unescapeHTML(a){  a = &quot;&quot; + a;  return a.replace(/&amp;lt;/g, &quot;&lt;&quot;).replace(/&amp;gt;/g, &quot;&gt;&quot;).replace(/&amp;amp;/g, &quot;&amp;&quot;).replace(/&amp;quot;/g, &apos;&quot;&apos;).replace(/&amp;apos;/g, &quot;&apos;&quot;);}</code></pre><p>前端页面cm5.html中要注意js脚本的路径是否存在：<br>    <script src="static/js/jquery-1.11.1.min.js" type="text/javascript"></script></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="https://my.oschina.net/smfx1314/blog/3053056" target="_blank" rel="noopener">https://my.oschina.net/smfx1314/blog/3053056</a><br>【2】<a href="https://www.jianshu.com/p/35020e29206c" target="_blank" rel="noopener">https://www.jianshu.com/p/35020e29206c</a><br>【3】<a href="http://xbhong.top/2018/02/28/ajax/" target="_blank" rel="noopener">http://xbhong.top/2018/02/28/ajax/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java中前后端交互例如使用ajax异步传值。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年12月" scheme="http://yoursite.com/categories/2019%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>数据库学习笔记VI</title>
    <link href="http://yoursite.com/2019/11/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0VI/"/>
    <id>http://yoursite.com/2019/11/05/数据库学习笔记VI/</id>
    <published>2019-11-05T03:54:12.000Z</published>
    <updated>2019-12-26T11:00:23.385Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL优化及常用函数</p><a id="more"></a><h1 id="SQL-CONCAT-函数"><a href="#SQL-CONCAT-函数" class="headerlink" title="SQL CONCAT 函数"></a>SQL CONCAT 函数</h1><p>CONCAT 函数用于将两个字符串连接为一个字符串，试一下下面这个例子：</p><pre><code>SQL&gt; SELECT CONCAT(&apos;FIRST &apos;, &apos;SECOND&apos;);+----------------------------+| CONCAT(&apos;FIRST &apos;, &apos;SECOND&apos;) |+----------------------------+| FIRST SECOND               |+----------------------------+1 row in set (0.00 sec)</code></pre><h1 id="case-when-then-else-end用法"><a href="#case-when-then-else-end用法" class="headerlink" title="case when then else end用法"></a>case when then else end用法</h1><pre><code>-简单case函数case sex  when &apos;1&apos; then &apos;男&apos;  when &apos;2&apos; then &apos;女’  else &apos;其他&apos; end--case搜索函数case when sex = &apos;1&apos; then &apos;男&apos;     when sex = &apos;2&apos; then &apos;女&apos;     else &apos;其他&apos; end  </code></pre><p>需要注重的问题，case函数只返回第一个符合条件的值，剩下的case部分将会被自动忽略。</p><h1 id="GROUP-BY-语句"><a href="#GROUP-BY-语句" class="headerlink" title="GROUP BY 语句"></a>GROUP BY 语句</h1><p>GROUP BY 语句用于结合合计函数，根据一个或多个列对结果集进行分组。</p><p>实例<br>我们拥有下面这个 “Orders” 表：</p><pre><code>O_Id    OrderDate    OrderPrice    Customer1    2008/12/29    1000    Bush2    2008/11/23    1600    Carter3    2008/10/05    700    Bush4    2008/09/28    300    Bush5    2008/08/06    2000    Adams6    2008/07/21    100    Carter</code></pre><p>现在，我们希望查找每个客户的总金额（总订单）。</p><p>我们想要使用 GROUP BY 语句对客户进行组合。</p><p>我们使用下列 SQL 语句：</p><pre><code>SELECT Customer,SUM(OrderPrice) FROM OrdersGROUP BY Customer</code></pre><p>结果集类似这样：</p><pre><code>Customer    SUM(OrderPrice)Bush    2000Carter    1700Adams    2000</code></pre><p>#参考资料<br>【1】 <a href="https://tech.meituan.com/2014/06/30/mysql-index.html" target="_blank" rel="noopener">https://tech.meituan.com/2014/06/30/mysql-index.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL优化及常用函数&lt;/p&gt;
    
    </summary>
    
      <category term="2019年11月" scheme="http://yoursite.com/categories/2019%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>设计模式学习笔记II</title>
    <link href="http://yoursite.com/2019/11/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0II/"/>
    <id>http://yoursite.com/2019/11/05/设计模式学习笔记II/</id>
    <published>2019-11-05T03:12:12.000Z</published>
    <updated>2019-12-30T08:47:51.583Z</updated>
    
    <content type="html"><![CDATA[<p>工厂模式</p><a id="more"></a><p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p><p>介绍<br>意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p><p>主要解决：主要解决接口选择的问题。</p><p>何时使用：我们明确地计划不同条件下创建不同实例时。</p><p>如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。</p><p>关键代码：创建过程在其子类执行。</p><p>应用实例： 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。</p><p>优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。</p><p>缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</p><p>使用场景： 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。</p><p>注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</p><p>实现<br>我们将创建一个 Shape 接口和实现 Shape 接口的实体类。下一步是定义工厂类 ShapeFactory。</p><p>FactoryPatternDemo，我们的演示类使用 ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。</p><p>步骤 1<br>创建一个接口:</p><p>Shape.java</p><pre><code>public interface Shape {   void draw();}</code></pre><p>步骤 2<br>创建实现接口的实体类。</p><p>Rectangle.java</p><pre><code>public class Rectangle implements Shape {   @Override   public void draw() {      System.out.println(&quot;Inside Rectangle::draw() method.&quot;);   }}Square.javapublic class Square implements Shape {   @Override   public void draw() {      System.out.println(&quot;Inside Square::draw() method.&quot;);   }}Circle.javapublic class Circle implements Shape {   @Override   public void draw() {      System.out.println(&quot;Inside Circle::draw() method.&quot;);   }}</code></pre><p>步骤 3<br>创建一个工厂，生成基于给定信息的实体类的对象。</p><p>ShapeFactory.java</p><pre><code>public class ShapeFactory {   //使用 getShape 方法获取形状类型的对象   public Shape getShape(String shapeType){      if(shapeType == null){         return null;      }              if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;)){         return new Circle();      } else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;)){         return new Rectangle();      } else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;)){         return new Square();      }      return null;   }}</code></pre><p>步骤 4<br>使用该工厂，通过传递类型信息来获取实体类的对象。</p><p>FactoryPatternDemo.java</p><pre><code>public class FactoryPatternDemo {   public static void main(String[] args) {      ShapeFactory shapeFactory = new ShapeFactory();      //获取 Circle 的对象，并调用它的 draw 方法      Shape shape1 = shapeFactory.getShape(&quot;CIRCLE&quot;);      //调用 Circle 的 draw 方法      shape1.draw();      //获取 Rectangle 的对象，并调用它的 draw 方法      Shape shape2 = shapeFactory.getShape(&quot;RECTANGLE&quot;);      //调用 Rectangle 的 draw 方法      shape2.draw();      //获取 Square 的对象，并调用它的 draw 方法      Shape shape3 = shapeFactory.getShape(&quot;SQUARE&quot;);      //调用 Square 的 draw 方法      shape3.draw();   }}</code></pre><p>步骤 5<br>执行程序，输出结果：</p><pre><code>Inside Circle::draw() method.Inside Rectangle::draw() method.Inside Square::draw() method.</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】 <a href="https://www.runoob.com/design-pattern/factory-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/factory-pattern.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工厂模式&lt;/p&gt;
    
    </summary>
    
      <category term="2019年11月" scheme="http://yoursite.com/categories/2019%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Design Pattern，Java" scheme="http://yoursite.com/tags/Design-Pattern%EF%BC%8CJava/"/>
    
  </entry>
  
  <entry>
    <title>设计模式学习笔记I</title>
    <link href="http://yoursite.com/2019/10/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0I/"/>
    <id>http://yoursite.com/2019/10/17/设计模式学习笔记I/</id>
    <published>2019-10-17T02:56:12.000Z</published>
    <updated>2019-10-17T03:06:59.684Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式学习笔记</p><a id="more"></a><h1 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h1><p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</p><p>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</p><p>我们通过下面的实例来演示装饰器模式的用法。其中，我们将把一个形状装饰上不同的颜色，同时又不改变形状类。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>意图：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p><p>主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。</p><p>何时使用：在不想增加很多子类的情况下扩展类。</p><p>如何解决：将具体功能职责划分，同时继承装饰者模式。</p><p>关键代码： 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。</p><p>应用实例： 1、孙悟空有 72 变，当他变成”庙宇”后，他的根本还是一只猴子，但是他又有了庙宇的功能。 2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。</p><p>优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p><p>缺点：多层装饰比较复杂。</p><p>使用场景： 1、扩展一个类的功能。 2、动态增加功能，动态撤销。</p><p>注意事项：可代替继承。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>我们将创建一个 Shape 接口和实现了 Shape 接口的实体类。然后我们创建一个实现了 Shape 接口的抽象装饰类 ShapeDecorator，并把 Shape 对象作为它的实例变量。</p><p>RedShapeDecorator 是实现了 ShapeDecorator 的实体类。</p><p>DecoratorPatternDemo，我们的演示类使用 RedShapeDecorator 来装饰 Shape 对象。<br><a href="https://www.runoob.com/wp-content/uploads/2014/08/decorator_pattern_uml_diagram.jpg" target="_blank" rel="noopener">https://www.runoob.com/wp-content/uploads/2014/08/decorator_pattern_uml_diagram.jpg</a></p><h2 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h2><p>创建一个接口：</p><p>Shape.java</p><pre><code>public interface Shape {   void draw();}</code></pre><h2 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h2><p>创建实现接口的实体类。</p><p>Rectangle.java</p><pre><code>public class Rectangle implements Shape {   @Override   public void draw() {      System.out.println(&quot;Shape: Rectangle&quot;);   }}</code></pre><p>Circle.java</p><pre><code>public class Circle implements Shape {   @Override   public void draw() {      System.out.println(&quot;Shape: Circle&quot;);   }}</code></pre><h2 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a>步骤 3</h2><p>创建实现了 Shape 接口的抽象装饰类。</p><p>ShapeDecorator.java</p><pre><code>public abstract class ShapeDecorator implements Shape {   protected Shape decoratedShape;   public ShapeDecorator(Shape decoratedShape){      this.decoratedShape = decoratedShape;   }   public void draw(){      decoratedShape.draw();   }  }</code></pre><h2 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤 4"></a>步骤 4</h2><p>创建扩展了 ShapeDecorator 类的实体装饰类。</p><p>RedShapeDecorator.java</p><pre><code>public class RedShapeDecorator extends ShapeDecorator {   public RedShapeDecorator(Shape decoratedShape) {      super(decoratedShape);        }   @Override   public void draw() {      decoratedShape.draw();               setRedBorder(decoratedShape);   }   private void setRedBorder(Shape decoratedShape){      System.out.println(&quot;Border Color: Red&quot;);   }}</code></pre><h2 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤 5"></a>步骤 5</h2><p>使用 RedShapeDecorator 来装饰 Shape 对象。</p><p>DecoratorPatternDemo.java</p><pre><code>public class DecoratorPatternDemo {   public static void main(String[] args) {      Shape circle = new Circle();      ShapeDecorator redCircle = new RedShapeDecorator(new Circle());      ShapeDecorator redRectangle = new RedShapeDecorator(new Rectangle());      //Shape redCircle = new RedShapeDecorator(new Circle());      //Shape redRectangle = new RedShapeDecorator(new Rectangle());      System.out.println(&quot;Circle with normal border&quot;);      circle.draw();      System.out.println(&quot;\nCircle of red border&quot;);      redCircle.draw();      System.out.println(&quot;\nRectangle of red border&quot;);      redRectangle.draw();   }}</code></pre><h2 id="步骤-6"><a href="#步骤-6" class="headerlink" title="步骤 6"></a>步骤 6</h2><p>执行程序，输出结果：</p><pre><code>Circle with normal borderShape: CircleCircle of red borderShape: CircleBorder Color: RedRectangle of red borderShape: RectangleBorder Color: Red</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】 <a href="https://www.runoob.com/design-pattern/decorator-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/decorator-pattern.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计模式学习笔记&lt;/p&gt;
    
    </summary>
    
      <category term="2019年10月" scheme="http://yoursite.com/categories/2019%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Design Pattern，Java" scheme="http://yoursite.com/tags/Design-Pattern%EF%BC%8CJava/"/>
    
  </entry>
  
  <entry>
    <title>Scala学习笔记II</title>
    <link href="http://yoursite.com/2019/09/25/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0II/"/>
    <id>http://yoursite.com/2019/09/25/Scala学习笔记II/</id>
    <published>2019-09-25T07:17:12.000Z</published>
    <updated>2019-09-27T09:36:36.534Z</updated>
    
    <content type="html"><![CDATA[<p>Scala学习：=&gt;语法糖,模式匹配</p><a id="more"></a><h1 id="Scala的“-gt-”符号简介"><a href="#Scala的“-gt-”符号简介" class="headerlink" title="Scala的“=&gt;”符号简介"></a>Scala的“=&gt;”符号简介</h1><p>Scala中的=&gt;符号可以看做是创建函数实例的语法糖。例如：A =&gt; T，A,B =&gt; T表示一个函数的输入参数类型是“A”，“A,B”，返回值类型是T。请看下面这个实例：</p><pre><code>scala&gt; val f: Int =&gt; String = myInt =&gt; &quot;The value of myInt is: &quot; + myInt.toString()f: Int =&gt; String = &lt;function1&gt;scala&gt; println(f(3))The value of myInt is: 3</code></pre><p>另外，() =&gt; T表示函数输入参数为空，而A =&gt; Unit则表示函数没有返回值。</p><pre><code>object HelloScala {  def main(args: Array[String])  {    /**      * 首先定义函数d,参数类型是Int=&gt;Int的函数,返回值根据上下文推算是Int。      * 返回值: 发现没有,返回值是x(2),它调用了传入函数。结果自然就是6了。      */    def d(x: (Int) =&gt; Int) = x(2);    println(d((x: Int) =&gt; x * 3));    // 继续增加难度,设置2个值。仔细看变化,你会明白的    def c(x: (Int, Int) =&gt; Int) = x(2, 3);    println(c((x: Int, y: Int) =&gt; x * y * 3));    // 加深难度,b第一次调用返回函数(y: Int) =&gt; x + y,在一次调用返回结果。    // 相关文章参考快学scala 第十二章 高阶函数 145页    val b = (x: Int) =&gt; (y: Int) =&gt; x + y;    println(b.apply(5).apply(6));  }}</code></pre><h1 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h1><pre><code>object scala {    def main(args: Array[String]):Unit={        println(matchTest(3))    }    def matchTest(x:Int):String =x match{      case 1=&gt;&quot;one&quot;      case 2=&gt;&quot;two&quot;      case _=&gt;&quot;many&quot;    }}</code></pre><p>match 对应 Java 里的 switch，但是写在选择器表达式之后。即： 选择器 match {备选项}。</p><p>match 表达式通过以代码编写的先后次序尝试每个模式来完成计算，只要发现有一个匹配的case，剩下的case不会继续匹配。</p><p>接下来我们来看一个不同数据类型的模式匹配：</p><pre><code>object scala {    def main(args: Array[String]):Unit={      println(matchTest(&quot;two&quot;))      println(matchTest(&quot;test&quot;))      println(matchTest(1))      println(matchTest(6))    }    def matchTest(x:Any) : Any=x match {      case 1=&gt;&quot;one&quot;      case &quot;two&quot;=&gt;2      case y:Int=&gt;&quot;scala.Int&quot;      case _=&gt;&quot;many&quot;    }}</code></pre><p>输出结果为：</p><pre><code>2manyonescala.Int</code></pre><p>实例中第一个 case 对应整型数值 1，第二个 case 对应字符串值 two，第三个 case 对应类型模式，用于判断传入的值是否为整型，相比使用isInstanceOf来判断类型，使用模式匹配更好。第四个 case 表示默认的全匹配备选项，即没有找到其他匹配时的匹配项，类似 switch 中的 default。</p><h2 id="使用样例类"><a href="#使用样例类" class="headerlink" title="使用样例类"></a>使用样例类</h2><p>使用了case关键字的类定义就是就是样例类(case classes)，样例类是种特殊的类，经过优化以用于模式匹配。</p><p>以下是样例类的简单实例:</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】 <a href="https://www.orchome.com/401" target="_blank" rel="noopener">https://www.orchome.com/401</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Scala学习：=&amp;gt;语法糖,模式匹配&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记IX</title>
    <link href="http://yoursite.com/2019/09/20/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0IX/"/>
    <id>http://yoursite.com/2019/09/20/Java学习笔记IX/</id>
    <published>2019-09-20T10:32:12.000Z</published>
    <updated>2019-09-20T10:46:42.351Z</updated>
    
    <content type="html"><![CDATA[<p>Java8 中的新特性：Optional类</p><a id="more"></a><p>看到代码中出现的Optional，所以来研究一下：</p><pre><code>Optional&lt;LoanPostloanInfosEntity&gt; postloanInfo = loanPostloanInfosRepository.getByContractId(contractId);</code></pre><p>  Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</p><p>  Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</p><p>  Optional 类的引入很好的解决空指针异常。</p><h1 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h1><p>  以下是一个 java.util.Optional<t> 类的声明：</t></p><pre><code>public final class Optional&lt;T&gt;extends Object</code></pre><h1 id="Optional实例"><a href="#Optional实例" class="headerlink" title="Optional实例"></a>Optional实例</h1><pre><code>import java.util.Optional;public class Java8Tester {    public static void optionalPrac(){        Integer value1 = null;        Integer value2 = new Integer(10);        // Optional.ofNullable - 允许传递为 null 参数        Optional&lt;Integer&gt; a = Optional.ofNullable(value1);        // Optional.of - 如果传递的参数是 null，抛出异常 NullPointerException        Optional&lt;Integer&gt; b = Optional.of(value2);        System.out.println(sum(a,b));    }    public static Integer sum(Optional&lt;Integer&gt; a, Optional&lt;Integer&gt; b){        // Optional.isPresent - 判断值是否存在        System.out.println(&quot;第一个参数值存在: &quot; + a.isPresent());        System.out.println(&quot;第二个参数值存在: &quot; + b.isPresent());        // Optional.orElse - 如果值存在，返回它，否则返回默认值        Integer value1 = a.orElse(new Integer(0));        //Optional.get - 获取值，值需要存在        Integer value2 = b.get();        return value1 + value2;    }    public static void main(String args[]){        optionalPrac();}</code></pre><p>}</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<br><a href="https://www.runoob.com/java/java8-optional-class.html" target="_blank" rel="noopener">https://www.runoob.com/java/java8-optional-class.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java8 中的新特性：Optional类&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Shell学习笔记I</title>
    <link href="http://yoursite.com/2019/09/16/Shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0I/"/>
    <id>http://yoursite.com/2019/09/16/Shell学习笔记I/</id>
    <published>2019-09-16T10:51:12.000Z</published>
    <updated>2019-09-17T06:20:30.433Z</updated>
    
    <content type="html"><![CDATA[<p>Shell脚本编程，懒虫的最爱。</p><a id="more"></a><p>世界的进步是由一群聪明的懒人推动的，可惜自己不但不聪明，还很懒。每次写完博客总打着熟悉git操作的旗号手动部署，终于洗心革面决定写个脚本来自动部署。</p><pre><code>#!/bin/bashcd /Users/liyiye/yiye-project/liyiye012.github.iogit add .git commit -m &quot;github.io 自动部署&quot;git pushhexo cleanhexo ghexo d</code></pre><p>这里写下Shell脚本学习的过程。</p><h1 id="What-is-Shell-and-Shell-Script"><a href="#What-is-Shell-and-Shell-Script" class="headerlink" title="What is Shell and Shell Script"></a>What is Shell and Shell Script</h1><p>shell是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。Ken Thompson的sh是第一种Unix Shell，Windows Explorer是一个典型的图形界面Shell。</p><p>Shell脚本(Shell script)是一种电脑程序与文本文件，内容由一连串的shell命令组成，经由Unix Shell直译其内容后运作。</p><p>被当成是一种脚本语言来设计，其运作方式与直译语言相当，由Unix shell扮演命令行解释器的角色，在读取shell script之后，依序运行其中的shell命令，之后输出结果。利用Shell script可以进行系统管理，文件操作等。</p><p>业界所说的shell通常都是指shell脚本，但读者朋友要知道，shell和shell script是两个不同的概念。由于习惯的原因，简洁起见，本文出现的“shell编程”都是指shell脚本编程，不是指开发shell自身（如Windows Explorer扩展开发）</p><p>打开文本编辑器，新建一个文本文件，并命名为 test.sh。</p><p>扩展名sh代表 shell，扩展名并不影响脚本执行，见名知意就好，如果用 php 写 shell 脚本，扩展名也可以用php。</p><h2 id="第一个shell脚本-Hello-World"><a href="#第一个shell脚本-Hello-World" class="headerlink" title="第一个shell脚本 Hello World"></a>第一个shell脚本 Hello World</h2><p>在 test.sh 中输入代码：</p><pre><code>#!/bin/bashecho &quot;Hello World !&quot;  #这是一条语句</code></pre><p>第 1 行的#!是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell；后面的/bin/bash就是指明了解释器的具体位置。</p><p>第 2 行的 echo 命令用于向标准输出文件（Standard Output，stdout，一般就是指显示器）输出文本。在.sh文件中使用命令与在终端直接输入命令的效果是一样的。</p><p>第 2 行的#及其后面的内容是注释。Shell 脚本中所有以#开头的都是注释（当然以#!开头的除外）</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>运行Shell脚本有两种方法：</p><h3 id="作为可执行程序"><a href="#作为可执行程序" class="headerlink" title="作为可执行程序"></a>作为可执行程序</h3><pre><code>chmod +x test.sh./test.sh</code></pre><p>注意，一定要写成./test.sh，而不是test.sh，运行其它二进制的程序也一样，直接写test.sh，linux系统会去PATH里寻找有没有叫test.sh的，而只有/bin, /sbin, /usr/bin，/usr/sbin等在PATH里，你的当前目录通常不在PATH里，所以写成test.sh是会找不到命令的，要用./test.sh告诉系统说，就在当前目录找。</p><p>通过这种方式运行bash脚本，第一行一定要写对，好让系统查找到正确的解释器。</p><p>这里的”系统”，其实就是shell这个应用程序（想象一下Windows Explorer），但我故意写成系统，是方便理解，既然这个系统就是指shell，那么一个使用/bin/sh作为解释器的脚本是不是可以省去第一行呢？是的。</p><h3 id="作为解释器参数"><a href="#作为解释器参数" class="headerlink" title="作为解释器参数"></a>作为解释器参数</h3><p>这种运行方式是，直接运行解释器，其参数就是shell脚本的文件名，如：</p><pre><code>/bin/sh test.sh/bin/php test.php</code></pre><p>这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。</p><h2 id="stdin"><a href="#stdin" class="headerlink" title="stdin"></a>stdin</h2><pre><code>#!/bin/bashecho &quot;What is your name?&quot;read PERSONecho &quot;Hello, $PERSON&quot;</code></pre><p>第 3 行中表示从终端读取用户输入的数据，并赋值给 PERSON 变量。read 命令用来从标准输入文件（Standard Input，stdin，一般就是指键盘）读取用户输入的数据。</p><p>第 4 行表示输出变量 PERSON 的内容。注意在变量名前边要加上$，否则变量名会作为字符串的一部分处理。</p><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><pre><code>#!/bin/shcd ~mkdir shell_tutcd shell_tutfor ((i=0; i&lt;10; i++)); do    touch test_$i.txtdone</code></pre><p>示例解释</p><pre><code>第1行：指定脚本解释器，这里是用/bin/sh做解释器的第2行：切换到当前用户的home目录第3行：创建一个目录shell_tut第4行：切换到shell_tut目录第5行：循环条件，一共循环10次第6行：创建一个test_0…9.txt文件第7行：循环体结束</code></pre><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><p>定义变量时，变量名不加美元符号（$），如：</p><pre><code>your_name=&quot;qinjx&quot;</code></pre><p>注意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。</p><p>除了显式地直接赋值，还可以用语句给变量赋值，如：</p><pre><code>for file in `ls /etc`</code></pre><h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><p>使用一个定义过的变量，只要在变量名前面加美元符号即可，如：</p><pre><code>your_name=&quot;qinjx&quot;echo $your_nameecho ${your_name}</code></pre><p>变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：</p><pre><code>for skill in Ada Coffe Action Java; do    echo &quot;I am good at ${skill}Script&quot;done</code></pre><p>如果不给skill变量加花括号，写成echo “I am good at $skillScript”，解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。</p><p>推荐给所有变量加上花括号，这是个好的编程习惯。IntelliJ IDEA编写shell script时，IDE就会提示加花括号。</p><h2 id="重定义变量"><a href="#重定义变量" class="headerlink" title="重定义变量"></a>重定义变量</h2><p>已定义的变量，可以被重新定义，如：</p><pre><code>your_name=&quot;qinjx&quot;echo $your_nameyour_name=&quot;alibaba&quot;echo $your_name</code></pre><p>这样写是合法的，但注意，第二次赋值的时候不能写$your_name=”alibaba”，使用变量的时候才加美元符。</p><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>以“#”开头的行就是注释，会被解释器忽略。</p><p>##多行注释<br>sh里没有多行注释，只能每一行加一个#号。</p><p>如果在开发过程中，遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？每一行加个#符号太费力了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。</p><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>字符串是shell编程中最常用最有用的数据类型，字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟PHP类似。</p><h2 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h2><pre><code>str=&apos;this is a string&apos;</code></pre><h3 id="单引号字符串的限制："><a href="#单引号字符串的限制：" class="headerlink" title="单引号字符串的限制："></a>单引号字符串的限制：</h3><p>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的</p><p>单引号字串中不能出现单引号（对单引号使用转义符后也不行）</p><h2 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h2><pre><code>your_name=&apos;qinjx&apos;str=&quot;Hello, I know your are \&quot;$your_name\&quot;! \n&quot;</code></pre><p>双引号里可以有变量</p><p>双引号里可以出现转义字符</p><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h3><pre><code>your_name=&quot;qinjx&quot;greeting=&quot;hello, &quot;$your_name&quot; !&quot;greeting_1=&quot;hello, ${your_name} !&quot;echo $greeting $greeting_1</code></pre><h3 id="获取字符串长度："><a href="#获取字符串长度：" class="headerlink" title="获取字符串长度："></a>获取字符串长度：</h3><pre><code>string=&quot;abcd&quot;echo ${#string} #输出：4</code></pre><h3 id="提取子字符串"><a href="#提取子字符串" class="headerlink" title="提取子字符串"></a>提取子字符串</h3><pre><code>string=&quot;alibaba is a great company&quot;echo ${string:1:4} #输出：liba</code></pre><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><h1 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h1><h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><p>和Java、PHP等语言不一样，sh的流程控制不可为空，如：</p><pre><code>&lt;?phpif (isset($_GET[&quot;q&quot;])) {    search(q);}else {    //do nothing}</code></pre><p>在sh/bash里可不能这么写，如果else分支没有语句执行，就不要写这个else。</p><p>还要注意，sh里的if [ $foo -eq 0 ]，这个方括号跟Java/PHP里if后面的圆括号大不相同，它是一个可执行程序（和ls, grep一样），想不到吧？在CentOS上，它在/usr/bin目录下：</p><pre><code>ll /usr/bin/[-rwxr-xr-x. 1 root root 33408 6月  22 2012 /usr/bin/[</code></pre><p>正因为方括号在这里是一个可执行程序，方括号后面必须加空格，不能写成if [$foo -eq 0]</p><h2 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><pre><code>if conditionthen    command1    command2    ...    commandNfi</code></pre><p>写成一行（适用于终端命令提示符）：</p><pre><code>if `ps -ef | grep ssh`;  then echo hello; fi</code></pre><p>末尾的fi就是if倒过来拼写，后面还会遇到类似的</p><h3 id="if-else-1"><a href="#if-else-1" class="headerlink" title="if else"></a>if else</h3><pre><code>if conditionthen    command1    command2    ...    commandNelse    commandfi</code></pre><h3 id="if-else-if-else"><a href="#if-else-if-else" class="headerlink" title="if else-if else"></a>if else-if else</h3><pre><code>if condition1then    command1elif condition2    command2else    commandNfi</code></pre><h2 id="for-while"><a href="#for-while" class="headerlink" title="for while"></a>for while</h2><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>在开篇的示例里演示过了：</p><pre><code>for var in item1 item2 ... itemNdo    command1    command2    ...    commandNdone</code></pre><p>写成一行：</p><pre><code>for var in item1 item2 ... itemN; do command1; command2… done;</code></pre><h3 id="C风格的for"><a href="#C风格的for" class="headerlink" title="C风格的for"></a>C风格的for</h3><pre><code>for (( EXP1; EXP2; EXP3 ))do    command1    command2    command3done</code></pre><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><pre><code>while conditiondo    commanddone</code></pre><h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h3><pre><code>while :do    commanddone</code></pre><p>或者</p><pre><code>while truedo    commanddone</code></pre><p>或者</p><pre><code>for (( ; ; ))</code></pre><h3 id="until"><a href="#until" class="headerlink" title="until"></a>until</h3><pre><code>until conditiondo    commanddone</code></pre><h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><pre><code>case &quot;${opt}&quot; in    &quot;Install-Puppet-Server&quot; )        install_master $1        exit    ;;    &quot;Install-Puppet-Client&quot; )        install_client $1        exit    ;;    &quot;Config-Puppet-Server&quot; )        config_puppet_master        exit    ;;    &quot;Config-Puppet-Client&quot; )        config_puppet_client        exit    ;;    &quot;Exit&quot; )        exit    ;;    * ) echo &quot;Bad option, please choose again&quot;esac</code></pre><p>case的语法和C family语言差别很大，它需要一个esac（就是case反过来）作为结束标记，每个case分支用右圆括号，用两个分号表示break</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><p>可以使用source和.关键字，如：</p><pre><code>source ./function.sh. ./function.sh</code></pre><p>在bash里，source和.是等效的，他们都是读入function.sh的内容并执行其内容（类似PHP里的include），为了更好的可移植性，推荐使用第二种写法。</p><p>包含一个文件和执行一个文件一样，也要写这个文件的路径，不能光写文件名，比如上述例子中:</p><p>  . ./function.sh<br>不可以写作：</p><p>  . function.sh<br>如果function.sh是用户传入的参数，如何获得它的绝对路径呢？方法是：</p><pre><code>real_path=`readlink -f $1`#$1是用户输入的参数，如function.sh. $real_path</code></pre><h1 id="用户输入"><a href="#用户输入" class="headerlink" title="用户输入"></a>用户输入</h1><h2 id="执行脚本时传入"><a href="#执行脚本时传入" class="headerlink" title="执行脚本时传入"></a>执行脚本时传入</h2><h2 id="脚本运行中输入"><a href="#脚本运行中输入" class="headerlink" title="脚本运行中输入"></a>脚本运行中输入</h2><h2 id="select菜单"><a href="#select菜单" class="headerlink" title="select菜单"></a>select菜单</h2><h2 id="stdin和stdout"><a href="#stdin和stdout" class="headerlink" title="stdin和stdout"></a>stdin和stdout</h2><h1 id="常用的命令"><a href="#常用的命令" class="headerlink" title="常用的命令"></a>常用的命令</h1><p>sh脚本结合系统命令便有了强大的威力，在字符处理领域，有grep、awk、sed三剑客，grep负责找出特定的行，awk能将行拆分成多个字段，sed则可以实现更新插入删除等写操作。</p><h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p>查看进程列表</p><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>排除grep自身<br>查找与target相邻的结果</p><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><h2 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h2><h1 id="脚本解释器"><a href="#脚本解释器" class="headerlink" title="脚本解释器"></a>脚本解释器</h1><h2 id="sh"><a href="#sh" class="headerlink" title="sh"></a>sh</h2><p>即Bourne shell，POSIX（Portable Operating System Interface）标准的shell解释器，它的二进制文件路径通常是/bin/sh，由Bell Labs开发。</p><p>下面讲的是sh，如果使用其它语言用作shell编程，请参考相应语言的文档。</p><h2 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h2><p>Bash是Bourne shell的替代品，属GNU Project，二进制文件路径通常是/bin/bash。业界通常混用bash、sh、和shell，比如你会经常在招聘运维工程师的文案中见到：熟悉Linux Bash编程，精通Shell编程。</p><p>在CentOS里，/bin/sh是一个指向/bin/bash的符号链接:</p><pre><code>[root@centosraw ~]# ls -l /bin/*sh-rwxr-xr-x. 1 root root 903272 Feb 22 05:09 /bin/bash-rwxr-xr-x. 1 root root 106216 Oct 17  2012 /bin/dashlrwxrwxrwx. 1 root root      4 Mar 22 10:22 /bin/sh -&gt; bash</code></pre><p>但在Mac OS上不是，/bin/sh和/bin/bash是两个不同的文件，尽管它们的大小只相差100字节左右:</p><pre><code>iMac:~ wuxiao$ ls -l /bin/*sh-r-xr-xr-x  1 root  wheel  1371648  6 Nov 16:52 /bin/bash-rwxr-xr-x  2 root  wheel   772992  6 Nov 16:52 /bin/csh-r-xr-xr-x  1 root  wheel  2180736  6 Nov 16:52 /bin/ksh-r-xr-xr-x  1 root  wheel  1371712  6 Nov 16:52 /bin/sh-rwxr-xr-x  2 root  wheel   772992  6 Nov 16:52 /bin/tcsh-rwxr-xr-x  1 root  wheel  1103984  6 Nov 16:52 /bin/zsh</code></pre><h1 id="高级编程语言"><a href="#高级编程语言" class="headerlink" title="高级编程语言"></a>高级编程语言</h1><p>理论上讲，只要一门语言提供了解释器（而不仅是编译器），这门语言就可以胜任脚本编程，常见的解释型语言都是可以用作脚本编程的，如：Perl、Tcl、Python、PHP、Ruby。Perl是最老牌的脚本编程语言了，Python这些年也成了一些linux发行版的预置解释器。</p><p>编译型语言，只要有解释器，也可以用作脚本编程，如C shell是内置的（/bin/csh），Java有第三方解释器Jshell，Ada有收费的解释器AdaScript。</p><h1 id="如何选择shell编程语言"><a href="#如何选择shell编程语言" class="headerlink" title="如何选择shell编程语言"></a>如何选择shell编程语言</h1><h2 id="熟悉-vs-陌生"><a href="#熟悉-vs-陌生" class="headerlink" title="熟悉 vs 陌生"></a>熟悉 vs 陌生</h2><p>如果你已经掌握了一门编程语言（如PHP、Python、Java、JavaScript），建议你就直接使用这门语言编写脚本程序，虽然某些地方会有点啰嗦，但你能利用在这门语言领域里的经验（单元测试、单步调试、IDE、第三方类库）。</p><p>新增的学习成本很小，只要学会怎么使用shell解释器（Jshell、AdaScript）就可以了。</p><h2 id="简单-vs-高级"><a href="#简单-vs-高级" class="headerlink" title="简单 vs 高级"></a>简单 vs 高级</h2><p>如果你觉得自己熟悉的语言（如Java、C）写shell脚本实在太啰嗦，你只是想做一些备份文件、安装软件、下载数据之类的事情，学着使用sh，bash会是一个好主意。</p><p>shell只定义了一个非常简单的编程语言，所以，如果你的脚本程序复杂度较高，或者要操作的数据结构比较复杂，那么还是应该使用Python、Perl这样的脚本语言，或者是你本来就已经很擅长的高级语言。因为sh和bash在这方面很弱，比如说：</p><p><strong><em>它的函数只能返回字串，无法返回数组</em></strong></p><p><strong><em>它不支持面向对象，你无法实现一些优雅的设计模式</em></strong></p><p><strong><em>它是解释型的，一边解释一边执行，连PHP那种预编译都不是，如果你的脚本包含错误(例如调用了不存在的函数)，只要没执行到这一行，就不会报错</em></strong></p><h2 id="环境兼容性"><a href="#环境兼容性" class="headerlink" title="环境兼容性"></a>环境兼容性</h2><p>如果你的脚本是提供给别的用户使用，使用sh或者bash，你的脚本将具有最好的环境兼容性，perl很早就是linux标配了，python这些年也成了一些linux发行版的标配，至于mac os，它默认安装了perl、python、ruby、php、java等主流编程语言。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】 <a href="https://www.runoob.com/w3cnote/shell-quick-start.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/shell-quick-start.html</a></p><p>【2】 <a href="https://github.com/qinjx/30min_guides/blob/master/shell.md" target="_blank" rel="noopener">https://github.com/qinjx/30min_guides/blob/master/shell.md</a></p><p>【3】 <a href="http://c.biancheng.net/view/735.html" target="_blank" rel="noopener">http://c.biancheng.net/view/735.html</a></p><p>【4】 <a href="http://tldp.org/LDP/abs/html/" target="_blank" rel="noopener">http://tldp.org/LDP/abs/html/</a> ，非常详细，非常易读，大量example，既可以当入门教材，也可以当做工具书查阅</p><p>【5】 <a href="http://www.tutorialspoint.com/unix/unix-shell.htm" target="_blank" rel="noopener">http://www.tutorialspoint.com/unix/unix-shell.htm</a></p><p>【6】 <a href="https://bash.cyberciti.biz/guide/Main_Page" target="_blank" rel="noopener">https://bash.cyberciti.biz/guide/Main_Page</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Shell脚本编程，懒虫的最爱。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Shell" scheme="http://yoursite.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Scala学习笔记I</title>
    <link href="http://yoursite.com/2019/09/10/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0I/"/>
    <id>http://yoursite.com/2019/09/10/Scala学习笔记I/</id>
    <published>2019-09-10T03:32:12.000Z</published>
    <updated>2019-09-25T07:17:36.347Z</updated>
    
    <content type="html"><![CDATA[<p>Scala学习：集合，柯里化，implicit关键字</p><a id="more"></a><h1 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h1><h1 id="fold-foldLeft和foldRight区别与联系"><a href="#fold-foldLeft和foldRight区别与联系" class="headerlink" title="fold,foldLeft和foldRight区别与联系"></a>fold,foldLeft和foldRight区别与联系</h1><p>从本质上说，fold函数将一种格式的输入数据转化成另外一种格式返回。</p><pre><code>def fold(){  val a=List(1,2,3,4)  val res=a.fold(0){    (z,i) =&gt; z+i  }  println(res)  //res=10}</code></pre><p>List中的fold方法需要输入两个参数：初始值以及一个函数。输入的函数也需要输入两个参数：累加值和当前item的索引。那么上面的代码片段发生了什么事？</p><p>代码开始运行的时候，初始值0作为第一个参数传进到fold函数中，list中的第一个item作为第二个参数传进fold函数中。</p><p>1、fold函数开始对传进的两个参数进行计算，在本例中，仅仅是做加法计算，然后返回计算的值；</p><p>2、Fold函数然后将上一步返回的值作为输入函数的第一个参数，并且把list中的下一个item作为第二个参数传进继续计算，同样返回计算的值；</p><p>3、第2步将重复计算，直到list中的所有元素都被遍历之后，返回最后的计算值，整个过程结束；</p><p>4、这虽然是一个简单的例子，让我们来看看一些比较有用的东西。早在后面将会介绍foldLeft函数，并解释它和fold之间的区别，目前，你只需要想象foldLeft函数和fold函数运行过程一样。</p><h1 id="Scala-函数柯里化-Currying"><a href="#Scala-函数柯里化-Currying" class="headerlink" title="Scala 函数柯里化(Currying)"></a>Scala 函数柯里化(Currying)</h1><p>柯里化(Currying)指的是将原来接受两个参数的函数变成新的接受一个参数的函数的过程。新的函数返回一个以原有第二个参数为参数的函数。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>首先我们定义一个函数:</p><pre><code>def add(x:Int,y:Int)=x+y</code></pre><p>那么我们应用的时候，应该是这样用：add(1,2)</p><p>现在我们把这个函数变一下形：</p><pre><code>def add(x:Int)(y:Int) = x + y</code></pre><p>那么我们应用的时候，应该是这样用：add(1)(2),最后结果都一样是3，这种方式（过程）就叫柯里化。</p><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>add(1)(2) 实际上是依次调用两个普通函数（非柯里化函数），第一次调用使用一个参数 x，返回一个函数类型的值，第二次使用参数y调用这个函数类型的值。</p><p>实质上最先演变成这样一个方法：</p><pre><code>def add(x:Int)=(y:Int)=&gt;x+y</code></pre><p>那么这个函数是什么意思呢？ 接收一个x为参数，返回一个匿名函数，该匿名函数的定义是：接收一个Int型参数y，函数体为x+y。现在我们来对这个方法进行调用。</p><pre><code>val result = add(1)</code></pre><p>返回一个result，那result的值应该是一个匿名函数：(y:Int)=&gt;1+y</p><p>所以为了得到结果，我们继续调用result。</p><pre><code>val sum = result(2)</code></pre><p>最后打印出来的结果就是3。</p><h1 id="Implicit详解"><a href="#Implicit详解" class="headerlink" title="Implicit详解"></a>Implicit详解</h1><p>在 Scala 中的 implicit 定义指编译器在需要修复类型匹配时可以用来自动插入的定义。比如说，如果 x+y 类型不匹配，那么编译器可能试着使用 convert(x) + y， 其中 convert 由某个 implicit 定义的，这有点类似一个整数和一个浮点数相加，编译器可以自动把整数转换为浮点数。Scala 的 implicit 定义是对这种情况的一个推广，你可以定义一个类型在需要时，如何自动转换成另外一种类型。</p><p>Scala 的 implicit 定义符合下面一些规则：</p><h2 id="标记规则"><a href="#标记规则" class="headerlink" title="标记规则"></a>标记规则</h2><p>只有哪些使用 implicit 关键字的定义才是可以使用的隐式定义。关键字 implicit 用来标记一个隐式定义。编译器才可以选择它作为隐式变化的候选项。你可以使用 implicit 来标记任意变量，函数或是对象。</p><p>例如下面为一个隐式函数定义：</p><pre><code>implicit def intToString(x:Int) : x.toString</code></pre><p>编译器只有在 convert 被标记成 implicit 才会将 x + y 改成convert(x) + y 。当然这是在 x + y 类型不匹配时。</p><h2 id="范围规则"><a href="#范围规则" class="headerlink" title="范围规则"></a>范围规则</h2><p>编译器在选择备选 implicit 定义时，只会选取当前作用域的定义，比如说编译器不会去调用 someVariable.convert。如果你需要使用 someVariable.convert，你必须把 someVarible 引入到当前作用域。也就是说编译器在选择备选 implicit 时，只有当 convert 是当前作用域下单个标志符时才会作为备选 implicit。比如说，对于一个函数库来说，在一个 Preamble 对象中定义一些常用的隐式类型转换非常常见，因此需要使用 Preamble 的代码可以使用 “import Preamble._”  把这些 implicit 定义引入到当前作用域才可以。</p><p>这个规则有一个例外，编译器也会在类的伙伴对象定义中查找所需的 implicit 定义。例如下面的定义：</p><pre><code>object Dollar {    implicit def dollarToEuro(x:Dollar):Euro = ...    ...}class Dollar {   ...}</code></pre><p>如果在 class Dollar 的方法有需要 Euro 类型，但输入数据使用的是 Dollar，编译器会在其伙伴对象 object Dollar 查找所需的隐式类型转换，本例定义一个从 Dollar 到 Euro 的 implicit 定义可以使用。</p><h2 id="一次规则"><a href="#一次规则" class="headerlink" title="一次规则"></a>一次规则</h2><p>编译器在需要使用 implicit 定义时，只会试图转换一次，也就是编译器永远不会把 x + y 改写成 convert1(convert2(x)) + y。</p><h2 id="优先规则"><a href="#优先规则" class="headerlink" title="优先规则"></a>优先规则</h2><p>编译器不会在 x+y 已经是合法的情况下去调用 implicit 规则。</p><h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><p>你可以为 implicit 定义任意的名称。通常情况下你可以任意命名，implicit 的名称只在两种情况下有用：一是你想在一个方法中明确指明，另外一个是想把那一个引入到当前作用域。比如我们定义一个对象，包含两个 implicit定义：</p><pre><code>object MyConversions {    implicit def stringWrapper(s:String):IndexedSeq[Char] = ...    implicit def intToString(x:Int):String = ...}</code></pre><p>在你的应用中，你想使用 stringWrapper 变换，而不想把整数自动转换成字符串，你可以只引入 stringWrapper。</p><pre><code>import  MyConversions.stringWrapper</code></pre><h2 id="编译器使用-implicit-的几种情况"><a href="#编译器使用-implicit-的几种情况" class="headerlink" title="编译器使用 implicit 的几种情况"></a>编译器使用 implicit 的几种情况</h2><p>有三种情况使用 implicit: 一是转换成预期的数据类型，二是转换 selection 的 receiver，三是隐含参数。转换成预期的数据类型比如你有一个方法参数类型是 IndexedSeq[Char]，在你传入 String 时，编译器发现类型不匹配，就检查当前作用域是否有从 String 到 IndexedSeq 隐式转换。</p><p>转换 selection 的 receiver 允许你适应某些方法调用，比如 “abc”.exist ，”abc”类型为 String，本身没有定义 exist 方法，这时编辑器就检查当前作用域内 String 的隐式转换后的类型是否有 exist 方法，发现 stringWrapper 转换后成 IndexedSeq 类型后，可以有 exist 方法，这个和 C# 静态扩展方法功能类似。</p><p>隐含参数有点类似是缺省参数，如果在调用方法时没有提供某个参数，编译器会查找当前作用域是否有符合条件的 implicit 对象作为参数传入（有点类似 dependency injection)。</p><h2 id="implicit-function-隐式函数"><a href="#implicit-function-隐式函数" class="headerlink" title="implicit function 隐式函数"></a>implicit function 隐式函数</h2><h3 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h3><p>第一种implicit的用法，是将其加在function定义的前面，形式为:</p><pre><code>implicit def int2String(someInt: Int): String = {  //...}</code></pre><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>这种用法可以用来进行implicit conversion，隐式转换，也就是说，编译器可以选择在合适的时候调用这些函数来进行一个转换，来保证类型的正确性，比如我可以通过定义一个implicit的转换函数将java的类型转换为scala的类型，这样在需要scala类型但是却使用java类型作为参数的时候，编译器会自动加入这个转换函数.</p><pre><code>object HelloScala {  implicit def conv(a: Int) = {    println(&quot;in conv&quot;)    a.toString  }  def say(b: String) = println(b)  def main(args: Array[String])  {    say(5)  }}//输出结果:// in conv// 5//这说明过程是say(conv(5))//原因是编译器在检查的时候发现需要一个String类型的参数，但是代入的是一个Int，于是//他会在范围内寻找implicit的function，找到了符合这个要求的String =&gt; Int的function，于是调用</code></pre><h2 id="implicit-parameter-amp-implicit-value-隐式参数和隐式值"><a href="#implicit-parameter-amp-implicit-value-隐式参数和隐式值" class="headerlink" title="implicit parameter &amp; implicit value 隐式参数和隐式值"></a>implicit parameter &amp; implicit value 隐式参数和隐式值</h2><h3 id="形式-1"><a href="#形式-1" class="headerlink" title="形式"></a>形式</h3><h3 id="隐式参数"><a href="#隐式参数" class="headerlink" title="隐式参数"></a>隐式参数</h3><p>隐式参数是在函数中，将参数标志出implicit，形式为:</p><pre><code>def func(implicit x: Int)def func2(x: Int)(implicit y: Int)def func3(implicit x: Int, y: Int)</code></pre><p>这三种形式是有区别的，在参数中implicit只能出现一次，而在此之后，所有的参数都会变为implicit。</p><pre><code>func: x是implicit的func2: 只有y是implicit的func3: x和y都是implicit的</code></pre><p>注意避免以下几种错误写法:<br>      //以下三种情况无法编译通过<br>      def err(x: Int, implicit y: Int)<br>      def err(implicit x: Int)(implicit y: Int)<br>      def err(implicit x: Int)(y: Int)<br>这三种情况都是无法编译通过的</p><h2 id="隐式值"><a href="#隐式值" class="headerlink" title="隐式值"></a>隐式值</h2><pre><code>implicit object Testimplicit val x = 5implicit var y</code></pre><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>这种用法的作用主要是两种用法搭配起来来达到一个效果，隐式参数表明这个参数是可以缺少的，也就是说在调用的时候这个参数可以不用出现，那么这个值由什么填充呢？ 那就是用隐式的值了，以下的例子说明了这一点:<br>    object HelloScala {<br>      abstract class Sayable{<br>        def say<br>      }<br>      implicit object hello extends Sayable{<br>        override def say()={<br>          println(“hello”)<br>        }<br>      }<br>      def func(implicit x:Sayable): Unit ={<br>        x.say<br>      }<br>      implicit val impVal=5<br>      def func1(implicit x:Int)={<br>        println(x)<br>      }<br>      def main(args: Array[String])  {<br>        func<br>        func1<br>      }<br>    }</p><p>输出结果为:</p><pre><code>im in hello5</code></pre><p>因为object的类型并不是object的名字，所以使用了一个抽象class来指明type。</p><p>在调用func的时候，没有代入参数，其参数是由编译器检查之后决定的，而这里决定的就是唯一的可能，hello那个object，所以这里的say调用的就是hello object里的say</p><p>在调用func1的时候，同样没有代入参数，需要一个Int作为参数，编译器寻找值的时候寻找到impVal是implicit的值，所以这里选择impVal作为他的值，输出了5</p><h2 id="implicit-class-隐式类"><a href="#implicit-class-隐式类" class="headerlink" title="implicit class 隐式类"></a>implicit class 隐式类</h2><p>这是一个在scala 2.10中新增的用法</p><h3 id="形式-2"><a href="#形式-2" class="headerlink" title="形式"></a>形式</h3><pre><code>implicit class MyClass(x: Int)</code></pre><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><p>这里的作用主要是其主构造函数可以作为隐式转换的参数，相当于其主构造函数可以用来当做一个implicit的function，下面举例说明一下:</p><pre><code>object HelloScala {  implicit class MyName(x: Int) {    println(&quot;im in cons&quot;)    val y = x  }  def say(x: MyName) = {    println(x.y)  }  def main(args: Array[String])  {    say(5)  }}</code></pre><p>输出结果:</p><pre><code>im in cons5</code></pre><p>这里的MyName是一个隐式类，其主构造函数可以用作隐式转换，所以say需要一个MyName类型的参数，但是调用的时候给的是一个Int，这里就会调用MyName的主构造函数转换为一个MyName的对象，然后再println其y的值</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】 <a href="https://www.iteblog.com/archives/1228.html" target="_blank" rel="noopener">https://www.iteblog.com/archives/1228.html</a><br>【2】 <a href="https://www.runoob.com/scala/currying-functions.html" target="_blank" rel="noopener">https://www.runoob.com/scala/currying-functions.html</a><br>【3】 <a href="https://blog.csdn.net/qq_29343201/article/details/58588470" target="_blank" rel="noopener">https://blog.csdn.net/qq_29343201/article/details/58588470</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Scala学习：集合，柯里化，implicit关键字&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记VIII</title>
    <link href="http://yoursite.com/2019/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0VIII/"/>
    <id>http://yoursite.com/2019/09/06/Java学习笔记VIII/</id>
    <published>2019-09-06T10:43:12.000Z</published>
    <updated>2019-09-16T09:04:07.370Z</updated>
    
    <content type="html"><![CDATA[<p>使用Quzrtz 及Cron定时表达式语法解析</p><a id="more"></a><h1 id="Cron表达式范例："><a href="#Cron表达式范例：" class="headerlink" title="Cron表达式范例："></a>Cron表达式范例：</h1><pre><code>*/10 * * * * ?  每隔10秒执行一次0 */1 * * * ?  每隔1分钟执行一次0 0 23 * * ?  每天23点执行一次0 0 1 * * ?  每天凌晨1点执行一次：0 0 1 1 * ?  每月1号凌晨1点执行一次0 0 23 L * ?  每月最后一天23点执行一次0 0 1 ? * L  每周星期天凌晨1点实行一次0 26,29,33 * * * ?  在26分、29分、33分执行一次0 0 0,13,18,21 * * ? 每天的0点、13点、18点、21点都执行一次</code></pre><h1 id="Cron-表达式"><a href="#Cron-表达式" class="headerlink" title="Cron 表达式"></a>Cron 表达式</h1><p>Cron表达式由7个部分组成，各部分用空格隔开，例如0 0 12 ? * WED（每星期三下午12:00 执行）</p><p>Cron表达式的7个部分从左到右代表的含义如下</p><pre><code>Seconds Minutes Hours Day-of-Month Month Day-of-Week Year</code></pre><p>其中Year是可选的</p><h1 id="Cron表达式可选的值"><a href="#Cron表达式可选的值" class="headerlink" title="Cron表达式可选的值"></a>Cron表达式可选的值</h1><pre><code>Seconds秒：数字0－59Minutes分：数字0－59Hours时 ：数字0-23Day-of-Month月中的几号 ：可以用数字1-31 中的任一一个值，但要注意一些特别的月份Month一年中的几月：可以用0-11 或用字符串 “JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV and DEC” 表示Day-of-Week每周：数字1-7（1 ＝ 星期日），或用字符口串“SUN, MON, TUE, WED, THU, FRI and SAT”字段名                 允许的值                        允许的特殊字符  秒                    0-59                            , - * /  分                    0-59                            , - * /  小时                  0-23                            , - * /  日                    1-31                            , - * ? / L W C  月                    1-12 or JAN-DEC                 , - * /  周几                  1-7 or SUN-SAT                   , - * ? / L C #  年 (可选字段)          empty, 1970-2099                 , - * /</code></pre><h1 id="Cron中的符号"><a href="#Cron中的符号" class="headerlink" title="Cron中的符号"></a>Cron中的符号</h1><pre><code>* ：代表整个时间段./ ：表示每多长时间执行一次0/15表示每隔15分钟执行一次,“0”表示为从“0”分开始；3/20表示每隔20分钟执行一次，“3”表示从第3分钟开始执行? ：表示每月的某一天，或第几周的某一天L ：“6L”表示“每月的最后一个星期五”W：表示为最近工作日如“15W”放在每月（day-of-month）字段上表示为“到本月15日最近的工作日”#：是用来指定“的”每月第n个工作日&quot;6#3&quot;或者&quot;FRI#3&quot;:在每周（day-of-week）中表示“每月第三个星期五”问号(?)就是用来对日期和星期字段做互斥的，问号(?)的作用是指明该字段‘没有特定的值’，星号(*)和其它值，比如数字，都是给该字段指明特定的值，而星号(*)代表所有，在天时表示每一天。“?”字符：表示不确定的值“,”字符：指定数个值“-”字符：指定一个值的范围“/”字符：指定一个值的增加幅度。n/m表示从n开始，每次增加m“L”字符：用在日表示一个月中的最后一天，用在周表示该月最后一个星期X“W”字符：指定离给定日期最近的工作日(周一到周五)“#”字符：表示该月第几个周X。6#3表示该月第3个周五</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<br><a href="https://www.jianshu.com/p/f03b1497122a" target="_blank" rel="noopener">https://www.jianshu.com/p/f03b1497122a</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Quzrtz 及Cron定时表达式语法解析&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
</feed>
