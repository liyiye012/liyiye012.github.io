<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-26T10:29:24.837Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot学习笔记IV</title>
    <link href="http://yoursite.com/2019/07/26/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0IV/"/>
    <id>http://yoursite.com/2019/07/26/SpringBoot学习笔记IV/</id>
    <published>2019-07-26T10:30:12.000Z</published>
    <updated>2019-07-26T10:29:24.837Z</updated>
    
    <content type="html"><![CDATA[<p>阐述Spring，Spring MVC，Spring Boot 三者的原理和区别。学习笔记II中涉及到对@Resource和@Autowired的区别做了解释。</p><a id="more"></a><pre><code>private static SqlSessionFactory sqlSessionFactory;    public static void main(String[] args) {        // Mybatis 配置文件        String resource = &quot;mybatis-config.xml&quot;;        // 得到配置文件流        InputStream inputStream = null;        try {            inputStream = Resources.getResourceAsStream(resource);        } catch (IOException e) {            e.printStackTrace();        }        System.out.println(inputStream);        // 创建会话工厂，传入 MyBatis 的配置文件信息        sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        System.out.println(sqlSessionFactory);//        for (int i = 0;i&lt;10;i++){//            insertUser();//        }//        insertUser();        // updateUser();        // deleteUser();        // selectUserById();        // selectAllUser();//        findAllUser();//        findUserByContactName();        deleteUserById();    }    // 新增用戶    private static void insertUser() {        // 通过工厂得到 SqlSession        SqlSession session = sqlSessionFactory.openSession();        TblMerchantEntityMapper mapper = session.getMapper(TblMerchantEntityMapper.class);        TblMerchantEntity user = new TblMerchantEntity();            user.setContactName(&quot;Tom&quot;);            user.setMerchantNo(String.valueOf(Math.random()*Long.MAX_VALUE));            user.setMerchantName(&quot;肯德基&quot;);            user.setStatus(&quot;1&quot;);        try {            mapper.insert(user);            session.commit();        } catch (Exception e) {            e.printStackTrace();            session.rollback();        }        // 释放资源        session.close();    }//    private static void updateUser(){//        SqlSession session = sqlSessionFactory.openSession();//        TblMerchantEntityMapper mapper = session.getMapper(TblMerchantEntityMapper.class);////        TblMerchantEntityExample tblMerchantEntityExample = new TblMerchantEntityExample();//        Criteria criteria = tblMerchantEntityExample.createCriteria();//////    }    private static void deleteUserById(){        SqlSession session = sqlSessionFactory.openSession();        TblMerchantEntityMapper mapper = session.getMapper(TblMerchantEntityMapper.class);        int x = mapper.deleteByPrimaryKey((long)30);        System.out.println(&quot;这次删除了&quot;+x+&quot;行数据&quot;);        session.commit();        session.close();    }    private static void findAllUser(){        SqlSession session = sqlSessionFactory.openSession();        TblMerchantEntityMapper mapper = session.getMapper(TblMerchantEntityMapper.class);        TblMerchantEntity entity;        TblMerchantEntityExample tblMerchantEntityExample = new TblMerchantEntityExample();        Criteria criteria = tblMerchantEntityExample.createCriteria();        criteria.getCriteria();        List&lt;TblMerchantEntity&gt; list = mapper.selectByExample(tblMerchantEntityExample);        Iterator it = list.iterator();        while (it.hasNext()){            entity = (TblMerchantEntity)it.next();            System.out.println(entity.toString());        }        session.close();    }    private static void findUserByContactName(){        SqlSession session = sqlSessionFactory.openSession();        TblMerchantEntityMapper mapper = session.getMapper(TblMerchantEntityMapper.class);        TblMerchantEntity entity;        TblMerchantEntityExample tblMerchantEntityExample = new TblMerchantEntityExample();        Criteria criteria = tblMerchantEntityExample.createCriteria();//        criteria.andContactNameEqualTo(&quot;李四&quot;).andIdGreaterThan((long)5);        criteria.andIdBetween((long)2,(long)7);//分页查询        List&lt;TblMerchantEntity&gt; list = mapper.selectByExample(tblMerchantEntityExample);        Iterator it = list.iterator();        while (it.hasNext()){            entity = (TblMerchantEntity)it.next();            System.out.println(entity.toString());        }    }</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;阐述Spring，Spring MVC，Spring Boot 三者的原理和区别。学习笔记II中涉及到对@Resource和@Autowired的区别做了解释。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年7月" scheme="http://yoursite.com/categories/2019%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot学习笔记III</title>
    <link href="http://yoursite.com/2019/07/25/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0III/"/>
    <id>http://yoursite.com/2019/07/25/SpringBoot学习笔记III/</id>
    <published>2019-07-25T01:36:12.000Z</published>
    <updated>2019-07-26T10:47:25.468Z</updated>
    
    <content type="html"><![CDATA[<p>阐述Spring，Spring MVC，Spring Boot 三者的原理和区别。学习笔记II中涉及到对@Resource和@Autowired的区别做了解释。<br>对用命令查询网络端口占用情况，查找/杀死进程做了回顾性的复习。</p><a id="more"></a><h1 id="三省吾身："><a href="#三省吾身：" class="headerlink" title="三省吾身："></a>三省吾身：</h1><h2 id="什么是Spring？它解决了什么问题？"><a href="#什么是Spring？它解决了什么问题？" class="headerlink" title="什么是Spring？它解决了什么问题？"></a>什么是Spring？它解决了什么问题？</h2><p>Spring是一个开源的轻量级Java SE（Java 标准版本）/Java EE（Java 企业版本）开发应用框架，其目的是用于简化企业级应用程序开发。应用程序是由一组相互协作的对象组成。而在传统应用程序开发中，一个完整的应用是由一组相互协作的对象组成。所以开发一个应用除了要开发业务逻辑之外，最多的是关注如何使这些对象协作来完成所需功能，而且要低耦合、高内聚。业务逻辑开发是不可避免的，那如果有个框架出来帮我们来创建对象及管理这些对象之间的依赖关系。可能有人说了，比如“抽象工厂、工厂方法设计模式”不也可以帮我们创建对象，“生成器模式”帮我们处理对象间的依赖关系，不也能完成这些功能吗？可是这些又需要我们创建另一些工厂类、生成器类，我们又要而外管理这些类，增加了我们的负担，如果能有种通过配置方式来创建对象，管理对象之间依赖关系，我们不需要通过工厂和生成器来创建及管理对象之间的依赖关系，这样我们是不是减少了许多工作，加速了开发，能节省出很多时间来干其他事。Spring框架刚出来时主要就是来完成这个功能。</p><p>Spring框架除了帮我们<strong><em>管理对象及其依赖关系</em></strong>，还提供像通用日志记录、性能统计、安全控制、异常处理等面向切面的能力，还能帮我管理最头疼的数据库事务，本身提供了一套简单的JDBC访问实现，提供与第三方数据访问框架集成（如Hibernate、JPA），与各种Java EE技术整合（如Java Mail、任务调度等等），提供一套自己的web层框架Spring MVC、而且还能非常简单的与第三方web框架集成。从这里我们可以认为Spring是一个超级粘合平台，除了自己提供功能外，还提供粘合其他技术和框架的能力，从而使我们可以更自由的选择到底使用什么技术进行开发。而且不管是JAVA SE（C/S架构）应用程序还是JAVA EE（B/S架构）应用程序都可以使用这个平台进行开发。</p><p>Spring，一般指代的是Spring Framework，它是一个开源的应用程序框架，提供了一个简易的开发方式，通过这种开发方式，将避免那些可能致使代码变得繁杂混乱的大量的业务/工具对象，说的更通俗一点就是由框架来帮你管理这些对象，包括它的创建，销毁等，比如基于Spring的项目里经常能看到的Bean，它代表的就是由Spring管辖的对象。<br>而在被管理对象与业务逻辑之间，Spring通过IOC（控制反转）架起使用的桥梁，IOC也可以看做Spring最核心最重要的思想，通过IOC能带来什么好处呢？首先来看一个实际开发中的典型应用场景，假设我们有一个基于MVC分层结构的应用，通过controller层对外提供接口，而通过service层提供具体的实现，在service层中有一个WelcomeService服务接口，一般情况下都是通过WelcomeService service = new WelcomeServiceImpl();创建实例并进行调用：</p><pre><code>public class WelcomeController {    private WelcomeService service = new WelcomeServiceImpl();    @RequestMapping(&quot;/welcome&quot;)    public String welcome() {    return service.retrieveWelcomeMessage();    }}</code></pre><p>调用后发现一切正常，此时，功能提交，需要进行测试，而由于实际应用环境与测试环境有所区别，需要替换WelcomeServiceImpl为一个MockWelcomeServiceImpl，以方便测试，怎么办？没有其他办法，只有改代码：</p><pre><code>public class WelcomeController {    private WelcomeService service = new MockWelcomeServiceImpl();    ...}测试OK后再将代码改回去，这种方式太过于繁琐，且对代码的侵入性很强；下面看通过Spring的IOC如何实现，首先将WelcomeService交由Spring管理：&lt;bean name=&quot;WelcomeService&quot; class=&quot;XXX.XXX.XXX.service.impl.WelcomeServiceImpl&quot;/&gt;</code></pre><p>然后在业务代码处通过Spring IOC拿到具体对象：</p><pre><code>public class WelcomeController {    @Autowired    private WelcomeService service;    @RequestMapping(&quot;/welcome&quot;)    public String welcome() {        return service.retrieveWelcomeMessage();    }}</code></pre><p>测试的时候，只需要更改配置文件，将WelcomeService对应的实现改为MockWelcomeServiceImpl即可：</p><pre><code>&lt;bean name=&quot;WelcomeService&quot; class=&quot;XXX.XXX.XXX.service.impl.MockWelcomeServiceImpl&quot;/&gt;</code></pre><p>这种方式对业务代码没有任何侵入，它有效的实现松耦合，大家都知道紧耦合的代码是业务发展的噩梦；同时，Spring IOC提供的远不止这些，如通过单例减少创建无用的对象，通过延迟加载优化初始化成本等<br>当然，Spring 的核心功能远不知这些，如：</p><pre><code>Spring AOPSpring JDBCSpring MVCSpring ORMSpring JMSSpring Test</code></pre><p>其实不通过Spring框架依然可以实现这些功能特定，但是Spring 提供了更优雅的抽象接口以方便对这些功能的组装，同时又给予每个具体实现以灵活的配置；另外，基于Spring，你可以方便的与其他框架进行集成，如hibernate，ibatis等，Spring官方的原则是绝不重复造轮子，有好的解决方案只需要通过Spring进行集成即可。纵览Spring的结构，你会发现Spring Framework 本身并未提供太多具体的功能，它主要专注于让你的项目代码组织更加优雅，使其具有极好的灵活性和扩展性，同时又能通过Spring集成业界优秀的解决方案，想了解Spring的核心实现机制可参考tiny spring 项目</p><h2 id="什么是Spring-MVC？它解决了什么问题？"><a href="#什么是Spring-MVC？它解决了什么问题？" class="headerlink" title="什么是Spring MVC？它解决了什么问题？"></a>什么是Spring MVC？它解决了什么问题？</h2><p>Spring MVC是Spring的一部分，Spring 出来以后，大家觉得很好用，于是按照这种模式设计了一个 MVC框架（一些用Spring 解耦的组件），主要用于开发WEB应用和网络接口，它是Spring的一个模块，通过Dispatcher Servlet, ModelAndView 和 View Resolver，让应用开发变得很容易，一个典型的Spring MVC应用开发分为下面几步：<br>首先通过配置文件声明Dispatcher Servlet：</p><pre><code>&lt;servlet&gt;    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;    &lt;servlet-class&gt;com.qgd.oms.web.common.mvc.OmsDispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;/WEB-INF/applicationContext.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><p>通过配置文件声明servlet详情，如MVC resource，data source，bean等</p><pre><code>&lt;mvc:resources mapping=&quot;/css/**/*&quot; location=&quot;/static/css/&quot; cache-period=&quot;21600&quot;/&gt;&lt;mvc:resources mapping=&quot;/js/**/*&quot; location=&quot;/static/js/&quot; cache-period=&quot;21600&quot;/&gt;&lt;mvc:resources mapping=&quot;/views/**/*.html&quot; location=&quot;/static/views/&quot; cache-period=&quot;21600&quot;/&gt;&lt;mvc:resources mapping=&quot;/fonts/**/*&quot; location=&quot;/static/fonts/&quot;/&gt;&lt;mvc:resources mapping=&quot;/ueditor/**/*&quot; location=&quot;/static/js/lib/ueditor/&quot;/&gt;&lt;mvc:resources mapping=&quot;/img/**/*&quot; location=&quot;/static/img/&quot;/&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp2.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;    &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot;/&gt;    &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;    &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt;    &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;    &lt;property name=&quot;validationQuery&quot; value=&quot;${jdbc.validationQuery}&quot;/&gt;    &lt;property name=&quot;maxTotal&quot; value=&quot;10&quot;/&gt;    &lt;property name=&quot;minIdle&quot; value=&quot;5&quot;/&gt;    &lt;property name=&quot;maxIdle&quot; value=&quot;10&quot;/&gt;    &lt;property name=&quot;defaultAutoCommit&quot; value=&quot;true&quot;/&gt;    &lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot;/&gt;    &lt;property name=&quot;testOnBorrow&quot; value=&quot;true&quot;/&gt;    &lt;property name=&quot;poolPreparedStatements&quot; value=&quot;true&quot;/&gt;    &lt;property name=&quot;maxOpenPreparedStatements&quot; value=&quot;50&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;configService&quot; class=&quot;com.qgd.oms.web.common.service.ConfigService&quot;&gt;    &lt;property name=&quot;configStore&quot;&gt;        &lt;bean class=&quot;com.qgd.oms.web.common.service.impl.DbConfigStore&quot;&gt;            &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;                &lt;property name=&quot;taskScheduler&quot; ref=&quot;defaultScheduler&quot;/&gt;            &lt;property name=&quot;refreshInterval&quot; value=&quot;30000&quot;/&gt;        &lt;/bean&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><p>若需添加其它功能，如security，则需添加对应配置：<br>    <http pattern="/css/**/*" security="none"><br>    <http pattern="/js/**/*" security="none"><br>    <http pattern="/views/**/*.html" security="none"><br>    <http pattern="/fonts/**/*" security="none"><br>    <http pattern="/ueditor/**/*" security="none"><br>    <http pattern="/img/**/*" security="none"></http></http></http></http></http></http></p><pre><code>&lt;http use-expressions=&quot;true&quot; entry-point-ref=&quot;omsAuthenticationEntryPoint&quot;&gt;    &lt;logout logout-url=&quot;/omsmc/authentication/logout/*&quot; success-handler-ref=&quot;omsLogoutSuccessHandler&quot;&gt;&lt;/logout&gt;    &lt;intercept-url pattern=&apos;/omsmc/authentication/login*&apos; access=&quot;permitAll&quot; /&gt;    &lt;intercept-url pattern=&apos;/ms/**/*&apos; access=&quot;permitAll&quot; /&gt;    &lt;intercept-url pattern=&apos;/**&apos; access=&quot;authenticated&quot; /&gt;    &lt;!--&lt;security:form-login /&gt;--&gt;    &lt;custom-filter ref=&quot;omsUsernamePasswordAuthenticationFilter&quot; position=&quot;FORM_LOGIN_FILTER&quot; /&gt;    &lt;remember-me services-ref=&quot;omsRememberMeServices&quot; key=&quot;yfboms&quot;/&gt;    &lt;csrf disabled=&quot;true&quot;/&gt;&lt;/http&gt;</code></pre><p>增加业务代码，如controller，service，model等，最后生成war包，通过容器进行启动</p><h2 id="什么是Spring-Boot？它解决了什么问题？"><a href="#什么是Spring-Boot？它解决了什么问题？" class="headerlink" title="什么是Spring Boot？它解决了什么问题？"></a>什么是Spring Boot？它解决了什么问题？</h2><p>初期的Spring通过代码加配置的形式为项目提供了良好的灵活性和扩展性，但随着Spring越来越庞大，其配置文件也越来越繁琐，太多复杂的xml文件也一直是Spring被人诟病的地方，特别是近些年其他简洁的WEB方案层出不穷，如基于Python或Node.Js，几行代码就能实现一个WEB服务器，对比起来，大家渐渐觉得Spring那一套太过繁琐，此时，Spring社区推出了Spring Boot，它的目的在于实现自动配置，降低项目搭建的复杂度，如需要搭建一个接口服务，通过Spring Boot，几行代码即可实现，请看代码示例：</p><pre><code>//引入spring-boot-starter-web依赖&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;//声明Spring Boot应用，直接写业务逻辑即可@Controller@SpringBootApplicationpublic class MockServerApplication {    @RequestMapping(&quot;/hi&quot;)    @ResponseBody    String home() {        return &quot;how are you!&quot;;    }    public static void main(String[] args) {        SpringApplication.run(MockServerApplication.class, args);    }}</code></pre><p>你甚至都不用额外的WEB容器，直接生成jar包执行即可，因为spring-boot-starter-web模块中包含有一个内置tomcat，可以直接提供容器使用；基于Spring Boot，不是说原来的配置没有了，而是Spring Boot有一套默认配置，我们可以把它看做比较通用的约定，而Spring Boot遵循的也是约定优于配置原则，同时，如果你需要使用到Spring以往提供的各种复杂但功能强大的配置功能，Spring Boot一样支持<br>在Spring Boot中，你会发现你引入的所有包都是starter形式，如：</p><p>spring-boot-starter-web-services，针对SOAP Web Services</p><p>spring-boot-starter-web，针对Web应用与网络接口</p><p>spring-boot-starter-jdbc，针对JDBC</p><p>spring-boot-starter-data-jpa，基于hibernate的持久层框架</p><p>spring-boot-starter-cache，针对缓存支持<br>等等</p><p>Spring Boot对starter的解释如下：</p><p><strong><em>Starters are a set of convenient dependency descriptors that you can include in your application. You get a one-stop-shop for all the Spring and related technology that you need, without having to hunt through sample code and copy paste loads of dependency descriptors. For example, if you want to get started using Spring and JPA for database access, just include the spring-boot-starter-data-jpa dependency in your project, and you are good to go</em></strong></p><p>这句话的译意为：</p><p><strong><em>Starters是一系列极其方便的依赖描述，通过在你的项目中包含这些starter，你可以一站式获得你所需要的服务，而无需像以往那样copy各种示例配置及代码，然后调试，真正做到开箱即用；比如你想使用Spring JPA进行数据操作，只需要在你的项目依赖中引入spring-boot-starter-data-jpa即可</em></strong></p><h2 id="Spring，Spring-MVC，Spring-Boot-三者比较"><a href="#Spring，Spring-MVC，Spring-Boot-三者比较" class="headerlink" title="Spring，Spring MVC，Spring Boot 三者比较"></a>Spring，Spring MVC，Spring Boot 三者比较</h2><p>三者专注的领域不同，解决的问题也不一样；总的来说，Spring 就像一个大家族，有众多衍生产品例如 Boot，Security，JPA等等。但他们的基础都是Spring 的 IOC 和 AOP，IOC提供了依赖注入的容器，而AOP解决了面向切面的编程，然后在此两者的基础上实现了其他衍生产品的高级功能；Spring MVC是基于 Servlet 的一个 MVC 框架，主要解决 WEB 开发的问题，因为 Spring 的配置非常复杂，各种xml，properties处理起来比较繁琐。于是为了简化开发者的使用，Spring社区创造性地推出了Spring Boot，它遵循约定优于配置，极大降低了Spring使用门槛，但又不失Spring原本灵活强大的功能</p><p><a href="https://upload-images.jianshu.io/upload_images/4185175-a0a50bf022178e1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/667" target="_blank" rel="noopener">https://upload-images.jianshu.io/upload_images/4185175-a0a50bf022178e1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/667</a></p><h2 id="Resource和-Autowired的区别？"><a href="#Resource和-Autowired的区别？" class="headerlink" title="@Resource和@Autowired的区别？"></a>@Resource和@Autowired的区别？</h2><p>@Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。</p><h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3><p>两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。</p><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><h4 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h4><p>@Autowired为Spring提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;只按照byType注入。</p><pre><code>public class TestServiceImpl {    // 下面两种@Autowired只要使用一种即可    @Autowired    private UserDao userDao; // 用于字段上    @Autowired    public void setUserDao(UserDao userDao) { // 用于属性的方法上        this.userDao = userDao;    }}</code></pre><p>  @Autowired注解是<strong>按照类型（byType）装配</strong>依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。如下：</p><pre><code>public class TestServiceImpl {    @Autowired    @Qualifier(&quot;userDao&quot;)    private UserDao userDao;}</code></pre><h4 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h4><p>@Resource默认按照ByName自动注入，<strong><em> 是JDK1.6支持的注解，按照名称进行装配，</em></strong><br>由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。</p><pre><code>public class TestServiceImpl {    // 下面两种@Resource只要使用一种即可    @Resource(name=&quot;userDao&quot;)    private UserDao userDao; // 用于字段上    @Resource(name=&quot;userDao&quot;)    public void setUserDao(UserDao userDao) { // 用于属性的setter方法上        this.userDao = userDao;    }}</code></pre><p>  注：最好是将@Resource放在setter方法上，因为这样更符合面向对象的思想，通过set、get去操作属性，而不是直接去操作属性。</p><h5 id="Resource装配顺序："><a href="#Resource装配顺序：" class="headerlink" title="@Resource装配顺序："></a>@Resource装配顺序：</h5><p><strong><em> ①如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。</em></strong></p><p><strong><em> ②如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。</em></strong></p><p><strong><em> ③如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。</em></strong></p><p><strong><em> ④如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。</em></strong></p><pre><code>@Resource的作用相当于@Autowired，只不过@Autowired按照byType自动注入。</code></pre><h1 id="Mac-OS-Linux命令查询网络端口占用情况，查找-杀死进程"><a href="#Mac-OS-Linux命令查询网络端口占用情况，查找-杀死进程" class="headerlink" title="Mac OS/Linux命令查询网络端口占用情况，查找/杀死进程"></a>Mac OS/Linux命令查询网络端口占用情况，查找/杀死进程</h1><h2 id="netstat命令"><a href="#netstat命令" class="headerlink" title="netstat命令"></a>netstat命令</h2><pre><code>netstat -an | grep 3306</code></pre><p>3306替换成需要grep的端口号</p><h2 id="lsof命令"><a href="#lsof命令" class="headerlink" title="lsof命令"></a>lsof命令</h2><p>通过list open file命令可以查看到当前打开文件，在linux中所有事物都是以文件形式存在，包括网络连接及硬件设备。</p><pre><code>lsof -i:80</code></pre><p>-i参数表示网络链接，:80指明端口号，该命令会同时列出PID，方便kill</p><p>查看所有进程监听的端口</p><pre><code>sudo lsof -i -P | grep -i &quot;listen&quot;</code></pre><h2 id="ps-A-grep-进程名"><a href="#ps-A-grep-进程名" class="headerlink" title="ps -A|grep [进程名]"></a>ps -A|grep [进程名]</h2><p>找PID： ps -A|grep [进程名]</p><h2 id="kill-PID"><a href="#kill-PID" class="headerlink" title="kill [PID]"></a>kill [PID]</h2><p>杀进程：kill [PID]<br>参考资料：</p><p>【1】<a href="https://www.jianshu.com/p/42620a0a2c33" target="_blank" rel="noopener">https://www.jianshu.com/p/42620a0a2c33</a></p><p>【2】<a href="https://www.cnblogs.com/think-in-java/p/5474740.html" target="_blank" rel="noopener">https://www.cnblogs.com/think-in-java/p/5474740.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;阐述Spring，Spring MVC，Spring Boot 三者的原理和区别。学习笔记II中涉及到对@Resource和@Autowired的区别做了解释。&lt;br&gt;对用命令查询网络端口占用情况，查找/杀死进程做了回顾性的复习。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年7月" scheme="http://yoursite.com/categories/2019%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot学习笔记II</title>
    <link href="http://yoursite.com/2019/07/19/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0II/"/>
    <id>http://yoursite.com/2019/07/19/SpringBoot学习笔记II/</id>
    <published>2019-07-19T03:23:12.000Z</published>
    <updated>2019-07-26T01:44:01.141Z</updated>
    
    <content type="html"><![CDATA[<p>总结整理在学习SpringBoot的过程中遇到的问题和解决方案。</p><a id="more"></a><h1 id="JPA任务："><a href="#JPA任务：" class="headerlink" title="JPA任务："></a>JPA任务：</h1><p>在Merchant表中完成一个JPA项目的增删改查,并在test/java/com.example.std.java.demo/DemoApplicationTests中进行测试</p><h1 id="Mybatis任务："><a href="#Mybatis任务：" class="headerlink" title="Mybatis任务："></a>Mybatis任务：</h1><p>在Merchant表中完成一个Mybatis项目的增删改查,并在test/java/com.example.std.java.demo/DemoApplicationTests中进行测试<br>使用Mybatis注册商户，根据商编（MerchantNO）查询商户，修改商户状态，从外部能查询，Controller调service，再调cto<br>注释<br>每个dto属性是做什么的<br>日志</p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="建表注意事项："><a href="#建表注意事项：" class="headerlink" title="建表注意事项："></a>建表注意事项：</h2><p>创建数据访问接口userRepository建在dao层中。</p><p>社区版的Intellij IDEA可以直接在文件夹上右键New-&gt;Jpa Entities即可自动创建实体。</p><p>对数据库对增删改查可以直接写在test文件夹下的DemoApplicationTest中，每次执行时只需要Run相应的test函数即可，不需全部Run一遍。</p><h2 id="常见问题application-properties文件解析错误："><a href="#常见问题application-properties文件解析错误：" class="headerlink" title="常见问题application.properties文件解析错误："></a>常见问题application.properties文件解析错误：</h2><p>application.yml和application.properties的格式是不同的，注意更改格式。</p><h2 id="导入目录时格式混乱"><a href="#导入目录时格式混乱" class="headerlink" title="导入目录时格式混乱"></a>导入目录时格式混乱</h2><p>打开本地项目时直接open pom.xml会自动解析项目</p><p>如果从git上拉分支则注意：<br>Intellij IDEA从git上拉取分支时要选择import project from external model，<br>在import Project一栏时Root directory栏目中不要默认目录，否则会找不到pom.xml，要选择clone下来的目录中的demo文件</p><h2 id="Maven配置问题"><a href="#Maven配置问题" class="headerlink" title="Maven配置问题"></a>Maven配置问题</h2><p>File-&gt;Preference-&gt;Maven中的Maven home directory; User settings file; Local repository三个根目录中都要选择公司私有的maven目录</p><h2 id="Debug问题"><a href="#Debug问题" class="headerlink" title="Debug问题"></a>Debug问题</h2><p>IDEA中错误信息以堆栈形式输出，所以最下面的错误是第一个错误，优先看</p><h2 id="hibernate-dialect配置问题"><a href="#hibernate-dialect配置问题" class="headerlink" title="hibernate.dialect配置问题"></a>hibernate.dialect配置问题</h2><p>启动时报错：<br>Access to DialectResolutionInfo cannot be null when ‘hibernate.dialect’ not set</p><p>hibernate.dialect是为了更好的适配各种数据库，针对每种数据库都指定方言dialect，将各类数据库Oracle，Mysql等不同类型等语法<br>转换成hibernate能理解等统一的格式。</p><h3 id="解决方法1"><a href="#解决方法1" class="headerlink" title="解决方法1:"></a>解决方法1:</h3><p>这个问题花了很长时间，google到的方法都没有作用，最后确定原因是demo/config/JpaConfig文件中的factory.setJpaProperties(jpaProperties.getProperties());一行中Jpaproperties读到的属性为空，</p><p>demo/config/JpaConfig文件如下</p><pre><code>package com.example.std.java.demo.config;import javax.annotation.Resource;import javax.persistence.EntityManagerFactory;import javax.sql.DataSource;import com.example.std.java.demo.config.jpa.HibernateConfig;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;import org.springframework.boot.autoconfigure.orm.jpa.JpaProperties;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import org.springframework.data.jpa.repository.config.EnableJpaRepositories;import org.springframework.orm.jpa.DefaultJpaDialect;import org.springframework.orm.jpa.JpaTransactionManager;import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;import org.springframework.transaction.PlatformTransactionManager;import org.springframework.transaction.annotation.EnableTransactionManagement;import java.util.Map;import java.util.Properties;@Configuration@EnableTransactionManagement@EnableJpaRepositories(    entityManagerFactoryRef = &quot;entityManagerFactory&quot;,    transactionManagerRef = &quot;platformTransactionManager&quot;,    basePackages = {&quot;com.example.std.java.demo.dao.jpa&quot;}) //设置Repository所在位置public class JpaConfig {    @Resource    private HibernateConfig jpaProperties;    @Resource(name = &quot;testDataSource&quot;)    private DataSource dataSource;    @Primary    @Bean(name = &quot;entityManagerFactory&quot;)    public EntityManagerFactory entityManagerFactory() {        HibernateJpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter();        LocalContainerEntityManagerFactoryBean factory = new LocalContainerEntityManagerFactoryBean();        factory.setJpaVendorAdapter(vendorAdapter);        factory.setPackagesToScan(&quot;com.example.std.java.demo.entity.jpa&quot;);        factory.setDataSource(dataSource);//数据源        factory.setJpaProperties(jpaProperties.getProperties());        factory.afterPropertiesSet();//在完成了其它所有相关的配置加载以及属性设置后,才初始化        return factory.getObject();    }    /**     * 配置事物管理器     * @return     */    @Bean(name = &quot;platformTransactionManager&quot;)    @Primary    public PlatformTransactionManager platformTransactionManager() {        JpaTransactionManager jpaTransactionManager = new JpaTransactionManager();        jpaTransactionManager.setEntityManagerFactory(this.entityManagerFactory());        return jpaTransactionManager;    }}</code></pre><p>为了能传进属性，在demo/config/jpa/HibernateConfig文件中增加属性properties</p><pre><code>package com.example.std.java.demo.config.jpa;import lombok.Data;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Configuration;import java.util.Properties;@Configuration@ConfigurationProperties(prefix = &quot;user.jpa&quot;)@Datapublic class HibernateConfig {    Properties properties;}</code></pre><p>其中注解中的的@ConfigurationProperties(prefix = “user.jpa”)指的是resources/local/application.yml中的数据源配置</p><pre><code>spring:  datasource:    test:      jdbcUrl: jdbc:mysql://10.143.248.78:3306/java_demo?autoReconnect=true&amp;characterEncoding=UTF8&amp;&amp;parseTime=True      type: org.apache.tomcat.jdbc.pool.DataSource      username: root      password: mojiti      testOnBorrow: true      validationQuery: &quot;select version()&quot;      driver-class-name: com.mysql.jdbc.Driver    shangtongdai:      jdbcUrl: jdbc:mysql://10.143.248.78:3306/shangtongdai?autoReconnect=true&amp;characterEncoding=UTF8&amp;&amp;parseTime=True      type: org.apache.tomcat.jdbc.pool.DataSource      username: root      password: mojiti      testOnBorrow: true      validationQuery: &quot;select version()&quot;      driver-class-name: com.mysql.jdbc.Driveruser:  jpa:    properties:      hibernate:        hbm2ddlauto: update        dialect: org.hibernate.dialect.MySQL5InnoDBDialect</code></pre><h3 id="解决方法2"><a href="#解决方法2" class="headerlink" title="解决方法2:"></a>解决方法2:</h3><p>也可以直接将properties固定的写在JpaConfig中</p><pre><code>@Primary @Bean(name = &quot;entityManagerFactory&quot;) public EntityManagerFactory entityManagerFactory() {     HibernateJpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter();     LocalContainerEntityManagerFactoryBean factory = new LocalContainerEntityManagerFactoryBean();     factory.setJpaVendorAdapter(vendorAdapter);     factory.setPackagesToScan(&quot;com.example.std.java.demo.entity.jpa&quot;);     factory.setDataSource(dataSource);//数据源     Properties properties=new Properties();     properties.setProperty(&quot;hibernate.dialect&quot;,&quot;org.hibernate.dialect.MySQL5InnoDBDialect&quot;);     factory.setJpaProperties(properties);     factory.afterPropertiesSet();//在完成了其它所有相关的配置加载以及属性设置后,才初始化     return factory.getObject(); }</code></pre><h2 id="新建SpringBoot项目启动时往往会报错"><a href="#新建SpringBoot项目启动时往往会报错" class="headerlink" title="新建SpringBoot项目启动时往往会报错"></a>新建SpringBoot项目启动时往往会报错</h2><h3 id="常见错误类型："><a href="#常见错误类型：" class="headerlink" title="常见错误类型："></a>常见错误类型：</h3><pre><code>***************************APPLICATION FAILED TO START***************************Description:Failed to configure a DataSource: &apos;url&apos; attribute is not specified and no embedded datasource could be configured.Reason: Failed to determine a suitable driver class</code></pre><h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><p>配置Mybatis时出现的错误，原因是因为添加了数据库组件，所以autoconfig会去读取数据源但配置，而新建项目还没有配置数据源，所以会导致异常出现。</p><p>方法1:需要先在target/pom.xml中去掉对数据库的依赖，即去掉下面这段。</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;2.1.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>方法2:也可以在启动类的@EnableAutoConfiguration或@SpringBootApplication中添加exclude = {DataSourceAutoConfiguration.class}，排除此类的autoconfig。启动以后就可以正常运行。修改如下：</p><pre><code>@SpringBootApplication(exclude= DataSourceAutoConfiguration.class)public class DemoApplication {    public static void main(String[] args) {        SpringApplication.run(DemoApplication.class, args);    }}</code></pre><h3 id="常见错误类型：-1"><a href="#常见错误类型：-1" class="headerlink" title="常见错误类型："></a>常见错误类型：</h3><pre><code>Error starting ApplicationContext. To display the conditions report re-run your application with &apos;debug&apos; enabled.</code></pre><h3 id="解决办法：-1"><a href="#解决办法：-1" class="headerlink" title="解决办法："></a>解决办法：</h3><p>这是配置JPA时出现的错误，错误原因同上，同理可知解决方法。</p><h2 id="多数据源问题："><a href="#多数据源问题：" class="headerlink" title="多数据源问题："></a>多数据源问题：</h2><p>在多数据源情况下，会出现所链接的数据库中没有需要查询的表，而该表在另一个数据库中，此时在demo/config/JpaConfig文件中找到</p><pre><code>@Qualifier(&quot;testDataSource&quot;)private DataSource dataSource;</code></pre><p>改为<br>    @Resource(name = “testDataSource”)<br>    private DataSource dataSource;<br>或者@Autowired注解来选择数据源，其中dataSource等来自于demo/config/DbAutoConfiguration</p><pre><code>package com.example.std.java.demo.config;import javax.sql.DataSource;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.jdbc.DataSourceBuilder;import org.springframework.context.annotation.AdviceMode;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.transaction.annotation.EnableTransactionManagement;/** * @Description: db数据库自动化配置 * @Author: * @Date: 2019-07-11 14:50 */@Configuration@EnableTransactionManagement(mode = AdviceMode.ASPECTJ)public class DbAutoConfiguration {    @Bean(&quot;testDataSource&quot;)    @ConfigurationProperties(prefix = &quot;spring.datasource.test&quot;)    public DataSource dataSource() {        return DataSourceBuilder.create().build();    }    @Bean(&quot;dataSource&quot;)    @ConfigurationProperties(prefix = &quot;spring.datasource.shangtongdai&quot;)    public DataSource dataSource2() {        return DataSourceBuilder.create().build();    }}</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1]<a href="https://stackoverflow.com/questions/40738818/illegalargumentexception-at-least-one-jpa-metamodel-must-be-present?newreg=1d1be5c9c5a04ec2878d9fc8237bbda5" target="_blank" rel="noopener">https://stackoverflow.com/questions/40738818/illegalargumentexception-at-least-one-jpa-metamodel-must-be-present?newreg=1d1be5c9c5a04ec2878d9fc8237bbda5</a><br>[2]]<a href="https://blog.csdn.net/zsg88/article/details/80780281" target="_blank" rel="noopener">https://blog.csdn.net/zsg88/article/details/80780281</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结整理在学习SpringBoot的过程中遇到的问题和解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年7月" scheme="http://yoursite.com/categories/2019%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot学习笔记I</title>
    <link href="http://yoursite.com/2019/07/17/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0I/"/>
    <id>http://yoursite.com/2019/07/17/SpringBoot学习笔记I/</id>
    <published>2019-07-17T07:30:12.000Z</published>
    <updated>2019-07-25T01:49:45.216Z</updated>
    
    <content type="html"><![CDATA[<p>总结整理在学习SpringBoot的过程中遇到的问题和解决方案（我又双叒要开始更新博客了）。</p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>忙忙碌碌的暑假结束了，虽然可以算得上十分充实，不过在学习新知识提高自己这一方面却做的并不尽如人意，之前制定的学习计划大都被其它各种计划所取代，<br>从屈指可数的博客更新就能看出来。<br>随着步入职场，自我学习变得更加重要，之前这段时间的状态不能再继续下去。写了这么多中心思想就一条：“我又双叒要开始更新博客了”。</p><h2 id="SSM框架"><a href="#SSM框架" class="headerlink" title="SSM框架"></a>SSM框架</h2><p>Java中常用的有三大框架SSM（Spring，SpringMVC和Mybatis），其中Spring是一个轻量级的控制反转（IoC）和面向切面（AOP）的容器框架，<br>是为了解决企业应用开发的复杂性而创建的。而SpringMVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。<br>SpringMVC分离了控制器、模型对象、分派器以及处理程序对象的角色，这种分离让它们更容易进行定制。<br>MyBatis本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。<br>MyBatis是一个基于Java的持久层框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects（DAO）MyBatis<br>消除了几乎所有的JDBC代码和参数的手工设置以及结果集的检索。<br>MyBatis 使用简单的 XML或注解用于配置和原始映射，将接口和 Java 的POJOs（Plain Old Java Objects，普通的 Java对象）映射成数据库中的记录。</p><h2 id="SpringBoot简介"><a href="#SpringBoot简介" class="headerlink" title="SpringBoot简介"></a>SpringBoot简介</h2><p>而我们之后要学习的SpringBoot则可以快速构建容易配置的 Spring 应用程序，使用SpringBoot可以减少配置的工作量。SpringBoot网站对它的简洁介绍如下：</p><p>“ Spring Boot 使您能轻松地创建独立的、生产级的、基于 Spring 且能直接运行的应用程序。我们对 Spring 平台和第三方库有自己的看法，<br>所以您从一开始只会遇到极少的麻烦。”</p><p>刚开始学习SpringBoot时可以从HelloWorld开始，此处网上例程很多，不再赘述。</p><h1 id="概念剖析"><a href="#概念剖析" class="headerlink" title="概念剖析"></a>概念剖析</h1><p>首先学习几个Java开发中会遇到的概念。<br><img src="assets/markdown-img-paste-20190718153319935.png" alt="https://img-blog.csdn.net/20170816144718827"></p><h2 id="1-DAO-data-access-object-数据访问对象"><a href="#1-DAO-data-access-object-数据访问对象" class="headerlink" title="1.DAO[data access object]数据访问对象"></a>1.DAO[data access object]数据访问对象</h2><p>一个面向对象的数据库接口，负责持久层的操作，为业务层提供接口，主要用来封装对数据库的访问，常见操作无外乎 CURD。我们也可以认为一个 DAO 对应一个 POJO 的对象，它位于业务逻辑与数据库资源中间，可以结合 PO 对数据库进行相关的操作。<br>此处注意对数据访问不仅仅指的是对数据库的访问。 假如A系统调用B系统的服务获取数据，这时候A系统对B系统访问数据对象的封装也可以称为DAO。</p><h2 id="2-DTO-data-transfer-object-数据传输对象"><a href="#2-DTO-data-transfer-object-数据传输对象" class="headerlink" title="2.DTO[data transfer object]数据传输对象"></a>2.DTO[data transfer object]数据传输对象</h2><p>主要用于远程调用等需要大量传输对象的地方，比如我们有一个交易订单表，含有20个字段，那么其对应的PO就有20个属性，但我们的页面上只需要显示5个字段，因此没有必要把整个 PO 对象传递给客户端，这时我们只需把仅有 5 个属性的 DTO 把结果传递给客户端即可，而且如果用这个对象来对应界面的显示对象，那此时它的身份就转为VO。使用DTO的好处有两个，一是能避免传递过多的无用数据，提高数据的传输速度；二是能隐藏后端的表结构。常见的用法是：将请求的数据或属性组装成一个RequestDTO，再将响应的数据或属性组装成一个 ResponseDTO.</p><h2 id="3-PO-persistant-object-持久层对象"><a href="#3-PO-persistant-object-持久层对象" class="headerlink" title="3.PO[persistant object]持久层对象"></a>3.PO[persistant object]持久层对象</h2><p>由一组属性和属性的get和set方法组成，最简单的 PO 就是对应数据库中某个表中的一条记录（也就是说，我们可以将数据库表中的一条记录理解为一个持久层对象），多个记录可以用 PO 的集合，PO 中应该不包含任何对数据库的操作。PO 的属性是跟数据库表的字段一一对应的，此外 PO 对象需要实现序列化接口。因对象-关系映射（Object-Relational Mapping，简称ORM）框架的广泛使用而被引入到JavaEE项目设计中。</p><h2 id="4-BO-bussiness-object-业务对象"><a href="#4-BO-bussiness-object-业务对象" class="headerlink" title="4.BO[bussiness object]业务对象"></a>4.BO[bussiness object]业务对象</h2><p>简单的真实世界的软件抽象，通常位于中间层。BO 的主要作用是把业务逻辑封装为一个对象，这个对象可以包括一个或多个其它的对象。举一个求职简历的例子，每份简历都包括教育经历、项目经历等，我们可以让教育经历和项目经历分别对应一个 PO，这样在我们建立对应求职简历的 BO 对象处理简历的时候，让每个 BO 都包含这些 PO 即可。</p><h2 id="5-VO-value-object-值对象"><a href="#5-VO-value-object-值对象" class="headerlink" title="5.VO[value object]值对象"></a>5.VO[value object]值对象</h2><p>通常用于业务层之间的数据传递，和 PO 一样也是仅仅包含数据而已，但 VO 应该是抽象出的业务对象，可以和表对应，也可以不对应，这根据业务的需要。 如果锅碗瓢盆分别为对应的业务对象的话，那么整个碗柜就是一个值对象。此外，VO 也可以称为页面对象，如果称为页面对象的话，那么它所代表的将是整个页面展示层的对象，也可以由需要的业务对象进行组装而来。</p><h2 id="6-POJO-plain-ordiary-java-object-简单java对象"><a href="#6-POJO-plain-ordiary-java-object-简单java对象" class="headerlink" title="6.POJO[plain ordiary java object] 简单java对象"></a>6.POJO[plain ordiary java object] 简单java对象</h2><p>实际就是普通的 JavaBeans，是为了避免和 EJB（Enterprise JavaBean）混淆所创造的简称。POJO 实质上可以理解为简单的实体类，其中有一些属性及其getter和setter方法的类，没有业务逻辑，也不允许有业务方法，也不能携带有connection之类的方法。POJO 是 JavaEE 世界里面最灵活的对象，在简单系统中，如果从数据库到页面展示都是 POJO 的话，它可以是 DTO；如果从数据库中到业务处理中都是 POJO 的话，它可以是 BO；如果从数据库到整个页面的展示的话，它也可以是 VO.</p><h2 id="7-Entity-实体"><a href="#7-Entity-实体" class="headerlink" title="7.Entity 实体"></a>7.Entity 实体</h2><p>对应数据库中的表，简单的理解为一个表对应一个实体，以交易订单表Order为例，若该表中含有20个字段，那么这个OrderEntity对象里面也要含有20个对应的属性。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】详述 PO VO BO DTO DAO 和 POJO 的概念及区别<a href="https://blog.csdn.net/qq_35246620/article/details/77247427" target="_blank" rel="noopener">https://blog.csdn.net/qq_35246620/article/details/77247427</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结整理在学习SpringBoot的过程中遇到的问题和解决方案（我又双叒要开始更新博客了）。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年7月" scheme="http://yoursite.com/categories/2019%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Linux配置问题小结</title>
    <link href="http://yoursite.com/2019/06/03/Linux%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2019/06/03/Linux配置问题小结/</id>
    <published>2019-06-03T04:47:45.000Z</published>
    <updated>2019-07-18T04:07:56.272Z</updated>
    
    <content type="html"><![CDATA[<p>记录Linux配置问题的解决方案，在Ubuntu 18.04中安装terminator 并在右键菜单中添加open in termintor;解决了搜狗输入法在Ubuntu 18.04 中无法安装和安装后无法使用的问题;解决了Linux下无线网卡rtl8821CE/rtl8723ce驱动无法驱动的问题。</p><a id="more"></a><h2 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h2><ol><li>Ubuntu 18.04 安装terminator 并在右键菜单中添加open in termintor</li><li>解决了搜狗输入法在Ubuntu 18.04 中无法安装和安装后无法使用的问题</li><li>解决了Linux下无线网卡rtl8821CE/rtl8723ce驱动无法驱动的问题。</li></ol><h2 id="Terminator安装和右键菜单添加解决方案"><a href="#Terminator安装和右键菜单添加解决方案" class="headerlink" title="Terminator安装和右键菜单添加解决方案"></a>Terminator安装和右键菜单添加解决方案</h2><p>  题外话，安利下terminator，是Linux环境下一款非常赞的命令行管理工具，前段时间微软宣布推出名为Windows Terminal的新款命令行工具，在个人看来也是姗姗来迟的将terminator能实现的功能在windows中实现了。</p><p>  安装terminator</p><pre><code>sudo apt install terminator</code></pre><p>  网上大多用dconf系统配置编辑器将terminator设为默认，但在我的系统中这样在文件位置中右键打开时还是只能打开默认的终端，用起来很不方便，直到找到了这种方法（<a href="https://blog.csdn.net/bestBT/article/details/81221378）。" target="_blank" rel="noopener">https://blog.csdn.net/bestBT/article/details/81221378）。</a><br>  安装Nautilus-actions</p><pre><code>sudo add-apt-repository ppa:daniel-marynicz/filemanager-actionssudo apt-get install filemanager-actions-nautilus-extension</code></pre><p>使用fma-config-tool 来配置。<br>1.新建动作，在action（动作）界面中勾选第二项Display item in location context menu。在Context label中输入想写的名字“在Terminator中打开”。<br>2.在Command（命令）界面中输入路径/usr/bin/terminator，参数中输入–working-directory=%d/%b。<br>3.这样操作完在terminator中打开还在右键的二级菜单中，所以点右上角齿轮标志（编辑您的首选项），在运行时首选项-》Nautilus菜单布局中取消勾选Create a root “FileManager-Actions” menu，这样就可以愉快的使用Terminator了。</p><h2 id="搜狗拼音输入法安装问题解决方案"><a href="#搜狗拼音输入法安装问题解决方案" class="headerlink" title="搜狗拼音输入法安装问题解决方案"></a>搜狗拼音输入法安装问题解决方案</h2><p>一开始嫌麻烦所以用Linux自带的Ibus系统下的输入法，但各种问题实在忍不了，所以还是装了搜狗拼音法，中间遇到几个问题只找到这个靠谱的解决方法（<a href="https://ywnz.com/linuxjc/1476.html）。" target="_blank" rel="noopener">https://ywnz.com/linuxjc/1476.html）。</a></p><p>在根据指导方法安装搜狗拼音输入法后，会遇到很多依赖问题，一路折腾后会发现搜狗拼音依赖的fcitx-libs-qt这个包在ubuntu18.04的源里面是不存在的。替代品似乎是libfcitx-qt0，但也很难搞。</p><h3 id="下载旧版"><a href="#下载旧版" class="headerlink" title="下载旧版"></a>下载旧版</h3><p>搜狗官方的最新版（sogoupinyin_2.2.0.0102_amd64.deb）是不能用的，原因不作深究。需要下载一个旧版本（sogoupinyin_2.1.0.0086_amd64.deb）。<br>将该deb包放置于一个空目录。</p><h3 id="创建软件包目录"><a href="#创建软件包目录" class="headerlink" title="创建软件包目录"></a>创建软件包目录</h3><pre><code>mkdir -p extract/DEBIAN</code></pre><h3 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h3><pre><code>dpkg-deb -x sogoupinyin_2.1.0.0086_amd64.deb extract/dpkg-deb -e sogoupinyin_2.1.0.0086_amd64.deb extract/DEBIAN</code></pre><h3 id="修改control文件"><a href="#修改control文件" class="headerlink" title="修改control文件"></a>修改control文件</h3><p>用任意文本编辑器打开extract/DEBIAN/control 找到Depends行，删除fcitx-libs和fcitx-libs-qt，保存退出。<br>其中要找的Depends行长这个样子</p><pre><code>Depends: fcitx (&gt;= 1:4.2.8.3-3~), fcitx-frontend-gtk2, fcitx-frontend-gtk3, fcitx-frontend-qt4, fcitx-module-kimpanel, im-config, libopencc2 | libopencc1, lsb-release, unzip, x11-utils, libc6 (&gt;= 2.8), libgcc1 (&gt;= 1:4.1.1), libgdk-pixbuf2.0-0 (&gt;= 2.22.0), libglib2.0-0 (&gt;= 2.16.0), libidn11 (&gt;= 1.13), libnotify4 (&gt;= 0.7.0), libqt4-dbus (&gt;= 4:4.8.0), libqt4-declarative (&gt;= 4:4.8.0), libqt4-network (&gt;= 4:4.8.0), libqtcore4 (&gt;= 4:4.8.0), libqtgui4 (&gt;= 4:4.8.0), libstdc++6 (&gt;= 4.6), libx11-6, zlib1g (&gt;= 1:1.2.0)</code></pre><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><pre><code>mkdir builddpkg-deb -b extract/ build/</code></pre><p>执行完毕build目录下会生成一个新的deb包。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>先彻底卸载掉搜狗输入法，并删除以下配置文件：</p><p>.sogouinput</p><p>.config/fcitx</p><p>.config/sogou-qimpanel</p><p>.config/SogouPY</p><p>.config/SogouPY.users</p><p>.config/fcitx-qimpanel</p><p>然后安装我们重新打包的输入法即可。重启之后，搜狗输入法恢复正常。<br>最后要记得在设置-》区域和语言-》管理已安装的语言-》语言支持-》语言-》键盘输入法系统中选择Fcitx系统，因为搜狗输入法等都是在Fcitx系统框架下的。</p><h2 id="LINUX下无线网卡rtl8821CE-rtl8723de驱动无法驱动解决办法"><a href="#LINUX下无线网卡rtl8821CE-rtl8723de驱动无法驱动解决办法" class="headerlink" title="LINUX下无线网卡rtl8821CE/rtl8723de驱动无法驱动解决办法"></a>LINUX下无线网卡rtl8821CE/rtl8723de驱动无法驱动解决办法</h2><h3 id="1-确保linux内核版本大于-4-14"><a href="#1-确保linux内核版本大于-4-14" class="headerlink" title="1. 确保linux内核版本大于 4.14"></a>1. 确保linux内核版本大于 4.14</h3><p>  如何查看linux 内核版本 ：终端 uname -sr</p><p>  如果内核版本低于 4.14：升级linux内核 ubuntu可以参照 <a href="https://www.linuxidc.com/Linux/2017-03/141940.html" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2017-03/141940.html</a></p><p>  升级完记得重启</p><h3 id="2-下载linux中8821CE-rtl8723de的驱动源码"><a href="#2-下载linux中8821CE-rtl8723de的驱动源码" class="headerlink" title="2. 下载linux中8821CE/rtl8723de的驱动源码"></a>2. 下载linux中8821CE/rtl8723de的驱动源码</h3><p>git原地址（rtl8821CE）：<a href="https://github.com/endlessm/linux/tree/master/drivers/net/wireless/rtl8821ce" target="_blank" rel="noopener">https://github.com/endlessm/linux/tree/master/drivers/net/wireless/rtl8821ce</a></p><p>git原地址（rtl8723de）：<a href="https://github.com/endlessm/linux/tree/master/drivers/net/wireless/rtl8723de" target="_blank" rel="noopener">https://github.com/endlessm/linux/tree/master/drivers/net/wireless/rtl8723de</a></p><p>或者本地下载 <a href="https://free-1253146430.cos.ap-shanghai.myqcloud.com/rtl8821ce.zip" target="_blank" rel="noopener">https://free-1253146430.cos.ap-shanghai.myqcloud.com/rtl8821ce.zip</a></p><p>（rtl8723de 的话 自己 去git上下吧）</p><h3 id="3-编译驱动"><a href="#3-编译驱动" class="headerlink" title="3.编译驱动"></a>3.编译驱动</h3><p>  <strong><em>解压rtl8821ce.zip</em></strong></p><p>  <strong><em>修改文件Makefile</em></strong></p><pre><code>export TopDIR ?= $(srctree)/drivers/net/wireless/rtl8821ce</code></pre><p>从这行 “export TopDIR ?= 后面改成当前目录 例如我的：</p><pre><code>export TopDIR ?= /home/horsun/Downloads/rtl8821ce</code></pre><p><strong><em>保存修改</em></strong></p><p>  分别进行：</p><pre><code>makesudo make installsudo modprobe -a 8821ce</code></pre><p>遇到问题</p><pre><code>modprobe: ERROR: could not insert &apos;8812au&apos;: Exec format error</code></pre><p><strong><em>执行</em></strong></p><pre><code>make cleanmakesudo make installsudo modprobe 8812au</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录Linux配置问题的解决方案，在Ubuntu 18.04中安装terminator 并在右键菜单中添加open in termintor;解决了搜狗输入法在Ubuntu 18.04 中无法安装和安装后无法使用的问题;解决了Linux下无线网卡rtl8821CE/rtl8723ce驱动无法驱动的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年6月" scheme="http://yoursite.com/categories/2019%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>操作系统基础概念I</title>
    <link href="http://yoursite.com/2019/06/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5I/"/>
    <id>http://yoursite.com/2019/06/02/操作系统基础概念I/</id>
    <published>2019-06-02T02:42:12.000Z</published>
    <updated>2019-07-18T04:08:31.095Z</updated>
    
    <content type="html"><![CDATA[<p>总结操作系统基础概念</p><a id="more"></a><h2 id="（一）请分别简单说一说进程和线程以及它们的区别。"><a href="#（一）请分别简单说一说进程和线程以及它们的区别。" class="headerlink" title="（一）请分别简单说一说进程和线程以及它们的区别。"></a>（一）请分别简单说一说进程和线程以及它们的区别。</h2><h3 id="1-进程是资源分配的基本单位"><a href="#1-进程是资源分配的基本单位" class="headerlink" title="1.进程是资源分配的基本单位"></a>1.进程是资源分配的基本单位</h3><p>进程是具有一定功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源调度和分配的基本单位。</p><h3 id="2-线程是独立调度的基本单位"><a href="#2-线程是独立调度的基本单位" class="headerlink" title="2.线程是独立调度的基本单位"></a>2.线程是独立调度的基本单位</h3><p>线程是进程的实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。<br>一个进程可以有多个线程，多个线程也可以并发执行</p><h3 id="3-区别"><a href="#3-区别" class="headerlink" title="3.区别"></a>3.区别</h3><h4 id="I-拥有资源"><a href="#I-拥有资源" class="headerlink" title="I 拥有资源"></a>I 拥有资源</h4><p>进程是资源分配的基本单位，而线程不拥有资源，线程可以访问隶属雨进程的资源</p><h4 id="II-调度"><a href="#II-调度" class="headerlink" title="II 调度"></a>II 调度</h4><p>线程是独立调度的基本单位，在同一进程中，线程切换不会引起进程切换。从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</p><h4 id="III-系统开销"><a href="#III-系统开销" class="headerlink" title="III 系统开销"></a>III 系统开销</h4><p>在创建或撤销进程时，系统都要为之分配或者回收资源（内存空间，I/O设备），开销远大于创建或者撤销线程的开销。在进行进程切换时，涉及当前执行进程CPU环境的保存及新调度进程CPU环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</p><h4 id="IV-通信方面"><a href="#IV-通信方面" class="headerlink" title="IV 通信方面"></a>IV 通信方面</h4><p>线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助IPC。</p><p>如果你对进程或者线程不太熟悉，建议阅读：<a href="https://link.zhihu.com/?target=http%3A//www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="noopener">进程与线程的一个简单解释</a></p><h2 id="（二）线程同步的方式有哪些？"><a href="#（二）线程同步的方式有哪些？" class="headerlink" title="（二）线程同步的方式有哪些？"></a>（二）线程同步的方式有哪些？</h2><h3 id="互斥量："><a href="#互斥量：" class="headerlink" title="互斥量："></a>互斥量：</h3><p>采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。</p><h3 id="信号量："><a href="#信号量：" class="headerlink" title="信号量："></a>信号量：</h3><p>它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</p><h3 id="事件（信号）："><a href="#事件（信号）：" class="headerlink" title="事件（信号）："></a>事件（信号）：</h3><p>通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</p><p>如果你对线程同步IPC的方式不太熟悉，建议阅读：<a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/lebronjames/archive/2010/08/11/1797702.html" target="_blank" rel="noopener">线程同步的几种方式</a></p><h2 id="（三）进程的通信方式有哪些？"><a href="#（三）进程的通信方式有哪些？" class="headerlink" title="（三）进程的通信方式有哪些？"></a>（三）进程的通信方式有哪些？</h2><p>主要分为：管道（普通管道PIPE 、流管道（s_pipe）、命名管道（name_pipe））、系统IPC（包括消息队列、信号量、共享存储）、套接字（SOCKET）</p><h3 id="1-管道"><a href="#1-管道" class="headerlink" title="1.管道"></a>1.管道</h3><p><strong><em>普通管道PIPE</em></strong></p><p>管道是通过调用匹配pipe函数创建的，fd[0]用于读，fd[1]用于写。</p><pre><code>#include&lt;unistd.h&gt;int pipe(int fd[2]);</code></pre><p>管道具有以下限制：</p><p>  （1）只支持半双工通信（单向交替传输）</p><p>  （2）只能在父子进程中使用（只能在具有亲缘关系的进程间流动，进程的亲缘关系通常是父子进程）</p><p><strong><em>命名管道FIFO</em></strong></p><p>  也是半双工的通信方式，它去除了管道只能在父子进程中使用的限制，允许无亲缘关系的进程间进行通信</p><pre><code>#include&lt;sys/stat.h&gt;int mkfifo(const char *path, mode_t mode);int mkfifoat(int fd,const char *path,mode_t mode);</code></pre><p>FIFO常用于客户-服务器应用程序中，FIFO用作汇聚点，在客户进程和服务器进程之间传递数据。</p><h3 id="2-系统IPC"><a href="#2-系统IPC" class="headerlink" title="2.系统IPC"></a>2.系统IPC</h3><p><strong><em>消息队列</em></strong></p><p>是消息的链表，存放在内核中并由消息队列标识符标识。<br>相比于FIFO，消息队列有以下优点：</p><p>  （1）消息队列能够独立于读写进程的存在，从而避免了FIFO中同步管道的打开和关闭时可能产生的困难。</p><p>  （2）避免了FIFO的同步阻塞问题，不需要进程自己提供同步方法。</p><p>  （3）读进程可以根据消息类型有选择地接受消息，而不像FIFO那样只能默认地接收。</p><p><strong><em>信号量</em></strong></p><p>是一个计数器,用于为多个进程提供共享对象的访问。</p><p><strong><em>信号</em></strong></p><p>是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p><p><strong><em>共享内存</em></strong></p><p>允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种IPC。</p><p>需要使用信号量用来同步对共享存储的访问。</p><p>多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外XSL共享内存不是使用文件，而是使用内存的匿名段。</p><h3 id="3-套接字"><a href="#3-套接字" class="headerlink" title="3.套接字"></a>3.套接字</h3><p>与其它通信机制不同的是，它可用于不同机器间的进程通信。</p><p>如果你对进程的通信方式不太熟悉，建议阅读： <a href="https://blog.csdn.net/yufaw/article/details/7409596" target="_blank" rel="noopener">进程间的几种通信方式</a></p><h2 id="（四）什么是缓冲区溢出？有什么危害？其原因是什么？"><a href="#（四）什么是缓冲区溢出？有什么危害？其原因是什么？" class="headerlink" title="（四）什么是缓冲区溢出？有什么危害？其原因是什么？"></a>（四）什么是缓冲区溢出？有什么危害？其原因是什么？</h2><p>缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。</p><p>危害有以下两点：</p><p>程序崩溃，导致拒绝额服务<br>跳转并且执行一段恶意代码<br>造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入。</p><p>如果你想深入了解缓冲区溢出，推荐阅读：<a href="http://www.cnblogs.com/fanzhidongyzby/archive/2013/08/10/3250405.html" target="_blank" rel="noopener">缓冲区溢出攻击</a></p><h2 id="（五）什么是死锁？死锁产生的条件？"><a href="#（五）什么是死锁？死锁产生的条件？" class="headerlink" title="（五）什么是死锁？死锁产生的条件？"></a>（五）什么是死锁？死锁产生的条件？</h2><p>在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。</p><p>通俗的讲就是两个或多个进程无限期的阻塞、相互等待的一种状态。</p><p><strong><em>死锁产生的四个条件</em></strong>（有一个条件不成立，则不会产生死锁）</p><p><strong><em>互斥</em></strong>：一个资源一次只能被一个进程使用,每个资源要么已经分配给了一个进程，要么就是可用的。</p><p><strong><em>请求与保持</em></strong>(也叫作占有和等待)：一个进程因请求资源而阻塞时，对已获得资源保持不放</p><p><strong><em>不可剥夺</em></strong>（不可抢占）：进程获得的资源，在未完全使用完之前，不能强行剥夺，其只能被占有它的资源显式地释放。</p><p><strong><em>循环等待</em></strong>（环路等待）：若干进程之间形成一种头尾相接的环形等待资源关系</p><p><strong><em>四种解锁方法</em></strong></p><p><strong><em>鸵鸟策略</em></strong>假装问题根本没发生，因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。<br>当发生死锁时不会对用户造成多大的影响，或发生概率很低时可采用鸵鸟策略。<br>Unix，Linux和Windows等多数操作系统处理死锁的方法就是忽略它。</p><p><strong><em>死锁检测与死锁恢复</em></strong><br><img src="lock.png" alt=""></p><p><strong><em>死锁预防</em></strong></p><p><strong><em>死锁避免</em></strong></p><p>如果对死锁还不是太熟悉，建议阅读：<a href="http://www.cnblogs.com/Jessy/p/3540724.html" target="_blank" rel="noopener">死锁产生的原因和解锁的方法</a></p><h2 id="（六）进程有哪几种状态？"><a href="#（六）进程有哪几种状态？" class="headerlink" title="（六）进程有哪几种状态？"></a>（六）进程有哪几种状态？</h2><p>就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源<br>运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数<br>阻塞状态： 进程等待某种条件，在条件满足之前无法执行<br>如果你对进程的几种状态以及中间的装换不太了解，建议阅读：<a href="http://www.cnblogs.com/Jessy/p/3540724.html" target="_blank" rel="noopener">进程的三种状态及转换</a></p><h2 id="（七）分页和分段有什么区别？"><a href="#（七）分页和分段有什么区别？" class="headerlink" title="（七）分页和分段有什么区别？"></a>（七）分页和分段有什么区别？</h2><p>段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 ；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的。<br>段的大小不固定，有它所完成的功能决定；页大大小固定，由系统决定<br>段向用户提供二维地址空间；页向用户提供的是一维地址空间<br>段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。<br>如果你对分页和分段还不太了解，建议阅读：<a href="https://blog.csdn.net/wangrunmin/article/details/7967293" target="_blank" rel="noopener">分段和分页</a></p><h2 id="（八）-操作系统中进程调度策略有哪几种？"><a href="#（八）-操作系统中进程调度策略有哪几种？" class="headerlink" title="（八） 操作系统中进程调度策略有哪几种？"></a>（八） 操作系统中进程调度策略有哪几种？</h2><p>FCFS(先来先服务)，优先级，时间片轮转，多级反馈</p><p>如果你想深入的了解这几种调度策略，推荐阅读：<a href="https://blog.csdn.net/luyafei_89430/article/details/12971171" target="_blank" rel="noopener">几个常用的操作系统进程调度算法</a></p><h2 id="（九）说一说进程同步有哪几种机制。"><a href="#（九）说一说进程同步有哪几种机制。" class="headerlink" title="（九）说一说进程同步有哪几种机制。"></a>（九）说一说进程同步有哪几种机制。</h2><p>原子操作、信号量机制、自旋锁管程、会合、分布式系统</p><p>如果你想深入的了解这几种机制，推荐阅读： <a href="http://www.cnblogs.com/sonic4x/archive/2011/07/05/2098036.html" target="_blank" rel="noopener">进程同步的几种机制</a></p><h2 id="（十）说一说死锁的处理基本策略和常用方法。"><a href="#（十）说一说死锁的处理基本策略和常用方法。" class="headerlink" title="（十）说一说死锁的处理基本策略和常用方法。"></a>（十）说一说死锁的处理基本策略和常用方法。</h2><p>解决死锁的基本方法如下：</p><p>预防死锁、避免死锁、检测死锁、解除死锁</p><p>解决四多的常用策略如下：</p><p>鸵鸟策略、预防策略、避免策略、检测与解除死锁<br>如果你对死锁的处理策略不是太熟悉，推荐阅读：<a href="https://blog.csdn.net/bxyill/article/details/8237339" target="_blank" rel="noopener">产生死锁的原因和必要条件+解决死锁的基本方法</a></p><h2 id="（十一）进程通信和进程同步的区别"><a href="#（十一）进程通信和进程同步的区别" class="headerlink" title="（十一）进程通信和进程同步的区别"></a>（十一）进程通信和进程同步的区别</h2><p>进程通信是一种手段，是在进程间传输信息<br>进程同步是一种目的，是控制多个进程按照一定的顺序执行<br>为了达到进程同步的目的，需要让进程进行通信，传输进程同步所需的信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结操作系统基础概念&lt;/p&gt;
    
    </summary>
    
      <category term="2019年6月" scheme="http://yoursite.com/categories/2019%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Operating System" scheme="http://yoursite.com/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客多终端更新问题</title>
    <link href="http://yoursite.com/2019/05/28/Hexo%E5%8D%9A%E5%AE%A2%E5%A4%9A%E7%BB%88%E7%AB%AF%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/05/28/Hexo博客多终端更新问题/</id>
    <published>2019-05-28T11:19:45.000Z</published>
    <updated>2019-07-18T04:07:43.663Z</updated>
    
    <content type="html"><![CDATA[<p>记录Hexo博客多终端备份更新问题的解决方案</p><a id="more"></a><h2 id="问题介绍"><a href="#问题介绍" class="headerlink" title="问题介绍"></a>问题介绍</h2><p>很多人会把Hexo生成出来的静态网站放到GitHub Pages来进行托管。一般发布Hexo博客的流程是，首先在本地搭建Hexo的环境，编写新文章，然后利用hexo deploy来发布到Git。那么对于本地的Hexo的原始文件怎么管理呢？如果换电脑了怎么办？如果没有对原始文件进行备份，突然有一天你的本地环境挂了导致源文件丢失，那就很悲催了。可以用Dropbox或者其他方案来对源文件进行备份，但是每次更新完博客，需要备份好源文件，然后执行hexo deploy进行发布，非常麻烦。这就是写博客常遇到的多终端备份和更新问题。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>目前找到的解决方法有两种：</p><h3 id="1-持续集成"><a href="#1-持续集成" class="headerlink" title="1.持续集成"></a>1.持续集成</h3><p>用两个GitHub Repo，一个Repo放Hexo的源文件（这里称之为Source Repo），另一个Repo放Hexo生成出来的静态网站（这里称之为Content Repo），然后使用AppVeyor做持续集成。每当需要更新博客，只需要更新Source Repo，AppVeyor会自动生成静态网站并push到Content Repo，一气呵成，版本控制完全由GitHub完成，也不需要手动deploy。参见（<a href="https://formulahendry.github.io/2016/12/04/hexo-ci/）。" target="_blank" rel="noopener">https://formulahendry.github.io/2016/12/04/hexo-ci/）。</a><br>但是这种方法比较麻烦，AppVeyor的注册和使用都很不顺畅。所以我推荐下面的方法。</p><h3 id="2-git分支进行多终端工作"><a href="#2-git分支进行多终端工作" class="headerlink" title="2.git分支进行多终端工作"></a>2.git分支进行多终端工作</h3><p>这种方法是利用git的分支进行多终端工作，可以参见（<a href="http://fangzh.top）" target="_blank" rel="noopener">http://fangzh.top）</a><br>每次打开不一样的电脑，只需要进行简单的配置和在github上把文件同步下来，可以无缝操作。而且这种方法对新手比较友好。</p><h3 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h3><p>由于hexo d上传部署到github的其实是hexo编译后的文件，是用来生成网页的，不包含源文件。也就是上传的是在本地目录里自动生成的.deploy_git里面。其他文件 ，包括我们写在source 里面的，和配置文件，主题文件，都没有上传到github<br>所以可以利用git的分支管理，将源文件上传到github的另一个分支即可。</p><h3 id="上传分支"><a href="#上传分支" class="headerlink" title="上传分支"></a>上传分支</h3><p>首先，先在github上新建一个hexo分支，然后在这个仓库的settings中，选择默认分支为hexo分支（这样每次同步的时候就不用指定分支，比较方便）。<br>然后在本地的任意目录下，打开git bash，</p><pre><code>git clone git@github.com:liyiye012/liyiye012.github.io.git</code></pre><p>将其克隆到本地，因为默认分支已经设成了hexo，所以clone时只clone了hexo。接下来在克隆到本地的liyiye012.github.io中，把除了.git 文件夹外的所有文件都删掉 把之前我们写的博客源文件全部复制过来，除了.deploy_git。<br>这里应该说一句，复制过来的源文件应该有一个.gitignore，用来忽略一些不需要的文件，如果没有的话，自己新建一个，在里面写上如下，表示这些类型文件不需要git：.DS_Store</p><pre><code>Thumbs.dbdb.json*.lognode_modules/public/.deploy*/</code></pre><p>注意，如果之前克隆过theme中的主题文件，那么应该把主题文件中的.git文件夹删掉，因为git不能嵌套上传，最好是显示隐藏文件，检查一下有没有，否则上传的时候会出错，导致你的主题文件无法上传，这样你的配置在别的电脑上就用不了了。而后</p><pre><code>git add .git commit –m &quot;add branch&quot;git push</code></pre><p>这样就上传完了，可以去github上看一看hexo分支有没有上传上去，其中node_modules、public、db.json已经被忽略掉了，没有关系，不需要上传的，因为在别的电脑上需要重新输入命令安装 。</p><p>这样就上传完了。</p><h3 id="更换电脑操作"><a href="#更换电脑操作" class="headerlink" title="更换电脑操作"></a>更换电脑操作</h3><p>跟之前的环境搭建一样，安装git</p><pre><code>sudo apt-get install git</code></pre><p>设置git全局邮箱和用户名</p><pre><code>git config --global user.name &quot;yourgithubname&quot;git config --global user.email &quot;yourgithubemail&quot;</code></pre><p>设置ssh key</p><pre><code>ssh-keygen -t rsa -C &quot;youremail&quot;#生成后填到github和coding上（有coding平台的话）#验证是否成功ssh -T git@github.comssh -T git@git.coding.net #(有coding平台的话)</code></pre><p>安装nodejs</p><pre><code>sudo apt-get install nodejssudo apt-get install npm</code></pre><p>安装hexo  </p><pre><code>sudo npm install hexo-cli -g</code></pre><p>但是已经不需要初始化了，直接在任意文件夹下，git clone git@………………<br>然后进入克隆到的文件夹：cd xxx.github.io</p><pre><code>npm installnpm install hexo-deployer-git --save</code></pre><p>生成，部署：</p><pre><code>hexo ghexo d</code></pre><p>然后就可以愉快的开始写新博客了</p><pre><code>hexo new newpage</code></pre><p>Tips:不要忘了，每次写完最好都把源文件上传一下</p><pre><code>git add .git commit –m &quot;xxxx&quot;git push</code></pre><p>如果是在已经编辑过的电脑上，已经有clone文件夹了，那么，每次只要和远端同步一下就行了</p><pre><code>git pull</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录Hexo博客多终端备份更新问题的解决方案&lt;/p&gt;
    
    </summary>
    
      <category term="2019年5月" scheme="http://yoursite.com/categories/2019%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow入门-Mnist手写数字识别</title>
    <link href="http://yoursite.com/2018/11/22/TensorFlow%E5%85%A5%E9%97%A8-Mnist%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/"/>
    <id>http://yoursite.com/2018/11/22/TensorFlow入门-Mnist手写数字识别/</id>
    <published>2018-11-22T08:30:34.000Z</published>
    <updated>2019-07-18T04:08:04.114Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下Mnist手写数字识别的练习过程，网上已经有很多类似的教程比如(<a href="https://blog.csdn.net/simple_the_best/article/details/75267863，https://blog.csdn.net/cqrtxwd/article/details/79028264），" target="_blank" rel="noopener">https://blog.csdn.net/simple_the_best/article/details/75267863，https://blog.csdn.net/cqrtxwd/article/details/79028264），</a> 但会有些许问题，所以做修改后整理一下<br>当然最好的入门教程还是TensorFlow中文社区（<a href="http://www.tensorfly.cn" target="_blank" rel="noopener">www.tensorfly.cn</a>)</p><a id="more"></a><h2 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h2><p> 可在<a href="http://yann.lecun.com/exdb/mnist/下载mnist数据集，包含" target="_blank" rel="noopener">http://yann.lecun.com/exdb/mnist/下载mnist数据集，包含</a></p><pre><code>Training set images: train-images-idx3-ubyte.gz (9.9 MB, 解压后 47 MB, 包含 60,000 个样本)Training set labels: train-labels-idx1-ubyte.gz (29 KB, 解压后 60 KB, 包含 60,000 个标签)Test set images: t10k-images-idx3-ubyte.gz (1.6 MB, 解压后 7.8 MB, 包含 10,000 个样本)Test set labels: t10k-labels-idx1-ubyte.gz (5KB, 解压后 10 KB, 包含 10,000 个标签）</code></pre><p>MNIST 数据集来自美国国家标准与技术研究所, National Institute of Standards and Technology (NIST). 训练集 (training set) 由来自 250 个不同人手写的数字构成, 其中 50% 是高中学生, 50% 来自人口普查局 (the Census Bureau) 的工作人员. 测试集(test set) 也是同样比例的手写数字数据.<br>图片是以字节的形式进行存储, 我们需要把它们读取到 NumPy array 中, 以便训练和测试算法,载入数据</p><pre><code>import tensorflow as tffrom tensorflow.examples.tutorials.mnist import input_datamnist=input_data.read_data_sets(&quot;MNIST_data/&quot;,one_hot=True)import osimport structimport numpy as npdef load_mnist(path,kind=&apos;train&apos;):    labels_path=os.path.join(path,&apos;%s-labels-idx1-ubyte&apos;%kind)    images_path=os.path.join(path,&apos;%s-images-idx3-ubyte&apos;%kind)    with open(labels_path,&apos;rb&apos;) as lbpath:        magic,n=struct.unpack(&apos;&gt;II&apos;,lbpath.read(8))        labels=np.fromfile(lbpath,dtype=np.uint8)    with open(images_path,&apos;rb&apos;) as imgpath:        magic,num,rows,cols=struct.unpack(&apos;IIII&apos;,imgpath.read(16))        images=np.fromfile(imgpath,dtype=np.uint8).reshape(len(labels),784)    return images,labels</code></pre><p>load_mnist 函数返回两个数组, 第一个是一个 n x m 维的NumPy array(images), 这里的 n 是样本数(行数), m 是特征数(列数). 训练数据集包含 60,000 个样本, 测试数据集包含 10,000 样本. 在 MNIST 数据集中的每张图片由 28 x 28 个像素点构成, 每个像素点用一个灰度值表示. 在这里, 我们将 28 x 28 的像素展开为一个一维的行向量, 这些行向量就是图片数组里的行(每行 784 个值, 或者说每行就是代表了一张图片). load_mnist 函数返回的第二个数组(labels) 包含了相应的目标变量, 也就是手写数字的类标签(整数 0-9).这里对图片的读取方式做一些解释：</p><pre><code>magic, n = struct.unpack(&apos;&gt;II&apos;, lbpath.read(8))labels = np.fromfile(lbpath, dtype=np.uint8)</code></pre><p>看一下 MNIST 网站上对数据集的介绍:</p><pre><code>TRAINING SET LABEL FILE (train-labels-idx1-ubyte):[offset] [type]          [value]          [description]0000     32 bit integer  0x00000801(2049) magic number (MSB first)0004     32 bit integer  60000            number of items0008     unsigned byte   ??               label0009     unsigned byte   ??               label........xxxx     unsigned byte   ??               labelThe labels values are 0 to 9.</code></pre><p>我们首先读入 magic number, 它是一个文件协议的描述, 也是在我们调用 fromfile 方法将字节读入 NumPy array 之前在文件缓冲中的 item 数(n). 作为参数值传入 struct.unpack 的 &gt;II 有两个部分:</p><blockquote><p>: 这是指大端(用来定义字节是如何存储的); 如果你还不知道什么是大端和小端, Endianness 是一个非常好的解释. (关于大小端, 更多内容可见&lt;&lt;深入理解计算机系统 – 2.1 节信息存储&gt;&gt;)<br>I: 这是指一个无符号整数.</p></blockquote><p>通过执行下面的代码, 我们将会从刚刚解压 MNIST 数据集后的 mnist 目录下加载 60,000 个训练样本和 10,000 个测试样本.</p><h2 id="数据预览"><a href="#数据预览" class="headerlink" title="数据预览"></a>数据预览</h2><p>此时要将文件解压后放在MNIST_data文件夹下，可视化处理. 从 feature matrix 中将 784-像素值 的向量 reshape 为之前的 28*28 的形状, 然后通过 matplotlib 的 imshow 函数进行绘制:</p><pre><code>import matplotlib.pyplot as pltX_train,y_train=load_mnist(&quot;MNIST_data/&quot;,kind=&apos;train&apos;)fig, ax = plt.subplots(    nrows=2,    ncols=5,    sharex=True,    sharey=True, )ax = ax.flatten()for i in range(10):    img = X_train[y_train == i][0].reshape(28, 28)    ax[i].imshow(img, cmap=&apos;Greys&apos;, interpolation=&apos;nearest&apos;)ax[0].set_xticks([])ax[0].set_yticks([])#plt.tight_layout()plt.show()</code></pre><p>可以看到一个 2*5 的图片, 里面分别是 0-9 单个数字的图片.还可以绘制某一数字的多个样本图片, 来看一下这些手写样本到底有多不同:</p><pre><code>fig,ax=plt.subplots(    nrows=5,    ncols=5,    sharex=True,    sharey=True,)ax=ax.flatten()for i in range(25):    img=X_train[y_train==7][i].reshape(28,28)    ax[i].imshow(img,cmap=&apos;Greys&apos;,interpolation=&apos;nearest&apos;)ax[0].set_xticks([])ax[0].set_yticks([])plt.show()</code></pre><p>我们也可以选择将 MNIST 图片数据和标签保存为 CSV 文件, 这样就可以在不支持特殊的字节格式的程序中打开数据集. 但是, 有一点要说明, CSV 的文件格式将会占用更多的磁盘空间, 如下所示:</p><pre><code>train_img.csv: 109.5 MBtrain_labels.csv: 120 KBtest_img.csv: 18.3 MBtest_labels: 20 KB</code></pre><p>如果我们打算保存这些 CSV 文件, 在将 MNIST 数据集加载入 NumPy array 以后, 我们应该执行下列代码:</p><pre><code>np.savetxt(&apos;train_img.csv&apos;, X_train,           fmt=&apos;%i&apos;, delimiter=&apos;,&apos;)np.savetxt(&apos;train_labels.csv&apos;, y_train,           fmt=&apos;%i&apos;, delimiter=&apos;,&apos;)np.savetxt(&apos;test_img.csv&apos;, X_test,           fmt=&apos;%i&apos;, delimiter=&apos;,&apos;)np.savetxt(&apos;test_labels.csv&apos;, y_test,           fmt=&apos;%i&apos;, delimiter=&apos;,&apos;)</code></pre><p>一旦将数据集保存为 CSV 文件, 我们也可以用 NumPy 的 genfromtxt 函数重新将它们加载入程序中:</p><pre><code>X_train = np.genfromtxt(&apos;train_img.csv&apos;,                        dtype=int, delimiter=&apos;,&apos;)y_train = np.genfromtxt(&apos;train_labels.csv&apos;,                        dtype=int, delimiter=&apos;,&apos;)X_test = np.genfromtxt(&apos;test_img.csv&apos;,                       dtype=int, delimiter=&apos;,&apos;)y_test = np.genfromtxt(&apos;test_labels.csv&apos;,                       dtype=int, delimiter=&apos;,&apos;)</code></pre><p>不过, 从 CSV 文件中加载 MNIST 数据将会显著发给更长的时间, 因此如果可能的话, 还是建议维持数据集原有的字节格式.</p><h2 id="神经网络结构"><a href="#神经网络结构" class="headerlink" title="神经网络结构"></a>神经网络结构</h2><p>流程分为三步：<br>1.构建卷积神经网络结构<br>2.构建loss function，配置寻优器<br>3.训练，测试<br>在源码中使用了两个卷积层+池化层，最后接上两个全连接层。<br>第一层卷积使用了32个3x3x1的卷积核，步长为1，边界处理方式为“SAME”（卷积的输入和输出保持相同尺寸），激活函数为ReLu，后接一个2x2的池化层，方式为最大化池化；<br>第二层卷积使用50个3x3x32的卷积核，步长为1，边界处理方式为“SAME”，激活函数为ReLu，后接一个2x2的池化层，方式为最大化池化；<br>第一层全连接层：使用1024个神经元，激活函数为ReLu。<br>第二层全连接层：使用10个神经元，激活函数为Softmax,用于输出结果</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><pre><code>import tensorflow as tffrom tensorflow.examples.tutorials.mnist import input_data#读取数据mnist=input_data.read_data_sets(&apos;MNIST_data/&apos;,one_hot=True)sess=tf.InteractiveSession()#构建卷积神经网络结构#自定义卷积函数def conv2d(x,w):    return tf.nn.conv2d(x,w,strides=[1,1,1,1],padding=&apos;SAME&apos;)#自定义池化函数def max_pool_2x2(x):    return tf.nn.max_pool(x,ksize=[1,2,2,1],strides=[1,2,2,1],padding=&apos;SAME&apos;)#设置占位符，尺寸为样本输入和输出的尺寸x=tf.placeholder(tf.float32,[None,784])y_=tf.placeholder(tf.float32,[None,10])x_img=tf.reshape(x,[-1,28,28,1])#设置第一个卷积层和池化层w_conv1=tf.Variable(tf.truncated_normal([3,3,1,32],stddev=0.1))b_conv1=tf.Variable(tf.constant(0.1,shape=[32]))h_conv1=tf.nn.relu(conv2d(x_img,w_conv1)+b_conv1)h_pool1=max_pool_2x2(h_conv1)#设置第二个卷积层和池化层w_conv2=tf.Variable(tf.truncated_normal([3,3,32,50],stddev=0.1))b_conv2=tf.Variable(tf.constant(0.1,shape=[50]))h_conv2=tf.nn.relu(conv2d(h_pool1,w_conv2)+b_conv2)h_pool2=max_pool_2x2(h_conv2)#设置第一个全连接层w_fc1=tf.Variable(tf.truncated_normal([7*7*50,1024],stddev=0.1))b_fc1=tf.Variable(tf.constant(0.1,shape=[1024]))h_pool2_flat=tf.reshape(h_pool2,[-1,7*7*50])h_fc1=tf.nn.relu(tf.matmul(h_pool2_flat,w_fc1)+b_fc1)#dropout(随机权重失活)keep_prob=tf.placeholder(tf.float32)h_fc1_drop=tf.nn.dropout(h_fc1,keep_prob)#设置第二个全连接层w_fc2=tf.Variable(tf.truncated_normal([1024,10]))b_fc2=tf.Variable(tf.constant(0.1,shape=[10]))y_out=tf.nn.softmax(tf.matmul(h_fc1_drop,w_fc2)+b_fc2)#建立loss function,为交叉熵loss=tf.reduce_mean(-tf.reduce_sum(y_*tf.log(y_out),reduction_indices=[1]))#配置Adam优化器，学习速率为1e-4train_step=tf.train.AdamOptimizer(1e-4).minimize(loss)#建立正确率计算表达式correct_prediction=tf.equal(tf.argmax(y_out,1),tf.argmax(y_,1))accuracy=tf.reduce_mean(tf.cast(correct_prediction,tf.float32))#训练tf.global_variables_initializer().run()for i in range(20000):    batch = mnist.train.next_batch(50)    if i%100==0:        train_accuracy=accuracy.eval(feed_dict={x:batch[0],y_:batch[1],keep_prob:1})        print(&quot;ste %d,train_accuracy=%g&quot; %(i,train_accuracy))    train_step.run(feed_dict={x:batch[0],y_:batch[1],keep_prob:0.5})#训练后用测试集进行测试，输出最终结果print(&quot;test_accuracy= %h&quot; %accuracy.eval(feed_dict={x:mnist.test.images,y_:mnist.test.labels,keep_prob:1}))</code></pre><h2 id="代码详解："><a href="#代码详解：" class="headerlink" title="代码详解："></a>代码详解：</h2><pre><code>#自定义卷积函数def conv2d(x,w):    return tf.nn.conv2d(x,w,strides=[1,1,1,1],padding=&apos;SAME&apos;)#自定义池化函数def max_pool_2x2(x):    return tf.nn.max_pool(x,ksize=[1,2,2,1],strides=[1,2,2,1],padding=&apos;SAME&apos;)</code></pre><p>卷积步长为1，如果要改为步长为2则strides=[1,2,2,1],对于二维图来说只有中间两个是有效的，使用‘SAME’的padding方法（即输出与输入保持相同尺寸，边界处少一两个像素则自动补上）；池化层的设置也类似，池化尺寸为2x2</p><pre><code>#设置占位符，尺寸为样本输入和输出的尺寸x=tf.placeholder(tf.float32,[None,784])y_=tf.placeholder(tf.float32,[None,10])x_img=tf.reshape(x,[-1,28,28,1])</code></pre><p>设置输入输出的占位符，占位符是向一个会话中喂数据的入口，因为在TensorFlow的使用中通过构建计算图来设计网络，而网络的运行计算则在会话中启动，这个过程我们无法直接介入，需要通过placeholder来对一个会话进行数据输入。<br>占位符设置好之后将x变形为28x28是矩阵形式（tf.reshape()函数)</p><pre><code>#设置第一个卷积层和池化层w_conv1=tf.Variable(tf.truncated_normal([3,3,1,32],stddev=0.1))b_conv1=tf.Variable(tf.constant(0.1,shape=[32]))h_conv1=tf.nn.relu(conv2d(x_img,w_conv1)+b_conv1)h_pool1=max_pool_2x2(h_conv1)#设置第二个卷积层和池化层w_conv2=tf.Variable(tf.truncated_normal([3,3,32,50],stddev=0.1))b_conv2=tf.Variable(tf.constant(0.1,shape=[50]))h_conv2=tf.nn.relu(conv2d(h_pool1,w_conv2)+b_conv2)h_pool2=max_pool_2x2(h_conv2)</code></pre><p>第一层卷积使用3x3x1的卷积核，一共有32个卷积核，权值使用方差为0.1的截断正态分布（最大值不超过方差两倍的分布）来初始化，偏置的初值设定为常数0.1。<br>第二层卷积核第一层类似，卷积核尺寸为3x3x32（32是通道数，因为上一层使用32个卷积核，所以这一层的通道数就变成了32），这一层一共使用了50个卷积核，其他设置与上一层相同。<br>每一层卷积完之后接上一个2x2的最大化池化操作</p><pre><code>#设置第一个全连接层w_fc1=tf.Variable(tf.truncated_normal([7*7*50,1024],stddev=0.1))b_fc1=tf.Variable(tf.constant(0.1,shape=[1024]))h_pool2_flat=tf.reshape(h_pool2,[-1,7*7*50])h_fc1=tf.nn.relu(tf.matmul(h_pool2_flat,w_fc1)+b_fc1)#dropout(随机权重失活)keep_prob=tf.placeholder(tf.float32)h_fc1_drop=tf.nn.dropout(h_fc1,keep_prob)#设置第二个全连接层w_fc2=tf.Variable(tf.truncated_normal([1024,10]))b_fc2=tf.Variable(tf.constant(0.1,shape=[10]))y_out=tf.nn.softmax(tf.matmul(h_fc1_drop,w_fc2)+b_fc2)</code></pre><p>卷积层之后就是两个全连接层，第一个全连接层有1024个神经元，现将卷积层得到的2x2输出展开成一长条，使用ReLu激活函数得到输出，输出为1024维。</p><p>Dropout：在这一层使用权值随机失活，对一些神经元突触连接进行强制的置零，这个trick可以防止神经网络过拟合。这里的dropout的保留比例是0.5，即随机的保留一半权值，删除另一半。dropout比例通过placeholder来设置，因为训练过程中需要dropout，但是在最后的测试过程中，我们有希望使用全部的权值，随意dropout的比例要能够改变，这里使用placeholder。</p><p>第二个全连接层有10个神经元，分别对应0-9这19个数字，和之前每层不同，这里使用的激活函数是softmax，softmax是以指数函数作为核函数的归一化操作，与一般归一化操作不同的是，指数函数能够放大一个分布内各个数值的差异，两级分布现象会更明显。</p><pre><code>#建立loss function,为交叉熵loss=tf.reduce_mean(-tf.reduce_sum(y_*tf.log(y_out),reduction_indices=[1]))#配置Adam优化器，学习速率为1e-4train_step=tf.train.AdamOptimizer(1e-4).minimize(loss)#建立正确率计算表达式correct_prediction=tf.equal(tf.argmax(y_out,1),tf.argmax(y_,1))accuracy=tf.reduce_mean(tf.cast(correct_prediction,tf.float32))</code></pre><p>建立loss function很重要，这里使用交叉熵作为loss，交叉熵用来衡量两个分布的相似程度。两个分布越接近，则交叉熵越小。<br>使用Adam优化器来最小化loss，配置学习速率为1e-4，然后建立正确率的计算表达式，tf.argmax(y_,1)函数用来返回其中最大的值的下标，tf.equal用来计算两个值是否相等，tf.cast()函数用来实现数据类型转换，tf.reduce_mean()用来求平均（得到正确率）</p><pre><code>#训练tf.global_variables_initializer().run()for i in range(20000):    batch = mnist.train.next_batch(50)    if i%100==0:        train_accuracy=accuracy.eval(feed_dict={x:batch[0],y_:batch[1],keep_prob:1})        print(&quot;ste %d,train_accuracy=%g&quot; %(i,train_accuracy))    train_step.run(feed_dict={x:batch[0],y_:batch[1],keep_prob:0.5})</code></pre><p>对网络进行训练，首先使用<code>tf.global_variables_initializer().run()</code>初始化所有数据，从mnist训练数据集中集中一次取50个样本作为一组训练，共进行20000组训练，每100次就输出一次该组数据上的正确率，进行训练计算的方式是<code>train_step.run(feed_dict={x:batch[0],y_:batch[1],keep_prob:0.5})</code><br>,通过feed_dict来对会话输送训练数据（以及其他一些想在计算过程中实时调整的参数，比如dropout比例）<br>这段代码中可以看到，训练时dropout的保留比例是0.5，测试时的保留比例是1.</p><pre><code>#训练后用测试集进行测试，输出最终结果print(&quot;test_accuracy= %h&quot; %accuracy.eval(feed_dict={x:mnist.test.images,y_:mnist.test.labels,keep_prob:1}))</code></pre><p>最后输入测试集进行测试验证</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下Mnist手写数字识别的练习过程，网上已经有很多类似的教程比如(&lt;a href=&quot;https://blog.csdn.net/simple_the_best/article/details/75267863，https://blog.csdn.net/cqrtxwd/article/details/79028264），&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/simple_the_best/article/details/75267863，https://blog.csdn.net/cqrtxwd/article/details/79028264），&lt;/a&gt; 但会有些许问题，所以做修改后整理一下&lt;br&gt;当然最好的入门教程还是TensorFlow中文社区（&lt;a href=&quot;http://www.tensorfly.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.tensorfly.cn&lt;/a&gt;)&lt;/p&gt;
    
    </summary>
    
      <category term="2018年11月" scheme="http://yoursite.com/categories/2018%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="TensorFlow" scheme="http://yoursite.com/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>235.Lowest Common Ancestor of a Binary Search Tree 二叉搜索树的最近公共祖先</title>
    <link href="http://yoursite.com/2018/10/30/235.Lowest%20Common%20Ancestor%20of%20a%20Binary%20Search%20Tree%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <id>http://yoursite.com/2018/10/30/235.Lowest Common Ancestor of a Binary Search Tree 二叉搜索树的最近公共祖先/</id>
    <published>2018-10-30T02:13:20.000Z</published>
    <updated>2019-07-18T06:30:25.299Z</updated>
    
    <content type="html"><![CDATA[<p> 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><a id="more"></a><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p><pre><code>     _______6______    /              \ ___2__          ___8__/      \        /      \0      _4       7       9      /  \      3   5</code></pre><p>示例 1:</p><pre><code>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8输出: 6解释: 节点 2 和节点 8 的最近公共祖先是 6。</code></pre><p>示例 2:</p><pre><code>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4输出: 2解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。说明:所有节点的值都是唯一的。p、q 为不同节点且均存在于给定的二叉搜索树中。</code></pre><h2 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h2><pre><code>/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {        if(root.val&gt;p.val &amp;&amp; root.val&gt;q.val){            return lowestCommonAncestor(root.left,p,q);        }        else if(root.val&lt;p.val &amp;&amp; root.val&lt;q.val){            return lowestCommonAncestor(root.right,p,q);        }else return root;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年10月" scheme="http://yoursite.com/categories/2018%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>Permutations全排列问题总结</title>
    <link href="http://yoursite.com/2018/10/11/Permutations%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/10/11/Permutations全排列问题总结/</id>
    <published>2018-10-11T02:33:14.000Z</published>
    <updated>2019-07-18T04:08:00.302Z</updated>
    
    <content type="html"><![CDATA[<p>总结几个常见的全排列问题<br>46.Permutations 全排列<br>47.PermutationsII 全排列II<br>31.Next Permutations 下一个排列<br>60.Permutation Sequence 第k个排列<br>266.Palindrome Permutation 回文排列<br>267.Palindrome PermutationII 回文排列II</p><a id="more"></a><h2 id="46-Permutations-全排列"><a href="#46-Permutations-全排列" class="headerlink" title="46.Permutations 全排列"></a>46.Permutations 全排列</h2><p>给定一个没有重复数字的序列，返回其所有可能的全排列。</p><p>示例:</p><pre><code>输入: [1,2,3]输出:[  [1,2,3],  [1,3,2],  [2,1,3],  [2,3,1],  [3,1,2],  [3,2,1]]</code></pre><h3 id="回溯思路"><a href="#回溯思路" class="headerlink" title="回溯思路"></a>回溯思路</h3><p>回溯的写法，每次交换nums里面的两个数字，经过回溯可以生成所有的排列情况</p><pre><code>class Solution {public:    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) {        vector&lt;vector&lt;int&gt;&gt; result;        permuteRecursive(nums,0,result);        return result;    }    void output(vector&lt;vector&lt;int&gt;&gt; result){        cout&lt;&lt;&quot;start to print&quot;&lt;&lt;endl;        for(int i=0;i&lt;result.size();i++){            for(int j=0;j&lt;result[i].size();j++){                cout&lt;&lt;result[i][j];            }cout&lt;&lt;endl;        }        cout&lt;&lt;&quot;end to print&quot;&lt;&lt;endl;    }    void permuteRecursive(vector&lt;int&gt; &amp;num,int begin,vector&lt;vector&lt;int&gt;&gt; &amp;result){        // cout&lt;&lt;&quot;begin=&quot;&lt;&lt;begin&lt;&lt;endl;        // cout&lt;&lt;&quot;   num=&quot;;        // for(int i=0;i&lt;num.size();i++) cout&lt;&lt;num[i]&lt;&lt;&quot; &quot;;        // cout&lt;&lt;endl;        // output(result);        if(begin&gt;=num.size()){            result.push_back(num);            return ;        }        for(int i=begin;i&lt;num.size();i++){            swap(num[begin],num[i]);            permuteRecursive(num,begin+1,result);            swap(num[begin],num[i]);        }    }};</code></pre><h3 id="DFS思路"><a href="#DFS思路" class="headerlink" title="DFS思路"></a>DFS思路</h3><p>这种方法是CareerCup书上的方法，也挺不错的，这道题是思想是这样的：</p><p>当n=1时，数组中只有一个数a1，其全排列只有一种，即为a1</p><p>当n=2时，数组中此时有a1a2，其全排列有两种，a1a2和a2a1，那么此时我们考虑和上面那种情况的关系，我们发现，其实就是在a1的前后两个位置分别加入了a2</p><p>当n=3时，数组中有a1a2a3，此时全排列有六种，分别为a1a2a3, a1a3a2, a2a1a3, a2a3a1, a3a1a2, 和 a3a2a1。那么根据上面的结论，实际上是在a1a2和a2a1的基础上在不同的位置上加入a3而得到的。</p><p>_ a1 _ a2 _ : a3a1a2, a1a3a2, a1a2a3</p><p>_ a2 _ a1 _ : a3a2a1, a2a3a1, a2a1a3</p><pre><code>class Solution {public:vector&lt;vector&lt;int&gt; &gt; permute(vector&lt;int&gt; &amp;num) {    vector&lt;vector&lt;int&gt; &gt; ans;    dfs(num, ans);    return ans;}void dfs(vector&lt;int&gt; &amp;num, vector&lt;vector&lt;int&gt;&gt; &amp;ans) {    if (num.size() == 1) {        vector&lt;int&gt; tmp(num.begin(), num.end());        ans.push_back(tmp);        return;    }    vector&lt;vector&lt;int&gt; &gt; ans1;    vector&lt;int&gt; num1(num.begin()+1, num.end());    dfs(num1, ans);    for(int i = 0; i &lt; ans.size(); ++i) {        for(int j = 0; j &lt;= ans[i].size(); ++j) {            vector&lt;int&gt; tmp = ans[i];            tmp.insert(tmp.begin()+j, num[0]);            ans1.push_back(tmp);        }    }    ans = ans1;}};</code></pre><h2 id="47-PermutationsII-全排列II"><a href="#47-PermutationsII-全排列II" class="headerlink" title="47.PermutationsII 全排列II"></a>47.PermutationsII 全排列II</h2><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p><p>示例:</p><pre><code>输入: [1,1,2]输出:[  [1,1,2],  [1,2,1],  [2,1,1]]</code></pre><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>  这里我们先考虑一下，它与上题唯一的不同在于：在DFS函数中，做循环遍历时，如果与当前元素相同的一个元素已经被取用过，则要跳过所有值相同的元素。<br>  举个例子：对于序列&lt;1,1,2,3&gt;。在DFS首遍历时，1 作为首元素被加到list中，并进行后续元素的添加；那么，当DFS跑完第一个分支，遍历到1 (第二个)时，这个1 不再作为首元素添加到list中，因为1 作为首元素的情况已经在第一个分支中考虑过了。<br>  为了实现这一剪枝思路，有了如下的解题算法。</p><p>解题算法：</p><p>  1. 先对给定的序列nums进行排序，使得大小相同的元素排在一起。<br>  2. 新建一个used数组，大小与nums相同，用来标记在本次DFS读取中，位置i的元素是否已经被添加到list中了。<br>  3. 根据思路可知，我们选择跳过一个数，当且仅当这个数与前一个数相等，并且前一个数未被添加到list中。</p><pre><code>class Solution {public:    void recursion(vector&lt;int&gt; num, int i, int j, vector&lt;vector&lt;int&gt; &gt; &amp;res) {        if (i == j-1) {            res.push_back(num);            return;        }        for (int k = i; k &lt; j; k++) {            if (i != k &amp;&amp; num[i] == num[k]) continue;            swap(num[i], num[k]);            recursion(num, i+1, j, res);        }    }    vector&lt;vector&lt;int&gt; &gt; permuteUnique(vector&lt;int&gt; &amp;num) {        sort(num.begin(), num.end());        vector&lt;vector&lt;int&gt; &gt;res;        recursion(num, 0, num.size(), res);        return res;    }};</code></pre><h2 id="31-Next-Permutations-下一个排列"><a href="#31-Next-Permutations-下一个排列" class="headerlink" title="31.Next Permutations 下一个排列"></a>31.Next Permutations 下一个排列</h2><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须原地修改，只允许使用额外常数空间。</p><p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。</p><pre><code>1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1</code></pre><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>  这里，先考虑一个序列的最大最小情况。当一个序列为非递减序列时，它必然是该组数的最小的排列数；同理，当一个序列为非递增序列时，它必然是该组数的最大的排列数。  </p><p>  由此，我们可以知道，本题的关键即是求出数组末尾的最长的非递增子序列。<br>  不妨假设在数组nums中，nums[k+1]…nums[n]均满足前一个元素大于等于后一个元素，即这一子序列非递增。<br>  那么，我们要做的，就是把nums[k]与其后序列中稍大于nums[k]的数交换，接着再逆序nums[k+1]…nums[n]即可。</p><pre><code>class Solution {public:    void nextPermutation(vector&lt;int&gt;&amp; nums) {        int n = nums.size(), k, l;        for (k = n - 2; k &gt;= 0; k--) {            if (nums[k] &lt; nums[k + 1]) {                break;            }        }        if (k &lt; 0) {            reverse(nums.begin(), nums.end());        } else {            for (l = n - 1; l &gt; k; l--) {                if (nums[l] &gt; nums[k]) {                    break;                }            }            swap(nums[k], nums[l]);            reverse(nums.begin() + k + 1, nums.end());        }    }};</code></pre><h2 id="60-Permutation-Sequence-第k个排列"><a href="#60-Permutation-Sequence-第k个排列" class="headerlink" title="60.Permutation Sequence 第k个排列"></a>60.Permutation Sequence 第k个排列</h2><p>给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。</p><p>按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：</p><pre><code>&quot;123&quot;&quot;132&quot;&quot;213&quot;&quot;231&quot;&quot;312&quot;&quot;321&quot;</code></pre><p>给定 n 和 k，返回第 k 个排列。</p><p>说明：</p><pre><code>给定 n 的范围是 [1, 9]。给定 k 的范围是[1,  n!]。</code></pre><p>示例 1:</p><pre><code>输入: n = 3, k = 3输出: &quot;213&quot;</code></pre><p>示例 2:</p><pre><code>输入: n = 4, k = 9输出: &quot;2314&quot;</code></pre><h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>  这里我们先考虑一个特殊情况，当n=4时，序列为[1,2,3,4]，有以下几种情况：<br>  “1+(2,3,4)的全排列”<br>  “2+(1,3,4)的全排列”<br>  “3+(1,2,4)的全排列”<br>  “4+(1,2,3)的全排列”<br>  我们已经知道，对于n个数的全排列，有n!种情况。所以，3个数的全排列就有6种情况。<br>  <br>  如果我们这里给定的k为14，那么它将会出现在：<br>    “3+(1,2,4)的全排列”<br>  这一情况中。</p><p>  我们可以程式化地得到这个结果：取k=13(从0开始计数)，(n-1)!=3!=6，k/(n-1)!=2，而3在有序序列[1,2,3,4]中的索引就是2。<br>  同理，我们继续计算，新的k=13%6=1，新的n=3，那么1/(n-1)!=2/2=0。在序列[1,2,4]中，索引0的数是1。那么，此时的字符串为”31”。<br>  继续迭代，新的k=1%2=1，新的n=2，那么k/(n-1)!=1/1=1。在序列[2,4]中，索引为1的数是4。那么，此时的字符串为”314”。最后在串尾添上仅剩的2，可以得到字符串”3142”。<br>  经过验算，此串确实是序列[1,2,3,4]的全排列数中第14大的序列。</p><p>解题算法：</p><p>  1. 创建一个长度为n 的数组array，存放对应下标n的阶乘值。<br>  2. 再新建一个长度为n 的数组nums，初始值为nums[i]=i+1，用来存放待选的字符序列。<br>  3. 将得到的k减1后，开始迭代。迭代的规则是：迭代n次，每次选nums数组中下标为k/(n-1)!的数放在字符串的末尾，新的k=k%(n-1)!，新的n=n-1。<br>  4. 最后，返回得到的字符串。</p><pre><code>class Solution {public:    string getPermutation(int n, int k) {        // initialize a dictionary that stores 1, 2, ..., n. This string will store the permutation.        string dict(n, 0);        iota(dict.begin(), dict.end(), &apos;1&apos;);        // build up a look-up table, which stores (n-1)!, (n-2)!, ..., 1!, 0!        vector&lt;int&gt; fract(n, 1);        for (int idx = n - 3; idx &gt;= 0; --idx) {            fract[idx] = fract[idx + 1] * (n - 1 - idx);        }        // let k be zero base        --k;        // the main part.        string ret(n, 0);        for (int idx = 0; idx &lt; n; ++idx) {            int select = k / fract[idx];            k %= fract[idx];            ret[idx] = dict[select];            dict.erase(next(dict.begin(), select)); // note that it is an O(n) operation        }        return ret;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结几个常见的全排列问题&lt;br&gt;46.Permutations 全排列&lt;br&gt;47.PermutationsII 全排列II&lt;br&gt;31.Next Permutations 下一个排列&lt;br&gt;60.Permutation Sequence 第k个排列&lt;br&gt;266.Palindrome Permutation 回文排列&lt;br&gt;267.Palindrome PermutationII 回文排列II&lt;/p&gt;
    
    </summary>
    
      <category term="2018年10月" scheme="http://yoursite.com/categories/2018%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>84.Largest Rectangle in Histogram柱状图中最大的矩形</title>
    <link href="http://yoursite.com/2018/10/09/84.Largest%20Rectangle%20in%20Histogram%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/"/>
    <id>http://yoursite.com/2018/10/09/84.Largest Rectangle in Histogram柱状图中最大的矩形/</id>
    <published>2018-10-09T02:06:44.000Z</published>
    <updated>2019-07-18T04:03:28.415Z</updated>
    
    <content type="html"><![CDATA[<p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><a id="more"></a><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p>柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。</p><p>阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。</p><p>示例:</p><pre><code>输入: [2,1,5,6,2,3]输出: 10</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>分析寻找的过程，如果要在O(n)的时间内找到最大的面积，则需要记录下来每个高度为N的矩形，其长度最大可以达到多少。这样就分为两种情况，如图中描述的，首先是高度N越来越大，其次是高度N越来越小。</p><p>1.在高度N越来越大时，其上一个数字构成的高度的矩形的最大长度则增加1，例如，2 3，高度为3时，则高度为2的矩形的长度就加1. 2.在高度N越来越小时，其上一个数字构成的高度的矩形的最大长度就不变，例如 4 3，高度为4时，其构成的矩形长度为1，到了3，矩形长度没有递增，而4之前的数字3构成的矩形的长度也加1。</p><p>可以使用一个stack来存储矩形的高度和长度，其中长度会动态的变化。当遇到一个数字大于栈顶数字的时候就压入栈，小于栈顶的数字就弹出栈，在这个动态过程中，更新最大的矩形面积。</p><pre><code>class Solution {public:    int largestRectangleArea(vector&lt;int&gt;&amp; heights) {        heights.push_back(0);        int len=heights.size();        stack&lt;int&gt; stk;        int i=0,maxarea=0;        while(i&lt;len){            if(stk.empty() || heights[i]&gt;=heights[stk.top()]) {                stk.push(i);                i++;            }            else{                int h=stk.top();                stk.pop();                maxarea=max(maxarea,heights[h]*(stk.empty()? i: i-stk.top()-1));            }        }        return maxarea;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年10月" scheme="http://yoursite.com/categories/2018%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>52. N-QueensNII皇后II</title>
    <link href="http://yoursite.com/2018/10/05/52.%20N-QueensIIN%E7%9A%87%E5%90%8EII/"/>
    <id>http://yoursite.com/2018/10/05/52. N-QueensIIN皇后II/</id>
    <published>2018-10-05T11:55:26.000Z</published>
    <updated>2019-07-18T04:03:05.140Z</updated>
    
    <content type="html"><![CDATA[<p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><a id="more"></a><p>给定一个整数 n，返回 n 皇后不同的解决方案的数量。</p><p>示例:</p><p>输入: 4<br>输出: 2<br>解释: 4 皇后问题存在如下两个不同的解法。<br>[<br> [“.Q..”,  // 解法 1<br>  “…Q”,<br>  “Q…”,<br>  “..Q.”],</p><p> [“..Q.”,  // 解法 2<br>  “Q…”,<br>  “…Q”,<br>  “.Q..”]<br>]</p><h2 id="思路-DFS"><a href="#思路-DFS" class="headerlink" title="思路 DFS"></a>思路 DFS</h2><pre><code>def totalNQueens(self, n):    self.res = 0    self.dfs([-1]*n, 0)    return self.resdef dfs(self, nums, index):    if index == len(nums):        self.res += 1        return    for i in xrange(len(nums)):        nums[index] = i        if self.valid(nums, index):            self.dfs(nums, index+1)def valid(self, nums, n):    for i in xrange(n):        if nums[i] == nums[n] or abs(nums[n]-nums[i]) == n-i:            return False    return True</code></pre><h2 id="C-版"><a href="#C-版" class="headerlink" title="C++版"></a>C++版</h2><pre><code>int totalNQueens(int n) {    vector&lt;bool&gt; col(n, true);    vector&lt;bool&gt; anti(2*n-1, true);    vector&lt;bool&gt; main(2*n-1, true);    vector&lt;int&gt; row(n, 0);    int count = 0;    dfs(0, row, col, main, anti, count);    return count;}void dfs(int i, vector&lt;int&gt; &amp;row, vector&lt;bool&gt; &amp;col, vector&lt;bool&gt;&amp; main, vector&lt;bool&gt; &amp;anti, int &amp;count) {        if (i == row.size()) {            count++;            return;        }       for (int j = 0; j &lt; col.size(); j++) {         if (col[j] &amp;&amp; main[i+j] &amp;&amp; anti[i+col.size()-1-j]) {             row[i] = j;             col[j] = main[i+j] = anti[i+col.size()-1-j] = false;             dfs(i+1, row, col, main, anti, count);             col[j] = main[i+j] = anti[i+col.size()-1-j] = true;      }    }</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年10月" scheme="http://yoursite.com/categories/2018%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>51. N-QueensN皇后</title>
    <link href="http://yoursite.com/2018/10/05/51.%20N-QueensN%E7%9A%87%E5%90%8E/"/>
    <id>http://yoursite.com/2018/10/05/51. N-QueensN皇后/</id>
    <published>2018-10-05T11:19:45.000Z</published>
    <updated>2019-07-18T06:32:04.263Z</updated>
    
    <content type="html"><![CDATA[<p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><a id="more"></a><p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p><p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><p>示例:</p><pre><code>输入: 4输出: [ [&quot;.Q..&quot;,  // 解法 1  &quot;...Q&quot;,  &quot;Q...&quot;,  &quot;..Q.&quot;], [&quot;..Q.&quot;,  // 解法 2  &quot;Q...&quot;,  &quot;...Q&quot;,  &quot;.Q..&quot;]]解释: 4 皇后问题存在两个不同的解法。</code></pre><h2 id="思路1-递归"><a href="#思路1-递归" class="headerlink" title="思路1 递归"></a>思路1 递归</h2><p>尝试每个可能存在皇后的位置</p><pre><code>class Solution {private:    vector&lt;vector&lt;string&gt;&gt; res;public:    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) {       vector&lt;string&gt; cur(n,string(n,&apos;.&apos;));        helper(cur,0);        return res;    }    void helper(vector&lt;string&gt; &amp;cur,int row){        if(row==cur.size()){            res.push_back(cur);            return;        }        for(int col=0;col&lt;cur.size();col++)            if(isValid(cur,row,col)){                cur[row][col]=&apos;Q&apos;;                helper(cur,row+1);                cur[row][col]=&apos;.&apos;;            }    }    bool isValid(vector&lt;string&gt; &amp;cur,int row,int col){        for(int i=0;i&lt;row;i++)            if(cur[i][col] == &apos;Q&apos;) return false;        for(int i=row-1,j=col-1;i&gt;=0 &amp;&amp; j&gt;=0;i--,j--)            if(cur[i][j]==&apos;Q&apos;) return false;        for(int i=row-1,j=col+1;i&gt;=0 &amp;&amp; j&lt;cur.size();i--,j++)            if(cur[i][j]==&apos;Q&apos;) return false;        return true;    }};</code></pre><h2 id="思路2：DFS"><a href="#思路2：DFS" class="headerlink" title="思路2：DFS"></a>思路2：DFS</h2><p>queen用来记录皇后的横纵坐标位置，xy_dif用来记录横纵坐标之差，xy_sum用来记录横纵坐标之和，p + q == x + y 时在同一条对角线上， p - q == x - y时在同一条反对角线上</p><pre><code>def solveNQueens(self, n):    def DFS(queens, xy_dif, xy_sum):        p = len(queens)        if p==n:            result.append(queens)            return None        for q in range(n):            if q not in queens and p-q not in xy_dif and p+q not in xy_sum:                DFS(queens+[q], xy_dif+[p-q], xy_sum+[p+q])      result = [] #全局变量    DFS([],[],[])    return [ [&quot;.&quot;*i + &quot;Q&quot; + &quot;.&quot;*(n-i-1) for i in sol] for sol in result]</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年10月" scheme="http://yoursite.com/categories/2018%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>102.Binary Tree Level Order Traversal二叉树的层次遍历</title>
    <link href="http://yoursite.com/2018/10/04/102.Binary%20Tree%20Level%20Order%20Traversal%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%20/"/>
    <id>http://yoursite.com/2018/10/04/102.Binary Tree Level Order Traversal二叉树的层次遍历 /</id>
    <published>2018-10-04T11:14:32.000Z</published>
    <updated>2019-07-18T06:30:49.533Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。</p><a id="more"></a><p>例如:</p><pre><code>给定二叉树: [3,9,20,null,null,15,7],    3   / \  9  20    /  \   15   7</code></pre><p>返回其层次遍历结果：</p><pre><code>[  [3],  [9,20],  [15,7]]</code></pre><h2 id="思路1-递归"><a href="#思路1-递归" class="headerlink" title="思路1:递归"></a>思路1:递归</h2><pre><code>/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {        vector&lt;vector&lt;int&gt;&gt; res;        leveltravel(res,0,root);        return res;    }    void leveltravel(vector&lt;vector&lt;int&gt;&gt; &amp;res,int depth,TreeNode * root){         if(!root) return ;        vector&lt;int&gt; temp;        if(res.size()==depth) res.push_back(temp);        res[depth].push_back(root-&gt;val);        leveltravel(res,depth+1,root-&gt;left);        leveltravel(res,depth+1,root-&gt;right);        return;    }};</code></pre><h2 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h2><p>在做的过程中注意队列的大小会随时变化，因此需要将q.size()保存为一个变量</p><pre><code>/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {        queue&lt;TreeNode *&gt; q;        vector&lt;vector&lt;int&gt;&gt; res;        if(root) {            q.push(root);        }        while(!q.empty()){         vector&lt;int&gt; temp;           int len=q.size();         for(int i=0;i&lt;len;i++){            TreeNode *cur;            cur=q.front();            temp.push_back(cur-&gt;val);            q.pop();             //cout&lt;&lt;&quot;i=&quot;&lt;&lt;i&lt;&lt;&quot;   cur-&gt;val=&quot;&lt;&lt;cur-&gt;val&lt;&lt;endl;            if(cur-&gt;left) q.push(cur-&gt;left);            if(cur-&gt;right) q.push(cur-&gt;right);            }            //cout&lt;&lt;&quot;  *********&quot;&lt;&lt;endl;            res.push_back(temp);        }    return res;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年10月" scheme="http://yoursite.com/categories/2018%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Breadth-first Search" scheme="http://yoursite.com/tags/Breadth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>117.Populating Next Right Pointers in Each NodeII填充同一层的兄弟节点II</title>
    <link href="http://yoursite.com/2018/10/04/117.Populating%20Next%20Right%20Pointers%20in%20Each%20NodeII%E5%A1%AB%E5%85%85%E5%90%8C%E4%B8%80%E5%B1%82%E7%9A%84%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9II/"/>
    <id>http://yoursite.com/2018/10/04/117.Populating Next Right Pointers in Each NodeII填充同一层的兄弟节点II/</id>
    <published>2018-10-04T11:14:32.000Z</published>
    <updated>2019-07-18T06:38:10.650Z</updated>
    
    <content type="html"><![CDATA[<p>填充同一层的兄弟节点II</p><a id="more"></a><p>给定一个二叉树</p><pre><code>struct TreeLinkNode {  TreeLinkNode *left;  TreeLinkNode *right;  TreeLinkNode *next;}</code></pre><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><!-- more --><p>说明:</p><p>你只能使用额外常数空间。<br>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。<br>示例:</p><p>给定二叉树，</p><pre><code>     1   /  \  2    3 / \    \4   5    7</code></pre><p>调用你的函数后，该二叉树变为：</p><pre><code>     1 -&gt; NULL   /  \  2 -&gt; 3 -&gt; NULL / \    \4-&gt; 5 -&gt; 7 -&gt; NULL</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用三个指针，head指向下一层的第一个结点，prev指向下一层的当前结点，cur指向当前层的当前结点，分层遍历，再按照当前结点是否有左结点和右结点分情况讨论，以当前结点有左结点为例，如果prev为空，说明当前层尚未被遍历过，因此初始化head，若非空说明已经被遍历过，上一个被遍历过的结点是prev，因此将prev的next指向当前结点左结点，然后推进一步，将prev置为cur-&gt;left</p><pre><code>/** * Definition for binary tree with next pointer. * struct TreeLinkNode { *  int val; *  TreeLinkNode *left, *right, *next; *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {} * }; */class Solution {public:    void connect(TreeLinkNode *root) {        TreeLinkNode *head = NULL; //head of the next level        TreeLinkNode *prev = NULL; //the leading node on the next level        TreeLinkNode *cur = root;  //current node of current level        while (cur != NULL) {            while (cur != NULL) { //iterate on the current level                //left child                if (cur-&gt;left != NULL) {                    if (prev != NULL) {                        prev-&gt;next = cur-&gt;left;                    } else {                        head = cur-&gt;left;                    }                    prev = cur-&gt;left;                }                //right child                if (cur-&gt;right != NULL) {                    if (prev != NULL) {                        prev-&gt;next = cur-&gt;right;                    } else {                        head = cur-&gt;right;                    }                    prev = cur-&gt;right;                }                //move to next node                cur = cur-&gt;next;            }            //move to next level            cur = head;            head = NULL;            prev = NULL;        }    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;填充同一层的兄弟节点II&lt;/p&gt;
    
    </summary>
    
      <category term="2018年10月" scheme="http://yoursite.com/categories/2018%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>199.Binary Tree Right Side View二叉树的右视图</title>
    <link href="http://yoursite.com/2018/10/04/199.Binary%20Tree%20Right%20Side%20View%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/"/>
    <id>http://yoursite.com/2018/10/04/199.Binary Tree Right Side View二叉树的右视图/</id>
    <published>2018-10-04T11:14:32.000Z</published>
    <updated>2019-07-18T04:04:54.455Z</updated>
    
    <content type="html"><![CDATA[<p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><a id="more"></a><p>示例:</p><pre><code>输入: [1,2,3,null,5,null,4]输出: [1, 3, 4]解释:   1            &lt;--- /   \2     3         &lt;--- \     \  5     4       &lt;---</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用队列层次遍历二叉树，存储每层最右边的结点</p><pre><code>/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public:    vector&lt;int&gt; rightSideView(TreeNode* root) {        vector&lt;int&gt; res;        queue&lt;TreeNode*&gt; q;        if(root) q.push(root);        while(!q.empty()){            int len=q.size();            for(int i=0;i&lt;len;i++){                TreeNode *cur=q.front();                q.pop();                if(i==len-1)res.push_back(cur-&gt;val);                if(cur-&gt;left) q.push(cur-&gt;left);                if(cur-&gt;right) q.push(cur-&gt;right);            }        }        return res;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。&lt;/p&gt;
    
    </summary>
    
      <category term="2018年10月" scheme="http://yoursite.com/categories/2018%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Breadth-first Search" scheme="http://yoursite.com/tags/Breadth-first-Search/"/>
    
      <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>545.Boundary of Binary Tree 二叉树的边界</title>
    <link href="http://yoursite.com/2018/10/04/545.Boundary%20of%20Binary%20Tree%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BE%B9%E7%95%8C/"/>
    <id>http://yoursite.com/2018/10/04/545.Boundary of Binary Tree 二叉树的边界/</id>
    <published>2018-10-04T11:14:32.000Z</published>
    <updated>2019-07-18T06:32:28.992Z</updated>
    
    <content type="html"><![CDATA[<p>Given a binary tree, return the values of its boundary in anti-clockwise direction starting from root. Boundary includes left boundary, leaves, and right boundary in order without duplicate nodes.</p><a id="more"></a><p>Left boundary is defined as the path from root to the left-most node. Right boundary is defined as the path from root to the right-most node. If the root doesn’t have left subtree or right subtree, then the root itself is left boundary or right boundary. Note this definition only applies to the input binary tree, and not applies to any subtrees.</p><p>The left-most node is defined as a leaf node you could reach when you always firstly travel to the left subtree if exists. If not, travel to the right subtree. Repeat until you reach a leaf node.</p><p>The right-most node is also defined by the same way with left and right exchanged.</p><p>Example 1</p><pre><code>Input:  1   \    2   / \  3   4Ouput:[1, 3, 4, 2]</code></pre><p>Explanation:<br>The root doesn’t have left subtree, so the root itself is left boundary.<br>The leaves are node 3 and 4.<br>The right boundary are node 1,2,4. Note the anti-clockwise direction means you should output reversed right boundary.<br>So order them in anti-clockwise without duplicates and we have [1,3,4,2].</p><p>Example 2</p><pre><code>Input:    ____1_____   /          \  2            3 / \          /4   5        6      / \      / \  7   8    9  10  Ouput:[1,2,4,7,8,9,10,6,3]</code></pre><p>Explanation:<br>The left boundary are node 1,2,4. (4 is the left-most node according to definition)<br>The leaves are node 4,7,8,9,10.<br>The right boundary are node 1,3,6,10. (10 is the right-most node).<br>So order them in anti-clockwise without duplicate nodes we have [1,2,4,7,8,9,10,6,3].</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题给了我们一棵二叉树，让我们以逆时针的顺序来输出树的边界，按顺序分别为左边界，叶结点和右边界。题目中给的例子也能让我们很清晰的明白哪些算是边界上的结点。那么最直接的方法就是分别按顺序求出左边界结点，叶结点，和右边界结点。那么如何求的，对于树的操作肯定是用递归最简洁啊，所以我们可以写分别三个递归函数来分别求左边界结点，叶结点，和右边界结点。首先我们先要处理根结点的情况，当根结点没有左右子结点时，其也是一个叶结点，那么我们一开始就将其加入结果res中，那么再计算叶结点的时候又会再加入一次，这样不对。所以我们判断如果根结点至少有一个子结点，我们才提前将其加入结果res中。然后再来看求左边界结点的函数，如果当前结点不存在，或者没有子结点，我们直接返回。否则就把当前结点值加入结果res中，然后看如果左子结点存在，就对其调用递归函数，反之如果左子结点不存在，那么对右子结点调用递归函数。而对于求右边界结点的函数就反过来了，如果右子结点存在，就对其调用递归函数，反之如果右子结点不存在，就对左子结点调用递归函数，注意在调用递归函数之后才将结点值加入结果res，因为我们是需要按逆时针的顺序输出。最后就来看求叶结点的函数，没什么可说的，就是看没有子结点存在了就加入结果res，然后对左右子结点分别调用递归即可，参见代码如下：</p><p>解法一：</p><pre><code>class Solution {public:    vector&lt;int&gt; boundaryOfBinaryTree(TreeNode* root) {        if (!root) return {};        vector&lt;int&gt; res;        if (root-&gt;left || root-&gt;right) res.push_back(root-&gt;val);        leftBoundary(root-&gt;left, res);        leaves(root, res);        rightBoundary(root-&gt;right, res);        return res;    }    void leftBoundary(TreeNode* node, vector&lt;int&gt;&amp; res) {        if (!node || (!node-&gt;left &amp;&amp; !node-&gt;right)) return;        res.push_back(node-&gt;val);        if (!node-&gt;left) leftBoundary(node-&gt;right, res);        else leftBoundary(node-&gt;left, res);    }    void rightBoundary(TreeNode* node, vector&lt;int&gt;&amp; res) {        if (!node || (!node-&gt;left &amp;&amp; !node-&gt;right)) return;        if (!node-&gt;right) rightBoundary(node-&gt;left, res);        else rightBoundary(node-&gt;right, res);        res.push_back(node-&gt;val);    }    void leaves(TreeNode* node, vector&lt;int&gt;&amp; res) {        if (!node) return;        if (!node-&gt;left &amp;&amp; !node-&gt;right) {            res.push_back(node-&gt;val);        }        leaves(node-&gt;left, res);        leaves(node-&gt;right, res);    }};</code></pre><p>下面这种方法把上面三种不同的递归揉合到了一个递归中，并用bool型变量来标记当前是求左边界结点还是求右边界结点，同时还有加入叶结点到结果res中的功能。如果左边界标记为true，那么将结点值加入结果res中，下面就是调用对左右结点调用递归函数了。根据上面的解题思路我们知道，如果是求左边界结点，优先调用左子结点，当左子结点不存在时再调右子结点，而对于求右边界结点，优先调用右子结点，当右子结点不存在时再调用左子结点。综上考虑，在对左子结点调用递归函数时，左边界标识设为leftbd &amp;&amp; node-&gt;left，而对右子结点调用递归的左边界标识设为leftbd &amp;&amp; !node-&gt;left，这样左子结点存在就会被优先调用。而右边界结点的情况就正好相反，调用左子结点的右边界标识为rightbd &amp;&amp; !node-&gt;right, 调用右子结点的右边界标识为 rightbd &amp;&amp; node-&gt;right，这样就保证了右子结点存在就会被优先调用，参见代码如下：</p><p>解法二：</p><pre><code>class Solution {public:    vector&lt;int&gt; boundaryOfBinaryTree(TreeNode* root) {        if (!root) return {};        vector&lt;int&gt; res{root-&gt;val};        helper(root-&gt;left, true, false, res);        helper(root-&gt;right, false, true, res);        return res;    }    void helper(TreeNode* node, bool leftbd, bool rightbd, vector&lt;int&gt;&amp; res) {        if (!node) return;        if (!node-&gt;left &amp;&amp; !node-&gt;right) {            res.push_back(node-&gt;val);            return;        }        if (leftbd) res.push_back(node-&gt;val);        helper(node-&gt;left, leftbd &amp;&amp; node-&gt;left, rightbd &amp;&amp; !node-&gt;right, res);        helper(node-&gt;right, leftbd &amp;&amp; !node-&gt;left, rightbd &amp;&amp; node-&gt;right, res);        if (rightbd) res.push_back(node-&gt;val);    }};</code></pre><p>下面这种解法实际上时解法一的迭代形式，整体思路基本一样，只是没有再用递归的写法，而是均采用while的迭代写法，注意在求右边界结点时迭代写法很难直接写出逆时针的顺序，我们可以先反过来保存，最后再调个顺序即可，参见代码如下：</p><p>解法三：</p><pre><code>class Solution {public:    vector&lt;int&gt; boundaryOfBinaryTree(TreeNode* root) {        if (!root) return {};        vector&lt;int&gt; res, right;        TreeNode *l = root-&gt;left, *r = root-&gt;right, *p = root;        if (root-&gt;left || root-&gt;right) res.push_back(root-&gt;val);        while (l &amp;&amp; (l-&gt;left || l-&gt;right)) {            res.push_back(l-&gt;val);            if (l-&gt;left) l = l-&gt;left;            else l = l-&gt;right;        }        stack&lt;TreeNode*&gt; st;        while (p || !st.empty()) {            if (p) {                st.push(p);                if (!p-&gt;left &amp;&amp; !p-&gt;right) res.push_back(p-&gt;val);                p = p-&gt;left;            } else {                p = st.top(); st.pop();                p = p-&gt;right;            }        }        while (r &amp;&amp; (r-&gt;left || r-&gt;right)) {            right.push_back(r-&gt;val);            if (r-&gt;right) r = r-&gt;right;            else r = r-&gt;left;        }        res.insert(res.end(), right.rbegin(), right.rend());        return res;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given a binary tree, return the values of its boundary in anti-clockwise direction starting from root. Boundary includes left boundary, leaves, and right boundary in order without duplicate nodes.&lt;/p&gt;
    
    </summary>
    
      <category term="2018年10月" scheme="http://yoursite.com/categories/2018%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>116.Populating Next Right Pointers in Each Node填充同一层的兄弟节点</title>
    <link href="http://yoursite.com/2018/10/04/116.Populating%20Next%20Right%20Pointers%20in%20Each%20Node%E5%A1%AB%E5%85%85%E5%90%8C%E4%B8%80%E5%B1%82%E7%9A%84%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9/"/>
    <id>http://yoursite.com/2018/10/04/116.Populating Next Right Pointers in Each Node填充同一层的兄弟节点/</id>
    <published>2018-10-04T11:13:54.000Z</published>
    <updated>2019-07-18T06:38:13.960Z</updated>
    
    <content type="html"><![CDATA[<p>填充同一层的兄弟节点</p><a id="more"></a><p>给定一个二叉树</p><pre><code>struct TreeLinkNode {  TreeLinkNode *left;  TreeLinkNode *right;  TreeLinkNode *next;}</code></pre><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><!-- more --><p>说明:</p><p>你只能使用额外常数空间。<br>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。<br>你可以假设它是一个完美二叉树（即所有叶子节点都在同一层，每个父节点都有两个子节点）。<br>示例:</p><pre><code>给定完美二叉树，     1   /  \  2    3 / \  / \4  5  6  7</code></pre><p>调用你的函数后，该完美二叉树变为：</p><pre><code>     1 -&gt; NULL   /  \  2 -&gt; 3 -&gt; NULL / \  / \4-&gt;5-&gt;6-&gt;7 -&gt; NULL</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用两个指针pre和cur，其中pre标记每一层的起始节点，cur用来遍历该层的节点</p><pre><code>/** * Definition for binary tree with next pointer. * struct TreeLinkNode { *  int val; *  TreeLinkNode *left, *right, *next; *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {} * }; */class Solution {public:    void connect(TreeLinkNode *root) {        if(!root) return;        TreeLinkNode *pre=root;        TreeLinkNode *cur=NULL;        while(pre-&gt;left){            cur=pre;            while(cur){                cur-&gt;left-&gt;next=cur-&gt;right;                if(cur-&gt;next) cur-&gt;right-&gt;next=cur-&gt;next-&gt;left;                cur=cur-&gt;next;            }            pre=pre-&gt;left;        }    }};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;填充同一层的兄弟节点&lt;/p&gt;
    
    </summary>
    
      <category term="2018年10月" scheme="http://yoursite.com/categories/2018%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>操作系统面试高频题</title>
    <link href="http://yoursite.com/2018/09/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%A2%98/"/>
    <id>http://yoursite.com/2018/09/21/操作系统面试高频题/</id>
    <published>2018-09-21T09:12:13.000Z</published>
    <updated>2019-07-18T04:08:33.835Z</updated>
    
    <content type="html"><![CDATA[<p>整理一下互联网公司操作系统面试高频题</p><a id="more"></a><h2 id="（1）-进程与线程的区别和联系"><a href="#（1）-进程与线程的区别和联系" class="headerlink" title="（1） 进程与线程的区别和联系"></a>（1） 进程与线程的区别和联系</h2><p>进程是具有一定功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源调度和分配的一个独立单位。<br>线程是进程的实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。<br>一个进程可以有多个线程，多个线程也可以并发执行<br>如果你对进程或者线程不太熟悉，建议阅读：<a href="https://link.zhihu.com/?target=http%3A//www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="noopener">进程与线程的一个简单解释</a></p><h2 id="（2）-一个进程可以创建多少线程，和什么有关"><a href="#（2）-一个进程可以创建多少线程，和什么有关" class="headerlink" title="（2） 一个进程可以创建多少线程，和什么有关"></a>（2） 一个进程可以创建多少线程，和什么有关</h2><h2 id="（3）-一个程序从开始运行到结束的完整过程（四个过程）"><a href="#（3）-一个程序从开始运行到结束的完整过程（四个过程）" class="headerlink" title="（3） 一个程序从开始运行到结束的完整过程（四个过程）"></a>（3） 一个程序从开始运行到结束的完整过程（四个过程）</h2><p>源程序到可执行程序的过程。在这个过程中，会发生如下的变化：</p><p>.c文件生成.obj文件的过程，称为编译，.obj文件生成到.exe文件的过程，称为链接。<br>.obj文件就是一个是程序编译生成的二进制文件，当.exe文件生成以后.obj文件就会被删除。<br>事实上，.c文件生成.exe文件的过程总共是经历了预处理，编译，汇编，链接，这四个过程。</p><p>1、预处理<br>为了接下来能够解释的更加清楚，使用linux平台下的gcc编译器解释。<br>先书写一个非常简单的程序来介绍：</p><pre><code>1 #include&lt;stdio.h&gt;23 int main()4 {5     printf(&quot;hello&quot;);67     return 0;8 }</code></pre><p>直接编译得到：</p><p>第一步发生的是预编译，使用-E指令会使程序只进行到预编译指令。经过预编译指令后的会生成一个.i文件。</p><p>在预编译的过程中，主要处理源代码中的预处理指令，引入头文件，去除注释，处理所有的条件编译指令，宏的替换，添加行号，保留所有的编译器指令。</p><p>当进行预编译以后的文件中将不再存在宏，所有的宏都已经被替代。当想要判断宏是否正确或者头文件包含是否正确时，也可以通过预编译来查看。</p><p>2、编译</p><p>在预处理结束后，进行的是编译。编译过程所进行的是对预处理后的文件进行语法分析，词法分析，语义分析，符号汇总，然后生成汇编代码。</p><p>3、汇编</p><p>汇编过程将汇编代码转成二进制文件，二进制文件就可以让机器来读取。每一条汇编语句都会产生一句机器语言。</p><p>在这里最终会生成一个重定位目标文件 .o文件，类似windows下的.obj文件。这里生成的目标文件里面就是二进制文件。另外，在这里会形成符号表，给这些符号会分配虚拟地址。</p><p>4、链接</p><p>由汇编程序生成的目标文件并不能立即就被执行，其中可能还有许多没有解决的问题。例如，某个源文件中的函数可能引用了另一个源文件中定义的某个符号（如变量或者函数调用等）；在程序中可能调用了某个库文件中的函数等等。所有这些问题，都需要经链接程序的处理方能得以解决。链接程序的主要工作就是将有关的目标文件彼此相连接，也即将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体。</p><p>链接分为静态链接和动态链接：</p><p>静态链接：后缀是.a，主要在编译的时候将库文件里面代码搬迁到可执行的文件中；</p><p>动态链接：后缀是.so,主要在执行的时候需要转换到库文件代码执行；</p><p>两种链接的优缺点：</p><p>（1）静态的链接产生的可执行的文件体积比较的大；而动态链接的可执行文件的体积比较小；</p><p>（2）动态的链接的编译的效率比较的高；</p><p>（3）静态链接的可执行的文件执行的效率高</p><p>（4）静态链接的可执行的文件的“布局”比较好一点；</p><h2 id="（4）-进程通信方法（Linux和windows下），线程通信方法（Linux和windows下）"><a href="#（4）-进程通信方法（Linux和windows下），线程通信方法（Linux和windows下）" class="headerlink" title="（4） 进程通信方法（Linux和windows下），线程通信方法（Linux和windows下）"></a>（4） 进程通信方法（Linux和windows下），线程通信方法（Linux和windows下）</h2><p>主要分为：管道、系统IPC（包括消息队列、信号量、共享存储）、SOCKET</p><p>管道主要分为：普通管道PIPE 、流管道（s_pipe）、命名管道（name_pipe）</p><p>管道是一种半双工的通信方式，数据只能单项流动，并且只能在具有亲缘关系的进程间流动，进程的亲缘关系通常是父子进程<br>命名管道也是半双工的通信方式，它允许无亲缘关系的进程间进行通信<br>信号量是一个计数器，用来控制多个进程对资源的访问，它通常作为一种锁机制。<br>消息队列是消息的链表，存放在内核中并由消息队列标识符标识。<br>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。<br>共享内存就是映射一段能被其它进程访问的内存，这段共享内存由一个进程创建，但是多个进程可以访问。<br>如果你对进程的通信方式不太熟悉，建议阅读： <a href="https://blog.csdn.net/yufaw/article/details/7409596" target="_blank" rel="noopener">进程间的几种通信方式</a></p><h2 id="（5）-进程调度方法详细介绍"><a href="#（5）-进程调度方法详细介绍" class="headerlink" title="（5） 进程调度方法详细介绍"></a>（5） 进程调度方法详细介绍</h2><h2 id="（6）-页面置换方法详细介绍"><a href="#（6）-页面置换方法详细介绍" class="headerlink" title="（6） 页面置换方法详细介绍"></a>（6） 页面置换方法详细介绍</h2><h2 id="（7）-能否实现一个LRU算法"><a href="#（7）-能否实现一个LRU算法" class="headerlink" title="（7） 能否实现一个LRU算法"></a>（7） 能否实现一个LRU算法</h2><h2 id="（8）-死锁的必要条件（怎么检测死锁，解决死锁问题）"><a href="#（8）-死锁的必要条件（怎么检测死锁，解决死锁问题）" class="headerlink" title="（8） 死锁的必要条件（怎么检测死锁，解决死锁问题）"></a>（8） 死锁的必要条件（怎么检测死锁，解决死锁问题）</h2><p>在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲就是两个或多个进程无限期的阻塞、相互等待的一种状态。</p><p>死锁产生的四个条件（有一个条件不成立，则不会产生死锁）</p><p>互斥条件：一个资源一次只能被一个进程使用<br>请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放<br>不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺<br>循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系<br>如果对死锁还不是太熟悉，建议阅读：<a href="http://www.cnblogs.com/Jessy/p/3540724.html" target="_blank" rel="noopener">死锁产生的原因和解锁的方法</a></p><h2 id="（9）-哲学家就餐，银行家，读者写者，生产者消费者（怎么加锁解锁，伪代码）"><a href="#（9）-哲学家就餐，银行家，读者写者，生产者消费者（怎么加锁解锁，伪代码）" class="headerlink" title="（9） 哲学家就餐，银行家，读者写者，生产者消费者（怎么加锁解锁，伪代码）"></a>（9） 哲学家就餐，银行家，读者写者，生产者消费者（怎么加锁解锁，伪代码）</h2><h2 id="（10）-海量数据的bitmap使用原理"><a href="#（10）-海量数据的bitmap使用原理" class="headerlink" title="（10） 海量数据的bitmap使用原理"></a>（10） 海量数据的bitmap使用原理</h2><h2 id="（11）-布隆过滤器原理与优点"><a href="#（11）-布隆过滤器原理与优点" class="headerlink" title="（11） 布隆过滤器原理与优点"></a>（11） 布隆过滤器原理与优点</h2><h2 id="（12）-布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题"><a href="#（12）-布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题" class="headerlink" title="（12） 布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题"></a>（12） 布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题</h2><h2 id="（13）-同步IO和异步IO"><a href="#（13）-同步IO和异步IO" class="headerlink" title="（13） 同步IO和异步IO"></a>（13） 同步IO和异步IO</h2><h2 id="（14）-文件读写使用的系统调用"><a href="#（14）-文件读写使用的系统调用" class="headerlink" title="（14） 文件读写使用的系统调用"></a>（14） 文件读写使用的系统调用</h2><h2 id="（15）-线程池的了解、优点、调度处理方式和保护任务队列的方式"><a href="#（15）-线程池的了解、优点、调度处理方式和保护任务队列的方式" class="headerlink" title="（15） 线程池的了解、优点、调度处理方式和保护任务队列的方式"></a>（15） 线程池的了解、优点、调度处理方式和保护任务队列的方式</h2><h2 id="（16）-怎么回收线程"><a href="#（16）-怎么回收线程" class="headerlink" title="（16） 怎么回收线程"></a>（16） 怎么回收线程</h2><h2 id="（17）-僵尸进程问题"><a href="#（17）-僵尸进程问题" class="headerlink" title="（17） 僵尸进程问题"></a>（17） 僵尸进程问题</h2><h2 id="（18）-多线程同步（尤其是如果项目中用到了多线程，很大可能会结合讨论）"><a href="#（18）-多线程同步（尤其是如果项目中用到了多线程，很大可能会结合讨论）" class="headerlink" title="（18） 多线程同步（尤其是如果项目中用到了多线程，很大可能会结合讨论）"></a>（18） 多线程同步（尤其是如果项目中用到了多线程，很大可能会结合讨论）</h2><h2 id="（19）-memcache了解"><a href="#（19）-memcache了解" class="headerlink" title="（19） memcache了解"></a>（19） memcache了解</h2><h2 id="（20）-异常和中断的区别"><a href="#（20）-异常和中断的区别" class="headerlink" title="（20） 异常和中断的区别"></a>（20） 异常和中断的区别</h2><h2 id="（21）-一般情况下在Linux-windows平台下栈空间的大小"><a href="#（21）-一般情况下在Linux-windows平台下栈空间的大小" class="headerlink" title="（21） 一般情况下在Linux/windows平台下栈空间的大小"></a>（21） 一般情况下在Linux/windows平台下栈空间的大小</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整理一下互联网公司操作系统面试高频题&lt;/p&gt;
    
    </summary>
    
      <category term="2018年9月" scheme="http://yoursite.com/categories/2018%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Operating System" scheme="http://yoursite.com/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>数据库面试高频题</title>
    <link href="http://yoursite.com/2018/09/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%A2%98/"/>
    <id>http://yoursite.com/2018/09/21/数据库面试高频题/</id>
    <published>2018-09-21T09:12:13.000Z</published>
    <updated>2019-07-18T04:08:39.062Z</updated>
    
    <content type="html"><![CDATA[<p>整理一下互联网公司数据库面试高频题</p><a id="more"></a><h2 id="（1）-关系型和非关系型数据库的区别（各自优点）"><a href="#（1）-关系型和非关系型数据库的区别（各自优点）" class="headerlink" title="（1） 关系型和非关系型数据库的区别（各自优点）"></a>（1） 关系型和非关系型数据库的区别（各自优点）</h2><p>关系数据库，是建立在关系模型基础上的数据库，关系模型由关系数据结构、关系操作集合、关系完整性约束三部分组成。<br>简单说，关系型数据库是由多张能互相联接的二维行列表格组成的数据库。<br><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1fw5t2txi6oj30z10extdp.jpg" alt="image"></p><h2 id="（2）-常用SQL语句（DDL-DML-DCL-TCL）"><a href="#（2）-常用SQL语句（DDL-DML-DCL-TCL）" class="headerlink" title="（2） 常用SQL语句（DDL,DML,DCL,TCL）"></a>（2） 常用SQL语句（DDL,DML,DCL,TCL）</h2><h2 id="（3）-数据库中join的类型与区别（inner-join-outer-join-cross-join-natural-join-self-join），注意适用场景和sql语句的编写"><a href="#（3）-数据库中join的类型与区别（inner-join-outer-join-cross-join-natural-join-self-join），注意适用场景和sql语句的编写" class="headerlink" title="（3） 数据库中join的类型与区别（inner join, outer join, cross join, natural join, self join），注意适用场景和sql语句的编写"></a>（3） 数据库中join的类型与区别（inner join, outer join, cross join, natural join, self join），注意适用场景和sql语句的编写</h2><h2 id="（4）-数据库的索引类型-数据库索引的作用"><a href="#（4）-数据库的索引类型-数据库索引的作用" class="headerlink" title="（4） 数据库的索引类型,数据库索引的作用"></a>（4） 数据库的索引类型,数据库索引的作用</h2><p>MySQL数据库几个基本的索引类型：普通索引、唯一索引、主键索引、全文索引</p><p>1)    数据库索引好比是一本书前面的目录，能加快数据库的查询速度。索引是对数据库表中一个或多个列（例如，employee 表的姓氏 (lname) 列）的值进行排序的结构。如果想按特定职员的姓来查找他或她，则与在表中搜索所有的行相比，索引有助于更快地获取信息。<br>2)    优点<br>大大加快数据的检索速度; 创建唯一性索引，保证数据库表中每一行数据的唯一性；加速表和表之间的连接; 在使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间。<br>3)    缺点<br>索引需要占用数据表以外的物理存储空间；创建索引和维护索引要花费一定的时间；当对表进行更新操作时，索引需要被重建，这样降低了数据的维护速度。<br>4)    类型<br><strong>唯一索引</strong>——UNIQUE，例如：create unique index stusno on student（sno）；表明此索引的每一个索引值只对应唯一的数据记录，对于单列惟一性索引，这保证单列不包含重复的值。对于多列惟一性索引，保证多个值的组合不重复。<br><strong><br>主键索引</strong>——primary key，数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。   在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。</p><p><strong>聚集索引</strong>（也叫聚簇索引）——cluster，在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引，如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。</p><p>5)    实现方式<br>B+树、散列索引、位图索引</p><p>索引加快数据库的检索速度<br>索引降低了插入、删除、修改等维护任务的速度<br>唯一索引可以确保每一行数据的唯一性<br>通过使用索引，可以在查询的过程中使用优化隐藏器，提高 系统的性能<br>索引需要占物理和数据空间<br>如果你对索引还不太熟悉，建议阅读：<a href="https://kb.cnblogs.com/page/45712/" target="_blank" rel="noopener">漫谈数据库索引</a></p><h2 id="（5）-聚集索引和非聚集索引的区别（叶节点存储内容）"><a href="#（5）-聚集索引和非聚集索引的区别（叶节点存储内容）" class="headerlink" title="（5） 聚集索引和非聚集索引的区别（叶节点存储内容）"></a>（5） 聚集索引和非聚集索引的区别（叶节点存储内容）</h2><p>1)    聚集索引表示表中存储的数据按照索引的顺序存储，检索效率比非聚集索引高，但对数据更新影响较大。非聚集索引表示数据存储在一个地方，索引存储在另一个地方，索引带有指针指向数据的存储位置，非聚集索引检索效率比聚集索引低，但对数据更新影响较小。<br>2)    聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个。聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续</p><h2 id="（6）-唯一性索引和主码索引的区别"><a href="#（6）-唯一性索引和主码索引的区别" class="headerlink" title="（6） 唯一性索引和主码索引的区别"></a>（6） 唯一性索引和主码索引的区别</h2><h2 id="（7）-索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）"><a href="#（7）-索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）" class="headerlink" title="（7） 索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）"></a>（7） 索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）</h2><p>通常,通过索引查询数据比全表扫描要快.但是我们也必须注意到它的代价.</p><p>索引需要空间来存储,也需要定期维护, 每当有记录在表中增减或索引列被修改时,索引本身也会被修改. 这意味着每条记录的INSERT,DELETE,UPDATE将为此多付出4,5 次的磁盘I/O. 因为索引需要额外的存储空间和处理,那些不必要的索引反而会使查询反应时间变慢.使用索引查询不一定能提高查询性能,索引范围查询(INDEX RANGE SCAN)适用于两种情况:</p><p>基于一个范围的检索,一般查询返回结果集小于表中记录数的30%<br>基于非唯一性索引的检索</p><h2 id="（8）-索引的底层实现（B-树，为何不采用红黑树，B树）"><a href="#（8）-索引的底层实现（B-树，为何不采用红黑树，B树）" class="headerlink" title="（8） 索引的底层实现（B+树，为何不采用红黑树，B树）"></a>（8） 索引的底层实现（B+树，为何不采用红黑树，B树）</h2><p>B-Tree和B+Tree</p><p>目前大部分数据库系统及文件系统都采用B-Tree和B+Tree作为索引结构。</p><p>索引<br>索引的目的：提高查询效率<br>原理：通过不断的缩小想要获得数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是我们总是通过同一种查找方式来锁定数据。<br>数据结构：B+树</p><h2 id="（9）-B树和B-树具体实现"><a href="#（9）-B树和B-树具体实现" class="headerlink" title="（9） B树和B+树具体实现"></a>（9） B树和B+树具体实现</h2><p>B 树可以看作是对2-3查找树的一种扩展，即他允许每个节点有M-1个子节点。</p><p>根节点至少有两个子节点<br>每个节点有M-1个key，并且以升序排列<br>位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间<br>其它节点至少有M/2个子节点<br>下图是一个M=4 阶的B树:</p><p>B+树是对B树的一种变形树，它与B树的差异在于：</p><p>有k个子结点的结点必然有k个关键码；<br>非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。<br>树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。<br>如下图，是一个B+树:</p><h2 id="（10）-索引最左前缀问题"><a href="#（10）-索引最左前缀问题" class="headerlink" title="（10） 索引最左前缀问题"></a>（10） 索引最左前缀问题</h2><h2 id="（11）-Mysql的优化（高频，索引优化，性能优化）"><a href="#（11）-Mysql的优化（高频，索引优化，性能优化）" class="headerlink" title="（11） Mysql的优化（高频，索引优化，性能优化）"></a>（11） Mysql的优化（高频，索引优化，性能优化）</h2><h2 id="（12）-数据库引擎介绍，innodb和myisam的特点与区别"><a href="#（12）-数据库引擎介绍，innodb和myisam的特点与区别" class="headerlink" title="（12） 数据库引擎介绍，innodb和myisam的特点与区别"></a>（12） 数据库引擎介绍，innodb和myisam的特点与区别</h2><h2 id="（13）-数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）"><a href="#（13）-数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）" class="headerlink" title="（13） 数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）"></a>（13） 数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）</h2><h2 id="（14）-数据库隔离性设置不同会出现的问题（脏读、不可重复读、丢失修改、幻读）"><a href="#（14）-数据库隔离性设置不同会出现的问题（脏读、不可重复读、丢失修改、幻读）" class="headerlink" title="（14） 数据库隔离性设置不同会出现的问题（脏读、不可重复读、丢失修改、幻读）"></a>（14） 数据库隔离性设置不同会出现的问题（脏读、不可重复读、丢失修改、幻读）</h2><h2 id="（15）-数据库的隔离级别，mysql和Oracle的隔离级别分别是什么"><a href="#（15）-数据库的隔离级别，mysql和Oracle的隔离级别分别是什么" class="headerlink" title="（15） 数据库的隔离级别，mysql和Oracle的隔离级别分别是什么"></a>（15） 数据库的隔离级别，mysql和Oracle的隔离级别分别是什么</h2><h2 id="（16）-数据库连接池的作用"><a href="#（16）-数据库连接池的作用" class="headerlink" title="（16） 数据库连接池的作用"></a>（16） 数据库连接池的作用</h2><h2 id="（17）-Mysql的表空间方式，各自特点"><a href="#（17）-Mysql的表空间方式，各自特点" class="headerlink" title="（17） Mysql的表空间方式，各自特点"></a>（17） Mysql的表空间方式，各自特点</h2><h2 id="（18）-分布式事务"><a href="#（18）-分布式事务" class="headerlink" title="（18） 分布式事务"></a>（18） 分布式事务</h2><p>本地事务数据库断电的这种情况，它是怎么保证数据一致性的呢？我们使用SQL Server来举例，我们知道我们在使用 SQL Server 数据库是由两个文件组成的，一个数据库文件和一个日志文件，通常情况下，日志文件都要比数据库文件大很多。数据库进行任何写入操作的时候都是要先写日志的，同样的道理，我们在执行事务的时候数据库首先会记录下这个事务的redo操作日志，然后才开始真正操作数据库，在操作之前首先会把日志文件写入磁盘，那么当突然断电的时候，即使操作没有完成，在重新启动数据库时候，数据库会根据当前数据的情况进行undo回滚或者是redo前滚，这样就保证了数据的强一致性。</p><h2 id="（19）-数据库的范式"><a href="#（19）-数据库的范式" class="headerlink" title="（19） 数据库的范式"></a>（19） 数据库的范式</h2><p>1)    第一范式，数据库表中的字段都是单一属性的，不可再分；每一个属性都是原子项，不可分割；如果实体中的某个属性有多个值时，必须拆分为不同的属性 通俗解释。1NF是关系模式应具备的最起码的条件，如果数据库设计不能满足第一范式，就不称为关系型数据库。也就是说，只要是关系型数据库，就一定满足第一范式。</p><p>2)    第二范式，数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖，即符合第二范式；如果一个表中某一个字段A的值是由另外一个字段或一组字段B的值来确定的，就称为A函数依赖于B；当某张表中的非主键信息不是由整个主键函数来决定时，即存在依赖于该表中不是主键的部分或者依赖于主键一部分的部分时，通常会违反2NF。</p><p>3)    第三范式，在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合3NF；第三范式规则查找以消除没有直接依赖于第一范式和第二范式形成的表的主键的属性。我们为没有与表的主键关联的所有信息建立了一张新表。每张新表保存了来自源表的信息和它们所依赖的主键；如果某一属性依赖于其他非主键属性，而其他非主键属性又依赖于主键，那么这个属性就是间接依赖于主键，这被称作传递依赖于主属性。 通俗理解：一张表最多只存2层同类型信息 。</p><h2 id="（20）-数据的锁的种类，加锁的方式"><a href="#（20）-数据的锁的种类，加锁的方式" class="headerlink" title="（20） 数据的锁的种类，加锁的方式"></a>（20） 数据的锁的种类，加锁的方式</h2><h2 id="（21）-视图的作用与使用方法（如何删除等）"><a href="#（21）-视图的作用与使用方法（如何删除等）" class="headerlink" title="（21） 视图的作用与使用方法（如何删除等）"></a>（21） 视图的作用与使用方法（如何删除等）</h2><h2 id="（22）-分库分表，主从复制，读写分离。（我不会，也没碰到过）"><a href="#（22）-分库分表，主从复制，读写分离。（我不会，也没碰到过）" class="headerlink" title="（22） 分库分表，主从复制，读写分离。（我不会，也没碰到过）"></a>（22） 分库分表，主从复制，读写分离。（我不会，也没碰到过）</h2><h2 id="（23）-项目中哪里用到了数据库，怎么用的"><a href="#（23）-项目中哪里用到了数据库，怎么用的" class="headerlink" title="（23） 项目中哪里用到了数据库，怎么用的"></a>（23） 项目中哪里用到了数据库，怎么用的</h2><h2 id="（24）-事务是什么"><a href="#（24）-事务是什么" class="headerlink" title="（24） 事务是什么"></a>（24） 事务是什么</h2><p>1)    事务（txn）是一系列在共享数据库上执行的行为，以达到更高层次更复杂逻辑的功能。事务是DBMS中最基础的单位，事务不可分割。</p><p>2)    ACID，是指在可靠数据库管理系统（DBMS）中，事务(transaction)所应该具有的四个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。</p><p>3)    原子性是指事务是一个不可再分割的工作单位，事务中的操作要么都发生，要么都不发生。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p><p>4)    一致性是指事务使得系统从一个一致的状态转换到另一个一致状态。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。</p><p>5)    多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。这指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。</p><p>6)    持久性，意味着在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。即使出现了任何事故比如断电等，事务一旦提交，则持久化保存在数据库中。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整理一下互联网公司数据库面试高频题&lt;/p&gt;
    
    </summary>
    
      <category term="2018年9月" scheme="http://yoursite.com/categories/2018%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Database" scheme="http://yoursite.com/tags/Database/"/>
    
  </entry>
  
</feed>
