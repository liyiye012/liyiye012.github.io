<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-30T16:10:49.197Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>240. 搜索二维矩阵II</title>
    <link href="http://yoursite.com/2020/06/30/240.%20%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5II/"/>
    <id>http://yoursite.com/2020/06/30/240. 搜索二维矩阵II/</id>
    <published>2020-06-30T14:52:12.000Z</published>
    <updated>2020-06-30T16:10:49.197Z</updated>
    
    <content type="html"><![CDATA[<p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。</p><a id="more"></a><p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：</p><p>每行的元素从左到右升序排列。<br>每列的元素从上到下升序排列。<br>示例:</p><pre><code>现有矩阵 matrix 如下：[  [1,   4,  7, 11, 15],  [2,   5,  8, 12, 19],  [3,   6,  9, 16, 22],  [10, 13, 14, 17, 24],  [18, 21, 23, 26, 30]]给定 target = 5，返回 true。给定 target = 20，返回 false。</code></pre><p>这道题出的不好，因为可以用74.搜索二维矩阵题一样的方法从左下角搜索来解决。</p><h1 id="从左下角开始搜索"><a href="#从左下角开始搜索" class="headerlink" title="从左下角开始搜索"></a>从左下角开始搜索</h1><p>因为矩阵的行和列是排序的（分别从左到右和从上到下），所以在查看任何特定值时，我们可以修剪O(m)或O(n)元素。</p><p>算法：</p><p>首先，我们初始化一个指向矩阵左下角的 (row，col) 指针。然后，直到找到目标并返回 true（或者指针指向矩阵维度之外的 (row，col) 为止，我们执行以下操作：</p><p>如果当前指向的值大于目标值，则可以 “向上” 移动一行。 </p><p>否则，如果当前指向的值小于目标值，则可以移动一列。不难理解为什么这样做永远不会删减正确的答案；因为行是从左到右排序的，所以我们知道当前值右侧的每个值都较大。 </p><p>因此，如果当前值已经大于目标值，我们知道它右边的每个值会比较大。也可以对列进行非常类似的论证，因此这种搜索方式将始终在矩阵中找到目标（如果存在）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean searchMatrix(int[][] matrix, int target) &#123;</span><br><span class="line">//        二维数组为空，要检查三个部分:</span><br><span class="line">//        一是数组首地址是否为空</span><br><span class="line">//        二是是否为&#123;&#125;，也就是array.length==0的情况</span><br><span class="line">//        三是&#123;&#123;&#125;&#125;，这时array.length=1，但是array[0].length==0。满足任意一个条件就可以返回false了。</span><br><span class="line">        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return false;</span><br><span class="line">        int row = matrix.length;</span><br><span class="line">        int col = matrix[0].length;</span><br><span class="line">        int rowindex = row - 1;</span><br><span class="line">        int colindex = 0;</span><br><span class="line"></span><br><span class="line">        while (colindex &lt; col &amp;&amp; rowindex &gt;= 0) &#123;</span><br><span class="line">            if (target == matrix[rowindex][colindex]) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else if (target &gt; matrix[rowindex][colindex]) &#123;</span><br><span class="line">                colindex++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                rowindex--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其它方法见<a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/solution/sou-suo-er-wei-ju-zhen-ii-by-leetcode-2/" target="_blank" rel="noopener">^1</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="Divide and Conquer" scheme="http://yoursite.com/tags/Divide-and-Conquer/"/>
    
  </entry>
  
  <entry>
    <title>74. 搜索二维矩阵</title>
    <link href="http://yoursite.com/2020/06/30/74.%20%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/"/>
    <id>http://yoursite.com/2020/06/30/74. 搜索二维矩阵/</id>
    <published>2020-06-30T14:52:12.000Z</published>
    <updated>2020-06-30T16:11:22.253Z</updated>
    
    <content type="html"><![CDATA[<p>编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。</p><a id="more"></a><p>该矩阵具有如下特性：</p><p>每行中的整数从左到右按升序排列。<br>每行的第一个整数大于前一行的最后一个整数。<br>示例 1:</p><pre><code>输入:matrix = [  [1,   3,  5,  7],  [10, 11, 16, 20],  [23, 30, 34, 50]]</code></pre><p>target = 3<br>输出: true<br>示例 2:</p><pre><code>输入:matrix = [  [1,   3,  5,  7],  [10, 11, 16, 20],  [23, 30, 34, 50]]target = 13输出: false</code></pre><h1 id="从左下角开始搜索"><a href="#从左下角开始搜索" class="headerlink" title="从左下角开始搜索"></a>从左下角开始搜索</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean searchMatrix(int[][] matrix, int target) &#123;</span><br><span class="line">//        二维数组为空，要检查三个部分:</span><br><span class="line">//        一是数组首地址是否为空</span><br><span class="line">//        二是是否为&#123;&#125;，也就是array.length==0的情况</span><br><span class="line">//        三是&#123;&#123;&#125;&#125;，这时array.length=1，但是array[0].length==0。满足任意一个条件就可以返回false了。</span><br><span class="line">        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return false;</span><br><span class="line">        int row = matrix.length;</span><br><span class="line">        int col = matrix[0].length;</span><br><span class="line">        int rowindex = row - 1;</span><br><span class="line">        int colindex = 0;</span><br><span class="line"></span><br><span class="line">        while (colindex &lt; col &amp;&amp; rowindex &gt;= 0) &#123;</span><br><span class="line">            if (target == matrix[rowindex][colindex]) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else if (target &gt; matrix[rowindex][colindex]) &#123;</span><br><span class="line">                colindex++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                rowindex--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法：二分查找"><a href="#方法：二分查找" class="headerlink" title="方法：二分查找"></a>方法：二分查找</h1><p><strong>直觉</strong></p><p>注意到输入的 <code>m x n</code> 矩阵可以视为长度为 <code>m x n</code>的有序数组。</p><p> <a href="https://pic.leetcode-cn.com/d9b47b40a4de17b0c56446b0a4935a5042490ea1d92a6f4c529c2aaa0095c189-287711dcb87bd4d4681fa117f792d1baaaa7ce3e2c65d6a4f6439c0cbbb0345e-image.png" target="_blank" rel="noopener">二分查找</a></p><p>由于该 <em>虚</em> 数组的序号可以由下式方便地转化为原矩阵中的行和列 (<em>我们当然不会真的创建一个新数组</em>) ，该有序数组非常适合二分查找。</p><blockquote><p><code>row = idx // n</code> ， <code>col = idx % n</code>。</p></blockquote><p><strong>算法</strong></p><p>这是一个标准二分查找算法 : </p><ul><li><p>初始化左右序号<br><code>left = 0</code> 和 <code>right = m x n - 1</code>。</p></li><li><p>While <code>left &lt; right</code> :</p><ul><li><p>选取虚数组最中间的序号作为中间序号: <code>pivot_idx = (left + right) / 2</code>。</p></li><li><p>该序号对应于原矩阵中的 <code>row = pivot_idx // n</code>行 <code>col = pivot_idx % n</code> 列, 由此可以拿到中间元素<code>pivot_element</code>。该元素将虚数组分为两部分。</p></li><li><p>比较 <code>pivot_element</code> 与 <code>target</code> 以确定在哪一部分进行进一步查找。</p></li></ul></li></ul><p><strong>实现</strong></p><figure class="highlight java"><figcaption><span>[solution1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分查找</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = m * n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> pivotIdx, pivotElement;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">      pivotIdx = (left + right) / <span class="number">2</span>;</span><br><span class="line">      pivotElement = matrix[pivotIdx / n][pivotIdx % n];</span><br><span class="line">      <span class="keyword">if</span> (target == pivotElement) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; pivotElement) right = pivotIdx - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> left = pivotIdx + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[solution1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span><span class="params">(self, matrix: List[List[int]], target: int)</span> -&gt; bool:</span></span><br><span class="line">        m = len(matrix)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        n = len(matrix[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#二分查找</span></span><br><span class="line">        left, right = <span class="number">0</span>, m * n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">                pivot_idx = (left + right) // <span class="number">2</span></span><br><span class="line">                pivot_element = matrix[pivot_idx // n][pivot_idx % n]</span><br><span class="line">                <span class="keyword">if</span> target == pivot_element:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> target &lt; pivot_element:</span><br><span class="line">                        right = pivot_idx - <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        left = pivot_idx + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>[solution1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分查找</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = m * n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> pivotIdx, pivotElement;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">      pivotIdx = (left + right) / <span class="number">2</span>;</span><br><span class="line">      pivotElement = matrix[pivotIdx / n][pivotIdx % n];</span><br><span class="line">      <span class="keyword">if</span> (target == pivotElement) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; pivotElement) right = pivotIdx - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> left = pivotIdx + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 : 由于是标准的二分查找，时间复杂度为O(log(mn)) 。</li><li>空间复杂度 : <em>O(1)</em>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>334. 递增的三元子序列</title>
    <link href="http://yoursite.com/2020/06/30/334.%E9%80%92%E5%A2%9E%E7%9A%84%E4%B8%89%E5%85%83%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2020/06/30/334.递增的三元子序列/</id>
    <published>2020-06-30T12:52:12.000Z</published>
    <updated>2020-06-30T13:09:57.486Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个未排序的数组，判断这个数组中是否存在长度为 3 的递增子序列。</p><a id="more"></a><p>数学表达式如下:</p><p>如果存在这样的 i, j, k,  且满足 0 ≤ i &lt; j &lt; k ≤ n-1，<br>使得 arr[i] &lt; arr[j] &lt; arr[k] ，返回 true ; 否则返回 false 。<br>说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1) 。</p><p>示例 1:</p><pre><code>输入: [1,2,3,4,5]输出: true</code></pre><p>示例 2:</p><pre><code>输入: [5,4,3,2,1]输出: false</code></pre><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ol><li>第一种方法采用了双指针的思想，针对这个题的三元子序列，如果是四元或更高元则不通用。主要思路是维护当前访问数组的最小值和最小值右侧大于最小值的最小的一个。具体步骤顺序遍历数组，首先确定当前已访问的数组的最小值，即如果小于等于min值的话更新min值，如果大于min，判断是否小于等于max值，如果是，更新max值。如果大于max值，则说明有三元子序列。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">increasingTriplet</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE, max = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num &lt;= min)&#123;</span><br><span class="line">                min = num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num &lt;= max)&#123;</span><br><span class="line">                max = num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>第二种方法是动态规划的思想，主要思路是维护和更新以i为结尾的三元子序列的最长递增长度。转移方程为dp[i] = max{dp[i], dp[j] + 1} (0&lt;=j&lt;i).</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">increasingTriplet</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个未排序的数组，判断这个数组中是否存在长度为 3 的递增子序列。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>350. 两个数组的交集II</title>
    <link href="http://yoursite.com/2020/06/29/350.%20%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86II/"/>
    <id>http://yoursite.com/2020/06/29/350. 两个数组的交集II/</id>
    <published>2020-06-29T15:52:12.000Z</published>
    <updated>2020-06-30T13:09:41.642Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个数组，编写一个函数来计算它们的交集。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: nums1 = [1,2,2,1], nums2 = [2,2]输出: [2,2]</code></pre><p>示例 2:</p><pre><code>输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [4,9]</code></pre><p>说明：</p><pre><code>输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。我们可以不考虑输出结果的顺序。</code></pre><p>进阶:</p><pre><code>如果给定的数组已经排好序呢？你将如何优化你的算法？如果 nums1 的大小比 nums2 小很多，哪种方法更优？如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？</code></pre><h1 id="方法一：哈希映射"><a href="#方法一：哈希映射" class="headerlink" title="方法一：哈希映射"></a>方法一：哈希映射</h1><p>前面的问题 <a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/" target="_blank" rel="noopener">349. 两个数组的交集</a>，我们使用 <code>set</code> 来实现线性时间复杂度。在这里，我们需要使用 <code>HashMap</code> 来跟踪每个数字出现的次数。</p><p>我们先在 <code>HashMap</code> 记录一个数组中的存在的数字和对应出现的次数。然后，我们遍历第二个数组，检查数字在 <code>HashMap</code> 中是否存在，如果存在且计数为正，则将该数字添加到答案并减少 <code>HashMap</code> 中的计数。<br> <a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMzUwLzM1MF9hcHByb2FjaDEtdjIucG5n?x-oss-process=image/format,png" target="_blank" rel="noopener">哈希映射</a><br>检查数组的大小并对较小的数组进行哈希映射是一个小细节，当其中一个数组较大时，会减少内存的使用。</p><p><strong>算法：</strong></p><ul><li>如果 <code>nums1</code> 元素个数大于 <code>nums2</code>，则交换数组元素。</li><li>对于 <code>nums1</code> 的每个元素，添加到 <code>HashMap m</code> 中，如果元素已经存在则增加对应的计数。</li><li>初始化 <code>k = 0</code>，记录当前交集元素个数。</li><li>遍历数组 <code>nums2</code>：<ul><li>检查元素在 <code>m</code> 是否存在，若存在且计数为正：<ul><li>将元素拷贝到 <code>nums1[k]</code>，且 <code>k++</code>。</li><li>减少 <code>m</code> 中对应元素的计数。</li></ul></li></ul></li><li>返回 <code>nums1</code> 前 <code>k</code> 个元素。</li></ul><figure class="highlight c++"><figcaption><span>[solution1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersect(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums1.size() &gt; nums2.size()) &#123;</span><br><span class="line">        <span class="keyword">return</span> intersect(nums2, nums1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n : nums1) &#123;</span><br><span class="line">        ++m[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n : nums2) &#123;</span><br><span class="line">        <span class="keyword">auto</span> it = m.find(n);</span><br><span class="line">        <span class="keyword">if</span> (it != end(m) &amp;&amp; --it-&gt;second &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[k++] = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vector</span>(begin(nums1), begin(nums1) + k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums1.length &gt; nums2.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> intersect(nums2, nums1);</span><br><span class="line">    &#125;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : nums1) &#123;</span><br><span class="line">        m.put(n, m.getOrDefault(n, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : nums2) &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = m.getOrDefault(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[k++] = n;</span><br><span class="line">            m.put(n, cnt - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOfRange(nums1, <span class="number">0</span>, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n+m) 。其中 <em>n</em>，<em>m</em> 分别代表了数组的大小。</li><li>空间复杂度：O(min(n,m)) ，我们对较小的数组进行哈希映射使用的空间。</li></ul><h1 id="方法二：排序"><a href="#方法二：排序" class="headerlink" title="方法二：排序"></a>方法二：排序</h1><p>当输入数据是有序的，推荐使用此方法。在这里，我们对两个数组进行排序，并且使用两个指针在一次扫面找出公共的数字。<br> <a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMzUwLzM1MF9hcHByb2FjaDItdjIucG5n?x-oss-process=image/format,png" target="_blank" rel="noopener">排序</a></p><p><strong>算法：</strong></p><ul><li>对数组 <code>nums1</code> 和 <code>nums2</code> 排序。</li><li>初始化指针 <code>i</code>，<code>j</code> 和 <code>k</code> 为 <code>0</code>。</li><li>指针 <code>i</code> 指向 <code>nums1</code>，指针 <code>j</code> 指向 <code>nums2</code>：<ul><li>如果 <code>nums1[i] &lt; nums2[j]</code>，则 <code>i++</code>。 </li><li>如果 <code>nums1[i] &gt; nums2[j]</code>，则 <code>j++</code>。 </li><li>如果 <code>nums1[i] == nums2[j]</code>，将元素拷贝到 <code>nums1[k]</code>，且 <code>i++</code>，<code>j++</code>，<code>k++</code>。</li></ul></li><li>返回数组 <code>nums1</code> 前 <code>k</code> 个元素。</li></ul><figure class="highlight c++"><figcaption><span>[solution2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersect(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">    sort(begin(nums1), end(nums1));</span><br><span class="line">    sort(begin(nums2), end(nums2));</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; nums1.size() &amp;&amp; j &lt; nums2.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[i] &lt; nums2[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums1[k++] = nums1[i++];</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(begin(nums1), begin(nums1) + k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[solution2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    Arrays.sort(nums1);</span><br><span class="line">    Arrays.sort(nums2);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; nums1.length &amp;&amp; j &lt; nums2.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[i] &lt; nums2[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums1[k++] = nums1[i++];</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOfRange(nums1, <span class="number">0</span>, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="public-static-int-copyOfRange-int-original-int-from-int-to"><a href="#public-static-int-copyOfRange-int-original-int-from-int-to" class="headerlink" title="public static int[] copyOfRange(int[] original, int from, int to)"></a>public static int[] copyOfRange(int[] original, int from, int to)</h2><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(nlogn+mlogm 。其中 <em>n</em>，<em>m</em> 分别代表了数组的大小。我们对数组进行了排序然后进行了线性扫描。</li><li>空间复杂度：<em>O(1)</em>，我们忽略存储答案所使用的空间，因为它对算法本身并不重要。</li></ul><h1 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h1><p><strong>算法：</strong></p><p>这类似于方法 2。我们不使用两个指针进行迭代，而是使用内置函数来查找公共元素。在 C++ 中，我们可以使用 <code>set_intersection</code> 来排序数组（或 <code>multisets</code>）。</p><p>在 Java 中的 <code>retainAll</code> 方法并不关心一个元素在另一个集合中出现的次数。这就有点尴尬了，我一开始想到的就是用内置函数但遇到用例<code>[1,2]，[1,2]</code>就错了，怎么写也没弄出来，所以Java此法暂不可行。</p><figure class="highlight c++"><figcaption><span>[solution3-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersect(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">    sort(begin(nums1), end(nums1));</span><br><span class="line">    sort(begin(nums2), end(nums2));</span><br><span class="line">    nums1.erase(set_intersection(begin(nums1), end(nums1), </span><br><span class="line">        begin(nums2), end(nums2), begin(nums1)), end(nums1));</span><br><span class="line">    <span class="keyword">return</span> nums1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时空复杂度：与方法二相同。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个数组，编写一个函数来计算它们的交集。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>349. 两个数组的交集</title>
    <link href="http://yoursite.com/2020/06/29/349.%20%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/"/>
    <id>http://yoursite.com/2020/06/29/349. 两个数组的交集/</id>
    <published>2020-06-29T12:42:12.000Z</published>
    <updated>2020-06-29T15:51:47.249Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个数组，编写一个函数来计算它们的交集。</p><a id="more"></a><p>示例 1：</p><pre><code>输入：nums1 = [1,2,2,1], nums2 = [2,2]输出：[2]</code></pre><p>示例 2：</p><pre><code>输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出：[9,4]</code></pre><p>说明：</p><pre><code>输出结果中的每个元素一定是唯一的。我们可以不考虑输出结果的顺序。</code></pre><h4 id="方法一：两个set"><a href="#方法一：两个set" class="headerlink" title="方法一：两个set"></a>方法一：两个set</h4><p>最直观的方法是迭代并检查第一个数组 <code>nums1</code> 中的每个值是否也存在于 <code>nums2</code> 中。如果存在，则将值添加到输出。这种方法的时间复杂度为 O(n*m)  ，其中 <code>n</code> 和 <code>m</code> 分别为数组 <code>nums1</code> 和 <code>nums2</code> 的长度。 </p><p>为了在线性时间内解决这个问题，我们使用集合 <code>set</code> 这一数据结构，该结构可以提供平均时间复杂度为 <em>O(1)</em> 的 <code>in/contains</code> 操作（用于测试某一元素是否为该集合的成员）。</p><p>本解法先将两个数组都转换为集合，然后迭代较小的集合，检查其中的每个元素是否同样存在于较大的集合中。平均情况下，这种方法的时间复杂度为 <em>O(n+m)</em> 。 </p><p><strong>实现：</strong></p><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_intersection</span><span class="params">(self, set1, set2)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> [x <span class="keyword">for</span> x <span class="keyword">in</span> set1 <span class="keyword">if</span> x <span class="keyword">in</span> set2]</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersection</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span>  </span><br><span class="line">        set1 = set(nums1)</span><br><span class="line">        set2 = set(nums2)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> len(set1) &lt; len(set2):</span><br><span class="line">            <span class="keyword">return</span> self.set_intersection(set1, set2)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.set_intersection(set2, set1)</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] set_intersection(HashSet&lt;Integer&gt; set1, HashSet&lt;Integer&gt; set2) &#123;</span><br><span class="line">    <span class="keyword">int</span> [] output = <span class="keyword">new</span> <span class="keyword">int</span>[set1.size()];</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Integer s : set1)</span><br><span class="line">      <span class="keyword">if</span> (set2.contains(s)) output[idx++] = s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(output, idx);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    HashSet&lt;Integer&gt; set1 = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Integer n : nums1) set1.add(n);</span><br><span class="line">    HashSet&lt;Integer&gt; set2 = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Integer n : nums2) set2.add(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (set1.size() &lt; set2.size()) <span class="keyword">return</span> set_intersection(set1, set2);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> set_intersection(set2, set1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(m+n)*，其中 <code>n</code> 和 <code>m</code> 是数组的长度。将 <code>nums1</code> 转换为集合需要 *O(n)</em> 的时间，类似地，将 <code>nums2</code> 转换为集合需要 <em>O(m)</em> 的时间。而在平均情况下，集合的 <code>in/contains</code> 操作只需要 <em>O(1)</em> 的时间。 </li><li>空间复杂度：<em>O(m+n)</em>，最坏的情况是数组中的所有元素都不同。 </li></ul><h3 id="Arrays-copyOf"><a href="#Arrays-copyOf" class="headerlink" title="Arrays.copyOf()"></a>Arrays.copyOf()</h3><p>original - 要复制的数组 </p><p>newLength - 要返回的副本的长度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*original - 要复制的数组 </span><br><span class="line">*newLength - 要返回的副本的长度</span><br><span class="line">*/</span><br><span class="line">public static int[] copyOf(int[] original, int newLength) &#123;</span><br><span class="line">        int[] copy = new int[newLength];</span><br><span class="line">        System.arraycopy(original, 0, copy, 0,</span><br><span class="line">                         Math.min(original.length, newLength));</span><br><span class="line">        return copy;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="方法二：内置函数"><a href="#方法二：内置函数" class="headerlink" title="方法二：内置函数"></a>方法二：内置函数</h4><p>如果使用内置函数：那么平均情况下，时间复杂度为 <em>O(n+m)</em> ；而最坏的情况下，时间复杂度是O(n*m)  。</p><p>Python 提供了可用于求交集的 <code>&amp;</code> 运算符，而 Java 提供了 <code>retainAll()</code>  函数。</p><p><strong>实现:</strong></p><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersection</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span>  </span><br><span class="line">        set1 = set(nums1)</span><br><span class="line">        set2 = set(nums2)</span><br><span class="line">        <span class="keyword">return</span> list(set2 &amp; set1)</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    HashSet&lt;Integer&gt; set1 = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Integer n : nums1) set1.add(n);</span><br><span class="line">    HashSet&lt;Integer&gt; set2 = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Integer n : nums2) set2.add(n);</span><br><span class="line"></span><br><span class="line">    set1.retainAll(set2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> [] output = <span class="keyword">new</span> <span class="keyword">int</span>[set1.size()];</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s : set1) output[idx++] = s;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：一般情况下是 <em>O(m+n)</em>，最坏情况下是 O(m*n)</li><li>空间复杂度：最坏的情况是 <em>O(m+n)</em>，数组中的所有元素都不同。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个数组，编写一个函数来计算它们的交集。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>384. 打乱数组</title>
    <link href="http://yoursite.com/2020/06/29/384.%20%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2020/06/29/384. 打乱数组/</id>
    <published>2020-06-29T10:02:12.000Z</published>
    <updated>2020-06-29T12:41:22.009Z</updated>
    
    <content type="html"><![CDATA[<p>打乱一个没有重复元素的数组。</p><a id="more"></a><p>示例:</p><pre><code>// 以数字集合 1, 2 和 3 初始化数组。int[] nums = {1,2,3};Solution solution = new Solution(nums);// 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。solution.shuffle();// 重设数组到它的初始状态[1,2,3]。solution.reset();// 随机返回数组[1,2,3]打乱后的结果。solution.shuffle();</code></pre><h1 id="绪章-1"><a href="#绪章-1" class="headerlink" title="绪章^1"></a>绪章<a href="https://leetcode-cn.com/problems/shuffle-an-array/solution/da-luan-shu-zu-by-leetcode/" target="_blank" rel="noopener">^1</a></h1><p>对于洗牌问题，Fisher-Yates 洗牌算法即是通俗解法，同时也是渐进最优的解法。</p><p>在我们开始之前需要了解一些关于随机化的知识 - 下面介绍的两个方法都假设编程语言中提供的伪随机数生成器是足够随机的。我们给出的示例代码也都采用了最简单的方法来得到伪随机数，但为了让数组的每个排列出现的可能性尽可能相等，还是有一些其他东西需要注意的。例如，一个长度为 <em>n</em> 的数组有 <em>n!</em> 个不同的排列组合。因此，为了能将所有的排列在整数空间编码，我们需要lg(n!) 比特，这是默认的伪随机数不能保证的。</p><h1 id="方法一：-暴力-【通过】"><a href="#方法一：-暴力-【通过】" class="headerlink" title="方法一： 暴力 【通过】"></a>方法一： 暴力 【通过】</h1><p><strong>思路</strong></p><p>假设我们把每个数都放在一个 ”帽子“ 里面，然后我们从帽子里面把它们一个个摸出来，摸出来的数按顺序放入数组，这个数组正好就是我们要的洗牌后的数组。</p><p><strong>算法</strong></p><p>暴力算法简单的来说就是把每个数放在一个 ”帽子“ 里面，每次从 ”帽子“ 里面随机摸一个数出来，直到 “帽子” 为空。下面是具体操作，首先我们把数组 <code>array</code> 复制一份给数组 <code>aux</code>，之后每次随机从 <code>aux</code> 中取一个数，为了防止数被重复取出，每次取完就把这个数从 <code>aux</code> 中移除。<code>重置</code> 的实现方式很简单，只需把 <code>array</code> 恢复称最开始的状态就可以了。 </p><p>这个算法的正确性在于，每次 <code>for</code> 循环中，任何一个元素都会以等可能的概率被选中。为了证明这一点，我们可以算出来，一个特定的元素 <em>e</em> 在第 <em>k</em> 轮被选中的概率为</p><p><em>P</em>(<em>e</em> 在第 <em>k</em> 轮被选中) ·  <em>P</em>(<em>e</em> 在前 <em>k</em> 轮不被选中)。</p><p>假设洗牌的数组有 <em>n</em> 个元素，这个概率公式见<a href="https://leetcode-cn.com/problems/shuffle-an-array/solution/da-luan-shu-zu-by-leetcode/" target="_blank" rel="noopener">^1</a></p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] original;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">getArrayCopy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; asList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            asList.add(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> asList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        array = nums;</span><br><span class="line">        original = nums.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reset() &#123;</span><br><span class="line">        array = original;</span><br><span class="line">        original = original.clone();</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] shuffle() &#123;</span><br><span class="line">        List&lt;Integer&gt; aux = getArrayCopy();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> removeIdx = rand.nextInt(aux.size());</span><br><span class="line">            array[i] = aux.get(removeIdx);</span><br><span class="line">            aux.remove(removeIdx);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度： <em>O(n^2)</em><br>乘方时间复杂度来自于 <code>list.remove</code>（<code>list.pop</code>）。每次操作都是线性时间的，总共发生 <em>n</em> 次。</p></li><li><p>空间复杂度： <em>O(n)</em><br>因为需要实现 <code>重置</code> 方法，需要额外的空间把原始数组另存一份，在重置的时候用来恢复原始状态。</p></li></ul><h4 id="方法二：-Fisher-Yates-洗牌算法-【通过】"><a href="#方法二：-Fisher-Yates-洗牌算法-【通过】" class="headerlink" title="方法二： Fisher-Yates 洗牌算法 【通过】"></a>方法二： Fisher-Yates 洗牌算法 【通过】</h4><p><strong>思路</strong></p><p>我们可以用一个简单的技巧来降低之前算法的时间复杂度和空间复杂度，那就是让数组中的元素互相交换，这样就可以避免掉每次迭代中用于修改列表的时间了。</p><p><strong>算法</strong></p><p>Fisher-Yates 洗牌算法跟暴力算法很像。在每次迭代中，生成一个范围在当前下标到数组末尾元素下标之间的随机整数。接下来，将当前元素和随机选出的下标所指的元素互相交换 - 这一步模拟了每次从 “帽子” 里面摸一个元素的过程，其中选取下标范围的依据在于每个被摸出的元素都不可能再被摸出来了。此外还有一个需要注意的细节，当前元素是可以和它本身互相交换的 - 否则生成最后的排列组合的概率就不对了。为了更清楚地理解这一过程，可以看下面这些动画：</p><p>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates1.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates2.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates3.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates4.png" target="_blank" rel="noopener">1000</a></p><p>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates5.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates6.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates7.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates8.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates9.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates10.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates11.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates12.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates13.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates14.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates15.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates16.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates17.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates18.png" target="_blank" rel="noopener">1000</a> </p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] original;</span><br><span class="line"></span><br><span class="line">    Random rand = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">randRange</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rand.nextInt(max - min) + min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swapAt</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        array = nums;</span><br><span class="line">        original = nums.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reset() &#123;</span><br><span class="line">        array = original;</span><br><span class="line">        original = original.clone();</span><br><span class="line">        <span class="keyword">return</span> original;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] shuffle() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            swapAt(i, randRange(i, array.length));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度 ： <em>O(n)</em><br>Fisher-Yates 洗牌算法时间复杂度是线性的，因为算法中生成随机序列，交换两个元素这两种操作都是常数时间复杂度的。</p></li><li><p>空间复杂度： <em>O(n)</em><br>因为要实现 <code>重置</code> 功能，原始数组必须得保存一份，因此空间复杂度并没有优化。</p></li></ul><h2 id="Random-nextInt-方法，随机产生某个范围内的整数"><a href="#Random-nextInt-方法，随机产生某个范围内的整数" class="headerlink" title="Random.nextInt()方法，随机产生某个范围内的整数"></a>Random.nextInt()方法，随机产生某个范围内的整数</h2><pre><code>int nextInt()            //随机返回一个int型整数int nextInt(int num)         //随机返回一个值在[0,num)的int类型的整数,包括0不包括num</code></pre><p>nextInt能接受一个整数作为它所产生的随机整数的上限,下限为零，若要达到非零下限的效果，必须把上限减去下限的结果传给 nextInt( )，然后把下限加入 nextInt( ) 返回的整数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;打乱一个没有重复元素的数组。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>283. 移动零</title>
    <link href="http://yoursite.com/2020/06/29/283.%20%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
    <id>http://yoursite.com/2020/06/29/283. 移动零/</id>
    <published>2020-06-29T09:49:12.000Z</published>
    <updated>2020-06-29T10:00:39.219Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><a id="more"></a><p>示例:</p><pre><code>输入: [0,1,0,3,12]输出: [1,3,12,0,0]</code></pre><p>说明:</p><p>必须在原数组上操作，不能拷贝额外的数组。<br>尽量减少操作次数。</p><p>我首先想到的解法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void moveZeroes(int[] nums) &#123;</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (nums[i] == 0) &#123;</span><br><span class="line">                swap(nums,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void swap(int[] nums, int zeroindex) &#123;</span><br><span class="line">        int i=zeroindex;</span><br><span class="line">        while (i &lt; nums.length) &#123;</span><br><span class="line">            if (nums[i] == 0) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                nums[zeroindex] = nums[i];</span><br><span class="line">                nums[i]=0;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">解答成功:</span><br><span class="line">执行耗时:5 ms,击败了12.67% 的Java用户</span><br><span class="line">内存消耗:40.4 MB,击败了5.62% 的Java用户</span><br></pre></td></tr></table></figure><p>这种方法效率较低，有没有更高效的方法呢？</p><h1 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h1><ol><li>定义一个非零的指针 <code>j=0</code>，循环遍历数组用指针<code>j</code>记录非零值<code>nums[j] = num[i]</code>;</li><li>判断两个指针<code>i</code>与<code>j</code>是否相等，这里两个指针初始值都为0，<code>j</code>指针只有在非零的情况下会<code>j++</code>；</li><li>因此可以判断<code>j</code>指针对应的值都为非零的数据，且保存原有顺序；</li><li>所以，原有数组继续遍历情况下，<code>nums[i]</code>都为0。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void moveZeroes(int[] nums) &#123;</span><br><span class="line">        int j = 0;</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (nums[i] != 0) &#123;</span><br><span class="line">                nums[j] = nums[i];</span><br><span class="line">                if( i != j)&#123;</span><br><span class="line">                    nums[i] = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">            解答成功:</span><br><span class="line">执行耗时:0 ms,击败了100.00% 的Java用户</span><br><span class="line">内存消耗:39.6 MB,击败了5.62% 的Java用户</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>Java之TreeSet类</title>
    <link href="http://yoursite.com/2020/06/29/Java%E4%B9%8BTreeSet%E7%B1%BB/"/>
    <id>http://yoursite.com/2020/06/29/Java之TreeSet类/</id>
    <published>2020-06-29T08:21:12.000Z</published>
    <updated>2020-06-29T09:09:17.746Z</updated>
    
    <content type="html"><![CDATA[<p>java.util.TreeSet 类实现Set接口。</p><a id="more"></a><p>以下是关于TreeSet的要点<a href="http://gitbook.net/java/util/java_util_treeset.html" target="_blank" rel="noopener">^1</a>：</p><ul><li>TreeSet类保证该映射将在升序键顺序，由TreeMap支持。</li><li>该映射是按照自然排序方法该键类，或在集创建时提供的比较器，这将取决于其构造函数中使用排序。</li><li>顺序必须是总为了使树到功能属性。</li></ul><p>这里仅列出几个常用的方法，更多详见<a href="http://gitbook.net/java/util/java_util_treeset.html" target="_blank" rel="noopener">^1</a></p><h1 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h1><h2 id="E-ceiling-E-e-方法"><a href="#E-ceiling-E-e-方法" class="headerlink" title="E ceiling(E e) 方法"></a>E ceiling(E e) 方法</h2><p>用来返回大于或等于给定的元素的最小元素，如果不存在这样的元素返回null。</p><h2 id="E-floor-E-e-方法"><a href="#E-floor-E-e-方法" class="headerlink" title="E floor(E e) 方法"></a>E floor(E e) 方法</h2><p>此方法返回小于或等于给定的元素的最大元素，如果不存在这样的元素返回null。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java.util.TreeSet 类实现Set接口。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="TreeSet" scheme="http://yoursite.com/tags/TreeSet/"/>
    
  </entry>
  
  <entry>
    <title>220. 存在重复元素III</title>
    <link href="http://yoursite.com/2020/06/29/220.%20%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0III/"/>
    <id>http://yoursite.com/2020/06/29/220. 存在重复元素III/</id>
    <published>2020-06-29T06:59:12.000Z</published>
    <updated>2020-06-29T09:31:29.444Z</updated>
    
    <content type="html"><![CDATA[<p>在整数数组 nums 中，是否存在两个下标 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值小于等于 t ，且满足 i 和 j 的差的绝对值也小于等于 ķ 。</p><a id="more"></a><p>如果存在则返回 true，不存在返回 false。</p><p>示例 1:</p><pre><code>输入: nums = [1,2,3,1], k = 3, t = 0输出: true</code></pre><p>示例 2:</p><pre><code>输入: nums = [1,0,1,1], k = 1, t = 2输出: true</code></pre><p>示例 3:</p><pre><code>输入: nums = [1,5,9,1,5,9], k = 2, t = 3输出: false</code></pre><h1 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h1><p>首先想到用HashSet来解决但超时了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            for (int j = nums[i] - t; j &lt;= nums[i] + t; j++) &#123;</span><br><span class="line">                if (set.contains(j)) &#123;</span><br><span class="line">//                    System.out.println(&quot;i=&quot;+i+&quot;, j=&quot;+j);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">            if (set.size() &gt; k) &#123;</span><br><span class="line">                set.remove(nums[i - k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看一下官方题解<a href="https://leetcode-cn.com/problems/contains-duplicate-iii/solution/cun-zai-zhong-fu-yuan-su-iii-by-leetcode/" target="_blank" rel="noopener">^1</a></p><h1 id="二叉搜索树-【通过】"><a href="#二叉搜索树-【通过】" class="headerlink" title="二叉搜索树 【通过】"></a>二叉搜索树 【通过】</h1><p>总结一下该方法引入自平衡二叉搜索树，来保证能在O(logn) 时间内完成 插入，搜索，删除 操作。减少对滑动窗口中符合条件的元素操作所需的时间。</p><p>下面给出整个算法的伪代码：</p><pre><code>初始化一颗空的二叉搜索树 set对于每个元素xx，遍历整个数组    在 set 上查找大于等于xx的最小的数，如果s - x \leq ts−x≤t则返回 true    在 set 上查找小于等于xx的最大的数，如果x - g \leq tx−g≤t则返回 true    在 set 中插入xx    如果树的大小超过了kk, 则移除最早加入树的那个数。返回 false</code></pre><p>我们把大于等于 <em>x</em> 的最小的数 <em>s</em> 当做 <em>x</em> 在 BST 中的后继节点。同样的，我们能把小于等于 <em>x</em> 最大的数 <em>g</em> 当做 <em>x</em> 在 BST 中的前继节点。<em>s</em> 和 <em>g</em> 这两个数是距离 <em>x</em> 最近的数。因此只需要检查它们和 <em>x</em> 的距离就能知道条件二是否满足了。</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="comment">// Find the successor of current element</span></span><br><span class="line">        Integer s = set.ceiling(nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span> &amp;&amp; s &lt;= nums[i] + t) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find the predecessor of current element</span></span><br><span class="line">        Integer g = set.floor(nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (g != <span class="keyword">null</span> &amp;&amp; nums[i] &lt;= g + t) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        set.add(nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (set.size() &gt; k) &#123;</span><br><span class="line">            set.remove(nums[i - k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-ceiling-E-e-方法-2"><a href="#E-ceiling-E-e-方法-2" class="headerlink" title="E ceiling(E e) 方法^2"></a>E ceiling(E e) 方法<a href="http://gitbook.net/java/util/java_util_treeset.html" target="_blank" rel="noopener">^2</a></h2><p>用来返回大于或等于给定的元素的最小元素，如果不存在这样的元素返回null。</p><h2 id="E-floor-E-e-方法"><a href="#E-floor-E-e-方法" class="headerlink" title="E floor(E e) 方法"></a>E floor(E e) 方法</h2><p>此方法返回小于或等于给定的元素的最大元素，如果不存在这样的元素返回null。</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(n log (min(n,k)))<br>我们需要遍历这个 n 长度的数组。对于每次遍历，在 BST 中 搜索，插入 或者 删除 都需要花费 O(logmin(k, n))的时间。</p><p>空间复杂度：O(min(n,k))<br>空间复杂度由 BST 的大小决定，其大小的上限由 k 和 n 共同决定。</p><h2 id="溢出错误"><a href="#溢出错误" class="headerlink" title="溢出错误"></a>溢出错误</h2><p>当数组中的元素非常大的时候，进行数学运算可能造成溢出。所以可以考虑使用支持大数的数据类型，例如 long。</p><p>C++ 中的 std::set，std::set::upper_bound 和 std::set::lower_bound 分别等价于 Java 中的 TreeSet，TreeSet::ceiling 和 TreeSet::floor。Python 标准库不提供自平衡 BST。</p><p>当测试用例为</p><pre><code>[-2147483648,-2147483647]33</code></pre><p>时会溢出，为了解决这个问题，使用long类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) &#123;</span><br><span class="line">        TreeSet&lt;Long&gt; set = new TreeSet&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            // Find the successor of current element</span><br><span class="line">            Long s = set.ceiling((long) nums[i]);</span><br><span class="line">            if (s != null &amp;&amp; s &lt;= (long) nums[i] + t) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Find the predecessor of current element</span><br><span class="line">            Long g = set.floor((long) nums[i]);</span><br><span class="line">            if (g != null &amp;&amp; g &gt;= (long) nums[i] - t) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            set.add((long) nums[i]);</span><br><span class="line">            if (set.size() &gt; k) &#123;</span><br><span class="line">                set.remove((long) nums[i - k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法三-（桶）-【通过】"><a href="#方法三-（桶）-【通过】" class="headerlink" title="方法三 （桶） 【通过】"></a>方法三 （桶） 【通过】</h1><p><strong>思路</strong></p><p>受 <code>桶排序</code> 的启发，我们可以把 <em>桶</em> 当做窗口来实现一个线性复杂度的解法。</p><p><strong>算法</strong></p><p>桶排序是一种把元素分散到不同桶中的排序算法。接着把每个桶再独立地用不同的排序算法进行排序。桶排序的概览如下所示：</p><p>在上面的例子中，我们有 8 个未排序的整数。我们首先来创建五个桶，这五个桶分别包含 <em>[0,9], [10,19], [20, 29], [30, 39], [40, 49]</em> 这几个区间。这 8 个元素中的任何一个元素都在一个桶里面。对于值为 <em>x</em> 的元素来说，它所属桶的标签为 <em>x/w</em>，在这里我们让 <em>w = 10</em>。对于每个桶我们单独用其他排序算法进行排序，最后按照桶的顺序收集所有的元素就可以得到一个有序的数组了。</p><p>回到这个问题，我们尝试去解决的最大的问题在于：</p><blockquote><ol><li>对于给定的元素 <em>x</em>, 在窗口中是否有存在区间 <em>[x-t, x+t]</em> 内的元素？  </li><li>我们能在常量时间内完成以上判断嘛？</li></ol></blockquote><p>我们不妨把把每个元素当做一个人的生日来考虑一下吧。假设你是班上新来的一位学生，你的生日在 <em>三月</em> 的某一天，你想知道班上是否有人生日跟你生日在 <em>t=30</em> 天以内。在这里我们先假设每个月都是<em>30<em>天，很明显，我们只需要检查所有生日在 *二月</em>，<em>三月</em>，*四月</em> 的同学就可以了。</p><p>之所以能这么做的原因在于，我们知道每个人的生日都属于一个桶，我们把这个桶称作月份！每个桶所包含的区间范围都是 <em>t</em>，这能极大的简化我们的问题。很显然，任何不在同一个桶或相邻桶的两个元素之间的距离一定是大于 <em>t</em> 的。</p><p>我们把上面提到的桶的思想应用到这个问题里面来，我们设计一些桶，让他们分别包含区间 <em>…, [0,t], [t+1, 2t+1], …*。我们把桶来当做窗口，于是每次我们只需要检查 *x</em> 所属的那个桶和相邻桶中的元素就可以了。终于，我们可以在常量时间解决在窗口中搜索的问题了。</p><p>还有一件值得注意的事！</p><p>这个问题和桶排序的不同之处在于每次我们的桶里只需要包含最多一个元素就可以了，因为如果任意一个桶中包含了两个元素，那么这也就是意味着这两个元素是 <em>足够接近的</em> 了，这时候我们就直接得到答案了。因此，我们只需使用一个标签为桶序号的散列表就可以了。 </p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Get the ID of the bucket from element value x and bucket width w</span></span><br><span class="line">    <span class="comment">// In Java, `-3 / 5 = 0` and but we need `-3 / 5 = -1`.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getID</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; <span class="number">0</span> ? (x + <span class="number">1</span>) / w - <span class="number">1</span> : x / w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// Key: ID of the bucket   Value: bucket  value</span></span><br><span class="line">        Map&lt;Long, Long&gt; d = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">long</span> w = (<span class="keyword">long</span>)t + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">long</span> m = getID(nums[i], w);</span><br><span class="line">            <span class="comment">// check if bucket m is empty, each bucket may contain at most one element</span></span><br><span class="line">            <span class="keyword">if</span> (d.containsKey(m))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// check the neighbor buckets for almost duplicate</span></span><br><span class="line">            <span class="keyword">if</span> (d.containsKey(m - <span class="number">1</span>) &amp;&amp; Math.abs(nums[i] - d.get(m - <span class="number">1</span>)) &lt; w)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (d.containsKey(m + <span class="number">1</span>) &amp;&amp; Math.abs(nums[i] - d.get(m + <span class="number">1</span>)) &lt; w)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// now bucket m is empty and no almost duplicate in nei***or buckets</span></span><br><span class="line">            d.put(m, (<span class="keyword">long</span>)nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k) d.remove(getID(nums[i - k], w));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(n)</em></li></ul><p>对于这 <em>n</em> 个元素中的任意一个元素来说，我们最多只需要在散列表中做三次 <code>搜索</code>，一次 <code>插入</code> 和一次 <code>删除</code>。这些操作是常量时间复杂度的。因此，整个算法的时间复杂度为 <em>O(n)</em>。</p><ul><li>空间复杂度：O(min(n,k))<br>需要开辟的额外空间取决了散列表的大小，其大小跟它所包含的元素数量成线性关系。散列表的大小的上限同时由 <em>n</em> 和 <em>k</em> 决定。因此，空间复杂度为O(min(n,k))  。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在整数数组 nums 中，是否存在两个下标 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值小于等于 t ，且满足 i 和 j 的差的绝对值也小于等于 ķ 。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Sort" scheme="http://yoursite.com/tags/Sort/"/>
    
      <category term="Ordered Map" scheme="http://yoursite.com/tags/Ordered-Map/"/>
    
  </entry>
  
  <entry>
    <title>217. 存在重复元素</title>
    <link href="http://yoursite.com/2020/06/29/217.%20%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2020/06/29/217. 存在重复元素/</id>
    <published>2020-06-29T06:33:12.000Z</published>
    <updated>2020-06-29T06:41:10.110Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数数组，判断是否存在重复元素。如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。</p><a id="more"></a><h1 id="哈希表解决"><a href="#哈希表解决" class="headerlink" title="哈希表解决"></a>哈希表解决</h1><p>可以用Set或HashMap来解决</p><figure class="highlight java"><figcaption><span>[solution 3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(nums.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x: nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(x)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        set.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多详细分析见<a href="https://leetcode-cn.com/problems/contains-duplicate/solution/cun-zai-zhong-fu-yuan-su-by-leetcode/" target="_blank" rel="noopener">^1</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://leetcode-cn.com/problems/contains-duplicate-ii/" target="_blank" rel="noopener">219 存在重复元素 II</a></li><li><a href="https://leetcode-cn.com/problems/contains-duplicate-iii/" target="_blank" rel="noopener">220 存在重复元素 III</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数数组，判断是否存在重复元素。如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>219. 存在重复元素II</title>
    <link href="http://yoursite.com/2020/06/29/219.%20%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II/"/>
    <id>http://yoursite.com/2020/06/29/219. 存在重复元素II/</id>
    <published>2020-06-29T06:33:12.000Z</published>
    <updated>2020-06-29T06:55:28.045Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: nums = [1,2,3,1], k = 3输出: true</code></pre><p>示例 2:</p><pre><code>输入: nums = [1,0,1,1], k = 1输出: true</code></pre><p>示例 3:</p><pre><code>输入: nums = [1,2,3,1,2,3], k = 2输出: false</code></pre><h1 id="解法一：HashMap"><a href="#解法一：HashMap" class="headerlink" title="解法一：HashMap"></a>解法一：HashMap</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean containsNearbyDuplicate(int[] nums, int k) &#123;</span><br><span class="line">        //Key-&gt;nums[i] , Value-&gt;i</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; hashMap=new HashMap&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (hashMap.containsKey(nums[i])) &#123;</span><br><span class="line">                if (Math.abs(i - hashMap.get(nums[i])) &lt;= k) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            hashMap.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法二-（散列表）"><a href="#方法二-（散列表）" class="headerlink" title="方法二 （散列表）"></a>方法二 （散列表）</h1><p><strong>思路</strong></p><p>用散列表来维护这个<em>k</em>大小的滑动窗口。<a href="https://leetcode-cn.com/problems/contains-duplicate-ii/solution/cun-zai-zhong-fu-yuan-su-ii-by-leetcode/" target="_blank" rel="noopener">^1</a></p><p><strong>算法</strong></p><p>在之前的方法中，我们知道了对数时间复杂度的 <code>搜索</code> 操作是不够的。在这个方法里面，我们需要一个支持在常量时间内完成 <code>搜索</code>，<code>删除</code>，<code>插入</code> 操作的数据结构，那就是散列表。这个算法的实现跟方法二几乎是一样的。</p><ul><li>遍历数组，对于每个元素做以下操作：<ul><li>在散列表中搜索当前元素，如果找到了就返回 <code>true</code>。</li><li>在散列表中插入当前元素。</li><li>如果当前散列表的大小超过了 <em>k</em>， 删除散列表中最旧的元素。</li></ul></li><li>返回 <code>false</code>。</li></ul><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(nums[i])) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        set.add(nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (set.size() &gt; k) &#123;</span><br><span class="line">            set.remove(nums[i - k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)</em><br>我们会做 <em>n</em> 次 <code>搜索</code>，<code>删除</code>，<code>插入</code> 操作，每次操作都耗费常数时间。</p></li><li><p>空间复杂度：O(min(n,k)) </p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>152. 乘积最大子数组</title>
    <link href="http://yoursite.com/2020/06/29/152.%20%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2020/06/29/152. 乘积最大子数组/</id>
    <published>2020-06-29T06:06:12.000Z</published>
    <updated>2020-06-29T06:23:19.793Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。</code></pre><p>示例 2:</p><pre><code>输入: [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</code></pre><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这道题比较经典，官方解法可以见<a href="https://leetcode-cn.com/problems/maximum-product-subarray/solution/cheng-ji-zui-da-zi-shu-zu-by-leetcode-solution/" target="_blank" rel="noopener">^1</a>,我首先想到用全局变量和局部变量的方法来解决，但是要注意两个测试样例[-2]和[0,2]，需要对全局和局部最大变量做相应处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProduct(int[] nums) &#123;</span><br><span class="line">        int maxpro=nums[0];</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            int localpro=nums[i];</span><br><span class="line">            maxpro = Math.max(maxpro, localpro);</span><br><span class="line">            for (int j = i+1; j &lt; nums.length; j++) &#123;</span><br><span class="line">                localpro *= nums[j];</span><br><span class="line">                maxpro = Math.max(maxpro, localpro);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxpro;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>189. 旋转数组</title>
    <link href="http://yoursite.com/2020/06/29/189.%20%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2020/06/29/189. 旋转数组/</id>
    <published>2020-06-29T06:06:12.000Z</published>
    <updated>2020-06-29T06:23:14.982Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4]</code></pre><p>示例 2:</p><pre><code>输入: [-1,-100,3,99] 和 k = 2输出: [3,99,-1,-100]解释: 向右旋转 1 步: [99,-1,-100,3]向右旋转 2 步: [3,99,-1,-100]</code></pre><p>说明:</p><pre><code>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。要求使用空间复杂度为 O(1) 的 原地 算法。</code></pre><h2 id="方法-1：暴力"><a href="#方法-1：暴力" class="headerlink" title="方法 1：暴力"></a>方法 1：暴力</h2><p>最简单的方法是旋转 k 次，每次将数组旋转 1 个元素。</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp, previous;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            previous = nums[nums.length - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                temp = nums[j];</span><br><span class="line">                nums[j] = previous;</span><br><span class="line">                previous = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(n*k)</em> 。每个元素都被移动 1 步（<em>O(n)</em>） k次（<em>O(k)</em>） 。</li><li>空间复杂度：<em>O(1)</em> 。没有额外空间被使用。</li></ul><h2 id="方法-2：使用额外的数组"><a href="#方法-2：使用额外的数组" class="headerlink" title="方法 2：使用额外的数组"></a>方法 2：使用额外的数组</h2><p><strong>算法</strong></p><p>我们可以用一个额外的数组来将每个元素放到正确的位置上，也就是原本数组里下标为 <em>i</em> 的我们把它放到 <img src="./p___i+k_%%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6_.png" alt="(i+k)\%数组长度 ">  的位置。然后把新的数组拷贝到原数组中。</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            a[(i + k) % nums.length] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度： <em>O(n)</em> 。将数字放到新的数组中需要一遍遍历，另一边来把新数组的元素拷贝回原数组。</li><li>空间复杂度： <em>O(n)</em>。另一个数组需要原数组长度的空间。</li></ul><h2 id="方法-3：使用环状替换"><a href="#方法-3：使用环状替换" class="headerlink" title="方法 3：使用环状替换"></a>方法 3：使用环状替换</h2><p><strong>算法</strong></p><p>如果我们直接把每一个数字放到它最后的位置，但这样的后果是遗失原来的元素。因此，我们需要把被替换的数字保存在变量 <em>temp</em> 里面。然后，我们将被替换数字（<em>temp*）放到它正确的位置，并继续这个过程 *n</em> 次， <em>n</em> 是数组的长度。这是因为我们需要将数组里所有的元素都移动。但是，这种方法可能会有个问题，如果 <img src="./p__n%k==0_.png" alt="n\%k==0 "> ，其中 <img src="./p__k=k%n_.png" alt="k=k\%n ">  （因为如果 <em>k</em> 大于 <em>n</em> ，移动 <em>k</em> 次实际上相当于移动 <img src="./p__k%n_.png" alt="k\%n ">  次）。这种情况下，我们会发现在没有遍历所有数字的情况下回到出发数字。此时，我们应该从下一个数字开始再重复相同的过程。</p><p>现在，我们看看上面方法的证明。假设，数组里我们有 <em>n</em> 个元素并且 <em>k</em> 是要求移动的次数。更进一步，假设 <img src="./p__n%k=0_.png" alt="n\%k=0 ">  。第一轮中，所有移动数字的下标 <em>i</em> 满足 <img src="./p__i%k==0_.png" alt="i\%k==0 ">  。这是因为我们每跳 <em>k</em> 步，我们只会到达相距为 <em>k</em> 个位置下标的数。每一轮，我们都会移动 <img src="./p__frac%7Bn%7D%7Bk%7D_.png" alt="\frac{n}{k} ">  个元素。下一轮中，我们会移动满足 <img src="./p__i%k==1_.png" alt="i\%k==1 ">  的位置的数。这样的轮次会一直持续到我们再次遇到 <img src="./p__i%k==0_.png" alt="i\%k==0 ">  的地方为止，此时 <em>i=k</em> 。此时在正确位置上的数字共有 <img src="./p__k_times_frac%7Bn%7D%7Bk%7D=n_.png" alt="k\times\frac{n}{k}=n ">  个。因此所有数字都在正确位置上。</p><p>让我们看一下接下来的例子，以更好地说明这个过程：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums: [1, 2, 3, 4, 5, 6]</span><br><span class="line">k: 2</span><br></pre></td></tr></table></figure></p><p> <a href="https://pic.leetcode-cn.com/f0493a97cdb7bc46b37306ca14e555451496f9f9c21effcad8517a81a26f30d6-image.png" target="_blank" rel="noopener">例子</a></p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k = k % nums.length;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; count &lt; nums.length; start++) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = start;</span><br><span class="line">            <span class="keyword">int</span> prev = nums[start];</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> next = (current + k) % nums.length;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[next];</span><br><span class="line">                nums[next] = prev;</span><br><span class="line">                prev = temp;</span><br><span class="line">                current = next;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">while</span> (start != current);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(n)</em> 。只遍历了每个元素一次。</li><li>空间复杂度：<em>O(1)</em> 。使用了常数个额外空间。</li></ul><h2 id="方法-4：使用反转"><a href="#方法-4：使用反转" class="headerlink" title="方法 4：使用反转"></a>方法 4：使用反转</h2><p><strong>算法</strong></p><p>这个方法基于这个事实：当我们旋转数组 k 次， <img src="./p__k%n_.png" alt="k\%n ">  个尾部元素会被移动到头部，剩下的元素会被向后移动。</p><p>在这个方法中，我们首先将所有元素反转。然后反转前 k 个元素，再反转后面 <em>n-k</em> 个元素，就能得到想要的结果。</p><p>我用这种方法来解决时遇到数组越界错误，是因为没有把k取模，因为有些情况下k可能大于数组长度。这个易错点需要注意。</p><p>假设 <em>n=7</em> 且 <em>k=3</em> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原始数组                  : 1 2 3 4 5 6 7</span><br><span class="line">反转所有数字后             : 7 6 5 4 3 2 1</span><br><span class="line">反转前 k 个数字后          : 5 6 7 4 3 2 1</span><br><span class="line">反转后 n-k 个数字后        : 5 6 7 1 2 3 4 --&gt; 结果</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k %= nums.length;</span><br><span class="line">        reverse(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, k, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[start];</span><br><span class="line">            nums[start] = nums[end];</span><br><span class="line">            nums[end] = temp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(n)</em> 。 <em>n</em> 个元素被反转了总共 3 次。</li><li>空间复杂度：<em>O(1)</em> 。 没有使用额外的空间。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>63. 不同路径II</title>
    <link href="http://yoursite.com/2020/06/28/63.%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II/"/>
    <id>http://yoursite.com/2020/06/28/63. 不同路径II/</id>
    <published>2020-06-28T12:50:12.000Z</published>
    <updated>2020-06-29T06:22:31.214Z</updated>
    
    <content type="html"><![CDATA[<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><a id="more"></a><p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p><p>说明：m 和 n 的值均不超过 100。</p><p>示例1:</p><pre><code>输入:[  [0,0,0],  [0,1,0],  [0,0,0]]输出: 2解释:3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</code></pre><h2 id="方法-1：动态规划-1"><a href="#方法-1：动态规划-1" class="headerlink" title="方法 1：动态规划^1"></a>方法 1：动态规划<a href="https://leetcode-cn.com/problems/unique-paths-ii/solution/bu-tong-lu-jing-ii-by-leetcode/" target="_blank" rel="noopener">^1</a></h2><p><strong>直觉</strong></p><p>机器人只可以向下和向右移动，因此第一行的格子只能从左边的格子移动到，第一列的格子只能从上方的格子移动到。</p><p>如果格子上有障碍，那么我们不考虑包含这个格子的任何路径。我们从左至右、从上至下的遍历整个数组，那么在到达某个顶点之前我们就已经获得了到达前驱节点的方案数，这就变成了一个<code>动态规划</code>问题。我们只需要一个 <code>obstacleGrid</code> 数组作为 DP 数组。</p><p><code>注意：</code> 根据题目描述，包含障碍物的格点有权值 <code>1</code>，我们依此来判断是否包含在路径中，然后我们可以用这个空间来存储到达这个格点的方案数。</p><p><strong>算法</strong></p><ol><li>如果第一个格点 <code>obstacleGrid[0,0]</code> 是 <code>1</code>，说明有障碍物，那么机器人不能做任何移动，我们返回结果 <code>0</code>。</li><li>否则，如果 <code>obstacleGrid[0,0]</code> 是 <code>0</code>，我们初始化这个值为 <code>1</code> 然后继续算法。</li><li>遍历第一行，如果有一个格点初始值为 <code>1</code> ，说明当前节点有障碍物，没有路径可以通过，设值为 <code>0</code> ；否则设这个值是前一个节点的值 <code>obstacleGrid[i,j] = obstacleGrid[i,j-1]</code>。</li><li>遍历第一列，如果有一个格点初始值为 <code>1</code> ，说明当前节点有障碍物，没有路径可以通过，设值为 <code>0</code> ；否则设这个值是前一个节点的值 <code>obstacleGrid[i,j] = obstacleGrid[i-1,j]</code>。</li><li>现在，从 <code>obstacleGrid[1,1]</code> 开始遍历整个数组，如果某个格点初始不包含任何障碍物，就把值赋为上方和左侧两个格点方案数之和 <code>obstacleGrid[i,j] = obstacleGrid[i-1,j] + obstacleGrid[i,j-1]</code>。</li><li>如果这个点有障碍物，设值为 <code>0</code> ，这可以保证不会对后面的路径产生贡献。</li></ol><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> R = obstacleGrid.length;</span><br><span class="line">        <span class="keyword">int</span> C = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the starting cell has an obstacle, then simply return as there would be</span></span><br><span class="line">        <span class="comment">// no paths to the destination.</span></span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Number of ways of reaching the starting cell = 1.</span></span><br><span class="line">        obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Filling the values for the first column</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; R; i++) &#123;</span><br><span class="line">            obstacleGrid[i][<span class="number">0</span>] = (obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; obstacleGrid[i - <span class="number">1</span>][<span class="number">0</span>] == <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Filling the values for the first row</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; C; i++) &#123;</span><br><span class="line">            obstacleGrid[<span class="number">0</span>][i] = (obstacleGrid[<span class="number">0</span>][i] == <span class="number">0</span> &amp;&amp; obstacleGrid[<span class="number">0</span>][i - <span class="number">1</span>] == <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Starting from cell(1,1) fill up the values</span></span><br><span class="line">        <span class="comment">// No. of ways of reaching cell[i][j] = cell[i - 1][j] + cell[i][j - 1]</span></span><br><span class="line">        <span class="comment">// i.e. From above and left.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; R; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; C; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    obstacleGrid[i][j] = obstacleGrid[i - <span class="number">1</span>][j] + obstacleGrid[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    obstacleGrid[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return value stored in rightmost bottommost cell. That is the destination.</span></span><br><span class="line">        <span class="keyword">return</span> obstacleGrid[R - <span class="number">1</span>][C - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 ： O(M\timesN)   。长方形网格的大小是 M\timesN ，而访问每个格点恰好一次。</li><li>空间复杂度 ： <em>O(1)</em>。我们利用 <code>obstacleGrid</code> 作为 DP 数组，因此不需要额外的空间。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>980. 不同路径 III</title>
    <link href="http://yoursite.com/2020/06/28/980.%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%20III/"/>
    <id>http://yoursite.com/2020/06/28/980. 不同路径 III/</id>
    <published>2020-06-28T12:50:12.000Z</published>
    <updated>2020-06-29T10:06:02.298Z</updated>
    
    <content type="html"><![CDATA[<p>返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目，每一个无障碍方格都要通过一次。</p><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在二维网格 grid 上，有 4 种类型的方格：</p><pre><code>1 表示起始方格。且只有一个起始方格。2 表示结束方格，且只有一个结束方格。0 表示我们可以走过的空方格。-1 表示我们无法跨越的障碍。</code></pre><p>返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目，每一个无障碍方格都要通过一次。</p><p>示例 1：</p><pre><code>输入：[[1,0,0,0],[0,0,0,0],[0,0,2,-1]]输出：2解释：我们有以下两条路径：1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)</code></pre><p>示例 2：</p><pre><code>输入：[[1,0,0,0],[0,0,0,0],[0,0,0,2]]输出：4解释：我们有以下四条路径： 1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)</code></pre><p>示例 3：</p><pre><code>输入：[[0,1],[2,0]]输出：0解释：没有一条路能完全穿过每一个空的方格一次。请注意，起始和结束方格可以位于网格中的任意位置。</code></pre><p>提示：</p><p>1 &lt;= grid.length * grid[0].length &lt;= 20</p><h4 id="方法一：回溯深度优先搜索"><a href="#方法一：回溯深度优先搜索" class="headerlink" title="方法一：回溯深度优先搜索"></a>方法一：回溯深度优先搜索</h4><p><strong>思路与算法</strong><a href="https://leetcode-cn.com/problems/unique-paths-iii/solution/bu-tong-lu-jing-iii-by-leetcode/" target="_blank" rel="noopener">^1</a></p><p>让我们尝试遍历每一个 <code>0</code> 方格，并在走过的方格里留下一个障碍。回溯的时候，我们要删除那些自己留下的障碍。</p><p>介于输入数据的限制，这个方法是可以通过的，因为一个不好的路径很快就会因没有无障碍的方格可以走而被卡住。 </p><figure class="highlight java"><figcaption><span>[2RULHstn-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="keyword">int</span>[][] grid;</span><br><span class="line">    <span class="keyword">int</span> targetR, targetC;</span><br><span class="line">    <span class="keyword">int</span> R, C;</span><br><span class="line">    <span class="keyword">int</span>[] dr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] dc = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsIII</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.grid = grid;</span><br><span class="line">        R = grid.length;</span><br><span class="line">        C = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> todo = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sourceR = <span class="number">0</span>, sourceC = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//获取无障碍方格数量和出发终止位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; c++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] != -<span class="number">1</span>) &#123;</span><br><span class="line">                    todo++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="number">1</span>) &#123;</span><br><span class="line">                    sourceR = r;</span><br><span class="line">                    sourceC = c;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[r][c] == <span class="number">2</span>) &#123;</span><br><span class="line">                    targetR = r;</span><br><span class="line">                    targetC = c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        dfs(sourceR, sourceC, todo);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> todo)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每一个无障碍方格都要通过一次</span></span><br><span class="line">        todo--;</span><br><span class="line">        <span class="keyword">if</span> (todo &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//到达终点</span></span><br><span class="line">        <span class="keyword">if</span> (r == targetR &amp;&amp; c == targetC) &#123;</span><br><span class="line">            <span class="keyword">if</span> (todo == <span class="number">0</span>) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在走过的方格里留下一个障碍</span></span><br><span class="line">        grid[r][c] = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">int</span> nr = r + dr[k];</span><br><span class="line">            <span class="keyword">int</span> nc = c + dc[k];</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> &lt;= nr &amp;&amp; nr &lt; R &amp;&amp; <span class="number">0</span> &lt;= nc &amp;&amp; nc &lt; C) &#123;</span><br><span class="line">                <span class="comment">//尝试遍历每一个 `0` 方格</span></span><br><span class="line">                <span class="keyword">if</span> (grid[nr][nc] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    dfs(nr, nc, todo);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//回溯的时候，我们要删除那些自己留下的障碍。</span></span><br><span class="line">        grid[r][c] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[2RULHstn-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsIII</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        R, C = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">nei</span>***<span class="title">ors</span><span class="params">(r, c)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> nr, nc <span class="keyword">in</span> ((r<span class="number">-1</span>, c), (r, c<span class="number">-1</span>), (r+<span class="number">1</span>, c), (r, c+<span class="number">1</span>)):</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= nr &lt; R <span class="keyword">and</span> <span class="number">0</span> &lt;= nc &lt; C <span class="keyword">and</span> grid[nr][nc] % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">yield</span> nr, nc</span><br><span class="line"></span><br><span class="line">        todo = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> r, row <span class="keyword">in</span> enumerate(grid):</span><br><span class="line">            <span class="keyword">for</span> c, val <span class="keyword">in</span> enumerate(row):</span><br><span class="line">                <span class="keyword">if</span> val != <span class="number">-1</span>: todo += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> val == <span class="number">1</span>: sr, sc = r, c</span><br><span class="line">                <span class="keyword">if</span> val == <span class="number">2</span>: tr, tc = r, c</span><br><span class="line"></span><br><span class="line">        self.ans = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(r, c, todo)</span>:</span></span><br><span class="line">            todo -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> todo &lt; <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> r == tr <span class="keyword">and</span> c == tc:</span><br><span class="line">                <span class="keyword">if</span> todo == <span class="number">0</span>:</span><br><span class="line">                    self.ans += <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            grid[r][c] = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">for</span> nr, nc <span class="keyword">in</span> nei***ors(r, c):</span><br><span class="line">                dfs(nr, nc, todo)</span><br><span class="line">            grid[r][c] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        dfs(sr, sc, todo)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(4^{R<em>C})</em>，其中 *R, C</em> 是这个二维网格行与列的大小。（我们可以找到一个更加精确的界限，但是这个界限已经超越了本文的范围）</p></li><li><p>空间复杂度：<em>O(R</em>C)*。</p></li></ul><hr><h4 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h4><p><strong>思路与算法</strong></p><p>让我们定义 <code>dp(r, c, todo)</code> 为从  <code>(r, c)</code> 开始行走，还没有遍历的无障碍方格集合为 <code>todo</code> 的好路径的数量。</p><p>我们可以使用一个与 <em>方法一</em> 类似的方法，并通过记忆化状态 <code>(r, c, todo)</code> 的答案来避免重复搜索。</p><figure class="highlight java"><figcaption><span>[pRtnUqNa-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="keyword">int</span>[][] grid;</span><br><span class="line">    <span class="keyword">int</span> R, C;</span><br><span class="line">    <span class="keyword">int</span> tr, tc, target;</span><br><span class="line">    <span class="keyword">int</span>[] dr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] dc = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    Integer[][][] memo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsIII</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.grid = grid;</span><br><span class="line">        R = grid.length;</span><br><span class="line">        C = grid[<span class="number">0</span>].length;</span><br><span class="line">        target = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sr = <span class="number">0</span>, sc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; ++r)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                    target |= code(r, c);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="number">1</span>) &#123;</span><br><span class="line">                    sr = r;</span><br><span class="line">                    sc = c;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[r][c] == <span class="number">2</span>) &#123;</span><br><span class="line">                    tr = r;</span><br><span class="line">                    tc = c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        memo = <span class="keyword">new</span> Integer[R][C][<span class="number">1</span> &lt;&lt; R*C];</span><br><span class="line">        <span class="keyword">return</span> dp(sr, sc, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">code</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; (r * C + c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">dp</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> todo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (memo[r][c][todo] != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> memo[r][c][todo];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r == tr &amp;&amp; c == tc) &#123;</span><br><span class="line">            <span class="keyword">return</span> todo == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">            <span class="keyword">int</span> nr = r + dr[k];</span><br><span class="line">            <span class="keyword">int</span> nc = c + dc[k];</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> &lt;= nr &amp;&amp; nr &lt; R &amp;&amp; <span class="number">0</span> &lt;= nc &amp;&amp; nc &lt; C) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((todo &amp; code(nr, nc)) != <span class="number">0</span>)</span><br><span class="line">                    ans += dp(nr, nc, todo ^ code(nr, nc));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memo[r][c][todo] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[pRtnUqNa-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsIII</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        R, C = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">code</span><span class="params">(r, c)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; (r * C + c)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">nei</span>***<span class="title">ors</span><span class="params">(r, c)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> nr, nc <span class="keyword">in</span> ((r<span class="number">-1</span>, c), (r, c<span class="number">-1</span>), (r+<span class="number">1</span>, c), (r, c+<span class="number">1</span>)):</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= nr &lt; R <span class="keyword">and</span> <span class="number">0</span> &lt;= nc &lt; C <span class="keyword">and</span> grid[nr][nc] % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">yield</span> nr, nc</span><br><span class="line"></span><br><span class="line">        target = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> r, row <span class="keyword">in</span> enumerate(grid):</span><br><span class="line">            <span class="keyword">for</span> c, val <span class="keyword">in</span> enumerate(row):</span><br><span class="line">                <span class="keyword">if</span> val % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    target |= code(r, c)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> val == <span class="number">1</span>:</span><br><span class="line">                    sr, sc = r, c</span><br><span class="line">                <span class="keyword">if</span> val == <span class="number">2</span>:</span><br><span class="line">                    tr, tc = r, c</span><br><span class="line"></span><br><span class="line"><span class="meta">        @lru_cache(None)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(r, c, todo)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> r == tr <span class="keyword">and</span> c == tc:</span><br><span class="line">                <span class="keyword">return</span> +(todo == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            ans = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> nr, nc <span class="keyword">in</span> nei***ors(r, c):</span><br><span class="line">                <span class="keyword">if</span> todo &amp; code(nr, nc):</span><br><span class="line">                    ans += dp(nr, nc, todo ^ code(nr, nc))</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp(sr, sc, target)</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(R * C * 2^{R<em>C})</em>，其中 *R, C</em> 是给定二维网格行与列的大小。</li><li>空间复杂度：<em>O(R * C * 2^{R</em>C})*。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目，每一个无障碍方格都要通过一次。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>62. 不同路径</title>
    <link href="http://yoursite.com/2020/06/28/62.%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2020/06/28/62. 不同路径/</id>
    <published>2020-06-28T12:12:12.000Z</published>
    <updated>2020-06-28T14:32:49.381Z</updated>
    
    <content type="html"><![CDATA[<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。问总共有多少条不同的路径？</p><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p><p>示例 1:</p><pre><code>输入: m = 3, n = 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向右 -&gt; 向下2. 向右 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向右</code></pre><p>示例 2:</p><pre><code>输入: m = 7, n = 3输出: 28</code></pre><p>提示：</p><pre><code>1 &lt;= m, n &lt;= 100</code></pre><p>题目数据保证答案小于等于 2 * 10 ^ 9</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="思路一：排列组合"><a href="#思路一：排列组合" class="headerlink" title="思路一：排列组合"></a><strong>思路一：排列组合</strong></h2><p>因为机器到底右下角，向下几步，向右几步都是固定的，</p><p>比如，<code>m=3, n=2</code>，我们只要向下 1 步，向右 2 步就一定能到达终点。</p><p>所以有 <em>C_{m+n-2}^{m-1}</em></p><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> int(math.factorial(m+n<span class="number">-2</span>)/math.factorial(m<span class="number">-1</span>)/math.factorial(n<span class="number">-1</span>))</span><br></pre></td></tr></table></figure><h2 id="思路二：动态规划"><a href="#思路二：动态规划" class="headerlink" title="思路二：动态规划"></a><strong>思路二：动态规划</strong></h2><p>我们令 <code>dp[i][j]</code> 是到达 <code>i, j</code> 最多路径</p><p>动态方程：<code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code></p><p>注意，对于第一行 <code>dp[0][j]</code>，或者第一列 <code>dp[i][0]</code>，由于都是在边界，所以只能为 <code>1</code></p><p>时间复杂度：<em>O(m*n)</em></p><p>空间复杂度：<em>O(m * n)</em></p><h2 id="优化：因为我们每次只需要-dp-i-1-j-dp-i-j-1"><a href="#优化：因为我们每次只需要-dp-i-1-j-dp-i-j-1" class="headerlink" title="优化：因为我们每次只需要 dp[i-1][j],dp[i][j-1]"></a>优化：因为我们每次只需要 <code>dp[i-1][j],dp[i][j-1]</code></h2><p>所以我们只要记录这两个数，直接看代码吧！</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>思路二：</p><figure class="highlight java"><figcaption><span>[1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化1：空间复杂度 <em>O(2n)</em></p><figure class="highlight java"><figcaption><span>[2]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] pre = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] cur = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(pre, <span class="number">1</span>);</span><br><span class="line">        Arrays.fill(cur,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                cur[j] = cur[j-<span class="number">1</span>] + pre[j];</span><br><span class="line">            &#125;</span><br><span class="line">            pre = cur.clone();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre[n-<span class="number">1</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化2：空间复杂度 <em>O(n)</em></p><figure class="highlight java"><figcaption><span>[3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] cur = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(cur,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                cur[j] += cur[j-<span class="number">1</span>] ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。问总共有多少条不同的路径？&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>212. 单词搜索II</title>
    <link href="http://yoursite.com/2020/06/28/212.%20%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2II/"/>
    <id>http://yoursite.com/2020/06/28/212. 单词搜索II/</id>
    <published>2020-06-28T10:12:12.000Z</published>
    <updated>2020-06-28T12:02:17.704Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二维网格board和一个字典中的单词列表 words，找出所有同时在二维网格和字典中出现的单词。</p><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。</p><p>示例:</p><p>输入: </p><pre><code>words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;] and board =[  [&apos;o&apos;,&apos;a&apos;,&apos;a&apos;,&apos;n&apos;],  [&apos;e&apos;,&apos;t&apos;,&apos;a&apos;,&apos;e&apos;],  [&apos;i&apos;,&apos;h&apos;,&apos;k&apos;,&apos;r&apos;],  [&apos;i&apos;,&apos;f&apos;,&apos;l&apos;,&apos;v&apos;]]</code></pre><p>输出:</p><pre><code>[&quot;eat&quot;,&quot;oath&quot;]</code></pre><p>说明:</p><p>你可以假设所有输入都由小写字母 a-z 组成。</p><p>提示:</p><ul><li><p>你需要优化回溯算法以通过更大数据量的测试。你能否早点停止回溯？</p></li><li><p>如果当前单词不存在于所有单词的前缀中，则可以立即停止回溯。什么样的数据结构可以有效地执行这样的操作？散列表是否可行？为什么？ 前缀树如何？如果你想学习如何实现一个基本的前缀树，请先查看这个问题： 实现Trie（前缀树）。</p></li></ul><h4 id="方法一：使用前缀树的回溯"><a href="#方法一：使用前缀树的回溯" class="headerlink" title="方法一：使用前缀树的回溯"></a>方法一：使用前缀树的回溯</h4><p>这个问题实际上是一个简化的纵横填字游戏，在这个游戏中，单词的解已经被嵌入了一些无关字母。我们要做的就是把它们划掉。</p><p>直观地说，为了划掉所有潜在的单词，总体策略是一个接一个地迭代单元格，然后从每个单元格沿着它的四个潜在方向的走，找到匹配的单词。</p><p>当我们在黑板上徘徊时，若我们知道这不会发现新单词时，我们会停止探索。</p><p>有人可能已经猜到了我们用来解决这个问题的方法。是的，它是回溯，这将是解决方案的主干。构造一个回溯的解决方案是相当简单的。</p><p>解决这个问题的关键在于我们如何从字典中找到单词的匹配项。直观地说，可以使用 hashset 数据结构（例如Python 中的 <code>set()</code>）。</p><p>然而，在回溯过程中，人们会更经常地遇到这样的问题：是否存在任何包含特定前缀的单词，而不是是否有一个字符串作为单词存在于字典中。因为如果我们知道给定前缀的字典中不存在任何单词匹配，那么我们就不需要进一步探索某个方向。而这，将大大减少探测空间，从而提高回溯算法的性能。</p><p>能够查找前缀的数据结构叫 Trie，于 hashset 比较。Trie 不仅可以检查一个单词，还可以立即找到共享给定前缀的单词。事实证明，数据结构的选择（Trie 与 hashset）可能以排名前 5% 或后 5% 的解决方案结束。</p><p>这里我们展示了一个由单词列表构建的 Trie 示例。如下图所示，在所表示的节点处，我们将知道字典中至少有两个前缀为 <code>d</code> 的单词。</p><p> <a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl90cmllX2V4YW1wbGUucG5n?x-oss-process=image/format,png" target="_blank" rel="noopener">一个由单词列表构建的 Trie 示例</a></p><p>我们在实现 Trie 数据结构时遇到麻烦。我们可以从<a href="https://leetcode.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">Trie 问题</a>开始作为热身，然后再回来这个问题。</p><p><strong>算法：</strong></p><p>该算法的整个工作流程是直观的，包括在二维网格中的每个单元上循环和从单元开始的递归函数调用。这是算法的框架。</p><ul><li>我们根据字典中的单词构建一个 Trie，稍后将用于匹配过程。</li><li>从每个单元格开始，如果字典中存在以单元格中的字母开头的单词,则我们开始回溯探索（即 <code>backtracking(cell)</code>）。</li><li>在递归函数 <code>backtracking(cell)</code> 调用过程中，我们探索当前单元格周围的相邻单元格（即 <code>neighborCell</code>）以进行下一个递归调用 <code>backtracking(neighborCell)</code>。在每次调用时，我们都会检查到目前为止遍历的字母序列是否与字典中的任何单词匹配，这需要借助于我们在开始时构建的 Trie 数据结构。</li></ul><p>下面是算法的工作原理的。基于上述思想，我们给出了一些示例实现。之后，我们详细介绍了一些可以进一步应用于该算法的优化。</p><p> <a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl90cmllX2FsZ28ucG5n?x-oss-process=image/format,png" target="_blank" rel="noopener">算法的工作原理</a></p><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">  HashMap&lt;Character, TrieNode&gt; children = <span class="keyword">new</span> HashMap&lt;Character, TrieNode&gt;();</span><br><span class="line">  String word = <span class="keyword">null</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span>[][] _board = <span class="keyword">null</span>;</span><br><span class="line">  ArrayList&lt;String&gt; _result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findWords</span><span class="params">(<span class="keyword">char</span>[][] board, String[] words)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 1). Construct the Trie</span></span><br><span class="line">    TrieNode root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">      TrieNode node = root;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (Character letter : word.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.children.containsKey(letter)) &#123;</span><br><span class="line">          node = node.children.get(letter);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          TrieNode newNode = <span class="keyword">new</span> TrieNode();</span><br><span class="line">          node.children.put(letter, newNode);</span><br><span class="line">          node = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      node.word = word;  <span class="comment">// store words in Trie</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._board = board;</span><br><span class="line">    <span class="comment">// Step 2). Backtracking starting for each cell in the board</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; board.length; ++row) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; board[row].length; ++col) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.children.containsKey(board[row][col])) &#123;</span><br><span class="line">          backtracking(row, col, root);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._result;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, TrieNode parent)</span> </span>&#123;</span><br><span class="line">    Character letter = <span class="keyword">this</span>._board[row][col];</span><br><span class="line">    TrieNode currNode = parent.children.get(letter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check if there is any match</span></span><br><span class="line">    <span class="keyword">if</span> (currNode.word != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>._result.add(currNode.word);</span><br><span class="line">      currNode.word = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mark the current letter before the EXPLORATION</span></span><br><span class="line">    <span class="keyword">this</span>._board[row][col] = <span class="string">'#'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// explore neighbor cells in around-clock directions: up, right, down, left</span></span><br><span class="line">    <span class="keyword">int</span>[] rowOffset = &#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] colOffset = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">      <span class="keyword">int</span> newRow = row + rowOffset[i];</span><br><span class="line">      <span class="keyword">int</span> newCol = col + colOffset[i];</span><br><span class="line">      <span class="keyword">if</span> (newRow &lt; <span class="number">0</span> || newRow &gt;= <span class="keyword">this</span>._board.length || newCol &lt; <span class="number">0</span></span><br><span class="line">          || newCol &gt;= <span class="keyword">this</span>._board[<span class="number">0</span>].length) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (currNode.children.containsKey(<span class="keyword">this</span>._board[newRow][newCol])) &#123;</span><br><span class="line">        backtracking(newRow, newCol, currNode);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// End of EXPLORATION, restore the original letter in the board.</span></span><br><span class="line">    <span class="keyword">this</span>._board[row][col] = letter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optimization: incrementally remove the leaf nodes</span></span><br><span class="line">    <span class="keyword">if</span> (currNode.children.isEmpty()) &#123;</span><br><span class="line">      parent.children.remove(letter);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了更好地理解回溯过程，我们将在下面的动画中演示如何在 Trie 中找到 <code>dog</code>。</p><p>  [1](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV8xLnBuZw?x-oss-process=image/format" target="_blank" rel="noopener">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV8xLnBuZw?x-oss-process=image/format</a> png) </p><p>  [2](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV8yLnBuZw?x-oss-process=image/format" target="_blank" rel="noopener">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV8yLnBuZw?x-oss-process=image/format</a> png)  </p><p>  [3](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV8zLnBuZw?x-oss-process=image/format" target="_blank" rel="noopener">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV8zLnBuZw?x-oss-process=image/format</a> png)  </p><p>  [4](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV80LnBuZw?x-oss-process=image/format" target="_blank" rel="noopener">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV80LnBuZw?x-oss-process=image/format</a> png)  </p><p>  [5](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV81LnBuZw?x-oss-process=image/format" target="_blank" rel="noopener">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV81LnBuZw?x-oss-process=image/format</a> png)  </p><p>  [6](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV82LnBuZw?x-oss-process=image/format" target="_blank" rel="noopener">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV82LnBuZw?x-oss-process=image/format</a> png) </p><h2 id="优化："><a href="#优化：" class="headerlink" title="优化："></a><strong>优化</strong>：</h2><p>在上述实现中，除了应用 Trie 数据结构外，我们还应用了一些技巧来进一步加快运行时间。特别是，Python 实现的运行速度可以超过 98% 的提交。我们按其重要性将这些技巧详述如下。</p><ul><li>沿着 Trie 的节点回溯。</li></ul><p>人们可以简单地使用 Trie 作为字典来快速找到单词和前缀的匹配，即在回溯的每一步，我们都从Trie 的根开始。</p><p>然而，更有效的方法是将 Trie 与回溯过程一起遍历，即每一步 <code>backtracking(TrieNode)</code>，<code>TrieNode</code> 的深度对应于我们到目前为止匹配的前缀的长度。这项措施可以将您的解决方案从提交的最低 <em>5%</em> 中脱颖出来。</p><ul><li>在回溯过程中逐渐剪除 Trie 中的节点（剪枝）。</li></ul><p>这个想法的动机是整个算法的时间复杂度取决于 Trie 的大小。对于 Trie 中的叶节点，一旦遍历它（即找到匹配的单词），就不需要再遍历它了。结果，我们可以把它从树上剪下来。</p><p>逐渐地，这些非叶节点可以成为叶节点以后，因为我们修剪他们的孩子叶节点。在极端情况下，一旦我们找到字典中所有单词的匹配项，Trie 就会变成空的。这个剪枝措施可以减少在线测试用例 50% 的运行时间。</p><p> <a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl90cmllX3BydW5lLnBuZw?x-oss-process=image/format,png" target="_blank" rel="noopener">剪枝</a></p><ul><li>从 Trie 中删除匹配的单词。</li></ul><p>在这个问题中，我们被要求返回所有匹配的单词，而不是潜在匹配的数量。因此，一旦到达包含单词匹配的特定 Trie 节点，我们就可以从 Trie 中删除匹配单词。</p><p>作为附带好处，我们不需要检查结果集中是否有任何重复项。因此，我们可以简单地使用一个列表而不是集合来保存结果，这样可以加快解决方案的速度。</p><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>\mathcal{O}(M(4\cdot3^{L-1}))<em>，其中</em>M</em> 是二维网格中的单元格数，<em>L</em> 是单词的最大长度。</p><ul><li>计算回溯算法将执行的确切步数是一个棘手的问题。我们为这个问题的最坏情况提供了该步骤的上限。该算法循环遍历二维网格中的所有单元，因此在复杂度公式中我们有 <em>M</em> 作为因子。然后将其归结为每个启动单元所需的最大步骤数（即 <em>4\cdot3^{L-1}</em>）。</li><li>假设单词的最大长度是 <em>L</em>，从一个单元格开始，最初我们最多可以探索 4 个方向。假设每个方向都是有效的（即最坏情况），在接下来的探索中，我们最多有 3 个相邻的单元（不包括我们来的单元）要探索。因此，在回溯探索期间，我们最多遍历 <em>4\cdot3^{L-1}</em> 个单元格。</li><li>你可能会想最坏的情况是什么样子。这里有一个例子。想象一下，二维网格中的每个单元都包含字母 <code>a</code>，单词词典包含一个单词 <code>[&#39;aaaa&#39;]</code>。这是算法将遇到的最坏的情况之一。</li></ul><p><a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9jb21wbGV4aXR5X2V4YW1wbGUucG5n?x-oss-process=image/format,png" target="_blank" rel="noopener">最坏的情况</a></p></li></ul><p>注意，上述时间复杂性是在 Trie 数据结构一旦构建就不会改变的假设下估计的。如果采用优化策略逐步删除 Trie 中的节点，则可以大大提高时间复杂度，因为一旦匹配词典中的所有单词，即 Trie 变为空，回溯的成本就会降低到零。 </p><ul><li>空间复杂度：<em>\mathcal{O}(N)*，其中 *N</em> 是字典中的字母总数。<ul><li>算法消耗的主要空间是我们构建的 Trie 数据结构。在最坏的情况下，如果单词之间没有前缀重叠，则 Trie 将拥有与所有单词的字母一样多的节点。也可以选择在 Trie 中保留单词的副本。因此，我们可能需要 *2N$ 的空间用于 Trie。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个二维网格board和一个字典中的单词列表 words，找出所有同时在二维网格和字典中出现的单词。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Trie" scheme="http://yoursite.com/tags/Trie/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Java编程思想-第二十三章 注解阅读笔记</title>
    <link href="http://yoursite.com/2020/06/28/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%89%E7%AB%A0%20%E6%B3%A8%E8%A7%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/06/28/Java编程思想-第二十三章 注解阅读笔记/</id>
    <published>2020-06-28T02:59:12.000Z</published>
    <updated>2020-06-29T06:23:06.841Z</updated>
    
    <content type="html"><![CDATA[<p>接口和抽象类提供了一种将接口与实现分离的更加结构化的方法。</p><a id="more"></a><p>[TOC]</p><!-- Annotations --><h1 id="第二十三章-注解"><a href="#第二十三章-注解" class="headerlink" title="第二十三章 注解"></a>第二十三章 注解</h1><p>注解（也被称为元数据）为我们在代码中添加信息提供了一种形式化的方式，使我们可以在稍后的某个时刻更容易的使用这些数据。</p><p>注解在一定程度上是把元数据和源代码文件结合在一起的趋势所激发的，而不是保存在外部文档。这同样是对像 C# 语言对于 Java 语言特性压力的一种回应。</p><p>注解是 Java 5 所引入的众多语言变化之一。它们提供了 Java 无法表达的但是你需要完整表述程序所需的信息。因此，注解使得我们可以以编译器验证的格式存储程序的额外信息。注解可以生成描述符文件，甚至是新的类定义，并且有助于减轻编写“样板”代码的负担。通过使用注解，你可以将元数据保存在 Java 源代码中。并拥有如下优势：简单易读的代码，编译器类型检查，使用 annotation API 为自己的注解构造处理工具。即使 Java 定义了一些类型的元数据，但是一般来说注解类型的添加和如何使用完全取决于你。</p><p>注解的语法十分简单，主要是在现有语法中添加 @ 符号。Java 5 引入了前三种定义在 <strong>java.lang</strong> 包中的注解：</p><ul><li><strong>@Override</strong>：表示当前的方法定义将覆盖基类的方法。如果你不小心拼写错误，或者方法签名被错误拼写的时候，编译器就会发出错误提示。</li><li><strong>@Deprecated</strong>：如果使用该注解的元素被调用，编译器就会发出警告信息。</li><li><strong>@SuppressWarnings</strong>：关闭不当的编译器警告信息。</li><li><strong>@SafeVarargs</strong>：在 Java 7 中加入用于禁止对具有泛型varargs参数的方法或构造函数的调用方发出警告。</li><li><strong>@FunctionalInterface</strong>：Java 8 中加入用于表示类型声明为函数式接口</li></ul><p>还有 5 种额外的注解类型用于创造新的注解。你将会在这一章学习它们。</p><p>每当创建涉及重复工作的类或接口时，你通常可以使用注解来自动化和简化流程。例如在 Enterprise JavaBean（EJB）中的许多额外工作就是通过注解来消除的。</p><p>注解的出现可以替代一些现有的系统，例如 XDoclet，它是一种独立的文档化工具，专门设计用来生成注解风格的文档。与之相比，注解是真正语言层级的概念，以前构造出来就享有编译器的类型检查保护。注解在源代码级别保存所有信息而不是通过注释文字，这使得代码更加整洁和便于维护。通过使用拓展的 annotation API 或稍后在本章节可以看到的外部的字节码工具类库，你会拥有对源代码及字节码强大的检查与操作能力。</p><!-- Basic Syntax --><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><!-- Writing Annotation Processors --><p>在下面的例子中，使用 <code>@Test</code> 对 <code>testExecute()</code> 进行注解。该注解本身不做任何事情，但是编译器要保证其类路径上有 <code>@Test</code> 注解的定义。你将在本章看到，我们通过注解创建了一个工具用于运行这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/Testable.java</span></span><br><span class="line"><span class="keyword">package</span> annotations;</span><br><span class="line"><span class="keyword">import</span> onjava.atunit.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Testable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Executing.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testExecute</span><span class="params">()</span> </span>&#123; execute(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被注解标注的方法和其他的方法没有任何区别。在这个例子中，注解 <code>@Test</code> 可以和任何修饰符共同用于方法，诸如 <strong>public</strong>、<strong>static</strong> 或 <strong>void</strong>。从语法的角度上看，注解的使用方式和修饰符的使用方式一致。</p><h3 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h3><p>如下是一个注解的定义。注解的定义看起来很像接口的定义。事实上，它们和其他 Java 接口一样，也会被编译成 class 文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/atunit/Test.java</span></span><br><span class="line"><span class="comment">// The @Test tag</span></span><br><span class="line"><span class="keyword">package</span> onjava.atunit;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test &#123;&#125;</span><br></pre></td></tr></table></figure><p>除了 @ 符号之外， <code>@Test</code> 的定义看起来更像一个空接口。注解的定义也需要一些元注解（meta-annoation），比如 <code>@Target</code> 和 <code>@Retention</code>。<code>@Target</code> 定义你的注解可以应用在哪里（例如是方法还是字段）。<code>@Retention</code> 定义了注解在哪里可用，在源代码中（SOURCE），class文件（CLASS）中或者是在运行时（RUNTIME）。</p><p>注解通常会包含一些表示特定值的元素。当分析处理注解的时候，程序或工具可以利用这些值。注解的元素看起来就像接口的方法，但是可以为其指定默认值。</p><p>不包含任何元素的注解称为标记注解（marker annotation），例如上例中的 <code>@Test</code> 就是标记注解。</p><p>下面是一个简单的注解，我们可以用它来追踪项目中的用例。程序员可以使用该注解来标注满足特定用例的一个方法或者一组方法。于是，项目经理可以通过统计已经实现的用例来掌控项目的进展，而开发者在维护项目时可以轻松的找到用例用于更新，或者他们可以调试系统中业务逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/UseCase.java</span></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> UseCase &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">description</span><span class="params">()</span> <span class="keyword">default</span> "no description"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 <strong>id</strong> 和 <strong>description</strong> 与方法定义类似。由于编译器会对 <strong>id</strong> 进行类型检查，因此将跟踪数据库与用例文档和源代码相关联是可靠的方式。<strong>description</strong> 元素拥有一个 <strong>default</strong> 值，如果在注解某个方法时没有给出 <strong>description</strong> 的值。则该注解的处理器会使用此元素的默认值。</p><p>在下面的类中，有三个方法被注解为用例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/PasswordUtils.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PasswordUtils</span> </span>&#123;</span><br><span class="line">    <span class="meta">@UseCase</span>(id = <span class="number">47</span>, description =</span><br><span class="line">            <span class="string">"Passwords must contain at least one numeric"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validatePassword</span><span class="params">(String passwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (passwd.matches(<span class="string">"\\w*\\d\\w*"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@UseCase</span>(id = <span class="number">48</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">encryptPassword</span><span class="params">(String passwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(passwd)</span><br><span class="line">                .reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@UseCase</span>(id = <span class="number">49</span>, description =</span><br><span class="line">            <span class="string">"New passwords can't equal previously used ones"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkForNewPassword</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            List&lt;String&gt; prevPasswords, String passwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !prevPasswords.contains(passwd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解的元素在使用时表现为 名-值 对的形式，并且需要放置在 <code>@UseCase</code> 声明之后的括号内。在 <code>encryptPassword()</code> 方法的注解中，并没有给出 <strong>description</strong> 的值，所以在 <strong>@interface UseCase</strong> 的注解处理器分析处理这个类的时候会使用该元素的默认值。</p><p>你应该能够想象到如何使用这套工具来“勾勒”出将要建造的系统，然后在建造的过程中逐渐实现系统的各项功能。</p><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>Java 语言中目前有 5 种标准注解（前面介绍过），以及 5 种元注解。元注解用于注解其他的注解</p><table><thead><tr><th>注解</th><th>解释</th></tr></thead><tbody><tr><td>@Target</td><td>表示注解可以用于哪些地方。可能的 <strong>ElementType</strong> 参数包括：<br><strong>CONSTRUCTOR</strong>：构造器的声明<br><strong>FIELD</strong>：字段声明（包括 enum 实例）<br><strong>LOCAL_VARIABLE</strong>：局部变量声明<br><strong>METHOD</strong>：方法声明<br><strong>PACKAGE</strong>：包声明<br><strong>PARAMETER</strong>：参数声明<br><strong>TYPE</strong>：类、接口（包括注解类型）或者 enum 声明</td></tr><tr><td>@Retention</td><td>表示注解信息保存的时长。可选的 <strong>RetentionPolicy</strong> 参数包括：<br><strong>SOURCE</strong>：注解将被编译器丢弃<br><strong>CLASS</strong>：注解在 class 文件中可用，但是会被 VM 丢弃。<br><strong>RUNTIME</strong>：VM 将在运行期也保留注解，因此可以通过反射机制读取注解的信息。</td></tr><tr><td>@Documented</td><td>将此注解保存在 Javadoc 中</td></tr><tr><td>@Inherited</td><td>允许子类继承父类的注解</td></tr><tr><td>@Repeatable</td><td>允许一个注解可以被使用一次或者多次（Java 8）。</td></tr></tbody></table><p>大多数时候，程序员定义自己的注解，并编写自己的处理器来处理他们。</p><h2 id="编写注解处理器"><a href="#编写注解处理器" class="headerlink" title="编写注解处理器"></a>编写注解处理器</h2><p>如果没有用于读取注解的工具，那么注解不会比注释更有用。使用注解中一个很重要的部分就是，创建与使用注解处理器。Java 拓展了反射机制的 API 用于帮助你创造这类工具。同时他还提供了 javac 编译器钩子在编译时使用注解。</p><p>下面是一个非常简单的注解处理器，我们用它来读取被注解的 <strong>PasswordUtils</strong> 类，并且使用反射机制来寻找 <strong>@UseCase</strong> 标记。给定一组 <strong>id</strong> 值，然后列出在 <strong>PasswordUtils</strong> 中找到的用例，以及缺失的用例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/UseCaseTracker.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseCaseTracker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">    trackUseCases(List&lt;Integer&gt; useCases, Class&lt;?&gt; cl) &#123;</span><br><span class="line">        <span class="keyword">for</span>(Method m : cl.getDeclaredMethods()) &#123;</span><br><span class="line">            UseCase uc = m.getAnnotation(UseCase.class);</span><br><span class="line">            <span class="keyword">if</span>(uc != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Found Use Case "</span> +</span><br><span class="line">                        uc.id() + <span class="string">"\n "</span> + uc.description());</span><br><span class="line">                useCases.remove(Integer.valueOf(uc.id()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        useCases.forEach(i -&gt;</span><br><span class="line">                System.out.println(<span class="string">"Missing use case "</span> + i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; useCases = IntStream.range(<span class="number">47</span>, <span class="number">51</span>)</span><br><span class="line">                .boxed().collect(Collectors.toList());</span><br><span class="line">        trackUseCases(useCases, PasswordUtils.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Found Use Case <span class="number">48</span></span><br><span class="line">no description</span><br><span class="line">Found Use Case <span class="number">47</span></span><br><span class="line">Passwords must contain at least one numeric</span><br><span class="line">Found Use Case <span class="number">49</span></span><br><span class="line">New passwords can<span class="string">'t equal previously used ones</span></span><br><span class="line"><span class="string">Missing use case 50</span></span><br></pre></td></tr></table></figure><p>这个程序用了两个反射的方法：<code>getDeclaredMethods()</code>  和 <code>getAnnotation()</code>，它们都属于 <strong>AnnotatedElement</strong> 接口（<strong>Class</strong>，<strong>Method</strong> 与 <strong>Field</strong> 类都实现了该接口）。<code>getAnnotation()</code> 方法返回指定类型的注解对象，在本例中就是 “<strong>UseCase</strong>”。如果被注解的方法上没有该类型的注解，返回值就为 <strong>null</strong>。我们通过调用 <code>id()</code> 和 <code>description()</code> 方法来提取元素值。注意 <code>encryptPassword()</code> 方法在注解的时候没有指定 <strong>description</strong> 的值，因此处理器在处理它对应的注解时，通过 <code>description()</code> 取得的是默认值 “no description”。</p><h3 id="注解元素"><a href="#注解元素" class="headerlink" title="注解元素"></a>注解元素</h3><p>在 <strong>UseCase.java</strong> 中定义的 <strong>@UseCase</strong> 的标签包含 int 元素 <strong>id</strong> 和 String 元素 <strong>description</strong>。注解元素可用的类型如下所示：</p><ul><li>所有基本类型（int、float、boolean等）</li><li>String</li><li>Class</li><li>enum</li><li>Annotation</li><li>以上类型的数组</li></ul><p>如果你使用了其他类型，编译器就会报错。注意，也不允许使用任何包装类型，但是由于自动装箱的存在，这不算是什么限制。注解也可以作为元素的类型。稍后你会看到，注解嵌套是一个非常有用的技巧。</p><h3 id="默认值限制"><a href="#默认值限制" class="headerlink" title="默认值限制"></a>默认值限制</h3><p>编译器对于元素的默认值有些过于挑剔。首先，元素不能有不确定的值。也就是说，元素要么有默认值，要么就在使用注解时提供元素的值。</p><p>这里有另外一个限制：任何非基本类型的元素， 无论是在源代码声明时还是在注解接口中定义默认值时，都不能使用 null 作为其值。这个限制使得处理器很难表现一个元素的存在或者缺失的状态，因为在每个注解的声明中，所有的元素都存在，并且具有相应的值。为了绕开这个约束，可以自定义一些特殊的值，比如空字符串或者负数用于表达某个元素不存在。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/SimulatingNull.java</span></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SimulatingNull &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line">    <span class="function">String <span class="title">description</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个在定义注解的习惯用法。</p><h3 id="生成外部文件"><a href="#生成外部文件" class="headerlink" title="生成外部文件"></a>生成外部文件</h3><p>当有些框架需要一些额外的信息才能与你的源代码协同工作，这种情况下注解就会变得十分有用。像 Enterprise JavaBeans (EJB3 之前)这样的技术，每一个 Bean 都需要需要大量的接口和部署描述文件，而这些就是“样板”文件。Web Service，自定义标签库以及对象/关系映射工具（例如 Toplink 和 Hibernate）通常都需要 XML 描述文件，而这些文件脱离于代码之外。除了定义 Java 类，程序员还必须忍受沉闷，重复的提供某些信息，例如类名和包名等已经在原始类中已经提供的信息。每当你使用外部描述文件时，他就拥有了一个类的两个独立信息源，这经常导致代码的同步问题。同时这也要求了为项目工作的程序员在知道如何编写 Java 程序的同时，也必须知道如何编辑描述文件。</p><p>假设你想提供一些基本的对象/关系映射功能，能够自动生成数据库表。你可以使用 XML 描述文件来指明类的名字、每个成员以及数据库映射的相关信息。但是，通过使用注解，你可以把所有信息都保存在 <strong>JavaBean</strong> 源文件中。为此你需要一些用于定义数据库表名称、数据库列以及将 SQL 类型映射到属性的注解。</p><p>以下是一个注解的定义，它告诉注解处理器应该创建一个数据库表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/database/DBTable.java</span></span><br><span class="line"><span class="keyword">package</span> annotations.database;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE) <span class="comment">// Applies to classes only</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DBTable &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>@Target</code> 注解中指定的每一个 <strong>ElementType</strong> 就是一个约束，它告诉编译器，这个自定义的注解只能用于指定的类型。你可以指定 <strong>enum ElementType</strong> 中的一个值，或者以逗号分割的形式指定多个值。如果想要将注解应用于所有的 <strong>ElementType</strong>，那么可以省去 <code>@Target</code> 注解，但是这并不常见。</p><p>注意 <strong>@DBTable</strong> 中有一个 <code>name()</code> 元素，该注解通过这个元素为处理器创建数据库时提供表的名字。</p><p>如下是修饰字段的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/database/Constraints.java</span></span><br><span class="line"><span class="keyword">package</span> annotations.database;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Constraints &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">primaryKey</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">allowNull</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">unique</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/database/SQLString.java</span></span><br><span class="line"><span class="keyword">package</span> annotations.database;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SQLString &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">Constraints <span class="title">constraints</span><span class="params">()</span> <span class="keyword">default</span> @Constraints</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/database/SQLInteger.java</span></span><br><span class="line"><span class="keyword">package</span> annotations.database;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SQLInteger &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">Constraints <span class="title">constraints</span><span class="params">()</span> <span class="keyword">default</span> @Constraints</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@Constraints</strong> 注解允许处理器提供数据库表的元数据。<strong>@Constraints</strong> 代表了数据库通常提供的约束的一小部分，但是它所要表达的思想已经很清楚了。<code>primaryKey()</code>，<code>allowNull()</code> 和 <code>unique()</code> 元素明显的提供了默认值，从而使得在大多数情况下，该注解的使用者不需要输入太多东西。</p><p>另外两个 <strong>@interface</strong> 定义的是 SQL 类型。如果希望这个框架更有价值的话，我们应该为每个 SQL 类型都定义相应的注解。不过为为示例，两个元素足够了。</p><p>这些 SQL 类型具有 <code>name()</code> 元素和 <code>constraints()</code> 元素。后者利用了嵌套注解的功能，将数据库列的类型约束信息嵌入其中。注意 <code>constraints()</code> 元素的默认值是 <strong>@Constraints</strong>。由于在 <strong>@Constraints</strong> 注解类型之后，没有在括号中指明 <strong>@Constraints</strong> 元素的值，因此，<strong>constraints()</strong> 的默认值为所有元素都为默认值的 <strong>@Constraints</strong> 注解。如果要使得嵌入的  <strong>@Constraints</strong>  注解中的 <code>unique()</code> 元素为 true，并作为 <code>constraints()</code> 元素的默认值，你可以像如下定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/database/Uniqueness.java</span></span><br><span class="line"><span class="comment">// Sample of nested annotations</span></span><br><span class="line"><span class="keyword">package</span> annotations.database;</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Uniqueness &#123;</span><br><span class="line">    <span class="function">Constraints <span class="title">constraints</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="keyword">default</span> @<span class="title">Constraints</span><span class="params">(unique = <span class="keyword">true</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个简单的，使用了如上注解的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/database/Member.java</span></span><br><span class="line"><span class="keyword">package</span> annotations.database;</span><br><span class="line"><span class="meta">@DBTable</span>(name = <span class="string">"MEMBER"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SQLString</span>(<span class="number">30</span>) String firstName;</span><br><span class="line">    <span class="meta">@SQLString</span>(<span class="number">50</span>) String lastName;</span><br><span class="line">    <span class="meta">@SQLInteger</span> Integer age;</span><br><span class="line">    <span class="meta">@SQLString</span>(value = <span class="number">30</span>,</span><br><span class="line">            constraints = <span class="meta">@Constraints</span>(primaryKey = <span class="keyword">true</span>))</span><br><span class="line">    String reference;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> memberCount;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getReference</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> reference; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> firstName; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> lastName; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> reference; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类注解 <strong>@DBTable</strong> 注解给定了元素值 MEMBER，它将会作为标的名字。类的属性 <strong>firstName</strong> 和 <strong>lastName</strong> 都被注解为 <strong>@SQLString</strong> 类型并且给了默认元素值分别为 30 和 50。这些注解都有两个有趣的地方：首先，他们都使用了嵌入的 <strong>@Constraints</strong> 注解的默认值；其次，它们都是用了快捷方式特性。如果你在注解中定义了名为 <strong>value</strong> 的元素，并且在使用该注解时，<strong>value</strong> 为唯一一个需要赋值的元素，你就不需要使用名—值对的语法，你只需要在括号中给出 <strong>value</strong> 元素的值即可。这可以应用于任何合法类型的元素。这也限制了你必须将元素命名为 <strong>value</strong>，不过在上面的例子中，这样的注解语句也更易于理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SQLString</span>(<span class="number">30</span>)</span><br></pre></td></tr></table></figure><p>处理器将在创建表的时候使用该值设置 SQL 列的大小。</p><p>默认值的语法虽然很灵巧，但是它很快就变的复杂起来。以 <strong>reference</strong> 字段的注解为例，上面拥有 <strong>@SQLString</strong> 注解，但是这个字段也将成为表的主键，因此在嵌入的 <strong>@Constraint</strong> 注解中设定 <strong>primaryKey</strong> 元素的值。这时事情就变的复杂了。你不得不为这个嵌入的注解使用很长的键—值对的形式，来指定元素名称和 <strong>@interface</strong> 的名称。同时，由于有特殊命名的 <strong>value</strong> 也不是唯一需要赋值的元素，因此不能再使用快捷方式特性。如你所见，最终结果不算清晰易懂。</p><h3 id="替代方案"><a href="#替代方案" class="headerlink" title="替代方案"></a>替代方案</h3><p>可以使用多种不同的方式来定义自己的注解用于上述任务。例如，你可以使用一个单一的注解类 <strong>@TableColumn</strong>，它拥有一个 <strong>enum</strong> 元素，元素值定义了 <strong>STRING</strong>，<strong>INTEGER</strong>，<strong>FLOAT</strong> 等类型。这消除了每个 SQL 类型都需要定义一个 <strong>@interface</strong> 的负担，不过也使得用额外信息修饰 SQL 类型变的不可能，这些额外的信息例如长度或精度等，都可能是非常有用的。</p><p>你也可以使用一个 <strong>String</strong> 类型的元素来描述实际的 SQL 类型，比如 “VARCHAR(30)” 或者 “INTEGER”。这使得你可以修饰 SQL 类型，但是这也将 Java 类型到 SQL 类型的映射绑在了一起，这不是一个好的设计。你并不想在数据库更改之后重新编译你的代码；如果我们只需要告诉注解处理器，我们正在使用的是什么“口味（favor）”的 SQL，然后注解助力器来为我们处理 SQL 类型的细节，那将是一个优雅的设计。</p><p>第三种可行的方案是一起使用两个注解，<strong>@Constraints</strong> 和相应的 SQL 类型（例如，<strong>@SQLInteger</strong>）去注解同一个字段。这可能会让代码有些混乱，但是编译器允许你对同一个目标使用多个注解。在 Java 8，在使用多个注解的时候，你可以重复使用同一个注解。</p><h3 id="注解不支持继承"><a href="#注解不支持继承" class="headerlink" title="注解不支持继承"></a>注解不支持继承</h3><p>你不能使用 <strong>extends</strong> 关键字来继承 <strong>@interfaces</strong>。这真是一个遗憾，如果可以定义 <strong>@TableColumn</strong> 注解（参考前面的建议），同时嵌套一个 <strong>@SQLType</strong> 类型的注解，将成为一个优雅的设计。按照这种方式，你可以通过继承 <strong>@SQLType</strong> 来创造各种 SQL 类型。例如 <strong>@SQLInteger</strong> 和 <strong>@SQLString</strong>。如果支持继承，就会大大减少打字的工作量并且使得语法更整洁。在 Java 的未来版本中，似乎没有任何关于让注解支持继承的提案，所以在当前情况下，上例中的解决方案可能已经是最佳方案了。</p><h3 id="实现处理器"><a href="#实现处理器" class="headerlink" title="实现处理器"></a>实现处理器</h3><p>下面是一个注解处理器的例子，他将读取一个类文件，检查上面的数据库注解，并生成用于创建数据库的 SQL 命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/database/TableCreator.java</span></span><br><span class="line"><span class="comment">// Reflection-based annotation processor</span></span><br><span class="line"><span class="comment">// &#123;java annotations.database.TableCreator</span></span><br><span class="line"><span class="comment">// annotations.database.Member&#125;</span></span><br><span class="line"><span class="keyword">package</span> annotations.database;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TableCreator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">    main(String[] args) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(</span><br><span class="line">                    <span class="string">"arguments: annotated classes"</span>);</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String className : args) &#123;</span><br><span class="line">            Class&lt;?&gt; cl = Class.forName(className);</span><br><span class="line">            DBTable dbTable = cl.getAnnotation(DBTable.class);</span><br><span class="line">            <span class="keyword">if</span> (dbTable == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(</span><br><span class="line">                        <span class="string">"No DBTable annotations in class "</span> +</span><br><span class="line">                                className);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String tableName = dbTable.name();</span><br><span class="line">            <span class="comment">// If the name is empty, use the Class name:</span></span><br><span class="line">            <span class="keyword">if</span> (tableName.length() &lt; <span class="number">1</span>)</span><br><span class="line">                tableName = cl.getName().toUpperCase();</span><br><span class="line">            List&lt;String&gt; columnDefs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (Field field : cl.getDeclaredFields()) &#123;</span><br><span class="line">                String columnName = <span class="keyword">null</span>;</span><br><span class="line">                Annotation[] anns =</span><br><span class="line">                        field.getDeclaredAnnotations();</span><br><span class="line">                <span class="keyword">if</span> (anns.length &lt; <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// Not a db table column</span></span><br><span class="line">                <span class="keyword">if</span> (anns[<span class="number">0</span>] <span class="keyword">instanceof</span> SQLInteger) &#123;</span><br><span class="line">                    SQLInteger sInt = (SQLInteger) anns[<span class="number">0</span>];</span><br><span class="line">                    <span class="comment">// Use field name if name not specified</span></span><br><span class="line">                    <span class="keyword">if</span> (sInt.name().length() &lt; <span class="number">1</span>)</span><br><span class="line">                        columnName = field.getName().toUpperCase();</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        columnName = sInt.name();</span><br><span class="line">                    columnDefs.add(columnName + <span class="string">" INT"</span> +</span><br><span class="line">                            getConstraints(sInt.constraints()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (anns[<span class="number">0</span>] <span class="keyword">instanceof</span> SQLString) &#123;</span><br><span class="line">                    SQLString sString = (SQLString) anns[<span class="number">0</span>];</span><br><span class="line">                    <span class="comment">// Use field name if name not specified.</span></span><br><span class="line">                    <span class="keyword">if</span> (sString.name().length() &lt; <span class="number">1</span>)</span><br><span class="line">                        columnName = field.getName().toUpperCase();</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        columnName = sString.name();</span><br><span class="line">                    columnDefs.add(columnName + <span class="string">" VARCHAR("</span> +</span><br><span class="line">                            sString.value() + <span class="string">")"</span> +</span><br><span class="line">                            getConstraints(sString.constraints()));</span><br><span class="line">                &#125;</span><br><span class="line">                StringBuilder createCommand = <span class="keyword">new</span> StringBuilder(</span><br><span class="line">                        <span class="string">"CREATE TABLE "</span> + tableName + <span class="string">"("</span>);</span><br><span class="line">                <span class="keyword">for</span> (String columnDef : columnDefs)</span><br><span class="line">                    createCommand.append(</span><br><span class="line">                            <span class="string">"\n "</span> + columnDef + <span class="string">","</span>);</span><br><span class="line">                <span class="comment">// Remove trailing comma</span></span><br><span class="line">                String tableCreate = createCommand.substring(</span><br><span class="line">                        <span class="number">0</span>, createCommand.length() - <span class="number">1</span>) + <span class="string">");"</span>;</span><br><span class="line">                System.out.println(<span class="string">"Table Creation SQL for "</span> +</span><br><span class="line">                        className + <span class="string">" is:\n"</span> + tableCreate);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getConstraints</span><span class="params">(Constraints con)</span> </span>&#123;</span><br><span class="line">        String constraints = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span> (!con.allowNull())</span><br><span class="line">            constraints += <span class="string">" NOT NULL"</span>;</span><br><span class="line">        <span class="keyword">if</span> (con.primaryKey())</span><br><span class="line">            constraints += <span class="string">" PRIMARY KEY"</span>;</span><br><span class="line">        <span class="keyword">if</span> (con.unique())</span><br><span class="line">            constraints += <span class="string">" UNIQUE"</span>;</span><br><span class="line">        <span class="keyword">return</span> constraints;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Table Creation SQL for annotations.database.Member is:</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">MEMBER</span>(</span><br><span class="line">    FIRSTNAME <span class="built_in">VARCHAR</span>(<span class="number">30</span>));</span><br><span class="line">Table Creation SQL for annotations.database.Member is:</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">MEMBER</span>(</span><br><span class="line">    FIRSTNAME <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">    LASTNAME <span class="built_in">VARCHAR</span>(<span class="number">50</span>));</span><br><span class="line">Table Creation SQL for annotations.database.Member is:</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">MEMBER</span>(</span><br><span class="line">    FIRSTNAME <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">    LASTNAME <span class="built_in">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    AGE <span class="built_in">INT</span>);</span><br><span class="line">Table Creation SQL for annotations.database.Member is:</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">MEMBER</span>(</span><br><span class="line">    FIRSTNAME <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">    LASTNAME <span class="built_in">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    AGE <span class="built_in">INT</span>,</span><br><span class="line">    <span class="keyword">REFERENCE</span> <span class="built_in">VARCHAR</span>(<span class="number">30</span>) PRIMARY <span class="keyword">KEY</span>);</span><br></pre></td></tr></table></figure><p>主方法会循环处理命令行传入的每一个类名。每一个类都是用 <code>forName()</code> 方法进行加载，并使用 <code>getAnnotation(DBTable.class)</code> 来检查该类是否带有 <strong>@DBTable</strong> 注解。如果存在，将表名存储起来。然后读取这个类的所有字段，并使用 <code>getDeclaredAnnotations()</code> 进行检查。这个方法返回一个包含特定字段上所有注解的数组。然后使用 <strong>instanceof</strong> 操作符判断这些注解是否是 <strong>@SQLInteger</strong> 或者 <strong>@SQLString</strong> 类型。如果是的话，在对应的处理块中将构造出相应的数据库列的字符串片段。注意，由于注解没有继承机制，如果要获取近似多态的行为，使用 <code>getDeclaredAnnotations()</code> 似乎是唯一的方式。</p><p>嵌套的 <strong>@Constraint</strong> 注解被传递给 <code>getConstraints()</code>方法，并用它来构造一个包含 SQL 约束的 String 对象。</p><p>需要提醒的是，上面演示的技巧对于真实的对象/映射关系而言，是十分幼稚的。使用 <strong>@DBTable</strong> 的注解来获取表的名称，这使得如果要修改表的名字，则迫使你重新编译 Java 代码。这种效果并不理想。现在已经有了很多可用的框架，用于将对象映射到数据库中，并且越来越多的框架开始使用注解了。</p><!-- Using javac to Process Annotations --><h2 id="使用javac处理注解"><a href="#使用javac处理注解" class="headerlink" title="使用javac处理注解"></a>使用javac处理注解</h2><p>通过 <strong>javac</strong>，你可以通过创建编译时（compile-time）注解处理器在 Java 源文件上使用注解，而不是编译之后的 class 文件。但是这里有一个重大限制：你不能通过处理器来改变源代码。唯一影响输出的方式就是创建新的文件。</p><p>如果你的注解处理器创建了新的源文件，在新一轮处理中注解会检查源文件本身。工具在检测一轮之后持续循环，直到不再有新的源文件产生。然后它编译所有的源文件。</p><p>每一个你编写的注解都需要处理器，但是 <strong>javac</strong> 可以非常容易的将多个注解处理器合并在一起。你可以指定多个需要处理的类，并且你可以添加监听器用于监听注解处理完成后接到通知。</p><p>本节中的示例将帮助你开始学习，但如果你必须深入学习，请做好反复学习，大量访问 Google 和StackOverflow 的准备。</p><h3 id="最简单的处理器"><a href="#最简单的处理器" class="headerlink" title="最简单的处理器"></a>最简单的处理器</h3><p>让我们开始定义我们能想到的最简单的处理器，只是为了编译和测试。如下是注解的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/simplest/Simple.java</span></span><br><span class="line"><span class="comment">// A bare-bones annotation</span></span><br><span class="line"><span class="keyword">package</span> annotations.simplest;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD,</span><br><span class="line">        ElementType.CONSTRUCTOR,</span><br><span class="line">        ElementType.ANNOTATION_TYPE,</span><br><span class="line">        ElementType.PACKAGE, ElementType.FIELD,</span><br><span class="line">        ElementType.LOCAL_VARIABLE&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Simple &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> "-<span class="keyword">default</span>-"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@Retention</strong> 的参数现在为 <strong>SOURCE</strong>，这意味着注解不会再存留在编译后的代码。这在编译时处理注解是没有必要的，它只是指出，在这里，<strong>javac</strong> 是唯一有机会处理注解的代理。</p><p><strong>@Target</strong> 声明了几乎所有的目标类型（除了 <strong>PACKAGE</strong>） ，同样是为了演示。下面是一个测试示例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/simplest/SimpleTest.java</span></span><br><span class="line"><span class="comment">// Test the "Simple" annotation</span></span><br><span class="line"><span class="comment">// &#123;java annotations.simplest.SimpleTest&#125;</span></span><br><span class="line"><span class="keyword">package</span> annotations.simplest;</span><br><span class="line"><span class="meta">@Simple</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Simple</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="meta">@Simple</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleTest</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Simple</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SimpleTest.foo()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Simple</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(String s, <span class="keyword">int</span> i, <span class="keyword">float</span> f)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SimpleTest.bar()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Simple</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Simple</span></span><br><span class="line">        SimpleTest st = <span class="keyword">new</span> SimpleTest();</span><br><span class="line">        st.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SimpleTest.foo()</span><br></pre></td></tr></table></figure><p>在这里我们使用 <strong>@Simple</strong> 注解了所有 <strong>@Target</strong> 声明允许的地方。</p><p><strong>SimpleTest.java</strong> 只需要 <strong>Simple.java</strong> 就可以编译成功。当我们编译的时候什么都没有发生。</p><p><strong>javac</strong> 允许 <strong>@Simple</strong> 注解（只要它存在）在我们创建处理器并将其 hook 到编译器之前，不做任何事情。</p><p>如下是一个十分简单的处理器，其所作的事情就是把注解相关的信息打印出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/simplest/SimpleProcessor.java</span></span><br><span class="line"><span class="comment">// A bare-bones annotation processor</span></span><br><span class="line"><span class="keyword">package</span> annotations.simplest;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.processing.*;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.SourceVersion;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="meta">@SupportedAnnotationTypes</span>(</span><br><span class="line">        <span class="string">"annotations.simplest.Simple"</span>)</span><br><span class="line"><span class="meta">@SupportedSourceVersion</span>(SourceVersion.RELEASE_8)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleProcessor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Set&lt;? extends TypeElement&gt; annotations,</span></span></span><br><span class="line"><span class="function"><span class="params">            RoundEnvironment env)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(TypeElement t : annotations)</span><br><span class="line">            System.out.println(t);</span><br><span class="line">        <span class="keyword">for</span>(Element el :</span><br><span class="line">                env.getElementsAnnotatedWith(Simple.class))</span><br><span class="line">            display(el);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Element el)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==== "</span> + el + <span class="string">" ===="</span>);</span><br><span class="line">        System.out.println(el.getKind() +</span><br><span class="line">                <span class="string">" : "</span> + el.getModifiers() +</span><br><span class="line">                <span class="string">" : "</span> + el.getSimpleName() +</span><br><span class="line">                <span class="string">" : "</span> + el.asType());</span><br><span class="line">        <span class="keyword">if</span>(el.getKind().equals(ElementKind.CLASS)) &#123;</span><br><span class="line">            TypeElement te = (TypeElement)el;</span><br><span class="line">            System.out.println(te.getQualifiedName());</span><br><span class="line">            System.out.println(te.getSuperclass());</span><br><span class="line">            System.out.println(te.getEnclosedElements());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(el.getKind().equals(ElementKind.METHOD)) &#123;</span><br><span class="line">            ExecutableElement ex = (ExecutableElement)el;</span><br><span class="line">            System.out.print(ex.getReturnType() + <span class="string">" "</span>);</span><br><span class="line">            System.out.print(ex.getSimpleName() + <span class="string">"("</span>);</span><br><span class="line">            System.out.println(ex.getParameters() + <span class="string">")"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（旧的，失效的）<strong>apt</strong> 版本的处理器需要额外的方法来确定支持哪些注解以及支持的 Java 版本。不过，你现在可以简单的使用 <strong>@SupportedAnnotationTypes</strong> 和 <strong>@SupportedSourceVersion</strong> 注解（这是一个很好的示例关于注解如何简化你的代码）。</p><p>你唯一需要实现的方法就是 <code>process()</code>，这里是所有行为发生的地方。第一个参数告诉你哪个注解是存在的，第二个参数保留了剩余信息。我们所做的事情只是打印了注解（这里只存在一个），可以看 <strong>TypeElement</strong> 文档中的其他行为。通过使用 <code>process()</code> 的第二个操作，我们循环所有被 <strong>@Simple</strong> 注解的元素，并且针对每一个元素调用我们的 <code>display()</code> 方法。所有 <strong>Element</strong> 展示了本身的基本信息；例如，<code>getModifiers()</code> 告诉你它是否为 <strong>public</strong> 和 <strong>static</strong> 的。</p><p><strong>Element</strong> 只能执行那些编译器解析的所有基本对象共有的操作，而类和方法之类的东西有额外的信息需要提取。所以（如果你阅读了正确的文档，但是我没有在任何文档中找到——我不得不通过 StackOverflow 寻找线索）你检查它是哪种 <strong>ElementKind</strong>，然后将其向下转换为更具体的元素类型，注入针对 CLASS 的 TypeElement 和 针对 METHOD 的ExecutableElement。此时，可以为这些元素调用其他方法。</p><p>动态向下转型（在编译期不进行检查）并不像是 Java 的做事方式，这非常不直观这也是为什么我从未想过要这样做事。相反，我花了好几天的时间，试图发现你应该如何访问这些信息，而这些信息至少在某种程度上是用不起作用的恰当方法简单明了的。我还没有遇到任何东西说上面是规范的形式，但在我看来是。</p><p>如果只是通过平常的方式来编译 <strong>SimpleTest.java</strong>，你不会得到任何结果。为了得到注解输出，你必须增加一个 <strong>processor</strong> 标志并且连接注解处理器类</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -processor annotations.simplest.SimpleProcessor SimpleTest.java</span><br></pre></td></tr></table></figure><p>现在编译器有了输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">annotations.simplest.Simple</span><br><span class="line">==== annotations.simplest.SimpleTest ====</span><br><span class="line">CLASS : [public] : SimpleTest : annotations.simplest.SimpleTest</span><br><span class="line">annotations.simplest.SimpleTest</span><br><span class="line">java.lang.Object</span><br><span class="line">i,SimpleTest(),foo(),bar(java.lang.String,int,float),main(java.lang.String[])</span><br><span class="line">==== i ====</span><br><span class="line">FIELD : [] : i : int</span><br><span class="line">==== SimpleTest() ====</span><br><span class="line">CONSTRUCTOR : [public] : &lt;init&gt; : ()void</span><br><span class="line">==== foo() ====</span><br><span class="line">METHOD : [public] : foo : ()void</span><br><span class="line">void foo()</span><br><span class="line">==== bar(java.lang.String,int,float) ====</span><br><span class="line">METHOD : [public] : bar : (java.lang.String,int,float)void</span><br><span class="line">void bar(s,i,f)</span><br><span class="line">==== main(java.lang.String[]) ====</span><br><span class="line">METHOD : [public, static] : main : (java.lang.String[])void</span><br><span class="line">void main(args)</span><br></pre></td></tr></table></figure><p>这给了你一些可以发现的东西，包括参数名和类型、返回值等。</p><h3 id="更复杂的处理器"><a href="#更复杂的处理器" class="headerlink" title="更复杂的处理器"></a>更复杂的处理器</h3><p>当你创建用于 javac 注解处理器时，你不能使用 Java 的反射特性，因为你处理的是源代码，而并非是编译后的 class 文件。各种 mirror[^3 ] 解决这个问题的方法是，通过允许你在未编译的源代码中查看方法、字段和类型。</p><p>如下是一个用于提取类中方法的注解，所以它可以被抽取成为一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/ifx/ExtractInterface.java</span></span><br><span class="line"><span class="comment">// javac-based annotation processing</span></span><br><span class="line"><span class="keyword">package</span> annotations.ifx;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ExtractInterface &#123;</span><br><span class="line">    <span class="function">String <span class="title">interfaceName</span><span class="params">()</span> <span class="keyword">default</span> "-!!-"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>RetentionPolicy</strong> 的值为 <strong>SOURCE</strong>，这是为了在提取类中的接口之后不再将注解信息保留在 class 文件中。接下来的测试类提供了一些公用方法，这些方法可以成为接口的一部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/ifx/Multiplier.java</span></span><br><span class="line"><span class="comment">// javac-based annotation processing</span></span><br><span class="line"><span class="comment">// &#123;java annotations.ifx.Multiplier&#125;</span></span><br><span class="line"><span class="keyword">package</span> annotations.ifx;</span><br><span class="line"><span class="meta">@ExtractInterface</span>(interfaceName=<span class="string">"IMultiplier"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Multiplier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x; i++)</span><br><span class="line">            total = add(total, y);</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fortySeven</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">47</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">timesTen</span><span class="params">(<span class="keyword">double</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arg * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Multiplier m = <span class="keyword">new</span> Multiplier();</span><br><span class="line">        System.out.println(</span><br><span class="line">                <span class="string">"11 * 16 = "</span> + m.multiply(<span class="number">11</span>, <span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span> * <span class="number">16</span> = <span class="number">176</span></span><br></pre></td></tr></table></figure><p><strong>Multiplier</strong> 类（只能处理正整数）拥有一个 <code>multiply()</code> 方法，这个方法会多次调用私有方法 <code>add()</code> 来模拟乘法操作。<code>add()</code> 是私有方法，因此不能成为接口的一部分。其他的方法提供了语法多样性。注解被赋予 <strong>IMultiplier</strong> 的 <strong>InterfaceName</strong> 作为要创建的接口的名称。</p><p>这里有一个编译时处理器用于提取有趣的方法，并创建一个新的 interface 源代码文件（这个源文件将会在下一轮中被自动编译）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/ifx/IfaceExtractorProcessor.java</span></span><br><span class="line"><span class="comment">// javac-based annotation processing</span></span><br><span class="line"><span class="keyword">package</span> annotations.ifx;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.processing.*;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.SourceVersion;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.*;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="meta">@SupportedAnnotationTypes</span>(</span><br><span class="line">        <span class="string">"annotations.ifx.ExtractInterface"</span>)</span><br><span class="line"><span class="meta">@SupportedSourceVersion</span>(SourceVersion.RELEASE_8)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IfaceExtractorProcessor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Element&gt;</span><br><span class="line">            interfaceMethods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Elements elementUtils;</span><br><span class="line">    <span class="keyword">private</span> ProcessingEnvironment processingEnv;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ProcessingEnvironment processingEnv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.processingEnv = processingEnv;</span><br><span class="line">        elementUtils = processingEnv.getElementUtils();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Set&lt;? extends TypeElement&gt; annotations,</span></span></span><br><span class="line"><span class="function"><span class="params">            RoundEnvironment env)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Element elem:env.getElementsAnnotatedWith(</span><br><span class="line">                ExtractInterface.class)) &#123;</span><br><span class="line">            String interfaceName = elem.getAnnotation(</span><br><span class="line">                    ExtractInterface.class).interfaceName();</span><br><span class="line">            <span class="keyword">for</span>(Element enclosed :</span><br><span class="line">                    elem.getEnclosedElements()) &#123;</span><br><span class="line">                <span class="keyword">if</span>(enclosed.getKind()</span><br><span class="line">                        .equals(ElementKind.METHOD) &amp;&amp;</span><br><span class="line">                        enclosed.getModifiers()</span><br><span class="line">                                .contains(Modifier.PUBLIC) &amp;&amp;</span><br><span class="line">                        !enclosed.getModifiers()</span><br><span class="line">                                .contains(Modifier.STATIC)) &#123;</span><br><span class="line">                    interfaceMethods.add(enclosed);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(interfaceMethods.size() &gt; <span class="number">0</span>)</span><br><span class="line">                writeInterfaceFile(interfaceName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span></span><br><span class="line">    writeInterfaceFile(String interfaceName) &#123;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">                Writer writer = processingEnv.getFiler()</span><br><span class="line">                        .createSourceFile(interfaceName)</span><br><span class="line">                        .openWriter()</span><br><span class="line">        ) &#123;</span><br><span class="line">            String packageName = elementUtils</span><br><span class="line">                    .getPackageOf(interfaceMethods</span><br><span class="line">                            .get(<span class="number">0</span>)).toString();</span><br><span class="line">            writer.write(</span><br><span class="line">                    <span class="string">"package "</span> + packageName + <span class="string">";\n"</span>);</span><br><span class="line">            writer.write(<span class="string">"public interface "</span> +</span><br><span class="line">                    interfaceName + <span class="string">" &#123;\n"</span>);</span><br><span class="line">            <span class="keyword">for</span>(Element elem : interfaceMethods) &#123;</span><br><span class="line">                ExecutableElement method =</span><br><span class="line">                        (ExecutableElement)elem;</span><br><span class="line">                String signature = <span class="string">" public "</span>;</span><br><span class="line">                signature += method.getReturnType() + <span class="string">" "</span>;</span><br><span class="line">                signature += method.getSimpleName();</span><br><span class="line">                signature += createArgList(</span><br><span class="line">                        method.getParameters());</span><br><span class="line">                System.out.println(signature);</span><br><span class="line">                writer.write(signature + <span class="string">";\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            writer.write(<span class="string">"&#125;"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">createArgList</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            List&lt;? extends VariableElement&gt; parameters)</span> </span>&#123;</span><br><span class="line">        String args = parameters.stream()</span><br><span class="line">                .map(p -&gt; p.asType() + <span class="string">" "</span> + p.getSimpleName())</span><br><span class="line">                .collect(Collectors.joining(<span class="string">", "</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"("</span> + args + <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Elements</strong> 对象实例 <strong>elementUtils</strong> 是一组静态方法的工具；我们用它来寻找 <strong>writeInterfaceFile()</strong> 中含有的包名。</p><p><code>getEnclosedElements()</code>方法会通过指定的元素生成所有的“闭包”元素。在这里，这个类闭包了它的所有元素。通过使用 <code>getKind()</code> 我们会找到所有的 <strong>public</strong> 和 <strong>static</strong> 方法，并将其添加到 <strong>interfaceMethods</strong> 列表中。接下来 <code>writeInterfaceFile()</code> 使用 <strong>interfaceMethods</strong> 列表里面的值生成新的接口定义。注意，在 <code>writeInterfaceFile()</code> 使用了向下转型到 <strong>ExecutableElement</strong>，这使得我们可以获取所有的方法信息。<strong>createArgList()</strong> 是一个帮助方法，用于生成参数列表。</p><p><strong>Filer</strong>是 <code>getFiler()</code> 生成的，并且是 <strong>PrintWriter</strong> 的一种实例，可以用于创建新文件。我们使用 <strong>Filer</strong> 对象，而不是原生的 <strong>PrintWriter</strong> 原因是，这个对象可以运行 <strong>javac</strong> 追踪你创建的新文件，这使得它可以在新一轮中检查新文件中的注解并编译文件。</p><p>如下是一个命令行，可以在编译的时候使用处理器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -processor annotations.ifx.IfaceExtractorProcessor Multiplier.java</span><br></pre></td></tr></table></figure><p>新生成的 <strong>IMultiplier.java</strong> 的文件，正如你通过查看上面处理器的 <code>println()</code> 语句所猜测的那样，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> annotations.ifx;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMultiplier</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fortySeven</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">timesTen</span><span class="params">(<span class="keyword">double</span> arg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类同样会被 <strong>javac</strong> 编译（在某一轮中），所以你会在同一个目录中看到 <strong>IMultiplier.class</strong> 文件。</p><!-- Annotation-Based Unit Testing --><h2 id="基于注解的单元测试"><a href="#基于注解的单元测试" class="headerlink" title="基于注解的单元测试"></a>基于注解的单元测试</h2><p>单元测试是对类中每个方法提供一个或者多个测试的一种事件，其目的是为了有规律的测试一个类中每个部分是否具备正确的行为。在 Java 中，最著名的单元测试工具就是 <strong>JUnit</strong>。<strong>JUnit</strong> 4 版本已经包含了注解。在注解版本之前的 JUnit 一个最主要的问题是，为了启动和运行 <strong>JUnit</strong> 测试，有大量的“仪式”需要标注。这种负担已经减轻了一些，<strong>但是</strong>注解使得测试更接近“可以工作的最简单的测试系统”。</p><p>在注解版本之前的 JUnit，你必须创建一个单独的文件来保存单元测试。通过注解，我们可以将单元测试集成在需要被测试的类中，从而将单元测试的时间和麻烦降到了最低。这种方式有额外的好处，就是使得测试私有方法和公有方法变的一样容易。</p><p>这个基于注解的测试框架叫做 <strong>@Unit</strong>。其最基本的测试形式，可能也是你使用的最多的一个注解是 <strong>@Test</strong>，我们使用 <strong>@Test</strong> 来标记测试方法。测试方法不带参数，并返回 <strong>boolean</strong> 结果来说明测试方法成功或者失败。你可以任意命名它的测试方法。同时 <strong>@Unit</strong> 测试方法可以是任意你喜欢的访问修饰方法，包括 <strong>private</strong>。</p><p>要使用 <strong>@Unit</strong>，你必须导入 <strong>onjava.atunit</strong> 包，并且使用 <strong>@Unit</strong> 的测试标记为合适的方法和字段打上标签（在接下来的例子中你会学到），然后让你的构建系统对编译后的类运行 <strong>@Unit</strong>，下面是一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/AtUnitExample1.java</span></span><br><span class="line"><span class="comment">// &#123;java onjava.atunit.AtUnit</span></span><br><span class="line"><span class="comment">// build/classes/main/annotations/AtUnitExample1.class&#125;</span></span><br><span class="line"><span class="keyword">package</span> annotations;</span><br><span class="line"><span class="keyword">import</span> onjava.atunit.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtUnitExample1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">methodOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"This is methodOne"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">methodTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is methodTwo"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">methodOneTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> methodOne().equals(<span class="string">"This is methodOne"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">m2</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> methodTwo() == <span class="number">2</span>; &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">m3</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">true</span>; &#125;</span><br><span class="line">    <span class="comment">// Shows output for failure:</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">failureTest</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">false</span>; &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">anotherDisappointment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">annotations.AtUnitExample1</span><br><span class="line">. m3</span><br><span class="line">. methodOneTest</span><br><span class="line">. m2 This is methodTwo</span><br><span class="line">. failureTest (failed)</span><br><span class="line">. anotherDisappointment (failed)</span><br><span class="line">(<span class="number">5</span> tests)</span><br><span class="line">&gt;&gt;&gt; <span class="number">2</span> FAILURES &lt;&lt;&lt;</span><br><span class="line">annotations.AtUnitExample1: failureTest</span><br><span class="line">annotations.AtUnitExample1: anotherDisappointment</span><br></pre></td></tr></table></figure><p>使用 <strong>@Unit</strong> 进行测试的类必须定义在某个包中（即必须包括 <strong>package</strong> 声明）。</p><p><strong>@Test</strong> 注解被置于 <code>methodOneTest()</code>、 <code>m2()</code>、<code>m3()</code>、<code>failureTest()</code> 以及 a<code>notherDisappointment()</code> 方法之前，它们告诉 <strong>@Unit</strong> 方法作为单元测试来运行。同时 <strong>@Test</strong> 确保这些方法没有任何参数并且返回值为 <strong>boolean</strong> 或者 <strong>void</strong>。当你填写单元测试时，唯一需要做的就是决定测试是成功还是失败，（对于返回值为 <strong>boolean</strong> 的方法）应该返回 <strong>ture</strong> 还是 <strong>false</strong>。</p><p>如果你熟悉 <strong>JUnit</strong>，你还将注意到 <strong>@Unit</strong> 输出的信息更多。你会看到现在正在运行的测试的输出更有用，最后它会告诉你导致失败的类和测试。</p><p>你并非必须将测试方法嵌入到原来的类中，有时候这种事情根本做不到。要生产一个非嵌入式的测试，最简单的方式就是继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/AUExternalTest.java</span></span><br><span class="line"><span class="comment">// Creating non-embedded tests</span></span><br><span class="line"><span class="comment">// &#123;java onjava.atunit.AtUnit</span></span><br><span class="line"><span class="comment">// build/classes/main/annotations/AUExternalTest.class&#125;</span></span><br><span class="line"><span class="keyword">package</span> annotations;</span><br><span class="line"><span class="keyword">import</span> onjava.atunit.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AUExternalTest</span> <span class="keyword">extends</span> <span class="title">AtUnitExample1</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">_MethodOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> methodOne().equals(<span class="string">"This is methodOne"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">_MethodTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> methodTwo() == <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">annotations.AUExternalTest</span><br><span class="line">. tMethodOne</span><br><span class="line">. tMethodTwo This is methodTwo</span><br><span class="line">OK (<span class="number">2</span> tests)</span><br></pre></td></tr></table></figure><p>这个示例还表现出灵活命名的价值。在这里，<strong>@Test</strong> 方法被命名为下划线前缀加上要测试的方法名称（我并不认为这是一种理想的命名形式，这只是表现一种可能性罢了）。</p><p>你也可以使用组合来创建非嵌入式的测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/AUComposition.java</span></span><br><span class="line"><span class="comment">// Creating non-embedded tests</span></span><br><span class="line"><span class="comment">// &#123;java onjava.atunit.AtUnit</span></span><br><span class="line"><span class="comment">// build/classes/main/annotations/AUComposition.class&#125;</span></span><br><span class="line"><span class="keyword">package</span> annotations;</span><br><span class="line"><span class="keyword">import</span> onjava.atunit.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AUComposition</span> </span>&#123;</span><br><span class="line">    AtUnitExample1 testObject = <span class="keyword">new</span> AtUnitExample1();</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tMethodOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> testObject.methodOne()</span><br><span class="line">                .equals(<span class="string">"This is methodOne"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tMethodTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> testObject.methodTwo() == <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">annotations.AUComposition</span><br><span class="line">. tMethodTwo This is methodTwo</span><br><span class="line">. tMethodOne</span><br><span class="line">OK (<span class="number">2</span> tests)</span><br></pre></td></tr></table></figure><p>因为在每一个测试里面都会创建 <strong>AUComposition</strong> 对象，所以创建新的成员变量 <strong>testObject</strong> 用于以后的每一个测试方法。</p><p>因为 <strong>@Unit</strong> 中没有 <strong>JUnit</strong> 中特殊的 <strong>assert</strong> 方法，不过另一种形式的 <strong>@Test</strong> 方法仍然允许返回值为 <strong>void</strong>（如果你还想使用 <strong>true</strong> 或者 <strong>false</strong> 的话，也可以使用 <strong>boolean</strong> 作为方法返回值类型）。为了表示测试成功，可以使用 Java 的 <strong>assert</strong> 语句。Java 断言机制需要你在 java 命令行行加上 <strong>-ea</strong> 标志来开启，但是 <strong>@Unit</strong> 已经自动开启了该功能。要表示测试失败的话，你甚至可以使用异常。<strong>@Unit</strong> 的设计目标之一就是尽可能减少添加额外的语法，而 Java 的 <strong>assert</strong> 和异常对于报告错误而言，即已经足够了。一个失败的 <strong>assert</strong> 或者从方法从抛出的异常都被视为测试失败，但是 <strong>@Unit</strong> 不会在这个失败的测试上卡住，它会继续运行，直到所有测试完毕，下面是一个示例程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/AtUnitExample2.java</span></span><br><span class="line"><span class="comment">// Assertions and exceptions can be used in @Tests</span></span><br><span class="line"><span class="comment">// &#123;java onjava.atunit.AtUnit</span></span><br><span class="line"><span class="comment">// build/classes/main/annotations/AtUnitExample2.class&#125;</span></span><br><span class="line"><span class="keyword">package</span> annotations;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> onjava.atunit.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtUnitExample2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">methodOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"This is methodOne"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">methodTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is methodTwo"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">assertExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">methodOne</span><span class="params">()</span>.<span class="title">equals</span><span class="params">(<span class="string">"This is methodOne"</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">assertFailureExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> <span class="number">1</span> == <span class="number">2</span>: <span class="string">"What a surprise!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exceptionExample</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(FileInputStream fis =</span><br><span class="line">                    <span class="keyword">new</span> FileInputStream(<span class="string">"nofile.txt"</span>)) &#123;&#125; <span class="comment">// Throws</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">assertAndReturn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Assertion with message:</span></span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">methodTwo</span><span class="params">()</span> </span>== <span class="number">2</span>: <span class="string">"methodTwo must equal 2"</span>;</span><br><span class="line">        <span class="keyword">return</span> methodOne().equals(<span class="string">"This is methodOne"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">annotations.AtUnitExample2</span><br><span class="line">. exceptionExample java.io.FileNotFoundException:</span><br><span class="line">nofile.txt (The system cannot find the file specified)</span><br><span class="line">(failed)</span><br><span class="line">. assertExample</span><br><span class="line">. assertAndReturn This is methodTwo</span><br><span class="line">. assertFailureExample java.lang.AssertionError: What</span><br><span class="line">a surprise!</span><br><span class="line">(failed)</span><br><span class="line">(<span class="number">4</span> tests)</span><br><span class="line">&gt;&gt;&gt; <span class="number">2</span> FAILURES &lt;&lt;&lt;</span><br><span class="line">annotations.AtUnitExample2: exceptionExample</span><br><span class="line">annotations.AtUnitExample2: assertFailureExample</span><br></pre></td></tr></table></figure><p>如下是一个使用非嵌入式测试的例子，并且使用了断言，它将会对 <strong>java.util.HashSet</strong> 进行一些简单的测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/HashSetTest.java</span></span><br><span class="line"><span class="comment">// &#123;java onjava.atunit.AtUnit</span></span><br><span class="line"><span class="comment">// build/classes/main/annotations/HashSetTest.class&#125;</span></span><br><span class="line"><span class="keyword">package</span> annotations;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> onjava.atunit.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetTest</span> </span>&#123;</span><br><span class="line">    HashSet&lt;String&gt; testObject = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initialization</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> testObject.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">_Contains</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        testObject.add(<span class="string">"one"</span>);</span><br><span class="line">        <span class="keyword">assert</span> testObject.contains(<span class="string">"one"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">_Remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        testObject.add(<span class="string">"one"</span>);</span><br><span class="line">        testObject.remove(<span class="string">"one"</span>);</span><br><span class="line">        <span class="keyword">assert</span> testObject.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用继承的方式可能会更简单，也没有一些其他的约束。</p><p>对每一个单元测试而言，<strong>@Unit</strong> 都会使用默认的无参构造器，为该测试类所属的类创建出一个新的实例。并在此新创建的对象上运行测试，然后丢弃该对象，以免对其他测试产生副作用。如此创建对象导致我们依赖于类的默认构造器。如果你的类没有默认构造器，或者对象需要复杂的构造过程，那么你可以创建一个 <strong>static</strong> 方法专门负责构造对象，然后使用 <strong>@TestObjectCreate</strong> 注解标记该方法，例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/AtUnitExample3.java</span></span><br><span class="line"><span class="comment">// &#123;java onjava.atunit.AtUnit</span></span><br><span class="line"><span class="comment">// build/classes/main/annotations/AtUnitExample3.class&#125;</span></span><br><span class="line"><span class="keyword">package</span> annotations;</span><br><span class="line"><span class="keyword">import</span> onjava.atunit.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtUnitExample3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtUnitExample3</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">this</span>.n = n; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getN</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">methodOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"This is methodOne"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">methodTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is methodTwo"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@TestObjectCreate</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> AtUnitExample3 <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AtUnitExample3(<span class="number">47</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">initialization</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> n == <span class="number">47</span>; &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">methodOneTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> methodOne().equals(<span class="string">"This is methodOne"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">m2</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> methodTwo() == <span class="number">2</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">annotations.AtUnitExample3</span><br><span class="line">. initialization</span><br><span class="line">. m2 This is methodTwo</span><br><span class="line">. methodOneTest</span><br><span class="line">OK (<span class="number">3</span> tests)</span><br></pre></td></tr></table></figure><p><strong>@TestObjectCreate</strong> 修饰的方法必须声明为 <strong>static</strong> ，且必须返回一个你正在测试的类型对象，这一切都由 <strong>@Unit</strong> 负责确保成立。</p><p>有的时候，你需要向单元测试中增加一些字段。这时候可以使用 <strong>@TestProperty</strong> 注解，由它注解的字段表示只在单元测试中使用（因此，在你将产品发布给客户之前，他们应该被删除）。在下面的例子中，一个 <strong>String</strong> 通过 <code>String.split()</code> 方法进行分割，从其中读取一个值，这个值将会被生成测试对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/AtUnitExample4.java</span></span><br><span class="line"><span class="comment">// &#123;java onjava.atunit.AtUnit</span></span><br><span class="line"><span class="comment">// build/classes/main/annotations/AtUnitExample4.class&#125;</span></span><br><span class="line"><span class="comment">// &#123;VisuallyInspectOutput&#125;</span></span><br><span class="line"><span class="keyword">package</span> annotations;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> onjava.atunit.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtUnitExample4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String theory = <span class="string">"All brontosauruses "</span> +</span><br><span class="line">            <span class="string">"are thin at one end, much MUCH thicker in the "</span> +</span><br><span class="line">            <span class="string">"middle, and then thin again at the far end."</span>;</span><br><span class="line">    <span class="keyword">private</span> String word;</span><br><span class="line">    <span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random(); <span class="comment">// Time-based seed</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtUnitExample4</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.word = word;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getWord</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> word; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">scrambleWord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Character&gt; chars = Arrays.asList(</span><br><span class="line">                ConvertTo.boxed(word.toCharArray()));</span><br><span class="line">        Collections.shuffle(chars, rand);</span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch : chars)</span><br><span class="line">            result.append(ch);</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@TestProperty</span></span><br><span class="line">    <span class="keyword">static</span> List&lt;String&gt; input =</span><br><span class="line">            Arrays.asList(theory.split(<span class="string">" "</span>));</span><br><span class="line">    <span class="meta">@TestProperty</span></span><br><span class="line">    <span class="keyword">static</span> Iterator&lt;String&gt; words = input.iterator();</span><br><span class="line">    <span class="meta">@TestObjectCreate</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> AtUnitExample4 <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(words.hasNext())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AtUnitExample4(words.next());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">words</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"'"</span> + getWord() + <span class="string">"'"</span>);</span><br><span class="line">        <span class="keyword">return</span> getWord().equals(<span class="string">"are"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">scramble1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// Use specific seed to get verifiable results:</span></span><br><span class="line">        rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        System.out.println(<span class="string">"'"</span> + getWord() + <span class="string">"'"</span>);</span><br><span class="line">        String scrambled = scrambleWord();</span><br><span class="line">        System.out.println(scrambled);</span><br><span class="line">        <span class="keyword">return</span> scrambled.equals(<span class="string">"lAl"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">scramble2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rand = <span class="keyword">new</span> Random(<span class="number">74</span>);</span><br><span class="line">        System.out.println(<span class="string">"'"</span> + getWord() + <span class="string">"'"</span>);</span><br><span class="line">        String scrambled = scrambleWord();</span><br><span class="line">        System.out.println(scrambled);</span><br><span class="line">        <span class="keyword">return</span> scrambled.equals(<span class="string">"tsaeborornussu"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">annotations.AtUnitExample4</span><br><span class="line">. words <span class="string">'All'</span></span><br><span class="line">(failed)</span><br><span class="line">. scramble1 <span class="string">'brontosauruses'</span></span><br><span class="line">ntsaueorosurbs</span><br><span class="line">(failed)</span><br><span class="line">. scramble2 <span class="string">'are'</span></span><br><span class="line">are</span><br><span class="line">(failed)</span><br><span class="line">(<span class="number">3</span> tests)</span><br><span class="line">&gt;&gt;&gt; <span class="number">3</span> FAILURES &lt;&lt;&lt;</span><br><span class="line">annotations.AtUnitExample4: words</span><br><span class="line">annotations.AtUnitExample4: scramble1</span><br><span class="line">annotations.AtUnitExample4: scramble2</span><br></pre></td></tr></table></figure><p><strong>@TestProperty</strong> 也可以用来标记那些只在测试中使用的方法，但是它们本身不是测试方法。</p><p>如果你的测试对象需要执行某些初始化工作，并且使用完成之后还需要执行清理工作，那么可以选择使用 <strong>static</strong> 的  <strong>@TestObjectCleanup</strong> 方法，当测试对象使用结束之后，该方法会为你执行清理工作。在下面的示例中，<strong>@TestObjectCleanup</strong> 为每一个测试对象都打开了一个文件，因此必须在丢弃测试的时候关闭该文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/AtUnitExample5.java</span></span><br><span class="line"><span class="comment">// &#123;java onjava.atunit.AtUnit</span></span><br><span class="line"><span class="comment">// build/classes/main/annotations/AtUnitExample5.class&#125;</span></span><br><span class="line"><span class="keyword">package</span> annotations;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> onjava.atunit.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtUnitExample5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String text;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtUnitExample5</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.text = text;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> text; &#125;</span><br><span class="line">    <span class="meta">@TestProperty</span></span><br><span class="line">    <span class="keyword">static</span> PrintWriter output;</span><br><span class="line">    <span class="meta">@TestProperty</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> counter;</span><br><span class="line">    <span class="meta">@TestObjectCreate</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> AtUnitExample5 <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String id = Integer.toString(counter++);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            output = <span class="keyword">new</span> PrintWriter(<span class="string">"Test"</span> + id + <span class="string">".txt"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AtUnitExample5(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@TestObjectCleanup</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">(AtUnitExample5 tobj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Running cleanup"</span>);</span><br><span class="line">        output.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        output.print(<span class="string">"test1"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        output.print(<span class="string">"test2"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        output.print(<span class="string">"test3"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">annotations.AtUnitExample5</span><br><span class="line">. test1</span><br><span class="line">Running cleanup</span><br><span class="line">. test3</span><br><span class="line">Running cleanup</span><br><span class="line">. test2</span><br><span class="line">Running cleanup</span><br><span class="line">OK (<span class="number">3</span> tests)</span><br></pre></td></tr></table></figure><p>在输出中我们可以看到，清理方法会在每个测试方法结束之后自动运行。</p><h3 id="在-Unit-中使用泛型"><a href="#在-Unit-中使用泛型" class="headerlink" title="在 @Unit 中使用泛型"></a>在 @Unit 中使用泛型</h3><p>泛型为 <strong>@Unit</strong> 出了一个难题，因为我们不可能“通用测试”。我们必须针对某个特定类型的参数或者参数集才能进行测试。解决方法十分简单，让测试类继承自泛型类的一个特定版本即可：</p><p>下面是一个 <strong>stack</strong> 的简单实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/StackL.java</span></span><br><span class="line"><span class="comment">// A stack built on a LinkedList</span></span><br><span class="line"><span class="keyword">package</span> annotations;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackL</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;T&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T v)</span> </span>&#123; list.addFirst(v); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">top</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> list.getFirst(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> list.removeFirst(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了测试 String 版本，我们直接让测试类继承一个 Stack&lt;String&gt; ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/StackLStringTst.java</span></span><br><span class="line"><span class="comment">// Applying @Unit to generics</span></span><br><span class="line"><span class="comment">// &#123;java onjava.atunit.AtUnit</span></span><br><span class="line"><span class="comment">// build/classes/main/annotations/StackLStringTst.class&#125;</span></span><br><span class="line"><span class="keyword">package</span> annotations;</span><br><span class="line"><span class="keyword">import</span> onjava.atunit.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="class"><span class="title">StackLStringTst</span> <span class="keyword">extends</span> <span class="title">StackL</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tPush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        push(<span class="string">"one"</span>);</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">top</span><span class="params">()</span>.<span class="title">equals</span><span class="params">(<span class="string">"one"</span>)</span></span>;</span><br><span class="line">        push(<span class="string">"two"</span>);</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">top</span><span class="params">()</span>.<span class="title">equals</span><span class="params">(<span class="string">"two"</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tPop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        push(<span class="string">"one"</span>);</span><br><span class="line">        push(<span class="string">"two"</span>);</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">pop</span><span class="params">()</span>.<span class="title">equals</span><span class="params">(<span class="string">"two"</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">pop</span><span class="params">()</span>.<span class="title">equals</span><span class="params">(<span class="string">"one"</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tTop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        push(<span class="string">"A"</span>);</span><br><span class="line">        push(<span class="string">"B"</span>);</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">top</span><span class="params">()</span>.<span class="title">equals</span><span class="params">(<span class="string">"B"</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">top</span><span class="params">()</span>.<span class="title">equals</span><span class="params">(<span class="string">"B"</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">annotations.StackLStringTst</span><br><span class="line">. tTop</span><br><span class="line">. tPush</span><br><span class="line">. tPop</span><br><span class="line">OK (<span class="number">3</span> tests)</span><br></pre></td></tr></table></figure><p>这种方法存在的唯一缺点是，继承使我们失去了访问被测试的类中 <strong>private</strong> 方法的能力。这对你非常重要，那你要么把 private 方法变为 <strong>protected</strong>，要么添加一个非 <strong>private</strong> 的 <strong>@TestProperty</strong> 方法，由它来调用 <strong>private</strong> 方法（稍后我们会看到，<strong>AtUnitRemover</strong> 会删除产品中的 <strong>@TestProperty</strong> 方法）。</p><p><strong>@Unit</strong> 搜索那些包含合适注解的类文件，然后运行 <strong>@Test</strong> 方法。我的主要目标就是让 <strong>@Unit</strong> 测试系统尽可能的透明，使得人们使用它的时候只需要添加 <strong>@Test</strong> 注解，而不需要特殊的编码和知识（现在版本的 <strong>JUnit</strong> 符合这个实践）。不过，如果说编写测试不会遇到任何困难，也不太可能，因此 <strong>@Unit</strong> 会尽量让这些困难变的微不足道，希望通过这种方式，你们会更乐意编写测试。</p><h3 id="实现-Unit"><a href="#实现-Unit" class="headerlink" title="实现 @Unit"></a>实现 @Unit</h3><p>首先我们需要定义所有的注解类型。这些都是简单的标签，并且没有任何字段。@Test 标签在本章开头已经定义过了，这里是其他所需要的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/atunit/TestObjectCreate.java</span></span><br><span class="line"><span class="comment">// The @Unit @TestObjectCreate tag</span></span><br><span class="line"><span class="keyword">package</span> onjava.atunit;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestObjectCreate &#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/atunit/TestObjectCleanup.java</span></span><br><span class="line"><span class="comment">// The @Unit @TestObjectCleanup tag</span></span><br><span class="line"><span class="keyword">package</span> onjava.atunit;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestObjectCleanup &#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/atunit/TestProperty.java</span></span><br><span class="line"><span class="comment">// The @Unit @TestProperty tag</span></span><br><span class="line"><span class="keyword">package</span> onjava.atunit;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="comment">// Both fields and methods can be tagged as properties:</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD, ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestProperty &#123;&#125;</span><br></pre></td></tr></table></figure><p>所有测试的保留属性都为 <strong>RUNTIME</strong>，这是因为 <strong>@Unit</strong> 必须在编译后的代码中发现这些注解。</p><p>要实现系统并运行测试，我们还需要反射机制来提取注解。下面这个程序通过注解中的信息，决定如何构造测试对象，并在测试对象上运行测试。正是由于注解帮助，这个程序才会如此短小而直接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/atunit/AtUnit.java</span></span><br><span class="line"><span class="comment">// An annotation-based unit-test framework</span></span><br><span class="line"><span class="comment">// &#123;java onjava.atunit.AtUnit&#125;</span></span><br><span class="line"><span class="keyword">package</span> onjava.atunit;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtUnit</span> <span class="keyword">implements</span> <span class="title">ProcessFiles</span>.<span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Class&lt;?&gt; testClass;</span><br><span class="line">    <span class="keyword">static</span> List&lt;String&gt; failedTests= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> testsRun = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> failures = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">    main(String[] args) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ClassLoader.getSystemClassLoader()</span><br><span class="line">                .setDefaultAssertionStatus(<span class="keyword">true</span>); <span class="comment">// Enable assert</span></span><br><span class="line">        <span class="keyword">new</span> ProcessFiles(<span class="keyword">new</span> AtUnit(), <span class="string">"class"</span>).start(args);</span><br><span class="line">        <span class="keyword">if</span>(failures == <span class="number">0</span>)</span><br><span class="line">            System.out.println(<span class="string">"OK ("</span> + testsRun + <span class="string">" tests)"</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"("</span> + testsRun + <span class="string">" tests)"</span>);</span><br><span class="line">            System.out.println(</span><br><span class="line">                    <span class="string">"\n&gt;&gt;&gt; "</span> + failures + <span class="string">" FAILURE"</span> +</span><br><span class="line">                            (failures &gt; <span class="number">1</span> ? <span class="string">"S"</span> : <span class="string">""</span>) + <span class="string">" &lt;&lt;&lt;"</span>);</span><br><span class="line">            <span class="keyword">for</span>(String failed : failedTests)</span><br><span class="line">                System.out.println(<span class="string">" "</span> + failed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(File cFile)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String cName = ClassNameFinder.thisClass(</span><br><span class="line">                    Files.readAllBytes(cFile.toPath()));</span><br><span class="line">            <span class="keyword">if</span>(!cName.startsWith(<span class="string">"public:"</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            cName = cName.split(<span class="string">":"</span>)[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(!cName.contains(<span class="string">"."</span>))</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// Ignore unpackaged classes</span></span><br><span class="line">            testClass = Class.forName(cName);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        TestMethods testMethods = <span class="keyword">new</span> TestMethods();</span><br><span class="line">        Method creator = <span class="keyword">null</span>;</span><br><span class="line">        Method cleanup = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(Method m : testClass.getDeclaredMethods()) &#123;</span><br><span class="line">            testMethods.addIfTestMethod(m);</span><br><span class="line">            <span class="keyword">if</span>(creator == <span class="keyword">null</span>)</span><br><span class="line">                creator = checkForCreatorMethod(m);</span><br><span class="line">            <span class="keyword">if</span>(cleanup == <span class="keyword">null</span>)</span><br><span class="line">                cleanup = checkForCleanupMethod(m);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(testMethods.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(creator == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!Modifier.isPublic(testClass</span><br><span class="line">                            .getDeclaredConstructor()</span><br><span class="line">                            .getModifiers())) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"Error: "</span> + testClass +</span><br><span class="line">                                <span class="string">" no-arg constructor must be public"</span>);</span><br><span class="line">                        System.exit(<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span>(NoSuchMethodException e) &#123;</span><br><span class="line"><span class="comment">// Synthesized no-arg constructor; OK</span></span><br><span class="line">                &#125;</span><br><span class="line">            System.out.println(testClass.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Method m : testMethods) &#123;</span><br><span class="line">            System.out.print(<span class="string">" . "</span> + m.getName() + <span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object testObject = createTestObject(creator);</span><br><span class="line">                <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(m.getReturnType().equals(<span class="keyword">boolean</span>.class))</span><br><span class="line">                        success = (Boolean)m.invoke(testObject);</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        m.invoke(testObject);</span><br><span class="line">                        success = <span class="keyword">true</span>; <span class="comment">// If no assert fails</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span>(InvocationTargetException e) &#123;</span><br><span class="line"><span class="comment">// Actual exception is inside e:</span></span><br><span class="line">                    System.out.println(e.getCause());</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(success ? <span class="string">""</span> : <span class="string">"(failed)"</span>);</span><br><span class="line">                testsRun++;</span><br><span class="line">                <span class="keyword">if</span>(!success) &#123;</span><br><span class="line">                    failures++;</span><br><span class="line">                    failedTests.add(testClass.getName() +</span><br><span class="line">                            <span class="string">": "</span> + m.getName());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cleanup != <span class="keyword">null</span>)</span><br><span class="line">                    cleanup.invoke(testObject, testObject);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(IllegalAccessException |</span><br><span class="line">                    IllegalArgumentException |</span><br><span class="line">                    InvocationTargetException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TestMethods</span> <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">Method</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">addIfTestMethod</span><span class="params">(Method m)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(m.getAnnotation(Test.class) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(m.getReturnType().equals(<span class="keyword">boolean</span>.class) ||</span><br><span class="line">                    m.getReturnType().equals(<span class="keyword">void</span>.class)))</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"@Test method"</span> +</span><br><span class="line">                        <span class="string">" must return boolean or void"</span>);</span><br><span class="line">            m.setAccessible(<span class="keyword">true</span>); <span class="comment">// If it's private, etc.</span></span><br><span class="line">            add(m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span></span><br><span class="line">    <span class="function">Method <span class="title">checkForCreatorMethod</span><span class="params">(Method m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m.getAnnotation(TestObjectCreate.class) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(!m.getReturnType().equals(testClass))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"@TestObjectCreate "</span> +</span><br><span class="line">                    <span class="string">"must return instance of Class to be tested"</span>);</span><br><span class="line">        <span class="keyword">if</span>((m.getModifiers() &amp;</span><br><span class="line">                java.lang.reflect.Modifier.STATIC) &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"@TestObjectCreate "</span> +</span><br><span class="line">                    <span class="string">"must be static."</span>);</span><br><span class="line">        m.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span></span><br><span class="line">    <span class="function">Method <span class="title">checkForCleanupMethod</span><span class="params">(Method m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m.getAnnotation(TestObjectCleanup.class) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(!m.getReturnType().equals(<span class="keyword">void</span>.class))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"@TestObjectCleanup "</span> +</span><br><span class="line">                    <span class="string">"must return void"</span>);</span><br><span class="line">        <span class="keyword">if</span>((m.getModifiers() &amp;</span><br><span class="line">                java.lang.reflect.Modifier.STATIC) &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"@TestObjectCleanup "</span> +</span><br><span class="line">                    <span class="string">"must be static."</span>);</span><br><span class="line">        <span class="keyword">if</span>(m.getParameterTypes().length == <span class="number">0</span> ||</span><br><span class="line">                m.getParameterTypes()[<span class="number">0</span>] != testClass)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"@TestObjectCleanup "</span> +</span><br><span class="line">                    <span class="string">"must take an argument of the tested type."</span>);</span><br><span class="line">        m.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object</span><br><span class="line">    createTestObject(Method creator) &#123;</span><br><span class="line">        <span class="keyword">if</span>(creator != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> creator.invoke(testClass);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(IllegalAccessException |</span><br><span class="line">                    IllegalArgumentException |</span><br><span class="line">                    InvocationTargetException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Couldn't run "</span> +</span><br><span class="line">                        <span class="string">"@TestObject (creator) method."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// Use the no-arg constructor:</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> testClass.newInstance();</span><br><span class="line">            &#125; <span class="keyword">catch</span>(InstantiationException |</span><br><span class="line">                    IllegalAccessException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                        <span class="string">"Couldn't create a test object. "</span> +</span><br><span class="line">                                <span class="string">"Try using a @TestObject method."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然它可能是“过早的重构”（因为它只在书中使用过一次），<strong>AtUnit.java</strong> 使用了 <strong>ProcessFiles</strong> 工具逐步判断命令行中的参数，决定它是一个目录还是文件，并采取相应的行为。这可以应用于不同的解决方法，是因为它包含了一个 可用于自定义的 <strong>Strategy</strong> 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/ProcessFiles.java</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessFiles</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(File file)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line">    <span class="keyword">private</span> String ext;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProcessFiles</span><span class="params">(Strategy strategy, String ext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">        <span class="keyword">this</span>.ext = ext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(args.length == <span class="number">0</span>)</span><br><span class="line">                processDirectoryTree(<span class="keyword">new</span> File(<span class="string">"."</span>));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">for</span>(String arg : args) &#123;</span><br><span class="line">                    File fileArg = <span class="keyword">new</span> File(arg);</span><br><span class="line">                    <span class="keyword">if</span>(fileArg.isDirectory())</span><br><span class="line">                        processDirectoryTree(fileArg);</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Allow user to leave off extension:</span></span><br><span class="line">                        <span class="keyword">if</span>(!arg.endsWith(<span class="string">"."</span> + ext))</span><br><span class="line">                            arg += <span class="string">"."</span> + ext;</span><br><span class="line">                        strategy.process(</span><br><span class="line">                                <span class="keyword">new</span> File(arg).getCanonicalFile());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processDirectoryTree</span><span class="params">(File root)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        PathMatcher matcher = FileSystems.getDefault()</span><br><span class="line">                .getPathMatcher(<span class="string">"glob:**/*.&#123;"</span> + ext + <span class="string">"&#125;"</span>);</span><br><span class="line">        Files.walk(root.toPath())</span><br><span class="line">                .filter(matcher::matches)</span><br><span class="line">                .forEach(p -&gt; strategy.process(p.toFile()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AtUnit</strong> 类实现了 <strong>ProcessFiles.Strategy</strong>，其包含了一个 <code>process()</code> 方法。在这种方式下，<strong>AtUnit</strong> 实例可以作为参数传递给 <strong>ProcessFiles</strong> 构造器。第二个构造器的参数告诉 <strong>ProcessFiles</strong> 如寻找所有包含 “class” 拓展名的文件。</p><p>如下是一个简单的使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// annotations/DemoProcessFiles.java</span></span><br><span class="line"><span class="keyword">import</span> onjava.ProcessFiles;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoProcessFiles</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ProcessFiles(file -&gt; System.out.println(file),</span><br><span class="line">                <span class="string">"java"</span>).start(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">.\AtUnitExample1.java</span><br><span class="line">.\AtUnitExample2.java</span><br><span class="line">.\AtUnitExample3.java</span><br><span class="line">.\AtUnitExample4.java</span><br><span class="line">.\AtUnitExample5.java</span><br><span class="line">.\AUComposition.java</span><br><span class="line">.\AUExternalTest.java</span><br><span class="line">.\database\Constraints.java</span><br><span class="line">.\database\DBTable.java</span><br><span class="line">.\database\Member.java</span><br><span class="line">.\database\SQLInteger.java</span><br><span class="line">.\database\SQLString.java</span><br><span class="line">.\database\TableCreator.java</span><br><span class="line">.\database\Uniqueness.java</span><br><span class="line">.\DemoProcessFiles.java</span><br><span class="line">.\HashSetTest.java</span><br><span class="line">.\ifx\ExtractInterface.java</span><br><span class="line">.\ifx\IfaceExtractorProcessor.java</span><br><span class="line">.\ifx\Multiplier.java</span><br><span class="line">.\PasswordUtils.java</span><br><span class="line">.\simplest\Simple.java</span><br><span class="line">.\simplest\SimpleProcessor.java</span><br><span class="line">.\simplest\SimpleTest.java</span><br><span class="line">.\SimulatingNull.java</span><br><span class="line">.\StackL.java</span><br><span class="line">.\StackLStringTst.java</span><br><span class="line">.\Testable.java</span><br><span class="line">.\UseCase.java</span><br><span class="line">.\UseCaseTracker.java</span><br></pre></td></tr></table></figure><p>如果没有命令行参数，这个程序会遍历当前的目录树。你还可以提供多个参数，这些参数可以是类文件（带或不带.class扩展名）或目录。</p><p>回到我们对 <strong>AtUnit.java</strong> 的讨论，因为 <strong>@Unit</strong> 会自动找到可测试的类和方法，所以不需要“套件”机制。</p><p><strong>AtUnit.java</strong> 中存在的一个我们必须要解决的问题是，当它发现类文件时，类文件名中的限定类名（包括包）不明显。为了发现这个信息，必须解析类文件 - 这不是微不足道的，但也不是不可能的。 找到 .class 文件时，会打开它并读取其二进制数据并将其传递给 <code>ClassNameFinder.thisClass()</code>。 在这里，我们正在进入“字节码工程”领域，因为我们实际上正在分析类文件的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/atunit/ClassNameFinder.java</span></span><br><span class="line"><span class="comment">// &#123;java onjava.atunit.ClassNameFinder&#125;</span></span><br><span class="line"><span class="keyword">package</span> onjava.atunit;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassNameFinder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">thisClass</span><span class="params">(<span class="keyword">byte</span>[] classBytes)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; offsetTable = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Integer,String&gt; classNameTable = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DataInputStream data = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">                    <span class="keyword">new</span> ByteArrayInputStream(classBytes));</span><br><span class="line">            <span class="keyword">int</span> magic = data.readInt(); <span class="comment">// 0xcafebabe</span></span><br><span class="line">            <span class="keyword">int</span> minorVersion = data.readShort();</span><br><span class="line">            <span class="keyword">int</span> majorVersion = data.readShort();</span><br><span class="line">            <span class="keyword">int</span> constantPoolCount = data.readShort();</span><br><span class="line">            <span class="keyword">int</span>[] constantPool = <span class="keyword">new</span> <span class="keyword">int</span>[constantPoolCount];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; constantPoolCount; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> tag = data.read();</span><br><span class="line">                <span class="comment">// int tableSize;</span></span><br><span class="line">                <span class="keyword">switch</span>(tag) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// UTF</span></span><br><span class="line">                        <span class="keyword">int</span> length = data.readShort();</span><br><span class="line">                        <span class="keyword">char</span>[] bytes = <span class="keyword">new</span> <span class="keyword">char</span>[length];</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; bytes.length; k++)</span><br><span class="line">                            bytes[k] = (<span class="keyword">char</span>)data.read();</span><br><span class="line">                        String className = <span class="keyword">new</span> String(bytes);</span><br><span class="line">                        classNameTable.put(i, className);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">5</span>: <span class="comment">// LONG</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="number">6</span>: <span class="comment">// DOUBLE</span></span><br><span class="line">                        data.readLong(); <span class="comment">// discard 8 bytes</span></span><br><span class="line">                        i++; <span class="comment">// Special skip necessary</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">7</span>: <span class="comment">// CLASS</span></span><br><span class="line">                        <span class="keyword">int</span> offset = data.readShort();</span><br><span class="line">                        offsetTable.put(i, offset);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">8</span>: <span class="comment">// STRING</span></span><br><span class="line">                        data.readShort(); <span class="comment">// discard 2 bytes</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">// INTEGER</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="number">4</span>: <span class="comment">// FLOAT</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="number">9</span>: <span class="comment">// FIELD_REF</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="number">10</span>: <span class="comment">// METHOD_REF</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="number">11</span>: <span class="comment">// INTERFACE_METHOD_REF</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="number">12</span>: <span class="comment">// NAME_AND_TYPE</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="number">18</span>: <span class="comment">// Invoke Dynamic</span></span><br><span class="line">                        data.readInt(); <span class="comment">// discard 4 bytes</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">15</span>: <span class="comment">// Method Handle</span></span><br><span class="line">                        data.readByte();</span><br><span class="line">                        data.readShort();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">16</span>: <span class="comment">// Method Type</span></span><br><span class="line">                        data.readShort();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">throw</span></span><br><span class="line">                                <span class="keyword">new</span> RuntimeException(<span class="string">"Bad tag "</span> + tag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">short</span> accessFlags = data.readShort();</span><br><span class="line">            String access = (accessFlags &amp; <span class="number">0x0001</span>) == <span class="number">0</span> ?</span><br><span class="line">                    <span class="string">"nonpublic:"</span> : <span class="string">"public:"</span>;</span><br><span class="line">            <span class="keyword">int</span> thisClass = data.readShort();</span><br><span class="line">            <span class="keyword">int</span> superClass = data.readShort();</span><br><span class="line">            <span class="keyword">return</span> access + classNameTable.get(</span><br><span class="line">                    offsetTable.get(thisClass)).replace(<span class="string">'/'</span>, <span class="string">'.'</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException | RuntimeException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Demonstration:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        PathMatcher matcher = FileSystems.getDefault()</span><br><span class="line">                .getPathMatcher(<span class="string">"glob:**/*.class"</span>);</span><br><span class="line"><span class="comment">// Walk the entire tree:</span></span><br><span class="line">        Files.walk(Paths.get(<span class="string">"."</span>))</span><br><span class="line">                .filter(matcher::matches)</span><br><span class="line">                .map(p -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> thisClass(Files.readAllBytes(p));</span><br><span class="line">                    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .filter(s -&gt; s.startsWith(<span class="string">"public:"</span>))</span><br><span class="line"><span class="comment">// .filter(s -&gt; s.indexOf('$') &gt;= 0)</span></span><br><span class="line">                .map(s -&gt; s.split(<span class="string">":"</span>)[<span class="number">1</span>])</span><br><span class="line">                .filter(s -&gt; !s.startsWith(<span class="string">"enums."</span>))</span><br><span class="line">                .filter(s -&gt; s.contains(<span class="string">"."</span>))</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">onjava.ArrayShow</span><br><span class="line">onjava.atunit.AtUnit$TestMethods</span><br><span class="line">onjava.atunit.AtUnit</span><br><span class="line">onjava.atunit.ClassNameFinder</span><br><span class="line">onjava.atunit.Test</span><br><span class="line">onjava.atunit.TestObjectCleanup</span><br><span class="line">onjava.atunit.TestObjectCreate</span><br><span class="line">onjava.atunit.TestProperty</span><br><span class="line">onjava.BasicSupplier</span><br><span class="line">onjava.CollectionMethodDifferences</span><br><span class="line">onjava.ConvertTo</span><br><span class="line">onjava.Count$Boolean</span><br><span class="line">onjava.Count$Byte</span><br><span class="line">onjava.Count$Character</span><br><span class="line">onjava.Count$Double</span><br><span class="line">onjava.Count$Float</span><br><span class="line">onjava.Count$Integer</span><br><span class="line">onjava.Count$Long</span><br><span class="line">onjava.Count$Pboolean</span><br><span class="line">onjava.Count$Pbyte</span><br><span class="line">onjava.Count$Pchar</span><br><span class="line">onjava.Count$Pdouble</span><br><span class="line">onjava.Count$Pfloat</span><br><span class="line">onjava.Count$Pint</span><br><span class="line">onjava.Count$Plong</span><br><span class="line">onjava.Count$Pshort</span><br><span class="line">onjava.Count$Short</span><br><span class="line">onjava.Count</span><br><span class="line">onjava.CountingIntegerList</span><br><span class="line">onjava.CountMap</span><br><span class="line">onjava.Countries</span><br><span class="line">onjava.Enums</span><br><span class="line">onjava.FillMap</span><br><span class="line">onjava.HTMLColors</span><br><span class="line">onjava.MouseClick</span><br><span class="line">onjava.Nap</span><br><span class="line">onjava.Null</span><br><span class="line">onjava.Operations</span><br><span class="line">onjava.OSExecute</span><br><span class="line">onjava.OSExecuteException</span><br><span class="line">onjava.Pair</span><br><span class="line">onjava.ProcessFiles$Strategy</span><br><span class="line">onjava.ProcessFiles</span><br><span class="line">onjava.Rand$Boolean</span><br><span class="line">onjava.Rand$Byte</span><br><span class="line">onjava.Rand$Character</span><br><span class="line">onjava.Rand$Double</span><br><span class="line">onjava.Rand$Float</span><br><span class="line">onjava.Rand$Integer</span><br><span class="line">onjava.Rand$Long</span><br><span class="line">onjava.Rand$Pboolean</span><br><span class="line">onjava.Rand$Pbyte</span><br><span class="line">onjava.Rand$Pchar</span><br><span class="line">onjava.Rand$Pdouble</span><br><span class="line">onjava.Rand$Pfloat</span><br><span class="line">onjava.Rand$Pint</span><br><span class="line">onjava.Rand$Plong</span><br><span class="line">onjava.Rand$Pshort</span><br><span class="line">onjava.Rand$Short</span><br><span class="line">onjava.Rand$String</span><br><span class="line">onjava.Rand</span><br><span class="line">onjava.Range</span><br><span class="line">onjava.Repeat</span><br><span class="line">onjava.RmDir</span><br><span class="line">onjava.Sets</span><br><span class="line">onjava.Stack</span><br><span class="line">onjava.Suppliers</span><br><span class="line">onjava.TimedAbort</span><br><span class="line">onjava.Timer</span><br><span class="line">onjava.Tuple</span><br><span class="line">onjava.Tuple2</span><br><span class="line">onjava.Tuple3</span><br><span class="line">onjava.Tuple4</span><br><span class="line">onjava.Tuple5</span><br><span class="line">onjava.TypeCounter</span><br></pre></td></tr></table></figure><p> 虽然无法在这里介绍其中所有的细节，但是每个类文件都必须遵循一定的格式，而我已经尽力用有意义的字段来表示这些从 <strong>ByteArrayInputStream</strong> 中提取出来的数据片段。通过施加在输入流上的读操作，你能看出每个信息片的大小。例如每一个类的头 32 个 bit 总是一个 “神秘数字” <strong>0xcafebabe</strong>，而接下来的两个 <strong>short</strong> 值是版本信息。常量池包含了程序的常量，所以这是一个可变的值。接下来的 <strong>short</strong> 告诉我们这个常量池有多大，然后我们为其创建一个尺寸合适的数组。常量池中的每一个元素，其长度可能是固定式，也可能是可变的值，因此我们必须检查每一个常量的起始标记，然后才能知道该怎么做，这就是 switch 语句的工作。我们并不打算精确的分析类中所有的数据，仅仅是从文件的起始一步一步的走，直到取得我们所需的信息，因此你会发现，在这个过程中我们丢弃了大量的数据。关于类的信息都保存在 <strong>classNameTable</strong> 和 <strong>offsetTable</strong> 中。在读取常量池之后，就找到了 <strong>this_class</strong> 信息，这是 <strong>offsetTable</strong> 的一个坐标，通过它可以找到进入  <strong>classNameTable</strong> 的坐标，然后就可以得到我们所需的类的名字了。</p><p>现在让我们回到 <strong>AtUtil.java</strong> 中，process() 方法中拥有了类的名字，然后检查它是否包含“.”，如果有就表示该类定义于一个包中。没有包的类会被忽略。如果一个类在包中，那么我们就可以使用标准的类加载器通过 <code>Class.forName()</code>  将其加载进来。现在我们可以对这个类进行 <strong>@Unit</strong> 注解的分析工作了。</p><p>我们只需要关注三件事：首先是 <strong>@Test</strong> 方法，它们被保存在 <strong>TestMehtods</strong> 列表中，然后检查其是否具有 @TestObjectCreate 和 <strong>@TestObjectCleanup****</strong> 方法。从代码中可以看到，我们通过调用相应的方法来查询注解从而找到这些方法。</p><p>每找到一个 @Test 方法，就打印出来当前类的名字，于是观察者立刻就可以知道发生了什么。接下来开始执行测试，也就是打印出方法名，然后调用 createTestObject() （如果存在一个加了 @TestObjectCreate 注解的方法），或者调用默认构造器。一旦创建出来测试对象，如果调用其上的测试方法。如果测试的返回值为 boolean，就捕获该结果。如果测试方法没有返回值，那么就没有异常发生，我们就假设测试成功，反之，如果当 assert 失败或者有任何异常抛出的时候，就说明测试失败，这时将异常信息打印出来以显示错误的原因。如果有失败的测试发生，那么还要统计失败的次数，并将失败所属的类和方法加入到 failedTests 中，以便最后报告给用户。</p><!-- Summary --><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>注解是 Java 引入的一项非常受欢迎的补充，它提供了一种结构化，并且具有类型检查能力的新途径，从而使得你能够为代码中加入元数据，而且不会导致代码杂乱并难以阅读。使用注解能够帮助我们避免编写累赘的部署描述性文件，以及其他的生成文件。而 Javadoc 中的 @deprecated 被 @Deprecated 注解所替代的事实也说明，与注释性文字相比，注解绝对更适用于描述类相关的信息。</p><p>Java 提供了很少的内置注解。这意味着如果你在别处找不到可用的类库，那么就只能自己创建新的注解以及相应的处理器。通过将注解处理器链接到 javac，你可以一步完成编译新生成的文件，简化了构造过程。</p><p>API 的提供方和框架将会将注解作为他们工具的一部分。通过 @Unit 系统，我们可以想象，注解会极大的改变我们的 Java 编程体验。</p><!-- 分页 --><div style="page-break-after: always;"></div><p>[^3 ]: The Java designers coyly suggest that a mirror is where you find a reflection.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接口和抽象类提供了一种将接口与实现分离的更加结构化的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java编程思想-第二十章 泛型阅读笔记</title>
    <link href="http://yoursite.com/2020/06/28/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0%20%E6%B3%9B%E5%9E%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/06/28/Java编程思想-第二十章 泛型阅读笔记/</id>
    <published>2020-06-28T02:53:12.000Z</published>
    <updated>2020-06-29T06:23:02.363Z</updated>
    
    <content type="html"><![CDATA[<p>接口和抽象类提供了一种将接口与实现分离的更加结构化的方法。</p><a id="more"></a><p>[TOC]</p><!-- Generics --><h1 id="第二十章-泛型"><a href="#第二十章-泛型" class="headerlink" title="第二十章 泛型"></a>第二十章 泛型</h1><blockquote><p>普通的类和方法只能使用特定的类型：基本数据类型或类类型。如果编写的代码需要应用于多种类型，这种严苛的限制对代码的束缚就会很大。</p></blockquote><p>多态是一种面向对象思想的泛化机制。可以将方法的参数类型设为基类，这样的方法就可以接受任何派生类作为参数，包括暂时还不存在的类。这样的方法更通用，应用范围更广。在类内部也是如此，在任何使用特定类型的地方，基类意味着更大的灵活性。除了 <code>final</code> 类（或只提供私有构造函数的类）任何类型都可被扩展，所以大部分时候这种灵活性是自带的。</p><p>拘泥于单一的继承体系太过局限，因为只有继承体系中的对象才能适用基类作为参数的方法中。如果方法以接口而不是类作为参数，限制就宽松多了，只要实现了接口就可以。这给予调用方一种选项，通过调整现有的类来实现接口，满足方法参数要求。接口可以突破继承体系的限制。</p><p>即便是接口也还是有诸多限制。一旦指定了接口，它就要求我们的代码必须使用特定的接口。而我们希望编写更通用的代码，能够适用“非特定的类型”，而不是一个具体的接口或类。</p><p>这就是泛型的概念，是 Java 5 的重大变化之一。泛型实现了<em>参数化类型</em>，这样我们编写的组件（通常是集合）可以适用于多种类型。“泛型”这个术语的含义是“适用于很多类型”。编程语言中泛型出现的初衷是通过解耦类或方法与所使用的类型之间的约束，使得类或方法具备最宽泛的表达力。随后我们会发现 Java 中泛型的实现并没有那么“泛”，我们可能会质疑“泛型”这个词是否合适用来描述这一功能。</p><p>如果我们从未接触过参数化类型机制，我们会发现泛型对 Java 语言确实是个很有益的补充。在我们实例化一个类型参数时，编译器会负责转型并确保类型的正确性。这是一大进步。</p><p>然而，如果我们了解其他语言（例如 C++ ）的参数化机制，我们会发现，Java 泛型并不能满足所有的预期。使用别人创建好的泛型相对容易，但是创建自己的泛型时，就会遇到很多意料之外的麻烦。</p><p>这并不是说 Java 泛型毫无用处。在很多情况下，它可以使代码更直接更优雅。不过，如果我们见识过那种实现了更纯粹的泛型的编程语言，那么，Java 可能会令我们失望。本章会介绍 Java 泛型的优点与局限。我会解释 Java 的泛型是如何发展成现在这样的，希望能够帮助我们更有效地使用这个特性。</p><h3 id="与-C-的比较"><a href="#与-C-的比较" class="headerlink" title="与 C++ 的比较"></a>与 C++ 的比较</h3><p>Java 的设计者曾说过，这门语言的灵感主要来自 C++ 。尽管如此，学习 Java 时基本不用参考 C++ 。</p><p>但是，Java 中的泛型需要与 C++ 进行对比，理由有两个：首先，理解 C++ <em>模板</em>（泛型的主要灵感来源，包括基本语法）的某些特性，有助于理解泛型的基础理念。同时，非常重要的一点是，我们可以了解 Java 泛型的局限是什么，以及为什么会有这些局限。最终的目标是明确 Java 泛型的边界，让我们成为一个程序高手。只有知道了某个技术不能做什么，我们才能更好地做到所能做的（部分原因是，不必浪费时间在死胡同里）。</p><p>第二个原因是，在 Java 社区中，大家普遍对 C++ 模板有一种误解，而这种误解可能会令我们在理解泛型的意图时产生偏差。</p><p>因此，本章中会介绍少量 C++ 模板的例子，仅当它们确实可以加深理解时才会引入。</p><!-- Simple Generics --><h2 id="简单泛型"><a href="#简单泛型" class="headerlink" title="简单泛型"></a>简单泛型</h2><p>促成泛型出现的最主要的动机之一是为了创建<em>集合类</em>，参见 集合 章节。集合用于存放要使用到的对象。数组也是如此，不过集合比数组更加灵活，功能更丰富。几乎所有程序在运行过程中都会涉及到一组对象，因此集合是可复用性最高的类库之一。</p><p>我们先看一个只能持有单个对象的类。这个类可以明确指定其持有的对象的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Holder1.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Automobile</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Automobile a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder1</span><span class="params">(Automobile a)</span> </span>&#123; <span class="keyword">this</span>.a = a; &#125;</span><br><span class="line">    <span class="function">Automobile <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类的可复用性不高，它无法持有其他类型的对象。我们可不希望为碰到的每个类型都编写一个新的类。</p><p>在 Java 5 之前，我们可以让这个类直接持有 <code>Object</code> 类型的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ObjectHolder.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObjectHolder</span><span class="params">(Object a)</span> </span>&#123; <span class="keyword">this</span>.a = a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object a)</span> </span>&#123; <span class="keyword">this</span>.a = a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ObjectHolder h2 = <span class="keyword">new</span> ObjectHolder(<span class="keyword">new</span> Automobile());</span><br><span class="line">        Automobile a = (Automobile)h2.get();</span><br><span class="line">        h2.set(<span class="string">"Not an Automobile"</span>);</span><br><span class="line">        String s = (String)h2.get();</span><br><span class="line">        h2.set(<span class="number">1</span>); <span class="comment">// 自动装箱为 Integer</span></span><br><span class="line">        Integer x = (Integer)h2.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，<code>ObjectHolder</code> 可以持有任何类型的对象，在上面的示例中，一个 <code>ObjectHolder</code> 先后持有了三种不同类型的对象。</p><p>一个集合中存储多种不同类型的对象的情况很少见，通常而言，我们只会用集合存储同一种类型的对象。泛型的主要目的之一就是用来约定集合要存储什么类型的对象，并且通过编译器确保规约得以满足。</p><p>因此，与其使用 <code>Object</code> ，我们更希望先指定一个类型占位符，稍后再决定具体使用什么类型。要达到这个目的，需要使用<em>类型参数</em>，用尖括号括住，放在类名后面。然后在使用这个类时，再用实际的类型替换此类型参数。在下面的例子中，<code>T</code> 就是类型参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericHolder.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericHolder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericHolder</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T a)</span> </span>&#123; <span class="keyword">this</span>.a = a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericHolder&lt;Automobile&gt; h3 = <span class="keyword">new</span> GenericHolder&lt;Automobile&gt;();</span><br><span class="line">        h3.set(<span class="keyword">new</span> Automobile()); <span class="comment">// 此处有类型校验</span></span><br><span class="line">        Automobile a = h3.get();  <span class="comment">// 无需类型转换</span></span><br><span class="line">        <span class="comment">//- h3.set("Not an Automobile"); // 报错</span></span><br><span class="line">        <span class="comment">//- h3.set(1);  // 报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 <code>GenericHolder</code> 对象时，必须指明要持有的对象的类型，将其置于尖括号内，就像 <code>main()</code> 中那样使用。然后，我们就只能在 <code>GenericHolder</code> 中存储该类型（或其子类，因为多态与泛型不冲突）的对象了。当我们调用 <code>get()</code> 取值时，直接就是正确的类型。</p><p>这就是 Java 泛型的核心概念：我们只需告诉编译器要使用什么类型，剩下的细节交给它来处理。</p><p>我们可能注意到 <code>h3</code> 的定义非常繁复。在 <code>=</code> 左边有 <code>GenericHolder&lt;Automobile&gt;</code>, 右边又重复了一次。在 Java 5 中，这种写法被解释成“必要的”，但在 Java 7 中设计者修正了这个问题（新的简写语法随后成为备受欢迎的特性）。以下是简写的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Diamond.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bob</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Diamond</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericHolder&lt;Bob&gt; h3 = <span class="keyword">new</span> GenericHolder&lt;&gt;();</span><br><span class="line">        h3.set(<span class="keyword">new</span> Bob());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，在 <code>h3</code> 的定义处，<code>=</code> 右边的尖括号是空的（称为“钻石语法”），而不是重复左边的类型信息。在本书剩余部分都会使用这种语法。</p><p>一般来说，我们可以认为泛型和其他类型差不多，只不过它们碰巧有类型参数罢了。在使用泛型时，我们只需要指定它们的名称和类型参数列表即可。</p><h3 id="一个元组类库"><a href="#一个元组类库" class="headerlink" title="一个元组类库"></a>一个元组类库</h3><p>有时一个方法需要能返回多个对象。而 <strong>return</strong> 语句只能返回单个对象，解决方法就是创建一个对象，用它打包想要返回的多个对象。当然，可以在每次需要的时候，专门创建一个类来完成这样的工作。但是有了泛型，我们就可以一劳永逸。同时，还获得了编译时的类型安全。</p><p>这个概念称为<em>元组*，它是将一组对象直接打包存储于单一对象中。可以从该对象读取其中的元素，但不允许向其中存储新对象（这个概念也称为 *数据传输对象</em> 或 <em>信使</em> ）。</p><p>通常，元组可以具有任意长度，元组中的对象可以是不同类型的。不过，我们希望能够为每个对象指明类型，并且从元组中读取出来时，能够得到正确的类型。要处理不同长度的问题，我们需要创建多个不同的元组。下面是一个可以存储两个对象的元组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/Tuple2.java</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple2</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> A a1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> B a2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tuple2</span><span class="params">(A a, B b)</span> </span>&#123; a1 = a; a2 = b; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">rep</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> a1 + <span class="string">", "</span> + a2; &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"("</span> + rep() + <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数传入要存储的对象。这个元组隐式地保持了其中元素的次序。</p><p>初次阅读上面的代码时，我们可能认为这违反了 Java 编程的封装原则。<code>a1</code> 和 <code>a2</code> 应该声明为 <strong>private</strong>，然后提供 <code>getFirst()</code> 和 <code>getSecond()</code> 取值方法才对呀？考虑下这样做能提供的“安全性”是什么：元组的使用程序可以读取 <code>a1</code> 和 <code>a2</code> 然后对它们执行任何操作，但无法对 <code>a1</code> 和 <code>a2</code> 重新赋值。例子中的 <code>final</code> 可以实现同样的效果，并且更为简洁明了。</p><p>另一种设计思路是允许元组的用户给 <code>a1</code> 和 <code>a2</code> 重新赋值。然而，采用上例中的形式无疑更加安全，如果用户想存储不同的元素，就会强制他们创建新的 <code>Tuple2</code> 对象。</p><p>我们可以利用继承机制实现长度更长的元组。添加更多的类型参数就行了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/Tuple3.java</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple3</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>&gt; <span class="keyword">extends</span> <span class="title">Tuple2</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> C a3;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tuple3</span><span class="params">(A a, B b, C c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(a, b);</span><br><span class="line">        a3 = c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">rep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.rep() + <span class="string">", "</span> + a3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// onjava/Tuple4.java</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple4</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>, <span class="title">D</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">Tuple3</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> D a4;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tuple4</span><span class="params">(A a, B b, C c, D d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(a, b, c);</span><br><span class="line">        a4 = d;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">rep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.rep() + <span class="string">", "</span> + a4;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// onjava/Tuple5.java</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple5</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>, <span class="title">D</span>, <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">Tuple4</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>, <span class="title">D</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> E a5;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tuple5</span><span class="params">(A a, B b, C c, D d, E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(a, b, c, d);</span><br><span class="line">        a5 = e;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">rep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.rep() + <span class="string">", "</span> + a5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>演示需要，再定义两个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Amphibian.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Amphibian</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// generics/Vehicle.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>使用元组时，我们只需要定义一个长度适合的元组，将其作为返回值即可。注意下面例子中方法的返回类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/TupleTest.java</span></span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TupleTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Tuple2&lt;String, Integer&gt; <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 47 自动装箱为 Integer</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;&gt;(<span class="string">"hi"</span>, <span class="number">47</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> Tuple3&lt;Amphibian, String, Integer&gt; <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple3&lt;&gt;(<span class="keyword">new</span> Amphibian(), <span class="string">"hi"</span>, <span class="number">47</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> Tuple4&lt;Vehicle, Amphibian, String, Integer&gt; <span class="title">h</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple4&lt;&gt;(<span class="keyword">new</span> Vehicle(), <span class="keyword">new</span> Amphibian(), <span class="string">"hi"</span>, <span class="number">47</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> Tuple5&lt;Vehicle, Amphibian, String, Integer, Double&gt; <span class="title">k</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple5&lt;&gt;(<span class="keyword">new</span> Vehicle(), <span class="keyword">new</span> Amphibian(), <span class="string">"hi"</span>, <span class="number">47</span>, <span class="number">11.1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Tuple2&lt;String, Integer&gt; ttsi = f();</span><br><span class="line">        System.out.println(ttsi);</span><br><span class="line">        <span class="comment">// ttsi.a1 = "there"; // 编译错误，因为 final 不能重新赋值</span></span><br><span class="line">        System.out.println(g());</span><br><span class="line">        System.out.println(h());</span><br><span class="line">        System.out.println(k());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment"> (hi, 47)</span></span><br><span class="line"><span class="comment"> (Amphibian@1540e19d, hi, 47)</span></span><br><span class="line"><span class="comment"> (Vehicle@7f31245a, Amphibian@6d6f6e28, hi, 47)</span></span><br><span class="line"><span class="comment"> (Vehicle@330bedb4, Amphibian@2503dbd3, hi, 47, 11.1)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>有了泛型，我们可以很容易地创建元组，令其返回一组任意类型的对象。</p><p>通过 <code>ttsi.a1 = &quot;there&quot;</code> 语句的报错，我们可以看出，<strong>final</strong> 声明确实可以确保 <strong>public</strong> 字段在对象被构造出来之后就不能重新赋值了。</p><p>在上面的程序中，<code>new</code> 表达式有些啰嗦。本章稍后会介绍，如何利用 <em>泛型方法</em> 简化它们。</p><h3 id="一个堆栈类"><a href="#一个堆栈类" class="headerlink" title="一个堆栈类"></a>一个堆栈类</h3><p>接下来我们看一个稍微复杂一点的例子：堆栈。在 <a href="book/12-Collections.md">集合</a> 一章中，我们用 <code>LinkedList</code> 实现了 <code>onjava.Stack</code> 类。在那个例子中，<code>LinkedList</code> 本身已经具备了创建堆栈所需的方法。<code>Stack</code> 是通过两个泛型类 <code>Stack&lt;T&gt;</code> 和 <code>LinkedList&lt;T&gt;</code> 的组合来创建。我们可以看出，泛型只不过是一种类型罢了（稍后我们会看到一些例外的情况）。</p><p>这次我们不用 <code>LinkedList</code> 来实现自己的内部链式存储机制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/LinkedStack.java</span></span><br><span class="line"><span class="comment">// 用链式结构实现的堆栈</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedStack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">U</span>&gt; </span>&#123;</span><br><span class="line">        U item;</span><br><span class="line">        Node&lt;U&gt; next;</span><br><span class="line">    </span><br><span class="line">        Node() &#123; item = <span class="keyword">null</span>; next = <span class="keyword">null</span>; &#125;</span><br><span class="line">        </span><br><span class="line">        Node(U item, Node&lt;U&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> item == <span class="keyword">null</span> &amp;&amp; next == <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; top = <span class="keyword">new</span> Node&lt;&gt;();  <span class="comment">// 栈顶</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">        top = <span class="keyword">new</span> Node&lt;&gt;(item, top);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T result = top.item;</span><br><span class="line">        <span class="keyword">if</span> (!top.end()) &#123;</span><br><span class="line">            top = top.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedStack&lt;String&gt; lss = <span class="keyword">new</span> LinkedStack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : <span class="string">"Phasers on stun!"</span>.split(<span class="string">" "</span>)) &#123;</span><br><span class="line">            lss.push(s);</span><br><span class="line">        &#125;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span> ((s = lss.pop()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stun!</span><br><span class="line">on</span><br><span class="line">Phasers</span><br></pre></td></tr></table></figure><p>内部类 <code>Node</code> 也是一个泛型，它拥有自己的类型参数。</p><p>这个例子使用了一个 <em>末端标识</em> (end sentinel) 来判断栈何时为空。这个末端标识是在构造 <code>LinkedStack</code> 时创建的。然后，每次调用 <code>push()</code> 就会创建一个 <code>Node&lt;T&gt;</code> 对象，并将其链接到前一个 <code>Node&lt;T&gt;</code> 对象。当我们调用 <code>pop()</code> 方法时，总是返回 <code>top.item</code>，然后丢弃当前 <code>top</code> 所指向的 <code>Node&lt;T&gt;</code>，并将 <code>top</code> 指向下一个 <code>Node&lt;T&gt;</code>，除非到达末端标识，这时就不能再移动 <code>top</code> 了。如果已经到达末端，程序还继续调用 <code>pop()</code> 方法，它只能得到 <code>null</code>，说明栈已经空了。</p><h3 id="RandomList"><a href="#RandomList" class="headerlink" title="RandomList"></a>RandomList</h3><p>作为容器的另一个例子，假设我们需要一个持有特定类型对象的列表，每次调用它的 <code>select()</code> 方法时都随机返回一个元素。如果希望这种列表可以适用于各种类型，就需要使用泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/RandomList.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(rand.nextInt(size()));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RandomList&lt;String&gt; rs = <span class="keyword">new</span> RandomList&lt;&gt;();</span><br><span class="line">        Arrays.stream(<span class="string">"The quick brown fox jumped over the lazy brown dog"</span>.split(<span class="string">" "</span>)).forEach(rs::add);</span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">11</span>).forEach(i -&gt; </span><br><span class="line">            System.out.print(rs.select() + <span class="string">" "</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brown over fox quick quick dog brown The brown lazy brown</span><br></pre></td></tr></table></figure><p><code>RandomList</code> 继承了 <code>ArrayList</code> 的所有方法。本例中只添加了 <code>select()</code> 这个方法。</p><!-- Generic Interfaces --><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>泛型也可以应用于接口。例如 <em>生成器*，这是一种专门负责创建对象的类。实际上，这是 *工厂方法</em> 设计模式的一种应用。不过，当使用生成器创建新的对象时，它不需要任何参数，而工厂方法一般需要参数。生成器无需额外的信息就知道如何创建新对象。</p><p>一般而言，一个生成器只定义一个方法，用于创建对象。例如 <code>java.util.function</code> 类库中的 <code>Supplier</code> 就是一个生成器，调用其 <code>get()</code> 获取对象。<code>get()</code> 是泛型方法，返回值为类型参数 <code>T</code>。</p><p>为了演示 <code>Supplier</code>，我们需要定义几个类。下面是个咖啡相关的继承体系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/coffee/Coffee.java</span></span><br><span class="line"><span class="keyword">package</span> generics.coffee;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getSimpleName() + <span class="string">" "</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// generics/coffee/Latte.java</span></span><br><span class="line"><span class="keyword">package</span> generics.coffee;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Latte</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// generics/coffee/Mocha.java</span></span><br><span class="line"><span class="keyword">package</span> generics.coffee;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mocha</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// generics/coffee/Cappuccino.java</span></span><br><span class="line"><span class="keyword">package</span> generics.coffee;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cappuccino</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// generics/coffee/Americano.java</span></span><br><span class="line"><span class="keyword">package</span> generics.coffee;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Americano</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// generics/coffee/Breve.java</span></span><br><span class="line"><span class="keyword">package</span> generics.coffee;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Breve</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>现在，我们可以编写一个类，实现 <code>Supplier&lt;Coffee&gt;</code> 接口，它能够随机生成不同类型的 <code>Coffee</code> 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/coffee/CoffeeSupplier.java</span></span><br><span class="line"><span class="comment">// &#123;java generics.coffee.CoffeeSupplier&#125;</span></span><br><span class="line"><span class="keyword">package</span> generics.coffee;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeSupplier</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">Coffee</span>&gt;, <span class="title">Iterable</span>&lt;<span class="title">Coffee</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] types = &#123; Latte.class, Mocha.class, </span><br><span class="line">        Cappuccino.class, Americano.class, Breve.class &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CoffeeSupplier</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// For iteration:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CoffeeSupplier</span><span class="params">(<span class="keyword">int</span> sz)</span> </span>&#123; size = sz; &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Coffee <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Coffee) types[rand.nextInt(types.length)].newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CoffeeIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Coffee</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = size;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> count &gt; <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Coffee <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            count--;</span><br><span class="line">            <span class="keyword">return</span> CoffeeSupplier.<span class="keyword">this</span>.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Coffee&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CoffeeIterator();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream.generate(<span class="keyword">new</span> CoffeeSupplier())</span><br><span class="line">              .limit(<span class="number">5</span>)</span><br><span class="line">              .forEach(System.out::println);</span><br><span class="line">        <span class="keyword">for</span> (Coffee c : <span class="keyword">new</span> CoffeeSupplier(<span class="number">5</span>)) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Americano <span class="number">0</span></span><br><span class="line">Latte <span class="number">1</span></span><br><span class="line">Americano <span class="number">2</span></span><br><span class="line">Mocha <span class="number">3</span></span><br><span class="line">Mocha <span class="number">4</span></span><br><span class="line">Breve <span class="number">5</span></span><br><span class="line">Americano <span class="number">6</span></span><br><span class="line">Latte <span class="number">7</span></span><br><span class="line">Cappuccino <span class="number">8</span></span><br><span class="line">Cappuccino <span class="number">9</span></span><br></pre></td></tr></table></figure><p>参数化的 <code>Supplier</code> 接口确保 <code>get()</code> 返回值是参数的类型。<code>CoffeeSupplier</code> 同时还实现了 <code>Iterable</code> 接口，所以能用于 <em>for-in</em> 语句。不过，它还需要知道何时终止循环，这正是第二个构造函数的作用。</p><p>下面是另一个实现 <code>Supplier&lt;T&gt;</code> 接口的例子，它负责生成 Fibonacci 数列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Fibonacci.java</span></span><br><span class="line"><span class="comment">// Generate a Fibonacci sequence</span></span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fibonacci</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> fib(count++); &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> fib(n-<span class="number">2</span>) + fib(n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream.generate(<span class="keyword">new</span> Fibonacci())</span><br><span class="line">              .limit(<span class="number">18</span>)</span><br><span class="line">              .map(n -&gt; n + <span class="string">" "</span>)</span><br><span class="line">              .forEach(System.out::print);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span> <span class="number">610</span> <span class="number">987</span> <span class="number">1597</span> <span class="number">2584</span></span><br></pre></td></tr></table></figure><p>虽然我们在 <code>Fibonacci</code> 类的里里外外使用的都是 <code>int</code> 类型，但是其参数类型却是 <code>Integer</code>。这个例子引出了 Java 泛型的一个局限性：基本类型无法作为类型参数。不过 Java 5 具备自动装箱和拆箱的功能，可以很方便地在基本类型和相应的包装类之间进行转换。通过这个例子中 <code>Fibonacci</code> 类对 <code>int</code> 的使用，我们已经看到了这种效果。</p><p>如果还想更进一步，编写一个实现了 <code>Iterable</code> 的 <code>Fibnoacci</code> 生成器。我们的一个选择是重写这个类，令其实现 <code>Iterable</code> 接口。不过，我们并不是总能拥有源代码的控制权，并且，除非必须这么做，否则，我们也不愿意重写一个类。而且我们还有另一种选择，就是创建一个 <em>适配器</em> (Adapter) 来实现所需的接口，我们在前面介绍过这个设计模式。</p><p>有多种方法可以实现适配器。例如，可以通过继承来创建适配器类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/IterableFibonacci.java</span></span><br><span class="line"><span class="comment">// Adapt the Fibonacci class to make it Iterable</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IterableFibonacci</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Fibonacci</span> <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IterableFibonacci</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123; n = count; &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Integer&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> n &gt; <span class="number">0</span>; &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                n--;</span><br><span class="line">                <span class="keyword">return</span> IterableFibonacci.<span class="keyword">this</span>.get();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123; <span class="comment">// Not implemented</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : <span class="keyword">new</span> IterableFibonacci(<span class="number">18</span>))</span><br><span class="line">            System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span> <span class="number">610</span> <span class="number">987</span> <span class="number">1597</span> <span class="number">2584</span></span><br></pre></td></tr></table></figure><p>在 <em>for-in</em> 语句中使用 <code>IterableFibonacci</code>，必须在构造函数中提供一个边界值，这样 <code>hasNext()</code> 才知道何时返回 <strong>false</strong>，结束循环。</p><!-- Generic Methods --><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>到目前为止，我们已经研究了参数化整个类。其实还可以参数化类中的方法。类本身可能是泛型的，也可能不是，不过这与它的方法是否是泛型的并没有什么关系。</p><p>泛型方法独立于类而改变方法。作为准则，请“尽可能”使用泛型方法。通常将单个方法泛型化要比将整个类泛型化更清晰易懂。</p><p>如果方法是 <strong>static</strong> 的，则无法访问该类的泛型类型参数，因此，如果使用了泛型类型参数，则它必须是泛型方法。</p><p>要定义泛型方法，请将泛型参数列表放置在返回值之前，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericMethods.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMethods</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">        System.out.println(x.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericMethods gm = <span class="keyword">new</span> GenericMethods();</span><br><span class="line">        gm.f(<span class="string">""</span>);</span><br><span class="line">        gm.f(<span class="number">1</span>);</span><br><span class="line">        gm.f(<span class="number">1.0</span>);</span><br><span class="line">        gm.f(<span class="number">1.0F</span>);</span><br><span class="line">        gm.f(<span class="string">'c'</span>);</span><br><span class="line">        gm.f(gm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">java.lang.String</span></span><br><span class="line"><span class="comment">java.lang.Integer</span></span><br><span class="line"><span class="comment">java.lang.Double</span></span><br><span class="line"><span class="comment">java.lang.Float</span></span><br><span class="line"><span class="comment">java.lang.Character</span></span><br><span class="line"><span class="comment">GenericMethods</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>尽管可以同时对类及其方法进行参数化，但这里未将 <strong>GenericMethods</strong> 类参数化。只有方法 <code>f()</code> 具有类型参数，该参数由方法返回类型之前的参数列表指示。</p><p>对于泛型类，必须在实例化该类时指定类型参数。使用泛型方法时，通常不需要指定参数类型，因为编译器会找出这些类型。 这称为 <em>类型参数推断</em>。因此，对 <code>f()</code> 的调用看起来像普通的方法调用，并且 <code>f()</code> 看起来像被重载了无数次一样。它甚至会接受 <strong>GenericMethods</strong> 类型的参数。</p><p>如果使用基本类型调用 <code>f()</code> ，自动装箱就开始起作用，自动将基本类型包装在它们对应的包装类型中。</p><!-- Varargs and Generic Methods --><h3 id="变长参数和泛型方法"><a href="#变长参数和泛型方法" class="headerlink" title="变长参数和泛型方法"></a>变长参数和泛型方法</h3><p>泛型方法和变长参数列表可以很好地共存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericVarargs.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericVarargs</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SafeVarargs</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">makeList</span><span class="params">(T... args)</span> </span>&#123;</span><br><span class="line">        List&lt;T&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (T item : args)</span><br><span class="line">            result.add(item);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; ls = makeList(<span class="string">"A"</span>);</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">        ls = makeList(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>);</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">        ls = makeList(</span><br><span class="line">                <span class="string">"ABCDEFFHIJKLMNOPQRSTUVWXYZ"</span>.split(<span class="string">""</span>));</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[A]</span></span><br><span class="line"><span class="comment">[A, B, C]</span></span><br><span class="line"><span class="comment">[A, B, C, D, E, F, F, H, I, J, K, L, M, N, O, P, Q, R,</span></span><br><span class="line"><span class="comment">S, T, U, V, W, X, Y, Z]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>此处显示的 <code>makeList()</code> 方法产生的功能与标准库的 <code>java.util.Arrays.asList()</code> 方法相同。</p><p><code>@SafeVarargs</code> 注解保证我们不会对变长参数列表进行任何修改，这是正确的，因为我们只从中读取。如果没有此注解，编译器将无法知道这些并会发出警告。</p><!-- A General-Purpose Supplier --><h3 id="一个泛型的-Supplier"><a href="#一个泛型的-Supplier" class="headerlink" title="一个泛型的 Supplier"></a>一个泛型的 Supplier</h3><p>这是一个为任意具有无参构造方法的类生成 <strong>Supplier</strong> 的类。为了减少键入，它还包括一个用于生成 <strong>BasicSupplier</strong> 的泛型方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/BasicSupplier.java</span></span><br><span class="line"><span class="comment">// Supplier from a class with a no-arg constructor</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicSupplier</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; type;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasicSupplier</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Assumes type is a public class:</span></span><br><span class="line">            <span class="keyword">return</span> type.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException |</span><br><span class="line">                IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Produce a default Supplier from a type token:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Supplier&lt;T&gt; <span class="title">create</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BasicSupplier&lt;&gt;(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此类提供了产生以下对象的基本实现：</p><ol><li><p>是 <strong>public</strong> 的。 因为 <strong>BasicSupplier</strong> 在单独的包中，所以相关的类必须具有 <strong>public</strong> 权限，而不仅仅是包级访问权限。</p></li><li><p>具有无参构造方法。要创建一个这样的 <strong>BasicSupplier</strong> 对象，请调用 <code>create()</code> 方法，并将要生成类型的类型令牌传递给它。通用的 <code>create()</code> 方法提供了 <code>BasicSupplier.create(MyType.class)</code> 这种较简洁的语法来代替较笨拙的 <code>new BasicSupplier &lt;MyType&gt;(MyType.class)</code>。</p></li></ol><p>例如，这是一个具有无参构造方法的简单类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/CountedObject.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountedObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">id</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"CountedObject "</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CountedObject</strong> 类可以跟踪自身创建了多少个实例，并通过 <code>toString()</code> 报告这些实例的数量。 <strong>BasicSupplier</strong> 可以轻松地为 <strong>CountedObject</strong> 创建 <strong>Supplier</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// generics/BasicSupplierDemo.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> onjava.BasicSupplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicSupplierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream.generate(</span><br><span class="line">                BasicSupplier.create(CountedObject.class))</span><br><span class="line">                .limit(<span class="number">5</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">CountedObject 0</span></span><br><span class="line"><span class="comment">CountedObject 1</span></span><br><span class="line"><span class="comment">CountedObject 2</span></span><br><span class="line"><span class="comment">CountedObject 3</span></span><br><span class="line"><span class="comment">CountedObject 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>泛型方法减少了产生 <strong>Supplier</strong> 对象所需的代码量。 Java 泛型强制传递 <strong>Class</strong> 对象，以便在 <code>create()</code> 方法中将其用于类型推断。</p><!-- Simplifying Tuple Use --><h3 id="简化元组的使用"><a href="#简化元组的使用" class="headerlink" title="简化元组的使用"></a>简化元组的使用</h3><p>使用类型参数推断和静态导入，我们将把早期的元组重写为更通用的库。在这里，我们使用重载的静态方法创建元组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/Tuple.java</span></span><br><span class="line"><span class="comment">// Tuple library using type argument inference</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;A, B&gt; <span class="function">Tuple2&lt;A, B&gt; <span class="title">tuple</span><span class="params">(A a, B b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;&gt;(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;A, B, C&gt; Tuple3&lt;A, B, C&gt;</span><br><span class="line">    tuple(A a, B b, C c) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple3&lt;&gt;(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;A, B, C, D&gt; Tuple4&lt;A, B, C, D&gt;</span><br><span class="line">    tuple(A a, B b, C c, D d) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple4&lt;&gt;(a, b, c, d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;A, B, C, D, E&gt;</span><br><span class="line">    <span class="function">Tuple5&lt;A, B, C, D, E&gt; <span class="title">tuple</span><span class="params">(A a, B b, C c, D d, E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple5&lt;&gt;(a, b, c, d, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们修改 <strong>TupleTest.java</strong> 来测试 <strong>Tuple.java</strong> :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/TupleTest2.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> onjava.Tuple2;</span><br><span class="line"><span class="keyword">import</span> onjava.Tuple3;</span><br><span class="line"><span class="keyword">import</span> onjava.Tuple4;</span><br><span class="line"><span class="keyword">import</span> onjava.Tuple5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> onjava.Tuple.tuple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TupleTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Tuple2&lt;String, Integer&gt; <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tuple(<span class="string">"hi"</span>, <span class="number">47</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Tuple2 <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tuple(<span class="string">"hi"</span>, <span class="number">47</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Tuple3&lt;Amphibian, String, Integer&gt; <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tuple(<span class="keyword">new</span> Amphibian(), <span class="string">"hi"</span>, <span class="number">47</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Tuple4&lt;Vehicle, Amphibian, String, Integer&gt; <span class="title">h</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tuple(</span><br><span class="line">                <span class="keyword">new</span> Vehicle(), <span class="keyword">new</span> Amphibian(), <span class="string">"hi"</span>, <span class="number">47</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Tuple5&lt;Vehicle, Amphibian,</span><br><span class="line">            String, Integer, Double&gt; k() &#123;</span><br><span class="line">        <span class="keyword">return</span> tuple(<span class="keyword">new</span> Vehicle(), <span class="keyword">new</span> Amphibian(),</span><br><span class="line">                <span class="string">"hi"</span>, <span class="number">47</span>, <span class="number">11.1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Tuple2&lt;String, Integer&gt; ttsi = f();</span><br><span class="line">        System.out.println(ttsi);</span><br><span class="line">        System.out.println(f2());</span><br><span class="line">        System.out.println(g());</span><br><span class="line">        System.out.println(h());</span><br><span class="line">        System.out.println(k());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">(hi, 47)</span></span><br><span class="line"><span class="comment">(hi, 47)</span></span><br><span class="line"><span class="comment">(Amphibian@14ae5a5, hi, 47)</span></span><br><span class="line"><span class="comment">(Vehicle@135fbaa4, Amphibian@45ee12a7, hi, 47)</span></span><br><span class="line"><span class="comment">(Vehicle@4b67cf4d, Amphibian@7ea987ac, hi, 47, 11.1)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>请注意，<code>f()</code> 返回一个参数化的 <strong>Tuple2</strong> 对象，而 <code>f2()</code> 返回一个未参数化的 <strong>Tuple2</strong> 对象。编译器不会在这里警告 <code>f2()</code> ，因为返回值未以参数化方式使用。从某种意义上说，它被“向上转型”为一个未参数化的 <strong>Tuple2</strong> 。 但是，如果尝试将 <code>f2()</code> 的结果放入到参数化的 <strong>Tuple2</strong> 中，则编译器将发出警告。</p><!-- A Set Utility --><h3 id="一个-Set-工具"><a href="#一个-Set-工具" class="headerlink" title="一个 Set 工具"></a>一个 Set 工具</h3><p>对于泛型方法的另一个示例，请考虑由 <strong>Set</strong> 表示的数学关系。这些被方便地定义为可用于所有不同类型的泛型方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/Sets.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sets</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Set&lt;T&gt; <span class="title">union</span><span class="params">(Set&lt;T&gt; a, Set&lt;T&gt; b)</span> </span>&#123;</span><br><span class="line">        Set&lt;T&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;(a);</span><br><span class="line">        result.addAll(b);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line">    <span class="function">Set&lt;T&gt; <span class="title">intersection</span><span class="params">(Set&lt;T&gt; a, Set&lt;T&gt; b)</span> </span>&#123;</span><br><span class="line">        Set&lt;T&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;(a);</span><br><span class="line">        result.retainAll(b);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Subtract subset from superset:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Set&lt;T&gt;</span><br><span class="line">    difference(Set&lt;T&gt; superset, Set&lt;T&gt; subset) &#123;</span><br><span class="line">        Set&lt;T&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;(superset);</span><br><span class="line">        result.removeAll(subset);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reflexive--everything not in the intersection:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Set&lt;T&gt; <span class="title">complement</span><span class="params">(Set&lt;T&gt; a, Set&lt;T&gt; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> difference(union(a, b), intersection(a, b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前三个方法通过将第一个参数的引用复制到新的 <strong>HashSet</strong> 对象中来复制第一个参数，因此不会直接修改参数集合。因此，返回值是一个新的 <strong>Set</strong> 对象。</p><p>这四种方法代表数学集合操作： <code>union()</code> 返回一个包含两个参数并集的 <strong>Set</strong> ， <code>intersection()</code> 返回一个包含两个参数集合交集的 <strong>Set</strong> ， <code>difference()</code> 从 <strong>superset</strong> 中减去 <strong>subset</strong> 的元素 ，而 <code>complement()</code> 返回所有不在交集中的元素的 <strong>Set</strong>。作为显示这些方法效果的简单示例的一部分，下面是一个包含不同水彩名称的 <strong>enum</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/watercolors/Watercolors.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> watercolors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Watercolors &#123;</span><br><span class="line">    ZINC, LEMON_YELLOW, MEDIUM_YELLOW, DEEP_YELLOW,</span><br><span class="line">    ORANGE, BRILLIANT_RED, CRIMSON, MAGENTA,</span><br><span class="line">    ROSE_MADDER, VIOLET, CERULEAN_BLUE_HUE,</span><br><span class="line">    PHTHALO_BLUE, ULTRAMARINE, COBALT_BLUE_HUE,</span><br><span class="line">    PERMANENT_GREEN, VIRIDIAN_HUE, SAP_GREEN,</span><br><span class="line">    YELLOW_OCHRE, BURNT_SIENNA, RAW_UMBER,</span><br><span class="line">    BURNT_UMBER, PAYNES_GRAY, IVORY_BLACK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了方便起见（不必全限定所有名称），将其静态导入到以下示例中。本示例使用 <strong>EnumSet</strong> 轻松从 <strong>enum</strong> 中创建 <strong>Set</strong> 。（可以在<a href="book/22-Enumerations.md">第二十二章 枚举</a>一章中了解有关 <strong>EnumSet</strong> 的更多信息。）在这里，静态方法 <code>EnumSet.range()</code> 要求提供所要在结果 <strong>Set</strong> 中创建的元素范围的第一个和最后一个元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/WatercolorSets.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> watercolors.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.EnumSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> watercolors.Watercolors.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> onjava.Sets.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WatercolorSets</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;Watercolors&gt; set1 =</span><br><span class="line">                EnumSet.range(BRILLIANT_RED, VIRIDIAN_HUE);</span><br><span class="line">        Set&lt;Watercolors&gt; set2 =</span><br><span class="line">                EnumSet.range(CERULEAN_BLUE_HUE, BURNT_UMBER);</span><br><span class="line">        System.out.println(<span class="string">"set1: "</span> + set1);</span><br><span class="line">        System.out.println(<span class="string">"set2: "</span> + set2);</span><br><span class="line">        System.out.println(</span><br><span class="line">                <span class="string">"union(set1, set2): "</span> + union(set1, set2));</span><br><span class="line">        Set&lt;Watercolors&gt; subset = intersection(set1, set2);</span><br><span class="line">        System.out.println(</span><br><span class="line">                <span class="string">"intersection(set1, set2): "</span> + subset);</span><br><span class="line">        System.out.println(<span class="string">"difference(set1, subset): "</span> +</span><br><span class="line">                difference(set1, subset));</span><br><span class="line">        System.out.println(<span class="string">"difference(set2, subset): "</span> +</span><br><span class="line">                difference(set2, subset));</span><br><span class="line">        System.out.println(<span class="string">"complement(set1, set2): "</span> +</span><br><span class="line">                complement(set1, set2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">set1: [BRILLIANT_RED, CRIMSON, MAGENTA, ROSE_MADDER,</span></span><br><span class="line"><span class="comment">VIOLET, CERULEAN_BLUE_HUE, PHTHALO_BLUE, ULTRAMARINE,</span></span><br><span class="line"><span class="comment">COBALT_BLUE_HUE, PERMANENT_GREEN, VIRIDIAN_HUE]</span></span><br><span class="line"><span class="comment">set2: [CERULEAN_BLUE_HUE, PHTHALO_BLUE, ULTRAMARINE,</span></span><br><span class="line"><span class="comment">COBALT_BLUE_HUE, PERMANENT_GREEN, VIRIDIAN_HUE,</span></span><br><span class="line"><span class="comment">SAP_GREEN, YELLOW_OCHRE, BURNT_SIENNA, RAW_UMBER,</span></span><br><span class="line"><span class="comment">BURNT_UMBER]</span></span><br><span class="line"><span class="comment">union(set1, set2): [BURNT_SIENNA, BRILLIANT_RED,</span></span><br><span class="line"><span class="comment">YELLOW_OCHRE, MAGENTA, SAP_GREEN, CERULEAN_BLUE_HUE,</span></span><br><span class="line"><span class="comment">ULTRAMARINE, VIRIDIAN_HUE, VIOLET, RAW_UMBER,</span></span><br><span class="line"><span class="comment">ROSE_MADDER, PERMANENT_GREEN, BURNT_UMBER,</span></span><br><span class="line"><span class="comment">PHTHALO_BLUE, CRIMSON, COBALT_BLUE_HUE]</span></span><br><span class="line"><span class="comment">intersection(set1, set2): [PERMANENT_GREEN,</span></span><br><span class="line"><span class="comment">CERULEAN_BLUE_HUE, ULTRAMARINE, VIRIDIAN_HUE,</span></span><br><span class="line"><span class="comment">PHTHALO_BLUE, COBALT_BLUE_HUE]</span></span><br><span class="line"><span class="comment">difference(set1, subset): [BRILLIANT_RED, MAGENTA,</span></span><br><span class="line"><span class="comment">VIOLET, CRIMSON, ROSE_MADDER]</span></span><br><span class="line"><span class="comment">difference(set2, subset): [BURNT_SIENNA, YELLOW_OCHRE,</span></span><br><span class="line"><span class="comment">BURNT_UMBER, SAP_GREEN, RAW_UMBER]</span></span><br><span class="line"><span class="comment">complement(set1, set2): [BURNT_SIENNA, BRILLIANT_RED,</span></span><br><span class="line"><span class="comment">YELLOW_OCHRE, MAGENTA, SAP_GREEN, VIOLET, RAW_UMBER,</span></span><br><span class="line"><span class="comment">ROSE_MADDER, BURNT_UMBER, CRIMSON]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>接下来的例子使用 <code>Sets.difference()</code> 方法来展示 <strong>java.util</strong> 包中各种 <strong>Collection</strong> 和 <strong>Map</strong> 类之间的方法差异：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/CollectionMethodDifferences.java</span></span><br><span class="line"><span class="comment">// &#123;java onjava.CollectionMethodDifferences&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionMethodDifferences</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Set&lt;String&gt; <span class="title">methodSet</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(type.getMethods())</span><br><span class="line">                .map(Method::getName)</span><br><span class="line">                .collect(Collectors.toCollection(TreeSet::<span class="keyword">new</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">interfaces</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"Interfaces in "</span> +</span><br><span class="line">                type.getSimpleName() + <span class="string">": "</span>);</span><br><span class="line">        System.out.println(</span><br><span class="line">                Arrays.stream(type.getInterfaces())</span><br><span class="line">                        .map(Class::getSimpleName)</span><br><span class="line">                        .collect(Collectors.toList()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Set&lt;String&gt; object = methodSet(Object.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        object.add(<span class="string">"clone"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">    difference(Class&lt;?&gt; superset, Class&lt;?&gt; subset) &#123;</span><br><span class="line">        System.out.print(superset.getSimpleName() +</span><br><span class="line">                <span class="string">" extends "</span> + subset.getSimpleName() +</span><br><span class="line">                <span class="string">", adds: "</span>);</span><br><span class="line">        Set&lt;String&gt; comp = Sets.difference(</span><br><span class="line">                methodSet(superset), methodSet(subset));</span><br><span class="line">        comp.removeAll(object); <span class="comment">// Ignore 'Object' methods</span></span><br><span class="line">        System.out.println(comp);</span><br><span class="line">        interfaces(superset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Collection: "</span> +</span><br><span class="line">                methodSet(Collection.class));</span><br><span class="line">        interfaces(Collection.class);</span><br><span class="line">        difference(Set.class, Collection.class);</span><br><span class="line">        difference(HashSet.class, Set.class);</span><br><span class="line">        difference(LinkedHashSet.class, HashSet.class);</span><br><span class="line">        difference(TreeSet.class, Set.class);</span><br><span class="line">        difference(List.class, Collection.class);</span><br><span class="line">        difference(ArrayList.class, List.class);</span><br><span class="line">        difference(LinkedList.class, List.class);</span><br><span class="line">        difference(Queue.class, Collection.class);</span><br><span class="line">        difference(PriorityQueue.class, Queue.class);</span><br><span class="line">        System.out.println(<span class="string">"Map: "</span> + methodSet(Map.class));</span><br><span class="line">        difference(HashMap.class, Map.class);</span><br><span class="line">        difference(LinkedHashMap.class, HashMap.class);</span><br><span class="line">        difference(SortedMap.class, Map.class);</span><br><span class="line">        difference(TreeMap.class, Map.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Collection: [add, addAll, clear, contains, containsAll,</span></span><br><span class="line"><span class="comment">equals, forEach, hashCode, isEmpty, iterator,</span></span><br><span class="line"><span class="comment">parallelStream, remove, removeAll, removeIf, retainAll,</span></span><br><span class="line"><span class="comment">size, spliterator, stream, toArray]</span></span><br><span class="line"><span class="comment">Interfaces in Collection: [Iterable]</span></span><br><span class="line"><span class="comment">Set extends Collection, adds: []</span></span><br><span class="line"><span class="comment">Interfaces in Set: [Collection]</span></span><br><span class="line"><span class="comment">HashSet extends Set, adds: []</span></span><br><span class="line"><span class="comment">Interfaces in HashSet: [Set, Cloneable, Serializable]</span></span><br><span class="line"><span class="comment">LinkedHashSet extends HashSet, adds: []</span></span><br><span class="line"><span class="comment">Interfaces in LinkedHashSet: [Set, Cloneable,</span></span><br><span class="line"><span class="comment">Serializable]</span></span><br><span class="line"><span class="comment">TreeSet extends Set, adds: [headSet,</span></span><br><span class="line"><span class="comment">descendingIterator, descendingSet, pollLast, subSet,</span></span><br><span class="line"><span class="comment">floor, tailSet, ceiling, last, lower, comparator,</span></span><br><span class="line"><span class="comment">pollFirst, first, higher]</span></span><br><span class="line"><span class="comment">Interfaces in TreeSet: [NavigableSet, Cloneable,</span></span><br><span class="line"><span class="comment">Serializable]</span></span><br><span class="line"><span class="comment">List extends Collection, adds: [replaceAll, get,</span></span><br><span class="line"><span class="comment">indexOf, subList, set, sort, lastIndexOf, listIterator]</span></span><br><span class="line"><span class="comment">Interfaces in List: [Collection]</span></span><br><span class="line"><span class="comment">ArrayList extends List, adds: [trimToSize,</span></span><br><span class="line"><span class="comment">ensureCapacity]</span></span><br><span class="line"><span class="comment">Interfaces in ArrayList: [List, RandomAccess,</span></span><br><span class="line"><span class="comment">Cloneable, Serializable]</span></span><br><span class="line"><span class="comment">LinkedList extends List, adds: [offerFirst, poll,</span></span><br><span class="line"><span class="comment">getLast, offer, getFirst, removeFirst, element,</span></span><br><span class="line"><span class="comment">removeLastOccurrence, peekFirst, peekLast, push,</span></span><br><span class="line"><span class="comment">pollFirst, removeFirstOccurrence, descendingIterator,</span></span><br><span class="line"><span class="comment">pollLast, removeLast, pop, addLast, peek, offerLast,</span></span><br><span class="line"><span class="comment">addFirst]</span></span><br><span class="line"><span class="comment">Interfaces in LinkedList: [List, Deque, Cloneable,</span></span><br><span class="line"><span class="comment">Serializable]</span></span><br><span class="line"><span class="comment">Queue extends Collection, adds: [poll, peek, offer,</span></span><br><span class="line"><span class="comment">element]</span></span><br><span class="line"><span class="comment">Interfaces in Queue: [Collection]</span></span><br><span class="line"><span class="comment">PriorityQueue extends Queue, adds: [comparator]</span></span><br><span class="line"><span class="comment">Interfaces in PriorityQueue: [Serializable]</span></span><br><span class="line"><span class="comment">Map: [clear, compute, computeIfAbsent,</span></span><br><span class="line"><span class="comment">computeIfPresent, containsKey, containsValue, entrySet,</span></span><br><span class="line"><span class="comment">equals, forEach, get, getOrDefault, hashCode, isEmpty,</span></span><br><span class="line"><span class="comment">keySet, merge, put, putAll, putIfAbsent, remove,</span></span><br><span class="line"><span class="comment">replace, replaceAll, size, values]</span></span><br><span class="line"><span class="comment">HashMap extends Map, adds: []</span></span><br><span class="line"><span class="comment">Interfaces in HashMap: [Map, Cloneable, Serializable]</span></span><br><span class="line"><span class="comment">LinkedHashMap extends HashMap, adds: []</span></span><br><span class="line"><span class="comment">Interfaces in LinkedHashMap: [Map]</span></span><br><span class="line"><span class="comment">SortedMap extends Map, adds: [lastKey, subMap,</span></span><br><span class="line"><span class="comment">comparator, firstKey, headMap, tailMap]</span></span><br><span class="line"><span class="comment">Interfaces in SortedMap: [Map]</span></span><br><span class="line"><span class="comment">TreeMap extends Map, adds: [descendingKeySet,</span></span><br><span class="line"><span class="comment">navigableKeySet, higherEntry, higherKey, floorKey,</span></span><br><span class="line"><span class="comment">subMap, ceilingKey, pollLastEntry, firstKey, lowerKey,</span></span><br><span class="line"><span class="comment">headMap, tailMap, lowerEntry, ceilingEntry,</span></span><br><span class="line"><span class="comment">descendingMap, pollFirstEntry, lastKey, firstEntry,</span></span><br><span class="line"><span class="comment">floorEntry, comparator, lastEntry]</span></span><br><span class="line"><span class="comment">Interfaces in TreeMap: [NavigableMap, Cloneable,</span></span><br><span class="line"><span class="comment">Serializable]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在第十二章 <a href="book/12-Collections.md#本章小结">集合的本章小结</a> 部分将会用到这里的输出结果。</p><!-- Building Complex Models --><h2 id="构建复杂模型"><a href="#构建复杂模型" class="headerlink" title="构建复杂模型"></a>构建复杂模型</h2><p>泛型的一个重要好处是能够简单安全地创建复杂模型。例如，我们可以轻松地创建一个元组列表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/TupleList.java</span></span><br><span class="line"><span class="comment">// Combining generic types to make complex generic types</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> onjava.Tuple4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TupleList</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>, <span class="title">D</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">Tuple4</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>, <span class="title">D</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TupleList&lt;Vehicle, Amphibian, String, Integer&gt; tl =</span><br><span class="line">                <span class="keyword">new</span> TupleList&lt;&gt;();</span><br><span class="line">        tl.add(TupleTest2.h());</span><br><span class="line">        tl.add(TupleTest2.h());</span><br><span class="line">        tl.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">(Vehicle@7cca494b, Amphibian@7ba4f24f, hi, 47)</span></span><br><span class="line"><span class="comment">(Vehicle@3b9a45b3, Amphibian@7699a589, hi, 47)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这将产生一个功能强大的数据结构，而无需太多代码。</p><p>下面是第二个例子。每个类都是组成块，总体包含很多个块。在这里，该模型是一个具有过道，货架和产品的零售商店：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Store.java</span></span><br><span class="line"><span class="comment">// Building a complex model using generic collections</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> onjava.Suppliers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line"></span><br><span class="line">    Product(<span class="keyword">int</span> idNumber, String descr, <span class="keyword">double</span> price) &#123;</span><br><span class="line">        id = idNumber;</span><br><span class="line">        description = descr;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">        System.out.println(toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id + <span class="string">": "</span> + description +</span><br><span class="line">                <span class="string">", price: $"</span> + price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">priceChange</span><span class="params">(<span class="keyword">double</span> change)</span> </span>&#123;</span><br><span class="line">        price += change;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Supplier&lt;Product&gt; generator =</span><br><span class="line">            <span class="keyword">new</span> Supplier&lt;Product&gt;() &#123;</span><br><span class="line">                <span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Product <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> Product(rand.nextInt(<span class="number">1000</span>), <span class="string">"Test"</span>,</span><br><span class="line">                            Math.round(</span><br><span class="line">                                    rand.nextDouble() * <span class="number">1000.0</span>) + <span class="number">0.99</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shelf</span> <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">Product</span>&gt; </span>&#123;</span><br><span class="line">    Shelf(<span class="keyword">int</span> nProducts) &#123;</span><br><span class="line">        Suppliers.fill(<span class="keyword">this</span>, Product.generator, nProducts);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Aisle</span> <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">Shelf</span>&gt; </span>&#123;</span><br><span class="line">    Aisle(<span class="keyword">int</span> nShelves, <span class="keyword">int</span> nProducts) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nShelves; i++)</span><br><span class="line">            add(<span class="keyword">new</span> Shelf(nProducts));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckoutStand</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Office</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Store</span> <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">Aisle</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;CheckoutStand&gt; checkouts =</span><br><span class="line">            <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Office office = <span class="keyword">new</span> Office();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Store</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> nAisles, <span class="keyword">int</span> nShelves, <span class="keyword">int</span> nProducts)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nAisles; i++)</span><br><span class="line">            add(<span class="keyword">new</span> Aisle(nShelves, nProducts));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (Aisle a : <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">for</span> (Shelf s : a)</span><br><span class="line">                <span class="keyword">for</span> (Product p : s) &#123;</span><br><span class="line">                    result.append(p);</span><br><span class="line">                    result.append(<span class="string">"\n"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Store(<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output: (First 8 Lines)</span></span><br><span class="line"><span class="comment">258: Test, price: $400.99</span></span><br><span class="line"><span class="comment">861: Test, price: $160.99</span></span><br><span class="line"><span class="comment">868: Test, price: $417.99</span></span><br><span class="line"><span class="comment">207: Test, price: $268.99</span></span><br><span class="line"><span class="comment">551: Test, price: $114.99</span></span><br><span class="line"><span class="comment">278: Test, price: $804.99</span></span><br><span class="line"><span class="comment">520: Test, price: $554.99</span></span><br><span class="line"><span class="comment">140: Test, price: $530.99</span></span><br><span class="line"><span class="comment">                  ...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>Store.toString()</code> 显示了结果：尽管有复杂的层次结构，但多层的集合仍然是类型安全的和可管理的。令人印象深刻的是，组装这样的模型并不需要耗费过多精力。</p><p><strong>Shelf</strong> 使用 <code>Suppliers.fill()</code> 这个实用程序，该实用程序接受 <strong>Collection</strong> （第一个参数），并使用 <strong>Supplier</strong> （第二个参数），以元素的数量为 <strong>n</strong> （第三个参数）来填充它。 <strong>Suppliers</strong> 类将会在本章末尾定义，其中的方法都是在执行某种填充操作，并在本章的其他示例中使用。</p><!-- The Mystery of Erasure --><h2 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h2><p>当我们开始更深入地钻研泛型时，会发现有大量的东西初看起来是没有意义的。例如，尽管可以说  <code>ArrayList.class</code>，但不能说成 <code>ArrayList&lt;Integer&gt;.class</code>。考虑下面的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ErasedTypeEquivalence.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErasedTypeEquivalence</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class c1 = <span class="keyword">new</span> ArrayList&lt;String&gt;().getClass();</span><br><span class="line">        Class c2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">        System.out.println(c1 == c2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>ArrayList&lt;String&gt;</code> 和 <code>ArrayList&lt;Integer&gt;</code> 应该是不同的类型。不同的类型会有不同的行为。例如，如果尝试向 <code>ArrayList&lt;String&gt;</code> 中放入一个 <code>Integer</code>，所得到的行为（失败）和向 <code>ArrayList&lt;Integer&gt;</code> 中放入一个 <code>Integer</code> 所得到的行为（成功）完全不同。然而上面的程序认为它们是相同的类型。</p><p>下面的例子是对该谜题的补充：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/LostInformation.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Frob</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fnorkle</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quark</span>&lt;<span class="title">Q</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Particle</span>&lt;<span class="title">POSITION</span>, <span class="title">MOMENTUM</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LostInformation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Frob&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Map&lt;Frob, Fnorkle&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Quark&lt;Fnorkle&gt; quark = <span class="keyword">new</span> Quark&lt;&gt;();</span><br><span class="line">        Particle&lt;Long, Double&gt; p = <span class="keyword">new</span> Particle&lt;&gt;();</span><br><span class="line">        System.out.println(Arrays.toString(list.getClass().getTypeParameters()));</span><br><span class="line">        System.out.println(Arrays.toString(map.getClass().getTypeParameters()));</span><br><span class="line">        System.out.println(Arrays.toString(quark.getClass().getTypeParameters()));</span><br><span class="line">        System.out.println(Arrays.toString(p.getClass().getTypeParameters()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[E]</span></span><br><span class="line"><span class="comment">[K,V]</span></span><br><span class="line"><span class="comment">[Q]</span></span><br><span class="line"><span class="comment">[POSITION,MOMENTUM]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>根据 JDK 文档，<strong>Class.getTypeParameters()</strong> “返回一个 <strong>TypeVariable</strong> 对象数组，表示泛型声明中声明的类型参数…” 这暗示我们可以发现这些参数类型。但是正如上例中输出所示，我们只能看到用作参数占位符的标识符，这并非有用的信息。</p><p>残酷的现实是：</p><p>在泛型代码内部，无法获取任何有关泛型参数类型的信息。</p><p>因此，我们可以知道如类型参数标识符和泛型边界这些信息，但无法得知实际的类型参数从而用来创建特定的实例。如果我们曾是 C++ 程序员，那么这个事实会让我们很沮丧，在使用 Java 泛型工作时，它是必须处理的最基本的问题。</p><p>Java 泛型是使用擦除实现的。这意味着当我们在使用泛型时，任何具体的类型信息都被擦除了，我们唯一知道的就是我们在使用一个对象。因此，<code>List&lt;String&gt;</code> 和 <code>List&lt;Integer&gt;</code> 在运行时实际上是相同的类型。它们都被擦除成原生类型 <code>List</code>。</p><p>理解擦除并知道如何处理它，是我们在学习 Java 泛型时面临的最大障碍之一。这也是本节将要探讨的内容。</p><h3 id="C-的方式"><a href="#C-的方式" class="headerlink" title="C++ 的方式"></a>C++ 的方式</h3><p>下面是使用模版的 C++ 示例。我们会看到类型参数的语法十分相似，因为 Java 是受 C++ 启发的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Templates.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Manipulator</span> &#123;</span></span><br><span class="line">    T obj;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Manipulator(T x) &#123; obj = x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span> </span>&#123; obj.f(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasF</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"HasF::f()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HasF hf;</span><br><span class="line">    Manipulator&lt;HasF&gt; manipulator(hf);</span><br><span class="line">    manipulator.manipulate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">HasF::f()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>Manipulator</strong> 类存储了一个 <strong>T</strong> 类型的对象。<code>manipulate()</code> 方法会调用 <strong>obj</strong> 上的 <code>f()</code> 方法。它是如何知道类型参数 <strong>T</strong> 中存在 <code>f()</code> 方法的呢？C++ 编译器会在我们实例化模版时进行检查，所以在 <code>Manipulator&lt;HasF&gt;</code> 实例化的那一刻，它看到 <strong>HasF</strong> 中含有一个方法 <code>f()</code>。如果情况并非如此，我们就会得到一个编译期错误，保持类型安全。</p><p>用 C++ 编写这种代码很简单，因为当模版被实例化时，模版代码就知道模版参数的类型。Java 泛型就不同了。下面是 <strong>HasF</strong> 的 Java 版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/HasF.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HasF</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HasF.f()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们将示例的其余代码用 Java 实现，就不会通过编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Manipulation.java</span></span><br><span class="line"><span class="comment">// &#123;WillNotCompile&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manipulator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line">    </span><br><span class="line">    Manipulator(T x) &#123;</span><br><span class="line">        obj = x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Error: cannot find symbol: method f():</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obj.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manipulation</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HasF hf = <span class="keyword">new</span> HasF();</span><br><span class="line">        Manipulator&lt;HasF&gt; manipulator = <span class="keyword">new</span> Manipulator&lt;&gt;(hf);</span><br><span class="line">        manipulator.manipulate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为擦除，Java 编译器无法将 <code>manipulate()</code> 方法必须能调用 <strong>obj</strong> 的 <code>f()</code> 方法这一需求映射到 HasF 具有 <code>f()</code> 方法这个事实上。为了调用 <code>f()</code>，我们必须协助泛型类，给定泛型类一个边界，以此告诉编译器只能接受遵循这个边界的类型。这里重用了 <strong>extends</strong> 关键字。由于有了边界，下面的代码就能通过编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manipulator2</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HasF</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line"></span><br><span class="line">    Manipulator2(T x) &#123;</span><br><span class="line">        obj = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obj.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>边界 <code>&lt;T extends HasF&gt;</code> 声明 T 必须是 HasF 类型或其子类。如果情况确实如此，就可以安全地在 <strong>obj</strong> 上调用 <code>f()</code> 方法。</p><p>我们说泛型类型参数会擦除到它的第一个边界（可能有多个边界，稍后我们将看到）。我们还提到了类型参数的擦除。编译器实际上会把类型参数替换为它的擦除，就像上面的示例，<strong>T</strong> 擦除到了 <strong>HasF</strong>，就像在类的声明中用 <strong>HasF</strong> 替换了 <strong>T</strong> 一样。</p><p>我们可能正确地观察到了泛型在 <strong>Manipulator2.java</strong> 中没有贡献任何事。我们可以很轻松地自己去执行擦除，生成没有泛型的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Manipulator3.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manipulator3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HasF obj;</span><br><span class="line">    </span><br><span class="line">    Manipulator3(HasF x) &#123;</span><br><span class="line">        obj = x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obj.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这提出了很重要的一点：泛型只有在类型参数比某个具体类型（以及其子类）更加“泛化”——代码能跨多个类工作时才有用。因此，类型参数和它们在有用的泛型代码中的应用，通常比简单的类替换更加复杂。但是，不能因此认为使用 <code>&lt;T extends HasF&gt;</code> 形式就是有缺陷的。例如，如果某个类有一个返回 <strong>T</strong> 的方法，那么泛型就有所帮助，因为它们之后将返回确切的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ReturnGenericType.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnGenericType</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HasF</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line">    </span><br><span class="line">    ReturnGenericType(T x) &#123;</span><br><span class="line">        obj = x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们必须查看所有的代码，从而确定代码是否复杂到必须使用泛型的程度。</p><p>我们将在本章稍后看到有关边界的更多细节。</p><h3 id="迁移兼容性"><a href="#迁移兼容性" class="headerlink" title="迁移兼容性"></a>迁移兼容性</h3><p>为了减少潜在的关于擦除的困惑，我们必须清楚地认识到这不是一个语言特性。它是 Java 实现泛型的一种妥协，因为泛型不是 Java 语言出现时就有的，所以就有了这种妥协。它会使我们痛苦，因此我们需要尽早习惯它并了解为什么它会这样。</p><p>如果 Java 1.0 就含有泛型的话，那么这个特性就不会使用擦除来实现——它会使用具体化，保持参数类型为第一类实体，因此我们就能在类型参数上执行基于类型的语言操作和反射操作。本章稍后我们会看到，擦除减少了泛型的泛化性。泛型在 Java 中仍然是有用的，只是不如它们本来设想的那么有用，而原因就是擦除。</p><p>在基于擦除的实现中，泛型类型被当作第二类类型处理，即不能在某些重要的上下文使用泛型类型。泛型类型只有在静态类型检测期间才出现，在此之后，程序中的所有泛型类型都将被擦除，替换为它们的非泛型上界。例如， <code>List&lt;T&gt;</code> 这样的类型注解会被擦除为 <strong>List</strong>，普通的类型变量在未指定边界的情况下会被擦除为 <strong>Object</strong>。</p><p>擦除的核心动机是我们可以在泛化的客户端上使用非泛型的类库，反之亦然。这经常被称为“迁移兼容性”。在理想情况下，所有事物将在指定的某天被泛化。在现实中，即使程序员只编写泛型代码，他们也必须处理 Java 5 之前编写的非泛型类库。这些类库的作者可能从没想过要泛化他们的代码，或许他们可能刚刚开始接触泛型。</p><p>因此 Java 泛型不仅必须支持向后兼容性——现有的代码和类文件仍然合法，继续保持之前的含义——而且还必须支持迁移兼容性，使得类库能按照它们自己的步调变为泛型，当某个类库变为泛型时，不会破坏依赖于它的代码和应用。在确定了这个目标后，Java 设计者们和从事此问题相关工作的各个团队决策认为擦除是唯一可行的解决方案。擦除使得这种向泛型的迁移成为可能，允许非泛型的代码和泛型代码共存。</p><p>例如，假设一个应用使用了两个类库 <strong>X</strong> 和 <strong>Y</strong>，<strong>Y</strong> 使用了类库 <strong>Z</strong>。随着 Java 5 的出现，这个应用和这些类库的创建者最终可能希望迁移到泛型上。但是当进行迁移时，它们有着不同的动机和限制。为了实现迁移兼容性，每个类库与应用必须与其他所有的部分是否使用泛型无关。因此，它们不能探测其他类库是否使用了泛型。因此，某个特定的类库使用了泛型这样的证据必须被”擦除“。</p><p>如果没有某种类型的迁移途径，所有已经构建了很长时间的类库就需要与希望迁移到 Java 泛型上的开发者们说再见了。类库毫无争议是编程语言的一部分，对生产效率有着极大的影响，所以这种代码无法接受。擦除是否是最佳的或唯一的迁移途径，还待时间来证明。</p><h3 id="擦除的问题"><a href="#擦除的问题" class="headerlink" title="擦除的问题"></a>擦除的问题</h3><p>因此，擦除主要的正当理由是从非泛化代码到泛化代码的转变过程，以及在不破坏现有类库的情况下将泛型融入到语言中。擦除允许我们继续使用现有的非泛型客户端代码，直至客户端准备好用泛型重写这些代码。这是一个崇高的动机，因为它不会骤然破坏所有现有的代码。</p><p>擦除的代价是显著的。泛型不能用于显式地引用运行时类型的操作中，例如转型、<strong>instanceof</strong> 操作和 <strong>new</strong> 表达式。因为所有关于参数的类型信息都丢失了，当我们在编写泛型代码时，必须时刻提醒自己，我们只是看起来拥有有关参数的类型信息而已。</p><p>考虑如下的代码段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T var;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上去当我们创建一个 <strong>Foo</strong> 实例时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Foo&lt;Cat&gt; f = <span class="keyword">new</span> Foo&lt;&gt;();</span><br></pre></td></tr></table></figure><p><strong>class</strong> <strong>Foo</strong> 中的代码应该知道现在工作于 <strong>Cat</strong> 之上。泛型语法也在强烈暗示整个类中所有 T 出现的地方都被替换，就像在 C++ 中一样。但是事实并非如此，当我们在编写这个类的代码时，必须提醒自己：“不，这只是一个 <strong>Object</strong>“。</p><p>另外，擦除和迁移兼容性意味着，使用泛型并不是强制的，尽管我们可能希望这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ErasureAndInheritance.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericBase</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T element;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">        element = arg;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived1</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">GenericBase</span>&lt;<span class="title">T</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived2</span> <span class="keyword">extends</span> <span class="title">GenericBase</span> </span>&#123;&#125; <span class="comment">// No warning</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// class Derived3 extends GenericBase&lt;?&gt; &#123;&#125;</span></span><br><span class="line"><span class="comment">// Strange error:</span></span><br><span class="line"><span class="comment">// unexpected type</span></span><br><span class="line"><span class="comment">// required: class or interface without bounds</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErasureAndInteritance</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Derived2 d2 = <span class="keyword">new</span> Derived2();</span><br><span class="line">        Object obj = d2.get();</span><br><span class="line">        d2.set(obj); <span class="comment">// Warning here!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Derived2</strong> 继承自 <strong>GenericBase</strong>，但是没有任何类型参数，编译器没有发出任何警告。直到调用 <code>set()</code> 方法时才出现警告。</p><p>为了关闭警告，Java 提供了一个注解，我们可以在列表中看到它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br></pre></td></tr></table></figure><p>这个注解放置在产生警告的方法上，而不是整个类上。当我们要关闭警告时，最好尽可能地“聚焦”，这样就不会因为过于宽泛地关闭警告，而导致意外地遮蔽掉真正的问题。</p><p>可以推断，<strong>Derived3</strong> 产生的错误意味着编译器期望得到一个原生基类。</p><p>当我们希望将类型参数不仅仅当作 Object 处理时，就需要付出额外努力来管理边界，并且与在 C++、Ada 和 Eiffel 这样的语言中获得参数化类型相比，我们需要付出多得多的努力来获得少得多的回报。这并不是说，对于大多数的编程问题而言，这些语言通常都会比 Java 更得心应手，只是说它们的参数化类型机制相比 Java 更灵活、更强大。</p><h3 id="边界处的动作"><a href="#边界处的动作" class="headerlink" title="边界处的动作"></a>边界处的动作</h3><p>因为擦除，我发现了泛型最令人困惑的方面是可以表示没有任何意义的事物。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ArrayMaker.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayMaker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; kind;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayMaker</span><span class="params">(Class&lt;T&gt; kind)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.kind = kind;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    T[] create(<span class="keyword">int</span> size) &#123;</span><br><span class="line">        <span class="keyword">return</span> (T[]) Array.newInstance(kind, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayMaker&lt;String&gt; stringMaker = <span class="keyword">new</span> ArrayMaker&lt;&gt;(String.class);</span><br><span class="line">        String[] stringArray = stringMaker.create(<span class="number">9</span>);</span><br><span class="line">        System.out.println(Arrays.toString(stringArray));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output</span></span><br><span class="line"><span class="comment">[null,null,null,null,null,null,null,null,null]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>即使 <strong>kind</strong> 被存储为 <code>Class&lt;T&gt;</code>，擦除也意味着它实际被存储为没有任何参数的 <strong>Class</strong>。因此，当我们在使用它时，例如创建数组，<code>Array.newInstance()</code> 实际上并未拥有 <strong>kind</strong> 所蕴含的类型信息。所以它不会产生具体的结果，因而必须转型，这会产生一条令我们无法满意的警告。</p><p>注意，对于在泛型中创建数组，使用 <code>Array.newInstance()</code> 是推荐的方式。</p><p>如果我们创建一个集合而不是数组，情况就不同了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ListMaker.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListMaker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ListMaker&lt;String&gt; stringMaker = <span class="keyword">new</span> ListMaker&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; stringList = stringMaker.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器不会给出任何警告，尽管我们知道（从擦除中）在 <code>create()</code> 内部的 <code>new ArrayList&lt;&gt;()</code> 中的 <code>&lt;T&gt;</code> 被移除了——在运行时，类内部没有任何 <code>&lt;T&gt;</code>，因此这看起来毫无意义。但是如果我们遵从这种思路，并将这个表达式改为 <code>new ArrayList()</code>，编译器就会发出警告。</p><p>本例中这么做真的毫无意义吗？如果在创建 <strong>List</strong> 的同时向其中放入一些对象呢，像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/FilledList.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilledList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    FilledList(Supplier&lt;T&gt; gen, <span class="keyword">int</span> size) &#123;</span><br><span class="line">        Suppliers.fill(<span class="keyword">this</span>, gen, size);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FilledList</span><span class="params">(T t, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> FilledList&lt;&gt;(<span class="string">"Hello"</span>, <span class="number">4</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">// Supplier version:</span></span><br><span class="line">        List&lt;Integer&gt; ilist = <span class="keyword">new</span> FilledList&lt;&gt;(() -&gt; <span class="number">47</span>, <span class="number">4</span>);</span><br><span class="line">        System.out.println(ilist);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[Hello,Hello,Hello,Hello]</span></span><br><span class="line"><span class="comment">[47,47,47,47]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>即使编译器无法得知 <code>add()</code> 中的 <strong>T</strong> 的任何信息，但它仍可以在编译期确保我们放入 <strong>FilledList</strong> 中的对象是 <strong>T</strong> 类型。因此，即使擦除移除了方法或类中的实际类型的信息，编译器仍可以确保方法或类中使用的类型的内部一致性。</p><p>因为擦除移除了方法体中的类型信息，所以在运行时的问题就是<em>边界</em>：即对象进入和离开方法的地点。这些正是编译器在编译期执行类型检查并插入转型代码的地点。</p><p>考虑如下这段非泛型示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/SimpleHolder.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleHolder holder = <span class="keyword">new</span> SimpleHolder();</span><br><span class="line">        holder.set(<span class="string">"Item"</span>);</span><br><span class="line">        String s = (String) holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用 <strong>javap -c SimpleHolder</strong> 反编译这个类，会得到如下内容（经过编辑）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(java.lang.Object)</span></span>;</span><br><span class="line">   <span class="number">0</span>: aload_0</span><br><span class="line">   <span class="number">1</span>: aload_1</span><br><span class="line">   2: putfield #2; // Field obj:Object;</span><br><span class="line">   <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> java.lang.<span class="function">Object <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="number">0</span>: aload_0</span><br><span class="line">   1: getfield #2; // Field obj:Object;</span><br><span class="line">   <span class="number">4</span>: areturn</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">   0: new #3; // class SimpleHolder</span><br><span class="line">   <span class="number">3</span>: dup</span><br><span class="line">   4: invokespecial #4; // Method "&lt;init&gt;":()V</span><br><span class="line">   <span class="number">7</span>: astore_1</span><br><span class="line">   <span class="number">8</span>: aload_1</span><br><span class="line">   9: ldc #5; // String Item</span><br><span class="line">   11: invokevirtual #6; // Method set:(Object;)V</span><br><span class="line">   <span class="number">14</span>: aload_1</span><br><span class="line">   15: invokevirtual #7; // Method get:()Object;</span><br><span class="line">   18: checkcast #8; // class java/lang/String</span><br><span class="line">   <span class="number">21</span>: astore_2</span><br><span class="line">   <span class="number">22</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p><code>set()</code> 和 <code>get()</code> 方法存储和产生值，转型在调用 <code>get()</code> 时接受检查。</p><p>现在将泛型融入上例代码中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericHolder2.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericHolder2</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericHolder2&lt;String&gt; holder =  <span class="keyword">new</span> GenericHolder2&lt;&gt;();</span><br><span class="line">        holder.set(<span class="string">"Item"</span>);</span><br><span class="line">        String s = holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 <code>get()</code> 返回后的转型消失了，但是我们还知道传递给 <code>set()</code> 的值在编译期会被检查。下面是相关的字节码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(java.lang.Object)</span></span>;</span><br><span class="line">   <span class="number">0</span>: aload_0</span><br><span class="line">   <span class="number">1</span>: aload_1</span><br><span class="line">   2: putfield #2; // Field obj:Object;</span><br><span class="line">   <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line">       </span><br><span class="line"><span class="keyword">public</span> java.lang.<span class="function">Object <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="number">0</span>: aload_0</span><br><span class="line">   1: getfield #2; // Field obj:Object;</span><br><span class="line">   <span class="number">4</span>: areturn</span><br><span class="line">       </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">   0: new #3; // class GenericHolder2</span><br><span class="line">   <span class="number">3</span>: dup</span><br><span class="line">   4: invokespecial #4; // Method "&lt;init&gt;":()V</span><br><span class="line">   <span class="number">7</span>: astore_1</span><br><span class="line">   <span class="number">8</span>: aload_1</span><br><span class="line">   9: ldc #5; // String Item</span><br><span class="line">   11: invokevirtual #6; // Method set:(Object;)V</span><br><span class="line">   <span class="number">14</span>: aload_1</span><br><span class="line">   15: invokevirtual #7; // Method get:()Object;</span><br><span class="line">   18: checkcast #8; // class java/lang/String</span><br><span class="line">   <span class="number">21</span>: astore_2</span><br><span class="line">   <span class="number">22</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>所产生的字节码是相同的。对进入 <code>set()</code> 的类型进行检查是不需要的，因为这将由编译器执行。而对 <code>get()</code> 返回的值进行转型仍然是需要的，只不过不需要我们来操作，它由编译器自动插入，这样我们就不用编写（阅读）杂乱的代码。</p><p><code>get()</code> 和 <code>set()</code> 产生了相同的字节码，这就告诉我们泛型的所有动作都发生在边界处——对入参的编译器检查和对返回值的转型。这有助于澄清对擦除的困惑，记住：“边界就是动作发生的地方”。</p><!-- Compensating for Erasure --><h2 id="补偿擦除"><a href="#补偿擦除" class="headerlink" title="补偿擦除"></a>补偿擦除</h2><p>因为擦除，我们将失去执行泛型代码中某些操作的能力。无法在运行时知道确切类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Erased.java</span></span><br><span class="line"><span class="comment">// &#123;WillNotCompile&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Erased</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// error: illegal generic type for instanceof</span></span><br><span class="line">        <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> T) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// error: unexpected type</span></span><br><span class="line">        T var = <span class="keyword">new</span> T();</span><br><span class="line">        <span class="comment">// error: generic array creation</span></span><br><span class="line">        T[] array = <span class="keyword">new</span> T[SIZE];</span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked cast</span></span><br><span class="line">        T[] array = (T[]) <span class="keyword">new</span> Object[SIZE];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时，我们可以对这些问题进行编程，但是有时必须通过引入类型标签来补偿擦除。这意味着为所需的类型显式传递一个 <strong>Class</strong> 对象，以在类型表达式中使用它。</p><p>例如，由于擦除了类型信息，因此在上一个程序中尝试使用 <strong>instanceof</strong> 将会失败。类型标签可以使用动态 <code>isInstance()</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ClassTypeCapture.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span> <span class="keyword">extends</span> <span class="title">Building</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassTypeCapture</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    Class&lt;T&gt; kind;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassTypeCapture</span><span class="params">(Class&lt;T&gt; kind)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.kind = kind;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">f</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> kind.isInstance(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassTypeCapture&lt;Building&gt; ctt1 =</span><br><span class="line">                <span class="keyword">new</span> ClassTypeCapture&lt;&gt;(Building.class);</span><br><span class="line">        System.out.println(ctt1.f(<span class="keyword">new</span> Building()));</span><br><span class="line">        System.out.println(ctt1.f(<span class="keyword">new</span> House()));</span><br><span class="line">        ClassTypeCapture&lt;House&gt; ctt2 =</span><br><span class="line">                <span class="keyword">new</span> ClassTypeCapture&lt;&gt;(House.class);</span><br><span class="line">        System.out.println(ctt2.f(<span class="keyword">new</span> Building()));</span><br><span class="line">        System.out.println(ctt2.f(<span class="keyword">new</span> House()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>编译器来保证类型标签与泛型参数相匹配。</p><!-- Creating Instances of Types --><h3 id="创建类型的实例"><a href="#创建类型的实例" class="headerlink" title="创建类型的实例"></a>创建类型的实例</h3><p>试图在 <strong>Erased.java</strong> 中 <code>new T()</code> 是行不通的，部分原因是由于擦除，部分原因是编译器无法验证 <strong>T</strong> 是否具有默认（无参）构造函数。但是在 C++ 中，此操作自然，直接且安全（在编译时检查）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/InstantiateGenericType.cpp</span></span><br><span class="line"><span class="comment">// C++, not Java!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">  T x; <span class="comment">// Create a field of type T</span></span><br><span class="line">  T* y; <span class="comment">// Pointer to T</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Initialize the pointer:</span></span><br><span class="line">  Foo() &#123; y = <span class="keyword">new</span> T(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Foo&lt;Bar&gt; fb;</span><br><span class="line">  Foo&lt;<span class="keyword">int</span>&gt; fi; <span class="comment">// ... and it works with primitives</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 中的解决方案是传入一个工厂对象，并使用该对象创建新实例。方便的工厂对象只是 <strong>Class</strong> 对象，因此，如果使用类型标记，则可以使用 <code>newInstance()</code> 创建该类型的新对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/InstantiateGenericType.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassAsFactory</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    Class&lt;T&gt; kind;</span><br><span class="line"></span><br><span class="line">    ClassAsFactory(Class&lt;T&gt; kind) &#123;</span><br><span class="line">        <span class="keyword">this</span>.kind = kind;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> kind.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException |</span><br><span class="line">                IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Employee"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstantiateGenericType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassAsFactory&lt;Employee&gt; fe =</span><br><span class="line">                <span class="keyword">new</span> ClassAsFactory&lt;&gt;(Employee.class);</span><br><span class="line">        System.out.println(fe.get());</span><br><span class="line">        ClassAsFactory&lt;Integer&gt; fi =</span><br><span class="line">                <span class="keyword">new</span> ClassAsFactory&lt;&gt;(Integer.class);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(fi.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Employee</span></span><br><span class="line"><span class="comment">java.lang.InstantiationException: java.lang.Integer</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这样可以编译，但对于 <code>ClassAsFactory&lt;Integer&gt;</code> 会失败，这是因为 <strong>Integer</strong> 没有无参构造函数。由于错误不是在编译时捕获的，因此语言创建者不赞成这种方法。他们建议使用显式工厂（<strong>Supplier</strong>）并约束类型，以便只有实现该工厂的类可以这样创建对象。这是创建工厂的两种不同方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/FactoryConstraint.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> onjava.Suppliers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegerFactory</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ++i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    Widget(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        id = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Widget "</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">Widget</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Widget <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Widget(++i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fudge</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n = count++;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Fudge "</span> + n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo2</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; x = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Foo2(Supplier&lt;T&gt; factory) &#123;</span><br><span class="line">        Suppliers.fill(x, factory, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryConstraint</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">                <span class="keyword">new</span> Foo2&lt;&gt;(<span class="keyword">new</span> IntegerFactory()));</span><br><span class="line">        System.out.println(</span><br><span class="line">                <span class="keyword">new</span> Foo2&lt;&gt;(<span class="keyword">new</span> Widget.Factory()));</span><br><span class="line">        System.out.println(</span><br><span class="line">                <span class="keyword">new</span> Foo2&lt;&gt;(Fudge::<span class="keyword">new</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment">[Widget 1, Widget 2, Widget 3, Widget 4, Widget 5]</span></span><br><span class="line"><span class="comment">[Fudge 1, Fudge 2, Fudge 3, Fudge 4, Fudge 5]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>IntegerFactory</strong> 本身就是通过实现 <code>Supplier&lt;Integer&gt;</code> 的工厂。 <strong>Widget</strong> 包含一个内部类，它是一个工厂。还要注意，<strong>Fudge</strong> 并没有做任何类似于工厂的操作，并且传递 <code>Fudge::new</code> 仍然会产生工厂行为，因为编译器将对函数方法 <code>::new</code> 的调用转换为对 <code>get()</code> 的调用。</p><p>另一种方法是模板方法设计模式。在以下示例中，<code>create()</code> 是模板方法，在子类中被重写以生成该类型的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/CreatorGeneric.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericWithCreate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> T element;</span><br><span class="line"></span><br><span class="line">    GenericWithCreate() &#123;</span><br><span class="line">        element = create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> T <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XCreator</span> <span class="keyword">extends</span> <span class="title">GenericWithCreate</span>&lt;<span class="title">X</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">X <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> X();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">                element.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatorGeneric</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        XCreator xc = <span class="keyword">new</span> XCreator();</span><br><span class="line">        xc.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">X</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>GenericWithCreate</strong> 包含 <code>element</code> 字段，并通过无参构造函数强制其初始化，该构造函数又调用抽象的 <code>create()</code> 方法。这种创建方式可以在子类中定义，同时建立 <strong>T</strong> 的类型。</p><!-- Arrays of Generics --><h3 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h3><p>正如在 <strong>Erased.java</strong> 中所看到的，我们无法创建泛型数组。通用解决方案是在试图创建泛型数组的时候使用 <strong>ArrayList</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ListOfGenerics.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListOfGenerics</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; array = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">        array.add(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做可以获得数组的行为，并且还具有泛型提供的编译时类型安全性。</p><p>有时，仍然会创建泛型类型的数组（例如， <strong>ArrayList</strong> 在内部使用数组）。可以通过使编译器满意的方式定义对数组的通用引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ArrayOfGenericReference.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayOfGenericReference</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Generic&lt;Integer&gt;[] gia;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器接受此操作而不产生警告。但是我们永远无法创建具有该确切类型（包括类型参数）的数组，因此有点令人困惑。由于所有数组，无论它们持有什么类型，都具有相同的结构（每个数组插槽的大小和数组布局），因此似乎可以创建一个 <strong>Object</strong> 数组并将其转换为所需的数组类型。实际上，这确实可以编译，但是会产生 <strong>ClassCastException</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ArrayOfGeneric.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayOfGeneric</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">static</span> Generic&lt;Integer&gt;[] gia;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            gia = (Generic&lt;Integer&gt;[]) <span class="keyword">new</span> Object[SIZE];</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Runtime type is the raw (erased) type:</span></span><br><span class="line">        gia = (Generic&lt;Integer&gt;[]) <span class="keyword">new</span> Generic[SIZE];</span><br><span class="line">        System.out.println(gia.getClass().getSimpleName());</span><br><span class="line">        gia[<span class="number">0</span>] = <span class="keyword">new</span> Generic&lt;&gt;();</span><br><span class="line">        <span class="comment">//- gia[1] = new Object(); // Compile-time error</span></span><br><span class="line">        <span class="comment">// Discovers type mismatch at compile time:</span></span><br><span class="line">        <span class="comment">//- gia[2] = new Generic&lt;Double&gt;();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[Ljava.lang.Object; cannot be cast to [LGeneric;</span></span><br><span class="line"><span class="comment">Generic[]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>问题在于数组会跟踪其实际类型，而该类型是在创建数组时建立的。因此，即使 <code>gia</code> 被强制转换为 <code>Generic&lt;Integer&gt;[]</code> ，该信息也仅在编译时存在（并且没有 <strong>@SuppressWarnings</strong> 注解，将会收到有关该强制转换的警告）。在运行时，它仍然是一个 <strong>Object</strong> 数组，这会引起问题。成功创建泛型类型的数组的唯一方法是创建一个已擦除类型的新数组，并将其强制转换。</p><p>让我们看一个更复杂的示例。考虑一个包装数组的简单泛型包装器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericArray.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericArray</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericArray</span><span class="params">(<span class="keyword">int</span> sz)</span> </span>&#123;</span><br><span class="line">        array = (T[]) <span class="keyword">new</span> Object[sz];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> index, T item)</span> </span>&#123;</span><br><span class="line">        array[index] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Method that exposes the underlying representation:</span></span><br><span class="line">    <span class="keyword">public</span> T[] rep() &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericArray&lt;Integer&gt; gai = <span class="keyword">new</span> GenericArray&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer[] ia = gai.rep();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// This is OK:</span></span><br><span class="line">        Object[] oa = gai.rep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[Ljava.lang.Object; cannot be cast to</span></span><br><span class="line"><span class="comment">[Ljava.lang.Integer;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>和以前一样，我们不能说 <code>T[] array = new T[sz]</code> ，所以我们创建了一个 <strong>Object</strong> 数组并将其强制转换。</p><p><code>rep()</code> 方法返回一个 <code>T[]</code> ，在主方法中它应该是 <code>gai</code> 的 <code>Integer[]</code>，但是如果调用它并尝试将结果转换为 <code>Integer[]</code> 引用，则会得到 <strong>ClassCastException</strong> ，这再次是因为实际的运行时类型为 <code>Object[]</code> 。</p><p>如果再注释掉 <strong>@SuppressWarnings</strong> 注解后编译 <strong>GenericArray.java</strong> ，则编译器会产生警告：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GenericArray.java uses unchecked or unsafe operations.</span><br><span class="line">Recompile with -Xlint:unchecked <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure><p>在这里，我们收到了一个警告，我们认为这是有关强制转换的。</p><p>但是要真正确定，请使用 <code>-Xlint：unchecked</code> 进行编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GenericArray.java:<span class="number">7</span>: warning: [unchecked] unchecked cast    array = (T[])<span class="keyword">new</span> Object[sz];                 ^  required: T[]  found:    Object[]  where T is a type-variable:    T extends Object declared in <span class="class"><span class="keyword">class</span> <span class="title">GenericArray</span> 1 <span class="title">warning</span></span></span><br></pre></td></tr></table></figure><p>确实是在抱怨那个强制转换。由于警告会变成噪音，因此，一旦我们确认预期会出现特定警告，我们可以做的最好的办法就是使用 <strong>@SuppressWarnings</strong> 将其关闭。这样，当警告确实出现时，我们将进行实际调查。</p><p>由于擦除，数组的运行时类型只能是 <code>Object[]</code> 。 如果我们立即将其转换为 <code>T[]</code> ，则在编译时会丢失数组的实际类型，并且编译器可能会错过一些潜在的错误检查。因此，最好在集合中使用 <code>Object[]</code> ，并在使用数组元素时向 <strong>T</strong> 添加强制类型转换。让我们来看看在 <strong>GenericArray.java</strong> 示例中会是怎么样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericArray2.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericArray2</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericArray2</span><span class="params">(<span class="keyword">int</span> sz)</span> </span>&#123;</span><br><span class="line">        array = <span class="keyword">new</span> Object[sz];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> index, T item)</span> </span>&#123;</span><br><span class="line">        array[index] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) array[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> T[] rep() &#123;</span><br><span class="line">        <span class="keyword">return</span> (T[]) array; <span class="comment">// Unchecked cast</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericArray2&lt;Integer&gt; gai =</span><br><span class="line">                <span class="keyword">new</span> GenericArray2&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">            gai.put(i, i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">            System.out.print(gai.get(i) + <span class="string">" "</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer[] ia = gai.rep();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"><span class="comment">java.lang.ClassCastException: [Ljava.lang.Object;</span></span><br><span class="line"><span class="comment">cannot be cast to [Ljava.lang.Integer;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>最初，看起来并没有太大不同，只是转换的位置移动了。没有 <strong>@SuppressWarnings</strong> 注解，仍然会收到“unchecked”警告。但是，内部表示现在是 <code>Object[]</code> 而不是 <code>T[]</code> 。 调用 <code>get()</code> 时，它将对象强制转换为 <strong>T</strong> ，实际上这是正确的类型，因此很安全。但是，如果调用 <code>rep()</code> ，它将再次尝试将 <code>Object[]</code> 强制转换为 <code>T[]</code> ，但仍然不正确，并在编译时生成警告，并在运行时生成异常。因此，无法破坏基础数组的类型，该基础数组只能是 <code>Object[]</code> 。在内部将数组视为 <code>Object[]</code> 而不是 <code>T[]</code> 的优点是，我们不太可能会忘记数组的运行时类型并意外地引入了bug，尽管大多数（也许是全部）此类错误会在运行时被迅速检测到。</p><p>对于新代码，请传入类型标记。在这种情况下，<strong>GenericArray</strong> 如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericArrayWithTypeToken.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericArrayWithTypeToken</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericArrayWithTypeToken</span><span class="params">(Class&lt;T&gt; type, <span class="keyword">int</span> sz)</span> </span>&#123;</span><br><span class="line">        array = (T[]) Array.newInstance(type, sz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> index, T item)</span> </span>&#123;</span><br><span class="line">        array[index] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Expose the underlying representation:</span></span><br><span class="line">    <span class="keyword">public</span> T[] rep() &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericArrayWithTypeToken&lt;Integer&gt; gai =</span><br><span class="line">                <span class="keyword">new</span> GenericArrayWithTypeToken&lt;&gt;(</span><br><span class="line">                        Integer.class, <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// This now works:</span></span><br><span class="line">        Integer[] ia = gai.rep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型标记 <strong>Class&lt;T&gt;</strong> 被传递到构造函数中以从擦除中恢复，因此尽管必须使用 <strong>@SuppressWarnings</strong> 关闭来自强制类型转换的警告，但我们仍可以创建所需的实际数组类型。一旦获得了实际的类型，就可以返回它并产生所需的结果，如在主方法中看到的那样。数组的运行时类型是确切的类型 <code>T[]</code> 。</p><p>不幸的是，如果查看 Java 标准库中的源代码，我们会发现到处都有从 <strong>Object</strong> 数组到参数化类型的转换。例如，这是<strong>ArrayList</strong> 中，复制一个 <strong>Collection</strong> 的构造函数，这里为了简化，去除了源码中对此不重要的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection c)</span> </span>&#123;</span><br><span class="line">  size = c.size();</span><br><span class="line">  elementData = (E[])<span class="keyword">new</span> Object[size];</span><br><span class="line">  c.toArray(elementData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们浏览 <strong>ArrayList.java</strong> 的代码，将会发现很多此类强制转换。当我们编译它时会发生什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Note: ArrayList.java uses unchecked or unsafe operations</span><br><span class="line">Note: Recompile with -Xlint:unchecked <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure><p>果然，标准库会产生很多警告。如果我们使用过 C 语言，尤其是使用 ANSI C 之前的语言，我们会记住警告的特殊效果：发现警告后，可以忽略它们。因此，除非程序员必须对其进行处理，否则最好不要从编译器发出任何类型的消息。</p><p>Neal Gafter（Java 5 的主要开发人员之一）在他的博客中[^2]指出，他在重写 Java 库时是很随意、马虎的，我们不应该像他那样做。Neal 还指出，他在不破坏现有接口的情况下无法修复某些 Java 库代码。因此，即使在 Java 库源代码中出现了一些习惯用法，它们也不一定是正确的做法。当查看库代码时，我们不能认为这就是要在自己代码中必须遵循的示例。</p><p>请注意，在 Java 文献中推荐使用类型标记技术，例如 Gilad Bracha 的论文《Generics in the Java Programming Language》[^3]，他指出：“例如，这种用法已广泛用于新的 API 中以处理注解。” 我发现此技术在人们对于舒适度的看法方面存在一些不一致之处；有些人强烈喜欢本章前面介绍的工厂方法。</p><!-- Bounds --><h2 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h2><p><em>边界</em>（bounds）在本章的前面进行了简要介绍。边界允许我们对泛型使用的参数类型施加约束。尽管这可以强制执行有关应用了泛型类型的规则，但潜在的更重要的效果是我们可以在绑定的类型中调用方法。</p><p>由于擦除会删除类型信息，因此唯一可用于无限制泛型参数的方法是那些 <strong>Object</strong> 可用的方法。但是，如果将该参数限制为某类型的子集，则可以调用该子集中的方法。为了应用约束，Java 泛型使用了 <code>extends</code> 关键字。</p><p>重要的是要理解，当用于限定泛型类型时，<code>extends</code> 的含义与通常的意义截然不同。此示例展示边界的基础应用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/BasicBounds.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">HasColor</span> </span>&#123;</span><br><span class="line">    java.awt.<span class="function">Color <span class="title">getColor</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithColor</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HasColor</span>&gt; </span>&#123;</span><br><span class="line">    T item;</span><br><span class="line"></span><br><span class="line">    WithColor(T item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">getItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The bound allows you to call a method:</span></span><br><span class="line">    java.awt.<span class="function">Color <span class="title">color</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.getColor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coord</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x, y, z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This fails. Class must be first, then interfaces:</span></span><br><span class="line"><span class="comment">// class WithColorCoord&lt;T extends HasColor &amp; Coord&gt; &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Multiple bounds:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithColorCoord</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Coord</span> &amp; <span class="title">HasColor</span>&gt; </span>&#123;</span><br><span class="line">    T item;</span><br><span class="line"></span><br><span class="line">    WithColorCoord(T item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">getItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    java.awt.<span class="function">Color <span class="title">color</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.getColor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getZ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Weight</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">weight</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// As with inheritance, you can have only one</span></span><br><span class="line"><span class="comment">// concrete class but multiple interfaces:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solid</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Coord</span> &amp; <span class="title">HasColor</span> &amp; <span class="title">Weight</span>&gt; </span>&#123;</span><br><span class="line">    T item;</span><br><span class="line"></span><br><span class="line">    Solid(T item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">getItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    java.awt.<span class="function">Color <span class="title">color</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.getColor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getZ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">weight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.weight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bounded</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">Coord</span> <span class="keyword">implements</span> <span class="title">HasColor</span>, <span class="title">Weight</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> java.awt.<span class="function">Color <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">weight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicBounds</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solid&lt;Bounded&gt; solid =</span><br><span class="line">                <span class="keyword">new</span> Solid&lt;&gt;(<span class="keyword">new</span> Bounded());</span><br><span class="line">        solid.color();</span><br><span class="line">        solid.getY();</span><br><span class="line">        solid.weight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可能会观察到 <strong>BasicBounds.java</strong> 中似乎包含一些冗余，它们可以通过继承来消除。在这里，每个继承级别还添加了边界约束：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/InheritBounds.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoldItem</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T item;</span><br><span class="line"></span><br><span class="line">    HoldItem(T item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">getItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithColor2</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HasColor</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">HoldItem</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    WithColor2(T item) &#123;</span><br><span class="line">        <span class="keyword">super</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    java.awt.<span class="function">Color <span class="title">color</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.getColor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithColorCoord2</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Coord</span> &amp; <span class="title">HasColor</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">WithColor2</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    WithColorCoord2(T item) &#123;</span><br><span class="line">        <span class="keyword">super</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getZ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solid2</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Coord</span> &amp; <span class="title">HasColor</span> &amp; <span class="title">Weight</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">WithColorCoord2</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    Solid2(T item) &#123;</span><br><span class="line">        <span class="keyword">super</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">weight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.weight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritBounds</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solid2&lt;Bounded&gt; solid2 =</span><br><span class="line">                <span class="keyword">new</span> Solid2&lt;&gt;(<span class="keyword">new</span> Bounded());</span><br><span class="line">        solid2.color();</span><br><span class="line">        solid2.getY();</span><br><span class="line">        solid2.weight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>HoldItem</strong> 拥有一个对象，因此此行为将继承到 <strong>WithColor2</strong> 中，这也需要其参数符合 <strong>HasColor</strong>。 <strong>WithColorCoord2</strong> 和 <strong>Solid2</strong> 进一步扩展了层次结构，并在每个级别添加了边界。现在，这些方法已被继承，并且在每个类中不再重复。</p><p>这是一个具有更多层次的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/EpicBattle.java</span></span><br><span class="line"><span class="comment">// Bounds in Java generics</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SuperPower</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">XRayVision</span> <span class="keyword">extends</span> <span class="title">SuperPower</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">seeThroughWalls</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SuperHearing</span> <span class="keyword">extends</span> <span class="title">SuperPower</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hearSubtleNoises</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SuperSmell</span> <span class="keyword">extends</span> <span class="title">SuperPower</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">trackBySmell</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperHero</span>&lt;<span class="title">POWER</span> <span class="keyword">extends</span> <span class="title">SuperPower</span>&gt; </span>&#123;</span><br><span class="line">    POWER power;</span><br><span class="line"></span><br><span class="line">    SuperHero(POWER power) &#123;</span><br><span class="line">        <span class="keyword">this</span>.power = power;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">POWER <span class="title">getPower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> power;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperSleuth</span>&lt;<span class="title">POWER</span> <span class="keyword">extends</span> <span class="title">XRayVision</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">SuperHero</span>&lt;<span class="title">POWER</span>&gt; </span>&#123;</span><br><span class="line">    SuperSleuth(POWER power) &#123;</span><br><span class="line">        <span class="keyword">super</span>(power);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">see</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        power.seeThroughWalls();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="class"><span class="title">CanineHero</span>&lt;<span class="title">POWER</span> <span class="keyword">extends</span> <span class="title">SuperHearing</span> &amp; <span class="title">SuperSmell</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">SuperHero</span>&lt;<span class="title">POWER</span>&gt; </span>&#123;</span><br><span class="line">    CanineHero(POWER power) &#123;</span><br><span class="line">        <span class="keyword">super</span>(power);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        power.hearSubtleNoises();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">smell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        power.trackBySmell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperHearSmell</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">SuperHearing</span>, <span class="title">SuperSmell</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hearSubtleNoises</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trackBySmell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DogPerson</span> <span class="keyword">extends</span> <span class="title">CanineHero</span>&lt;<span class="title">SuperHearSmell</span>&gt; </span>&#123;</span><br><span class="line">    DogPerson() &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> SuperHearSmell());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EpicBattle</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Bounds in generic methods:</span></span><br><span class="line">    <span class="keyword">static</span> &lt;POWER extends SuperHearing&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">useSuperHearing</span><span class="params">(SuperHero&lt;POWER&gt; hero)</span> </span>&#123;</span><br><span class="line">        hero.getPower().hearSubtleNoises();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;POWER extends SuperHearing &amp; SuperSmell&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">superFind</span><span class="params">(SuperHero&lt;POWER&gt; hero)</span> </span>&#123;</span><br><span class="line">        hero.getPower().hearSubtleNoises();</span><br><span class="line">        hero.getPower().trackBySmell();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DogPerson dogPerson = <span class="keyword">new</span> DogPerson();</span><br><span class="line">        useSuperHearing(dogPerson);</span><br><span class="line">        superFind(dogPerson);</span><br><span class="line">        <span class="comment">// You can do this:</span></span><br><span class="line">        List&lt;? extends SuperHearing&gt; audioPeople;</span><br><span class="line">        <span class="comment">// But you can't do this:</span></span><br><span class="line">        <span class="comment">// List&lt;? extends SuperHearing &amp; SuperSmell&gt; dogPs;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来将要研究的通配符将会把范围限制在单个类型。</p><!-- Wildcards --><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p>我们已经在 <a href="book/12-Collections.md">集合</a> 章节中看到了一些简单示例使用了通配符——在泛型参数表达式中的问号，在 <a href="book/19-Type-Information.md">类型信息</a> 一章中这种示例更多。本节将更深入地探讨这个特性。</p><p>我们的起始示例要展示数组的一种特殊行为：我们可以将派生类的数组赋值给基类的引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/CovariantArrays.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jonathan</span> <span class="keyword">extends</span> <span class="title">Apple</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantArrays</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Fruit[] fruit = <span class="keyword">new</span> Apple[<span class="number">10</span>];</span><br><span class="line">        fruit[<span class="number">0</span>] = <span class="keyword">new</span> Apple(); <span class="comment">// OK</span></span><br><span class="line">        fruit[<span class="number">1</span>] = <span class="keyword">new</span> Jonathan(); <span class="comment">// OK</span></span><br><span class="line">        <span class="comment">// Runtime type is Apple[], not Fruit[] or Orange[]:</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Compiler allows you to add Fruit:</span></span><br><span class="line">            fruit[<span class="number">0</span>] = <span class="keyword">new</span> Fruit(); <span class="comment">// ArrayStoreException</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Compiler allows you to add Oranges:</span></span><br><span class="line">            fruit[<span class="number">0</span>] = <span class="keyword">new</span> Orange(); <span class="comment">// ArrayStoreException</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">java.lang.ArrayStoreException: Fruit</span></span><br><span class="line"><span class="comment">java.lang.ArrayStoreException: Orange</span></span><br></pre></td></tr></table></figure><p><code>main()</code> 中的第一行创建了 <strong>Apple</strong> 数组，并赋值给一个 <strong>Fruit</strong> 数组引用。这是有意义的，因为 <strong>Apple</strong> 也是一种 <strong>Fruit</strong>，因此 <strong>Apple</strong> 数组应该也是一个 <strong>Fruit</strong> 数组。</p><p>但是，如果实际的数组类型是 <strong>Apple[]</strong>，我们可以在其中放置 <strong>Apple</strong> 或 <strong>Apple</strong> 的子类型，这在编译期和运行时都可以工作。但是我们也可以在数组中放置 <strong>Fruit</strong> 对象。这对编译器来说是有意义的，因为它有一个 <strong>Fruit[]</strong> 引用——它有什么理由不允许将 <strong>Fruit</strong> 对象或任何从 <strong>Fruit</strong> 继承出来的对象（比如 <strong>Orange</strong>），放置到这个数组中呢？因此在编译期，这是允许的。然而，运行时的数组机制知道它处理的是 <strong>Apple[]</strong>，因此会在向数组中放置异构类型时抛出异常。</p><p>向上转型用在这里不合适。我们真正在做的是将一个数组赋值给另一个数组。数组的行为是持有其他对象，这里只是因为我们能够向上转型而已，所以很明显，数组对象可以保留有关它们包含的对象类型的规则。看起来就像数组对它们持有的对象是有意识的，因此在编译期检查和运行时检查之间，我们不能滥用它们。</p><p>数组的这种赋值并不是那么可怕，因为在运行时我们可以发现插入了错误的类型。但是泛型的主要目标之一是将这种错误检测移到编译期。所以当我们试图使用泛型集合代替数组时，会发生什么呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/NonCovariantGenerics.java</span></span><br><span class="line"><span class="comment">// &#123;WillNotCompile&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonCovariantGenerics</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Compile Error: incompatible types:</span></span><br><span class="line">    List&lt;Fruit&gt; flist = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管我们在首次阅读这段代码时会认为“不能将一个 <strong>Apple</strong> 集合赋值给一个 <strong>Fruit</strong> 集合”。记住，泛型不仅仅是关于集合，它真正要表达的是“不能把一个涉及 <strong>Apple</strong> 的泛型赋值给一个涉及 <strong>Fruit</strong> 的泛型”。如果像在数组中的情况一样，编译器对代码的了解足够多，可以确定所涉及到的集合，那么它可能会留下一些余地。但是它不知道任何有关这方面的信息，因此它拒绝向上转型。然而实际上这也不是向上转型—— <strong>Apple</strong> 的 <strong>List</strong> 不是 <strong>Fruit</strong> 的 <strong>List</strong>。<strong>Apple</strong> 的 <strong>List</strong> 将持有 <strong>Apple</strong> 和 <strong>Apple</strong> 的子类型，<strong>Fruit</strong> 的 <strong>List</strong> 将持有任何类型的 <strong>Fruit</strong>。是的，这包括 <strong>Apple</strong>，但是它不是一个 <strong>Apple</strong> 的 <strong>List</strong>，它仍然是 <strong>Fruit</strong> 的 <strong>List</strong>。<strong>Apple</strong> 的 <strong>List</strong> 在类型上不等价于 <strong>Fruit</strong> 的 <strong>List</strong>，即使 <strong>Apple</strong> 是一种 <strong>Fruit</strong> 类型。</p><p>真正的问题是我们在讨论的集合类型，而不是集合持有对象的类型。与数组不同，泛型没有内建的协变类型。这是因为数组是完全在语言中定义的，因此可以具有编译期和运行时的内建检查，但是在使用泛型时，编译器和运行时系统不知道我们想用类型做什么，以及应该采用什么规则。</p><p>但是，有时我们想在两个类型间建立某种向上转型关系。通配符可以产生这种关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericsAndCovariance.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsAndCovariance</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Wildcards allow covariance:</span></span><br><span class="line">        List&lt;? extends Fruit&gt; flist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// Compile Error: can't add any type of object:</span></span><br><span class="line">        <span class="comment">// flist.add(new Apple());</span></span><br><span class="line">        <span class="comment">// flist.add(new Fruit());</span></span><br><span class="line">        <span class="comment">// flist.add(new Object());</span></span><br><span class="line">        flist.add(<span class="keyword">null</span>); <span class="comment">// Legal but uninteresting</span></span><br><span class="line">        <span class="comment">// We know it returns at least Fruit:</span></span><br><span class="line">        Fruit f = flist.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>flist</strong> 的类型现在是 <code>List&lt;? extends Fruit&gt;</code>，我们可以读作“一个具有任何从 <strong>Fruit</strong> 继承的类型的列表”。然而，这实际上并不意味着这个 <strong>List</strong> 将持有任何类型的 <strong>Fruit</strong>。通配符引用的是明确的类型，因此它意味着“某种 <strong>flist</strong> 引用没有指定的具体类型”。因此这个被赋值的 <strong>List</strong> 必须持有诸如 <strong>Fruit</strong> 或 <strong>Apple</strong> 这样的指定类型，但是为了向上转型为 <strong>Fruit</strong>，这个类型是什么没人在意。</p><p><strong>List</strong> 必须持有一种具体的 <strong>Fruit</strong> 或 <strong>Fruit</strong> 的子类型，但是如果我们不关心具体的类型是什么，那么我们能对这样的 <strong>List</strong> 做什么呢？如果不知道 <strong>List</strong> 中持有的对象是什么类型，我们怎能保证安全地向其中添加对象呢？就像在 <strong>CovariantArrays.java</strong> 中向上转型一样，我们不能，除非编译器而不是运行时系统可以阻止这种操作的发生。我们很快就会发现这个问题。</p><p>我们可能认为事情开始变得有点走极端了，因为现在我们甚至不能向刚刚声明过将持有 <strong>Apple</strong> 对象的 <strong>List</strong> 中放入一个 <strong>Apple</strong> 对象。是的，但编译器并不知道这一点。<code>List&lt;? extends Fruit&gt;</code> 可能合法地指向一个 <code>List&lt;Orange&gt;</code>。一旦执行这种类型的向上转型，我们就丢失了向其中传递任何对象的能力，甚至传递 <strong>Object</strong> 也不行。</p><p>另一方面，如果我们调用了一个返回 <strong>Fruit</strong> 的方法，则是安全的，因为我们知道这个 <strong>List</strong> 中的任何对象至少具有 <strong>Fruit</strong> 类型，因此编译器允许这么做。</p><h3 id="编译器有多聪明"><a href="#编译器有多聪明" class="headerlink" title="编译器有多聪明"></a>编译器有多聪明</h3><p>现在我们可能会猜想自己不能去调用任何接受参数的方法，但是考虑下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/CompilerIntelligence.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompilerIntelligence</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;? extends Fruit&gt; flist = Arrays.asList(<span class="keyword">new</span> Apple());</span><br><span class="line">        Apple a = (Apple) flist.get(<span class="number">0</span>); <span class="comment">// No warning</span></span><br><span class="line">        flist.contains(<span class="keyword">new</span> Apple()); <span class="comment">// Argument is 'Object'</span></span><br><span class="line">        flist.indexOf(<span class="keyword">new</span> Apple()); <span class="comment">// Argument is 'Object'</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里对 <code>contains()</code> 和 <code>indexOf()</code> 的调用接受 <strong>Apple</strong> 对象作为参数，执行没问题。这是否意味着编译器实际上会检查代码，以查看是否有某个特定的方法修改了它的对象？</p><p>通过查看 <strong>ArrayList</strong> 的文档，我们发现编译器没有那么聪明。尽管 <code>add()</code> 接受一个泛型参数类型的参数，但 <code>contains()</code> 和 <code>indexOf()</code> 接受的参数类型是 <strong>Object</strong>。因此当我们指定一个 <code>ArrayList&lt;? extends Fruit&gt;</code> 时，<code>add()</code> 的参数就变成了”<strong>? extends Fruit</strong>“。从这个描述中，编译器无法得知这里需要 <strong>Fruit</strong> 的哪个具体子类型，因此它不会接受任何类型的 <strong>Fruit</strong>。如果我们先把 <strong>Apple</strong> 向上转型为 <strong>Fruit</strong>，也没有关系——编译器仅仅会拒绝调用像 <code>add()</code> 这样参数列表中涉及通配符的方法。</p><p><code>contains()</code> 和 <code>indexOf()</code> 的参数类型是 <strong>Object</strong>，不涉及通配符，所以编译器允许调用它们。这意味着将由泛型类的设计者来决定哪些调用是“安全的”，并使用 <strong>Object</strong> 类作为它们的参数类型。为了禁止对类型中使用了通配符的方法调用，需要在参数列表中使用类型参数。</p><p>下面展示一个简单的 <strong>Holder</strong> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Holder.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">        value = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">        value = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o <span class="keyword">instanceof</span> Holder &amp;&amp; Objects.equals(value, ((Holder) o).value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Holder&lt;Apple&gt; apple = <span class="keyword">new</span> Holder&lt;&gt;(<span class="keyword">new</span> Apple());</span><br><span class="line">        Apple d = apple.get();</span><br><span class="line">        apple.set(d);</span><br><span class="line">        <span class="comment">// Holder&lt;Fruit&gt; fruit = apple; // Cannot upcast</span></span><br><span class="line">        Holder&lt;? extends Fruit&gt; fruit = apple; <span class="comment">// OK</span></span><br><span class="line">        Fruit p = fruit.get();</span><br><span class="line">        d = (Apple) fruit.get();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Orange c = (Orange) fruit.get(); <span class="comment">// No warning</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fruit.set(new Apple()); // Cannot call set()</span></span><br><span class="line">        <span class="comment">// fruit.set(new Fruit()); // Cannot call set()</span></span><br><span class="line">        System.out.println(fruit.equals(d)); <span class="comment">// OK</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output</span></span><br><span class="line"><span class="comment">java.lang.ClassCastException: Apple cannot be cast to Orange</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>Holder</strong> 有一个接受 <strong>T</strong> 类型对象的 <code>set()</code> 方法，一个返回 T 对象的 <code>get()</code> 方法和一个接受 Object 对象的 <code>equals()</code> 方法。正如我们所见，如果创建了一个 <code>Holder&lt;Apple&gt;</code>，就不能将其向上转型为 <code>Holder&lt;Fruit&gt;</code>，但是可以向上转型为 <code>Holder&lt;? extends Fruit&gt;</code>。如果调用 <code>get()</code>，只能返回一个 <strong>Fruit</strong>——这就是在给定“任何扩展自 <strong>Fruit</strong> 的对象”这一边界后，它所能知道的一切了。如果我们知道更多的信息，就可以将其转型到某种具体的 <strong>Fruit</strong> 而不会导致任何警告，但是存在得到 <strong>ClassCastException</strong> 的风险。<code>set()</code> 方法不能工作在 <strong>Apple</strong> 和 <strong>Fruit</strong> 上，因为 <code>set()</code> 的参数也是”<strong>? extends Fruit</strong>“，意味着它可以是任何事物，编译器无法验证“任何事物”的类型安全性。</p><p>但是，<code>equals()</code> 方法可以正常工作，因为它接受的参数是 <strong>Object</strong> 而不是 <strong>T</strong> 类型。因此，编译器只关注传递进来和要返回的对象类型。它不会分析代码，以查看是否执行了任何实际的写入和读取操作。</p><p>Java 7 引入了 <strong>java.util.Objects</strong> 库，使创建 <code>equals()</code> 和 <code>hashCode()</code> 方法变得更加容易，当然还有很多其他功能。<code>equals()</code> 方法的标准形式参考 <a href="book/Appendix-Understanding-equals-and-hashCode">附录：理解 equals 和 hashCode 方法</a> 一章。</p><h3 id="逆变"><a href="#逆变" class="headerlink" title="逆变"></a>逆变</h3><p>还可以走另外一条路，即使用超类型通配符。这里，可以声明通配符是由某个特定类的任何基类来界定的，方法是指定 <code>&lt;？super MyClass&gt;</code> ，或者甚至使用类型参数： <code>&lt;？super T&gt;</code>（尽管我们不能对泛型参数给出一个超类型边界；即不能声明 <code>&lt;T super MyClass&gt;</code> ）。这使得我们可以安全地传递一个类型对象到泛型类型中。因此，有了超类型通配符，就可以向 <strong>Collection</strong> 写入了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/SuperTypeWildcards.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperTypeWildcards</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeTo</span><span class="params">(List&lt;? <span class="keyword">super</span> Apple&gt; apples)</span> </span>&#123;</span><br><span class="line">        apples.add(<span class="keyword">new</span> Apple());</span><br><span class="line">        apples.add(<span class="keyword">new</span> Jonathan());</span><br><span class="line">        <span class="comment">// apples.add(new Fruit()); // Error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数 <strong>apples</strong> 是 <strong>Apple</strong> 的某种基类型的 <strong>List</strong>，这样我们就知道向其中添加 <strong>Apple</strong> 或 <strong>Apple</strong> 的子类型是安全的。但是因为 <strong>Apple</strong> 是下界，所以我们知道向这样的 <strong>List</strong> 中添加 <strong>Fruit</strong> 是不安全的，因为这将使这个 <strong>List</strong> 敞开口子，从而可以向其中添加非 <strong>Apple</strong> 类型的对象，而这是违反静态类型安全的。<br>下面的示例复习了一下逆变和通配符的的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericReading.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericReading</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;Apple&gt; apples = Arrays.asList(<span class="keyword">new</span> Apple());</span><br><span class="line">    <span class="keyword">static</span> List&lt;Fruit&gt; fruit = Arrays.asList(<span class="keyword">new</span> Fruit());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">readExact</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// A static method adapts to each call:</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Apple a = readExact(apples);</span><br><span class="line">        Fruit f = readExact(fruit);</span><br><span class="line">        f = readExact(apples);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// A class type is established</span></span><br><span class="line">    <span class="comment">// when the class is instantiated:</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Reader</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">readExact</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> list.get(<span class="number">0</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Reader&lt;Fruit&gt; fruitReader = <span class="keyword">new</span> Reader&lt;&gt;();</span><br><span class="line">        Fruit f = fruitReader.readExact(fruit);</span><br><span class="line">        <span class="comment">//- Fruit a = fruitReader.readExact(apples);</span></span><br><span class="line">        <span class="comment">// error: incompatible types: List&lt;Apple&gt;</span></span><br><span class="line">        <span class="comment">// cannot be converted to List&lt;Fruit&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantReader</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">readCovariant</span><span class="params">(List&lt;? extends T&gt; list)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CovariantReader&lt;Fruit&gt; fruitReader = <span class="keyword">new</span> CovariantReader&lt;&gt;();</span><br><span class="line">        Fruit f = fruitReader.readCovariant(fruit);</span><br><span class="line">        Fruit a = fruitReader.readCovariant(apples);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        f1(); </span><br><span class="line">        f2(); </span><br><span class="line">        f3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>readExact()</code> 方法使用了精确的类型。如果使用这个没有任何通配符的精确类型，就可以向 <strong>List</strong> 中写入和读取这个精确类型。另外，对于返回值，静态的泛型方法 <code>readExact()</code> 可以有效地“适应”每个方法调用，并能够从 <code>List&lt;Apple&gt;</code> 中返回一个 <strong>Apple</strong> ，从 <code>List&lt;Fruit&gt;</code> 中返回一个 <strong>Fruit</strong> ，就像在 <code>f1()</code> 中看到的那样。因此，如果可以摆脱静态泛型方法，那么在读取时就不需要协变类型了。<br>然而对于泛型类来说，当我们创建这个类的实例时，就要为这个类确定参数。就像在 <code>f2()</code> 中看到的，<strong>fruitReader</strong> 实例可以从 <code>List&lt;Fruit&gt;</code> 中读取一个 <strong>Fruit</strong> ，因为这就是它的确切类型。但是 <code>List&lt;Apple&gt;</code> 也应该产生 <strong>Fruit</strong> 对象，而 <strong>fruitReader</strong> 不允许这么做。<br>为了修正这个问题，<code>CovariantReader.readCovariant()</code> 方法将接受 <code>List&lt;？extends T&gt;</code> ，因此，从这个列表中读取一个 <strong>T</strong> 是安全的（我们知道在这个列表中的所有对象至少是一个 <strong>T</strong> ，并且可能是从 T 导出的某种对象）。在 <code>f3()</code> 中，我们可以看到现在可以从 <code>List&lt;Apple&gt;</code> 中读取 <strong>Fruit</strong> 了。</p><h3 id="无界通配符"><a href="#无界通配符" class="headerlink" title="无界通配符"></a>无界通配符</h3><p>无界通配符 <code>&lt;?&gt;</code> 看起来意味着“任何事物”，因此使用无界通配符好像等价于使用原生类型。事实上，编译器初看起来是支持这种判断的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/UnboundedWildcards1.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnboundedWildcards1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List list1;</span><br><span class="line">    <span class="keyword">static</span> List&lt;?&gt; list2;</span><br><span class="line">    <span class="keyword">static</span> List&lt;? extends Object&gt; list3;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign1</span><span class="params">(List list)</span> </span>&#123;</span><br><span class="line">        list1 = list;</span><br><span class="line">        list2 = list;</span><br><span class="line">        <span class="comment">//- list3 = list;</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked conversion</span></span><br><span class="line">        <span class="comment">// list3 = list;</span></span><br><span class="line">        <span class="comment">//         ^</span></span><br><span class="line">        <span class="comment">// required: List&lt;? extends Object&gt;</span></span><br><span class="line">        <span class="comment">// found:    List</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign2</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">        list1 = list;</span><br><span class="line">        list2 = list;</span><br><span class="line">        list3 = list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign3</span><span class="params">(List&lt;? extends Object&gt; list)</span> </span>&#123;</span><br><span class="line">        list1 = list;</span><br><span class="line">        list2 = list;</span><br><span class="line">        list3 = list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        assign1(<span class="keyword">new</span> ArrayList());</span><br><span class="line">        assign2(<span class="keyword">new</span> ArrayList());</span><br><span class="line">        <span class="comment">//- assign3(new ArrayList());</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked method invocation:</span></span><br><span class="line">        <span class="comment">// method assign3 in class UnboundedWildcards1</span></span><br><span class="line">        <span class="comment">// is applied to given types</span></span><br><span class="line">        <span class="comment">// assign3(new ArrayList());</span></span><br><span class="line">        <span class="comment">//        ^</span></span><br><span class="line">        <span class="comment">// required: List&lt;? extends Object&gt;</span></span><br><span class="line">        <span class="comment">// found: ArrayList</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked conversion</span></span><br><span class="line">        <span class="comment">// assign3(new ArrayList());</span></span><br><span class="line">        <span class="comment">//         ^</span></span><br><span class="line">        <span class="comment">// required: List&lt;? extends Object&gt;</span></span><br><span class="line">        <span class="comment">// found:    ArrayList</span></span><br><span class="line">        <span class="comment">// 2 warnings</span></span><br><span class="line">        assign1(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        assign2(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        assign3(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="comment">// Both forms are acceptable as List&lt;?&gt;:</span></span><br><span class="line">        List&lt;?&gt; wildList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        wildList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        assign1(wildList);</span><br><span class="line">        assign2(wildList);</span><br><span class="line">        assign3(wildList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有很多情况都和我们在这里看到的情况类似，即编译器很少关心使用的是原生类型还是 <code>&lt;?&gt;</code> 。在这些情况中，<code>&lt;?&gt;</code> 可以被认为是一种装饰，但是它仍旧是很有价值的，因为，实际上它是在声明：“我是想用 Java 的泛型来编写这段代码，我在这里并不是要用原生类型，但是在当前这种情况下，泛型参数可以持有任何类型。”<br>第二个示例展示了无界通配符的一个重要应用。当我们在处理多个泛型参数时，有时允许一个参数可以是任何类型，同时为其他参数确定某种特定类型的这种能力会显得很重要：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/UnboundedWildcards2.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnboundedWildcards2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Map map1;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;?,?&gt; map2;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String,?&gt; map3;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign1</span><span class="params">(Map map)</span> </span>&#123; </span><br><span class="line">        map1 = map; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign2</span><span class="params">(Map&lt;?,?&gt; map)</span> </span>&#123; </span><br><span class="line">        map2 = map; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign3</span><span class="params">(Map&lt;String,?&gt; map)</span> </span>&#123; </span><br><span class="line">        map3 = map; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        assign1(<span class="keyword">new</span> HashMap());</span><br><span class="line">        assign2(<span class="keyword">new</span> HashMap());</span><br><span class="line">        <span class="comment">//- assign3(new HashMap());</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked method invocation:</span></span><br><span class="line">        <span class="comment">// method assign3 in class UnboundedWildcards2</span></span><br><span class="line">        <span class="comment">// is applied to given types</span></span><br><span class="line">        <span class="comment">//     assign3(new HashMap());</span></span><br><span class="line">        <span class="comment">//            ^</span></span><br><span class="line">        <span class="comment">//   required: Map&lt;String,?&gt;</span></span><br><span class="line">        <span class="comment">//   found: HashMap</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked conversion</span></span><br><span class="line">        <span class="comment">//     assign3(new HashMap());</span></span><br><span class="line">        <span class="comment">//             ^</span></span><br><span class="line">        <span class="comment">//   required: Map&lt;String,?&gt;</span></span><br><span class="line">        <span class="comment">//   found:    HashMap</span></span><br><span class="line">        <span class="comment">// 2 warnings</span></span><br><span class="line">        assign1(<span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">        assign2(<span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">        assign3(<span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，当我们拥有的全都是无界通配符时，就像在 <code>Map&lt;?,?&gt;</code> 中看到的那样，编译器看起来就无法将其与原生 <strong>Map</strong> 区分开了。另外， <strong>UnboundedWildcards1.java</strong> 展示了编译器处理  <code>List&lt;?&gt;</code> 和 <code>List&lt;? extends Object&gt;</code> 是不同的。<br>令人困惑的是，编译器并非总是关注像 <code>List</code> 和 <code>List&lt;?&gt;</code> 之间的这种差异，因此它们看起来就像是相同的事物。事实上，因为泛型参数擦除到它的第一个边界，因此 <code>List&lt;?&gt;</code> 看起来等价于 <code>List&lt;Object&gt;</code> ，而 <strong>List</strong> 实际上也是 <code>List&lt;Object&gt;</code> ——除非这些语句都不为真。<strong>List</strong> 实际上表示“持有任何 <strong>Object</strong> 类型的原生 <strong>List ** ”，而 <code>List&lt;?&gt;</code> 表示“具有某种特定类型的非原生 **List</strong> ，只是我们不知道类型是什么。”<br>编译器何时才会关注原生类型和涉及无界通配符的类型之间的差异呢？下面的示例使用了前面定义的 <code>Holder&lt;T&gt;</code> 类，它包含接受 <strong>Holder</strong> 作为参数的各种方法，但是它们具有不同的形式：作为原生类型，具有具体的类型参数以及具有无界通配符参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Wildcards.java</span></span><br><span class="line"><span class="comment">// Exploring the meaning of wildcards</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wildcards</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Raw argument:</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rawArgs</span><span class="params">(Holder holder, Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//- holder.set(arg);</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked call to set(T)</span></span><br><span class="line">        <span class="comment">// as a member of the raw type Holder</span></span><br><span class="line">        <span class="comment">//     holder.set(arg);</span></span><br><span class="line">        <span class="comment">//               ^</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in class Holder</span></span><br><span class="line">        <span class="comment">// 1 warning</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Can't do this; don't have any 'T':</span></span><br><span class="line">        <span class="comment">// T t = holder.get();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// OK, but type information is lost:</span></span><br><span class="line">        Object obj = holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Like rawArgs(), but errors instead of warnings:</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unboundedArg</span><span class="params">(Holder&lt;?&gt; holder, Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//- holder.set(arg);</span></span><br><span class="line">        <span class="comment">// error: method set in class Holder&lt;T&gt;</span></span><br><span class="line">        <span class="comment">// cannot be applied to given types;</span></span><br><span class="line">        <span class="comment">//     holder.set(arg);</span></span><br><span class="line">        <span class="comment">//           ^</span></span><br><span class="line">        <span class="comment">//   required: CAP#1</span></span><br><span class="line">        <span class="comment">//   found: Object</span></span><br><span class="line">        <span class="comment">//   reason: argument mismatch;</span></span><br><span class="line">        <span class="comment">//     Object cannot be converted to CAP#1</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in class Holder</span></span><br><span class="line">        <span class="comment">//   where CAP#1 is a fresh type-variable:</span></span><br><span class="line">        <span class="comment">//     CAP#1 extends Object from capture of ?</span></span><br><span class="line">        <span class="comment">// 1 error</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Can't do this; don't have any 'T':</span></span><br><span class="line">        <span class="comment">// T t = holder.get();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// OK, but type information is lost:</span></span><br><span class="line">        Object obj = holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">exact1</span><span class="params">(Holder&lt;T&gt; holder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">exact2</span><span class="params">(Holder&lt;T&gt; holder, T arg)</span> </span>&#123;</span><br><span class="line">        holder.set(arg);</span><br><span class="line">        <span class="keyword">return</span> holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">wildSubtype</span><span class="params">(Holder&lt;? extends T&gt; holder, T arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//- holder.set(arg);</span></span><br><span class="line">        <span class="comment">// error: method set in class Holder&lt;T#2&gt;</span></span><br><span class="line">        <span class="comment">// cannot be applied to given types;</span></span><br><span class="line">        <span class="comment">//     holder.set(arg);</span></span><br><span class="line">        <span class="comment">//           ^</span></span><br><span class="line">        <span class="comment">//   required: CAP#1</span></span><br><span class="line">        <span class="comment">//   found: T#1</span></span><br><span class="line">        <span class="comment">//   reason: argument mismatch;</span></span><br><span class="line">        <span class="comment">//     T#1 cannot be converted to CAP#1</span></span><br><span class="line">        <span class="comment">//   where T#1,T#2 are type-variables:</span></span><br><span class="line">        <span class="comment">//     T#1 extends Object declared in method</span></span><br><span class="line">        <span class="comment">//     &lt;T#1&gt;wildSubtype(Holder&lt;? extends T#1&gt;,T#1)</span></span><br><span class="line">        <span class="comment">//     T#2 extends Object declared in class Holder</span></span><br><span class="line">        <span class="comment">//   where CAP#1 is a fresh type-variable:</span></span><br><span class="line">        <span class="comment">//     CAP#1 extends T#1 from</span></span><br><span class="line">        <span class="comment">//       capture of ? extends T#1</span></span><br><span class="line">        <span class="comment">// 1 error</span></span><br><span class="line">        <span class="keyword">return</span> holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">wildSupertype</span><span class="params">(Holder&lt;? <span class="keyword">super</span> T&gt; holder, T arg)</span> </span>&#123;</span><br><span class="line">        holder.set(arg);</span><br><span class="line">        <span class="comment">//- T t = holder.get();</span></span><br><span class="line">        <span class="comment">// error: incompatible types:</span></span><br><span class="line">        <span class="comment">// CAP#1 cannot be converted to T</span></span><br><span class="line">        <span class="comment">//     T t = holder.get();</span></span><br><span class="line">        <span class="comment">//                     ^</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in method</span></span><br><span class="line">        <span class="comment">//       &lt;T&gt;wildSupertype(Holder&lt;? super T&gt;,T)</span></span><br><span class="line">        <span class="comment">//   where CAP#1 is a fresh type-variable:</span></span><br><span class="line">        <span class="comment">//     CAP#1 extends Object super:</span></span><br><span class="line">        <span class="comment">//       T from capture of ? super T</span></span><br><span class="line">        <span class="comment">// 1 error</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// OK, but type information is lost:</span></span><br><span class="line">        Object obj = holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Holder raw = <span class="keyword">new</span> Holder&lt;&gt;();</span><br><span class="line">        <span class="comment">// Or:</span></span><br><span class="line">        raw = <span class="keyword">new</span> Holder();</span><br><span class="line">        Holder&lt;Long&gt; qualified = <span class="keyword">new</span> Holder&lt;&gt;();</span><br><span class="line">        Holder&lt;?&gt; unbounded = <span class="keyword">new</span> Holder&lt;&gt;();</span><br><span class="line">        Holder&lt;? extends Long&gt; bounded = <span class="keyword">new</span> Holder&lt;&gt;();</span><br><span class="line">        Long lng = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">        rawArgs(raw, lng);</span><br><span class="line">        rawArgs(qualified, lng);</span><br><span class="line">        rawArgs(unbounded, lng);</span><br><span class="line">        rawArgs(bounded, lng);</span><br><span class="line"></span><br><span class="line">        unboundedArg(raw, lng);</span><br><span class="line">        unboundedArg(qualified, lng);</span><br><span class="line">        unboundedArg(unbounded, lng);</span><br><span class="line">        unboundedArg(bounded, lng);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Object r1 = exact1(raw);</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked method invocation:</span></span><br><span class="line">        <span class="comment">// method exact1 in class Wildcards is applied</span></span><br><span class="line">        <span class="comment">// to given types</span></span><br><span class="line">        <span class="comment">//      Object r1 = exact1(raw);</span></span><br><span class="line">        <span class="comment">//                        ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;T&gt;</span></span><br><span class="line">        <span class="comment">//   found: Holder</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//     method &lt;T&gt;exact1(Holder&lt;T&gt;)</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked conversion</span></span><br><span class="line">        <span class="comment">//      Object r1 = exact1(raw);</span></span><br><span class="line">        <span class="comment">//                         ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;T&gt;</span></span><br><span class="line">        <span class="comment">//   found:    Holder</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//     method &lt;T&gt;exact1(Holder&lt;T&gt;)</span></span><br><span class="line">        <span class="comment">// 2 warnings</span></span><br><span class="line"></span><br><span class="line">        Long r2 = exact1(qualified);</span><br><span class="line">        Object r3 = exact1(unbounded); <span class="comment">// Must return Object</span></span><br><span class="line">        Long r4 = exact1(bounded);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Long r5 = exact2(raw, lng);</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked method invocation:</span></span><br><span class="line">        <span class="comment">// method exact2 in class Wildcards is</span></span><br><span class="line">        <span class="comment">// applied to given types</span></span><br><span class="line">        <span class="comment">//     Long r5 = exact2(raw, lng);</span></span><br><span class="line">        <span class="comment">//                     ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;T&gt;,T</span></span><br><span class="line">        <span class="comment">//   found: Holder,Long</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//       method &lt;T&gt;exact2(Holder&lt;T&gt;,T)</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked conversion</span></span><br><span class="line">        <span class="comment">//     Long r5 = exact2(raw, lng);</span></span><br><span class="line">        <span class="comment">//                      ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;T&gt;</span></span><br><span class="line">        <span class="comment">//   found:    Holder</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//       method &lt;T&gt;exact2(Holder&lt;T&gt;,T)</span></span><br><span class="line">        <span class="comment">// 2 warnings</span></span><br><span class="line"></span><br><span class="line">        Long r6 = exact2(qualified, lng);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Long r7 = exact2(unbounded, lng);</span></span><br><span class="line">        <span class="comment">// error: method exact2 in class Wildcards</span></span><br><span class="line">        <span class="comment">// cannot be applied to given types;</span></span><br><span class="line">        <span class="comment">//     Long r7 = exact2(unbounded, lng);</span></span><br><span class="line">        <span class="comment">//               ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;T&gt;,T</span></span><br><span class="line">        <span class="comment">//   found: Holder&lt;CAP#1&gt;,Long</span></span><br><span class="line">        <span class="comment">//   reason: inference variable T has</span></span><br><span class="line">        <span class="comment">//     incompatible bounds</span></span><br><span class="line">        <span class="comment">//     equality constraints: CAP#1</span></span><br><span class="line">        <span class="comment">//     lower bounds: Long</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//       method &lt;T&gt;exact2(Holder&lt;T&gt;,T)</span></span><br><span class="line">        <span class="comment">//   where CAP#1 is a fresh type-variable:</span></span><br><span class="line">        <span class="comment">//     CAP#1 extends Object from capture of ?</span></span><br><span class="line">        <span class="comment">// 1 error</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Long r8 = exact2(bounded, lng);</span></span><br><span class="line">        <span class="comment">// error: method exact2 in class Wildcards</span></span><br><span class="line">        <span class="comment">// cannot be applied to given types;</span></span><br><span class="line">        <span class="comment">//      Long r8 = exact2(bounded, lng);</span></span><br><span class="line">        <span class="comment">//                ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;T&gt;,T</span></span><br><span class="line">        <span class="comment">//   found: Holder&lt;CAP#1&gt;,Long</span></span><br><span class="line">        <span class="comment">//   reason: inference variable T</span></span><br><span class="line">        <span class="comment">//     has incompatible bounds</span></span><br><span class="line">        <span class="comment">//     equality constraints: CAP#1</span></span><br><span class="line">        <span class="comment">//     lower bounds: Long</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//       method &lt;T&gt;exact2(Holder&lt;T&gt;,T)</span></span><br><span class="line">        <span class="comment">//   where CAP#1 is a fresh type-variable:</span></span><br><span class="line">        <span class="comment">//     CAP#1 extends Long from</span></span><br><span class="line">        <span class="comment">//       capture of ? extends Long</span></span><br><span class="line">        <span class="comment">// 1 error</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Long r9 = wildSubtype(raw, lng);</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked method invocation:</span></span><br><span class="line">        <span class="comment">// method wildSubtype in class Wildcards</span></span><br><span class="line">        <span class="comment">// is applied to given types</span></span><br><span class="line">        <span class="comment">//     Long r9 = wildSubtype(raw, lng);</span></span><br><span class="line">        <span class="comment">//                          ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;? extends T&gt;,T</span></span><br><span class="line">        <span class="comment">//   found: Holder,Long</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//     method &lt;T&gt;wildSubtype(Holder&lt;? extends T&gt;,T)</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked conversion</span></span><br><span class="line">        <span class="comment">//     Long r9 = wildSubtype(raw, lng);</span></span><br><span class="line">        <span class="comment">//                           ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;? extends T&gt;</span></span><br><span class="line">        <span class="comment">//   found:    Holder</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//     method &lt;T&gt;wildSubtype(Holder&lt;? extends T&gt;,T)</span></span><br><span class="line">        <span class="comment">// 2 warnings</span></span><br><span class="line"></span><br><span class="line">        Long r10 = wildSubtype(qualified, lng);</span><br><span class="line">        <span class="comment">// OK, but can only return Object:</span></span><br><span class="line">        Object r11 = wildSubtype(unbounded, lng);</span><br><span class="line">        Long r12 = wildSubtype(bounded, lng);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- wildSupertype(raw, lng);</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked method invocation:</span></span><br><span class="line">        <span class="comment">//   method wildSupertype in class Wildcards</span></span><br><span class="line">        <span class="comment">//   is applied to given types</span></span><br><span class="line">        <span class="comment">//     wildSupertype(raw, lng);</span></span><br><span class="line">        <span class="comment">//                  ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;? super T&gt;,T</span></span><br><span class="line">        <span class="comment">//   found: Holder,Long</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//     method &lt;T&gt;wildSupertype(Holder&lt;? super T&gt;,T)</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked conversion</span></span><br><span class="line">        <span class="comment">//     wildSupertype(raw, lng);</span></span><br><span class="line">        <span class="comment">//                   ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;? super T&gt;</span></span><br><span class="line">        <span class="comment">//   found:    Holder</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//     method &lt;T&gt;wildSupertype(Holder&lt;? super T&gt;,T)</span></span><br><span class="line">        <span class="comment">// 2 warnings</span></span><br><span class="line"></span><br><span class="line">        wildSupertype(qualified, lng);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- wildSupertype(unbounded, lng);</span></span><br><span class="line">        <span class="comment">// error: method wildSupertype in class Wildcards</span></span><br><span class="line">        <span class="comment">// cannot be applied to given types;</span></span><br><span class="line">        <span class="comment">//     wildSupertype(unbounded, lng);</span></span><br><span class="line">        <span class="comment">//     ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;? super T&gt;,T</span></span><br><span class="line">        <span class="comment">//   found: Holder&lt;CAP#1&gt;,Long</span></span><br><span class="line">        <span class="comment">//   reason: cannot infer type-variable(s) T</span></span><br><span class="line">        <span class="comment">//     (argument mismatch; Holder&lt;CAP#1&gt;</span></span><br><span class="line">        <span class="comment">//     cannot be converted to Holder&lt;? super T&gt;)</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//     method &lt;T&gt;wildSupertype(Holder&lt;? super T&gt;,T)</span></span><br><span class="line">        <span class="comment">//   where CAP#1 is a fresh type-variable:</span></span><br><span class="line">        <span class="comment">//     CAP#1 extends Object from capture of ?</span></span><br><span class="line">        <span class="comment">// 1 error</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//- wildSupertype(bounded, lng);</span></span><br><span class="line">        <span class="comment">// error: method wildSupertype in class Wildcards</span></span><br><span class="line">        <span class="comment">// cannot be applied to given types;</span></span><br><span class="line">        <span class="comment">//     wildSupertype(bounded, lng);</span></span><br><span class="line">        <span class="comment">//     ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;? super T&gt;,T</span></span><br><span class="line">        <span class="comment">//   found: Holder&lt;CAP#1&gt;,Long</span></span><br><span class="line">        <span class="comment">//   reason: cannot infer type-variable(s) T</span></span><br><span class="line">        <span class="comment">//     (argument mismatch; Holder&lt;CAP#1&gt;</span></span><br><span class="line">        <span class="comment">//     cannot be converted to Holder&lt;? super T&gt;)</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//     method &lt;T&gt;wildSupertype(Holder&lt;? super T&gt;,T)</span></span><br><span class="line">        <span class="comment">//   where CAP#1 is a fresh type-variable:</span></span><br><span class="line">        <span class="comment">//     CAP#1 extends Long from capture of</span></span><br><span class="line">        <span class="comment">//     ? extends Long</span></span><br><span class="line">        <span class="comment">// 1 error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>rawArgs()</code> 中，编译器知道 <code>Holder</code> 是一个泛型类型，因此即使它在这里被表示成一个原生类型，编译器仍旧知道向 <code>set()</code> 传递一个 <strong>Object</strong> 是不安全的。由于它是原生类型，我们可以将任何类型的对象传递给 <code>set()</code> ，而这个对象将被向上转型为 <strong>Object</strong> 。因此无论何时，只要使用了原生类型，都会放弃编译期检查。对 <code>get()</code> 的调用说明了相同的问题：没有任何 <strong>T</strong> 类型的对象，因此结果只能是一个 <strong>Object</strong>。<br>人们很自然地会开始考虑原生 <code>Holder</code> 与 <code>Holder&lt;?&gt;</code> 是大致相同的事物。但是 <code>unboundedArg()</code> 强调它们是不同的——它揭示了相同的问题，但是它将这些问题作为错误而不是警告报告，因为原生 <strong>Holder</strong> 将持有任何类型的组合，而 <code>Holder&lt;?&gt;</code> 将持有具有某种具体类型的同构集合，因此不能只是向其中传递 <strong>Object</strong> 。<br>在 <code>exact1()</code> 和 <code>exact2()</code> 中，我们可以看到使用了确切的泛型参数——没有任何通配符。我们将看到，<code>exact2()</code>与 <code>exact1()</code> 具有不同的限制，因为它有额外的参数。<br>在 <code>wildSubtype()</code> 中，在 <strong>Holder</strong> 类型上的限制被放松为包括持有任何扩展自 <strong>T</strong> 的对象的 <strong>Holder</strong> 。这还是意味着如果 T 是 <strong>Fruit</strong> ，那么 <code>holder</code> 可以是 <code>Holder&lt;Apple&gt;</code> ，这是合法的。为了防止将 <strong>Orange</strong> 放置到 <code>Holder&lt;Apple&gt;</code> 中，对 <code>set()</code> 的调用（或者对任何接受这个类型参数为参数的方法的调用）都是不允许的。但是，我们仍旧知道任何来自 <code>Holder&lt;？extends Fruit&gt;</code> 的对象至少是 <strong>Fruit</strong> ，因此 <code>get()</code> （或者任何将产生具有这个类型参数的返回值的方法）都是允许的。<br><code>wildSupertype()</code> 展示了超类型通配符，这个方法展示了与 <code>wildSubtype()</code> 相反的行为：<code>holder</code> 可以是持有任何 T 的基类型的容器。因此， <code>set()</code> 可以接受 <strong>T</strong> ，因为任何可以工作于基类的对象都可以多态地作用于导出类（这里就是 <strong>T</strong> ）。但是，尝试着调用 <code>get()</code> 是没有用的，因为由 <code>holder</code> 持有的类型可以是任何超类型，因此唯一安全的类型就是 <strong>Object</strong> 。<br>这个示例还展示了对于在 <code>unbounded()</code> 中使用无界通配符能够做什么不能做什么所做出的限制：因为我们没有 <strong>T</strong>，所以我们不能将 <code>set()</code> 或 <code>get()</code> 作用于 <strong>T</strong> 上。</p><p>在 <code>main()</code> 方法中我们看到了某些方法在接受某些类型的参数时没有报错和警告。为了迁移兼容性，<code>rawArgs()</code>  将接受所有 <strong>Holder</strong> 的不同变体，而不会产生警告。<code>unboundedArg()</code> 方法也可以接受相同的所有类型，尽管如前所述，它在方法体内部处理这些类型的方式并不相同。</p><p>如果向接受“确切”泛型类型（没有通配符）的方法传递一个原生 <strong>Holder</strong> 引用，就会得到一个警告，因为确切的参数期望得到在原生类型中并不存在的信息。如果向 <code>exact1()</code> 传递一个无界引用，就不会有任何可以确定返回类型的类型信息。<br>可以看到，<code>exact2()</code> 具有最多的限制，因为它希望精确地得到一个 <code>Holder&lt;T&gt;</code> ，以及一个具有类型 <strong>T</strong> 的参数，正由于此，它将产生错误或警告，除非提供确切的参数。有时，这样做很好，但是如果它过于受限，那么就可以使用通配符，这取决于是否想要从泛型参数中返回类型确定的返回值（就像在 <code>wildSubtype()</code> 中看到的那样），或者是否想要向泛型参数传递类型确定的参数（就像在 <code>wildSupertype()</code> 中看到的那样）。<br>因此，使用确切类型来替代通配符类型的好处是，可以用泛型参数来做更多的事，但是使用通配符使得我们必须接受范围更宽的参数化类型作为参数。因此，必须逐个情况地权衡利弊，找到更适合我们的需求的方法。</p><h3 id="捕获转换"><a href="#捕获转换" class="headerlink" title="捕获转换"></a>捕获转换</h3><p>有一种特殊情况需要使用 <code>&lt;?&gt;</code> 而不是原生类型。如果向一个使用 <code>&lt;?&gt;</code> 的方法传递原生类型，那么对编译器来说，可能会推断出实际的类型参数，使得这个方法可以回转并调用另一个使用这个确切类型的方法。下面的示例演示了这种技术，它被称为捕获转换，因为未指定的通配符类型被捕获，并被转换为确切类型。这里，有关警告的注释只有在 <code>@SuppressWarnings</code> 注解被移除之后才能起作用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/CaptureConversion.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CaptureConversion</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(Holder&lt;T&gt; holder)</span> </span>&#123;</span><br><span class="line">        T t = holder.get();</span><br><span class="line">        System.out.println(t.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">(Holder&lt;?&gt; holder)</span> </span>&#123;</span><br><span class="line">        f1(holder); <span class="comment">// Call with captured type</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Holder raw = <span class="keyword">new</span> Holder&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">        f1(raw);</span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked method invocation:</span></span><br><span class="line">        <span class="comment">// method f1 in class CaptureConversion</span></span><br><span class="line">        <span class="comment">// is applied to given types</span></span><br><span class="line">        <span class="comment">//     f1(raw);</span></span><br><span class="line">        <span class="comment">//       ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;T&gt;</span></span><br><span class="line">        <span class="comment">//   found: Holder</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//     method &lt;T&gt;f1(Holder&lt;T&gt;)</span></span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked conversion</span></span><br><span class="line">        <span class="comment">//     f1(raw);</span></span><br><span class="line">        <span class="comment">//        ^</span></span><br><span class="line">        <span class="comment">//   required: Holder&lt;T&gt;</span></span><br><span class="line">        <span class="comment">//   found:    Holder</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in</span></span><br><span class="line">        <span class="comment">//     method &lt;T&gt;f1(Holder&lt;T&gt;)</span></span><br><span class="line">        <span class="comment">// 2 warnings</span></span><br><span class="line">        f2(raw); <span class="comment">// No warnings</span></span><br><span class="line">        </span><br><span class="line">        Holder rawBasic = <span class="keyword">new</span> Holder();</span><br><span class="line">        rawBasic.set(<span class="keyword">new</span> Object());</span><br><span class="line">        <span class="comment">// warning: [unchecked] unchecked call to set(T)</span></span><br><span class="line">        <span class="comment">// as a member of the raw type Holder</span></span><br><span class="line">        <span class="comment">//     rawBasic.set(new Object());</span></span><br><span class="line">        <span class="comment">//                 ^</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends Object declared in class Holder</span></span><br><span class="line">        <span class="comment">// 1 warning</span></span><br><span class="line">        f2(rawBasic); <span class="comment">// No warnings</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Upcast to Holder&lt;?&gt;, still figures it out:</span></span><br><span class="line">        Holder&lt;?&gt; wildcarded = <span class="keyword">new</span> Holder&lt;&gt;(<span class="number">1.0</span>);</span><br><span class="line">        f2(wildcarded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Integer</span></span><br><span class="line"><span class="comment">Integer</span></span><br><span class="line"><span class="comment">Object</span></span><br><span class="line"><span class="comment">Double</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>f1()</code> 中的类型参数都是确切的，没有通配符或边界。在 <code>f2()</code> 中，<strong>Holder</strong> 参数是一个无界通配符，因此它看起来是未知的。但是，在 <code>f2()</code> 中调用了 <code>f1()</code>，而 <code>f1()</code> 需要一个已知参数。这里所发生的是：在调用 <code>f2()</code> 的过程中捕获了参数类型，并在调用 <code>f1()</code> 时使用了这种类型。<br>我们可能想知道这项技术是否可以用于写入，但是这要求在传递 <code>Holder&lt;?&gt;</code> 时同时传递一个具体类型。捕获转换只有在这样的情况下可以工作：即在方法内部，我们需要使用确切的类型。注意，不能从 <code>f2()</code> 中返回 <strong>T</strong>，因为 <strong>T</strong> 对于 <code>f2()</code> 来说是未知的。捕获转换十分有趣，但是非常受限。</p><!-- Issues --><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>本节将阐述在使用 Java 泛型时会出现的各类问题。</p><h3 id="任何基本类型都不能作为类型参数"><a href="#任何基本类型都不能作为类型参数" class="headerlink" title="任何基本类型都不能作为类型参数"></a>任何基本类型都不能作为类型参数</h3><p>正如本章早先提到的，Java 泛型的限制之一是不能将基本类型用作类型参数。因此，不能创建  <code>ArrayList&lt;int&gt;</code> 之类的东西。<br>解决方法是使用基本类型的包装器类以及自动装箱机制。如果创建一个 <code>ArrayList&lt;Integer&gt;</code>，并将基本类型 <strong>int</strong> 应用于这个集合，那么我们将发现自动装箱机制将自动地实现 <strong>int</strong> 到 <strong>Integer</strong> 的双向转换——因此，这几乎就像是有一个 <code>ArrayList&lt;int&gt;</code> 一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ListOfInt.java</span></span><br><span class="line"><span class="comment">// Autoboxing compensates for the inability</span></span><br><span class="line"><span class="comment">// to use primitives in generics</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListOfInt</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; li = IntStream.range(<span class="number">38</span>, <span class="number">48</span>)</span><br><span class="line">            .boxed() <span class="comment">// Converts ints to Integers</span></span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">        System.out.println(li);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[38, 39, 40, 41, 42, 43, 44, 45, 46, 47]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>通常，这种解决方案工作得很好——能够成功地存储和读取 <strong>int</strong>，自动装箱隐藏了转换的过程。但是如果性能成为问题的话，就需要使用专门为基本类型适配的特殊版本的集合；一个开源版本的实现是 <strong>org.apache.commons.collections.primitives</strong>。<br>下面是另外一种方式，它可以创建持有 <strong>Byte</strong> 的 <strong>Set</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ByteSet.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteSet</span> </span>&#123;</span><br><span class="line">    Byte[] possibles = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    Set&lt;Byte&gt; mySet = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(possibles));</span><br><span class="line">    <span class="comment">// But you can't do this:</span></span><br><span class="line">    <span class="comment">// Set&lt;Byte&gt; mySet2 = new HashSet&lt;&gt;(</span></span><br><span class="line">    <span class="comment">// Arrays.&lt;Byte&gt;asList(1,2,3,4,5,6,7,8,9));</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自动装箱机制解决了一些问题，但并没有解决所有问题。</p><p>在下面的示例中，<strong>FillArray</strong> 接口包含一些通用方法，这些方法使用 <strong>Supplier</strong> 来用对象填充数组（这使得类泛型在本例中无法工作，因为这个方法是静态的）。<strong>Supplier</strong> 实现来自 <a href="book/21-Arrays.md">数组</a> 一章,并且在 <code>main()</code> 中，可以看到 <code>FillArray.fill()</code> 使用对象填充了数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/PrimitiveGenericTest.java</span></span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fill an array using a generator:</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FillArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; T[] fill(T[] a, Supplier&lt;T&gt; gen) &#123;</span><br><span class="line">        Arrays.setAll(a, n -&gt; gen.get());</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] fill(<span class="keyword">int</span>[] a, IntSupplier gen) &#123;</span><br><span class="line">        Arrays.setAll(a, n -&gt; gen.getAsInt());</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span>[] fill(<span class="keyword">long</span>[] a, LongSupplier gen) &#123;</span><br><span class="line">        Arrays.setAll(a, n -&gt; gen.getAsLong());</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span>[] fill(<span class="keyword">double</span>[] a, DoubleSupplier gen) &#123;</span><br><span class="line">        Arrays.setAll(a, n -&gt; gen.getAsDouble());</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimitiveGenericTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] strings = FillArray.fill(</span><br><span class="line">            <span class="keyword">new</span> String[<span class="number">5</span>], <span class="keyword">new</span> Rand.String(<span class="number">9</span>));</span><br><span class="line">        System.out.println(Arrays.toString(strings));</span><br><span class="line">        <span class="keyword">int</span>[] integers = FillArray.fill(</span><br><span class="line">            <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>], <span class="keyword">new</span> Rand.Pint());</span><br><span class="line">        System.out.println(Arrays.toString(integers));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[btpenpccu, xszgvgmei, nneeloztd, vewcippcy, gpoalkljl]</span></span><br><span class="line"><span class="comment">[635, 8737, 3941, 4720, 6177, 8479, 6656, 3768, 4948]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>自动装箱不适用于数组，因此我们必须创建 <code>FillArray.fill()</code> 的重载版本，或创建产生 <strong>Wrapped</strong> 输出的生成器。 <strong>FillArray</strong> 仅比 <code>java.util.Arrays.setAll()</code> 有用一点，因为它返回填充的数组。</p><h3 id="实现参数化接口"><a href="#实现参数化接口" class="headerlink" title="实现参数化接口"></a>实现参数化接口</h3><p>一个类不能实现同一个泛型接口的两种变体，由于擦除的原因，这两个变体会成为相同的接口。下面是产生这种冲突的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/MultipleInterfaceVariants.java</span></span><br><span class="line"><span class="comment">// &#123;WillNotCompile&#125;</span></span><br><span class="line"><span class="keyword">package</span> generics;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Payable</span>&lt;<span class="title">T</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Payable</span>&lt;<span class="title">Employee</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hourly</span> <span class="keyword">extends</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Payable</span>&lt;<span class="title">Hourly</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>Hourly</strong> 不能编译，因为擦除会将  <code>Payable&lt;Employe&gt;</code> 和 <code>Payable&lt;Hourly&gt;</code> 简化为相同的类 <strong>Payable</strong>，这样，上面的代码就意味着在重复两次地实现相同的接口。十分有趣的是，如果从 <strong>Payable</strong> 的两种用法中都移除掉泛型参数（就像编译器在擦除阶段所做的那样）这段代码就可以编译。</p><p>在使用某些更基本的 Java 接口，例如 <code>Comparable&lt;T&gt;</code> 时，这个问题可能会变得十分令人恼火，就像我们在本节稍后看到的那样。</p><h3 id="转型和警告"><a href="#转型和警告" class="headerlink" title="转型和警告"></a>转型和警告</h3><p>使用带有泛型类型参数的转型或 <strong>instanceof</strong> 不会有任何效果。下面的集合在内部将各个值存储为 <strong>Object</strong>，并在获取这些值时，再将它们转型回 <strong>T</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericCast.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FixedSizeStack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> Object[] storage;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    FixedSizeStack(<span class="keyword">int</span> size) &#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        storage = <span class="keyword">new</span> Object[size];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; size)</span><br><span class="line">            storage[index++] = item;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index == <span class="number">0</span> ? <span class="keyword">null</span> : (T)storage[--index];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function">Stream&lt;T&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Stream&lt;T&gt;)Arrays.stream(storage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericCast</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String[] letters = <span class="string">"ABCDEFGHIJKLMNOPQRS"</span>.split(<span class="string">""</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FixedSizeStack&lt;String&gt; strings =</span><br><span class="line">            <span class="keyword">new</span> FixedSizeStack&lt;&gt;(letters.length);</span><br><span class="line">        Arrays.stream(<span class="string">"ABCDEFGHIJKLMNOPQRS"</span>.split(<span class="string">""</span>))</span><br><span class="line">            .forEach(strings::push);</span><br><span class="line">        System.out.println(strings.pop());</span><br><span class="line">        strings.stream()</span><br><span class="line">            .map(s -&gt; s + <span class="string">" "</span>)</span><br><span class="line">            .forEach(System.out::print);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">S</span></span><br><span class="line"><span class="comment">A B C D E F G H I J K L M N O P Q R S</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>如果没有 <strong>@SuppressWarnings</strong> 注解，编译器将对 <code>pop()</code> 产生 “unchecked cast” 警告。由于擦除的原因，编译器无法知道这个转型是否是安全的，并且 <code>pop()</code> 方法实际上并没有执行任何转型。<br>这是因为，<strong>T</strong> 被擦除到它的第一个边界，默认情况下是 <strong>Object</strong> ，因此 <code>pop()</code> 实际上只是将 <strong>Object</strong> 转型为 <strong>Object</strong>。<br>有时，泛型没有消除对转型的需要，这就会由编译器产生警告，而这个警告是不恰当的。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/NeedCasting.java</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NeedCasting</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">            <span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]));</span><br><span class="line">        List&lt;Widget&gt; shapes = (List&lt;Widget&gt;)in.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如我们将在 <a href="book/Appendix-Object-Serialization.md">附录：对象序列化</a> 中学到的那样，<code>readObject()</code> 无法知道它正在读取的是什么，因此它返回的是必须转型的对象。但是当注释掉 <strong>@SuppressWarnings</strong> 注解并编译这个程序时，就会得到下面的警告。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NeedCasting.java uses unchecked or unsafe operations.</span><br><span class="line">Recompile with -Xlint:unchecked for details.</span><br><span class="line"></span><br><span class="line">And if you follow the instructions and recompile with  -</span><br><span class="line">Xlint:unchecked :(如果遵循这条指示，使用-Xlint:unchecked来重新编译：)</span><br><span class="line"></span><br><span class="line">NeedCasting.java:10: warning: [unchecked] unchecked cast</span><br><span class="line">    List&lt;Widget&gt; shapes = (List&lt;Widget&gt;)in.readObject();</span><br><span class="line">    required: List&lt;Widget&gt;</span><br><span class="line">    found: Object</span><br><span class="line">1 warning</span><br></pre></td></tr></table></figure><p>我们会被强制要求转型，但是又被告知不应该转型。为了解决这个问题，必须使用 Java 5 引入的新的转型形式，既通过泛型类来转型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ClassCasting.java</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassCasting</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">            <span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]));</span><br><span class="line">        <span class="comment">// Won't Compile:</span></span><br><span class="line">        <span class="comment">//    List&lt;Widget&gt; lw1 =</span></span><br><span class="line">        <span class="comment">//    List&lt;&gt;.class.cast(in.readObject());</span></span><br><span class="line">        List&lt;Widget&gt; lw2 = List.class.cast(in.readObject());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，不能转型到实际类型（ <code>List&lt;Widget&gt;</code> ）。也就是说，不能声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Widget&gt;.class.cast(in.readobject())</span><br></pre></td></tr></table></figure><p>甚至当我们添加一个像下面这样的另一个转型时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(List&lt;Widget&gt;)List.class.cast(in.readobject())</span><br></pre></td></tr></table></figure><p>仍旧会得到一个警告。</p><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>下面的程序是不能编译的，即使它看起来是合理的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/UseList.java</span></span><br><span class="line"><span class="comment">// &#123;WillNotCompile&#125;</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseList</span>&lt;<span class="title">W</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(List&lt;T&gt; v)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(List&lt;W&gt; v)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为擦除，所以重载方法产生了相同的类型签名。</p><p>因而，当擦除后的参数不能产生唯一的参数列表时，我们必须提供不同的方法名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/UseList2.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseList2</span>&lt;<span class="title">W</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(List&lt;T&gt; v)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(List&lt;W&gt; v)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>幸运的是，编译器可以检测到这类问题。</p><h3 id="基类劫持接口"><a href="#基类劫持接口" class="headerlink" title="基类劫持接口"></a>基类劫持接口</h3><p>假设我们有一个实现了 <strong>Comparable</strong> 接口的 <strong>Pet</strong> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ComparablePet.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparablePet</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ComparablePet</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(ComparablePet o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试缩小 <strong>ComparablePet</strong> 子类的比较类型是有意义的。例如，<strong>Cat</strong> 类可以与其他的 <strong>Cat</strong> 比较：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/HijackedInterface.java</span></span><br><span class="line"><span class="comment">// &#123;WillNotCompile&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">ComparablePet</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Cat</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// error: Comparable cannot be inherited with</span></span><br><span class="line">    <span class="comment">// different arguments: &lt;Cat&gt; and &lt;ComparablePet&gt;</span></span><br><span class="line">    <span class="comment">// class Cat</span></span><br><span class="line">    <span class="comment">// ^</span></span><br><span class="line">    <span class="comment">// 1 error</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Cat arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不幸的是，这不能工作。一旦 <strong>Comparable</strong> 的类型参数设置为 <strong>ComparablePet</strong>，其他的实现类只能比较 <strong>ComparablePet</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/RestrictedComparablePets.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hamster</span> <span class="keyword">extends</span> <span class="title">ComparablePet</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ComparablePet</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(ComparablePet arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Or just:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gecko</span> <span class="keyword">extends</span> <span class="title">ComparablePet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(ComparablePet arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Hamster</strong> 显示了重新实现 <strong>ComparableSet</strong> 中相同的接口是可能的，只要接口完全相同，包括参数类型。然而正如 <strong>Gecko</strong> 中所示，这与直接覆写基类的方法完全相同。</p><!-- Self-Bounded Types --><h2 id="自限定的类型"><a href="#自限定的类型" class="headerlink" title="自限定的类型"></a>自限定的类型</h2><p>在 Java 泛型中，有一个似乎经常性出现的惯用法，它相当令人费解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123; <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>这就像两面镜子彼此照向对方所引起的目眩效果一样，是一种无限反射。<strong>SelfBounded</strong> 类接受泛型参数 <strong>T</strong>，而 <strong>T</strong> 由一个边界类限定，这个边界就是拥有 <strong>T</strong> 作为其参数的 <strong>SelfBounded</strong>。</p><p>当我们首次看到它时，很难去解析它，它强调的是当 <strong>extends</strong> 关键字用于边界与用来创建子类明显是不同的。</p><h3 id="古怪的循环泛型"><a href="#古怪的循环泛型" class="headerlink" title="古怪的循环泛型"></a>古怪的循环泛型</h3><p>为了理解自限定类型的含义，我们从这个惯用法的一个简单版本入手，它没有自限定的边界。</p><p>不能直接继承一个泛型参数，但是，可以继承在其自己的定义中使用这个泛型参数的类。也就是说，可以声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/CuriouslyRecurringGeneric.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericType</span>&lt;<span class="title">T</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuriouslyRecurringGeneric</span></span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">GenericType</span>&lt;<span class="title">CuriouslyRecurringGeneric</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>这可以按照 Jim Coplien 在 C++ 中的<em>古怪的循环模版模式</em>的命名方式，称为古怪的循环泛型（CRG）。“古怪的循环”是指类相当古怪地出现在它自己的基类中这一事实。<br>为了理解其含义，努力大声说：“我在创建一个新类，它继承自一个泛型类型，这个泛型类型接受我的类的名字作为其参数。”当给出导出类的名字时，这个泛型基类能够实现什么呢？好吧，Java 中的泛型关乎参数和返回类型，因此它能够产生使用导出类作为其参数和返回类型的基类。它还能将导出类型用作其域类型，尽管这些将被擦除为 <strong>Object</strong> 的类型。下面是表示了这种情况的一个泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/BasicHolder.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicHolder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T element;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(T arg)</span> </span>&#123; element = arg; &#125;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> element; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(element.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个普通的泛型类型，它的一些方法将接受和产生具有其参数类型的对象，还有一个方法在其存储的域上执行操作（尽管只是在这个域上执行 <strong>Object</strong> 操作）。<br>我们可以在一个古怪的循环泛型中使用 <strong>BasicHolder</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/CRGWithBasicHolder.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subtype</span> <span class="keyword">extends</span> <span class="title">BasicHolder</span>&lt;<span class="title">Subtype</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CRGWithBasicHolder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subtype st1 = <span class="keyword">new</span> Subtype(), st2 = <span class="keyword">new</span> Subtype();</span><br><span class="line">        st1.set(st2);</span><br><span class="line">        Subtype st3 = st1.get();</span><br><span class="line">        st1.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Subtype</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>注意，这里有些东西很重要：新类 <strong>Subtype</strong> 接受的参数和返回的值具有 <strong>Subtype</strong> 类型而不仅仅是基类 <strong>BasicHolder</strong> 类型。这就是 CRG 的本质：基类用导出类替代其参数。这意味着泛型基类变成了一种其所有导出类的公共功能的模版，但是这些功能对于其所有参数和返回值，将使用导出类型。也就是说，在所产生的类中将使用确切类型而不是基类型。因此，在<strong>Subtype</strong> 中，传递给 <code>set()</code> 的参数和从 <code>get()</code> 返回的类型都是确切的 <strong>Subtype</strong>。</p><h3 id="自限定"><a href="#自限定" class="headerlink" title="自限定"></a>自限定</h3><p><strong>BasicHolder</strong> 可以使用任何类型作为其泛型参数，就像下面看到的那样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Unconstrained.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// We make no guarantees that this code is fit for any purpose.</span></span><br><span class="line"><span class="comment">// Visit http://OnJava8.com for more book information.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Other</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicOther</span> <span class="keyword">extends</span> <span class="title">BasicHolder</span>&lt;<span class="title">Other</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Unconstrained</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BasicOther b = <span class="keyword">new</span> BasicOther();</span><br><span class="line">        BasicOther b2 = <span class="keyword">new</span> BasicOther();</span><br><span class="line">        b.set(<span class="keyword">new</span> Other());</span><br><span class="line">        Other other = b.get();</span><br><span class="line">        b.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Other</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>限定将采取额外的步骤，强制泛型当作其自身的边界参数来使用。观察所产生的类可以如何使用以及不可以如何使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/SelfBounding.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    T element;</span><br><span class="line">    <span class="function">SelfBounded&lt;T&gt; <span class="title">set</span><span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">        element = arg;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> element; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">A</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">A</span>&gt; </span>&#123;&#125; <span class="comment">// Also OK</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">C</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">C <span class="title">setAndGet</span><span class="params">(C arg)</span> </span>&#123; </span><br><span class="line">        set(arg); </span><br><span class="line">        <span class="keyword">return</span> get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// Can't do this:</span></span><br><span class="line"><span class="comment">// class E extends SelfBounded&lt;D&gt; &#123;&#125;</span></span><br><span class="line"><span class="comment">// Compile error:</span></span><br><span class="line"><span class="comment">//   Type parameter D is not within its bound</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Alas, you can do this, so you cannot force the idiom:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfBounding</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        a.set(<span class="keyword">new</span> A());</span><br><span class="line">        a = a.set(<span class="keyword">new</span> A()).get();</span><br><span class="line">        a = a.get();</span><br><span class="line">        C c = <span class="keyword">new</span> C();</span><br><span class="line">        c = c.setAndGet(<span class="keyword">new</span> C());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自限定所做的，就是要求在继承关系中，像下面这样使用这个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">A</span>&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>这会强制要求将正在定义的类当作参数传递给基类。</p><p>自限定的参数有何意义呢？它可以保证类型参数必须与正在被定义的类相同。正如我们在 B 类的定义中所看到的，还可以从使用了另一个 <strong>SelfBounded</strong> 参数的 <strong>SelfBounded</strong> 中导出，尽管在 <strong>A</strong> 类看到的用法看起来是主要的用法。对定义 <strong>E</strong> 的尝试说明不能使用不是 <strong>SelfBounded</strong> 的类型参数。<br>遗憾的是， <strong>F</strong> 可以编译，不会有任何警告，因此自限定惯用法不是可强制执行的。如果它确实很重要，可以要求一个外部工具来确保不会使用原生类型来替代参数化类型。<br>注意，可以移除自限定这个限制，这样所有的类仍旧是可以编译的，但是 <strong>E</strong> 也会因此而变得可编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/NotSelfBounded.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T element;</span><br><span class="line">    <span class="function">NotSelfBounded&lt;T&gt; <span class="title">set</span><span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">        element = arg;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> element; &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span> <span class="keyword">extends</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">A2</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span> <span class="keyword">extends</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">A2</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2</span> <span class="keyword">extends</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">C2</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">C2 <span class="title">setAndGet</span><span class="params">(C2 arg)</span> </span>&#123; </span><br><span class="line">        set(arg); </span><br><span class="line">        <span class="keyword">return</span> get(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// Now this is OK:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E2</span> <span class="keyword">extends</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">D2</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>因此很明显，自限定限制只能强制作用于继承关系。如果使用自限定，就应该了解这个类所用的类型参数将与使用这个参数的类具有相同的基类型。这会强制要求使用这个类的每个人都要遵循这种形式。<br>还可以将自限定用于泛型方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/SelfBoundingMethods.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// We make no guarantees that this code is fit for any purpose.</span></span><br><span class="line"><span class="comment">// Visit http://OnJava8.com for more book information.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfBoundingMethods</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T extends SelfBounded&lt;T&gt;&gt; <span class="function">T <span class="title">f</span><span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arg.set(arg).get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = f(<span class="keyword">new</span> A());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这可以防止这个方法被应用于除上述形式的自限定参数之外的任何事物上。</p><h3 id="参数协变"><a href="#参数协变" class="headerlink" title="参数协变"></a>参数协变</h3><p>自限定类型的价值在于它们可以产生<em>协变参数类型</em>——方法参数类型会随子类而变化。</p><p>尽管自限定类型还可以产生与子类类型相同的返回类型，但是这并不十分重要，因为<em>协变返回类型</em>是在 Java 5 引入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/CovariantReturnTypes.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OrdinaryGetter</span> </span>&#123;</span><br><span class="line">    <span class="function">Base <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DerivedGetter</span> <span class="keyword">extends</span> <span class="title">OrdinaryGetter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Overridden method return type can vary:</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Derived <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantReturnTypes</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(DerivedGetter d)</span> </span>&#123;</span><br><span class="line">        Derived d2 = d.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>DerivedGetter</strong> 中的 <code>get()</code> 方法覆盖了 <strong>OrdinaryGetter</strong> 中的 <code>get()</code> ，并返回了一个从 <code>OrdinaryGetter.get()</code> 的返回类型中导出的类型。尽管这是完全合乎逻辑的事情（导出类方法应该能够返回比它覆盖的基类方法更具体的类型）但是这在早先的 Java 版本中是不合法的。</p><p>自限定泛型事实上将产生确切的导出类型作为其返回值，就像在 <code>get()</code> 中所看到的一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericsAndReturnTypes.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GenericGetter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">GenericGetter</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Getter</span> <span class="keyword">extends</span> <span class="title">GenericGetter</span>&lt;<span class="title">Getter</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsAndReturnTypes</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Getter g)</span> </span>&#123;</span><br><span class="line">        Getter result = g.get();</span><br><span class="line">        GenericGetter gg = g.get(); <span class="comment">// Also the base type</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这段代码不能编译，除非是使用囊括了协变返回类型的 Java 5。</p><p>然而，在非泛型代码中，参数类型不能随子类型发生变化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/OrdinaryArguments.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrdinarySetter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Base base)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"OrdinarySetter.set(Base)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedSetter</span> <span class="keyword">extends</span> <span class="title">OrdinarySetter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Derived derived)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"DerivedSetter.set(Derived)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrdinaryArguments</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Base base = <span class="keyword">new</span> Base();</span><br><span class="line">        Derived derived = <span class="keyword">new</span> Derived();</span><br><span class="line">        DerivedSetter ds = <span class="keyword">new</span> DerivedSetter();</span><br><span class="line">        ds.set(derived);</span><br><span class="line">        <span class="comment">// Compiles--overloaded, not overridden!:</span></span><br><span class="line">        ds.set(base);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">DerivedSetter.set(Derived)</span></span><br><span class="line"><span class="comment">OrdinarySetter.set(Base)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>set(derived)</code> 和 <code>set(base)</code> 都是合法的，因此 <code>DerivedSetter.set()</code> 没有覆盖 <code>OrdinarySetter.set()</code> ，而是重载了这个方法。从输出中可以看到，在 <strong>DerivedSetter</strong> 中有两个方法，因此基类版本仍旧是可用的，因此可以证明它被重载过。<br>但是，在使用自限定类型时，在导出类中只有一个方法，并且这个方法接受导出类型而不是基类型为参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/SelfBoundingAndCovariantArguments.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SelfBoundSetter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SelfBoundSetter</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(T arg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Setter</span> <span class="keyword">extends</span> <span class="title">SelfBoundSetter</span>&lt;<span class="title">Setter</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfBoundingAndCovariantArguments</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span></span><br><span class="line">    testA(Setter s1, Setter s2, SelfBoundSetter sbs) &#123;</span><br><span class="line">        s1.set(s2);</span><br><span class="line">        <span class="comment">//- s1.set(sbs);</span></span><br><span class="line">        <span class="comment">// error: method set in interface SelfBoundSetter&lt;T&gt;</span></span><br><span class="line">        <span class="comment">// cannot be applied to given types;</span></span><br><span class="line">        <span class="comment">//     s1.set(sbs);</span></span><br><span class="line">        <span class="comment">//       ^</span></span><br><span class="line">        <span class="comment">//   required: Setter</span></span><br><span class="line">        <span class="comment">//   found: SelfBoundSetter</span></span><br><span class="line">        <span class="comment">//   reason: argument mismatch;</span></span><br><span class="line">        <span class="comment">// SelfBoundSetter cannot be converted to Setter</span></span><br><span class="line">        <span class="comment">//   where T is a type-variable:</span></span><br><span class="line">        <span class="comment">//     T extends SelfBoundSetter&lt;T&gt; declared in</span></span><br><span class="line">        <span class="comment">//     interface SelfBoundSetter</span></span><br><span class="line">        <span class="comment">// 1 error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器不能识别将基类型当作参数传递给 <code>set()</code> 的尝试，因为没有任何方法具有这样的签名。实际上，这个参数已经被覆盖。<br>如果不使用自限定类型，普通的继承机制就会介入，而我们将能够重载，就像在非泛型的情况下一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/PlainGenericInheritance.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericSetter</span>&lt;<span class="title">T</span>&gt; </span>&#123; <span class="comment">// Not self-bounded</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"GenericSetter.set(Base)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedGS</span> <span class="keyword">extends</span> <span class="title">GenericSetter</span>&lt;<span class="title">Base</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Derived derived)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"DerivedGS.set(Derived)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlainGenericInheritance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Base base = <span class="keyword">new</span> Base();</span><br><span class="line">        Derived derived = <span class="keyword">new</span> Derived();</span><br><span class="line">        DerivedGS dgs = <span class="keyword">new</span> DerivedGS();</span><br><span class="line">        dgs.set(derived);</span><br><span class="line">        dgs.set(base); <span class="comment">// Overloaded, not overridden!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">DerivedGS.set(Derived)</span></span><br><span class="line"><span class="comment">GenericSetter.set(Base)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这段代码在模仿 <strong>OrdinaryArguments.java</strong>；在那个示例中，<strong>DerivedSetter</strong> 继承自包含一个 <code>set(Base)</code> 的<strong>OrdinarySetter</strong> 。而这里，<strong>DerivedGS</strong> 继承自泛型创建的也包含有一个 <code>set(Base)</code>的 <code>GenericSetter&lt;Base&gt;</code>。就像 <strong>OrdinaryArguments.java</strong> 一样，我们可以从输出中看到， <strong>DerivedGS</strong> 包含两个  <code>set()</code> 的重载版本。如果不使用自限定，将重载参数类型。如果使用了自限定，只能获得方法的一个版本，它将接受确切的参数类型。</p><!-- Dynamic Type Safety --><h2 id="动态类型安全"><a href="#动态类型安全" class="headerlink" title="动态类型安全"></a>动态类型安全</h2><p>因为可以向 Java 5 之前的代码传递泛型集合，所以旧式代码仍旧有可能会破坏我们的集合。Java 5 的 <strong>java.util.Collections</strong> 中有一组便利工具，可以解决在这种情况下的类型检查问题，它们是：静态方法 <code>checkedCollection()</code> 、<code>checkedList()</code>、 <code>checkedMap()</code> 、 <code>checkedSet()</code> 、<code>checkedSortedMap()</code>和 <code>checkedSortedSet()</code>。这些方法每一个都会将我们希望动态检查的集合当作第一个参数接受，并将我们希望强制要求的类型作为第二个参数接受。</p><p>受检查的集合在我们试图插入类型不正确的对象时抛出 <strong>ClassCastException</strong> ，这与泛型之前的（原生）集合形成了对比，对于后者来说，当我们将对象从集合中取出时，才会通知我们出现了问题。在后一种情况中，我们知道存在问题，但是不知道罪魁祸首在哪里，如果使用受检查的集合，就可以发现谁在试图插入不良对象。<br>让我们用受检查的集合来看看“将猫插入到狗列表中”这个问题。这里，<code>oldStyleMethod()</code> 表示遗留代码，因为它接受的是原生的 <strong>List</strong> ，而 <strong>@SuppressWarnings（“unchecked”）</strong> 注解对于压制所产生的警告是必需的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/CheckedList.java</span></span><br><span class="line"><span class="comment">// Using Collection.checkedList()</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckedList</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">oldStyleMethod</span><span class="params">(List probablyDogs)</span> </span>&#123;</span><br><span class="line">        probablyDogs.add(<span class="keyword">new</span> Cat());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Dog&gt; dogs1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        oldStyleMethod(dogs1); <span class="comment">// Quietly accepts a Cat</span></span><br><span class="line">        List&lt;Dog&gt; dogs2 = Collections.checkedList(</span><br><span class="line">            <span class="keyword">new</span> ArrayList&lt;&gt;(), Dog.class);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oldStyleMethod(dogs2); <span class="comment">// Throws an exception</span></span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Expected: "</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Derived types work fine:</span></span><br><span class="line">        List&lt;Pet&gt; pets = Collections.checkedList(</span><br><span class="line">            <span class="keyword">new</span> ArrayList&lt;&gt;(), Pet.class);</span><br><span class="line">        pets.add(<span class="keyword">new</span> Dog());</span><br><span class="line">        pets.add(<span class="keyword">new</span> Cat());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Expected: java.lang.ClassCastException: Attempt to</span></span><br><span class="line"><span class="comment">insert class typeinfo.pets.Cat element into collection</span></span><br><span class="line"><span class="comment">with element type class typeinfo.pets.Dog</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>运行这个程序时，我们会发现插入一个 <strong>Cat</strong> 对于 <strong>dogs1</strong> 来说没有任何问题，而 <strong>dogs2</strong> 立即会在这个错误类型的插入操作上抛出一个异常。还可以看到，将导出类型的对象放置到将要检查基类型的受检查容器中是没有问题的。</p><!-- Exceptions --><h2 id="泛型异常"><a href="#泛型异常" class="headerlink" title="泛型异常"></a>泛型异常</h2><p>由于擦除的原因，<strong>catch</strong> 语句不能捕获泛型类型的异常，因为在编译期和运行时都必须知道异常的确切类型。泛型类也不能直接或间接继承自 <strong>Throwable</strong>（这将进一步阻止我们去定义不能捕获的泛型异常）。<br>但是，类型参数可能会在一个方法的 <strong>throws</strong> 子句中用到。这使得我们可以编写随检查型异常类型变化的泛型代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ThrowGenericException.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Processor</span>&lt;<span class="title">T</span>, <span class="title">E</span> <span class="keyword">extends</span> <span class="title">Exception</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;T&gt; resultCollector)</span> <span class="keyword">throws</span> E</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProcessRunner</span>&lt;<span class="title">T</span>, <span class="title">E</span> <span class="keyword">extends</span> <span class="title">Exception</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">Processor</span>&lt;<span class="title">T</span>, <span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">processAll</span><span class="params">()</span> <span class="keyword">throws</span> E </span>&#123;</span><br><span class="line">        List&lt;T&gt; resultCollector = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Processor&lt;T, E&gt; processor : <span class="keyword">this</span>)</span><br><span class="line">            processor.process(resultCollector);</span><br><span class="line">        <span class="keyword">return</span> resultCollector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Failure1</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Processor1</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Processor</span>&lt;<span class="title">String</span>, <span class="title">Failure1</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">3</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;String&gt; resultCollector)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Failure1 </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count-- &gt; <span class="number">1</span>)</span><br><span class="line">            resultCollector.add(<span class="string">"Hep!"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            resultCollector.add(<span class="string">"Ho!"</span>);</span><br><span class="line">        <span class="keyword">if</span>(count &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Failure1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Failure2</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Processor2</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Processor</span>&lt;<span class="title">Integer</span>, <span class="title">Failure2</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">2</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;Integer&gt; resultCollector)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Failure2 </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count-- == <span class="number">0</span>)</span><br><span class="line">            resultCollector.add(<span class="number">47</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            resultCollector.add(<span class="number">11</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Failure2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowGenericException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProcessRunner&lt;String, Failure1&gt; runner =</span><br><span class="line">            <span class="keyword">new</span> ProcessRunner&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">            runner.add(<span class="keyword">new</span> Processor1());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(runner.processAll());</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Failure1 e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ProcessRunner&lt;Integer, Failure2&gt; runner2 =</span><br><span class="line">            <span class="keyword">new</span> ProcessRunner&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">            runner2.add(<span class="keyword">new</span> Processor2());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(runner2.processAll());</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Failure2 e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[Hep!, Hep!, Ho!]</span></span><br><span class="line"><span class="comment">Failure2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>Processor</strong> 执行 <code>process()</code> 方法，并且可能会抛出具有类型 <strong>E</strong> 的异常。<code>process()</code> 的结果存储在 <code>List&lt;T&gt;resultCollector</code> 中（这被称为<em>收集参数</em>）。<strong>ProcessRunner</strong> 有一个 <code>processAll()</code> 方法，它会在所持有的每个 <strong>Process</strong> 对象执行，并返回 <strong>resultCollector</strong> 。<br>如果不能参数化所抛出的异常，那么由于检查型异常的缘故，将不能编写出这种泛化的代码。</p><!-- Mixins --><h2 id="混型"><a href="#混型" class="headerlink" title="混型"></a>混型</h2><p>术语<em>混型<em>随时间的推移好像拥有了无数的含义，但是其最基本的概念是混合多个类的能力，以产生一个可以表示混型中所有类型的类。这往往是我们最后的手段，它将使组装多个类变得简单易行。<br>混型的价值之一是它们可以将特性和行为一致地应用于多个类之上。如果想在混型类中修改某些东西，作为一种意外的好处，这些修改将会应用于混型所应用的所有类型之上。正由于此，混型有一点</em>面向切面编程</em> （AOP） 的味道，而切面经常被建议用来解决混型问题。</p><h3 id="C-中的混型"><a href="#C-中的混型" class="headerlink" title="C++ 中的混型"></a>C++ 中的混型</h3><p>在 C++ 中，使用多重继承的最大理由，就是为了使用混型。但是，对于混型来说，更有趣、更优雅的方式是使用参数化类型，因为混型就是继承自其类型参数的类。在 C++ 中，可以很容易地创建混型，因为 C++ 能够记住其模版参数的类型。<br>下面是一个 C++ 示例，它有两个混型类型：一个使得我们可以在每个对象中混入拥有一个时间戳这样的属性，而另一个可以混入一个序列号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Mixins.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">TimeStamped</span> :</span> <span class="keyword">public</span> T &#123;</span><br><span class="line">    <span class="keyword">long</span> timeStamp;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TimeStamped() &#123; timeStamp = time(<span class="number">0</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getStamp</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> timeStamp; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">SerialNumbered</span> :</span> <span class="keyword">public</span> T &#123;</span><br><span class="line">    <span class="keyword">long</span> serialNumber;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> counter;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SerialNumbered() &#123; serialNumber = counter++; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getSerialNumber</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> serialNumber; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define and initialize the static storage:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">long</span> <span class="title">SerialNumbered</span>&lt;T&gt;:</span>:counter = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Basic</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="built_in">string</span> val)</span> </span>&#123; value = val; &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TimeStamped&lt;SerialNumbered&lt;Basic&gt;&gt; mixin1, mixin2;</span><br><span class="line">    mixin1.<span class="built_in">set</span>(<span class="string">"test string 1"</span>);</span><br><span class="line">    mixin2.<span class="built_in">set</span>(<span class="string">"test string 2"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mixin1.get() &lt;&lt; <span class="string">" "</span> &lt;&lt; mixin1.getStamp() &lt;&lt;</span><br><span class="line">      <span class="string">" "</span> &lt;&lt; mixin1.getSerialNumber() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mixin2.get() &lt;&lt; <span class="string">" "</span> &lt;&lt; mixin2.getStamp() &lt;&lt;</span><br><span class="line">      <span class="string">" "</span> &lt;&lt; mixin2.getSerialNumber() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">test string 1 1452987605 1</span></span><br><span class="line"><span class="comment">test string 2 1452987605 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在 <code>main()</code> 中， <strong>mixin1</strong> 和 <strong>mixin2</strong> 所产生的类型拥有所混入类型的所有方法。可以将混型看作是一种功能，它可以将现有类映射到新的子类上。注意，使用这种技术来创建一个混型是多么的轻而易举。基本上，只需要声明“这就是我想要的”，紧跟着它就发生了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TimeStamped&lt;SerialNumbered&lt;Basic&gt;&gt; mixin1，mixin2；</span><br></pre></td></tr></table></figure><p>遗憾的是，Java 泛型不允许这样。擦除会忘记基类类型，因此</p><blockquote><p> 泛型类不能直接继承自一个泛型参数</p></blockquote><p>这突显了许多我在 Java 语言设计决策（以及与这些功能一起发布）中遇到的一大问题：处理一件事很有希望，但是当您实际尝试做一些有趣的事情时，您会发现自己做不到。</p><h3 id="与接口混合"><a href="#与接口混合" class="headerlink" title="与接口混合"></a>与接口混合</h3><p>一种更常见的推荐解决方案是使用接口来产生混型效果，就像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Mixins.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TimeStamped</span> </span>&#123; <span class="function"><span class="keyword">long</span> <span class="title">getStamp</span><span class="params">()</span></span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeStampedImp</span> <span class="keyword">implements</span> <span class="title">TimeStamped</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timeStamp;</span><br><span class="line">    TimeStampedImp() &#123;</span><br><span class="line">        timeStamp = <span class="keyword">new</span> Date().getTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getStamp</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> timeStamp; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SerialNumbered</span> </span>&#123; <span class="function"><span class="keyword">long</span> <span class="title">getSerialNumber</span><span class="params">()</span></span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerialNumberedImp</span> <span class="keyword">implements</span> <span class="title">SerialNumbered</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> serialNumber = counter++;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSerialNumber</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> serialNumber; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Basic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(String val)</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicImp</span> <span class="keyword">implements</span> <span class="title">Basic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String val)</span> </span>&#123; value = val; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mixin</span> <span class="keyword">extends</span> <span class="title">BasicImp</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">TimeStamped</span>, <span class="title">SerialNumbered</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TimeStamped timeStamp = <span class="keyword">new</span> TimeStampedImp();</span><br><span class="line">    <span class="keyword">private</span> SerialNumbered serialNumber =</span><br><span class="line">        <span class="keyword">new</span> SerialNumberedImp();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getStamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timeStamp.getStamp();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSerialNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serialNumber.getSerialNumber();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mixins</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mixin mixin1 = <span class="keyword">new</span> Mixin(), mixin2 = <span class="keyword">new</span> Mixin();</span><br><span class="line">        mixin1.set(<span class="string">"test string 1"</span>);</span><br><span class="line">        mixin2.set(<span class="string">"test string 2"</span>);</span><br><span class="line">        System.out.println(mixin1.get() + <span class="string">" "</span> +</span><br><span class="line">            mixin1.getStamp() +  <span class="string">" "</span> + mixin1.getSerialNumber());</span><br><span class="line">        System.out.println(mixin2.get() + <span class="string">" "</span> +</span><br><span class="line">            mixin2.getStamp() +  <span class="string">" "</span> + mixin2.getSerialNumber());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">test string 1 1494331663026 1</span></span><br><span class="line"><span class="comment">test string 2 1494331663027 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>Mixin</strong> 类基本上是在使用<em>委托</em>，因此每个混入类型都要求在 <strong>Mixin</strong> 中有一个相应的域，而我们必须在 <strong>Mixin</strong> 中编写所有必需的方法，将方法调用转发给恰当的对象。这个示例使用了非常简单的类，但是当使用更复杂的混型时，代码数量会急速增加。</p><h3 id="使用装饰器模式"><a href="#使用装饰器模式" class="headerlink" title="使用装饰器模式"></a>使用装饰器模式</h3><p>当我们观察混型的使用方式时，就会发现混型概念好像与<em>装饰器</em>设计模式关系很近。装饰器经常用于满足各种可能的组合，而直接子类化会产生过多的类，因此是不实际的。<br>装饰器模式使用分层对象来动态透明地向单个对象中添加责任。装饰器指定包装在最初的对象周围的所有对象都具有相同的基本接口。某些事物是可装饰的，可以通过将其他类包装在这个可装饰对象的四周，来将功能分层。这使得对装饰器的使用是透明的——无论对象是否被装饰，我们都拥有一个可以向对象发送的公共消息集。装饰类也可以添加新方法，但是正如我们所见，这将是受限的。<br>装饰器是通过使用组合和形式化结构（可装饰物/装饰器层次结构）来实现的，而混型是基于继承的。因此可以将基于参数化类型的混型当作是一种泛型装饰器机制，这种机制不需要装饰器设计模式的继承结构。<br>前面的示例可以被改写为使用装饰器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/decorator/Decoration.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;java generics.decorator.Decoration&#125;</span></span><br><span class="line"><span class="keyword">package</span> generics.decorator;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Basic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String val)</span> </span>&#123; value = val; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">Basic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Basic basic;</span><br><span class="line">    Decorator(Basic basic) &#123; <span class="keyword">this</span>.basic = basic; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String val)</span> </span>&#123; basic.set(val); &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> basic.get(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeStamped</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timeStamp;</span><br><span class="line">    TimeStamped(Basic basic) &#123;</span><br><span class="line">        <span class="keyword">super</span>(basic);</span><br><span class="line">        timeStamp = <span class="keyword">new</span> Date().getTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getStamp</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> timeStamp; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerialNumbered</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> serialNumber = counter++;</span><br><span class="line">    SerialNumbered(Basic basic) &#123; <span class="keyword">super</span>(basic); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSerialNumber</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> serialNumber; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decoration</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TimeStamped t = <span class="keyword">new</span> TimeStamped(<span class="keyword">new</span> Basic());</span><br><span class="line">        TimeStamped t2 = <span class="keyword">new</span> TimeStamped(</span><br><span class="line">            <span class="keyword">new</span> SerialNumbered(<span class="keyword">new</span> Basic()));</span><br><span class="line">        <span class="comment">//- t2.getSerialNumber(); // Not available</span></span><br><span class="line">        SerialNumbered s = <span class="keyword">new</span> SerialNumbered(<span class="keyword">new</span> Basic());</span><br><span class="line">        SerialNumbered s2 = <span class="keyword">new</span> SerialNumbered(</span><br><span class="line">            <span class="keyword">new</span> TimeStamped(<span class="keyword">new</span> Basic()));</span><br><span class="line">        <span class="comment">//- s2.getStamp(); // Not available</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>产生自泛型的类包含所有感兴趣的方法，但是由使用装饰器所产生的对象类型是最后被装饰的类型。也就是说，尽管可以添加多个层，但是最后一层才是实际的类型，因此只有最后一层的方法是可视的，而混型的类型是所有被混合到一起的类型。因此对于装饰器来说，其明显的缺陷是它只能有效地工作于装饰中的一层（最后一层），而混型方法显然会更自然一些。因此，装饰器只是对由混型提出的问题的一种局限的解决方案。</p><h3 id="与动态代理混合"><a href="#与动态代理混合" class="headerlink" title="与动态代理混合"></a>与动态代理混合</h3><p>可以使用动态代理来创建一种比装饰器更贴近混型模型的机制（查看 <a href="book/19-Type-Information.md">类型信息</a> 一章中关于 Java 的动态代理如何工作的解释）。通过使用动态代理，所产生的类的动态类型将会是已经混入的组合类型。<br>由于动态代理的限制，每个被混入的类都必须是某个接口的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/DynamicProxyMixin.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> onjava.Tuple.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MixinProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; delegatesByMethod;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    MixinProxy(Tuple2&lt;Object, Class&lt;?&gt;&gt;... pairs) &#123;</span><br><span class="line">        delegatesByMethod = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Tuple2&lt;Object, Class&lt;?&gt;&gt; pair : pairs) &#123;</span><br><span class="line">            <span class="keyword">for</span>(Method method : pair.a2.getMethods()) &#123;</span><br><span class="line">                String methodName = method.getName();</span><br><span class="line">                <span class="comment">// The first interface in the map</span></span><br><span class="line">                <span class="comment">// implements the method.</span></span><br><span class="line">                <span class="keyword">if</span>(!delegatesByMethod.containsKey(methodName))</span><br><span class="line">                    delegatesByMethod.put(methodName, pair.a1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method,</span></span></span><br><span class="line"><span class="function"><span class="params">      Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        String methodName = method.getName();</span><br><span class="line">        Object delegate = delegatesByMethod.get(methodName);</span><br><span class="line">        <span class="keyword">return</span> method.invoke(delegate, args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newInstance</span><span class="params">(Tuple2... pairs)</span> </span>&#123;</span><br><span class="line">        Class[] interfaces = <span class="keyword">new</span> Class[pairs.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pairs.length; i++) &#123;</span><br><span class="line">            interfaces[i] = (Class)pairs[i].a2;</span><br><span class="line">        &#125;</span><br><span class="line">        ClassLoader cl = pairs[<span class="number">0</span>].a1.getClass().getClassLoader();</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(cl, interfaces, <span class="keyword">new</span> MixinProxy(pairs));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyMixin</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object mixin = MixinProxy.newInstance(</span><br><span class="line">          tuple(<span class="keyword">new</span> BasicImp(), Basic.class),</span><br><span class="line">          tuple(<span class="keyword">new</span> TimeStampedImp(), TimeStamped.class),</span><br><span class="line">          tuple(<span class="keyword">new</span> SerialNumberedImp(), SerialNumbered.class));</span><br><span class="line">        Basic b = (Basic)mixin;</span><br><span class="line">        TimeStamped t = (TimeStamped)mixin;</span><br><span class="line">        SerialNumbered s = (SerialNumbered)mixin;</span><br><span class="line">        b.set(<span class="string">"Hello"</span>);</span><br><span class="line">        System.out.println(b.get());</span><br><span class="line">        System.out.println(t.getStamp());</span><br><span class="line">        System.out.println(s.getSerialNumber());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Hello</span></span><br><span class="line"><span class="comment">1494331653339</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>因为只有动态类型而不是静态类型才包含所有的混入类型，因此这仍旧不如 C++ 的方式好，因为可以在具有这些类型的对象上调用方法之前，我们被强制要求必须先将这些对象向下转型到恰当的类型。但是，它明显地更接近于真正的混型。<br>为了让 Java 支持混型，人们已经做了大量的工作朝着这个目标努力，包括创建了至少一种附加语言（ Jam 语言），它是专门用来支持混型的。</p><!-- Latent Typing --><h2 id="潜在类型机制"><a href="#潜在类型机制" class="headerlink" title="潜在类型机制"></a>潜在类型机制</h2><p>在本章的开头介绍过这样的思想，即要编写能够尽可能广泛地应用的代码。为了实现这一点，我们需要各种途径来放松对我们的代码将要作用的类型所作的限制，同时不丢失静态类型检查的好处。然后，我们就可以编写出无需修改就可以应用于更多情况的代码，即更加“泛化”的代码。</p><p>Java 泛型看起来是向这一方向迈进了一步。当我们在编写或使用只是持有对象的泛型时，这些代码将可以工作于任何类型（除了基本类型，尽管正如我们所见到的，自动装箱机制可以克服这一点）。或者，换个角度讲，“持有器”泛型能够声明：“我不关心我们是什么类型”。如果代码不关心它将要作用的类型，那么这种代码就可以真正地应用于任何地方，并因此而相当泛化。</p><p>还是正如我们所见到的，当要在泛型类型上执行操作（即调用 <strong>Object</strong> 方法之外的方法）时，就会产生问题。擦除强制要求指定可能会用到的泛型类型的边界，以安全地调用代码中的泛型对象上的具体方法。这是对“泛化”概念的一种明显的限制，因为必须限制我们的泛型类型，使它们继承自特定的类，或者实现特定的接口。在某些情况下，我们最终可能会使用普通类或普通接口，因为限定边界的泛型可能会和指定类或接口没有任何区别。</p><p>某些编程语言提供的一种解决方案称为<em>潜在类型机制</em>或<em>结构化类型机制</em>，而更古怪的术语称为<em>鸭子类型机制</em>，即“如果它走起来像鸭子，并且叫起来也像鸭子，那么我们就可以将它当作鸭子对待。”鸭子类型机制变成了一种相当流行的术语，可能是因为它不像其他的术语那样承载着历史的包袱。</p><p>泛型代码典型地只能在泛型类型上调用少量方法，而具有潜在类型机制的语言只要求实现某个方法子集，而不是某个特定类或接口，从而放松了这种限制（并且可以产生更加泛化的代码）。正由于此，潜在类型机制使得我们可以横跨类继承结构，调用不属于某个公共接口的方法。因此，实际上一段代码可以声明：“我不关心我们是什么类型，只要我们可以 <code>speak()</code> 和 <code>sit()</code> 即可。”由于不要求具体类型，因此代码就可以更加泛化。</p><p>潜在类型机制是一种代码组织和复用机制。有了它，编写出的代码相对于没有它编写出的代码，能够更容易地复用。代码组织和复用是所有计算机编程的基本手段：编写一次，多次使用，并在一个位置保存代码。因为我并未被要求去命名我的代码要操作于其上的确切接口，所以，有了潜在类型机制，我就可以编写更少的代码，并更容易地将其应用于多个地方。</p><p>支持潜在类型机制的语言包括 Python（可以从 <a href="http://www.Python.org" target="_blank" rel="noopener">www.Python.org</a> 免费下载）、C++、Ruby、SmallTalk 和 Go。Python 是动态类型语言（几乎所有的类型检查都发生在运行时），而 C++ 和 Go 是静态类型语言（类型检查发生在编译期），因此潜在类型机制不要求静态或动态类型检查。</p><h3 id="pyhton-中的潜在类型"><a href="#pyhton-中的潜在类型" class="headerlink" title="pyhton 中的潜在类型"></a>pyhton 中的潜在类型</h3><p>如果我们将上面的描述用 Python 来表示，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># generics/DogsAndRobots.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Arf!"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sit</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Sitting"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reproduce</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Robot</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Click!"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sit</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Clank!"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">oilChange</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">perform</span><span class="params">(anything)</span>:</span></span><br><span class="line">    anything.speak()</span><br><span class="line">    anything.sit()</span><br><span class="line"></span><br><span class="line">a = Dog()</span><br><span class="line">b = Robot()</span><br><span class="line">perform(a)</span><br><span class="line">perform(b)</span><br><span class="line"></span><br><span class="line">output = <span class="string">"""</span></span><br><span class="line"><span class="string">Arf!</span></span><br><span class="line"><span class="string">Sitting</span></span><br><span class="line"><span class="string">Click!</span></span><br><span class="line"><span class="string">Clank!</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>Python 使用缩进来确定作用域（因此不需要任何花括号），而冒号将表示新的作用域的开始。“<strong>#</strong>” 表示注释到行尾，就像Java中的 “ <strong>//</strong> ”。类的方法需要显式地指定 <strong>this</strong> 引用的等价物作为第一个参数，按惯例成为 <strong>self</strong> 。构造器调用不要求任何类型的“ <strong>new</strong> ”关键字，并且 Python 允许普通（非成员）函数，就像 <code>perform()</code> 所表明的那样。注意，在 <code>perform(anything)</code> 中，没有任何针对 <strong>anything</strong> 的类型，<strong>anything</strong> 只是一个标识符，它必须能够执行 <code>perform()</code> 期望它执行的操作，因此这里隐含着一个接口。但是我们从来都不必显式地写出这个接口——它是潜在的。<code>perform()</code> 不关心其参数的类型，因此我可以向它传递任何对象，只要该对象支持  <code>speak()</code> 和 <code>sit()</code> 方法。如果传递给 <code>perform()</code> 的对象不支持这些操作，那么将会得到运行时异常。</p><p>输出规定使用三重引号创建带有内嵌换行符的字符串。</p><h3 id="C-中的潜在类型"><a href="#C-中的潜在类型" class="headerlink" title="C++ 中的潜在类型"></a>C++ 中的潜在类型</h3><p>我们可以用 C++ 产生相同的效果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/DogsAndRobots.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Arf!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sitting"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reproduce</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Robot</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Click!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Clank!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">oilChange</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">perform</span>(<span class="title">T</span> <span class="title">anything</span>) &#123;</span></span><br><span class="line">    anything.speak();</span><br><span class="line">    anything.sit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Dog d;</span><br><span class="line">    Robot r;</span><br><span class="line">    perform(d);</span><br><span class="line">    perform(r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Arf!</span></span><br><span class="line"><span class="comment">Sitting</span></span><br><span class="line"><span class="comment">Click!</span></span><br><span class="line"><span class="comment">Clank!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在 Python 和 C++ 中，<strong>Dog</strong> 和 <strong>Robot</strong> 没有任何共同的东西，只是碰巧有两个方法具有相同的签名。从类型的观点看，它们是完全不同的类型。但是，<code>perform()</code> 不关心其参数的具体类型，并且潜在类型机制允许它接受这两种类型的对象。<br>C++ 确保了它实际上可以发送的那些消息，如果试图传递错误类型，编译器就会给我们一个错误消息（这些错误消息从历史上看是相当可怕和冗长的，是 C++ 的模版名声欠佳的主要原因）。尽管它们是在不同时期实现这一点的，C++ 在编译期，而 Python 在运行时，但是这两种语言都可以确保类型不会被误用，因此被认为是强类型的。潜在类型机制没有损害强类型机制。</p><h3 id="Go-中的潜在类型"><a href="#Go-中的潜在类型" class="headerlink" title="Go 中的潜在类型"></a>Go 中的潜在类型</h3><p>这里用 Go 语言编写相同的程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/dogsandrobots.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this Dog)</span> <span class="title">speak</span><span class="params">()</span></span> &#123; fmt.Printf(<span class="string">"Arf!\n"</span>)&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this Dog)</span> <span class="title">sit</span><span class="params">()</span></span> &#123; fmt.Printf(<span class="string">"Sitting\n"</span>)&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this Dog)</span> <span class="title">reproduce</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Robot <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this Robot)</span> <span class="title">speak</span><span class="params">()</span></span> &#123; fmt.Printf(<span class="string">"Click!\n"</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this Robot)</span> <span class="title">sit</span><span class="params">()</span></span> &#123; fmt.Printf(<span class="string">"Clank!\n"</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this Robot)</span> <span class="title">oilChange</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">perform</span><span class="params">(speaker <span class="keyword">interface</span> &#123; speak()</span>; <span class="title">sit</span><span class="params">()</span> &#125;)</span> &#123;</span><br><span class="line">  speaker.speak();</span><br><span class="line">  speaker.sit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  perform(Dog&#123;&#125;)</span><br><span class="line">  perform(Robot&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Arf!</span></span><br><span class="line"><span class="comment">Sitting</span></span><br><span class="line"><span class="comment">Click!</span></span><br><span class="line"><span class="comment">Clank!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>Go 没有 <strong>class</strong> 关键字，但是可以使用上述形式创建等效的基本类：它通常不定义为类，而是定义为 <strong>struct</strong> ，在其中定义数据字段（此处不存在）。 对于每种方法，都以 <strong>func</strong> 关键字开头，然后（为了将该方法附加到您的类上）放在括号中，该括号包含对象引用，该对象引用可以是任何标识符，但是我在这里使用 <strong>this</strong> 来提醒您，就像在 C ++ 或 Java 中的 <strong>this</strong> 一样。 然后，在Go中像这样定义其余的函数。</p><p>Go也没有继承关系，因此这种“面向对象的目标”形式是相对原始的，并且可能是我无法花更多的时间来学习该语言的主要原因。 但是，Go 的组成很简单。</p><p><code>perform()</code> 函数使用潜在类型：参数的确切类型并不重要，只要它包含了 <code>speak()</code> 和  <code>sit()</code> 方法即可。 该接口在此处匿名定义，内联，如 <code>perform()</code> 的参数列表所示。</p><p><code>main()</code> 证明 <code>perform()</code> 确实对其参数的确切类型不在乎，只要可以在该参数上调用 <code>talk()</code> 和 <code>sit()</code> 即可。 但是，就像 C ++ 模板函数一样，在编译时检查类型。</p><p>语法 <strong>Dog {}</strong> 和 <strong>Robot {}</strong> 创建匿名的 <strong>Dog</strong> 和 <strong>Robot</strong> 结构。</p><h3 id="java中的直接潜在类型"><a href="#java中的直接潜在类型" class="headerlink" title="java中的直接潜在类型"></a>java中的直接潜在类型</h3><p>因为泛型是在这场竞赛的后期才添加到 Java 中，因此没有任何机会可以去实现任何类型的潜在类型机制，因此 Java 没有对这种特性的支持。所以，初看起来，Java 的泛型机制比支持潜在类型机制的语言更“缺乏泛化性”。（使用擦除来实现 Java 泛型的实现有时称为第二类泛型类型）例如，在 Java 8  之前如果我们试图用 Java 实现上面 dogs-and-robots 的示例，那么就会被强制要求使用一个类或接口，并在边界表达式中指定它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Performs.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Performs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/DogsAndRobots.java</span></span><br><span class="line"><span class="comment">// No (direct) latent typing in Java</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PerformingDog</span> <span class="keyword">extends</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Performs</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Woof!"</span>); &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Sitting"</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reproduce</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Robot</span> <span class="keyword">implements</span> <span class="title">Performs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Click!"</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Clank!"</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oilChange</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Communicate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Performs&gt;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">perform</span><span class="params">(T performer)</span> </span>&#123;</span><br><span class="line">        performer.speak();</span><br><span class="line">        performer.sit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DogsAndRobots</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Communicate.perform(<span class="keyword">new</span> PerformingDog());</span><br><span class="line">        Communicate.perform(<span class="keyword">new</span> Robot());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Woof!</span></span><br><span class="line"><span class="comment">Sitting</span></span><br><span class="line"><span class="comment">Click!</span></span><br><span class="line"><span class="comment">Clank!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>但是要注意，<code>perform()</code> 不需要使用泛型来工作，它可以被简单地指定为接受一个 <strong>Performs</strong> 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/SimpleDogsAndRobots.java</span></span><br><span class="line"><span class="comment">// Removing the generic; code still works</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommunicateSimply</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perform</span><span class="params">(Performs performer)</span> </span>&#123;</span><br><span class="line">        performer.speak();</span><br><span class="line">        performer.sit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDogsAndRobots</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CommunicateSimply.perform(<span class="keyword">new</span> PerformingDog());</span><br><span class="line">        CommunicateSimply.perform(<span class="keyword">new</span> Robot());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Woof!</span></span><br><span class="line"><span class="comment">Sitting</span></span><br><span class="line"><span class="comment">Click!</span></span><br><span class="line"><span class="comment">Clank!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在本例中，泛型不是必需的，因为这些类已经被强制要求实现 <strong>Performs</strong> 接口。</p><!-- Compensating for the Lack of (Direct) Latent --><h2 id="对缺乏潜在类型机制的补偿"><a href="#对缺乏潜在类型机制的补偿" class="headerlink" title="对缺乏潜在类型机制的补偿"></a>对缺乏潜在类型机制的补偿</h2><p>尽管 Java 不直接支持潜在类型机制，但是这并不意味着泛型代码不能在不同的类型层次结构之间应用。也就是说，我们仍旧可以创建真正的泛型代码，但是这需要付出一些额外的努力。</p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>可以使用的一种方式是反射，下面的 <code>perform()</code> 方法就是用了潜在类型机制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/LatentReflection.java</span></span><br><span class="line"><span class="comment">// Using reflection for latent typing</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Does not implement Performs:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mime</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walkAgainstTheWind</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Pretending to sit"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushInvisibleWalls</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Mime"</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Does not implement Performs:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartDog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Woof!"</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Sitting"</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reproduce</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommunicateReflectively</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perform</span><span class="params">(Object speaker)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; spkr = speaker.getClass();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Method speak = spkr.getMethod(<span class="string">"speak"</span>);</span><br><span class="line">                speak.invoke(speaker);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(NoSuchMethodException e) &#123;</span><br><span class="line">                System.out.println(speaker + <span class="string">" cannot speak"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Method sit = spkr.getMethod(<span class="string">"sit"</span>);</span><br><span class="line">                sit.invoke(speaker);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(NoSuchMethodException e) &#123;</span><br><span class="line">                System.out.println(speaker + <span class="string">" cannot sit"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(SecurityException |</span><br><span class="line">            IllegalAccessException |</span><br><span class="line">            IllegalArgumentException |</span><br><span class="line">            InvocationTargetException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(speaker.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LatentReflection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CommunicateReflectively.perform(<span class="keyword">new</span> SmartDog());</span><br><span class="line">        CommunicateReflectively.perform(<span class="keyword">new</span> Robot());</span><br><span class="line">        CommunicateReflectively.perform(<span class="keyword">new</span> Mime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Woof!</span></span><br><span class="line"><span class="comment">Sitting</span></span><br><span class="line"><span class="comment">Click!</span></span><br><span class="line"><span class="comment">Clank!</span></span><br><span class="line"><span class="comment">Mime cannot speak</span></span><br><span class="line"><span class="comment">Pretending to sit</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>上例中，这些类完全是彼此分离的，没有任何公共基类（除了 <strong>Object</strong> ）或接口。通过反射, <code>CommunicateReflectively.perform()</code> 能够动态地确定所需要的方法是否可用并调用它们。它甚至能够处理 <strong>Mime</strong> 只具有一个必需的方法这一事实，并能够部分实现其目标。</p><h3 id="将一个方法应用于序列"><a href="#将一个方法应用于序列" class="headerlink" title="将一个方法应用于序列"></a>将一个方法应用于序列</h3><p>反射提供了一些有用的可能性，但是它将所有的类型检查都转移到了运行时，因此在许多情况下并不是我们所希望的。如果能够实现编译期类型检查，这通常会更符合要求。但是有可能实现编译期类型检查和潜在类型机制吗？</p><p>让我们看一个说明这个问题的示例。假设想要创建一个 <code>apply()</code> 方法，它能够将任何方法应用于某个序列中的所有对象。这种情况下使用接口不适合，因为我们想要将任何方法应用于一个对象集合，而接口不可能描述任何方法。如何用 Java 来实现这个需求呢？</p><p>最初，我们可以用反射来解决这个问题，由于有了 Java 的可变参数，这种方式被证明是相当优雅的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Apply.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apply</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, S extends Iterable&lt;T&gt;&gt;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(S seq, Method f, Object... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(T t: seq)</span><br><span class="line">                f.invoke(t, args);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IllegalAccessException |</span><br><span class="line">            IllegalArgumentException |</span><br><span class="line">            InvocationTargetException e) &#123;</span><br><span class="line">            <span class="comment">// Failures are programmer errors</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <strong>Apply.java</strong> 中，异常被转换为 <strong>RuntimeException</strong> ，因为没有多少办法可以从这种异常中恢复——在这种情况下，它们实际上代表着程序员的错误。</p><p>为什么我们不只使用 Java 8 方法参考（稍后显示）而不是反射方法 <strong>f</strong> ？ 注意，<code>invoke()</code> 和 <code>apply()</code> 的优点是它们可以接受任意数量的参数。 在某些情况下，灵活性可能至关重要。</p><p>为了测试 <strong>Apply</strong> ，我们首先创建一个 <strong>Shape</strong> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Shape.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getSimpleName() + <span class="string">" "</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span> + <span class="string">" rotate"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newSize)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span> + <span class="string">" resize "</span> + newSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被一个子类 <strong>Square</strong> 继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Square.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>通过这些，我们可以测试 <strong>Apply</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ApplyTest.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplyTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;Shape&gt; shapes =</span><br><span class="line">          Suppliers.create(ArrayList::<span class="keyword">new</span>, Shape::<span class="keyword">new</span>, <span class="number">3</span>);</span><br><span class="line">        Apply.apply(shapes, Shape.class.getMethod(<span class="string">"rotate"</span>));</span><br><span class="line">        Apply.apply(shapes, Shape.class.getMethod(<span class="string">"resize"</span>, <span class="keyword">int</span>.class), <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Square&gt; squares =</span><br><span class="line">          Suppliers.create(ArrayList::<span class="keyword">new</span>, Square::<span class="keyword">new</span>, <span class="number">3</span>);</span><br><span class="line">        Apply.apply(squares, Shape.class.getMethod(<span class="string">"rotate"</span>));</span><br><span class="line">        Apply.apply(squares, Shape.class.getMethod(<span class="string">"resize"</span>, <span class="keyword">int</span>.class), <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        Apply.apply(<span class="keyword">new</span> FilledList&lt;&gt;(Shape::<span class="keyword">new</span>, <span class="number">3</span>),</span><br><span class="line">          Shape.class.getMethod(<span class="string">"rotate"</span>));</span><br><span class="line">        Apply.apply(<span class="keyword">new</span> FilledList&lt;&gt;(Square::<span class="keyword">new</span>, <span class="number">3</span>),</span><br><span class="line">          Shape.class.getMethod(<span class="string">"rotate"</span>));</span><br><span class="line"></span><br><span class="line">        SimpleQueue&lt;Shape&gt; shapeQ = Suppliers.fill(</span><br><span class="line">          <span class="keyword">new</span> SimpleQueue&lt;&gt;(), SimpleQueue::add,</span><br><span class="line">          Shape::<span class="keyword">new</span>, <span class="number">3</span>);</span><br><span class="line">        Suppliers.fill(shapeQ, SimpleQueue::add,</span><br><span class="line">          Square::<span class="keyword">new</span>, <span class="number">3</span>);</span><br><span class="line">        Apply.apply(shapeQ, Shape.class.getMethod(<span class="string">"rotate"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Shape 0 rotate</span></span><br><span class="line"><span class="comment">Shape 1 rotate</span></span><br><span class="line"><span class="comment">Shape 2 rotate</span></span><br><span class="line"><span class="comment">Shape 0 resize 7</span></span><br><span class="line"><span class="comment">Shape 1 resize 7</span></span><br><span class="line"><span class="comment">Shape 2 resize 7</span></span><br><span class="line"><span class="comment">Square 3 rotate</span></span><br><span class="line"><span class="comment">Square 4 rotate</span></span><br><span class="line"><span class="comment">Square 5 rotate</span></span><br><span class="line"><span class="comment">Square 3 resize 7</span></span><br><span class="line"><span class="comment">Square 4 resize 7</span></span><br><span class="line"><span class="comment">Square 5 resize 7</span></span><br><span class="line"><span class="comment">Shape 6 rotate</span></span><br><span class="line"><span class="comment">Shape 7 rotate</span></span><br><span class="line"><span class="comment">Shape 8 rotate</span></span><br><span class="line"><span class="comment">Square 9 rotate</span></span><br><span class="line"><span class="comment">Square 10 rotate</span></span><br><span class="line"><span class="comment">Square 11 rotate</span></span><br><span class="line"><span class="comment">Shape 12 rotate</span></span><br><span class="line"><span class="comment">Shape 13 rotate</span></span><br><span class="line"><span class="comment">Shape 14 rotate</span></span><br><span class="line"><span class="comment">Square 15 rotate</span></span><br><span class="line"><span class="comment">Square 16 rotate</span></span><br><span class="line"><span class="comment">Square 17 rotate</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在 <strong>Apply</strong> 中，我们运气很好，因为碰巧在 Java 中内建了一个由 Java 集合类库使用的 <strong>Iterable</strong> 接口。正由于此， <code>apply()</code> 方法可以接受任何实现了 <strong>Iterable</strong> 接口的事物，包括诸如 <strong>List</strong> 这样的所有 <strong>Collection</strong> 类。但是它还可以接受其他任何事物，只要能够使这些事物是 <strong>Iterable</strong> 的——例如，在 <code>main()</code> 中使用下面定义的 <strong>SimpleQueue</strong> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/SimpleQueue.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A different kind of Iterable collection</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleQueue</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;T&gt; storage = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span> </span>&#123; storage.offer(t); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> storage.poll(); &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> storage.iterator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如反射解决方案看起来那样优雅，我们必须观察到反射（尽管在 Java 的最新版本中得到了显着改进）通常比非反射实现要慢，因为在运行时发生了很多事情。 但它不应阻止您尝试这种解决方案，这依然是值得考虑的一点。</p><p>几乎可以肯定，我们会首先使用 Java 8 的函数式方法，并且只有在解决了特殊需求时才诉诸反射。 这里对 <strong>ApplyTest.java</strong> 进行了重写，以利用 Java 8 的流和函数工具：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/ApplyFunctional.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplyFunctional</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream.of(</span><br><span class="line">          Stream.generate(Shape::<span class="keyword">new</span>).limit(<span class="number">2</span>),</span><br><span class="line">          Stream.generate(Square::<span class="keyword">new</span>).limit(<span class="number">2</span>))</span><br><span class="line">        .flatMap(c -&gt; c) <span class="comment">// flatten into one stream</span></span><br><span class="line">        .peek(Shape::rotate)</span><br><span class="line">        .forEach(s -&gt; s.resize(<span class="number">7</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> FilledList&lt;&gt;(Shape::<span class="keyword">new</span>, <span class="number">2</span>)</span><br><span class="line">          .forEach(Shape::rotate);</span><br><span class="line">        <span class="keyword">new</span> FilledList&lt;&gt;(Square::<span class="keyword">new</span>, <span class="number">2</span>)</span><br><span class="line">          .forEach(Shape::rotate);</span><br><span class="line"></span><br><span class="line">        SimpleQueue&lt;Shape&gt; shapeQ = Suppliers.fill(</span><br><span class="line">          <span class="keyword">new</span> SimpleQueue&lt;&gt;(), SimpleQueue::add,</span><br><span class="line">          Shape::<span class="keyword">new</span>, <span class="number">2</span>);</span><br><span class="line">        Suppliers.fill(shapeQ, SimpleQueue::add,</span><br><span class="line">          Square::<span class="keyword">new</span>, <span class="number">2</span>);</span><br><span class="line">        shapeQ.forEach(Shape::rotate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Shape 0 rotate</span></span><br><span class="line"><span class="comment">Shape 0 resize 7</span></span><br><span class="line"><span class="comment">Shape 1 rotate</span></span><br><span class="line"><span class="comment">Shape 1 resize 7</span></span><br><span class="line"><span class="comment">Square 2 rotate</span></span><br><span class="line"><span class="comment">Square 2 resize 7</span></span><br><span class="line"><span class="comment">Square 3 rotate</span></span><br><span class="line"><span class="comment">Square 3 resize 7</span></span><br><span class="line"><span class="comment">Shape 4 rotate</span></span><br><span class="line"><span class="comment">Shape 5 rotate</span></span><br><span class="line"><span class="comment">Square 6 rotate</span></span><br><span class="line"><span class="comment">Square 7 rotate</span></span><br><span class="line"><span class="comment">Shape 8 rotate</span></span><br><span class="line"><span class="comment">Shape 9 rotate</span></span><br><span class="line"><span class="comment">Square 10 rotate</span></span><br><span class="line"><span class="comment">Square 11 rotate</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>由于使用 Java 8，因此不需要 <code>Apply.apply()</code> 。</p><p>我们首先生成两个 <strong>Stream</strong> ： 一个是 <strong>Shape</strong> ，一个是 <strong>Square</strong> ，并将它们展平为单个流。 尽管 Java 缺少功能语言中经常出现的 <code>flatten()</code> ，但是我们可以使用 <code>flatMap(c-&gt; c)</code> 产生相同的结果，后者使用身份映射将操作简化为“  <strong>flatten</strong> ”。</p><p>我们使用 <code>peek()</code> 当做对 <code>rotate()</code> 的调用，因为 <code>peek()</code> 执行一个操作（此处是出于副作用），并在未更改的情况下传递对象。</p><p>注意，使用 <strong>FilledList</strong> 和 <strong>shapeQ</strong> 调用 <code>forEach()</code> 比 <code>Apply.apply()</code> 代码整洁得多。 在代码简单性和可读性方面，结果比以前的方法好得多。 并且，现在也不可能从  <code>main()</code> 引发异常。</p><!-- Assisted Latent Typing in Java 8 --><h2 id="Java8-中的辅助潜在类型"><a href="#Java8-中的辅助潜在类型" class="headerlink" title="Java8 中的辅助潜在类型"></a>Java8 中的辅助潜在类型</h2><p>先前声明关于 Java 缺乏对潜在类型的支持在 Java 8 之前是完全正确的。但是，Java 8 中的非绑定方法引用使我们能够产生一种潜在类型的形式，以满足创建一段可工作在不相干类型上的代码。因为 Java 最初并不是如此设计，所以结果可想而知，比其他语言中要尴尬一些。但是，至少现在成为了可能，只是缺乏令人惊艳之处。</p><p>我在其他地方从没遇过这种技术，因此我将其称为辅助潜在类型。</p><p>我们将重写 <strong>DogsAndRobots.java</strong> 来演示该技术。 为使外观看起来与原始示例尽可能相似，我仅向每个原始类名添加了 <strong>A</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/DogsAndRobotMethodReferences.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// "Assisted Latent Typing"</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PerformingDogA</span> <span class="keyword">extends</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Woof!"</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Sitting"</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reproduce</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RobotA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Click!"</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Clank!"</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oilChange</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommunicateA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;P&gt; <span class="function"><span class="keyword">void</span> <span class="title">perform</span><span class="params">(P performer,</span></span></span><br><span class="line"><span class="function"><span class="params">      Consumer&lt;P&gt; action1, Consumer&lt;P&gt; action2)</span> </span>&#123;</span><br><span class="line">        action1.accept(performer);</span><br><span class="line">        action2.accept(performer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DogsAndRobotMethodReferences</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CommunicateA.perform(<span class="keyword">new</span> PerformingDogA(),</span><br><span class="line">          PerformingDogA::speak, PerformingDogA::sit);</span><br><span class="line">        CommunicateA.perform(<span class="keyword">new</span> RobotA(),</span><br><span class="line">          RobotA::speak, RobotA::sit);</span><br><span class="line">        CommunicateA.perform(<span class="keyword">new</span> Mime(),</span><br><span class="line">          Mime::walkAgainstTheWind,</span><br><span class="line">          Mime::pushInvisibleWalls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Woof!</span></span><br><span class="line"><span class="comment">Sitting</span></span><br><span class="line"><span class="comment">Click!</span></span><br><span class="line"><span class="comment">Clank!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>PerformingDogA</strong> 和 <strong>RobotA</strong> 与 <strong>DogsAndRobots.java</strong> 中的相同，不同之处在于它们不继承通用接口 <strong>Performs</strong> ，因此它们没有通用性。</p><p><code>CommunicateA.perform()</code> 在没有约束的 <strong>P</strong> 上生成。 只要可以使用 <code>Consumer &lt;P&gt;</code>，它在这里就可以是任何东西，这些 <code>Consumer&lt;P&gt;</code> 代表不带参数的 <strong>P</strong> 方法的未绑定方法引用。当您调用 <strong>Consumer</strong>  的 <code>accept()</code> 方法时，它将方法引用绑定到执行者对象并调用该方法。 由于 <a href="book/13-Functional-Programming.md">函数式编程</a> 一章中描述的“魔术”，我们可以将任何符合签名的未绑定方法引用传递给 <code>CommunicateA.perform()</code> 。</p><p>之所以称其为“辅助”，是因为您必须显式地为 <code>perform()</code> 提供要使用的方法引用。 它不能只按名称调用方法。</p><p>尽管传递未绑定的方法引用似乎要花很多力气，但潜在类型的最终目标还是可以实现的。 我们创建了一个代码片段 <code>CommunicateA.perform()</code> ，该代码可用于任何具有符合签名的方法引用的类型。 请注意，这与我们看到的其他语言中的潜在类型有所不同，因为这些语言不仅需要签名以符合规范，还需要方法名称。 因此，该技术可以说产生了更多的通用代码。</p><p>为了证明这一点，我还从 <strong>LatentReflection.java</strong> 中引入了 <strong>Mime</strong>。</p><h3 id="使用Suppliers类的通用方法"><a href="#使用Suppliers类的通用方法" class="headerlink" title="使用Suppliers类的通用方法"></a>使用<strong>Suppliers</strong>类的通用方法</h3><p>通过辅助潜在类型，我们可以定义本章其他部分中使用的 <strong>Suppliers</strong> 类。 此类包含使用生成器填充 <strong>Collection</strong> 的工具方法。 泛化这些操作很有意义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/Suppliers.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A utility to use with Suppliers</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Suppliers</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create a collection and fill it:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, C extends Collection&lt;T&gt;&gt; C</span><br><span class="line">      create(Supplier&lt;C&gt; factory, Supplier&lt;T&gt; gen, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">return</span> Stream.generate(gen)</span><br><span class="line">            .limit(n)</span><br><span class="line">            .collect(factory, C::add, C::addAll);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Fill an existing collection:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, C extends Collection&lt;T&gt;&gt;</span><br><span class="line">      <span class="function">C <span class="title">fill</span><span class="params">(C coll, Supplier&lt;T&gt; gen, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Stream.generate(gen)</span><br><span class="line">            .limit(n)</span><br><span class="line">            .forEach(coll::add);</span><br><span class="line">        <span class="keyword">return</span> coll;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Use an unbound method reference to</span></span><br><span class="line">    <span class="comment">// produce a more general method:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;H, A&gt; <span class="function">H <span class="title">fill</span><span class="params">(H holder,</span></span></span><br><span class="line"><span class="function"><span class="params">      BiConsumer&lt;H, A&gt; adder, Supplier&lt;A&gt; gen, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Stream.generate(gen)</span><br><span class="line">            .limit(n)</span><br><span class="line">            .forEach(a -&gt; adder.accept(holder, a));</span><br><span class="line">        <span class="keyword">return</span> holder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>create()</code> 为我们创建一个新的 <strong>Collection</strong> 子类型，而 <code>fill()</code> 的第一个版本将元素放入 <strong>Collection</strong> 的现有子类型中。 请注意，还会返回传入的容器的确切类型，因此不会丢失类型信息。</p><p>前两种方法一般都受约束，只能与 <strong>Collection</strong> 子类型一起使用。<code>fill()</code> 的第二个版本适用于任何类型的 <strong>holder</strong> 。 它需要一个附加参数：未绑定方法引用 <code>adder. fill()</code> ，使用辅助潜在类型来使其与任何具有添加元素方法的 <strong>holder</strong> 类型一起使用。因为此未绑定方法 <strong>adder</strong> 必须带有一个参数（要添加到 <strong>holder</strong> 的元素），所以 <strong>adder</strong> 必须是 <code>BiConsumer &lt;H，A&gt;</code> ，其中 <strong>H</strong> 是要绑定到的 <strong>holder</strong> 对象的类型，而 <strong>A</strong> 是要被添加的绑定元素类型。 对 <code>accept()</code> 的调用将使用参数 a 调用对象 <strong>holder</strong> 上的未绑定方法 <strong>holder</strong>。</p><p>在一个稍作模拟的测试中对 <strong>Suppliers</strong> 工具程序进行了测试，该仿真还使用了本章前面定义的 <strong>RandomList</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/BankTeller.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A very simple bank teller simulation</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Customer "</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teller</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Teller "</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;BankTeller&gt; tellers =</span><br><span class="line">        <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(BankTeller bt)</span> </span>&#123;</span><br><span class="line">        tellers.add(bt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankTeller</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serve</span><span class="params">(Teller t, Customer c)</span> </span>&#123;</span><br><span class="line">        System.out.println(t + <span class="string">" serves "</span> + c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Demonstrate create():</span></span><br><span class="line">        RandomList&lt;Teller&gt; tellers =</span><br><span class="line">            Suppliers.create(</span><br><span class="line">            RandomList::<span class="keyword">new</span>, Teller::<span class="keyword">new</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// Demonstrate fill():</span></span><br><span class="line">        List&lt;Customer&gt; customers = Suppliers.fill(</span><br><span class="line">            <span class="keyword">new</span> ArrayList&lt;&gt;(), Customer::<span class="keyword">new</span>, <span class="number">12</span>);</span><br><span class="line">        customers.forEach(c -&gt;</span><br><span class="line">            serve(tellers.select(), c));</span><br><span class="line">        <span class="comment">// Demonstrate assisted latent typing:</span></span><br><span class="line">        Bank bank = Suppliers.fill(</span><br><span class="line">            <span class="keyword">new</span> Bank(), Bank::put, BankTeller::<span class="keyword">new</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// Can also use second version of fill():</span></span><br><span class="line">        List&lt;Customer&gt; customers2 = Suppliers.fill(</span><br><span class="line">            <span class="keyword">new</span> ArrayList&lt;&gt;(),</span><br><span class="line">            List::add, Customer::<span class="keyword">new</span>, <span class="number">12</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Teller 3 serves Customer 1</span></span><br><span class="line"><span class="comment">Teller 2 serves Customer 2</span></span><br><span class="line"><span class="comment">Teller 3 serves Customer 3</span></span><br><span class="line"><span class="comment">Teller 1 serves Customer 4</span></span><br><span class="line"><span class="comment">Teller 1 serves Customer 5</span></span><br><span class="line"><span class="comment">Teller 3 serves Customer 6</span></span><br><span class="line"><span class="comment">Teller 1 serves Customer 7</span></span><br><span class="line"><span class="comment">Teller 2 serves Customer 8</span></span><br><span class="line"><span class="comment">Teller 3 serves Customer 9</span></span><br><span class="line"><span class="comment">Teller 3 serves Customer 10</span></span><br><span class="line"><span class="comment">Teller 2 serves Customer 11</span></span><br><span class="line"><span class="comment">Teller 4 serves Customer 12</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以看到 <code>create()</code> 生成一个新的 <strong>Collection</strong> 对象，而 <code>fill()</code> 添加到现有 <strong>Collection</strong> 中。第二个版本<code>fill()</code> 显示，它不仅与无关的新类型 <strong>Bank</strong> 一起使用，还能与 <strong>List</strong> 一起使用。因此，从技术上讲，<code>fill()</code> 的第一个版本在技术上不是必需的，但在使用 <strong>Collection</strong> 时提供了较短的语法。</p><!-- Summary: Is Casting Really So Bad? --><h2 id="总结：类型转换真的如此之糟吗？"><a href="#总结：类型转换真的如此之糟吗？" class="headerlink" title="总结：类型转换真的如此之糟吗？"></a>总结：类型转换真的如此之糟吗？</h2><p>自从 C++ 模版出现以来，我就一直在致力于解释它，我可能比大多数人都更早地提出了下面的论点。直到最近，我才停下来，去思考这个论点到底在多少时间内是有效的——我将要描述的问题到底有多少次可以穿越障碍得以解决。</p><p>这个论点就是：使用泛型类型机制的最吸引人的地方，就是在使用集合类的地方，这些类包括诸如各种 <strong>List</strong> 、各种 <strong>Set</strong> 、各种 <strong>Map</strong> 等我们在 <a href="book/12-Collections.md">集合</a> 和 <a href="book/Appendix-Collection-Topics.md">附录：集合主题</a> 这两章所见。在 Java 5 之前，当我们将一个对象放置到集合中时，这个对象就会被向上转型为 <strong>Object</strong> ，因此我们会丢失类型信息。当我们想要将这个对象从集合中取回，用它去执行某些操作时，必须将其向下转型回正确的类型。我用的示例是持有 <strong>Cat</strong> 的 <strong>List</strong> （这个示例的一种使用苹果和桔子的变体在 <a href="book/12-Collections.md">集合</a> 章节的开头展示过）。如果没有 Java 5 泛型版本的集合，我们放到容集里和从集合中取回的都是 <strong>Object</strong> 。因此，我们很可能会将一个 <strong>Dog</strong> 放置到 <strong>Cat</strong> 的 <strong>List</strong> 中。</p><p>但是，泛型出现之前的 Java 并不会让我们误用放入到集合中的对象。如果将一个 <strong>Dog</strong> 扔到 <strong>Cat</strong> 的集合中，并且试图将这个集合中的所有东西都当作 <strong>Cat</strong> 处理，那么当我们从这个 <strong>Cat</strong> 集合中取回那个 <strong>Dog</strong> 引用，并试图将其转型为 <strong>Cat</strong> 时，就会得到一个 <strong>RuntimeException</strong> 。我们仍旧可以发现问题，但是是在运行时而非编译期发现它的。</p><p>在本书以前的版本中，我曾经说过：</p><blockquote><p>这不止令人恼火，它还可能会产生难以发现的缺陷。如果这个程序的某个部分（或数个部分）向集合中插入了对象，并且通过异常，我们在程序的另一个独立的部分中发现有不良对象被放置到了集合中，那么必须发现这个不良插入到底是在何处发生的。</p></blockquote><p>但是，随着对这个论点的进一步检查，我开始怀疑它了。首先，这会多么频繁地发生呢？我记得这类事情从未发生在我身上，并且当我在会议上询问其他人时，我也从来没有听说过有人碰上过。另一本书使用了一个称为 <strong>files</strong> 的 list 示例，它包含 <strong>String</strong> 对象。在这个示例中，向 <strong>files</strong> 中添加一个 <strong>File</strong> 对象看起来相当自然，因此这个对象的名字可能叫 <strong>fileNames</strong> 更好。无论 Java 提供了多少类型检查，仍旧可能会写出晦涩的程序，而编写差劲儿的程序即便可以编译，它仍旧是编写差劲儿的程序。可能大多数人都会使用命名良好的集合，例如 <strong>cats</strong> ，因为它们可以向试图添加非 <strong>Cat</strong> 对象的程序员提供可视的警告。并且即便这类事情发生了，它真正又能潜伏多久呢？只要我们开始用真实数据来运行测试，就会非常快地看到异常。</p><p>有一位作者甚至断言，这样的缺陷将“<em>潜伏数年</em>”。但是我不记得有任何大量的相关报告，来说明人们在查找“狗在猫列表中”这类缺陷时困难重重，或者是说明人们会非常频繁地产生这种错误。然而，我们将在 <a href="book/24-Concurrent-Programming.md">多线程编程</a> 章节中看到，在使用线程时，出现那些可能看起来极罕见的缺陷，是很寻常并容易发生的事，而且，对于到底出了什么错，这些缺陷只能给我们一个很模糊的概念。因此，对于泛型是添加到 Java 中的非常显著和相当复杂的特性这一点，“狗在猫列表中”这个论据真的能够成为它的理由吗？<br>我相信被称为<em>泛型</em>的通用语言特性（并非必须是其在 Java 中的特定实现）的目的在于可表达性，而不仅仅是为了创建类型安全的集合。类型安全的集合是能够创建更通用代码这一能力所带来的副作用。<br>因此，即便“狗在猫列表中”这个论据经常被用来证明泛型是必要的，但是它仍旧是有问题的。就像我在本章开头声称的，我不相信这就是泛型这个概念真正的含义。相反，泛型正如其名称所暗示的：它是一种方法，通过它可以编写出更“泛化”的代码，这些代码对于它们能够作用的类型具有更少的限制，因此单个的代码段可以应用到更多的类型上。正如我们在本章中看到的，编写真正泛化的“持有器”类（ Java 的容器就是这种类）相当简单，但是编写出能够操作其泛型类型的泛化代码就需要额外的努力了，这些努力需要类创建者和类消费者共同付出，他们必须理解这些代码的概念和实现。这些额外的努力会增加使用这种特性的难度，并可能会因此而使其在某些场合缺乏可应用性，而在这些场合中，它可能会带来附加的价值。</p><p>还要注意到，因为泛型是后来添加到 Java 中，而不是从一开始就设计到这种语言中的，所以某些容器无法达到它们应该具备的健壮性。例如，观察一下 <strong>Map</strong> ，在特定的方法 <code>containsKey(Object key)</code>和 <code>get(Object key)</code> 中就包含这类情况。如果这些类是使用在它们之前就存在的泛型设计的，那么这些方法将会使用参数化类型而不是 <strong>Object</strong> ，因此也就可以提供这些泛型假设会提供的编译期检查。例如，在 C++ 的 <strong>map</strong> 中，键的类型总是在编译期检查的。</p><p>有一件事很明显：在一种语言已经被广泛应用之后，在其较新的版本中引入任何种类的泛型机制，都会是一项非常非常棘手的任务，并且是一项不付出艰辛就无法完成的任务。在 C++ 中，模版是在其最初的 ISO 版本中就引入的（即便如此，也引发了阵痛，因为在第一个标准 C++ 出现之前，有很多非模版版本在使用），因此实际上模版一直都是这种语言的一部分。在 Java 中，泛型是在这种语言首次发布大约 10 年之后才引入的，因此向泛型迁移的问题特别多，并且对泛型的设计产生了明显的影响。其结果就是，程序员将承受这些痛苦，而这一切都是由于 Java 设计者在设计 1.0 版本时所表现出来的短视造成的。当 Java 最初被创建时，它的设计者们当然了解 C++ 的模版，他们甚至考虑将其囊括到 Java 语言中，但是出于这样或那样的原因，他们决定将模版排除在外（其迹象就是他们过于匆忙）。因此， Java 语言和使用它的程序员都将承受这些痛苦。只有时间将会说明 Java 的泛型方式对这种语言所造成的最终影响。<br>某些语言，已经融入了更简洁、影响更小的方式，来实现参数化类型。我们不可能不去想象这样的语言将会成为 Java 的继任者，因为它们采用的方式，与 C++ 通过 C 来实现的方式相同：按原样使用它，然后对其进行改进。</p><h2 id="进阶阅读"><a href="#进阶阅读" class="headerlink" title="进阶阅读"></a>进阶阅读</h2><p>泛型的入门文档是 《Generics in the Java Programming Language》，作者是 Gilad Bracha，可以从 <a href="http://java.oracle.com" target="_blank" rel="noopener">http://java.oracle.com</a> 获取。</p><p>Angelika Langer 的《Java Generics FAQs》是一份非常有帮助的资料，可以从 <a href="http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html" target="_blank" rel="noopener">http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html</a> 获取。</p><p>我们可以从 《Adding Wildcards to the Java Programming Language》中学到更多关于通配符的知识，作者是 Torgerson、Ernst、Hansen、von der Ahe、Bracha 和 Gafter，地址是 <a href="http://www.jot.fm/issues/issue_2004_12/article5。" target="_blank" rel="noopener">http://www.jot.fm/issues/issue_2004_12/article5。</a></p><p>Neal After 对于 Java 问题（尤其是擦除）的看法可以从这里找到：<a href="http://www.infoq.com/articles/neal-gafter-on-java。" target="_blank" rel="noopener">http://www.infoq.com/articles/neal-gafter-on-java。</a></p><!-- 分页 --><div style="page-break-after: always;"></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接口和抽象类提供了一种将接口与实现分离的更加结构化的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>79. 单词搜索</title>
    <link href="http://yoursite.com/2020/06/27/79.%20%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/"/>
    <id>http://yoursite.com/2020/06/27/79. 单词搜索/</id>
    <published>2020-06-26T17:12:12.000Z</published>
    <updated>2020-06-28T09:09:01.023Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二维网格和一个单词，找出该单词是否存在于网格中</p><a id="more"></a><p>这道题已经做过两次，这次决定完全不看提示自己写，做到晚上三点多还是有小问题，静下心调试了一次才彻底解决。更精简版的官方解法可以见<a href="https://leetcode-cn.com/problems/word-search/solution/zai-er-wei-ping-mian-shang-shi-yong-hui-su-fa-pyth/" target="_blank" rel="noopener">^1</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p>示例:</p><pre><code>board =[  [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;],  [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;],  [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]]给定 word = &quot;ABCCED&quot;, 返回 true给定 word = &quot;SEE&quot;, 返回 true给定 word = &quot;ABCB&quot;, 返回 false</code></pre><p>提示：</p><ul><li>board 和 word 中只包含大写和小写英文字母。</li><li>1 &lt;= board.length &lt;= 200</li><li>1 &lt;= board[i].length &lt;= 200</li><li>1 &lt;= word.length &lt;= 10^3</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>首先想到用dfs来解决：</p><h2 id="第一版代码-错误-："><a href="#第一版代码-错误-：" class="headerlink" title="第一版代码(错误)："></a>第一版代码(错误)：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean exist(char[][] board, String word) &#123;</span><br><span class="line">    if (board.length == 0 || board[0].length == 0 || board == null || word == null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean[][] visit = new boolean[board.length][board[0].length];</span><br><span class="line">    for (int i = 0; i &lt; board.length; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; board[i].length; j++) &#123;</span><br><span class="line">            if (existHelper(board, visit, word, 0, i, j)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    public boolean existHelper(char[][] board, boolean[][] visit, String s, int index, int i, int j) &#123;</span><br><span class="line">        if (i &lt; 0 || i &gt;= board.length || j &lt; 0 || j &gt;= board[i].length) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (index &lt; s.length() - 1) &#123;</span><br><span class="line">            if (s.charAt(index) == board[i][j] &amp;&amp; visit[i][j] == false) &#123;</span><br><span class="line">                visit[i][j] = true;</span><br><span class="line">                return existHelper(board, visit, s, index + 1, i - 1, j) || existHelper(board, visit, s, index + 1, i + 1, j) || existHelper(board, visit, s, index + 1, i, j - 1) || existHelper(board, visit, s, index + 1, i, j + 1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (s.charAt(index) == board[i][j] &amp;&amp; visit[i][j] == false) &#123;</span><br><span class="line">                visit[i][j] = true;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                visit[i][j] = false;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//total_testcases:89</span><br><span class="line">//total_correct:80</span><br><span class="line">//input_formatted:[[&quot;C&quot;,&quot;A&quot;,&quot;A&quot;],[&quot;A&quot;,&quot;A&quot;,&quot;A&quot;],[&quot;B&quot;,&quot;C&quot;,&quot;D&quot;]], &quot;AAB&quot;</span><br><span class="line">//expected_output:true</span><br><span class="line">//code_output:false</span><br></pre></td></tr></table></figure><p>错误原因，因为没有每次开始访问都初始化visit数组，所以把visit数组的初始化放到每次开始遍历的前面，即：</p><h2 id="第二版代码（错误）"><a href="#第二版代码（错误）" class="headerlink" title="第二版代码（错误）"></a>第二版代码（错误）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean exist(char[][] board, String word) &#123;</span><br><span class="line">    if (board.length == 0 || board[0].length == 0 || board == null || word == null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; board.length; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; board[i].length; j++) &#123;</span><br><span class="line">            boolean[][] visit = new boolean[board.length][board[0].length];</span><br><span class="line">            if (existHelper(board, visit, word, 0, i, j)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean existHelper(char[][] board, boolean[][] visit, String s, int index, int i, int j) &#123;</span><br><span class="line">        if (i &lt; 0 || i &gt;= board.length || j &lt; 0 || j &gt;= board[i].length) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (index &lt; s.length() - 1) &#123;</span><br><span class="line">            if (s.charAt(index) == board[i][j] &amp;&amp; visit[i][j] == false) &#123;</span><br><span class="line">                visit[i][j] = true;</span><br><span class="line">                return existHelper(board, visit, s, index + 1, i - 1, j) || existHelper(board, visit, s, index + 1, i + 1, j) || existHelper(board, visit, s, index + 1, i, j - 1) || existHelper(board, visit, s, index + 1, i, j + 1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (s.charAt(index) == board[i][j] &amp;&amp; visit[i][j] == false) &#123;</span><br><span class="line">                visit[i][j] = true;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                visit[i][j] = false;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//total_testcases:89</span><br><span class="line">//total_correct:85</span><br><span class="line">//input_formatted:[[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;E&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], &quot;ABCESEEEFS&quot;</span><br><span class="line">//expected_output:true</span><br><span class="line">//code_output:false</span><br></pre></td></tr></table></figure><p>又有问题，找到第（1，3）位置的S时再找E时会将四周的E都置为true，没有在返回前将其恢复。我们简化一下代码，加入每次回溯完恢复现场的代码：</p><h2 id="第三版代码（错误）"><a href="#第三版代码（错误）" class="headerlink" title="第三版代码（错误）"></a>第三版代码（错误）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    private static int[][] dires = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;;</span><br><span class="line">    private int row, col;</span><br><span class="line">    //用于标记是否已经找到解</span><br><span class="line">    private boolean hasFind;</span><br><span class="line">    private boolean[][] visit;</span><br><span class="line"></span><br><span class="line">    public boolean exist(char[][] board, String word) &#123;</span><br><span class="line">        if (board.length == 0 || board[0].length == 0 || board == null || word == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        row = board.length;</span><br><span class="line">        col = board[0].length;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; row; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; col; j++) &#123;</span><br><span class="line">                visit = new boolean[row][col];</span><br><span class="line">                if (existHelper(board, visit, word, 0, i, j)) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean existHelper(char[][] board, boolean[][] visit, String s, int index, int i, int j) &#123;</span><br><span class="line">        if (!isIn(i, j)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (index &lt; s.length() - 1) &#123;</span><br><span class="line">            if (s.charAt(index) == board[i][j] &amp;&amp; visit[i][j] == false) &#123;</span><br><span class="line">                visit[i][j] = true;</span><br><span class="line">                boolean res1 = existHelper(board, visit, s, index + 1, i - 1, j);</span><br><span class="line">                boolean res2 = existHelper(board, visit, s, index + 1, i + 1, j);</span><br><span class="line">                boolean res3 = existHelper(board, visit, s, index + 1, i, j - 1);</span><br><span class="line">                boolean res4 = existHelper(board, visit, s, index + 1, i, j + 1);</span><br><span class="line">                //对于这个分支的DFS已经完成了，需要回溯还原现场</span><br><span class="line">                if (res1 || res2 || res3 || res4) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    visit[i][j] = false;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (s.charAt(index) == board[i][j] &amp;&amp; visit[i][j] == false) &#123;</span><br><span class="line">                visit[i][j] = true;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                visit[i][j] = false;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean isIn(int i, int j) &#123;</span><br><span class="line">        if (i &lt; 0 || i &gt;= row || j &lt; 0 || j &gt;= col) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//total_testcases:89</span><br><span class="line">//total_correct:86</span><br><span class="line">//input_formatted:[[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]], &quot;aaaaaaaaaaaaa&quot;</span><br><span class="line">//expected_output:false</span><br><span class="line">//code_output:true</span><br></pre></td></tr></table></figure><p>13个a，理论上应该返回false的，但是我没有做这种情况的判断</p><p>修改后双错了</p><h2 id="第四版代码（错误）"><a href="#第四版代码（错误）" class="headerlink" title="第四版代码（错误）"></a>第四版代码（错误）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    private static int[][] dires = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;;</span><br><span class="line">    private int row, col;</span><br><span class="line">    //用于标记是否已经找到解</span><br><span class="line">    private boolean hasFind;</span><br><span class="line">    private boolean[][] visit;</span><br><span class="line"></span><br><span class="line">    public boolean exist(char[][] board, String word) &#123;</span><br><span class="line">        if (board.length == 0 || board[0].length == 0 || board == null || word == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        row = board.length;</span><br><span class="line">        col = board[0].length;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; row; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; col; j++) &#123;</span><br><span class="line">                visit = new boolean[row][col];</span><br><span class="line">                if (existHelper(board, visit, word, 0, i, j)) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean existHelper(char[][] board, boolean[][] visit, String s, int index, int i, int j) &#123;</span><br><span class="line">        if (!isIn(i, j, s)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (index &lt; s.length() - 1) &#123;</span><br><span class="line">            if (s.charAt(index) == board[i][j] &amp;&amp; visit[i][j] == false) &#123;</span><br><span class="line">                visit[i][j] = true;</span><br><span class="line">                boolean res1 = existHelper(board, visit, s, index + 1, i - 1, j);</span><br><span class="line">                boolean res2 = existHelper(board, visit, s, index + 1, i + 1, j);</span><br><span class="line">                boolean res3 = existHelper(board, visit, s, index + 1, i, j - 1);</span><br><span class="line">                boolean res4 = existHelper(board, visit, s, index + 1, i, j + 1);</span><br><span class="line">                //对于这个分支的DFS已经完成了，需要回溯还原现场</span><br><span class="line">                if (res1 || res2 || res3 || res4) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    visit[i][j] = false;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (s.charAt(index) == board[i][j] &amp;&amp; visit[i][j] == false) &#123;</span><br><span class="line">                visit[i][j] = true;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                visit[i][j] = false;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean isIn(int i, int j, String s) &#123;</span><br><span class="line">        if (i &lt; 0 || i &gt;= row || j &lt; 0 || j &gt;= col || col * row &lt; s.length()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//total_testcases:89</span><br><span class="line">//total_correct:87</span><br><span class="line">//input_formatted:[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;a&quot;],[&quot;b&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;a&quot;,&quot;b&quot;,&quot;a&quot;],[&quot;b&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]], &quot;bbbaabbbbbab&quot;</span><br><span class="line">//expected_output:false</span><br><span class="line">//code_output:true</span><br></pre></td></tr></table></figure><p>叒错了，这次调试后发现是到最后一步时dfs回退时把本为true的visit数组元素置为了false，为了避免叕错，把最后一步处理的置为false的代码去掉终于可以通过了，泪牛满面呜呜呜。</p><h2 id="第五版代码（正确）"><a href="#第五版代码（正确）" class="headerlink" title="第五版代码（正确）"></a>第五版代码（正确）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    private static int[][] dires = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;;</span><br><span class="line">    private int row, col;</span><br><span class="line">    private boolean[][] visit;</span><br><span class="line"></span><br><span class="line">    public boolean exist(char[][] board, String word) &#123;</span><br><span class="line">        if (board.length == 0 || board[0].length == 0 || board == null || word == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        row = board.length;</span><br><span class="line">        col = board[0].length;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; row; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; col; j++) &#123;</span><br><span class="line">                visit = new boolean[row][col];</span><br><span class="line">                if (existHelper(board, visit, word, 0, i, j)) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean existHelper(char[][] board, boolean[][] visit, String s, int index, int i, int j) &#123;</span><br><span class="line">        if (!isIn(i, j)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (index &lt; s.length() - 1) &#123;</span><br><span class="line">            if (s.charAt(index) == board[i][j] &amp;&amp; visit[i][j] == false) &#123;</span><br><span class="line">                visit[i][j] = true;</span><br><span class="line">                boolean res1 = existHelper(board, visit, s, index + 1, i - 1, j);</span><br><span class="line">                boolean res2 = existHelper(board, visit, s, index + 1, i + 1, j);</span><br><span class="line">                boolean res3 = existHelper(board, visit, s, index + 1, i, j - 1);</span><br><span class="line">                boolean res4 = existHelper(board, visit, s, index + 1, i, j + 1);</span><br><span class="line">                //对于这个分支的DFS已经完成了，需要回溯还原现场</span><br><span class="line">                if (res1 || res2 || res3 || res4) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    visit[i][j] = false;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (s.charAt(index) == board[i][j] &amp;&amp; visit[i][j] == false ) &#123;</span><br><span class="line">                visit[i][j] = true;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean isIn(int i, int j) &#123;</span><br><span class="line">        if (i &lt; 0 || i &gt;= row || j &lt; 0 || j &gt;= col) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个二维网格和一个单词，找出该单词是否存在于网格中&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
</feed>
