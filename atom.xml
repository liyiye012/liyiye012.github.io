<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-01-16T09:03:49.286Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Effctive-Java阅读笔记XI</title>
    <link href="http://yoursite.com/2020/01/16/Effctive-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0XI/"/>
    <id>http://yoursite.com/2020/01/16/Effctive-Java阅读笔记XI/</id>
    <published>2020-01-16T08:23:12.000Z</published>
    <updated>2020-01-16T09:03:49.286Z</updated>
    
    <content type="html"><![CDATA[<p>第四章阅读：类和接口</p><p>21.为后代设计接口<br>应该避免使用默认方法向现有的接口添加新的方法，除非这个需要是关键的。在默认方法的情况下，接口的现有实现类可以在没有错误或警告的情况下编译，但在运行时会失败。<br>22.接口仅用来定义类型</p><a id="more"></a><h1 id="为后代设计接口"><a href="#为后代设计接口" class="headerlink" title="为后代设计接口"></a>为后代设计接口</h1><p>　　在 Java 8 之前，不可能在不破坏现有实现的情况下为接口添加方法。 如果向接口添加了一个新方法，现有的实现通常会缺少该方法，从而导致编译时错误。 在 Java 8 中，添加了默认方法（default method）构造[JLS 9.4]，目的是允许将方法添加到现有的接口。 但是增加新的方法到现有的接口是充满风险的。</p><p>　　默认方法的声明包含一个默认实现，该方法允许实现接口的类直接使用，而不必实现默认方法。 虽然在 Java 中添加默认方法可以将方法添加到现有接口，但不能保证这些方法可以在所有已有的实现中使用。 默认的方法被「注入（injected）」到现有的实现中，没有经过实现类的知道或同意。 在 Java 8 之前，这些实现是用默认的接口编写的，它们的接口永远不会获得任何新的方法。</p><p>　　许多新的默认方法被添加到 Java 8 的核心集合接口中，主要是为了方便使用 lambda 表达式（第 6 章）。 Java 类库的默认方法是高质量的通用实现，在大多数情况下，它们工作正常。 但是，编写一个默认方法并不总是可能的，它保留了每个可能的实现的所有不变量。</p><p>　　例如，考虑在 Java 8 中添加到 Collection 接口的 removeIf 方法。此方法删除给定布尔方法（或 Predicate 函数式接口）返回 true 的所有元素。默认实现被指定为使用迭代器遍历集合，调用每个元素的谓词，并使用迭代器的 remove 方法删除谓词返回 true 的元素。 据推测，这个声明看起来像这样：默认实现被指定为使用迭代器遍历集合，调用每个元素的 Predicate 函数式接口，并使用迭代器的 remove 方法删除 Predicate 函数式接口返回 true 的元素。 根据推测，这个声明看起来像这样：</p><pre><code>// Default method added to the Collection interface in Java 8default boolean removeIf(Predicate&lt;? super E&gt; filter) {    Objects.requireNonNull(filter);    boolean result = false;    for (Iterator&lt;E&gt; it = iterator(); it.hasNext(); ) {        if (filter.test(it.next())) {            it.remove();            result = true;        }    }    return result;}</code></pre><p>　　这是可能为 removeIf 方法编写的最好的通用实现，但遗憾的是，它在一些实际的 Collection 实现中失败了。 例如，考虑 org.apache.commons.collections4.collection.SynchronizedCollection 方法。 这个类出自 Apache Commons 类库中，与 java.util 包中的静态工厂 Collections.synchronizedCollection 方法返回的类相似。 Apache 版本还提供了使用客户端提供的对象进行锁定的能力，以代替集合。 换句话说，它是一个包装类（条目 18），它们的所有方法在委托给包装集合类之前在一个锁定对象上进行同步。</p><p>　　Apache 的 SynchronizedCollection 类仍然在积极维护，但在撰写本文时，并未重写 removeIf 方法。 如果这个类与 Java 8 一起使用，它将继承 removeIf 的默认实现，但实际上不能保持类的基本承诺：自动同步每个方法调用。 默认实现对同步一无所知，并且不能访问包含锁定对象的属性。 如果客户端在另一个线程同时修改集合的情况下调用 SynchronizedCollection 实例上的 removeIf 方法，则可能会导致 ConcurrentModificationException 异常或其他未指定的行为。</p><p>　　为了防止在类似的 Java 平台类库实现中发生这种情况，比如 Collections.synchronizedCollection 返回的包级私有的类，JDK 维护者必须重写默认的 removeIf 实现和其他类似的方法来在调用默认实现之前执行必要的同步。 原来不属于 Java 平台的集合实现没有机会与接口更改进行类似的改变，有些还没有这样做。</p><p>　　<strong><em>在默认方法的情况下，接口的现有实现类可以在没有错误或警告的情况下编译，但在运行时会失败。</em></strong> 虽然不是非常普遍，但这个问题也不是一个孤立的事件。 在 Java 8 中添加到集合接口的一些方法已知是易受影响的，并且已知一些现有的实现会受到影响。</p><p>　　应该避免使用默认方法向现有的接口添加新的方法，除非这个需要是关键的，在这种情况下，你应该仔细考虑，以确定现有的接口实现是否会被默认的方法实现所破坏。然而，默认方法对于在创建接口时提供标准的方法实现非常有用，以减轻实现接口的任务（详见第 20 条）。</p><p>　　还值得注意的是，默认方法不是被用来设计，来支持从接口中移除方法或者改变现有方法的签名的目的。在不破坏现有客户端的情况下，这些接口都不可能发生更改。</p><p>　　准则是清楚的。 尽管默认方法现在是 Java 平台的一部分，<strong><em>但是非常悉心地设计接口仍然是非常重要的</em></strong>。 虽然默认方法可以将方法添加到现有的接口，但这样做有很大的风险。 如果一个接口包含一个小缺陷，可能会永远惹怒用户。 如果一个接口严重缺陷，可能会破坏包含它的 API。</p><p>　　因此，在发布之前测试每个新接口是非常重要的。 多个程序员应该以不同的方式实现每个接口。 至少，你应该准备三种不同的实现。 编写多个使用每个新接口的实例来执行各种任务的客户端程序同样重要。 这将大大确保每个接口都能满足其所有的预期用途。 这些步骤将允许你在发布之前发现接口中的缺陷，但仍然可以轻松地修正它们。 虽然在接口被发布后可能会修正一些存在的缺陷，但不要太指望这一点。</p><h1 id="接口仅用来定义类型"><a href="#接口仅用来定义类型" class="headerlink" title="接口仅用来定义类型"></a>接口仅用来定义类型</h1><p>　　当类实现接口时，该接口作为一种类型（type），可以用来引用类的实例。因此，一个类实现了一个接口，因此表明客户端可以如何处理类的实例。为其他目的定义接口是不合适的。</p><p>　　一种失败的接口就是所谓的常量接口（constant interface）。 这样的接口不包含任何方法; 它只包含静态 final 属性，每个输出一个常量。 使用这些常量的类实现接口，以避免需要用类名限定常量名。 这里是一个例子：</p><pre><code>// Constant interface antipattern - do not use!public interface PhysicalConstants {    // Avogadro&apos;s number (1/mol)    static final double AVOGADROS_NUMBER   = 6.022_140_857e23;    // Boltzmann constant (J/K)    static final double BOLTZMANN_CONSTANT = 1.380_648_52e-23;    // Mass of the electron (kg)    static final double ELECTRON_MASS      = 9.109_383_56e-31;}</code></pre><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="http://sjsdfg.gitee.io/effective-java-3rd-chinese/#/notes/21.%20%E4%B8%BA%E5%90%8E%E4%BB%A3%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3" target="_blank" rel="noopener">http://sjsdfg.gitee.io/effective-java-3rd-chinese/#/notes/21.%20%E4%B8%BA%E5%90%8E%E4%BB%A3%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第四章阅读：类和接口&lt;/p&gt;
&lt;p&gt;21.为后代设计接口&lt;br&gt;应该避免使用默认方法向现有的接口添加新的方法，除非这个需要是关键的。在默认方法的情况下，接口的现有实现类可以在没有错误或警告的情况下编译，但在运行时会失败。&lt;br&gt;22.接口仅用来定义类型&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Effctive-Java阅读笔记X</title>
    <link href="http://yoursite.com/2020/01/16/Effctive-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0X/"/>
    <id>http://yoursite.com/2020/01/16/Effctive-Java阅读笔记X/</id>
    <published>2020-01-16T06:29:12.000Z</published>
    <updated>2020-01-16T08:24:08.142Z</updated>
    
    <content type="html"><![CDATA[<p>第四章阅读：类和接口</p><p>19.要么设计继承并提供文档说明，要么禁用继承<br>除非知道真正需要子类，否则最好通过将类声明为 final，或者确保没有可访问的构造器来禁止类被继承。<br>20.接口优于抽象类<br>一个接口通常是定义允许多个实现的类型的最佳方式。 如果导出一个重要的接口，应该强烈考虑提供一个骨架的实现类。在可能的情况下，应该通过接口上的默认方法提供骨架实现，以便接口的所有实现者都可以使用它。即对接口的限制通常要求骨架实现类采用抽象类的形式。</p><a id="more"></a><h1 id="要么设计继承并提供文档说明，要么禁用继承"><a href="#要么设计继承并提供文档说明，要么禁用继承" class="headerlink" title="要么设计继承并提供文档说明，要么禁用继承"></a>要么设计继承并提供文档说明，要么禁用继承</h1><p>　　条目 18 中提醒你注意继承没有设计和文档说明的「外来」类的子类化的危险。 那么对于专门为了继承而设计并且具有良好文档说明的类而言，这又意味着什么呢？</p><p>　　首先，这个类必须准确地描述重写每个方法带来的影响。 换句话说，该类必须文档说明可重写方法的自用性（self-use）。 对于每个 public 或者 protected 的方法，文档必须指明方法调用哪些可重写方法，以何种顺序调用的，以及每次调用的结果又是如何影响后续处理。 （重写方法，这里是指非 final 修饰的方法，无论是公开还是保护的。）更一般地说，一个类必须文档说明任何可能调用可重写方法的情况。 例如，后台线程或者静态初始化代码块可能会调用这样的方法。</p><p>　　调用可重写方法的方法在文档注释结束时包含对这些调用的描述。 这些描述在规范中特定部分，标记为「Implementation Requirements」，由 Javadoc 标签 @implSpec 生成。 这段话介绍该方法的内部工作原理。 下面是从 java.util.AbstractCollection 类的规范中拷贝的例子：</p><pre><code>public boolean remove(Object o)Removes a single instance of the specified element from this collection, if it is present (optional operation). More formally, removes an element e such that Objects.equals(o, e), if this collection contains one or more such elements. Returns true if this collection contained the specified element (or equivalently, if this collection changed as a result of the call).Implementation Requirements: This implementation iterates over the collection looking for the specified element. If it finds the element, it removes the element from the collection using the iterator’s remove method. Note that this implementation throws an UnsupportedOperationException if the iterator returned by this collection’s iterator method does not implement the remove method and this collection contains the specified object.</code></pre><p>　　从该集合中删除指定元素的单个实例（如果存在，optional 实例操作）。 更广义地说，如果这个集合包含一个或多个这样的元素 e，就删除其中的一个满足 Objects.equals(o, e) 的元素 e。 如果此集合包含指定的元素（或者等同于此集合因调用而发生了更改），则返回 true。</p><p>　　实现要求： 这个实现迭代遍历集合查找指定元素。 如果找到元素，则使用迭代器的 remove 方法从集合中删除元素。 请注意，如果此集合的 iterator 方法返回的迭代器未实现 remove 方法，并且此集合包含指定的对象，则该实现将引发 UnsupportedOperationException 异常。</p><p>　　这个文档清楚地说明，重写 iterator 方法将会影响 remove 方法的行为。 它还描述了 iterator 方法返回的 Iterator 行为将如何影响 remove 方法的行为。 与条目 18 中的情况相反，在这种情况下，程序员继承 HashSet 并不能说明重写 add 方法是否会影响 addAll 方法的行为。</p><p>　　关于程序文档有句格言：好的 API 文档应该描述一个给定的方法做了什么工作，而不是描述它是如何做到的。那么，上面这种做法是否违背了这句格言呢？是的，它确实违背了！这正是继承破坏了封装性所带来的不幸后果。所以，为了设计一个类的文档，以便它能够被安全地子类化，你必须描述清楚那些有可能未定义的实现细节。</p><p>　　@implSpec 标签是在 Java 8 中添加的，并且在 Java 9 中被大量使用。这个标签应该默认启用，但是从 Java 9 开始，除非通过命令行开关-tag “apiNote:a:API Note:”，否则 Javadoc 工具仍然会忽略它。</p><p>　　为了继承而进行的设计不仅仅涉及自用模式的文档设计。为了使程序员能够编写出更加有效的子类，而无须承受不必要的痛苦，类必须以精心挑选的 protected 方法的形式，提供适当的钩子（hook），以便进入其内部工作中。或者在罕见的情况下，提供受保护的属性。 例如，考虑 java.util.AbstractList 中的 removeRange 方法：</p><pre><code>protected void removeRange(int fromIndex, int toIndex)Removes from this list all of the elements whose index is between fromIndex, inclusive, and toIndex, exclusive. Shifts any succeeding elements to the left (reduces their index). This call shortens the list by (toIndex - fromIndex) elements. (If toIndex == fromIndex, this operation has no effect.)This method is called by the clear operation on this list and its sublists. Overriding this method to take advantage of the internals of the list implementation can substantially improve the performance of the clear operation on this list and its sublists.Implementation Requirements: This implementation gets a list iterator positioned before fromIndex and repeatedly calls ListIterator.nextfollowed by ListIterator.remove, until the entire range has been removed. Note: If ListIterator.remove requires linear time, this implementation requires quadratic time.Parameters:    fromIndex    index of first element to be removed.    toIndex      index after last element to be removed.</code></pre><p>　　从此列表中删除索引介于 fromIndex（包含）和 inclusive（不含）之间的所有元素。 将任何后续元素向左移（减少索引）。 这个调用通过（toIndex - fromIndex）元素来缩短列表。 （如果 toIndex == fromIndex，则此操作无效。）</p><p>　　这个方法是通过列表及其子类的 clear 操作来调用的。重写这个方法利用列表内部实现的优势，可以大大提高列表和子类的 clear 操作性能。</p><p>　　实现要求： 这个实现获取一个列表迭代器，它位于 fromIndex 之前，并重复调用 ListIterator.remove 和 ListIterator.next 方法，直到整个范围被删除。 注意：如果 ListIterator.remove 需要线性时间，则此实现需要平方级时间。</p><p>参数：<br>　　fromIndex 要移除的第一个元素的索引<br>　　toIndex 要移除的最后一个元素之后的索引</p><p>　　这个方法对 List 实现的最终用户来说是没有意义的。 它仅仅是为了使子类很容易提供一个快速 clear 方法。 在没有 removeRange 方法的情况下，当在子列表上调用 clear 方法，子类将不得不使用平方级的时间，否则，或从头重写整个 subList 机制——这不是一件容易的事情！</p><p>　　那么当你设计一个继承类的时候，你如何决定暴露哪些的受保护的成员呢？ 不幸的是，没有灵丹妙药。 所能做的最好的就是努力思考，做出最好的测试，然后通过编写子类来进行测试。 应该尽可能少地暴露受保护的成员，因为每个成员都表示对实现细节的承诺。 另一方面，你不能暴露太少，因为失去了保护的成员会导致一个类几乎不能用于继承。</p><p>　　<strong><em>测试为继承而设计的类的唯一方法是编写子类</em></strong>。 如果你忽略了一个关键的受保护的成员，试图编写一个子类将会使得遗漏痛苦地变得明显。 相反，如果编写的几个子类，而且没有一个使用受保护的成员，那么应该将其设为私有。 经验表明，三个子类通常足以测试一个可继承的类。 这些子类应该由父类作者以外的人编写。</p><p>　　当你为继承设计一个可能被广泛使用的类的时候，要意识到你永远承诺你文档说明的自用模式以及隐含在其保护的方法和属性中的实现决定。 这些承诺可能会使后续版本中改善类的性能或功能变得困难或不可能。 因此， 在发布它之前，你必须通过编写子类来测试你的类。</p><p>　　另外，请注意，继承所需的特殊文档混乱了正常的文档，这是为创建类的实例并在其上调用方法的程序员设计的。 在撰写本文时，几乎没有工具将普通的 API 文档从和仅仅针对子类实现的信息，分离出来。</p><p>　　还有一些类必须遵守允许继承的限制。 <strong><em>构造方法绝不能直接或间接调用可重写的方法</em></strong>。 如果违反这个规则，将导致程序失败。 父类构造方法在子类构造方法之前运行，所以在子类构造方法运行之前，子类中的重写方法被调用。 如果重写方法依赖于子类构造方法执行的任何初始化，则此方法将不会按预期运行。 为了具体说明，这是一个违反这个规则的类：</p><pre><code>public class Super {    // Broken - constructor invokes an overridable method    public Super() {        overrideMe();    }    public void overrideMe() {    }}</code></pre><p>以下是一个重写 overrideMe 方法的子类，Super 类的唯一构造方法会错误地调用它：</p><pre><code>public final class Sub extends Super {    // Blank final, set by constructor    private final Instant instant;    Sub() {        instant = Instant.now();    }    // Overriding method invoked by superclass constructor    @Override    public void overrideMe() {        System.out.println(instant);    }    public static void main(String[] args) {        Sub sub = new Sub();        sub.overrideMe();    }}</code></pre><p>　　你可能期望这个程序打印两次 instant 实例，但是它第一次打印出 null，因为在 Sub 构造方法有机会初始化 instant 属性之前，overrideMe 被 Super 构造方法调用。 请注意，这个程序观察两个不同状态的 final 属性！ 还要注意的是，如果 overrideMe 方法调用了 instant 实例中任何方法，那么当父类构造方法调用 overrideMe 时，它将抛出一个 NullPointerException 异常。 这个程序不会抛出 NullPointerException 的唯一原因是 println 方法容忍 null 参数。</p><p>　　请注意，从构造方法中调用私有方法，其中任何一个方法都不可重写的，那么 final 方法和静态方法是安全的。</p><p>　　Cloneable 和 Serializable 接口在设计继承时会带来特殊的困难。 对于为继承而设计的类来说，实现这些接口通常不是一个好主意，因为这会给继承类的程序员带来很大的负担。 然而，可以采取特殊的行动来允许子类实现这些接口，而不需要强制这样做。 这些操作在条目 13 和条目 86 中有描述。</p><p>　　如果你决定在为继承而设计的类中实现 Cloneable 或 Serializable 接口，那么应该知道，由于 clone 和 readObject 方法与构造方法相似，所以也有类似的限制： clone 和 readObject <strong><em>都不会直接或间接调用可重写的方法</em></strong>。 在 readObject 的情况下，重写方法将在子类的状态被反序列化之前运行。 在 clone 的情况下，重写方法将在子类的 clone 方法有机会修复克隆的状态之前运行。 在任何一种情况下，都可能会出现程序故障。 在 clone 的情况下，故障可能会损坏原始对象以及被克隆对象本身。 例如，如果重写方法假定它正在修改对象的深层结构的拷贝，但是尚未创建拷贝，则可能发生这种情况。</p><p>　　最后，如果你决定在为继承设计的类中实现 Serializable 接口，并且该类有一个 readResolve 或 writeReplace 方法，则必须使 readResolve 或 writeReplace 方法设置为受保护而不是私有。 如果这些方法是私有的，它们将被子类无声地忽略。 这是另一种情况，把实现细节成为类的 API 的一部分，以允许继承。</p><p>　　到目前为止，<strong><em>设计一个继承类需要很大的努力，并且对这个类有很大的限制。</em></strong> 这不是一个轻率的决定。 有些情况显然是正确的，比如抽象类，包括接口的骨架实现（skeletal implementations）（详见第 20 条）。 还有其他的情况显然是错误的，比如不可变的类（详见第 17 条）。</p><p>　　但是普通的具体类呢？ 传统上，它们既不是 final 的，也不是为了子类化而设计和文档说明的，但是这种情况是危险的。每次修改这样的类，则继承此类的子类将被破坏。 这不仅仅是一个理论问题。 在修改非 final 的具体类的内部之后，接收与子类相关的错误报告并不少见，这些类没有为继承而设计和文档说明。</p><p>　　<strong><em>解决这个问题的最好办法是，在没有想要安全地子类化的设计和文档说明的类中禁止子类化。</em></strong> 有两种方法禁止子类化。 两者中较容易的是声明类为 final。 另一种方法是使所有的构造方法都是私有的或包级私有的，并且添加公共静态工厂来代替构造方法。 这个方案在内部提供了使用子类的灵活性，在条目 17 中讨论过。两种方法都是可以接受的。</p><p>　　这个建议可能有些争议，因为许多程序员已经习惯于继承普通的具体类来增加功能，例如通知和同步等功能，或限制原有类的功能。 如果一个类实现了捕获其本质的一些接口，比如 Set，List 或 Map，那么不应该为了禁止子类化而感到愧疚。 在条目 18 中描述的包装类模式为增强功能提供了继承的优越选择。</p><p>　　如果一个具体的类没有实现一个标准的接口，那么你可能会通过禁止继承来给一些程序员带来不便。 如果你觉得你必须允许从这样的类继承，一个合理的方法是确保类从不调用任何可重写的方法，并文档说明这个事实。 换句话说，完全消除类的自用（self-use）的可重写的方法。 这样做，你将创建一个合理安全的子类。 重写一个方法不会影响任何其他方法的行为。</p><p>　　你可以机械地消除类的自我使用的重写方法，而不会改变其行为。 将每个可重写的方法的主体移动到一个私有的“帮助器方法”，并让每个可重写的方法调用其私有的帮助器方法。 然后用直接调用可重写方法的专用帮助器方法来替换每个自用的可重写方法。</p><p>　　简而言之，专门为了继承而设计类是一件很辛苦的工作。你必须建立文档说明其所有的自用模式，并且一旦建立了文档，在这个类的整个生命周期中都必须遵守。如果没有做到，子类就会依赖父类的实现细节，如果父类的实现发生了变化，它就有可能遭到破坏。为了允许其他人能编写出高效的子类，还你必须导出一个或者多个受保护的方法。<strong><em>除非知道真正需要子类，否则最好通过将类声明为 final，或者确保没有可访问的构造器来禁止类被继承。</em></strong></p><h1 id="接口优于抽象类"><a href="#接口优于抽象类" class="headerlink" title="接口优于抽象类"></a>接口优于抽象类</h1><p>　　Java 有两种机制来定义允许多个实现的类型：接口和抽象类。 由于在 Java 8 [JLS 9.4.3] 中引入了接口的默认方法（default methods ），因此这两种机制都允许为某些实例方法提供实现。 一个主要的区别是要实现由抽象类定义的类型，类必须是抽象类的子类。 因为 Java 只允许单一继承，所以对抽象类的这种限制严格限制了它们作为类型定义的使用。 任何定义所有必需方法并服从通用约定的类都可以实现一个接口，而不管类在类层次结构中的位置。</p><p>　　现有的类可以很容易地进行改进来实现一个新的接口。 你只需添加所需的方法（如果尚不存在的话），并向类声明中添加一个 implements 子句。 例如，当 Comparable, Iterable， 和 Autocloseable 接口添加到 Java 平台时，很多现有类需要实现它们来加以改进。 一般来说，现有的类不能改进以继承一个新的抽象类。 如果你想让两个类继承相同的抽象类，你必须把它放在类型层级结构中的上面位置，它是两个类的祖先。 不幸的是，这会对类型层级结构造成很大的附带损害，迫使新的抽象类的所有后代对它进行子类化，无论这些后代类是否合适。</p><p>　　接口是定义混合类型（mixin）的理想选择。 一般来说，mixin 是一个类，除了它的“主类型”之外，还可以声明它提供了一些可选的行为。 例如，Comparable 是一个类型接口，它允许一个类声明它的实例相对于其他可相互比较的对象是有序的。 这样的接口被称为类型，因为它允许可选功能被“混合”到类型的主要功能。 抽象类不能用于定义混合类，这是因为它们不能被加载到现有的类中：一个类不能有多个父类，并且在类层次结构中没有合理的位置来插入一个类型。</p><p>　　接口允许构建非层级类型的框架。 类型层级对于组织某些事物来说是很好的，但是其他的事物并不是整齐地落入严格的层级结构中。 例如，假设我们有一个代表歌手的接口，和另一个代表作曲家的接口：</p><pre><code>public interface Singer {    AudioClip sing(Song s);}public interface Songwriter {    Song compose(int chartPosition);}</code></pre><p>　　在现实生活中，一些歌手也是作曲家。 因为我们使用接口而不是抽象类来定义这些类型，所以单个类实现歌手和作曲家两个接口是完全允许的。 事实上，我们可以定义一个继承歌手和作曲家的第三个接口，并添加适合于这个组合的新方法：</p><pre><code>public interface SingerSongwriter extends Singer, Songwriter {    AudioClip strum();    void actSensitive();}</code></pre><p>　　你并不总是需要这种灵活性，但是当你这样做的时候，接口是一个救星。 另一种方法是对于每个受支持的属性组合，包含一个单独的类的臃肿类层级结构。 如果类型系统中有 n 个属性，则可能需要支持 2n 种可能的组合。 这就是所谓的组合爆炸（combinatorial explosion）。 臃肿的类层级结构可能会导致具有许多方法的臃肿类，这些方法仅在参数类型上有所不同，因为类层级结构中没有类型来捕获通用行为。</p><p>　　接口通过包装类模式确保安全的，强大的功能增强成为可能（详见第 18 条）。 如果使用抽象类来定义类型，那么就让程序员想要添加功能，只能继承。 生成的类比包装类更弱，更脆弱。</p><p>　　当其他接口方法有明显的接口方法实现时，可以考虑向程序员提供默认形式的方法实现帮助。 有关此技术的示例，请参阅第 104 页的 removeIf 方法。如果提供默认方法，请确保使用@implSpec Javadoc 标记（条目 19）将它们文档说明为继承。</p><p>　　使用默认方法可以提供实现帮助多多少少是有些限制的。 尽管许多接口指定了 Object 类中方法（如 equals 和 hashCode）的行为，但不允许为它们提供默认方法。 此外，接口不允许包含实例属性或非公共静态成员（私有静态方法除外）。 最后，不能将默认方法添加到不受控制的接口中。</p><p>　　但是，你可以通过提供一个抽象的骨架实现类（abstract skeletal implementation class）来与接口一起使用，将接口和抽象类的优点结合起来。 接口定义了类型，可能提供了一些默认的方法，而骨架实现类在原始接口方法的顶层实现了剩余的非原始接口方法。 继承骨架实现需要大部分的工作来实现一个接口。 这就是模板方法设计模式[Gamma95]。</p><p>　　按照惯例，骨架实现类被称为 AbstractInterface，其中 Interface 是它们实现的接口的名称。 例如，集合框架（ Collections Framework）提供了一个框架实现以配合每个主要集合接口：AbstractCollection，AbstractSet，AbstractList 和 AbstractMap。 可以说，将它们称为 SkeletalCollection，SkeletalSet，SkeletalList 和 SkeletalMap 是有道理的，但是现在已经确立了抽象约定。 如果设计得当，骨架实现（无论是单独的抽象类还是仅由接口上的默认方法组成）可以使程序员非常容易地提供他们自己的接口实现。 例如，下面是一个静态工厂方法，在 AbstractList 的顶层包含一个完整的功能齐全的 List 实现：</p><pre><code>// Concrete implementation built atop skeletal implementationstatic List&lt;Integer&gt; intArrayAsList(int[] a) {    Objects.requireNonNull(a);    // The diamond operator is only legal here in Java 9 and later    // If you&apos;re using an earlier release, specify &lt;Integer&gt;    return new AbstractList&lt;&gt;() {        @Override        public Integer get(int i) {            return a[i];  // Autoboxing ([Item 6](https://www.safaribooksonline.com/library/view/effective-java-third/9780134686097/ch2.xhtml#lev6))        }        @Override        public Integer set(int i, Integer val) {            int oldVal = a[i];            a[i] = val;     // Auto-unboxing            return oldVal;  // Autoboxing        }        @Override        public int size() {            return a.length;        }    };}</code></pre><p>　　当你考虑一个 List 实现为你做的所有事情时，这个例子是一个骨架实现的强大的演示。 顺便说一句，这个例子是一个适配器（Adapter）[Gamma95]，它允许一个 int 数组被看作 Integer 实例列表。 由于 int 值和整数实例（装箱和拆箱）之间的来回转换，其性能并不是非常好。 请注意，实现采用匿名类的形式（详见第 24 条）。</p><p>　　骨架实现类的优点在于，它们提供抽象类的所有实现的帮助，而不会强加抽象类作为类型定义时的严格约束。对于具有骨架实现类的接口的大多数实现者来说，继承这个类是显而易见的选择，但它不是必需的。如果一个类不能继承骨架的实现，这个类可以直接实现接口。该类仍然受益于接口本身的任何默认方法。此外，骨架实现类仍然可以协助接口的实现。实现接口的类可以将接口方法的调用转发给继承骨架实现的私有内部类的包含实例。这种被称为模拟多重继承的技术与条目 18 讨论的包装类模式密切相关。它提供了多重继承的许多好处，同时避免了缺陷。</p><p>　　编写一个骨架的实现是一个相对简单的过程，虽然有些乏味。 首先，研究接口，并确定哪些方法是基本的，其他方法可以根据它们来实现。 这些基本方法是你的骨架实现类中的抽象方法。 接下来，为所有可以直接在基本方法之上实现的方法提供接口中的默认方法，回想一下，你可能不会为诸如 Object 类中 equals 和 hashCode 等方法提供默认方法。 如果基本方法和默认方法涵盖了接口，那么就完成了，并且不需要骨架实现类。 否则，编写一个声明实现接口的类，并实现所有剩下的接口方法。 为了适合于该任务，此类可能包含任何的非公共属性和方法。</p><p>　　作为一个简单的例子，考虑一下 Map.Entry 接口。 显而易见的基本方法是 getKey，getValue 和（可选的）setValue。 接口指定了 equals 和 hashCode 的行为，并且在基本方面方面有一个 toString 的明显的实现。 由于不允许为 Object 类方法提供默认实现，因此所有实现均放置在骨架实现类中：</p><pre><code>// Skeletal implementation classpublic abstract class AbstractMapEntry&lt;K,V&gt;        implements Map.Entry&lt;K,V&gt; {    // Entries in a modifiable map must override this method    @Override public V setValue(V value) {        throw new UnsupportedOperationException();    }    // Implements the general contract of Map.Entry.equals    @Override    public boolean equals(Object o) {        if (o == this)            return true;        if (!(o instanceof Map.Entry))            return false;        Map.Entry&lt;?,?&gt; e = (Map.Entry) o;        return Objects.equals(e.getKey(),  getKey())            &amp;&amp; Objects.equals(e.getValue(), getValue());    }    // Implements the general contract of Map.Entry.hashCode    @Override    public int hashCode() {        return Objects.hashCode(getKey())             ^ Objects.hashCode(getValue());    }    @Override    public String toString() {        return getKey() + &quot;=&quot; + getValue();    }}</code></pre><p>　　请注意，这个骨架实现不能在 Map.Entry 接口中实现，也不能作为子接口实现，因为默认方法不允许重写诸如 equals，hashCode 和 toString 等 Object 类方法。</p><p>　　由于骨架实现类是为了继承而设计的，所以你应该遵循条目 19 中的所有设计和文档说明。为了简洁起见，前面的例子中省略了文档注释，但是好的文档在骨架实现中是绝对必要的，无论它是否包含 一个接口或一个单独的抽象类的默认方法。</p><p>　　与骨架实现有稍许不同的是简单实现，以 AbstractMap.SimpleEntry 为例。 一个简单的实现就像一个骨架实现，它实现了一个接口，并且是为了继承而设计的，但是它的不同之处在于它不是抽象的：它是最简单的工作实现。 你可以按照情况使用它，也可以根据情况进行子类化。</p><p>　　总而言之，一个接口通常是定义允许多个实现的类型的最佳方式。 如果你导出一个重要的接口，应该强烈考虑提供一个骨架的实现类。 在可能的情况下，应该通过接口上的默认方法提供骨架实现，以便接口的所有实现者都可以使用它。 也就是说，对接口的限制通常要求骨架实现类采用抽象类的形式。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="http://sjsdfg.gitee.io/effective-java-3rd-chinese/#/notes/19.%20%E8%A6%81%E4%B9%88%E8%AE%BE%E8%AE%A1%E7%BB%A7%E6%89%BF%E5%B9%B6%E6%8F%90%E4%BE%9B%E6%96%87%E6%A1%A3%E8%AF%B4%E6%98%8E%EF%BC%8C%E8%A6%81%E4%B9%88%E7%A6%81%E7%94%A8%E7%BB%A7%E6%89%BF" target="_blank" rel="noopener">http://sjsdfg.gitee.io/effective-java-3rd-chinese/#/notes/19.%20%E8%A6%81%E4%B9%88%E8%AE%BE%E8%AE%A1%E7%BB%A7%E6%89%BF%E5%B9%B6%E6%8F%90%E4%BE%9B%E6%96%87%E6%A1%A3%E8%AF%B4%E6%98%8E%EF%BC%8C%E8%A6%81%E4%B9%88%E7%A6%81%E7%94%A8%E7%BB%A7%E6%89%BF</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第四章阅读：类和接口&lt;/p&gt;
&lt;p&gt;19.要么设计继承并提供文档说明，要么禁用继承&lt;br&gt;除非知道真正需要子类，否则最好通过将类声明为 final，或者确保没有可访问的构造器来禁止类被继承。&lt;br&gt;20.接口优于抽象类&lt;br&gt;一个接口通常是定义允许多个实现的类型的最佳方式。 如果导出一个重要的接口，应该强烈考虑提供一个骨架的实现类。在可能的情况下，应该通过接口上的默认方法提供骨架实现，以便接口的所有实现者都可以使用它。即对接口的限制通常要求骨架实现类采用抽象类的形式。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Effctive-Java阅读笔记IX</title>
    <link href="http://yoursite.com/2020/01/16/Effctive-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0IX/"/>
    <id>http://yoursite.com/2020/01/16/Effctive-Java阅读笔记IX/</id>
    <published>2020-01-16T03:28:12.000Z</published>
    <updated>2020-01-16T08:24:15.884Z</updated>
    
    <content type="html"><![CDATA[<p>第四章阅读：类和接口</p><p>17.最小化可变性<br>18.组合优于继承<br>灵魂三问：<br>　如果你试图让 B 类继承 A 类时，问自己这个问题：每个 B 都是 A 吗？ 如果你不能如实回答这个问题，那么 B 就不应该继承 A。在决定使用继承来代替组合之前，你应该问自己最后一组问题。对于试图继承的类，它的 API 有没有缺陷呢？ 如果有，你是否愿意将这些缺陷传播到你的类的 API 中？继承传播父类的 API 中的任何缺陷，而组合可以让你设计一个隐藏这些缺陷的新 API。</p><a id="more"></a><h1 id="最小化可变性"><a href="#最小化可变性" class="headerlink" title="最小化可变性"></a>最小化可变性</h1><p>　　不可变类简单来说是其实例不能被修改的类。 包含在每个实例中的所有信息在对象的生命周期中是固定的，因此不会观察到任何变化。 Java 平台类库包含许多不可变的类，包括 String 类、基本类型包装类以及 BigInteger 类和 BigDecimal 类。 有很多很好的理由：不可变类比可变类更易于设计，实现和使用。 他们不容易出错，并且更安全。</p><p>　　要使一个类成为不可变类，请遵循以下五条规则：</p><h2 id="不要提供修改对象状态的方法（也称为-mutators，设值方法）。"><a href="#不要提供修改对象状态的方法（也称为-mutators，设值方法）。" class="headerlink" title="不要提供修改对象状态的方法（也称为 mutators，设值方法）。"></a>不要提供修改对象状态的方法（也称为 mutators，设值方法）。</h2><h2 id="确保这个类不能被继承。"><a href="#确保这个类不能被继承。" class="headerlink" title="确保这个类不能被继承。"></a>确保这个类不能被继承。</h2><p>这可以防止粗心或者恶意的子类假装对象的状态已经改变，从而破坏类的不可变行为。 防止子类化，通常是通过 final 修饰类，但是我们稍后将讨论另一种方法。<br>##把所有字段设置为 final。<br>通过系统强制执行的方式，清楚地表达了你的意图。 另外，如果一个新创建的实例的引用在缺乏同步机制的情况下从一个线程传递到另一个线程，就必须保证正确的行为，正如内存模型[JLS，17.5; Goetz06 16] 所述。</p><h2 id="把所有的字段设置为-private。"><a href="#把所有的字段设置为-private。" class="headerlink" title="把所有的字段设置为 private。"></a>把所有的字段设置为 private。</h2><p>这可以防止客户端获得对字段引用的可变对象的访问权限，并直接修改这些对象。 虽然技术上允许不可变类具有包含基本类型数值的公有的 final 字段或对不可变对象的引用，但不建议这样做，因为这样使得在以后的版本中无法再改变内部的表示状态（详见第 15 和 16 条）。</p><h2 id="确保对任何可变组件的互斥访问。"><a href="#确保对任何可变组件的互斥访问。" class="headerlink" title="确保对任何可变组件的互斥访问。"></a>确保对任何可变组件的互斥访问。</h2><p>如果你的类有任何引用可变对象的字段，请确保该类的客户端无法获得对这些对象的引用。 切勿将这样的属性初始化为客户端提供的对象引用，或从访问方法返回属性。 在构造方法，访问方法和 readObject 方法（详见第 88 条）中进行防御性拷贝（详见第 50 条）。<br>　　以前条目中的许多示例类都是不可变的。 其中一个例子是条目 11 中的 PhoneNumber 类，它具有每个字段的访问方法（accessors），但没有相应的设值方法（mutators）。下面一个稍微复杂一点的例子：</p><pre><code>// Immutable complex number classpublic final class Complex {    private final double re;    private final double im;    public Complex(double re, double im) {        this.re = re;        this.im = im;    }    public double realPart() {        return re;    }    public double imaginaryPart() {        return im;    }    public Complex plus(Complex c) {        return new Complex(re + c.re, im + c.im);    }    public Complex minus(Complex c) {        return new Complex(re - c.re, im - c.im);    }    public Complex times(Complex c) {        return new Complex(re * c.re - im * c.im,                re * c.im + im * c.re);    }    public Complex dividedBy(Complex c) {        double tmp = c.re * c.re + c.im * c.im;        return new Complex((re * c.re + im * c.im) / tmp,                (im * c.re - re * c.im) / tmp);    }    @Override    public boolean equals(Object o) {        if (o == this) {            return true;        }        if (!(o instanceof Complex)) {            return false;        }        Complex c = (Complex) o;        // See page 47 to find out why we use compare instead of ==        return Double.compare(c.re, re) == 0                &amp;&amp; Double.compare(c.im, im) == 0;    }    @Override    public int hashCode() {        return 31 * Double.hashCode(re) + Double.hashCode(im);    }    @Override    public String toString() {        return &quot;(&quot; + re + &quot; + &quot; + im + &quot;i)&quot;;    }}</code></pre><p>　　这个类代表了一个复数（包含实部和虚部的数字）。 除了标准的 Object 方法之外，它还为实部和虚部提供访问方法，并提供四个基本的算术运算：加法，减法，乘法和除法。 注意算术运算如何创建并返回一个新的 Complex 实例，而不是修改这个实例。 这种模式被称为函数式方法，因为方法返回将操作数应用于函数的结果，而不修改它们。 与其对应的过程式的（procedural）或命令式的（imperative）的方法相对比，在这种方法中，将一个过程作用在操作数上，导致其状态改变。 请注意，方法名称是介词（如 plus）而不是动词（如 add）。 这强调了方法不会改变对象的值的事实。 BigInteger 和 BigDecimal 类没有遵守这个命名约定，并导致许多使用错误。</p><p>　　如果你不熟悉函数式方法，可能会觉得它显得不自然，但它具有不变性，具有许多优点。 不可变对象很简单。 一个不可变的对象可以完全处于一种状态，也就是被创建时的状态。 如果确保所有的构造方法都建立了类不变量，那么就保证这些不变量在任何时候都保持不变，使用此类的程序员无需再做额外的工作。 另一方面，可变对象可以具有任意复杂的状态空间。 如果文档没有提供由设置（mutator）方法执行的状态转换的精确描述，那么可靠地使用可变类可能是困难的或不可能的。</p><p>　　<strong><em>不可变对象本质上是线程安全的；它们不需要同步</em></strong> 。 被多个线程同时访问它们时，不会遭到破坏。 这是实现线程安全的最简单方法。 由于没有线程可以观察到另一个线程对不可变对象的影响，所以 <strong><em>不可变对象可以被自由地共享</em></strong> 。 因此，不可变类应鼓励客户端尽可能重用现有的实例。 一个简单的方法是为常用的值提供公共的静态 final 常量。 例如，Complex 类可能提供这些常量：</p><pre><code>public static final Complex ZERO = new Complex(0, 0);public static final Complex ONE  = new Complex(1, 0);public static final Complex I    = new Complex(0, 1);</code></pre><p>　　这种方法可以更进一步。 一个不可变的类可以提供静态的工厂（详见第 1 条）来缓存经常被请求的实例，以避免在现有的实例中创建新的实例。 所有基本类型的包装类和 BigInteger 类都是这样做的。 使用这样的静态工厂会使客户端共享实例而不是创建新实例，从而减少内存占用和垃圾回收成本。 在设计新类时，选择静态工厂代替公共构造方法，可以在以后增加缓存的灵活性，而不需要修改客户端。</p><p>　　不可变对象可以自由分享的结果是，你永远不需要做出防御性拷贝（defensive copies）（详见第 50 条）。 事实上，永远不需要做任何拷贝，因为这些拷贝永远等于原始对象。 因此，你不需要也不应该在一个不可变的类上提供一个 clone 方法或拷贝构造方法（copy constructor）（详见第 13 条）。 这一点在 Java 平台的早期阶段还不是很好理解，所以 String 类有一个拷贝构造方法，但是它应该尽量很少使用（详见第 6 条）。</p><p>　　<strong><em>不仅可以共享不可变的对象，而且可以共享内部信息</em></strong> 。 例如，BigInteger 类在内部使用符号数值表示法。 符号用 int 值表示，数值用 int 数组表示。 negate 方法生成了一个数值相同但符号相反的新 BigInteger 实例。 即使它是可变的，也不需要复制数组；新创建的 BigInteger 指向与原始相同的内部数组。</p><p>　　<strong><em>不可变对象为其他对象提供了很好的构件（building blocks）</em></strong>，无论是可变的还是不可变的。 如果知道一个复杂组件的内部对象不会发生改变，那么维护复杂对象的不变量就容易多了。这一原则的特例是，不可变对象可以构成 Map 对象的键和 Set 的元素，一旦不可变对象作为 Map 的键或 Set 里的元素，即使破坏了 Map 和 Set 的不可变性，但不用担心它们的值会发生变化。</p><p>　　<strong><em>不可变对象无偿地提供了的原子失败机制（详见第 76 条）</em></strong>。 它们的状态永远不会改变，所以不可能出现临时的不一致。</p><p>　　<strong><em>不可变类的主要缺点是对于每个不同的值都需要一个单独的对象</em></strong>。 创建这些对象可能代价很高，特别是是大型的对象下。 例如，假设你有一个百万位的 BigInteger ，你想改变它的低位：</p><pre><code>BigInteger moby = ...;moby = moby.flipBit(0);</code></pre><p>　　flipBit 方法创建一个新的 BigInteger 实例，也是一百万位长，与原始位置只有一位不同。 该操作需要与 BigInteger 大小成比例的时间和空间。 将其与 java.util.BitSet 对比。 像 BigInteger 一样，BitSet 表示一个任意长度的位序列，但与 BigInteger 不同，BitSet 是可变的。 BitSet 类提供了一种方法，允许你在固定时间内更改百万位实例中单个位的状态：</p><pre><code>BitSet moby = ...;moby.flip(0);</code></pre><p>　　如果执行一个多步操作，在每一步生成一个新对象，除最终结果之外丢弃所有对象，则性能问题会被放大。这里有两种方式来处理这个问题。第一种办法，先猜测一下会经常用到哪些多步的操作，然后讲它们作为基本类型提供。如果一个多步操作是作为一个基本类型提供的，那么不可变类就不必在每一步创建一个独立的对象。在内部，不可变的类可以是任意灵活的。 例如，BigInteger 有一个包级私有的可变的“伙伴类（companion class）”，它用来加速多步操作，比如模幂运算（modular exponentiation）。出于前面所述的所有原因，使用可变伙伴类比使用 BigInteger 要困难得多。 幸运的是，你不必使用它：BigInteger 类的实现者为你做了很多努力。</p><p>　　如果你可以准确预测客户端要在你的不可变类上执行哪些复杂的操作，那么包级私有可变伙伴类的方式可以正常工作。如果不是的话，那么最好的办法就是提供一个公开的可变伙伴类。 这种方法在 Java 平台类库中的主要例子是 String 类，它的可变伙伴类是 StringBuilder（及其过时的前身 StringBuffer 类）。</p><p>　　现在你已经知道如何创建一个不可改变类，并且了解不变性的优点和缺点，下面我们来讨论几个设计方案。 回想一下，为了保证不变性，一个类不得允许子类化。 这可以通过使类用 final 修饰，但是还有另外一个更灵活的选择。 而不是使不可变类设置为 final，<strong><em>可以使其所有的构造方法私有或包级私有，并添加公共静态工厂，而不是公共构造方法</em></strong>（详见第 1 条）。 为了具体说明这种方法，下面以 Complex 为例，看看如何使用这种方法：</p><pre><code>// Immutable class with static factories instead of constructorspublic class Complex {    private final double re;    private final double im;    private Complex(double re, double im) {        this.re = re;        this.im = im;    }    public static Complex valueOf(double re, double im) {        return new Complex(re, im);    }    ... // Remainder unchanged}</code></pre><p>　　这种方法往往是最好的选择。 这是最灵活的，因为它允许使用多个包级私有实现类。 对于驻留在包之外的客户端，不可变类实际上是 final 的，因为不可能继承来自另一个包的类，并且缺少公共或受保护的构造方法。 除了允许多个实现类的灵活性以外，这种方法还可以通过改进静态工厂的对象缓存功能来调整后续版本中类的性能。<br>　　当 BigInteger 和 BigDecimal 刚被编写出来的时候，“不可变类必须是 final”的说法还没有得到广泛地理解，因此它们的所有方法都可能被重写。不幸的是，为了保持向后兼容性，这一问题无法得以纠正。如果你编写一个安全性取决于来自不受信任的客户端的 BigInteger 或 BigDecimal 参数的不变类时，则必须检查该参数是否为“真实的”BigInteger 或者 BigDecimal，而不应该是不受信任的子类的实例。如果是后者，则必须在假设可能是可变的情况下保护性拷贝（defensively copy）（详见第 50 条）：</p><pre><code>public static BigInteger safeInstance(BigInteger val) {    return val.getClass() == BigInteger.class ?            val : new BigInteger(val.toByteArray());}</code></pre><p>　　在本条目开头关于不可变类的规则说明，没有方法可以修改对象，并且它的所有属性必须是 final 的。事实上，这些规则比实际需要的要强硬一些，其实可以有所放松来提高性能。 事实上，任何方法都不能在对象的状态中产生外部可见的变化。 然而，一些不可变类具有一个或多个非 final 属性，在第一次需要时将开销昂贵的计算结果缓存在这些属性中。 如果再次请求相同的值，则返回缓存的值，从而节省了重新计算的成本。 这个技巧的作用恰恰是因为对象是不可变的，这保证了如果重复的话，计算会得到相同的结果。</p><p>　　例如，PhoneNumber 类的 hashCode 方法（详见第 11 条）在第一次调用改方法时计算哈希码，并在再次调用时 对其进行缓存。 这种延迟初始化（详见第 83 条）的一个例子，String 类也使用到了。</p><p>　　关于序列化应该加上一个警告。 如果你选择使您的不可变类实现 Serializable 接口，并且它包含一个或多个引用可变对象的属性，则必须提供显式的 readObject 或 readResolve 方法，或者使用 ObjectOutputStream.writeUnshared 和 ObjectInputStream.readUnshared 方法，即默认的序列化形式也是可以接受的。 否则攻击者可能会创建一个可变的类的实例。 这个主题会在条目 88 中会详细介绍。</p><p>　　总而言之，坚决不要为每个属性编写一个 get 方法后再编写一个对应的 set 方法。<strong><em>除非有充分的理由使类成为可变类，否则类应该是不可变的</em></strong>。 不可变类提供了许多优点，唯一的缺点是在某些情况下可能会出现性能问题。 你应该始终使用较小的值对象（如 PhoneNumber 和 Complex），使其不可变。（Java 平台类库中有几个类，如 java.util.Date 和 java.awt.Point，本应该是不可变的，但实际上并不是）。你应该认真考虑创建更大的值对象，例如 String 和 BigInteger ，设成不可改变的。 只有当你确认有必要实现令人满意的性能（详见第 67 条）时，才应该为不可改变类提供一个公开的可变伙伴类。</p><p>　　对于一些类来说，不变性是不切实际的。<strong><em>如果一个类不能设计为不可变类，那么也要尽可能地限制它的可变性</em></strong> 。减少对象可以存在的状态数量，可以更容易地分析对象，以及降低出错的可能性。因此，除非有足够的理由把属性设置为非 final 的情况下，否则应该每个属性都设置为 final 的。把本条目的建议与条目 15 的建议结合起来，你自然的倾向就是：<strong><em>除非有充分的理由不这样做，否则应该把每个属性声明为私有 final 的</em></strong>。</p><p>　　<strong><em>构造方法应该创建完全初始化的对象，并建立所有的不变性。</em></strong> 除非有令人信服的理由，否则不要提供独立于构造方法或静态工厂的公共初始化方法。 同样，不要提供一个“reinitialize”方法，使对象可以被重用，就好像它是用不同的初始状态构建的。 这样的方法通常以增加的复杂度为代价，仅仅提供很少的性能优势。</p><p>　　CountDownLatch 类是这些原理的例证。 它是可变的，但它的状态空间有意保持最小范围内。 创建一个实例，使用它一次，并完成：一旦 countdown 锁的计数器已经达到零，不能再重用它。</p><p>　　在这个条目中，应该添加关于 Complex 类的最后一个注释。 这个例子只是为了说明不变性。 这不是一个工业强度复杂的复数实现。 它对复数使用了乘法和除法的标准公式，这些公式不正确会进行不正确的四舍五入，没有为复数的 NaN 和无穷大提供良好的语义[Kahan91，Smith62，Thomas94]。</p><h1 id="组合优于继承"><a href="#组合优于继承" class="headerlink" title="组合优于继承"></a>组合优于继承</h1><p>　　继承是实现代码重用的有效方式，但并不总是最好的工具。使用不当，会导致脆弱的软件。 在包中使用继承是安全的，其中子类和父类的实现都在同一个程序员的控制之下。对应专门为了继承而设计的，并且有文档说明的类来说（详见第 19 条），使用继承也是安全的。 然而，从普通的具体类跨越包级边界继承，是危险的。 提醒一下，本书使用「继承」一词，其含义是实现继承（当一个类扩展另一个类时）。 在本条目中讨论的问题不适用于接口继承（当类实现接口，或者当接口继承另一个接口时）。</p><p>　　<strong><em>与方法调用不同，继承打破了封装[Snyder86]</em></strong>。 换句话说，一个子类依赖于其父类的实现细节来保证其正确的功能。 父类的实现可能会从发布版本不断变化，如果是这样，子类可能会被破坏，即使它的代码没有任何改变。 因此，一个子类必须与其超类一起更新而变化，除非父类的作者为了继承的目的而专门设计它，并对应有文档的说明。</p><p>　　为了具体说明，假设有一个使用 HashSet 的程序。 为了调整程序的性能，需要查询 HashSet ，从创建它之后已经添加了多少个元素（不要和当前的元素数量混淆，当元素被删除时数量也会下降）。 为了提供这个功能，编写了一个 HashSet 变体，它保留了尝试元素插入的数量，并导出了这个插入数量的一个访问方法。 HashSet 类包含两个添加元素的方法，分别是 add 和 addAll，所以我们重写这两个方法：</p><pre><code>// Broken - Inappropriate use of inheritance!public class InstrumentedHashSet&lt;E&gt; extends HashSet&lt;E&gt; {    // The number of attempted element insertions    private int addCount = 0;    public InstrumentedHashSet() {    }    public InstrumentedHashSet(int initCap, float loadFactor) {        super(initCap, loadFactor);    }    @Override public boolean add(E e) {        addCount++;        return super.add(e);    }    @Override public boolean addAll(Collection&lt;? extends E&gt; c) {        addCount += c.size();        return super.addAll(c);    }    public int getAddCount() {        return addCount;    }}</code></pre><p>这个类看起来很合理，但是不能正常工作。 假设创建一个实例并使用 addAll 方法添加三个元素。 顺便提一句，请注意，下面代码使用在 Java 9 中添加的静态工厂方法 List.of 来创建一个列表；如果使用的是早期版本，请改为使用 Arrays.asList：</p><pre><code>InstrumentedHashSet&lt;String&gt; s = new InstrumentedHashSet&lt;&gt;();s.addAll(List.of(&quot;Snap&quot;, &quot;Crackle&quot;, &quot;Pop&quot;));</code></pre><p>　　我们期望 getAddCount 方法返回的结果是 3，但实际上返回了 6。哪里出来问题？在 HashSet 内部，addAll 方法是基于它的 add 方法来实现的，即使 HashSet 文档中没有指名其实现细节，倒也是合理的。InstrumentedHashSet 中的 addAll 方法首先给 addCount 属性设置为 3，然后使用 super.addAll 方法调用了 HashSet 的 addAll 实现。然后反过来又调用在 InstrumentedHashSet 类中重写的 add 方法，每个元素调用一次。这三次调用又分别给 addCount 加 1，所以，一共增加了 6：通过 addAll 方法每个增加的元素都被计算了两次。</p><p>　　我们可以通过消除 addAll 方法的重写来“修复”子类。 尽管生成的类可以正常工作，但是它依赖于它的正确方法，因为 HashSet 的 addAll 方法是在其 add 方法之上实现的。 这个“自我使用（self-use）”是一个实现细节，并不保证在 Java 平台的所有实现中都可以适用，并且可以随发布版本而变化。 因此，产生的 InstrumentedHashSet 类是脆弱的。</p><p>　　稍微好一点的做法是，重写 addAll 方法遍历指定集合，为每个元素调用 add 方法一次。 不管 HashSet 的 addAll 方法是否在其 add 方法上实现，都会保证正确的结果，因为 HashSet 的 addAll 实现将不再被调用。然而，这种技术并不能解决所有的问题。 这相当于重新实现了父类方法，这样的方法可能不能确定到底是否《时》自用（self-use）的，实现起来也是困难的，耗时的，容易出错的，并且可能会降低性能。 此外，这种方式并不能总是奏效，因为子类无法访问一些私有属性，所以有些方法就无法实现。</p><p>　　导致子类脆弱的一个相关原因是，它们的父类在后续的发布版本中可以添加新的方法。假设一个程序的安全性依赖于这样一个事实：所有被插入到集中的元素都满足一个先决条件。可以通过对集合进行子类化，然后并重写所有添加元素的方法，以确保在添加每个元素之前满足这个先决条件，来确保这一问题。如果在后续的版本中，父类没有新增添加元素的方法，那么这样做没有问题。但是，一旦父类增加了这样的新方法，则很有可能由于调用了未被重写的新方法，将非法的元素添加到子类的实例中。这不是个纯粹的理论问题。在把 Hashtable 和 Vector 类加入到 Collections 框架中的时候，就修复了几个类似性质的安全漏洞。</p><p>　　这两个问题都源于重写方法。 如果仅仅添加新的方法并且不要重写现有的方法，可能会认为继承一个类是安全的。 虽然这种扩展更为安全，但这并非没有风险。 如果父类在后续版本中添加了一个新的方法，并且你不幸给了子类一个具有相同签名和不同返回类型的方法，那么你的子类编译失败[JLS，8.4.8.3]。 如果已经为子类提供了一个与新的父类方法具有相同签名和返回类型的方法，那么你现在正在重写它，因此将遇到前面所述的问题。 此外，你的方法是否会履行新的父类方法的约定，这是值得怀疑的，因为在你编写子类方法时，这个约定还没有写出来。</p><p>　　幸运的是，有一种方法可以避免上述所有的问题。<strong><em>不要继承一个现有的类，而应该给你的新类增加一个私有属性，该属性是 现有类的实例引用，这种设计被称为组合（composition）</em></strong>，因为现有的类成为新类的组成部分。<strong><em>新类中的每个实例方法调用现有类的包含实例上的相应方法并返回结果。这被称为转发（forwarding），而新类中的方法被称为转发方法</em></strong>。由此产生的类将坚如磐石，不依赖于现有类的实现细节。即使将新的方法添加到现有的类中，也不会对新类产生影响。为了具体说用，下面代码使用组合和转发方法替代 InstrumentedHashSet 类。请注意，实现分为两部分，类本身和一个可重用的转发类，其中包含所有的转发方法，没有别的方法：</p><pre><code>// Reusable forwarding classimport java.util.Collection;import java.util.Iterator;import java.util.Set;public class ForwardingSet&lt;E&gt; implements Set&lt;E&gt; {    private final Set&lt;E&gt; s;    public ForwardingSet(Set&lt;E&gt; s) {        this.s = s;    }    public void clear() {        s.clear();    }    public boolean contains(Object o) {        return s.contains(o);    }    public boolean isEmpty() {        return s.isEmpty();    }    public int size() {        return s.size();    }    public Iterator&lt;E&gt; iterator() {        return s.iterator();    }    public boolean add(E e) {        return s.add(e);    }    public boolean remove(Object o) {        return s.remove(o);    }    public boolean containsAll(Collection&lt;?&gt; c) {        return s.containsAll(c);    }    public boolean addAll(Collection&lt;? extends E&gt; c) {        return s.addAll(c);    }    public boolean removeAll(Collection&lt;?&gt; c) {        return s.removeAll(c);    }    public boolean retainAll(Collection&lt;?&gt; c) {        return s.retainAll(c);    }    public Object[] toArray() {        return s.toArray();    }    public &lt;T&gt; T[] toArray(T[] a) {        return s.toArray(a);    }    @Override    public boolean equals(Object o) {        return s.equals(o);    }    @Override    public int hashCode() {        return s.hashCode();    }    @Override    public String toString() {        return s.toString();    }}// Wrapper class - uses composition in place of inheritanceimport java.util.Collection;import java.util.Set;public class InstrumentedSet&lt;E&gt; extends ForwardingSet&lt;E&gt; {    private int addCount = 0;    public InstrumentedSet(Set&lt;E&gt; s) {        super(s);    }    @Override public boolean add(E e) {        addCount++;        return super.add(e);    }    @Override public boolean addAll(Collection&lt;? extends E&gt; c) {        addCount += c.size();        return super.addAll(c);    }    public int getAddCount() {        return addCount;    }}</code></pre><p>InstrumentedSet 类的设计是通过存在的 Set 接口来实现的，该接口包含 HashSet 类的功能特性。除了功能强大，这个设计是非常灵活的。InstrumentedSet 类实现了 Set 接口，并有一个构造方法，其参数也是 Set 类型的。本质上，这个类把 Set 转换为另一个类型 Set， 同时添加了计数的功能。与基于继承的方法不同，该方法仅适用于单个具体类，并且父类中每个需要支持构造方法，提供单独的构造方法，所以可以使用包装类来包装任何 Set 实现，并且可以与任何预先存在的构造方法结合使用：</p><pre><code>Set&lt;Instant&gt; times = new InstrumentedSet&lt;&gt;(new TreeSet&lt;&gt;(cmp));Set&lt;E&gt; s = new InstrumentedSet&lt;&gt;(new HashSet&lt;&gt;(INIT_CAPACITY));</code></pre><p>　　InstrumentedSet 类甚至可以用于临时替换没有计数功能下使用的集合实例：</p><pre><code>static void walk(Set&lt;Dog&gt; dogs) {    InstrumentedSet&lt;Dog&gt; iDogs = new InstrumentedSet&lt;&gt;(dogs);    ... // Within this method use iDogs instead of dogs}</code></pre><p>　　InstrumentedSet 类被称为包装类，因为每个 InstrumentedSet 实例都包含（“包装”）另一个 Set 实例。 这也被称为装饰器模式[Gamma95]，因为 InstrumentedSet 类通过添加计数功能来“装饰”一个集合。 有时组合和转发的结合被不精确地地称为委托（delegation）。 从技术上讲，除非包装对象把自身传递给被包装对象，否则不是委托[Lieberman86; Gamma95]。</p><p>　　包装类的缺点很少。 一个警告是包装类不适合在回调框架（callback frameworks）中使用，其中对象将自我引用传递给其他对象以用于后续调用（「回调」）。 因为一个被包装的对象不知道它外面的包装对象，所以它传递一个指向自身的引用（this），回调时并不记得外面的包装对象。 这被称为 SELF 问题[Lieberman86]。 有些人担心转发方法调用的性能影响，以及包装对象对内存占用。 两者在实践中都没有太大的影响。 编写转发方法有些繁琐，但是只需为每个接口编写一次可重用的转发类，并且提供转发类。 例如，Guava 为所有的 Collection 接口提供转发类[Guava]。</p><p>　　只有在子类真的是父类的子类型的情况下，继承才是合适的。 换句话说，只有在两个类之间存在「is-a」关系的情况下，B 类才能继承 A 类。 如果你试图让 B 类继承 A 类时，问自己这个问题：每个 B 都是 A 吗？ 如果你不能如实回答这个问题，那么 B 就不应该继承 A。如果答案是否定的，那么 B 通常包含一个 A 的私有实例，并且暴露一个不同的 API ：A 不是 B 的重要部分 ，只是其实现细节。</p><p>　　在 Java 平台类库中有一些明显的违反这个原则的情况。 例如，stacks 实例并不是 vector 实例，所以 Stack 类不应该继承 Vector 类。 同样，一个属性列表不是一个哈希表，所以 Properties 不应该继承 Hashtable 类。 在这两种情况下，组合方式更可取。</p><p>　　如果在合适组合的地方使用继承，则会不必要地公开实现细节。由此产生的 API 将与原始实现联系在一起，永远限制类的性能。更严重的是，通过暴露其内部，客户端可以直接访问它们。至少，它可能导致混淆语义。例如，属性 p 指向 Properties 实例，那么 p.getProperty(key) 和 p.get(key) 就有可能返回不同的结果：前者考虑了默认的属性表，而后者是继承 Hashtable 的，它则没有考虑默认属性列表。最严重的是，客户端可以通过直接修改超父类来破坏子类的不变性。在 Properties 类，设计者希望只有字符串被允许作为键和值，但直接访问底层的 Hashtable 允许违反这个不变性。一旦违反，就不能再使用属性 API 的其他部分（load 和 store 方法）。在发现这个问题的时候，纠正这个问题为时已晚，因为客户端依赖于使用非字符串键和值了。</p><p>　　在决定使用继承来代替组合之前，你应该问自己最后一组问题。对于试图继承的类，它的 API 有没有缺陷呢？ 如果有，你是否愿意将这些缺陷传播到你的类的 API 中？继承传播父类的 API 中的任何缺陷，而组合可以让你设计一个隐藏这些缺陷的新 API。</p><p>　　总之，继承是强大的，但它是有问题的，因为它违反封装。 只有在子类和父类之间存在真正的子类型关系时才适用。 即使如此，如果子类与父类不在同一个包中，并且父类不是为继承而设计的，继承可能会导致脆弱性。 为了避免这种脆弱性，使用合成和转发代替继承，特别是如果存在一个合适的接口来实现包装类。 包装类不仅比子类更健壮，而且更强大。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="http://sjsdfg.gitee.io/effective-java-3rd-chinese/#/notes/17.%20%E6%9C%80%E5%B0%8F%E5%8C%96%E5%8F%AF%E5%8F%98%E6%80%A7" target="_blank" rel="noopener">http://sjsdfg.gitee.io/effective-java-3rd-chinese/#/notes/17.%20%E6%9C%80%E5%B0%8F%E5%8C%96%E5%8F%AF%E5%8F%98%E6%80%A7</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第四章阅读：类和接口&lt;/p&gt;
&lt;p&gt;17.最小化可变性&lt;br&gt;18.组合优于继承&lt;br&gt;灵魂三问：&lt;br&gt;　如果你试图让 B 类继承 A 类时，问自己这个问题：每个 B 都是 A 吗？ 如果你不能如实回答这个问题，那么 B 就不应该继承 A。在决定使用继承来代替组合之前，你应该问自己最后一组问题。对于试图继承的类，它的 API 有没有缺陷呢？ 如果有，你是否愿意将这些缺陷传播到你的类的 API 中？继承传播父类的 API 中的任何缺陷，而组合可以让你设计一个隐藏这些缺陷的新 API。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Effctive-Java阅读笔记VIII</title>
    <link href="http://yoursite.com/2020/01/16/Effctive-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0VIII/"/>
    <id>http://yoursite.com/2020/01/16/Effctive-Java阅读笔记VIII/</id>
    <published>2020-01-16T03:07:12.000Z</published>
    <updated>2020-01-16T08:24:21.651Z</updated>
    
    <content type="html"><![CDATA[<p>第四章阅读：类和接口</p><p>15.使类和成员的可访问性最小化<br>16.在公共类中使用访问方法而不是公共属性</p><a id="more"></a><h1 id="使类和成员的可访问性最小化"><a href="#使类和成员的可访问性最小化" class="headerlink" title="使类和成员的可访问性最小化"></a>使类和成员的可访问性最小化</h1><p>将设计良好的组件与设计不佳的组件区分开来的最重要的因素是，隐藏内部数据和其他实现细节的程度。一个设计良好的组件隐藏了它的所有实现细节，干净地将它的 API 与它的实现分离开来。然后，组件只通过它们的 API 进行通信，并且对彼此的内部工作一无所知。这一概念，被称为信息隐藏或封装，是软件设计的基本原则[Parnas72]。</p><p>　　信息隐藏很重要有很多原因，其中大部分来源于它将组成系统的组件分离开来，允许它们被独立地开发，测试，优化，使用，理解和修改。这加速了系统开发，因为组件可以并行开发。它减轻了维护的负担，因为可以更快速地理解组件，调试或更换组件，而不用担心损害其他组件。虽然信息隐藏本身并不会导致良好的性能，但它可以有效地进行性能调整：一旦系统完成并且分析确定了哪些组件导致了性能问题（条目 67），则可以优化这些组件，而不会影响别人的正确的组件。信息隐藏增加了软件重用，因为松耦合的组件通常在除开发它们之外的其他环境中证明是有用的。最后，隐藏信息降低了构建大型系统的风险，因为即使系统不能运行，各个独立的组件也可能是可用的。</p><p>　　Java 提供了许多机制来帮助信息隐藏。 <strong><em>访问控制机制（access control mechanism）</em></strong>[JLS，6.6] 指定了类，接口和成员的可访问性。 实体的可访问性取决于其声明的位置，以及声明中存在哪些访问修饰符（private，protected 和 public）。 正确使用这些修饰符对信息隐藏至关重要。</p><p>　　经验法则很简单： <strong><em>让每个类或成员尽可能地不可访问</em></strong>。 换句话说，使用尽可能低的访问级别，与你正在编写的软件的对应功能保持一致。</p><p>　　对于顶层（非嵌套的）类和接口，只有两个可能的访问级别：包级私有（package-private）和公共的（public）。如果你使用 public 修饰符声明顶级类或接口，那么它是公开的；否则，它是包级私有的。如果一个顶层类或接口可以被做为包级私有，那么它应该是。通过将其设置为包级私有，可以将其作为实现的一部分，而不是导出的 API，你可以修改它、替换它，或者在后续版本中消除它，而不必担心损害现有的客户端。如果你把它公开，你就有义务永远地支持它，以保持兼容性。</p><p>　　如果一个包级私有顶级类或接口只被一个类使用，那么可以考虑这个类作为使用它的唯一类的私有静态嵌套类 （详见第 24 条）。这将它的可访问性从包级的所有类减少到使用它的一个类。但是，减少不必要的公共类的可访问性要比包级私有的顶级类更重要：公共类是包的 API 的一部分，而包级私有的顶级类已经是这个包实现的一部分了。</p><p>　　对于成员（字段、方法、嵌套类和嵌套接口），有四种可能的访问级别，在这里，按照可访问性从小到大列出：</p><h2 id="private"><a href="#private" class="headerlink" title="private"></a>private</h2><p>—— 该成员只能在声明它的顶级类内访问。</p><h2 id="package-private"><a href="#package-private" class="headerlink" title="package-private"></a>package-private</h2><p>—— 成员可以从被声明的包中的任何类中访问。从技术上讲，如果没有指定访问修饰符（接口成员除外，它默认是公共的），这是默认访问级别。</p><h2 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h2><p>—— 成员可以从被声明的类的子类中访问（会受一些限制 [JLS, 6.6.2]），以及它声明的包中的任何类。</p><h2 id="public"><a href="#public" class="headerlink" title="public"></a>public</h2><p>—— 该成员可以从任何地方被访问。<br>　　在仔细设计你的类的公共 API 之后，你的反应应该是让所有其他成员设计为私有的。 只有当同一个包中的其他类真的需要访问成员时，需要删除私有修饰符，从而使成员包成为包级私有的。 如果你发现自己经常这样做，你应该重新检查你的系统的设计，看看另一个分解可能产生更好的解耦的类。 也就是说，私有成员和包级私有成员都是类实现的一部分，通常不会影响其导出的 API。 但是，如果类实现 Serializable 接口（详见第 86 和 87 条），则这些字段可以「泄漏（leak）」到导出的 API 中。</p><p>　　对于公共类的成员，当访问级别从包私有到受保护级时，可访问性会大大增加。 受保护（protected）的成员是类导出的 API 的一部分，并且必须永远支持。 此外，导出类的受保护成员表示对实现细节的公开承诺（详见第 19 条）。 对受保护成员的需求应该相对较少。</p><p>　　有一个关键的规则限制了你减少方法访问性的能力。 如果一个方法重写一个超类方法，那么它在子类中的访问级别就不能低于父类中的访问级别[JLS，8.4.8.3]。 这对于确保子类的实例在父类的实例可用的地方是可用的（Liskov 替换原则，见条目 15）是必要的。 如果违反此规则，编译器将在尝试编译子类时生成错误消息。 这个规则的一个特例是，如果一个类实现了一个接口，那么接口中的所有类方法都必须在该类中声明为 public。</p><p>　　为了便于测试你的代码，你可能会想要让一个类，接口或者成员更容易被访问。 这没问题。 为了测试将公共类的私有成员指定为包级私有是可以接受的，但是提高到更高的访问级别却是不可接受的。 换句话说，将类，接口或成员作为包级导出的 API 的一部分来促进测试是不可接受的。 幸运的是，这不是必须的，因为测试可以作为被测试包的一部分运行，从而获得对包私有元素的访问。</p><p>　　<strong><em>公共类的实例字段很少情况下采用 public 修饰</em></strong>（详见第 16 条）。 如果一个实例字段是非 final 的，或者是对可变对象的引用，那么通过将其公开，你就放弃了限制可以存储在字段中的值的能力。这意味着你放弃了执行涉及该字段的不变量的能力。另外，当字段被修改时，就放弃了采取任何操作的能力，<strong><em>因此带有公共可变字段的类通常不是线程安全的</em></strong> 。即使一个字段是 final 的，并且引用了一个不可变的对象，通过将其公开，你放弃了切换到一个新的内部数据表示的灵活性，而该字段并不存在。</p><p>　　同样的建议适用于静态字段，但有一个例外。 假设常量是类的抽象的一个组成部分，你可以通过 public static final 字段暴露常量。 按照惯例，这些字段的名字由大写字母组成，字母用下划线分隔（详见第 68 条）。 很重要的一点是，这些字段包含基本类型的值或对不可变对象的引用（详见第 17 条）。 包含对可变对象的引用的字段具有非 final 字段的所有缺点。 虽然引用不能被修改，但引用的对象可以被修改，并会带来灾难性的结果。</p><p>　　请注意，非零长度的数组总是可变的，<strong><em>所以类具有公共静态 final 数组字段，或返回这样一个字段的访问器是错误的</em></strong>。 如果一个类有这样的字段或访问方法，客户端将能够修改数组的内容。 这是安全漏洞的常见来源：</p><pre><code>// Potential security hole!public static final Thing[] VALUES = { ... };</code></pre><p>要小心这样的事实，一些 IDE 生成的访问方法返回对私有数组字段的引用，导致了这个问题。 有两种方法可以解决这个问题。 你可以使公共数组私有并添加一个公共的不可变列表：</p><pre><code>private static final Thing[] PRIVATE_VALUES = { ... };public static final List&lt;Thing&gt; VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));</code></pre><p>或者，可以将数组设置为 private，并添加一个返回私有数组拷贝的公共方法：</p><pre><code>private static final Thing[] PRIVATE_VALUES = { ... };public static final Thing[] values() {    return PRIVATE_VALUES.clone();}</code></pre><p>   要在这些方法之间进行选择，请考虑客户端可能如何处理返回的结果。 哪种返回类型会更方便？ 哪个会更好的表现？</p><p>　　在 Java 9 中，作为模块系统（module system）的一部分引入了两个额外的隐式访问级别。模块包含一组包，就像一个包包含一组类一样。模块可以通过模块声明中的导出（export）声明显式地导出某些包 (这是 module-info.java 的源文件中包含的约定)。模块中的未导出包的公共和受保护成员在模块之外是不可访问的；在模块中，可访问性不受导出（export）声明的影响。使用模块系统允许你在模块之间共享类，而不让它们对整个系统可见。在未导出的包中，公共和受保护的公共类的成员会产生两个隐式访问级别，这是普通公共和受保护级别的内部类似的情况。这种共享的需求是相对少见的，并且可以通过重新安排包中的类来消除。</p><p>　　与四个主要访问级别不同，这两个基于模块的级别主要是建议（advisory）。 如果将模块的 JAR 文件放在应用程序的类路径而不是其模块路径中，那么模块中的包将恢复为非模块化行为：包的公共类的所有公共类和受保护成员都具有其普通的可访问性，不管包是否由模块导出[Reinhold，1.2]。 新引入的访问级别严格执行的地方是 JDK 本身：Java 类库中未导出的包在模块之外真正无法访问。</p><p>　　对于典型的 Java 程序员来说，不仅程序模块所提供的访问保护存在局限性，而且在本质上是很大程度上建议性的；为了利用它，你必须把你的包组合成模块，在模块声明中明确所有的依赖关系，重新安排你的源码树层级，并采取特殊的行动来适应你的模块内任何对非模块化包的访问[Reinhold, 3]。 现在说模块是否会在 JDK 之外得到广泛的使用还为时尚早。 与此同时，除非你有迫切的需要，否则似乎最好避免它们。</p><p>　　总而言之，应该尽可能地减少程序元素的可访问性（在合理范围内）。 在仔细设计一个最小化的公共 API 之后，你应该防止任何散乱的类，接口或成员成为 API 的一部分。 除了作为常量的公共静态 final 字段之外，公共类不应该有公共字段。 确保 public static final 字段引用的对象是不可变的。</p><h1 id="在公共类中使用访问方法而不是公共属性"><a href="#在公共类中使用访问方法而不是公共属性" class="headerlink" title="在公共类中使用访问方法而不是公共属性"></a>在公共类中使用访问方法而不是公共属性</h1><p>有时候，你可能会试图写一些退化的类（degenerate classes），除了集中实例属性之外别无用处：</p><pre><code>// Degenerate classes like this should not be public!class Point {    public double x;    public double y;}</code></pre><p>由于这些类的数据属性可以直接被访问，因此这些类不提供封装的好处（详见第 15 条）。 如果不更改 API，则无法更改其表示形式，无法强制执行不变量，并且在访问属性时无法执行辅助操作。 坚持面向对象的程序员觉得这样的类是厌恶的，应该被具有私有属性和公共访问方法的类（getter）所取代，而对于可变类来说，它们应该被替换为 setter 设值方法：</p><pre><code>// Encapsulation of data by accessor methods and mutatorsclass Point {    private double x;    private double y;    public Point(double x, double y) {        this.x = x;        this.y = y;    }    public double getX() { return x; }    public double getY() { return y; }    public void setX(double x) { this.x = x; }    public void setY(double y) { this.y = y; }}</code></pre><p>　　当然，对于公共类来说，坚持面向对象是正确的：如果一个类在其包之外是可访问的，则提供访问方法来保留更改类内部表示的灵活性。 如果一个公共类暴露其数据属性，那么以后更改其表示形式基本上没有可能，因为客户端代码可以散布在很多地方。</p><p>　　但是，如果一个类是包级私有的，或者是一个私有的内部类，那么暴露它的数据属性就没有什么本质上的错误——假设它们提供足够描述该类提供的抽象。 在类定义和使用它的客户端代码中，这种方法比访问方法产生更少的视觉混乱。 虽然客户端代码绑定到类的内部表示，但是这些代码仅限于包含该类的包。 如果类的内部表示是可取的，可以在不触碰包外的任何代码的情况下进行更改。 在私有内部类的情况下，更改作用范围进一步限制在封闭类中。</p><p>　　Java 平台类库中的几个类违反了公共类不应直接暴露属性的建议。 著名的例子包括 java.awt 包中的 Point 和 Dimension 类。 这些类别应该被视为警示性的示例，而不是模仿的例子。 如条目 67 所述，时至今日，暴露 Dimension 的内部结构的决定仍然导致着严重的性能问题。</p><p>　　虽然公共类直接暴露属性并不是一个好主意，但是如果属性是不可变的，那么危害就不那么大了。当一个属性是只读的时候，除了更改类的 API 外，你不能改变类的内部表示形式，也不能采取一些辅助的行为，但是可以加强不变性。例如，下面的例子中保证每个实例表示一个有效的时间：</p><pre><code>// Public class with exposed immutable fields - questionablepublic final class Time {    private static final int HOURS_PER_DAY    = 24;    private static final int MINUTES_PER_HOUR = 60;    public final int hour;    public final int minute;    public Time(int hour, int minute) {        if (hour &lt; 0 || hour &gt;= HOURS_PER_DAY)           throw new IllegalArgumentException(&quot;Hour: &quot; + hour);        if (minute &lt; 0 || minute &gt;= MINUTES_PER_HOUR)           throw new IllegalArgumentException(&quot;Min: &quot; + minute);        this.hour = hour;        this.minute = minute;    }    ... // Remainder omitted}</code></pre><p>　　总之，公共类不应该暴露可变属性。 公共类暴露不可变属性的危害虽然仍然存在问题，但其危害较小。 然而，有时需要包级私有或私有内部类来暴露属性，无论此类是否是可变的。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="http://sjsdfg.gitee.io/effective-java-3rd-chinese/#/notes/15.%20%E4%BD%BF%E7%B1%BB%E5%92%8C%E6%88%90%E5%91%98%E7%9A%84%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%80%A7%E6%9C%80%E5%B0%8F%E5%8C%96" target="_blank" rel="noopener">http://sjsdfg.gitee.io/effective-java-3rd-chinese/#/notes/15.%20%E4%BD%BF%E7%B1%BB%E5%92%8C%E6%88%90%E5%91%98%E7%9A%84%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%80%A7%E6%9C%80%E5%B0%8F%E5%8C%96</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第四章阅读：类和接口&lt;/p&gt;
&lt;p&gt;15.使类和成员的可访问性最小化&lt;br&gt;16.在公共类中使用访问方法而不是公共属性&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Hexo的spfk主题修改</title>
    <link href="http://yoursite.com/2020/01/15/Hexo%E7%9A%84spfk%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9/"/>
    <id>http://yoursite.com/2020/01/15/Hexo的spfk主题修改/</id>
    <published>2020-01-15T03:34:12.000Z</published>
    <updated>2020-01-15T10:48:39.628Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo的spfk主题修改：添加字数统计和阅读时长，添加网站运行时间，访问量统计，添加live2d卡通人物</p><a id="more"></a><p>新年新气象，使用Hexo的spfk主题博客很久了，想要做一些主题上的改动，准备在保持简洁风格前提下适当加一些有趣的小功能。</p><h1 id="添加字数统计和阅读时长"><a href="#添加字数统计和阅读时长" class="headerlink" title="添加字数统计和阅读时长"></a>添加字数统计和阅读时长</h1><p>先在博客目录下执行以下命令安装 hexo-wordcount 插件：</p><pre><code>$ npm i --save hexo-wordcount</code></pre><p>同样的，以 spfk 主题为例，在 \themes\hexo-theme-spfk\layout_partial\post 目录下创建 word.ejs 文件，在 word.ejs 文件中写入以下代码：</p><pre><code>&lt;div style=&quot;margin-top:10px;&quot;&gt;    &lt;span class=&quot;post-time&quot;&gt;      &lt;span class=&quot;post-meta-item-icon&quot;&gt;        &lt;i class=&quot;fa fa-keyboard-o&quot;&gt;&lt;/i&gt;        &lt;span class=&quot;post-meta-item-text&quot;&gt;  字数统计: &lt;/span&gt;        &lt;span class=&quot;post-count&quot;&gt;&lt;%= wordcount(post.content) %&gt;字&lt;/span&gt;      &lt;/span&gt;    &lt;/span&gt;    &amp;nbsp; | &amp;nbsp;    &lt;span class=&quot;post-time&quot;&gt;      &lt;span class=&quot;post-meta-item-icon&quot;&gt;        &lt;i class=&quot;fa fa-hourglass-half&quot;&gt;&lt;/i&gt;        &lt;span class=&quot;post-meta-item-text&quot;&gt;  阅读时长: &lt;/span&gt;        &lt;span class=&quot;post-count&quot;&gt;&lt;%= min2read(post.content) %&gt;分&lt;/span&gt;      &lt;/span&gt;    &lt;/span&gt;&lt;/div&gt;</code></pre><p>然后在 \themes\hexo-theme-spfk\layout_partial\article.ejs 中适当位置添加以下代码：<br>添加前：</p><pre><code>&lt;% if (post.link || post.title){ %&gt;  &lt;header class=&quot;article-header&quot;&gt;    &lt;%- partial(&apos;post/title&apos;, {class_name: &apos;article-title&apos;}) %&gt;  &lt;/header&gt;</code></pre><p>添加后：</p><pre><code>&lt;% if (post.link || post.title){ %&gt;  &lt;header class=&quot;article-header&quot;&gt;    &lt;%- partial(&apos;post/title&apos;, {class_name: &apos;article-title&apos;}) %&gt;  &lt;% if(theme.word_count &amp;&amp; !post.no_word_count){ %&gt;    &lt;%- partial(&apos;post/word&apos;) %&gt;    &lt;% } %&gt;  &lt;/header&gt;</code></pre><p>最后在主题目录下的 _config.yml 添加以下配置</p><pre><code>word_count: true</code></pre><p>另外：要在博客底部显示所有文章的总字数，可以点击此处，根据你博客底部文件的类型选择相应的代码放在适当的位置即可，前提是要安装好 hexo-wordcount 插件，例如我使用 spfk 主题，在 \themes\material-x\layout_partial 目录下的 footer.ejs 文件中添加如下代码：</p><pre><code>&lt;i class=&quot;fas fa-chart-area&quot;&gt;&lt;/i&gt;&lt;span class=&quot;post-count&quot;&gt;字数统计：&lt;%= totalcount(site) %&gt;&lt;/span&gt;</code></pre><p>添加前的位置：</p><pre><code>&lt;div class=&quot;outer&quot;&gt;    &lt;div id=&quot;footer-info&quot;&gt;        &lt;div class=&quot;footer-left&quot;&gt;            &amp;copy; &lt;%= date(new Date(), &apos;YYYY&apos;) %&gt; &lt;%= config.author || config.title %&gt;        &lt;/div&gt;        &lt;div class=&quot;footer-right&quot;&gt;            &lt;a href=&quot;http://hexo.io/&quot; target=&quot;_blank&quot;&gt;Hexo&lt;/a&gt;  Theme &lt;a href=&quot;https://github.com/luuman/hexo-theme-spfk&quot; target=&quot;_blank&quot;&gt;spfk&lt;/a&gt; by luuman        &lt;/div&gt;    &lt;/div&gt;</code></pre><p>添加后的位置：</p><pre><code>&lt;div class=&quot;outer&quot;&gt;    &lt;div id=&quot;footer-info&quot;&gt;        &lt;div class=&quot;footer-left&quot;&gt;            &amp;copy; &lt;%= date(new Date(), &apos;YYYY&apos;) %&gt; &lt;%= config.author || config.title %&gt;        &lt;/div&gt;        &lt;i class=&quot;fas fa-chart-area&quot;&gt;&lt;/i&gt;            &lt;span class=&quot;post-count&quot;&gt;总字数：&lt;%= totalcount(site) %&gt;&lt;/span&gt;        &lt;div class=&quot;footer-right&quot;&gt;            &lt;a href=&quot;http://hexo.io/&quot; target=&quot;_blank&quot;&gt;Hexo&lt;/a&gt;  Theme &lt;a href=&quot;https://github.com/luuman/hexo-theme-spfk&quot; target=&quot;_blank&quot;&gt;spfk&lt;/a&gt; by luuman        &lt;/div&gt;    &lt;/div&gt;</code></pre><h1 id="添加网站运行时间"><a href="#添加网站运行时间" class="headerlink" title="添加网站运行时间"></a>添加网站运行时间</h1><p>一个比较好的小功能，可以看见自己的博客运行多久了，时间一天天的增加，成就感也会一天天增加的<br>在 \themes\hexo-theme-spfk\layout_partial\footer.ejs 文件下添加以下代码：</p><pre><code>&lt;span id=&quot;timeDate&quot;&gt;载入天数...&lt;/span&gt;&lt;span id=&quot;times&quot;&gt;载入时分秒...&lt;/span&gt;&lt;script&gt;    var now = new Date();    function createtime() {        var grt= new Date(&quot;11/16/2017 21:14:20&quot;);//在此处修改你的建站时间，格式：月/日/年 时:分:秒        now.setTime(now.getTime()+250);        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);        if(String(hnum).length ==1 ){hnum = &quot;0&quot; + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = &quot;0&quot; + mnum;}        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = &quot;0&quot; + snum;}        document.getElementById(&quot;timeDate&quot;).innerHTML = &quot;本站已安全运行 &quot;+dnum+&quot; 天 &quot;;        document.getElementById(&quot;times&quot;).innerHTML = hnum + &quot; 小时 &quot; + mnum + &quot; 分 &quot; + snum + &quot; 秒&quot;;    }setInterval(&quot;createtime()&quot;,250);&lt;/script&gt;</code></pre><h1 id="访问量统计"><a href="#访问量统计" class="headerlink" title="访问量统计"></a>访问量统计</h1><p>使用不蒜子提供的服务，因为其域名更改，所以把原有的：</p><pre><code>&lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</code></pre><p>域名改一下即可：</p><pre><code>&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</code></pre><h1 id="安装脚本（必选）"><a href="#安装脚本（必选）" class="headerlink" title="安装脚本（必选）"></a>安装脚本（必选）</h1><p>要使用不蒜子必须在页面中引入busuanzi.js，目前最新版如下。</p><pre><code>&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</code></pre><p>不蒜子可以给任何类型的个人站点使用，如果是用的hexo，打开themes/主题/layout/_partial/footer.ejs添加上述脚本即可，当然你也可以添加到 header 中。</p><h1 id="安装标签（可选）"><a href="#安装标签（可选）" class="headerlink" title="安装标签（可选）"></a>安装标签（可选）</h1><p>只需要复制相应的html标签到网站要显示访问量的位置即可。可以随意更改不蒜子标签为自己喜欢的显示效果，内容参考第三部分扩展开发。根据要显示内容的不同，这分几种情况。</p><h2 id="显示站点总访问量"><a href="#显示站点总访问量" class="headerlink" title="显示站点总访问量"></a>显示站点总访问量</h2><p>要显示站点总访问量，复制以下代码添加到你需要显示的位置。有两种算法可选：</p><p>算法a：pv的方式，单个用户连续点击n篇文章，记录n次访问量。</p><pre><code>&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;    本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt;</code></pre><p>算法b：uv的方式，单个用户连续点击n篇文章，只记录1次访客数。</p><pre><code>&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;  本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次&lt;/span&gt;</code></pre><p>如果你是用的hexo，打开themes/主题/layout/_partial/footer.ejs添加即可。</p><h1 id="显示单页面访问量"><a href="#显示单页面访问量" class="headerlink" title="显示单页面访问量"></a>显示单页面访问量</h1><p>要显示每篇文章的访问量，复制以下代码添加到需要显示的位置。</p><p>算法：pv的方式，单个用户点击1篇文章，本篇文章记录1次阅读量。</p><pre><code>&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt;  本文总阅读量&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt;</code></pre><p>代码中文字是可以修改的，只要保留id正确即可。</p><h1 id="Hexo博客添加live2d卡通人物"><a href="#Hexo博客添加live2d卡通人物" class="headerlink" title="Hexo博客添加live2d卡通人物"></a>Hexo博客添加live2d卡通人物</h1><p>因为之前自己对卡通形象不太感冒所以没有在博客里加入卡通人物，这次在live2d里找到了几个还比较有趣的形象。<br>参见：<br><a href="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md" target="_blank" rel="noopener">https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md</a><br>Hexo</p><h2 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块:"></a>安装模块:</h2><pre><code>npm install --save hexo-helper-live2d</code></pre><h2 id="配置："><a href="#配置：" class="headerlink" title="配置："></a>配置：</h2><p>请向Hexo的_config.yml 文件或主题的_config.yml 文件中添加配置:</p><pre><code>live2d:  enable: true  scriptFrom: local  pluginRootPath: live2dw/  pluginJsPath: lib/  pluginModelPath: assets/  tagMode: false  debug: false  model:    use: live2d-widget-model-gf  display:    position: right    width: 150    height: 300  mobile:    show: true  react:    opacity: 0.7</code></pre><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>有许多方法来使用不同的模型:</p><p>a. live2d_models子目录名称<br>在博客根目录下创建一个 live2d_models 文件夹.</p><p>在此文件夹内新建一个子文件夹.</p><p>将 Live2D 模型复制到这个子文件夹中.</p><p>将子文件夹的名称输入_config.yml 的 model.use 中.</p><p>示例</p><pre><code>你的模型叫 mymiku.在博客根目录 (应当有_config.yml 、sources 、 themes ) 新建名为 mymiku 的子文件夹.将模型复制到 /live2d_models/mymiku/ 中.现在, 在这里应当有一个 .model.json 文件 (例如 mymiku.model.json)在 /live2d_models/mymiku/ 中.将 mymiku 输入到位于_config.yml 的 model.use 中.</code></pre><p>b. 相对于博客根目录的自定义路径<br>可直接输入相对于博客根目录的自定义路径到 model.use 中.</p><p>示例: ./wives/wanko</p><p>c. npm 模块名<br>使用现有的的模型<br>需要先使用 npm install 模型的包名 来安装,</p><p>然后将包名输入位于_config.yml 的 model.use 中.</p><p>但在安装过程中遇到问题：</p><pre><code>make: *** [Release/obj.target/fse/fsevents.o] Error 1gyp ERR! build errorgyp ERR! stack Error: `make` failed with exit code: 2gyp ERR! stack     at ChildProcess.onExit (/usr/local/lib/node_modules/npm/node_modules/node-gyp/lib/build.js:262:23)gyp ERR! stack     at ChildProcess.emit (events.js:203:13)gyp ERR! stack     at Process.ChildProcess._handle.onexit (internal/child_process.js:272:12)gyp ERR! System Darwin 18.7.0gyp ERR! command &quot;/usr/local/Cellar/node/12.6.0/bin/node&quot; &quot;/usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js&quot; &quot;build&quot; &quot;--fallback-to-build&quot; &quot;--module=/Users/liyiye/yiye-project/liyiye012.github.io/node_modules/fsevents/lib/binding/Release/node-v72-darwin-x64/fse.node&quot; &quot;--module_name=fse&quot; &quot;--module_path=/Users/liyiye/yiye-project/liyiye012.github.io/node_modules/fsevents/lib/binding/Release/node-v72-darwin-x64&quot; &quot;--napi_version=4&quot; &quot;--node_abi_napi=napi&quot;gyp ERR! cwd /Users/liyiye/yiye-project/liyiye012.github.io/node_modules/fseventsgyp ERR! node -v v12.6.0gyp ERR! node-gyp -v v3.8.0gyp ERR! not oknode-pre-gyp ERR! build errornode-pre-gyp ERR! stack Error: Failed to execute &apos;/usr/local/Cellar/node/12.6.0/bin/node /usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js build --fallback-to-build --module=/Users/liyiye/yiye-project/liyiye012.github.io/node_modules/fsevents/lib/binding/Release/node-v72-darwin-x64/fse.node --module_name=fse --module_path=/Users/liyiye/yiye-project/liyiye012.github.io/node_modules/fsevents/lib/binding/Release/node-v72-darwin-x64 --napi_version=4 --node_abi_napi=napi&apos; (1)</code></pre><p>类似问题在<a href="https://github.com/nodejs/node-gyp/issues/1547中找到：" target="_blank" rel="noopener">https://github.com/nodejs/node-gyp/issues/1547中找到：</a></p><p>执行命令：</p><pre><code>sudo npm i --unsafe-permsudo npm audit fix --forcesudo npm install live2d-widget-model-gf</code></pre><p>但做完这个功能后个人感觉有点花哨，容易分散阅读注意力，就暂时不上线了。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="https://cniter.github.io/posts/b1e9411b.html" target="_blank" rel="noopener">https://cniter.github.io/posts/b1e9411b.html</a><br>【2】<a href="https://blog.csdn.net/qq_36759224/article/details/85420403" target="_blank" rel="noopener">https://blog.csdn.net/qq_36759224/article/details/85420403</a><br>【3】<a href="https://zhuanlan.zhihu.com/p/69213954" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/69213954</a><br>【4】<a href="https://www.itrhx.com/2018/08/27/A04-Hexo-blog-topic-personalization/" target="_blank" rel="noopener">https://www.itrhx.com/2018/08/27/A04-Hexo-blog-topic-personalization/</a><br>【5】<a href="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md" target="_blank" rel="noopener">https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md</a><br>【6】<a href="http://ibruce.info/2015/04/04/busuanzi/" target="_blank" rel="noopener">http://ibruce.info/2015/04/04/busuanzi/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hexo的spfk主题修改：添加字数统计和阅读时长，添加网站运行时间，访问量统计，添加live2d卡通人物&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Effctive-Java阅读笔记VII</title>
    <link href="http://yoursite.com/2020/01/15/Effctive-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0VII/"/>
    <id>http://yoursite.com/2020/01/15/Effctive-Java阅读笔记VII/</id>
    <published>2020-01-15T02:48:12.000Z</published>
    <updated>2020-01-16T03:29:47.438Z</updated>
    
    <content type="html"><![CDATA[<p>第三章阅读：Methods Common to All Objects<br>13.谨慎地重写 clone 方法<br>14.考虑实现 Comparable 接口</p><a id="more"></a><h1 id="谨慎地重写-clone-方法"><a href="#谨慎地重写-clone-方法" class="headerlink" title="谨慎地重写 clone 方法"></a>谨慎地重写 clone 方法</h1><p>TODO：这一条没有读懂，留待看过20/65条后再回头来读。</p><p>Cloneable 接口的目的是作为一个 mixin 接口 （详见第 20 条），公布这样的类允许克隆。不幸的是，它没有达到这个目的。它的主要缺点是缺少 clone 方法，而 Object 的 clone 方法是受保护的。你不能，不借助反射 （详见第 65 条），仅仅因为它实现了 Cloneable 接口，就调用对象上的 clone 方法。即使是反射调用也可能失败，因为不能保证对象具有可访问的 clone 方法。尽管存在许多缺陷，该机制在合理的范围内使用，所以理解它是值得的。这个条目告诉你如何实现一个行为良好的 clone 方法，在适当的时候讨论这个方法，并提出替代方案。</p><p>　　既然 Cloneable 接口不包含任何方法，那它用来做什么？ 它决定了 Object 的受保护的 clone 方法实现的行为：如果一个类实现了 Cloneable 接口，那么 Object 的 clone 方法将返回该对象的逐个属性（field-by-field）拷贝；否则会抛出 CloneNotSupportedException 异常。这是一个非常反常的接口使用，而不应该被效仿。 通常情况下，实现一个接口用来表示可以为客户做什么。但对于 Cloneable 接口，它会修改父类上受保护方法的行为。</p><p>　　虽然规范并没有说明，但在实践中，实现 Cloneable 接口的类希望提供一个正常运行的公共 clone 方法。为了实现这一目标，该类及其所有父类必须遵循一个复杂的、不可执行的、稀疏的文档协议。由此产生的机制是脆弱的、危险的和不受语言影响的（extralinguistic）：它创建对象而不需要调用构造方法。</p><p>　　clone 方法的通用规范很薄弱的。 以下内容是从 Object 规范中复制出来的：</p><p>　　创建并返回此对象的副本。 「复制（copy）」的确切含义可能取决于对象的类。 一般意图是，对于任何对象 x，表达式 x.clone() != x 返回 true，并且 x.clone().getClass() == x.getClass() 也返回 true，但它们不是绝对的要求，但通常情况下，x.clone().equals(x) 返回 true，当然这个要求也不是绝对的。</p><p>　　根据约定，这个方法返回的对象应该通过调用 super.clone 方法获得的。 如果一个类和它的所有父类（Object 除外）都遵守这个约定，情况就是如此，x.clone().getClass() == x.getClass()。</p><p>　　根据约定，返回的对象应该独立于被克隆的对象。 为了实现这种独立性，在返回对象之前，可能需要修改由 super.clone 返回的对象的一个或多个属性。</p><p>　　这种机制与构造方法链（chaining）很相似，只是它没有被强制执行；如果一个类的 clone 方法返回一个通过调用构造方法获得而不是通过调用 super.clone 的实例，那么编译器不会抱怨，但是如果一个类的子类调用了 super.clone，那么返回的对象包含错误的类，从而阻止子类 clone 方法正常执行。如果一个类重写的 clone 方法是有 final 修饰的，那么这个约定可以被安全地忽略，因为子类不需要担心。但是，如果一个 final 类有一个不调用 super.clone 的 clone 方法，那么这个类没有理由实现 Cloneable 接口，因为它不依赖于 Object 的 clone 实现的行为。</p><p>　　假设你希望在一个类中实现 Cloneable 接口，它的父类提供了一个行为良好的 clone 方法。首先调用 super.clone。 得到的对象将是原始的完全功能的复制品。 在你的类中声明的任何属性将具有与原始属性相同的值。 如果每个属性包含原始值或对不可变对象的引用，则返回的对象可能正是你所需要的，在这种情况下，不需要进一步的处理。 例如，对于条目 11 中的 PhoneNumber 类，情况就是这样，但是请注意，不可变类永远不应该提供 clone 方法，因为这只会浪费复制。 有了这个警告，以下是 PhoneNumber 类的 clone 方法：</p><pre><code>// Clone method for class with no references to mutable state@Override public PhoneNumber clone() {    try {        return (PhoneNumber) super.clone();    } catch (CloneNotSupportedException e) {        throw new AssertionError();  // Can&apos;t happen    }}</code></pre><p>为了使这个方法起作用，PhoneNumber 的类声明必须被修改，以表明它实现了 Cloneable 接口。 虽然 Object 类的 clone 方法返回 Object 类，但是这个 clone 方法返回 PhoneNumber 类。 这样做是合法和可取的，<strong><em>因为 Java 支持协变返回类型。 换句话说，重写方法的返回类型可以是重写方法的返回类型的子类。</em></strong> 这消除了在客户端转换的需要。 在返回之前，我们必须将 Object 的 super.clone 的结果强制转换为 PhoneNumber，但保证强制转换成功。</p><p>　　super.clone 的调用包含在一个 try-catch 块中。 这是因为 Object 声明了它的 clone 方法来抛出 CloneNotSupportedException 异常，这是一个检查时异常。 由于 PhoneNumber 实现了 Cloneable 接口，所以我们知道调用 super.clone 会成功。 这里引用的需要表明 CloneNotSupportedException 应该是未被检查的（详见第 71条）。</p><p>　　如果对象包含引用可变对象的属性，则前面显示的简单 clone 实现可能是灾难性的。 例如，考虑条目 7 中的 Stack 类：</p><pre><code>public class Stack {    private Object[] elements;    private int size = 0;    private static final int DEFAULT_INITIAL_CAPACITY = 16;    public Stack() {        this.elements = new Object[DEFAULT_INITIAL_CAPACITY];    }    public void push(Object e) {        ensureCapacity();        elements[size++] = e;    }    public Object pop() {        if (size == 0)            throw new EmptyStackException();        Object result = elements[--size];        elements[size] = null; // Eliminate obsolete reference        return result;    }    // Ensure space for at least one more element.    private void ensureCapacity() {        if (elements.length == size)            elements = Arrays.copyOf(elements, 2 * size + 1);    }}</code></pre><p>假设你想让这个类可以克隆。 如果 clone 方法仅返回 super.clone() 调用的对象，那么生成的 Stack 实例在其 size 属性中具有正确的值，但 elements 属性引用与原始 Stack 实例相同的数组。 修改原始实例将破坏克隆中的不变量，反之亦然。 你会很快发现你的程序产生了无意义的结果，或者抛出 NullPointerException 异常。</p><p>　　这种情况永远不会发生，因为调用 Stack 类中的唯一构造方法。 实际上，clone 方法作为另一种构造方法; 必须确保它不会损坏原始对象，并且可以在克隆上正确建立不变量。 为了使 Stack 上的 clone 方法正常工作，它必须复制 stack 对象的内部。 最简单的方法是对元素数组递归调用 clone 方法：</p><pre><code>// Clone method for class with references to mutable state@Override public Stack clone() {    try {        Stack result = (Stack) super.clone();        result.elements = elements.clone();        return result;    } catch (CloneNotSupportedException e) {        throw new AssertionError();    }}</code></pre><p>请注意，我们不必将 elements.clone 的结果转换为 Object[] 数组。 在数组上调用 clone 会返回一个数组，其运行时和编译时类型与被克隆的数组相同。 这是复制数组的首选习语(行话)。 事实上，数组是 clone 机制的唯一有力的用途。</p><p>　　还要注意，如果 elements 属性是 final 的，则以前的解决方案将不起作用，因为克隆将被禁止向该属性分配新的值。 这是一个基本的问题：像序列化一样，Cloneable 体系结构与引用可变对象的 final 属性的正常使用不兼容，除非可变对象可以在对象和其克隆之间安全地共享。 为了使一个类可以克隆，可能需要从一些属性中移除 final 修饰符。</p><p>　　仅仅递归地调用 clone 方法并不总是足够的。 例如，假设您正在为哈希表编写一个 clone 方法，其内部包含一个哈希桶数组，每个哈希桶都指向「键-值」对链表的第一项。 为了提高性能，该类实现了自己的轻量级单链表，而没有使用 java 内部提供的 java.util.LinkedList：</p><pre><code>public class HashTable implements Cloneable {    private Entry[] buckets = ...;    private static class Entry {        final Object key;        Object value;        Entry  next;        Entry(Object key, Object value, Entry next) {            this.key   = key;            this.value = value;            this.next  = next;          }    }    ... // Remainder omitted}</code></pre><p>假设你只是递归地克隆哈希桶数组，就像我们为 Stack 所做的那样：</p><pre><code>// Broken clone method - results in shared mutable state!@Override public HashTable clone() {    try {        HashTable result = (HashTable) super.clone();        result.buckets = buckets.clone();        return result;    } catch (CloneNotSupportedException e) {        throw new AssertionError();    }}</code></pre><p>虽然被克隆的对象有自己的哈希桶数组，但是这个数组引用与原始数组相同的链表，这很容易导致克隆对象和原始对象中的不确定性行为。 要解决这个问题，你必须复制包含每个桶的链表。 下面是一种常见的方法：</p><pre><code>// Recursive clone method for class with complex mutable statepublic class HashTable implements Cloneable {    private Entry[] buckets = ...;    private static class Entry {        final Object key;        Object value;        Entry  next;        Entry(Object key, Object value, Entry next) {            this.key   = key;            this.value = value;            this.next  = next;          }        // Recursively copy the linked list headed by this Entry        Entry deepCopy() {            return new Entry(key, value,                next == null ? null : next.deepCopy());        }    }    @Override public HashTable clone() {        try {            HashTable result = (HashTable) super.clone();            result.buckets = new Entry[buckets.length];            for (int i = 0; i &lt; buckets.length; i++)                if (buckets[i] != null)                    result.buckets[i] = buckets[i].deepCopy();            return result;        } catch (CloneNotSupportedException e) {            throw new AssertionError();        }    }    ... // Remainder omitted}</code></pre><p>　私有类 HashTable.Entry 已被扩充以支持「深度复制」方法。 HashTable 上的 clone 方法分配一个合适大小的新哈希桶数组，迭代原来哈希桶数组，深度复制每个非空的哈希桶。 Entry 上的 deepCopy 方法递归地调用它自己以复制由头节点开始的整个链表。 如果哈希桶不是太长，这种技术很聪明并且工作正常。但是，克隆链表不是一个好方法，因为它为列表中的每个元素消耗一个栈帧（stack frame）。 如果列表很长，这很容易导致堆栈溢出。 为了防止这种情况发生，可以用迭代来替换 deepCopy 中的递归：</p><pre><code>// Iteratively copy the linked list headed by this EntryEntry deepCopy() {   Entry result = new Entry(key, value, next);   for (Entry p = result; p.next != null; p = p.next)      p.next = new Entry(p.next.key, p.next.value, p.next.next);   return result;}</code></pre><p>克隆复杂可变对象的最后一种方法是调用 super.clone，将结果对象中的所有属性设置为其初始状态，然后调用更高级别的方法来重新生成原始对象的状态。 以 HashTable 为例，bucket 属性将被初始化为一个新的 bucket 数组，并且 put(key, value) 方法（未示出）被调用用于被克隆的哈希表中的键值映射。 这种方法通常产生一个简单，合理的优雅 clone 方法，其运行速度不如直接操纵克隆内部的方法快。 虽然这种方法是干净的，但它与整个 Cloneable 体系结构是对立的，因为它会盲目地重写构成体系结构基础的逐个属性对象复制。</p><p>　　与构造方法一样，clone 方法绝对不可以在构建过程中，调用一个可以重写的方法（详见第 19 条）。如果 clone 方法调用一个在子类中重写的方法，则在子类有机会在克隆中修复它的状态之前执行该方法，很可能导致克隆和原始对象的损坏。因此，我们在前面讨论的 put(key, value) 方法应该时 final 或 private 修饰的。（如果时 private 修饰，那么大概是一个非 final 公共方法的辅助方法）。</p><p>　　Object 类的 clone 方法被声明为抛出 CloneNotSupportedException 异常，但重写方法时不需要。 公共 clone 方法应该省略 throws 子句，因为不抛出检查时异常的方法更容易使用（详见第 71 条）。</p><p>　　在为继承设计一个类时（详见第 19 条），通常有两种选择，但无论选择哪一种，都不应该实现 Clonable 接口。你可以选择通过实现正确运行的受保护的 clone 方法来模仿 Object 的行为，该方法声明为抛出 CloneNotSupportedException 异常。 这给了子类实现 Cloneable 接口的自由，就像直接继承 Object 一样。 或者，可以选择不实现工作的 clone 方法，并通过提供以下简并 clone 实现来阻止子类实现它：</p><pre><code>// clone method for extendable class not supporting Cloneable@Overrideprotected final Object clone() throws CloneNotSupportedException {    throw new CloneNotSupportedException();}</code></pre><p>还有一个值得注意的细节。 如果你编写一个实现了 Cloneable 的线程安全的类，记得它的 clone 方法必须和其他方法一样（详见第 78 条）需要正确的同步。 Object 类的 clone 方法是不同步的，所以即使它的实现是令人满意的，也可能需要编写一个返回 super.clone() 的同步 clone 方法。</p><p>　　回顾一下，实现 Cloneable 的所有类应该重写公共 clone 方法，而这个方法的返回类型是类本身。 这个方法应该首先调用 super.clone，然后修复任何需要修复的属性。 通常，这意味着复制任何包含内部「深层结构」的可变对象，并用指向新对象的引用来代替原来指向这些对象的引用。虽然这些内部拷贝通常可以通过递归调用 clone 来实现，但这并不总是最好的方法。 如果类只包含基本类型或对不可变对象的引用，那么很可能是没有属性需要修复的情况。 这个规则也有例外。 例如，表示序列号或其他唯一 ID 的属性即使是基本类型的或不可变的，也需要被修正。</p><p>　　这么复杂是否真的有必要？很少。 如果你继承一个已经实现了 Cloneable 接口的类，你别无选择，只能实现一个行为良好的 clone 方法。 否则，通常你最好提供另一种对象复制方法。 对象复制更好的方法是提供一个复制构造方法或复制工厂。 复制构造方法接受参数，其类型为包含此构造方法的类，例如：</p><pre><code>// Copy constructorpublic Yum(Yum yum) { ... };</code></pre><p>复制工厂类似于复制构造方法的静态工厂：</p><pre><code>// Copy factorypublic static Yum newInstance(Yum yum) { ... };</code></pre><p>复制构造方法及其静态工厂变体与 Cloneable/clone 相比有许多优点：它们不依赖风险很大的语言外的对象创建机制；不要求遵守那些不太明确的惯例；不会与 final 属性的正确使用相冲突; 不会抛出不必要的检查异常; 而且不需要类型转换。</p><p>　　此外，复制构造方法或复制工厂可以接受类型为该类实现的接口的参数。 例如，按照惯例，所有通用集合实现都提供了一个构造方法，其参数的类型为 Collection 或 Map。 基于接口的复制构造方法和复制工厂（更适当地称为转换构造方法和转换工厂）允许客户端选择复制的实现类型，而不是强制客户端接受原始实现类型。 例如，假设你有一个 HashSet，并且你想把它复制为一个 TreeSet。 clone 方法不能提供这种功能，但使用转换构造方法很容易：new TreeSet&lt;&gt;(s)。</p><p>　　考虑到与 Cloneable 接口相关的所有问题，新的接口不应该继承它，新的可扩展类不应该实现它。 虽然实现 Cloneable 接口对于 final 类没有什么危害，但应该将其视为性能优化的角度，仅在极少数情况下才是合理的（详见第 67 条）。 通常，复制功能最好由构造方法或工厂提供。 这个规则的一个明显的例外是数组，它最好用 clone 方法复制。</p><h1 id="考虑实现-Comparable-接口"><a href="#考虑实现-Comparable-接口" class="headerlink" title="考虑实现 Comparable 接口"></a>考虑实现 Comparable 接口</h1><p>与本章讨论的其他方法不同，compareTo 方法并没有在 Object 类中声明。 相反，它是 Comparable 接口中的唯一方法。 它与 Object 类的 equals 方法在性质上是相似的，除了它允许在简单的相等比较之外的顺序比较，它是泛型的。 通过实现 Comparable 接口，一个类表明它的实例有一个自然顺序（natural ordering）。 对实现 Comparable 接口的对象数组排序非常简单，如下所示：</p><pre><code>Arrays.sort(a);</code></pre><p>它很容易查找，计算极端数值，以及维护 Comparable 对象集合的自动排序。例如，在下面的代码中，依赖于 String 类实现了 Comparable 接口，去除命令行参数输入重复的字符串，并按照字母顺序排序：</p><pre><code>public class WordList {    public static void main(String[] args) {        Set&lt;String&gt; s = new TreeSet&lt;&gt;();        Collections.addAll(s, args);        System.out.println(s);    }}</code></pre><p>通过实现 Comparable 接口，可以让你的类与所有依赖此接口的通用算法和集合实现进行互操作。 只需少量的努力就可以获得巨大的能量。 几乎 Java 平台类库中的所有值类以及所有枚举类型（详见第 34 条）都实现了 Comparable 接口。 如果你正在编写具有明显自然顺序（如字母顺序，数字顺序或时间顺序）的值类，则应该实现 Comparable 接口：</p><pre><code>public interface Comparable&lt;T&gt; {    int compareTo(T t);}</code></pre><p>compareTo 方法的通用约定与 equals 相似：</p><p>　　将此对象与指定的对象按照排序进行比较。 返回值可能为负整数，零或正整数，因为此对象对应小于，等于或大于指定的对象。 如果指定对象的类型与此对象不能进行比较，则引发 ClassCastException 异常。</p><p>　　下面的描述中，符号 sgn(expression) 表示数学中的 signum 函数，它根据表达式的值为负数、零、正数，对应返回-1、0 和 1。</p><p>实现类必须确保所有 x 和 y 都满足 sgn(x.compareTo(y)) == -sgn(y. compareTo(x))。 （这意味着当且仅当 y.compareTo(x) 抛出异常时，x.compareTo(y) 必须抛出异常。）<br>实现类还必须确保该关系是可传递的：(x. compareTo(y) &gt; 0 &amp;&amp; y.compareTo(z) &gt; 0) 意味着 x.compareTo(z) &gt; 0。<br>最后，对于所有的 z，实现类必须确保 x.compareTo(y) == 0 意味着 sgn(x.compareTo(z)) == sgn(y.compareTo(z))。<br>强烈推荐 (x.compareTo(y) == 0) == (x.equals(y))，但不是必需的。 一般来说，任何实现了 Comparable 接口的类违反了这个条件都应该清楚地说明这个事实。 推荐的语言是「注意：这个类有一个自然顺序，与 equals 不一致」。<br>　　与 equals 方法一样，不要被上述约定的数学特性所退缩。这个约定并不像看起来那么复杂。 与 equals 方法不同，equals 方法在所有对象上施加了全局等价关系，compareTo 不必跨越不同类型的对象：当遇到不同类型的对象时，compareTo 被允许抛出 ClassCastException 异常。 通常，这正是它所做的。 约定确实允许进行不同类型间比较，这种比较通常在由被比较的对象实现的接口中定义。</p><p>　　正如一个违反 hashCode 约定的类可能会破坏依赖于哈希的其他类一样，违反 compareTo 约定的类可能会破坏依赖于比较的其他类。 依赖于比较的类，包括排序后的集合 TreeSet 和 TreeMap 类，以及包含搜索和排序算法的实用程序类 Collections 和 Arrays。</p><p>　　我们来看看 compareTo 约定的规定。 第一条规定，如果反转两个对象引用之间的比较方向，则会发生预期的事情：如果第一个对象小于第二个对象，那么第二个对象必须大于第一个; 如果第一个对象等于第二个，那么第二个对象必须等于第一个; 如果第一个对象大于第二个，那么第二个必须小于第一个。 第二项约定说，如果一个对象大于第二个对象，而第二个对象大于第三个对象，则第一个对象必须大于第三个对象。 最后一条规定，所有比较相等的对象与任何其他对象相比，都必须得到相同的结果。</p><p>　　这三条规定的一个结果是，compareTo 方法所实施的平等测试必须遵守 equals 方法约定所施加的相同限制：自反性，对称性和传递性。 因此，同样需要注意的是：除非你愿意放弃面向对象抽象（详见第 10 条）的好处，否则无法在保留 compareTo 约定的情况下使用新的值组件继承可实例化的类。 同样的解决方法也适用。 如果要将值组件添加到实现 Comparable 的类中，请不要继承它；编写一个包含第一个类实例的不相关的类。 然后提供一个返回包含实例的「视图”方法。 这使你可以在包含类上实现任何 compareTo 方法，同时客户端在需要时，把包含类的实例视同以一个类的实例。</p><p>　　compareTo 约定的最后一段是一个强烈的建议，而不是一个真正的要求，只是声明 compareTo 方法施加的相等性测试，通常应该返回与 equals 方法相同的结果。 如果遵守这个约定，则 compareTo 方法施加的顺序被认为与 equals 相一致。 如果违反，顺序关系被认为与 equals 不一致。 其 compareTo 方法施加与 equals 不一致顺序关系的类仍然有效，但包含该类元素的有序集合可能不服从相应集合接口（Collection，Set 或 Map）的一般约定。 这是因为这些接口的通用约定是用 equals 方法定义的，但是排序后的集合使用 compareTo 强加的相等性测试来代替 equals。 如果发生这种情况，虽然不是一场灾难，但仍是一件值得注意的事情。</p><p>　　例如，考虑 BigDecimal 类，其 compareTo 方法与 equals 不一致。 如果你创建一个空的 HashSet 实例，然后添加 new BigDecimal(“1.0”) 和 new BigDecimal(“1.00”)，则该集合将包含两个元素，因为与 equals 方法进行比较时，添加到集合的两个 BigDecimal 实例是不相等的。 但是，如果使用 TreeSet 而不是 HashSet 执行相同的过程，则该集合将只包含一个元素，因为使用 compareTo 方法进行比较时，两个 BigDecimal 实例是相等的。 （有关详细信息，请参阅 BigDecimal 文档。）</p><p>　　编写 compareTo 方法与编写 equals 方法类似，但是有一些关键的区别。 因为 Comparable 接口是参数化的，compareTo 方法是静态类型的，所以你不需要输入检查或者转换它的参数。 如果参数是错误的类型，那么调用将不会编译。 如果参数为 null，则调用应该抛出一个 NullPointerException 异常，并且一旦该方法尝试访问其成员，它就会立即抛出这个异常。</p><p>　　在 compareTo 方法中，比较属性的顺序而不是相等。 要比较对象引用属性，请递归调用 compareTo 方法。 如果一个属性没有实现 Comparable，或者你需要一个非标准的顺序，那么使用 Comparator 接口。 可以编写自己的比较器或使用现有的比较器，如在条目 10 中的 CaseInsensitiveString 类的 compareTo 方法中：</p><pre><code>// Single-field Comparable with object reference fieldpublic final class CaseInsensitiveString        implements Comparable&lt;CaseInsensitiveString&gt; {    public int compareTo(CaseInsensitiveString cis) {        return String.CASE_INSENSITIVE_ORDER.compare(s, cis.s);    }    ... // Remainder omitted}</code></pre><p>请注意，CaseInsensitiveString 类实现了 Comparable<caseinsensitivestring> 接口。 这意味着 CaseInsensitiveString 引用只能与另一个 CaseInsensitiveString 引用进行比较。 当声明一个类来实现 Comparable 接口时，这是正常模式。</caseinsensitivestring></p><p>　　在本书第二版中，曾经推荐如果比较整型基本类型的属性，使用关系运算符「&lt;」和 「&gt;」，对于浮点类型基本类型的属性，使用 Double.compare 和 Float.compare 静态方法。在 Java 7 中，静态比较方法被添加到 Java 的所有包装类中。 在 compareTo 方法中使用关系运算符「&lt;」和「&gt;」是冗长且容易出错的，不再推荐。</p><p>　　如果一个类有多个重要的属性，那么比较他们的顺序是至关重要的。 从最重要的属性开始，逐步比较所有的重要属性。 如果比较结果不是零（零表示相等），则表示比较完成; 只是返回结果。 如果最重要的字段是相等的，比较下一个重要的属性，依此类推，直到找到不相等的属性或比较剩余不那么重要的属性。 以下是条目 11 中 PhoneNumber 类的 compareTo 方法，演示了这种方法：</p><pre><code>// Multiple-field `Comparable` with primitive fieldspublic int compareTo(PhoneNumber pn) {    int result = Short.compare(areaCode, pn.areaCode);    if (result == 0) {        result = Short.compare(prefix, pn.prefix);        if (result == 0)            result = Short.compare(lineNum, pn.lineNum);    }    return result;}</code></pre><p>在 Java 8 中 Comparator 接口提供了一系列比较器方法，可以使比较器流畅地构建。 这些比较器可以用来实现 compareTo 方法，就像 Comparable 接口所要求的那样。 许多程序员更喜欢这种方法的简洁性，尽管它的性能并不出众：在我的机器上排序 PhoneNumber 实例的数组速度慢了大约 10％。 在使用这种方法时，考虑使用 Java 的静态导入，以便可以通过其简单名称来引用比较器静态方法，以使其清晰简洁。 以下是 PhoneNumber 的 compareTo 方法的使用方法：</p><pre><code>// Comparable with comparator construction methodsprivate static final Comparator&lt;PhoneNumber&gt; COMPARATOR =        comparingInt((PhoneNumber pn) -&gt; pn.areaCode)          .thenComparingInt(pn -&gt; pn.prefix)          .thenComparingInt(pn -&gt; pn.lineNum);public int compareTo(PhoneNumber pn) {    return COMPARATOR.compare(this, pn);}</code></pre><p>此实现在类初始化时构建比较器，使用两个比较器构建方法。第一个是 comparingInt 方法。它是一个静态方法，它使用一个 <strong><em>键提取器函数式接口</em></strong> (key extractor function）作为参数，将对象引用映射为 int 类型的键，并返回一个根据该键排序的实例的比较器。在前面的示例中，comparingInt 方法使用 lambda 表达式，它从 PhoneNumber 中提取区域代码，并返回一个 Comparator<phonenumber>，根据它们的区域代码来排序电话号码。注意，lambda 表达式显式指定了其输入参数的类型 (PhoneNumber pn)。事实证明，在这种情况下，Java 的类型推断功能不够强大，无法自行判断类型，因此我们不得不帮助它以使程序编译。</phonenumber></p><p>　　如果两个电话号码实例具有相同的区号，则需要进一步细化比较，这正是第二个比较器构建方法，即 thenComparingInt 方法做的。 它是 Comparator 上的一个实例方法，接受一个 int 类型 <strong><em>键提取器函数式接口</em></strong> key extractor function）作为参数，并返回一个比较器，该比较器首先应用原始比较器，然后使用提取的键来打破连接。 你可以按照喜欢的方式多次调用 thenComparingInt 方法，从而产生一个字典顺序。 在上面的例子中，我们将两个调用叠加到 thenComparingInt，产生一个排序，它的二级键是 prefix，而其三级键是 lineNum。 请注意，我们不必指定传递给 thenComparingInt 的任何一个调用的 <strong><em>键提取器函数式接口</em></strong> 的参数类型：Java 的类型推断足够聪明，可以自己推断出参数的类型。</p><p>　　Comparator 类具有完整的构建方法。对于 long 和 double 基本类型，也有对应的类似于 comparingInt 和 thenComparingInt 的方法，int 版本的方法也可以应用于取值范围小于 int 的类型上，如 short 类型，如 PhoneNumber 实例中所示。对于 double 版本的方法也可以用在 float 类型上。这提供了所有 Java 的基本数字类型的覆盖。</p><p>　　也有对象引用类型的比较器构建方法。静态方法 comparing 有两个重载方式。第一个方法使用 <strong><em>键提取器函数式接口</em></strong> 并按键的自然顺序。第二种方法是 <strong><em>键提取器函数式接口</em></strong> 和比较器，用于键的排序。thenComparing 方法有三种重载。第一个重载只需要一个比较器，并使用它来提供一个二级排序。第二次重载只需要一个 <strong><em>键提取器函数式接口</em></strong> ，并使用键的自然顺序作为二级排序。最后的重载方法同时使用一个 <strong><em>键提取器函数式接口</em></strong> 和一个比较器来用在提取的键上。</p><p>　　有时，你可能会看到 compareTo 或 compare 方法依赖于两个值之间的差值，如果第一个值小于第二个值，则为负；如果两个值相等则为零，如果第一个值大于，则为正值。这是一个例子：</p><pre><code>// BROKEN difference-based comparator - violates transitivity!static Comparator&lt;Object&gt; hashCodeOrder = new Comparator&lt;&gt;() {    public int compare(Object o1, Object o2) {        return o1.hashCode() - o2.hashCode();    }};</code></pre><p>不要使用这种技术！它可能会导致整数最大长度溢出和 IEEE 754 浮点运算失真的危险[JLS 15.20.1,15.21.1]。 此外，由此产生的方法不可能比使用上述技术编写的方法快得多。 使用静态 compare 方法：</p><pre><code>// Comparator based on static compare methodstatic Comparator&lt;Object&gt; hashCodeOrder = new Comparator&lt;&gt;() {    public int compare(Object o1, Object o2) {        return Integer.compare(o1.hashCode(), o2.hashCode());    }};</code></pre><p>或者使用 Comparator 的构建方法：</p><pre><code>// Comparator based on Comparator construction methodstatic Comparator&lt;Object&gt; hashCodeOrder =        Comparator.comparingInt(o -&gt; o.hashCode());</code></pre><p><strong><em>总而言之，无论何时实现具有合理排序的值类，你都应该让该类实现 Comparable 接口，以便在基于比较的集合中轻松对其实例进行排序，搜索和使用。 比较<br>compareTo 方法的实现中的字段值时，请避免使用「&lt;」和「&gt;」运算符。 相反，使用包装类中的静态 compare 方法或 Comparator 接口中的构建方法</em></strong></p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="http://sjsdfg.gitee.io/effective-java-3rd-chinese/#/notes/13.%20%E8%B0%A8%E6%85%8E%E5%9C%B0%E9%87%8D%E5%86%99%20clone%20%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">http://sjsdfg.gitee.io/effective-java-3rd-chinese/#/notes/13.%20%E8%B0%A8%E6%85%8E%E5%9C%B0%E9%87%8D%E5%86%99%20clone%20%E6%96%B9%E6%B3%95</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第三章阅读：Methods Common to All Objects&lt;br&gt;13.谨慎地重写 clone 方法&lt;br&gt;14.考虑实现 Comparable 接口&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Effctive-Java阅读笔记VI</title>
    <link href="http://yoursite.com/2020/01/14/Effctive-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0VI/"/>
    <id>http://yoursite.com/2020/01/14/Effctive-Java阅读笔记VI/</id>
    <published>2020-01-14T06:56:12.000Z</published>
    <updated>2020-01-15T02:48:53.520Z</updated>
    
    <content type="html"><![CDATA[<p>第三章阅读：Methods Common to All Objects<br>11.重写 equals 方法时同时也要重写 hashcode 方法<br>12.始终重写 toString 方法</p><a id="more"></a><h1 id="重写-equals-方法时同时也要重写-hashcode-方法"><a href="#重写-equals-方法时同时也要重写-hashcode-方法" class="headerlink" title="重写 equals 方法时同时也要重写 hashcode 方法"></a>重写 equals 方法时同时也要重写 hashcode 方法</h1><p>在每个类中，在重写 equals 方法的时侯，一定要重写 hashcode 方法。 如果不这样做，你的类违反了 hashCode 的通用约定，这会阻止它在 HashMap 和 HashSet 这样的集合中正常工作。根据 Object 规范，以下时具体约定。</p><p>1.当在一个应用程序执行过程中，如果在 equals 方法比较中没有修改任何信息，在一个对象上重复调用 hashCode 方法时，它必须始终返回相同的值。从一个应用程序到另一个应用程序的每一次执行返回的值可以是不一致的。<br>2.如果两个对象根据 equals(Object) 方法比较是相等的，那么在两个对象上调用 hashCode 就必须产生的结果是相同的整数。<br>3.如果两个对象根据 equals(Object) 方法比较并不相等，则不要求在每个对象上调用 hashCode 都必须产生不同的结果。 但是，程序员应该意识到，为不相等的对象生成不同的结果可能会提高散列表（hash tables）的性能。<br>　　当无法重写 hashCode 时，所违反第二个关键条款是：相等的对象必须具有相等的哈希码（ hash codes）。 根据类的 equals 方法，两个不同的实例可能在逻辑上是相同的，但是对于 Object 类的 hashCode 方法，它们只是两个没有什么共同之处的对象。因此， Object 类的 hashCode 方法返回两个看似随机的数字，而不是按约定要求的两个相等的数字。</p><p>举例说明，假设你使用条目 10 中的 PhoneNumber 类的实例做为 HashMap 的键（key）：</p><pre><code>Map&lt;PhoneNumber, String&gt; m = new HashMap&lt;&gt;();m.put(new PhoneNumber(707, 867, 5309), &quot;Jenny&quot;);</code></pre><p>你可能期望 m.get(new PhoneNumber(707, 867, 5309)) 方法返回 Jenny 字符串，但实际上，返回了 null。注意，这里涉及到两个 PhoneNumber 实例：一个实例插入到 HashMap 中，另一个作为判断相等的实例用来检索。PhoneNumber 类没有重写 hashCode 方法导致两个相等的实例返回了不同的哈希码，违反了 hashCode 约定。put 方法把 PhoneNumber 实例保存在了一个哈希桶（ hash bucket）中，但 get 方法却是从不同的哈希桶中去查找，即使恰好两个实例放在同一个哈希桶中，get 方法几乎肯定也会返回 null。因为 HashMap 做了优化，缓存了与每一项（entry）相关的哈希码，如果哈希码不匹配，则不会检查对象是否相等了。</p><p>　　解决这个问题很简单，只需要为 PhoneNumber 类重写一个合适的 hashCode 方法。hashCode 方法是什么样的？写一个不规范的方法的是很简单的。以下示例，虽然永远是合法的，但绝对不能这样使用：</p><pre><code>// The worst possible legal hashCode implementation - never use!@Override public int hashCode() { return 42; }</code></pre><p>这是合法的，因为它确保了相等的对象具有相同的哈希码。这很糟糕，因为它确保了每个对象都有相同的哈希码。因此，每个对象哈希到同一个桶中，哈希表退化为链表。应该在线性时间内运行的程序，运行时间变成了平方级别。对于数据很大的哈希表而言，会影响到能够正常工作。</p><p>　　一个好的 hash 方法趋向于为不相等的实例生成不相等的哈希码。这也正是 hashCode 约定中第三条的表达。理想情况下，hash 方法为集合中不相等的实例均匀地分配 int 范围内的哈希码。实现这种理想情况可能是困难的。 幸运的是，要获得一个合理的近似的方式并不难。 以下是一个简单的配方：</p><p>1.声明一个 int 类型的变量 result，并将其初始化为对象中第一个重要属性 c 的哈希码，如下面步骤 2.a 中所计算的那样。（回顾条目 10，重要的属性是影响比较相等的领域。）</p><p>2.对于对象中剩余的重要属性 f，请执行以下操作：<br>a. 比较属性 f 与属性 c 的 int 类型的哈希码：</p><pre><code>-- i. 如果这个属性是基本类型的，使用 Type.hashCode(f) 方法计算，其中 Type 类是对应属性 f 基本类型的包装类。-- ii. 如果该属性是一个对象引用，并且该类的 equals 方法通过递归调用 equals 来比较该属性，并递归地调用 hashCode 方法。 如果需要更复杂的比较，则计算此字段的“范式（“canonical representation）”，并在范式上调用 hashCode。 如果该字段的值为空，则使用 0（也可以使用其他常数，但通常来使用 0 表示）。 -- iii. 如果属性 f 是一个数组，把它看作每个重要的元素都是一个独立的属性。 也就是说，通过递归地应用这些规则计算每个重要元素的哈希码，并且将每个步骤 2.b 的值合并。 如果数组没有重要的元素，则使用一个常量，最好不要为 0。如果所有元素都很重要，则使用 Arrays.hashCode 方法。</code></pre><p>b. 将步骤 2.a 中属性 c 计算出的哈希码合并为如下结果：result = 31 * result + c;</p><p>3.返回 result 值。</p><p>当你写完 hashCode 方法后，问自己是否相等的实例有相同的哈希码。 编写单元测试来验证你的直觉（除非你使用 AutoValue 框架来生成你的 equals 和 hashCode 方法，在这种情况下，你可以放心地忽略这些测试）。 如果相同的实例有不相等的哈希码，找出原因并解决问题。</p><p>　　可以从哈希码计算中排除派生属性（derived fields）。换句话说，如果一个属性的值可以根据参与计算的其他属性值计算出来，那么可以忽略这样的属性。您必须排除在 equals 比较中没有使用的任何属性，否则可能会违反 hashCode 约定的第二条。</p><p>　　步骤 2.b 中的乘法计算结果取决于属性的顺序，如果类中具有多个相似属性，则产生更好的散列函数。 例如，如果乘法计算从一个 String 散列函数中被省略，则所有的字符将具有相同的散列码。 之所以选择 31，因为它是一个奇数的素数。 如果它是偶数，并且乘法溢出，信息将会丢失，因为乘以 2 相当于移位。 使用素数的好处不太明显，但习惯上都是这么做的。 31 的一个很好的特性，是在一些体系结构中乘法可以被替换为移位和减法以获得更好的性能：31 * i ==（i &lt;&lt; 5） - i。 现代 JVM 可以自动进行这种优化。</p><p>　　让我们把上述办法应用到 PhoneNumber 类中：</p><pre><code>// Typical hashCode method@Overridepublic int hashCode() {    int result = Short.hashCode(areaCode);    result = 31 * result + Short.hashCode(prefix);    result = 31 * result + Short.hashCode(lineNum);    return result;}</code></pre><p>因为这个方法返回一个简单的确定性计算的结果，它的唯一的输入是 PhoneNumber 实例中的三个重要的属性，所以显然相等的 PhoneNumber 实例具有相同的哈希码。 实际上，这个方法是 PhoneNumber 的一个非常好的 hashCode 实现，与 Java 平台类库中的实现一样。 它很简单，速度相当快，并且合理地将不相同的电话号码分散到不同的哈希桶中。</p><p>　　虽然在这个项目的方法产生相当好的哈希函数，但并不是最先进的。 它们的质量与 Java 平台类库的值类型中找到的哈希函数相当，对于大多数用途来说都是足够的。 如果真的需要哈希函数而不太可能产生碰撞，请参阅 Guava 框架的的com.google.common.hash.Hashing [Guava] 方法。</p><p>　　Objects 类有一个静态方法，它接受任意数量的对象并为它们返回一个哈希码。 这个名为 hash 的方法可以让你编写一行 hashCode 方法，其质量与根据这个项目中的上面编写的方法相当。 不幸的是，它们的运行速度更慢，因为它们需要创建数组以传递可变数量的参数，以及如果任何参数是基本类型，则进行装箱和取消装箱。 这种哈希函数的风格建议仅在性能不重要的情况下使用。 以下是使用这种技术编写的 PhoneNumber 的哈希函数：</p><pre><code>// One-line hashCode method - mediocre performance@Overridepublic int hashCode() {   return Objects.hash(lineNum, prefix, areaCode);}</code></pre><p>如果一个类是不可变的，并且计算哈希码的代价很大，那么可以考虑在对象中缓存哈希码，而不是在每次请求时重新计算哈希码。 如果你认为这种类型的大多数对象将被用作哈希键，那么应该在创建实例时计算哈希码。 否则，可以选择在首次调用 hashCode 时延迟初始化（lazily initialize）哈希码。 需要注意确保类在存在延迟初始化属性的情况下保持线程安全（项目 83）。 PhoneNumber 类不适合这种情况，但只是为了展示它是如何完成的。 请注意，属性 hashCode 的初始值（在本例中为 0）不应该是通常创建的实例的哈希码：</p><pre><code>// hashCode method with lazily initialized cached hash codeprivate int hashCode; // Automatically initialized to 0@Overridepublic int hashCode() {    int result = hashCode;    if (result == 0) {        result = Short.hashCode(areaCode);        result = 31 * result + Short.hashCode(prefix);        result = 31 * result + Short.hashCode(lineNum);        hashCode = result;    }    return result;}</code></pre><p>不要试图从哈希码计算中排除重要的属性来提高性能。 由此产生的哈希函数可能运行得更快，但其质量较差可能会降低哈希表的性能，使其无法使用。 具体来说，哈希函数可能会遇到大量不同的实例，这些实例主要在你忽略的区域中有所不同。 如果发生这种情况，哈希函数将把所有这些实例映射到少许哈希码上，而应该以线性时间运行的程序将会运行平方级的时间。</p><p>　　这不仅仅是一个理论问题。 在 Java 2 之前，String 类哈希函数在整个字符串中最多使用 16 个字符，从第一个字符开始，在整个字符串中均匀地选取。 对于大量的带有层次名称的集合（如 URL），此功能正好显示了前面描述的病态行为。</p><p>　　不要为 hashCode 返回的值提供详细的规范，因此客户端不能合理地依赖它； 你可以改变它的灵活性。 Java 类库中的许多类（例如 String 和 Integer）都将 hashCode 方法返回的确切值指定为实例值的函数。 这不是一个好主意，而是一个我们不得不忍受的错误：它妨碍了在未来版本中改进哈希函数的能力。 如果未指定细节并在散列函数中发现缺陷，或者发现了更好的哈希函数，则可以在后续版本中对其进行更改。</p><p>　　总之，每次重写 equals 方法时都必须重写 hashCode 方法，否则程序将无法正常运行。你的 hashCode 方法必须遵从 Object 类指定的常规约定，并且必须执行合理的工作，将不相等的哈希码分配给不相等的实例。如果使用第 51 页的配方，这很容易实现。如条目 10 所述，AutoValue 框架为手动编写 equals 和 hashCode 方法提供了一个很好的选择，IDE 也提供了一些这样的功能。</p><h1 id="始终重写-toString-方法"><a href="#始终重写-toString-方法" class="headerlink" title="始终重写 toString 方法"></a>始终重写 toString 方法</h1><p>虽然 Object 类提供了 toString 方法的实现，但它返回的字符串通常不是你的类的用户想要看到的。 它由类名后跟一个「at」符号（@）和哈希码的无符号十六进制表示组成，例如 PhoneNumber@163b91。 toString 的通用约定要求，返回的字符串应该是「一个简洁但内容丰富的表示，对人们来说是很容易阅读的」。虽然可以认为 PhoneNumber@163b91 简洁易读，但相比于 707-867-5309，但并不是很丰富 。 toString 通用约定「建议所有的子类重写这个方法」。好的建议，的确如此！</p><p>　　虽然它并不像遵守 equals 和 hashCode 约定那样重要 (条目 10 和 11)，但是提供一个良好的 toString 实现使你的类更易于使用，并对使用此类的系统更易于调试。当对象被传递到 println、printf、字符串连接操作符或断言，或者由调试器打印时，toString 方法会自动被调用。即使你从不调用对象上的 toString，其他人也可以。例如，对对象有引用的组件可能包含在日志错误消息中对象的字符串表示。如果未能重写 toString，则消息可能是无用的。</p><p>　　如果为 PhoneNumber 提供了一个很好的 toString 方法，那么生成一个有用的诊断消息就像下面这样简单：</p><pre><code>System.out.println(&quot;Failed to connect to &quot; + phoneNumber);</code></pre><p>程序员将以这种方式生成诊断消息，不管你是否重写 toString，但是除非你这样做，否则这些消息将不会有用。 提供一个很好的 toString 方法的好处不仅包括类的实例，同样有益于包含实例引用的对象，特别是集合。 打印 map 对象时你会看到哪一个，{Jenny=PhoneNumber@163b91} 还是 {Jenny=707-867-5309}?</p><p>　　实际上，toString 方法应该返回对象中包含的所有需要关注的信息，如电话号码示例中所示。 如果对象很大或者包含不利于字符串表示的状态，这是不切实际的。 在这种情况下，toString 应该返回一个摘要，如 Manhattan residential phone directory (1487536 listings) 或线程[main，5，main]。 理想情况下，字符串应该是不言自明的（线程示例并没有遵守这点）。 如果未能将所有对象的值得关注的信息包含在字符串表示中，则会导致一个特别烦人的处罚：测试失败报告如下所示：</p><pre><code>Assertion failure: expected {abc, 123}, but was {abc, 123}.</code></pre><p>实现 toString 方法时，必须做出的一个重要决定是：在文档中指定返回值的格式。 建议你对值类进行此操作，例如电话号码或矩阵类。 指定格式的好处是它可以作为标准的，明确的，可读的对象表示。 这种表示形式可以用于输入、输出以及持久化可读性的数据对象，如 CSV 文件。 如果指定了格式，通常提供一个匹配的静态工厂或构造方法，是个好主意，所以程序员可以轻松地在对象和字符串表示之间来回转换。 Java 平台类库中的许多值类都采用了这种方法，包括 BigInteger，BigDecimal 和大部分基本类型包装类。</p><p>　　指定 toString 返回值的格式的缺点是，假设你的类被广泛使用，一旦指定了格式，就会终身使用。程序员将编写代码来解析表达式，生成它，并将其嵌入到持久数据中。如果在将来的版本中更改了格式的表示，那么会破坏他们的代码和数据，并且还会抱怨。但通过选择不指定格式，就可以保留在后续版本中添加信息或改进格式的灵活性。</p><p>　　无论是否决定指定格式，你都应该清楚地在文档中表明你的意图。如果指定了格式，则应该这样做。例如，这里有一个 toString 方法，该方法在条目 11 中使用 PhoneNumber 类：</p><pre><code>/** * Returns the string representation of this phone number. * The string consists of twelve characters whose format is * &quot;XXX-YYY-ZZZZ&quot;, where XXX is the area code, YYY is the * prefix, and ZZZZ is the line number. Each of the capital * letters represents a single decimal digit. * * If any of the three parts of this phone number is too small * to fill up its field, the field is padded with leading zeros. * For example, if the value of the line number is 123, the last * four characters of the string representation will be &quot;0123&quot;. */@Overridepublic String toString() {    return String.format(&quot;%03d-%03d-%04d&quot;,            areaCode, prefix, lineNum);}</code></pre><p>如果你决定不指定格式，那么文档注释应该是这样的：</p><pre><code>/** * Returns a brief description of this potion. The exact details * of the representation are unspecified and subject to change, * but the following may be regarded as typical: * * &quot;[Potion #9: type=love, smell=turpentine, look=india ink]&quot; */@Overridepublic String toString() { ... }</code></pre><p>在阅读了这条注释之后，那些生成依赖于格式细节的代码或持久化数据的程序员，在这种格式发生改变的时候，只能怪他们自己。</p><p>　　无论是否指定格式，都可以通过编程方式访问 toString 返回的值中包含的信息。 例如，PhoneNumber 类应该包含 areaCode, prefix, lineNum 这三个属性。 如果不这样做，就会强迫程序员需要这些信息来解析字符串。 除了降低性能和程序员做不必要的工作之外，这个过程很容易出错，如果改变格式就会中断，并导致脆弱的系统。 由于未能提供访问器，即使已指定格式可能会更改，也可以将字符串格式转换为事实上的 API。</p><p>　　在静态工具类（详见第 4 条）中编写 toString 方法是没有意义的。 你也不应该在大多数枚举类型（条目 34）中写一个 toString 方法，因为 Java 为你提供了一个非常好的方法。 但是，你应该在任何抽象类中定义 toString 方法，该类的子类共享一个公共字符串表示形式。 例如，大多数集合实现上的 toString 方法都是从抽象集合类继承的。</p><p>　　Google 的开放源代码 AutoValue 工具在条目 10 中讨论过，它为你生成一个 toString 方法，就像大多数 IDE 工具一样。 这些方法非常适合告诉你每个属性的内容，但并不是专门针对类的含义。 因此，例如，为我们的 PhoneNumber 类使用自动生成的 toString 方法是不合适的（因为电话号码具有标准的字符串表示形式），但是对于我们的 Potion 类来说，这是完全可以接受的。 也就是说，自动生成的 toString 方法比从 Object 继承的方法要好得多，它不会告诉你对象的值。</p><p>　　回顾一下，除非父类已经这样做了，否则在每个实例化的类中重写 Object 的 toString 实现。 它使得类更加舒适地使用和协助调试。 toString 方法应该以一种美观的格式返回对象的简明有用的描述。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="http://sjsdfg.gitee.io/effective-java-3rd-chinese/#/notes/11.%20%E9%87%8D%E5%86%99equals%E6%96%B9%E6%B3%95%E6%97%B6%E5%90%8C%E6%97%B6%E4%B9%9F%E8%A6%81%E9%87%8D%E5%86%99hashcode%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">http://sjsdfg.gitee.io/effective-java-3rd-chinese/#/notes/11.%20%E9%87%8D%E5%86%99equals%E6%96%B9%E6%B3%95%E6%97%B6%E5%90%8C%E6%97%B6%E4%B9%9F%E8%A6%81%E9%87%8D%E5%86%99hashcode%E6%96%B9%E6%B3%95</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第三章阅读：Methods Common to All Objects&lt;br&gt;11.重写 equals 方法时同时也要重写 hashcode 方法&lt;br&gt;12.始终重写 toString 方法&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Git学习笔记III</title>
    <link href="http://yoursite.com/2020/01/13/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0III/"/>
    <id>http://yoursite.com/2020/01/13/Git学习笔记III/</id>
    <published>2020-01-13T10:12:12.000Z</published>
    <updated>2020-01-13T10:25:57.647Z</updated>
    
    <content type="html"><![CDATA[<p>使用Git进行工程开发时需要的常见规范，常见的Git命令， Git 客户端SourceTree简介</p><a id="more"></a><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在团队开发中，遵循一个合理、清晰的Git使用流程，是非常重要的。否则，每个人都提交一堆杂乱无章的commit，项目很快就会变得难以协调和维护。</p><h1 id="Git的特点"><a href="#Git的特点" class="headerlink" title="Git的特点"></a>Git的特点</h1><p>Git有很多优点，其中很显著的一点，就是版本的分支（branch）和合并（merge）十分方便，但如果管理不善，分支太多会导致杂乱不堪。</p><p>Vincent Driessen提出了一个分支管理的策略，我觉得非常值得借鉴。它可以使得版本库的演进保持简洁，主干清晰，各个分支各司其职、井井有条。</p><h1 id="Git分支管理策略"><a href="#Git分支管理策略" class="headerlink" title="Git分支管理策略"></a>Git分支管理策略</h1><p>主分支：应该有且只有一个主分支，所有提供给用户使用的正式上线版本都是从该主分支上发布。</p><p>开发分支：日常开发任务在develop分支上进行。<br>如果想要对外发布，就需要提交merge request，申请从develop分支merge到master中进行合并。</p><p>临时性分支：除了发布和开发，我们还需要一些临时性分支，用于 功能分支（feature）、预发布功能（release）分支、修正bug（fixbug）分支等，以及敏捷开发中的Sprint分支，在使用完成后，都需要将其快速删除，使得代码库的分支始终只会有 develop 和 master 分支。</p><h1 id="当前功能分支命名规范"><a href="#当前功能分支命名规范" class="headerlink" title="当前功能分支命名规范"></a>当前功能分支命名规范</h1><p>功能分支（feature，命名规范 feature-XXX）<br>Sprint分支（命名规范 sprint-XXX），在Sprint结束之后，合并至develop并进行预发布；<br>预发布功能分支（release）：在正式发布之前，我们需要一个预发布版本用来做测试，可以考虑将测试Lain环境中的分支都指向release分支而非develop；<br>修正bug（fixbug）分支：修补bug分支是从Master分支上面分出来的。修补结束以后，再合并进Master和Develop分支。它的命名，可以采用fixbug-XXX的形式。<br>根据JIRA问题创建出来的分支（jira-XXX）：当存在JIRA问题，并以此作为修改代码的依据时，可以使用这种方式的分支命名。</p><h1 id="Git-Commit信息的编写"><a href="#Git-Commit信息的编写" class="headerlink" title="Git Commit信息的编写"></a>Git Commit信息的编写</h1><p>如果有对应JIRA问题，编写格式可以直接以JIRA问题为准（这样可以在IDEA中查看代码时能够快速链接到该问题的描述）</p><pre><code>Git JIRA 提交信息JIRA-56http://jira/XXX</code></pre><p>如果没有JIRA问题，首先尝试在JIRA系统上建立问题并按照第一条原则。如果确实没有必要，则需要在提交时指定问题类型，基本的模板为：</p><pre><code>Git 普通问题提交信息&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;typefeat：新功能（feature）fix：修补bugdoc：文档（documentation）style： 代码风格或格式（不影响代码运行的变动）refactor：重构（即不是新增功能，也不是修改bug的代码变动）test：增加测试build: 构建过程或辅助工具的变动chore：其它类型提交,无关src目录以及test目scope用于说明此次提交影响的范围subject  commit 目的的简短描述。以动词开头，使用第一人称现在时，比如change，而不是changed或changes第一个字母小写结尾不加句号（。）</code></pre><h1 id="Git-标准流程"><a href="#Git-标准流程" class="headerlink" title="Git 标准流程"></a>Git 标准流程</h1><p>Git分支管理流程遵循以下几点：</p><p>developer没有任何权限能直接将codepush到develop、release和master分支。<br>developer开发feature时先建立issue之后再从develop创建相应的feature分支。<br>feature开发完毕后提交测试，测试可对此feature分支需要按照之前设计的case进行测试，并将bug录入到JIRA中。<br>上线日前1天从develop分支创建release分支命名规则遵守：release_yyyy/MM/dd<br>与产品沟通最后确认上线内容，并于涉及到的项目组沟通确认上线日配合验证测试。<br>将所有需要上线的feature分支提交merge request到release分支此时由中级或高级developer进行code review。<br>代码合并后测试进行主干的测试。确保上线前一天封版（理论上上线当天不进行代码改动）。<br>上线当上午发送上线通知邮件。</p><h1 id="代码提交规范："><a href="#代码提交规范：" class="headerlink" title="代码提交规范："></a>代码提交规范：</h1><p>首先master 拉取分支—–&gt;建立开发分支——&gt;开发完成-→合并develop 分支—-&gt;提交测试—–&gt;测试完成—-&gt;开发分支合并到master分支</p><h2 id="流程阻塞型功能提测"><a href="#流程阻塞型功能提测" class="headerlink" title="流程阻塞型功能提测"></a>流程阻塞型功能提测</h2><p>如果为后端必须零流量进行线上的回归，再开权限。</p><h1 id="提交测试："><a href="#提交测试：" class="headerlink" title="提交测试："></a>提交测试：</h1><p>项目开发完毕后，发邮件提测，提测内容如下：</p><p>背景：提测项目的背景和目的<br>修改点：代码变动和参数参数变动，以及配置文件有哪些变动<br>单元测试的覆盖率报表地址<br>有代码变动，可将git的diff结果页面的链接附上（是否建立代码的卡关流程，测试看完后，高工review确认合主分支）<br>测试或验证功能点：本次测试的重点check点，标明和强调（例如功能、兼容性、参数、代码逻辑，防止漏侧改动点）</p><h2 id="后端提测"><a href="#后端提测" class="headerlink" title="后端提测:"></a>后端提测:</h2><p>(1).需要指明哪些接口，接口的请求(新接口、老接口、内部接口)的必要参数和接口响应结果的重要业务字段，另外这些字段的重要逻辑需要指明<br>(2).接口的功能是什么<br>(3).测试的功能点是什么，需要测试做什么<br>前端和安卓测试：<br>(1).交互逻辑有哪些修改,交互的条件有哪些<br>(2).新增UI页面、前端效果有哪些<br>(3).交互完成的功能主要是什么<br>(4).主要测试的功能点是什么<br>测试范围：哪个端（pc\移动\h5）<br>自测范围和自测机型：自测功能点要详细说明（自测中验证了什么）</p><p>附上各个应用中git基本操作流程<br>个人可以根据需要，选择适合自己的工具（建议从原理入手，选择命令行）</p><h1 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h1><p>查看当前分支信息</p><pre><code>git branch -a  （-a 表示列出所有的本地分支以及远程分支）git branch -d xxx (删除合并过的分支xxx)git branch -D xxx (强制删除分支xxx，及时xxx未被合并过)</code></pre><p>切换分支</p><pre><code>git checkout xxx (切换至存在的分支)git checkout -b yyy (以当前分支为基础，新建分支yyy，并切换至分支yyy)</code></pre><p>更改工作区内容至暂存区</p><pre><code>git add . (添加所有文件至暂存区)git add  source/to/file (添加指定文件至暂存区)git rm source/to/file (删除工作区和暂存区的指定文件)git mv source/to/file destination/to/file (移动工作区和暂存区的指定文件)</code></pre><p>提交暂存区内容至本地分支</p><pre><code>git commit -m &quot;&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&quot;</code></pre><p>同步本地分支至远程分支</p><pre><code>git push origin branch</code></pre><p>拉取远程代码至本地</p><pre><code>git fetchgit rebase master</code></pre><h1 id="SourceTree"><a href="#SourceTree" class="headerlink" title="SourceTree"></a>SourceTree</h1><pre><code>SourceTree 是 Windows 和Mac OS X 下的 Git 客户端，下载地址：https://www.sourcetreeapp.com/</code></pre><h2 id="提交代码-（git-commit-amp-push）"><a href="#提交代码-（git-commit-amp-push）" class="headerlink" title="提交代码 （git commit &amp; push）"></a>提交代码 （git commit &amp; push）</h2><p>1.提交代码前应仔细看代码变更，不提交的改动可以选择暂存或舍弃。</p><p>2.选择要提交的文件后，会显示在已暂存文件列表中。</p><p>3.填写提交信息。</p><p>4.提交（勾选立即推送可立即推送到远端）</p><h2 id="本地合并分支（git-merge）"><a href="#本地合并分支（git-merge）" class="headerlink" title="本地合并分支（git merge）"></a>本地合并分支（git merge）</h2><p>提交代码后，如果有冲突无法在远端解决，可以在本地合并，解决冲突。</p><p>假设将 feature-test 合并到 master 上，先切换到 master 分支，再右键选择合并 feature-test 到 master。</p><h2 id="贮藏-（git-stash）"><a href="#贮藏-（git-stash）" class="headerlink" title="贮藏 （git stash）"></a>贮藏 （git stash）</h2><p>贮藏是一项十分有用的功能。当你处在开发阶段，有代码没提交，却需要切换分支或临时解决其他问题时，贮藏是最好的解决办法。</p><p>贮藏可以将当前改动暂时存起来，在左侧已贮藏列表显示已储存的代码。</p><p>在解决完临时问题后，通过应用贮藏将代码变更应用到当前分支。</p><p>SourceTree 的基本操作介绍如上，更多详细操作可以参考以下文档：</p><p>官方文档：<a href="https://confluence.atlassian.com/get-started-with-sourcetree" target="_blank" rel="noopener">https://confluence.atlassian.com/get-started-with-sourcetree</a></p><p>SoureTree使用方法：<a href="https://www.jianshu.com/p/6d2717c2a3e1" target="_blank" rel="noopener">https://www.jianshu.com/p/6d2717c2a3e1</a></p><p>提交merge request之后，如果source branch没有其他用处，可在merge完直接删除掉</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Git进行工程开发时需要的常见规范，常见的Git命令， Git 客户端SourceTree简介&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Effctive-Java阅读笔记V</title>
    <link href="http://yoursite.com/2020/01/06/Effctive-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0V/"/>
    <id>http://yoursite.com/2020/01/06/Effctive-Java阅读笔记V/</id>
    <published>2020-01-06T01:46:12.000Z</published>
    <updated>2020-01-14T06:55:57.501Z</updated>
    
    <content type="html"><![CDATA[<p>第三章阅读：Methods Common to All Objects<br>09.使用 try-with-resources 语句替代 try-finally 语句<br>10.重写 equals 方法时遵守通用约定</p><a id="more"></a><h1 id="使用-try-with-resources-语句替代-try-finally-语句"><a href="#使用-try-with-resources-语句替代-try-finally-语句" class="headerlink" title="使用 try-with-resources 语句替代 try-finally 语句"></a>使用 try-with-resources 语句替代 try-finally 语句</h1><p>从以往来看，try-finally 语句是保证资源正确关闭的最佳方式，即使是在程序抛出异常或返回的情况下：</p><pre><code>// try-finally - No longer the best way to close resources!static String firstLineOfFile(String path) throws IOException {    BufferedReader br = new BufferedReader(new FileReader(path));    try {        return br.readLine();    } finally {        br.close();    }}</code></pre><p>这可能看起来并不坏，但是当添加第二个资源时，情况会变得更糟：</p><pre><code>// try-finally is ugly when used with more than one resource!static void copy(String src, String dst) throws IOException {    InputStream in = new FileInputStream(src);    try {        OutputStream out = new FileOutputStream(dst);        try {            byte[] buf = new byte[BUFFER_SIZE];            int n;            while ((n = in.read(buf)) &gt;= 0)                out.write(buf, 0, n);        } finally {            out.close();        }    } finally {        in.close();    }}</code></pre><p>即使是用 try-finally 语句关闭资源的正确代码，如前面两个代码示例所示，也有一个微妙的缺陷。 try-with-resources 块和 finally 块中的代码都可以抛出异常。 例如，在前面的 firstLineOfFile 方法中，由于底层物理设备发生故障，对 readLine 方法的调用可能会引发异常，并且由于相同的原因，调用 close 方法可能会失败。 在这种情况下，第二个异常完全冲掉了第一个异常。 在异常堆栈跟踪中没有第一个异常的记录，这可能使实际系统中的调试非常复杂——通常这是你想要诊断问题的第一个异常。 虽然可以编写代码来抑制第二个异常，但是实际上没有人这样做，因为它太冗长了。</p><p>　　当 Java 7 引入了 try-with-resources 语句时，所有这些问题一下子都得到了解决。要使用这个构造，资源必须实现 AutoCloseable 接口，该接口由一个返回为 void 的 close 组成。Java 类库和第三方类库中的许多类和接口现在都实现或继承了 AutoCloseable 接口。如果你编写的类表示必须关闭的资源，那么这个类也应该实现 AutoCloseable 接口。</p><p>　　以下是我们的第一个使用 try-with-resources 的示例：</p><pre><code>// try-with-resources - the the best way to close resources!static String firstLineOfFile(String path) throws IOException {    try (BufferedReader br = new BufferedReader(new FileReader(path))) {       return br.readLine();    }}</code></pre><p>　以下是我们的第二个使用 try-with-resources 的示例：</p><pre><code>// try-with-resources on multiple resources - short and sweetstatic void copy(String src, String dst) throws IOException {    try (InputStream   in = new FileInputStream(src);         OutputStream out = new FileOutputStream(dst)) {        byte[] buf = new byte[BUFFER_SIZE];        int n;        while ((n = in.read(buf)) &gt;= 0)            out.write(buf, 0, n);    }}</code></pre><p>不仅 try-with-resources 版本比原始版本更精简，更好的可读性，而且它们提供了更好的诊断。 考虑 firstLineOfFile 方法。 如果调用 readLine 和（不可见）close 方法都抛出异常，则后一个异常将被抑制（suppressed），而不是前者。 事实上，为了保留你真正想看到的异常，可能会抑制多个异常。 这些抑制的异常没有被抛弃， 而是打印在堆栈跟踪中，并标注为被抑制了。 你也可以使用 getSuppressed 方法以编程方式访问它们，该方法在 Java 7 中已添加到的 Throwable 中。</p><p>　　可以在 try-with-resources 语句中添加 catch 子句，就像在常规的 try-finally 语句中一样。这允许你处理异常，而不会在另一层嵌套中污染代码。作为一个稍微有些做作的例子，这里有一个版本的 firstLineOfFile 方法，它不会抛出异常，但是如果它不能打开或读取文件，则返回默认值：</p><pre><code>// try-with-resources with a catch clausestatic String firstLineOfFile(String path, String defaultVal) {    try (BufferedReader br = new BufferedReader(           new FileReader(path))) {        return br.readLine();    } catch (IOException e) {        return defaultVal;    }}</code></pre><p>结论很明确：在处理必须关闭的资源时，使用 try-with-resources 语句替代 try-finally 语句。 生成的代码更简洁，更清晰，并且生成的异常更有用。 try-with-resources 语句在编写必须关闭资源的代码时会更容易，也不会出错，而使用 try-finally 语句实际上是不可能的。</p><h1 id="重写-equals-方法时遵守通用约定"><a href="#重写-equals-方法时遵守通用约定" class="headerlink" title="重写 equals 方法时遵守通用约定"></a>重写 equals 方法时遵守通用约定</h1><p>写在前面的读后感：这一节十分冗长，作者举例说明了尽量不要重写equals方法，如果一定要重写，那么要按照约定遵循自反性，对称性，传递性，一致性和非空性。</p><p>　虽然 Object 是一个具体的类，但它主要是为继承而设计的。它的所有非 final 方法（equals、hashCode、toString、clone 和 finalize）都有清晰的通用约定（ general contracts），因为它们被设计为被子类重写。任何类要重写这些方法时，都有义务去遵从它们的通用约定；如果不这样做，将会阻止其他依赖于约定的类 (例如 HashMap 和 HashSet) 与此类一起正常工作。</p><p>重写 equals 方法看起来很简单，但是有很多方式会导致重写出错，其结果可能是可怕的。避免此问题的最简单方法是不覆盖 equals 方法，在这种情况下，类的每个实例只与自身相等。如果满足以下任一下条件，则说明是正确的做法：</p><p>每个类的实例都是固有唯一的。 对于像 Thread 这样代表活动实体而不是值的类来说，这是正确的。 Object 提供的 equals 实现对这些类完全是正确的行为。</p><p>类不需要提供一个「逻辑相等（logical equality）」的测试功能。例如 java.util.regex.Pattern 可以重写 equals 方法检查两个是否代表完全相同的正则表达式 Pattern 实例，但是设计者并不认为客户需要或希望使用此功能。在这种情况下，从 Object 继承的 equals 实现是最合适的。</p><p>父类已经重写了 equals 方法，则父类行为完全适合于该子类。例如，大多数 Set 从 AbstractSet 继承了 equals 实现、List 从 AbstractList 继承了 equals 实现，Map 从 AbstractMap 的 Map 继承了 equals 实现。</p><p>类是私有的或包级私有的，可以确定它的 equals 方法永远不会被调用。如果你非常厌恶风险，可以重写 equals 方法，以确保不会被意外调用：</p><pre><code>@Overridepublic boolean equals(Object o) {    throw new AssertionError(); // Method is never called}</code></pre><p>什么时候需要重写 equals 方法呢？如果一个类包含一个逻辑相等（logical equality）的概念，此概念有别于对象标识（object identity），而且父类还没有重写过 equals 方法。这通常用在值类（value classes）的情况。值类只是一个表示值的类，例如 Integer 或 String 类。程序员使用 equals 方法比较值对象的引用，期望发现它们在逻辑上是否相等，而不是引用相同的对象。重写 equals 方法不仅可以满足程序员的期望，它还支持重写过 equals 的实例作为 Map 的键（key），或者 Set 里的元素，以满足预期和期望的行为。</p><p>　　一种不需要 equals 方法重写的值类是使用实例控制（instance control）（详见第 1 条）的类，以确保每个值至多存在一个对象。 枚举类型（详见第 34 条）属于这个类别。 对于这些类，逻辑相等与对象标识是一样的，所以 Object 的 equals 方法作用逻辑 equals 方法。</p><p>　　当你重写 equals 方法时，必须遵守它的通用约定。Object 的规范如下： equals 方法实现了一个等价关系（equivalence relation）。它有以下这些属性:</p><p><strong><em>自反性</em></strong>： 对于任何非空引用 x，x.equals(x) 必须返回 true。<br><strong><em>对称性</em></strong>： 对于任何非空引用 x 和 y，如果且仅当 y.equals(x) 返回 true 时 x.equals(y) 必须返回 true。<br><strong><em>传递性</em></strong>： 对于任何非空引用 x、y、z，如果 x.equals(y) 返回 true，y.equals(z) 返回 true，则 x.equals(z) 必须返回 true。<br><strong><em>一致性</em></strong>： 对于任何非空引用 x 和 y，如果在 equals 比较中使用的信息没有修改，则 x.equals(y) 的多次调用必须始终返回 true 或始终返回 false。<br><strong><em>非空性</em></strong>：<br>对于任何非空引用 x，x.equals(null) 必须返回 false。</p><p>　　除非你喜欢数学，否则这看起来有点吓人，但不要忽略它！如果一旦违反了它，很可能会发现你的程序运行异常或崩溃，并且很难确定失败的根源。套用约翰·多恩（John Donne）的说法，没有哪个类是孤立存在的。一个类的实例常常被传递给另一个类的实例。许多类，包括所有的集合类，都依赖于传递给它们遵守 equals 约定的对象。</p><p>　　既然已经意识到违反 equals 约定的危险，让我们详细地讨论一下这个约定。好消息是，表面上看，这并不是很复杂。一旦你理解了，就不难遵守这一约定。</p><p>　　那么什么是等价关系？ 笼统地说，它是一个运算符，它将一组元素划分为彼此元素相等的子集。 这些子集被称为等价类（equivalence classes）。 为了使 equals 方法有用，每个等价类中的所有元素必须从用户的角度来说是可以互换（interchangeable）的。 现在让我们依次看下这个五个要求：</p><p>　　自反性（Reflexivity）——第一个要求只是说一个对象必须与自身相等。 很难想象无意中违反了这个规定。 如果你违反了它，然后把类的实例添加到一个集合中，那么 contains 方法可能会说集合中没有包含刚添加的实例。</p><p>　　对称性（Symmetry）——第二个要求是，任何两个对象必须在是否相等的问题上达成一致。与第一个要求不同的是，我们不难想象在无意中违反了这一要求。例如，考虑下面的类，它实现了不区分大小写的字符串。字符串被 toString 保存，但在 equals 比较中被忽略：</p><pre><code>import java.util.Objects;public final class CaseInsensitiveString {    private final String s;    public CaseInsensitiveString(String s){        this.s = Objects.requireNonNull(s);    }    // Broken - violates symmetry!    @Override    public boolean equals(Object o){        if(o instanceof CaseInsensitiveString){            return s.equalsIgnoreCase(                    ((CaseInsensitiveString)o).s);        }        if(o instanceof String){// One-way interoperability!            return s.equalsIgnoreCase((String)o);        }        return false;    }}</code></pre><p>上面CaseInsensitiveString（大小写不敏感）类中的 equals 试图与正常的字符串进行操作，假设我们有一个不区分大小写的字符串和一个正常的字符串：</p><pre><code>CaseInsensitiveString cis = new CaseInsensitiveString(&quot;Polish&quot;);String s = &quot;polish&quot;;System.out.println(cis.equals(s)); // trueSystem.out.println(s.equals(cis)); // false</code></pre><p>正如所料，cis.equals(s) 返回 true。 问题是，尽管 CaseInsensitiveString 类中的 equals 方法知道正常字符串，但 String 类中的 equals 方法却忽略了不区分大小写的字符串。 因此，s.equals(cis) 返回 false，明显违反对称性。 假设把一个不区分大小写的字符串放入一个集合中：</p><pre><code>List&lt;CaseInsensitiveString&gt; list = new ArrayList&lt;&gt;();list.add(cis);</code></pre><p>list.contains(s) 返回了什么？谁知道呢？在当前的 OpenJDK 实现中，它会返回 false，但这只是一个实现构件。在另一个实现中，它可以很容易地返回 true 或抛出运行时异常。一旦违反了 equals 约定，就不知道其他对象在面对你的对象时会如何表现了。</p><p>　　要消除这个问题，只需删除 equals 方法中与 String 类相互操作的恶意尝试。这样做之后，可以将该方法重构为单个返回语句:</p><pre><code>@Overridepublic boolean equals(Object o) {    return o instanceof CaseInsensitiveString &amp;&amp;            ((CaseInsensitiveString) o).s.equalsIgnoreCase(s);}</code></pre><p>传递性（Transitivity）—— equals 约定的第三个要求是，如果第一个对象等于第二个对象，第二个对象等于第三个对象，那么第一个对象必须等于第三个对象。同样，也不难想象，无意中违反了这一要求。考虑子类的情况， 将新值组件（value component）添加到其父类中。换句话说，子类添加了一个信息，它影响了 equals 方法比较。让我们从一个简单不可变的二维整数类型 Point 类开始：</p><pre><code>public class Point {    private final int x;    private final int y;    public Point(int x, int y) {        this.x = x;        this.y = y;    }    @Override    public boolean equals(Object o) {        if (!(o instanceof Point))            return false;        Point p = (Point) o;        return p.x == x &amp;&amp; p.y == y;    }    ...  // Remainder omitted}</code></pre><p>假设想继承这个类，将表示颜色的 Color 类添加到 Point 类中：</p><pre><code>public class ColorPoint extends Point {    private final Color color;    public ColorPoint(int x, int y, Color color) {        super(x, y);        this.color = color;    }    ...  // Remainder omitted}</code></pre><p>equals 方法应该是什么样子？如果完全忽略，则实现是从 Point 类上继承的，颜色信息在 equals 方法比较中被忽略。虽然这并不违反 equals 约定，但这显然是不可接受的。假设你写了一个 equals 方法，它只在它的参数是另一个具有相同位置和颜色的 ColorPoint 实例时返回 true：</p><pre><code>// Broken - violates symmetry!@Overridepublic boolean equals(Object o) {    if (!(o instanceof ColorPoint))        return false;    return super.equals(o) &amp;&amp; ((ColorPoint) o).color == color;}</code></pre><p>当你比较 Point 对象和 ColorPoint 对象时，可以会得到不同的结果，反之亦然。前者的比较忽略了颜色属性，而后者的比较会一直返回 false，因为参数的类型是错误的。为了让问题更加具体，我们创建一个 Point 对象和 ColorPoint 对象：</p><pre><code>Point p = new Point(1, 2);ColorPoint cp = new ColorPoint(1, 2, Color.RED);</code></pre><p>　　p.equals(cp) 返回 true，但是 cp.equals(p) 返回 false。你可能想使用 ColorPoint.equals 通过混合比较的方式来解决这个问题。</p><pre><code>@Overridepublic boolean equals(Object o) {if (!(o instanceof Point))    return false;// If o is a normal Point, do a color-blind comparisonif (!(o instanceof ColorPoint))    return o.equals(this);// o is a ColorPoint; do a full comparisonreturn super.equals(o) &amp;&amp; ((ColorPoint) o).color == color;}</code></pre><p>这种方法确实提供了对称性，但是丧失了传递性：</p><pre><code>ColorPoint p1 = new ColorPoint(1, 2, Color.RED);Point p2 = new Point(1, 2);ColorPoint p3 = new ColorPoint(1, 2, Color.BLUE);</code></pre><p>现在，p1.equals(p2) 和 p2.equals(p3) 返回了 true，但是 p1.equals(p3) 却返回了 false，很明显违背了传递性的要求。前两个比较都是不考虑颜色信息的，而第三个比较时却包含颜色信息。</p><p>　　此外，这种方法可能导致无限递归：假设有两个 Point 的子类，比如 ColorPoint 和 SmellPoint，每个都有这种 equals 方法。 然后调用 myColorPoint.equals(mySmellPoint) 将抛出一个 StackOverflowError 异常。</p><p>　　那么解决方案是什么？ 事实证明，这是面向对象语言中关于等价关系的一个基本问题。 除非您愿意放弃面向对象抽象的好处，否则无法继承可实例化的类，并在保留 equals 约定的同时添加一个值组件。</p><p>　　你可能听说过，可以继承一个可实例化的类并添加一个值组件，同时通过在 equals 方法中使用一个 getClass 测试代替 instanceof 测试来保留 equals 约定：</p><pre><code>@Overridepublic boolean equals(Object o) {    if (o == null || o.getClass() != getClass())        return false;    Point p = (Point) o;    return p.x == x &amp;&amp; p.y == y;}</code></pre><p>　只有当对象具有相同的实现类时，才会产生相同的效果。这看起来可能不是那么糟糕，但是结果是不可接受的:一个 Point 类子类的实例仍然是一个 Point 的实例，它仍然需要作为一个 Point 来运行，但是如果你采用这个方法，就会失败！假设我们要写一个方法来判断一个 Point 对象是否在 unitCircle 集合中。我们可以这样做：</p><pre><code>private static final Set&lt;Point&gt; unitCircle = Set.of(        new Point( 1,  0), new Point( 0,  1),        new Point(-1,  0), new Point( 0, -1));public static boolean onUnitCircle(Point p) {    return unitCircle.contains(p);}</code></pre><p>　虽然这可能不是实现功能的最快方法，但它可以正常工作。假设以一种不添加值组件的简单方式继承 Point 类，比如让它的构造方法跟踪记录创建了多少实例：</p><pre><code>public class CounterPoint extends Point {    private static final AtomicInteger counter =            new AtomicInteger();    public CounterPoint(int x, int y) {        super(x, y);        counter.incrementAndGet();    }    public static int numberCreated() {        return counter.get();    }}</code></pre><p>里氏替代原则（Liskov substitution principle）指出，任何类型的重要属性都应该适用于所有的子类型，因此任何为这种类型编写的方法都应该在其子类上同样适用。 这是我们之前声明的一个正式陈述，即 Point 的子类（如 CounterPoint）仍然是一个 Point，必须作为一个 Point 类来看待。 但是，假设我们将一个 CounterPoint 对象传递给 onUnitCircle 方法。 如果 Point 类使用基于 getClass 的 equals 方法，则无论 CounterPoint 实例的 x 和 y 坐标如何，onUnitCircle 方法都将返回 false。 这是因为大多数集合（包括 onUnitCircle 方法使用的 HashSet）都使用 equals 方法来测试是否包含元素，并且 CounterPoint 实例并不等于任何 Point 实例。 但是，如果在 Point 上使用了适当的基于 instanceof 的 equals 方法，则在使用 CounterPoint 实例呈现时，同样的 onUnitCircle 方法可以正常工作。</p><p>　　虽然没有令人满意的方法来继承一个可实例化的类并添加一个值组件，但是有一个很好的变通方法：按照条目 18 的建议，“优先使用组合而不是继承”。取代继承 Point 类的 ColorPoint 类，可以在 ColorPoint 类中定义一个私有 Point 属性，和一个公共的视图（view）（详见第 6 条）方法，用来返回具有相同位置的 ColorPoint 对象。</p><pre><code>// Adds a value component without violating the equals contractpublic class ColorPoint {    private final Point point;    private final Color color;    public ColorPoint(int x, int y, Color color) {        point = new Point(x, y);        this.color = Objects.requireNonNull(color);    }    /**     * Returns the point-view of this color point.     */    public Point asPoint() {        return point;    }    @Override    public boolean equals(Object o) {        if (!(o instanceof ColorPoint))            return false;        ColorPoint cp = (ColorPoint) o;        return cp.point.equals(point) &amp;&amp; cp.color.equals(color);    }    ...    // Remainder omitted}</code></pre><p>Java 平台类库中有一些类可以继承可实例化的类并添加一个值组件。 例如，java.sql.Timestamp 继承了 java.util.Date 并添加了一个 nanoseconds 字段。 Timestamp 的等价 equals 确实违反了对称性，并且如果 Timestamp 和 Date 对象在同一个集合中使用，或者以其他方式混合使用，则可能导致不稳定的行为。 Timestamp 类有一个免责声明，告诫程序员不要混用 Timestamp 和 Date。 虽然只要将它们分开使用就不会遇到麻烦，但没有什么可以阻止你将它们混合在一起，并且由此产生的错误可能很难调试。 Timestamp 类的这种行为是一个错误，不应该被仿效。</p><p>你可以将值组件添加到抽象类的子类中，而不会违反 equals 约定。这对于通过遵循第 23 个条目中“优先考虑类层级（class hierarchies）来代替标记类（tagged classes）”中的建议而获得的类层级，是非常重要的。例如，可以有一个没有值组件的抽象类 Shape，子类 Circle 有一个 radius 属性，另一个子类 Rectangle 包含 length 和 width 属性 。 只要不直接创建父类实例，就不会出现前面所示的问题。</p><p>　　一致性（Consistent）——equals 约定的第四个要求是，如果两个对象是相等的，除非一个（或两个）对象被修改了， 那么它们必须始终保持相等。 换句话说，可变对象可以在不同时期可以与不同的对象相等，而不可变对象则不会。 当你写一个类时，要认真思考它是否应该设计为不可变的（详见第 17 条）。 如果你认为应该这样做，那么确保你的 equals 方法强制执行这样的限制：相等的对象永远相等，不相等的对象永远都不会相等。</p><p>　　不管一个类是不是不可变的，都不要写一个依赖于不可靠资源的 equals 方法。 如果违反这一禁令，满足一致性要求是非常困难的。 例如，java.net.URL 类中的 equals 方法依赖于与 URL 关联的主机的 IP 地址的比较。 将主机名转换为 IP 地址可能需要访问网络，并且不能保证随着时间的推移会产生相同的结果。 这可能会导致 URL 类的 equals 方法违反 equals 约定，并在实践中造成问题。 URL 类的 equals 方法的行为是一个很大的错误，不应该被效仿。 不幸的是，由于兼容性的要求，它不能改变。 为了避免这种问题，equals 方法应该只对内存驻留对象执行确定性计算。</p><p>　　非空性（Non-nullity）——最后 equals 约定的要求没有官方的名称，所以我冒昧地称之为“非空性”。意思是说说所有的对象都必须不等于 null。虽然很难想象在调用 o.equals(null) 的响应中意外地返回 true，但不难想象不小心抛出 NullPointerException 异常的情况。通用的约定禁止抛出这样的异常。许多类中的 equals 方法都会明确阻止对象为 null 的情况：</p><pre><code>@Overridepublic boolean equals(Object o) {    if (o == null)        return false;    ...}</code></pre><p>　这个判断是不必要的。 为了测试它的参数是否相等，equals 方法必须首先将其参数转换为合适类型，以便调用访问器或允许访问的属性。 在执行类型转换之前，该方法必须使用 instanceof 运算符来检查其参数是否是正确的类型：</p><pre><code>@Overridepublic boolean equals(Object o) {    if (!(o instanceof MyType))        return false;    MyType mt = (MyType) o;    ...}</code></pre><p>如果此类型检查漏掉，并且 equals 方法传递了错误类型的参数，那么 equals 方法将抛出 ClassCastException 异常，这违反了 equals 约定。 但是，如果第一个操作数为 null，则指定 instanceof 运算符返回 false，而不管第二个操作数中出现何种类型[JLS，15.20.2]。 因此，如果传入 null，类型检查将返回 false，因此不需要 明确的 null 检查。</p><p>划重点：<br>　　<strong>* 综合起来，以下是编写高质量 equals 方法的配方（recipe）：*</strong></p><p>1.使用 == 运算符检查参数是否为该对象的引用。如果是，返回 true。这只是一种性能优化，但是如果这种比较可能很昂贵的话，那就值得去做。</p><p>2.使用 instanceof 运算符来检查参数是否具有正确的类型。 如果不是，则返回 false。 通常，正确的类型是 equals 方法所在的那个类。 有时候，改类实现了一些接口。 如果类实现了一个接口，该接口可以改进 equals 约定以允许实现接口的类进行比较，那么使用接口。 集合接口（如 Set，List，Map 和 Map.Entry）具有此特性。</p><p>3.参数转换为正确的类型。因为转换操作在 instanceof 中已经处理过，所以它肯定会成功。</p><p>4.对于类中的每个「重要」的属性，请检查该参数属性是否与该对象对应的属性相匹配。如果所有这些测试成功，返回 true，否则返回 false。如果步骤 2 中的类型是一个接口，那么必须通过接口方法访问参数的属性;如果类型是类，则可以直接访问属性，这取决于属性的访问权限。</p><p>　　对于类型为非 float 或 double 的基本类型，使用 == 运算符进行比较；对于对象引用属性，递归地调用 equals 方法；对于 float 基本类型的属性，使用静态 Float.compare(float, float) 方法；对于 double 基本类型的属性，使用 Double.compare(double, double) 方法。由于存在 Float.NaN，-0.0f 和类似的 double 类型的值，所以需要对 float 和 double 属性进行特殊的处理；有关详细信息，请参阅 JLS 15.21.1 或 Float.equals 方法的详细文档。 虽然你可以使用静态方法 Float.equals 和 Double.equals 方法对 float 和 double 基本类型的属性进行比较，这会导致每次比较时发生自动装箱，引发非常差的性能。 对于数组属性，将这些准则应用于每个元素。 如果数组属性中的每个元素都很重要，请使用其中一个重载的 Arrays.equals 方法。</p><p>　　某些对象引用的属性可能合法地包含 null。 为避免出现 NullPointerException 异常，请使用静态方法 Objects.equals(Object, Object) 检查这些属性是否相等。</p><p>　　对于一些类，例如上的 CaseInsensitiveString 类，属性比较相对于简单的相等性测试要复杂得多。在这种情况下，你想要保存属性的一个规范形式（canonical form），这样 equals 方法就可以基于这个规范形式去做开销很小的精确比较，来取代开销很大的非标准比较。这种方式其实最适合不可变类（详见第 17 条）。一旦对象发生改变，一定要确保把对应的规范形式更新到最新。</p><p>　　equals 方法的性能可能受到属性比较顺序的影响。 为了获得最佳性能，你应该首先比较最可能不同的属性，开销比较小的属性，或者最好是两者都满足（derived fields）。 你不要比较不属于对象逻辑状态的属性，例如用于同步操作的 lock 属性。 不需要比较可以从“重要属性”计算出来的派生属性，但是这样做可以提高 equals 方法的性能。 如果派生属性相当于对整个对象的摘要描述，比较这个属性将节省在比较失败时再去比较实际数据的开销。 例如，假设有一个 Polygon 类，并缓存该区域。 如果两个多边形的面积不相等，则不必费心比较它们的边和顶点。</p><p>　　当你完成编写完 equals 方法时，问你自己三个问题：它是对称的吗?它是传递吗?它是一致的吗?除此而外，编写单元测试加以排查，除非使用 AutoValue 框架（第 49 页）来生成 equals 方法，在这种情况下可以安全地省略测试。如果持有的属性失败，找出原因，并相应地修改 equals 方法。当然，equals 方法也必须满足其他两个属性 (自反性和非空性)，但这两个属性通常都会满足。</p><p>　　在下面这个简单的 PhoneNumber 类中展示了根据之前的配方构建的 equals 方法：</p><pre><code>public final class PhoneNumber {    private final short areaCode, prefix, lineNum;    public PhoneNumber(int areaCode, int prefix, int lineNum) {        this.areaCode = rangeCheck(areaCode, 999, &quot;area code&quot;);        this.prefix = rangeCheck(prefix, 999, &quot;prefix&quot;);        this.lineNum = rangeCheck(lineNum, 9999, &quot;line num&quot;);    }    private static short rangeCheck(int val, int max, String arg) {        if (val &lt; 0 || val &gt; max)            throw new IllegalArgumentException(arg + &quot;: &quot; + val);        return (short) val;    }    @Override    public boolean equals(Object o) {        if (o == this)            return true;        if (!(o instanceof PhoneNumber))            return false;        PhoneNumber pn = (PhoneNumber) o;        return pn.lineNum == lineNum &amp;&amp; pn.prefix == prefix                &amp;&amp; pn.areaCode == areaCode;    }    ... // Remainder omitted}</code></pre><p>以下是一些最后提醒：</p><p>当重写 equals 方法时，同时也要重写 hashCode 方法（详见第 11 条）。<br>不要让 equals 方法试图太聪明。 如果只是简单地测试用于相等的属性，那么要遵守 equals 约定并不困难。如果你在寻找相等方面过于激进，那么很容易陷入麻烦。一般来说，考虑到任何形式的别名通常是一个坏主意。例如，File 类不应该试图将引用的符号链接等同于同一文件对象。幸好 File 类并没这么做。<br>在 equal 时方法声明中，不要将参数 Object 替换成其他类型。 对于程序员来说，编写一个看起来像这样的 equals 方法并不少见，然后花上几个小时苦苦思索为什么它不能正常工作：</p><pre><code>// Broken - parameter type must be Object!public boolean equals(MyClass o) {       …}</code></pre><p>　问题在于这个方法并没有重写 Object.equals 方法，它的参数是 Object 类型的，这样写只是重载了 equals 方法（详见第 52 条）。 即使除了正常的方法之外，提供这种“强类型”的 equals 方法也是不可接受的，因为它可能会导致子类中的 Override 注解产生误报，提供不安全的错觉。 在这里，使用 Override 注解会阻止你犯这个错误 （详见第 40 条）。这个 equals 方法不会编译，错误消息会告诉你到底错在哪里：</p><p>编写和测试 equals（和 hashCode）方法很繁琐，生的代码也很普通。替代手动编写和测试这些方法的优雅的手段是，使用谷歌 AutoValue 开源框架，该框架自动为你生成这些方法，只需在类上添加一个注解即可。在大多数情况下，AutoValue 框架生成的方法与你自己编写的方法本质上是相同的。</p><p>　　很多 IDE（例如 Eclipse，NetBeans，IntelliJ IDEA 等）也有生成 equals 和 hashCode 方法的功能，但是生成的源代码比使用 AutoValue 框架的代码更冗长、可读性更差，不会自动跟踪类中的更改，因此需要进行测试。这就是说，使用 IDE 工具生成 equals(和 hashCode) 方法通常比手动编写它们更可取，因为 IDE 工具不会犯粗心大意的错误，而人类则会。</p><p>　　总之，除非必须：在很多情况下，不要重写 equals 方法，从 Object 继承的实现完全是你想要的。 如果你确实重写了 equals 方法，那么一定要比较这个类的所有重要属性，并且以保护前面 equals 约定里五个规定的方式去比较。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="http://sjsdfg.gitee.io/effective-java-3rd-chinese/#/notes/10.%20%E9%87%8D%E5%86%99equals%E6%96%B9%E6%B3%95%E6%97%B6%E9%81%B5%E5%AE%88%E9%80%9A%E7%94%A8%E7%BA%A6%E5%AE%9A" target="_blank" rel="noopener">http://sjsdfg.gitee.io/effective-java-3rd-chinese/#/notes/10.%20%E9%87%8D%E5%86%99equals%E6%96%B9%E6%B3%95%E6%97%B6%E9%81%B5%E5%AE%88%E9%80%9A%E7%94%A8%E7%BA%A6%E5%AE%9A</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第三章阅读：Methods Common to All Objects&lt;br&gt;09.使用 try-with-resources 语句替代 try-finally 语句&lt;br&gt;10.重写 equals 方法时遵守通用约定&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Hexo标签与md文件冲突问题解决</title>
    <link href="http://yoursite.com/2020/01/03/Hexo%E6%A0%87%E7%AD%BE%E4%B8%8Emd%E6%96%87%E4%BB%B6%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>http://yoursite.com/2020/01/03/Hexo标签与md文件冲突问题解决/</id>
    <published>2020-01-03T10:23:12.000Z</published>
    <updated>2020-01-15T07:19:44.739Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo标签与md文件冲突问题解决</p><a id="more"></a><p>今天使用 Github+Hexo 搭建的博客写文章时遇到一个 Bug，查阅资料解决之后，发现很多人都遇到过由于 nunjucks 模板标签导致 MD 文件解析报错的问题，于是记录一下这个问题的解决方法。</p><h1 id="报错及原因"><a href="#报错及原因" class="headerlink" title="报错及原因"></a>报错及原因</h1><p>  今天使用 hexo generate 生成文章时，出现了如下报错：</p><pre><code>INFO  Start processingFATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlTemplate render error: (unknown path) [Line 17, Column 30]  unexpected token: }}    at Object._prettifyError</code></pre><p>出现上述情况的原因是 Markdown 文件中内容含有的双大括号 标签与 nunjucks 模板引擎的标签发生了冲突。双大括号等这些标签都是模板引擎的占位标签，如果 MarkDown 文件中包含这些标签，且不被 ``` 代码块包裹，那么解析时就会把 MD 文件中的标签动态解析了，于是导致 MD 文件解析时报错。</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><h2 id="修改-Markdown-文件"><a href="#修改-Markdown-文件" class="headerlink" title="修改 Markdown 文件"></a>修改 Markdown 文件</h2><p>将含有双大括号的内容首尾添加如下标签进行处理：</p><pre><code>{% raw %}    {{ 双大括号内包裹的内容 }}    {% endraw %}</code></pre><p>用这个标签虽然可以解决问题，但之后再遇到类似的情况每次都需要对 MarkDown 文件进行修改。下面介绍一种更便捷的方法。</p><h2 id="修改-nunjucks-模块源代码"><a href="#修改-nunjucks-模块源代码" class="headerlink" title="修改 nunjucks 模块源代码"></a>修改 nunjucks 模块源代码</h2><p>我们还可以直接在 nunjucks 模块上修改源代码，更改有冲突的渲染标签。<br>首先打开这个文件，路径如下：<br>    node_modules/nunjucks/src/lexer.js<br>找到下述两行代码：</p><pre><code>var VARIABLE_START = &apos;{{';    var VARIABLE_END = '}}&apos;;</code></pre><p>将其修改为：</p><pre><code>var VARIABLE_START = &apos;{$&apos;;var VARIABLE_END = &apos;$}&apos;;</code></pre><p>将有冲突的模板引擎的占位符更改为其他字符，进行模板解析时就不会与 MarkDown 的内容发生冲突了，且这种方法对所有 MarkDown 文件都是有效的，一劳永逸。<br>类似的，如果出现类似符号的解析错误时，也可以根据情况将其更改为其他占位符（自定义）。</p><h2 id="搜索、RSS-插件同步修改"><a href="#搜索、RSS-插件同步修改" class="headerlink" title="搜索、RSS 插件同步修改"></a>搜索、RSS 插件同步修改</h2><p>若博客使用 hexo-generator-search 或 hexo-generator-feed 等其他依赖于 nunjucks 模板的插件，那么这些插件的模板处理标签也需要进行同步修改。以搜索插件为例，打开如下路径的文件：<br>node_modules/hexo-generator-search/templates/search.xml<br>根据之前修改的 nunjucks 的内容，将此文件的  也更改为 {$ 和 $} 即可。</p><h1 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h1><p>如果在项目下执行 npm install 更新 nunjucks 模板时，那么之前更改的内容会被还原，需要重新对有冲突的符号进行更改。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>【1】<a href="https://www.jianshu.com/p/6032a1a2dc25" target="_blank" rel="noopener">https://www.jianshu.com/p/6032a1a2dc25</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hexo标签与md文件冲突问题解决&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Java编程思想-第二十三章阅读笔记</title>
    <link href="http://yoursite.com/2020/01/03/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%89%E7%AB%A0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/01/03/Java编程思想-第二十三章阅读笔记/</id>
    <published>2020-01-03T08:12:12.000Z</published>
    <updated>2020-01-03T07:51:20.308Z</updated>
    
    <content type="html"><![CDATA[<p>第二十三章 注解</p><a id="more"></a><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://lingcoder.github.io/OnJava8/#/book/23-Annotations?id=%e5%9f%ba%e6%9c%ac%e8%af%ad%e6%b3%95" target="_blank" rel="noopener">https://lingcoder.github.io/OnJava8/#/book/23-Annotations?id=%e5%9f%ba%e6%9c%ac%e8%af%ad%e6%b3%95</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二十三章 注解&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java开发中的易错点</title>
    <link href="http://yoursite.com/2020/01/03/Java%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E6%98%93%E9%94%99%E7%82%B9/"/>
    <id>http://yoursite.com/2020/01/03/Java开发中的易错点/</id>
    <published>2020-01-03T08:11:12.000Z</published>
    <updated>2020-01-15T07:23:28.776Z</updated>
    
    <content type="html"><![CDATA[<p>Java开发中的易错点</p><a id="more"></a><h1 id="避免非空判断仅判断是否为empty"><a href="#避免非空判断仅判断是否为empty" class="headerlink" title="避免非空判断仅判断是否为empty"></a>避免非空判断仅判断是否为empty</h1><p>反例：</p><pre><code>public  static  void  main(String[] args){    Map data=new HashMap();    data=null;    if(data.isEmpty()){        return;    }}</code></pre><p>只判断data是否为isEmpty，但当数据为null时会报空指针异常</p><pre><code>Exception in thread &quot;main&quot; java.lang.NullPointerException    at Application.main(Application.java:454)</code></pre><h1 id="log抛出要有详情和具体说明"><a href="#log抛出要有详情和具体说明" class="headerlink" title="log抛出要有详情和具体说明"></a>log抛出要有详情和具体说明</h1><p>反例：</p><pre><code>try {  param = JSONObject.parseObject(methodParam,method.getParameterTypes()[0]);} catch (Exception e){  throw new ParamException(e.getMessage());}</code></pre><p>信息需要详细具体，参见<br>正例：</p><pre><code>try {  ...} catch (IOException e){  logger.error(&quot;....Failed&quot;,e);  return null;}</code></pre><h1 id="配置文件尽量在配置文件定义，代码中不要配置"><a href="#配置文件尽量在配置文件定义，代码中不要配置" class="headerlink" title="配置文件尽量在配置文件定义，代码中不要配置"></a>配置文件尽量在配置文件定义，代码中不要配置</h1><p>反例：</p><p>  String ip=”127.0.0.1”;<br>  Socket socket=new Socket(ip,6667);</p><p>正例：</p><p>  String ip= System.getProperty(“myapplication.ip”);<br>  Socket socket=new Socket(ip,6667);</p><h1 id="精度转换"><a href="#精度转换" class="headerlink" title="精度转换"></a>精度转换</h1><p>BigDecimal转double，需先转换为string再 BigDecimal（String s），再使用BigDecimal.valueOf()方法，避免精度丢失</p><p>BigDecimal(double val)构造，用double当参数来构造一个BigDecimal对象。<br>但是BigDecimal(0.1)实际上等于0.1000000000000000055511151231257827021181583404541015625，因为准确的来说0.1本身不能算是一个double（其实0.1不能代表任何一个定长二进制分数）。</p><p>BigDecimal(String val)构造是靠谱的，BigDecimal(“0.1”)就是等于0.1，推荐大家用这个构造。</p><p>如果非要用一个double变量来构造一个BigDecimal，请使用静态方法valueOf(double)，这个方法跟new Decimal(Double.toString(double))效果是一样的。</p><pre><code>public static void doubleToBigDecimal(){    float f=0.1f;    BigDecimal decimal1=new BigDecimal(f);    System.out.println(decimal1);    double d=0.1;    BigDecimal decimal2=new BigDecimal(d);    System.out.println(decimal2);    BigDecimal decimal3=new BigDecimal(Double.toString(d));    System.out.println(decimal3);    BigDecimal decimal4=BigDecimal.valueOf(d);    System.out.println(decimal4);}</code></pre><p>输出结果：</p><pre><code>0.1000000014901161193847656250.10000000000000000555111512312578270211815834045410156250.10.1</code></pre><h1 id="Map、Set、list初始化"><a href="#Map、Set、list初始化" class="headerlink" title="Map、Set、list初始化"></a>Map、Set、list初始化</h1><pre><code>Map source = new HashMap(){{ // Noncompliant        put("firstName", "John");        put("lastName", "Smith");    }};</code></pre><p>上述方式潜在问题：</p><p>看起来优雅了不少，一步到位。问题来了，这里的双大括号到底什么意思，什么用法呢？<br>双大括号,用来初始化，使代码简洁易读。<br>第一层括弧实际是定义了一个匿名内部类 (Anonymous Inner Class)，第二层括弧实际上是一个实例初始化块 (instance initializer block)，这个块在内部匿名类构造时被执行。</p><p>1.此种方式是匿名内部类的声明方式，所以引用中持有着外部类的引用。所以当时串行化这个集合时外部类也会被不知不觉的串行化，当外部类没有实现serialize接口时，就会报错。</p><p>2.上例中，其实是声明了一个继承自HashMap的子类。然而有些串行化方法，例如要通过Gson串行化为json，或者要串行化为xml时，类库中提供的方式，是无法串行化Hashset或者HashMap的子类的，从而导致串行化失败。<br>解决办法：重新初始化为一个HashMap对象：<br>new HashMap(map);<br>这样就可以正常初始化了。</p><pre><code>Map source = new HashMap() // compliantsource.put(&quot;firstName&quot;, &quot;John&quot;);source.put(&quot;lastName&quot;, &quot;Smith&quot;);</code></pre><h1 id="null值时刻注意非空判断"><a href="#null值时刻注意非空判断" class="headerlink" title="null值时刻注意非空判断"></a>null值时刻注意非空判断</h1><p>反例：</p><pre><code>TreeMap&lt;String,String&gt; paramTreeMap=convertMapToTreeMap(paramMap);try{  .....} catch (Exception e){  throw new FailException(&quot; .... param=&quot;+ paramMap.toString() e);}</code></pre><p>paramMap.toString()这里没有考虑为null的情况</p><h1 id="文件数据流、zip流、字节流等一定要谨记在finally关闭数据流"><a href="#文件数据流、zip流、字节流等一定要谨记在finally关闭数据流" class="headerlink" title="文件数据流、zip流、字节流等一定要谨记在finally关闭数据流"></a>文件数据流、zip流、字节流等一定要谨记在finally关闭数据流</h1><p>反例1:</p><pre><code>private void readFile() throw IOException{  Path path=Paths.get(this.fileName);  BufferedReader reader=Files.newBufferedReader(path,this.charset);  reader.close();   //Noncompliant}</code></pre><p>反例2:</p><pre><code>private void doSomething(){  OutputStream stream=null;  try {    for(String property:propertyList){      stream = new FileOutputStream(&quot;file.txt&quot;); //Noncompliant      // ...    }  } catch (Exception e){    //...  } finally{    stream.close(); //Multiple streams were opened. Only the last is closed.  }}</code></pre><h1 id="返回值尽量不要进行复杂的条件判断，条件和结果尽量清楚明了"><a href="#返回值尽量不要进行复杂的条件判断，条件和结果尽量清楚明了" class="headerlink" title="返回值尽量不要进行复杂的条件判断，条件和结果尽量清楚明了"></a>返回值尽量不要进行复杂的条件判断，条件和结果尽量清楚明了</h1><h1 id="把数组转成ArrayList"><a href="#把数组转成ArrayList" class="headerlink" title="把数组转成ArrayList"></a>把数组转成ArrayList</h1><p>为了将数组转换为ArrayList，开发者经常会这样做：</p><pre><code>List list = Arrays.asList(arr);</code></pre><p>使用Arrays.asList()方法可以得到一个ArrayList，但是得到这个ArrayList其实是定义在Arrays类中的一个私有的静态内部类。这个类虽然和java.util.ArrayList同名，但是并不是同一个类。java.util.Arrays.ArrayList类中实现了set(), get(), contains()等方法，但是并没有定义向其中增加元素的方法。也就是说通过Arrays.asList()得到的ArrayList的大小是固定的。</p><p>如果在开发过程中，想得到一个真正的ArrayList对象（java.util.ArrayList的实例），可以通过以下方式：</p><pre><code>ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(Arrays.asList(arr));</code></pre><p>java.util.ArrayList中包含一个可以接受集合类型参数的构造函数。因为java.util.Arrays.ArrayList这个内部类继承了AbstractList类，所以，该类也是Collection的子类。</p><h1 id="判断一个数组是否包含某个值"><a href="#判断一个数组是否包含某个值" class="headerlink" title="判断一个数组是否包含某个值"></a>判断一个数组是否包含某个值</h1><p>在判断一个数组中是否包含某个值的时候，开发者经常这样做：</p><pre><code>Set&lt;String&gt; set = new HashSet&lt;String&gt;(Arrays.asList(arr));return set.contains(targetValue);</code></pre><p>在《在Java中如何高效的判断数组中是否包含某个元素》[2]中深入分析过,以上方式虽然可以实现功能，但是效率却比较低。因为将数组压入Collection类型中，首先要将数组元素遍历一遍，然后再使用集合类做其他操作。<br>在判断一个数组是否包含某个值的时候，推荐使用for循环遍历的形式或者使用Apache Commons类库中提供的ArrayUtils类的contains方法。</p><h1 id="在循环中删除列表中的元素"><a href="#在循环中删除列表中的元素" class="headerlink" title="在循环中删除列表中的元素"></a>在循环中删除列表中的元素</h1><p>在讨论这个问题之前，先考虑以下代码的输出结果：</p><pre><code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;));for(int i=0;i&lt;list.size();i++){list.remove(i);}System.out.println(list);</code></pre><p>输出结果：</p><pre><code>[b,d]</code></pre><p>以上代码的目的是想遍历删除list中所有元素，但是结果却没有成功。原因是忽略了一个关键的问题：当一个元素被删除时，列表的大小缩小并且下标也会随之变化，所以当你想要在一个循环中用下标删除多个元素的时候，它并不会正常的生效。</p><p>也有些人知道以上代码的问题就由于数组下标变换引起的。所以，他们想到使用增强for循环的形式：</p><pre><code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;));for(String s:list){    if(s.equals(&quot;a&quot;)){        list.remove(s);    }}</code></pre><p>但是，很不幸的是，以上代码会抛出ConcurrentModificationException，有趣的是，如果在remove操作后增加一个break，代码就不会报错：</p><pre><code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;));for(String s:list){    if(s.equals(&quot;a&quot;)){        list.remove(s);        break;    }}</code></pre><p>在《Java中的fail-fast机制》[3]一文中，深入分析了几种在遍历数组的同时删除其中元素的方法以及各种方法存在的问题。其中就介绍了上面的代码出错的原因。<br>迭代器（Iterator）是工作在一个独立的线程中，并且拥有一个 mutex 锁。 迭代器被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，这个索引表的内容不会同步改变，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则 迭代器会马上抛出java.util.ConcurrentModificationException 异常。</p><p>所以，正确的在遍历过程中删除元素的方法应该是使用Iterator：</p><pre><code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;));Iterator&lt;String&gt; iter = list.iterator();while (iter.hasNext()) {    String s = iter.next();    if (s.equals(&quot;a&quot;)) {        iter.remove();    }}</code></pre><p>next()方法必须在调用remove()方法之前调用。如果在循环过程中先调用remove()，再调用next()，就会导致异常ConcurrentModificationException。原因如上。</p><h1 id="HashTable-和-HashMap-的选择"><a href="#HashTable-和-HashMap-的选择" class="headerlink" title="HashTable 和 HashMap 的选择"></a>HashTable 和 HashMap 的选择</h1><p>了解算法的人可能对HashTable比较熟悉，因为他是一个数据结构的名字。但在Java里边，用HashMap来表示这样的数据结构。Hashtable和 HashMap的一个关键性的不同是，HashTable是同步的，而HashMap不是。所以通常不需要HashTable，HashMap用的更多。<br>《HashMap完全解读》[4]、《Java中常见亲属比较》[5]等文章中介绍了他们的区别和如何选择。</p><h1 id="使用原始集合类型"><a href="#使用原始集合类型" class="headerlink" title="使用原始集合类型"></a>使用原始集合类型</h1><p>在Java里边，原始类型和无界通配符类型很容易混合在一起。以Set为例，Set是一个原始类型，而Set&lt; ? &gt;是一个无界通配符类型。 （可以把原始类型理解为没有使用泛型约束的类型）</p><p>考虑下面使用原始类型List作为参数的代码：</p><pre><code>public static void add(List list, Object o){    list.add(o);}public static void main(String[] args){    List&lt;String&gt; list = new ArrayList&lt;String&gt;();    add(list, 10);    String s = list.get(0);}</code></pre><p>上面的代码将会抛出异常：</p><pre><code>java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</code></pre><p>使用原始集合类型是很危险的，因为原始集合类型跳过了泛型类型检查，是不安全的。Set、Set&lt; ? &gt;和Set&lt; Object &gt;之间有很大差别。关于泛型，可以参考下列文章：《Java基础知识——泛型》[12]</p><h1 id="访问级别"><a href="#访问级别" class="headerlink" title="访问级别"></a>访问级别</h1><p>程序员们经常使用public作为类中的字段的修饰符，因为这样可以很简单的通过引用得到值，但这并不是好的设计，按照经验，分配给成员变量的访问级别应该尽可能的低。参考《Java中的四种访问级别》[13]</p><h1 id="ArrayList与LinkedList的选择"><a href="#ArrayList与LinkedList的选择" class="headerlink" title="ArrayList与LinkedList的选择"></a>ArrayList与LinkedList的选择</h1><p>当程序员们不知道ArrayList与LinkedList的区别时，他们经常使用ArrayList，因为它看起来比较熟悉。然而，它们之前有巨大的性能差别。在《ArrayList vs LinkedList vs Vector 区别》[8]、《Java中常见亲属比较》[9]等文章中介绍过，简而言之，如果有大量的增加删除操作并且没有很多的随机访问元素的操作，应该首先LinkedList。（LinkedList更适合从中间插入或者删除（链表的特性））</p><h1 id="可变与不可变"><a href="#可变与不可变" class="headerlink" title="可变与不可变"></a>可变与不可变</h1><p>在《为什么Java要把字符串设计成不可变的》[10]一文中介绍过，不可变对象有许多的优点，比如简单，安全等等。同时，也有人提出疑问：既然不可变有这么多好处，为什么不把所有类都搞成不可变的呢？</p><p>通常情况下，可变对象可以用来避免产生过多的中间对象。一个经典的实例就是连接大量的字符串，如果使用不可变的字符串，将会产生大量的需要进行垃圾回收的对象。这会浪费CPU大量的时间，使用可变对象才是正确的方案(比如StringBuilder)。</p><pre><code>String result=&quot;&quot;;for(String s: arr){    result = result + s;}</code></pre><p>StackOverflow[11]中也有关于这个的讨论。</p><h1 id="””还是构造函数"><a href="#””还是构造函数" class="headerlink" title="””还是构造函数"></a>””还是构造函数</h1><p>关于这个问题，也是程序员经常出现困惑的地方，在《该如何创建字符串，使用” “还是构造函数？》[12]中也介绍过。<br>如果你只需要创建一个字符串，你可以使用双引号的方式，如果你需要在堆中创建一个新的对象，你可以选择构造函数的方式。<br>在String d = new String(“abcd”)时，因为字面值“abcd”已经是字符串类型，那么使用构造函数方式只会创建一个额外没有用处的对象。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="https://www.hollischuang.com/archives/1360" target="_blank" rel="noopener">https://www.hollischuang.com/archives/1360</a><br>【2】<a href="http://www.hollischuang.com/archives/1269" target="_blank" rel="noopener">http://www.hollischuang.com/archives/1269</a><br>【3】<a href="http://www.hollischuang.com/archives/33" target="_blank" rel="noopener">http://www.hollischuang.com/archives/33</a><br>【4】<a href="http://www.hollischuang.com/archives/82" target="_blank" rel="noopener">http://www.hollischuang.com/archives/82</a><br>【5】<a href="http://www.hollischuang.com/archives/442" target="_blank" rel="noopener">http://www.hollischuang.com/archives/442</a><br>【6】<a href="http://www.hollischuang.com/archives/1182" target="_blank" rel="noopener">http://www.hollischuang.com/archives/1182</a><br>【7】<a href="http://www.hollischuang.com/archives/1182" target="_blank" rel="noopener">http://www.hollischuang.com/archives/1182</a><br>【8】<a href="http://www.hollischuang.com/archives/1349" target="_blank" rel="noopener">http://www.hollischuang.com/archives/1349</a><br>【9】<a href="http://www.hollischuang.com/archives/442" target="_blank" rel="noopener">http://www.hollischuang.com/archives/442</a><br>【10】<a href="http://www.hollischuang.com/archives/1246" target="_blank" rel="noopener">http://www.hollischuang.com/archives/1246</a><br>【11】<a href="https://stackoverflow.com/questions/23616211/why-we-need-mutable-classes" target="_blank" rel="noopener">https://stackoverflow.com/questions/23616211/why-we-need-mutable-classes</a><br>【12】<a href="http://www.hollischuang.com/archives/1249" target="_blank" rel="noopener">http://www.hollischuang.com/archives/1249</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java开发中的易错点&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>设计模式学习笔记IV</title>
    <link href="http://yoursite.com/2020/01/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0IV/"/>
    <id>http://yoursite.com/2020/01/03/设计模式学习笔记IV/</id>
    <published>2020-01-03T07:55:12.000Z</published>
    <updated>2020-01-03T07:50:34.899Z</updated>
    
    <content type="html"><![CDATA[<p>建造者（Builder）模式：<br>经典Builder模式；<br>变种Builder模式；</p><a id="more"></a><p>建造者模式是日常开发中比较常见的设计模式，它的主要作用就是将复杂事物创建的过程抽象出来，该抽象的不同实现方式不同，创建出的对象也不同。通俗的讲，创建一个对象一般都会有一个固定的步骤，这个固定的步骤我们把它抽象出来，每个抽象步骤都会有不同的实现方式，不同的实现方式创建出的对象也将不同。举个常见的例子，想必大家都买过电脑，电脑的生产或者组装其实就是属于建造者模式，我们知道，电脑的生产都需要安装CPU、内存条、硬盘等元器件。我们可以把这个安装步骤抽象出来，至于到底装哪种CPU，比如i5还是i7就是对该抽象安装步骤的具体实现。</p><p>建造者模式分为两种，一种为经典建造者模式，另一种为变种建造者模式。我们来挨个看下：</p><h1 id="经典Builder模式"><a href="#经典Builder模式" class="headerlink" title="经典Builder模式"></a>经典Builder模式</h1><p>经典Buider模式中有四个角色：</p><p>要建造的产品Product – 组装的电脑<br>抽象的Builder – 装CPU、内存条、硬盘等抽象的步骤<br>Builder的具体实现ConcreteBuilder – 对上述抽象步骤的实现，比如装i5CPU、8G内存条、1T硬盘<br>使用者Director – 电脑装机人员<br>接下来我们来看下用代码如何实现上述组装电脑的过程：</p><h2 id="首先我们先来创建一个Computer类："><a href="#首先我们先来创建一个Computer类：" class="headerlink" title="首先我们先来创建一个Computer类："></a>首先我们先来创建一个Computer类：</h2><pre><code>public class Computer {    /*CPU*/    private String CPU;    /*内存*/    private String memory;    /*硬盘*/    private String hardDisk;    /*键盘*/    private String keyboard;    /*鼠标*/    private String mouse;    public String getCPU() {        return CPU;    }    public void setCPU(String CPU) {        this.CPU = CPU;    }    public String getMemory() {        return memory;    }    public void setMemory(String memory) {        this.memory = memory;    }    public String getHardDisk() {        return hardDisk;    }    public void setHardDisk(String hardDisk) {        this.hardDisk = hardDisk;    }    public String getKeyboard() {        return keyboard;    }    public void setKeyboard(String keyboard) {        this.keyboard = keyboard;    }    public String getMouse() {        return mouse;    }    public void setMouse(String mouse) {        this.mouse = mouse;    }    @Override    public String toString() {        return &quot;Computer{&quot; +                &quot;CPU=&apos;&quot; + CPU + &apos;\&apos;&apos; +                &quot;, memory=&apos;&quot; + memory + &apos;\&apos;&apos; +                &quot;, hardDisk=&apos;&quot; + hardDisk + &apos;\&apos;&apos; +                &quot;, keyboard=&apos;&quot; + keyboard + &apos;\&apos;&apos; +                &quot;, mouse=&apos;&quot; + mouse + &apos;\&apos;&apos; +                &apos;}&apos;;    }}</code></pre><p>很简单，可以看到这个Computer类中有五个基本属性CPU、内存条、硬盘、键盘和鼠标，然后还有一个toString方法，用于之后方便打印信息用。</p><h2 id="接下来我们来创建一个抽象的电脑组装过程的Builder类："><a href="#接下来我们来创建一个抽象的电脑组装过程的Builder类：" class="headerlink" title="接下来我们来创建一个抽象的电脑组装过程的Builder类："></a>接下来我们来创建一个抽象的电脑组装过程的Builder类：</h2><pre><code>public interface ComputerConfigBuilder {    void setCPU();    void setMemery();    void setHardDisk();    void setKeyboard();    void setMouse();    Computer getComputer();}</code></pre><p>电脑组装一般都需要安装CPU、内存条、硬盘、键盘鼠标等，我们把这一安装过程给抽象出来，也就是这里的ComputerConfigBuilder ，至于具体安装什么需要其实现类来实现，另外其中还定义了一个获取Conputer的方法。</p><h2 id="创建具体的实现类"><a href="#创建具体的实现类" class="headerlink" title="创建具体的实现类"></a>创建具体的实现类</h2><p>好了，有了抽象的组装过程，接下来我们就需要创建具体的实现类。我们知道电脑一般都有低配版和高配版，不同配置，组装成的电脑自然就不一样。接下我们首先来创建一个低配版的套餐LowConfigBuilder ，让其实现ComputerConfigBuilder：</p><pre><code>public class LowConfigBuilder implements ComputerConfigBuilder {    private Computer mComputer;    public LowConfigBuilder(){        this.mComputer = new Computer();    }    @Override    public void setCPU() {        mComputer.setCPU(&quot;i5&quot;);    }    @Override    public void setMemery() {        mComputer.setMemory(&quot;8G&quot;);    }    @Override    public void setHardDisk() {        mComputer.setHardDisk(&quot;500G&quot;);    }    @Override    public void setKeyboard() {        mComputer.setKeyboard(&quot;薄膜键盘&quot;);    }    @Override    public void setMouse() {        mComputer.setMouse(&quot;有线鼠标&quot;);    }    @Override    public Computer getComputer() {        return mComputer;    }}</code></pre><p>可以看到这个低配版的配置为：i5的CPU、8G内存、500G硬盘、薄膜键盘和有线鼠标。</p><p>接着我们再创建一个高配版的套餐：</p><pre><code>public class HighConfigBuider implements ComputerConfigBuilder {    private Computer mComputer;    public HighConfigBuider(){        this.mComputer = new Computer();    }    @Override    public void setCPU() {        mComputer.setCPU(&quot;i7&quot;);    }    @Override    public void setMemery() {        mComputer.setMemory(&quot;16G&quot;);    }    @Override    public void setHardDisk() {        mComputer.setHardDisk(&quot;1T&quot;);    }    @Override    public void setKeyboard() {        mComputer.setKeyboard(&quot;机械键盘&quot;);    }    @Override    public void setMouse() {        mComputer.setMouse(&quot;无线鼠标&quot;);    }    @Override    public Computer getComputer() {        return mComputer;    }}</code></pre><p>可以看到这个高配版的配置为：i7的CPU、16G内存、1T硬盘、机械键盘和无线鼠标。</p><h2 id="上面我们已经定义好了两种配置方案，接下我们还需要一名装机人员Director："><a href="#上面我们已经定义好了两种配置方案，接下我们还需要一名装机人员Director：" class="headerlink" title="上面我们已经定义好了两种配置方案，接下我们还需要一名装机人员Director："></a>上面我们已经定义好了两种配置方案，接下我们还需要一名装机人员Director：</h2><pre><code>public class Director {    private ComputerConfigBuilder mBuilder;    public void setBuilder(ComputerConfigBuilder builder){        this.mBuilder = builder;    }    public void createComputer(){        mBuilder.setCPU();        mBuilder.setMemery();        mBuilder.setHardDisk();        mBuilder.setKeyboard();        mBuilder.setMouse();    }    public Computer getComputer(){        return mBuilder.getComputer();    }}</code></pre><p>我们需要通过setBuilder来告诉他电脑需要什么配置，然后就可以通过createComputer来一步步组装电脑，组装完之后就可以调用getComputer方法来获取我们需要的电脑啦。</p><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>接下来我们就来创建一台电脑试下，首先我们先创建一个<br>低配版的：</p><pre><code>Director director = new Director();//创建装机人员director.setBuilder(new LowConfigBuilder()); //告诉装机人员电脑配置，这里为低配版director.createComputer(); //装机人员开始组装Computer computer = director.getComputer(); //从装机人员获取组装好的电脑System.out.print(&quot;电脑配置：&quot; + computer.toString());  //查看电脑配置--------------------------------------输出结果：电脑配置：Computer{CPU=&apos;i5&apos;, memory=&apos;8G&apos;, hardDisk=&apos;500G&apos;, keyboard=&apos;薄膜键盘&apos;, mouse=&apos;有线鼠标&apos;}--------------------------------------</code></pre><h1 id="变种Builder模式"><a href="#变种Builder模式" class="headerlink" title="变种Builder模式"></a>变种Builder模式</h1><p>需要创建一个不可变的Person对象，这个Person可以拥有以下几个属性：名字、性别、年龄、职业、车、鞋子、衣服、钱、房子。其中名字和性别是必须有的。</p><p>我们首先想到的是给出以下的一个符合要求的Person类</p><pre><code>public class Person {    /*名字（必须）*/    private final String name;    /*性别（必须）*/    private final String gender;    /*年龄（非必须）*/    private final String age;    /*鞋子（非必须）*/    private final String shoes;    /*衣服（非必须）*/    private final String clothes;    /*钱（非必须）*/    private final String money;    /*房子（非必须）*/    private final String house;    /*汽车（非必须）*/    private final String car;    /*职业（非必须）*/    private final String career;    public Person(String name,String gender,String age,String shoes,String clothes,String money,String house,String car,String career){        this.name = name;        this.gender = gender;        this.age = age;        this.shoes = shoes;        this.clothes = clothes;        this.money = money;        this.house = house;        this.car = car;        this.career = career;    }    public Person(String name, String gender){        this(name,gender,null,null,null,null,null,null,null);    }}</code></pre><p>由于要创建出的Person对象是不可变的，所以将类中的属性都声明为final的，然后定义了一个参数为所有属性的构造方法，又因为name和gender为必须项，所以为了调用者方便又单独定义了一个参数为name和gender的构造方法。这样Person类就好了，但这样存在一个问题，就是如果需要传入非必须属性的时候，这个构造方法调用起来不是很方便，因为这个构造方法参数太多了，很容易传错。所以我们改用set方法设置：</p><pre><code>public class Person {    /*名字（必须）*/    private String name;    /*性别（必须）*/    private String gender;    /*年龄（非必须）*/    private String age;    /*鞋子（非必须）*/    private String shoes;    /*衣服（非必须）*/    private String clothes;    /*钱（非必须）*/    private String money;    /*房子（非必须）*/    private String house;    /*汽车（非必须）*/    private String car;    /*职业（非必须）*/    private String career;    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public String getGender() {        return gender;    }    public void setGender(String gender) {        this.gender = gender;    }    public String getAge() {        return age;    }    public void setAge(String age) {        this.age = age;    }    public String getShoes() {        return shoes;    }    public void setShoes(String shoes) {        this.shoes = shoes;    }    ......}</code></pre><p>如果要创建对象的话只用如下操作就行了：</p><pre><code>Person person = new Person();person.setName(&quot;张三&quot;);person.setAge(&quot;22&quot;);person.setGender(&quot;男&quot;);person.setCareer(&quot;程序员&quot;);......</code></pre><p>这样看上去比较清晰了，只要创建一个对象，想要赋什么值set上去就可以了，不过你细细看了下，还是发现了不少的问题的，首先用这个set方法，违背了刚开始这个对象不可变的需求，其次用这种set方法一条一条赋值，很可能会得到一个不完整的Person对象，因为当建完了Person对象，可能出于各方面的原因有些信息忘记set了，那么得到的Person对象就不是预期的对象。这时我们只能用下面这种变种的Builder模式：</p><pre><code>public class Person {    /*名字（必须）*/    private final String name;    /*性别（必须）*/    private final String gender;    /*年龄（非必须）*/    private final String age;    /*鞋子（非必须）*/    private final String shoes;    /*衣服（非必须）*/    private final String clothes;    /*钱（非必须）*/    private final String money;    /*房子（非必须）*/    private final String house;    /*汽车（非必须）*/    private final String car;    /*职业（非必须）*/    private final String career;    private Person(Builder builder) {        this.name = builder.name;        this.gender = builder.gender;        this.age = builder.age;        this.shoes = builder.shoes;        this.clothes = builder.clothes;        this.money = builder.money;        this.house = builder.house;        this.car = builder.car;        this.career = builder.career;    }    public static class Builder {        private final String name;        private final String gender;        private String age;        private String shoes;        private String clothes;        private String money;        private String house;        private String car;        private String career;        public Builder(String name,String gender) {            this.name = name;            this.gender = gender;        }        public Builder age(String age) {            this.age = age;            return this;        }        public Builder car(String car) {            this.car = car;            return this;        }        public Builder shoes(String shoes) {            this.shoes = shoes;            return this;        }        public Builder clothes(String clothes) {            this.clothes = clothes;            return this;        }        public Builder money(String money) {            this.money = money;            return this;        }        public Builder house(String house) {            this.house = house;            return this;        }        public Builder career(String career) {            this.career = career;            return this;        }        public Person build(){            return new Person(this);        }    }</code></pre><p>由于这个Person对象是不可变的，所以毫无疑问我们给他的所有属性都加了final修饰，当然如果没有不可变的需求也是可以不加的，然后在Person类中定义一个内部类Builder，这个Builder内部类中的属性要和Person中的相同，并且必须有的属性要用final修饰，防止这些属性没有被赋值，其他非必须的属性不能用final，因为如果加了final，就必须对其进行初始化，这样这些非必须的属性又变成必须的。然后内部类中定义了一个构造方法，传入必须有的属性。其他非必须的属性都通过方法设置，每个方法都返回Builder对象自身。最后定义了一个build方法，将Builder对象传入Person的私有构造方法，最终返回一个对象。</p><p>接下来我们来看下Person的创建：</p><pre><code>Person person = new Person.Builder(&quot;张三&quot;,&quot;男&quot;)        .age(&quot;12&quot;)        .money(&quot;1000000&quot;)        .car(&quot;宝马&quot;)        .build();</code></pre><p>非必须的属性可以根据需要任意设置，非常灵活，而且这样先设置属性再创建对象，最终获取的对象一定是你预期的完整对象，不会像用之前set的方法创建的对象可能还没有设置完全。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="https://www.jianshu.com/p/afe090b2e19c" target="_blank" rel="noopener">https://www.jianshu.com/p/afe090b2e19c</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;建造者（Builder）模式：&lt;br&gt;经典Builder模式；&lt;br&gt;变种Builder模式；&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Design Pattern，Java" scheme="http://yoursite.com/tags/Design-Pattern%EF%BC%8CJava/"/>
    
  </entry>
  
  <entry>
    <title>数据库学习笔记VI</title>
    <link href="http://yoursite.com/2020/01/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0VII/"/>
    <id>http://yoursite.com/2020/01/03/数据库学习笔记VII/</id>
    <published>2020-01-03T03:12:12.000Z</published>
    <updated>2020-01-06T01:30:00.687Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL建表,LIMIT,OFFSET的用法,Rank函数的用法   </p><a id="more"></a><h1 id="MySQL建表"><a href="#MySQL建表" class="headerlink" title="MySQL建表"></a>MySQL建表</h1><p>下面是通用的SQL语法用来创建MySQL表：</p><pre><code>CREATE TABLE table_name (column_name column_type);</code></pre><p>现在，我们将在 test 数据库中创建以下表。</p><pre><code>create table tutorials_tbl(   tutorial_id INT NOT NULL AUTO_INCREMENT,   tutorial_title VARCHAR(100) NOT NULL,   tutorial_author VARCHAR(40) NOT NULL,   submission_date DATE,   PRIMARY KEY ( tutorial_id ));</code></pre><p>在这里，一些数据项需要解释：<br>字段使用NOT NULL属性，是因为我们不希望这个字段的值为NULL。 因此，如果用户将尝试创建具有NULL值的记录，那么MySQL会产生错误。</p><p>字段的AUTO_INCREMENT属性告诉MySQL自动增加id字段下一个可用编号。</p><h1 id="LIMIT-OFFSET"><a href="#LIMIT-OFFSET" class="headerlink" title="LIMIT,OFFSET"></a>LIMIT,OFFSET</h1><pre><code>SELECT column_name FROM table_name LIMIT 4 OFFSET 3;</code></pre><p>LIMIT 4 OFFSET 3指示MySQL等DBMS返回从第3行（从0行计数）起的4行数据。第一个数字是检索的行数，第二个数字是指从哪儿开始。</p><p>MySQL和MariaDB支持简化版的LIMIT 4 OFFSET 3语句，即LIMIT 3,4。使用这个语法，之前的值对应OFFSET之后的值对应LIMIT 。</p><p> limit10000,20的意思扫描满足条件的10020行，扔掉前面的10000行，返回最后的20行.</p><p>参考练习题：<a href="https://leetcode.com/problems/nth-highest-salary" target="_blank" rel="noopener">https://leetcode.com/problems/nth-highest-salary</a></p><h1 id="mysql变量的种类"><a href="#mysql变量的种类" class="headerlink" title="mysql变量的种类"></a>mysql变量的种类</h1><p>用户变量：以”@”开始，形式为”@变量名”。用户变量跟mysql客户端是绑定的，设置的变量，只对当前用户使用的客户端生效<br>全局变量：定义时，以如下两种形式出现，set GLOBAL 变量名  或者  set @@global.变量名，对所有客户端生效。只有具有super权限才可以设置全局变量<br>会话变量：只对连接的客户端有效。<br>局部变量：作用范围在begin到end语句块之间。在该语句块里设置的变量。declare语句专门用于定义局部变量。set语句是设置不同类型的变量，包括会话变量和全局变量<br>通俗理解术语之间的区别：</p><p>用户定义的变量就叫用户变量。这样理解的话，会话变量和全局变量都可以是用户定义的变量。只是他们是对当前客户端生效还是对所有客户端生效的区别了。所以，用户变量包括了会话变量和全局变量</p><p>局部变量与用户变量的区分在于:<br>1.用户变量是以”@”开头的。局部变量没有这个符号。<br>2.定义变量不同。用户变量使用set语句，局部变量使用declare语句定义<br>3.作用范围。局部变量只在begin-end语句块之间有效。在begin-end语句块运行完之后，局部变量就消失了。</p><p>所以，最后它们之间的层次关系是：变量包括局部变量和用户变量。用户变量包括会话变量和全局变量。</p><h1 id="mysql-declare定义变量"><a href="#mysql-declare定义变量" class="headerlink" title="mysql declare定义变量"></a>mysql declare定义变量</h1><p>mysql declare用于定义变量，在存储过程和函数中通过declare定义变量在BEGIN…END中，且在语句之前。并且可以通过重复定义多个变量</p><p>declare变量的作用范围同编程里面类似，在这里一般是在对应的begin和end之间。在end之后这个变量就没有作用了，不能使用了。这个同编程一样。</p><p>注意：declare定义的变量名不能带‘@’符号，mysql在这点做的确实不够直观，往往变量名会被错成参数或者字段名。</p><p>mysql存储过程中使用declare定义变量，实例如下：</p><p> DROP PROCEDURE IF EXISTS insert_ten_rows $$<br> CREATE PROCEDURE insert_ten_rows ()<br>     BEGIN<br>         DECLARE crs INT DEFAULT 0;</p><pre><code>    WHILE crs &lt; 10 DO        INSERT INTO `continent`(`name`) VALUES (&apos;cont&apos;+crs);        SET crs = crs + 1;    END WHILE;END $$</code></pre><p> DELIMITER ;</p><h1 id="mysql-SET定义变量"><a href="#mysql-SET定义变量" class="headerlink" title="mysql SET定义变量"></a>mysql SET定义变量</h1><p>mysql set也可以用来定于变量，定义变量的形式是以”@”开始，如：”@变量名”。</p><p>mysql SET定义变量实例：</p><p>   mysql&gt; SET @t1=0, @t2=1, @t3=2;</p><p>   mysql&gt; select @t1;<br>   +——+<br>   | @t1  |<br>   +——+<br>   | 0    |<br>   +——+</p><p>   mysql&gt; select @t2;<br>   +——+<br>   | @t2  |<br>   +——+<br>   | 1    |<br>   +——+</p><p>   mysql&gt; select @t3;<br>   +——+<br>   | @t3  |<br>   +——+<br>   | 2    |<br>   +——+</p><p>   mysql&gt;</p><p>复杂一点的实例：</p><p>   mysql&gt; SET @t1=0, @t2=1, @t3=2;</p><p>   mysql&gt; SELECT @t1:=(@t2:=1)+@t3:=4,@t1,@t2,@t3;<br>   +———————-+——+——+——+<br>   | @t1:=(@t2:=1)+@t3:=4 | @t1  | @t2  | @t3  |<br>   +———————-+——+——+——+<br>   |                    5 | 5    | 1    | 4    |<br>   +———————-+——+——+——+</p><h1 id="mysql-declare和set定义变量的区别"><a href="#mysql-declare和set定义变量的区别" class="headerlink" title="mysql declare和set定义变量的区别"></a>mysql declare和set定义变量的区别</h1><p>mysql declare和set定义变量，除了一个不加@和一个加@这个区别之外，还有以下区别：</p><p> declare用来定义局部变量</p><p> @用来定义会话变量</p><p> declare变量的作用范围同编程里面类似，在这里一般是在对应的begin和end之间。在end之后这个变量就没有作用了，不能使用了。这个同编程一样。</p><p> 另外有种变量叫做会话变量(session variable)，也叫做用户定义的变量(user defined variable)。这种变量要在变量名称前面加上“@”符号，叫做会话变量，代表整个会话过程他都是有作用的，这个有点类似于全局变量一样。这种变量用途比较广，因为只要在一个会话内(就是某个应用的一个连接过程中)，这个变量可以在被调用的存储过程或者代码之间共享数据。</p><h1 id="rank函数"><a href="#rank函数" class="headerlink" title="rank函数"></a>rank函数</h1><p>用于返回结果集的分区内每行的排名， 行的排名是相关行之前的排名数加一。简单来说rank函数就是对查询出来的记录进行排名，与row_number函数不同的是，rank函数考虑到了over子句中排序字段值相同的情况，如果使用rank函数来生成序号，over子句中排序字段值相同的序号是一样的，后面字段值不相同的序号将跳过相同的排名号排下一个，也就是相关行之前的排名数加一，可以理解为根据当前的记录数生成序号，后面的记录依此类推。</p><p>select RANK() OVER(order by column_name) as rank,* from table_name</p><p>#参考资料<br>【1】 <a href="https://tech.meituan.com/2014/06/30/mysql-index.html" target="_blank" rel="noopener">https://tech.meituan.com/2014/06/30/mysql-index.html</a><br>【2】 <a href="https://blog.csdn.net/qq_37923253/article/details/79688313" target="_blank" rel="noopener">https://blog.csdn.net/qq_37923253/article/details/79688313</a><br>【3】 <a href="http://www.manongjc.com/article/1441.html" target="_blank" rel="noopener">http://www.manongjc.com/article/1441.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL建表,LIMIT,OFFSET的用法,Rank函数的用法   &lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Java开发规范</title>
    <link href="http://yoursite.com/2020/01/02/Java%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    <id>http://yoursite.com/2020/01/02/Java开发规范/</id>
    <published>2020-01-02T07:06:12.000Z</published>
    <updated>2020-01-02T14:16:09.502Z</updated>
    
    <content type="html"><![CDATA[<p>常见的开发规范</p><a id="more"></a><h1 id="编程规约"><a href="#编程规约" class="headerlink" title="编程规约"></a>编程规约</h1><h2 id="【强制】-代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。"><a href="#【强制】-代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。" class="headerlink" title="【强制】 代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。"></a>【强制】 代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。</h2><p>反例： <em>name / __name / $Object / name</em> / name$ / Object$</p><h2 id="【强制】-代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。"><a href="#【强制】-代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。" class="headerlink" title="【强制】 代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。"></a>【强制】 代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。</h2><p>说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式<br>也要避免采用。</p><p>反例： DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3<br>正例： alibaba / taobao / youku / hangzhou 等国际通用的名称，可视同英文。</p><h2 id="【强制】类名使用-UpperCamelCase-风格，必须遵从驼峰形式，但以下情形例外：（领域模型的相关命名）DO-BO-DTO-VO-等。"><a href="#【强制】类名使用-UpperCamelCase-风格，必须遵从驼峰形式，但以下情形例外：（领域模型的相关命名）DO-BO-DTO-VO-等。" class="headerlink" title="【强制】类名使用 UpperCamelCase 风格，必须遵从驼峰形式，但以下情形例外：（领域模型的相关命名）DO / BO / DTO / VO 等。"></a>【强制】类名使用 UpperCamelCase 风格，必须遵从驼峰形式，但以下情形例外：（领域模型的相关命名）DO / BO / DTO / VO 等。</h2><p>正例：MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion<br>反例：macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion</p><h2 id="【强制】方法名、参数名、成员变量、局部变量都统一使用-lowerCamelCase-风格，必须遵从驼峰形式。"><a href="#【强制】方法名、参数名、成员变量、局部变量都统一使用-lowerCamelCase-风格，必须遵从驼峰形式。" class="headerlink" title="【强制】方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。"></a>【强制】方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。</h2><p>正例： localValue / getHttpMessage() / inputUserId</p><h2 id="【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。"><a href="#【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。" class="headerlink" title="【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。"></a>【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。</h2><p>正例： MAX_STOCK_COUNT<br>反例： MAX_COUNT</p><h2 id="【强制】抽象类命名使用-Abstract-或-Base-开头；异常类命名使用-Exception-结尾；测试类命名以它要测试的类的名称开始，以-Test-结尾。"><a href="#【强制】抽象类命名使用-Abstract-或-Base-开头；异常类命名使用-Exception-结尾；测试类命名以它要测试的类的名称开始，以-Test-结尾。" class="headerlink" title="【强制】抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾。"></a>【强制】抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾。</h2><h2 id="【强制】中括号是数组类型的一部分，数组定义如下：String-args"><a href="#【强制】中括号是数组类型的一部分，数组定义如下：String-args" class="headerlink" title="【强制】中括号是数组类型的一部分，数组定义如下：String[] args;"></a>【强制】中括号是数组类型的一部分，数组定义如下：String[] args;</h2><p>反例：请勿使用 String args[]的方式来定义。</p><h2 id="【强制】POJO-类中布尔类型的变量，都不要加-is，否则部分框架解析会引起序列化错误。"><a href="#【强制】POJO-类中布尔类型的变量，都不要加-is，否则部分框架解析会引起序列化错误。" class="headerlink" title="【强制】POJO 类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。"></a>【强制】POJO 类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。</h2><p>反例：定义为基本数据类型 boolean isSuccess；的属性，它的方法也是 isSuccess()，RPC<br>框架在反向解析的时候，“以为”对应的属性名称是 success，导致属性获取不到，进而抛出异<br>常。</p><h2 id="【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。"><a href="#【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。" class="headerlink" title="【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。"></a>【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。</h2><p>正例： 应用工具类包名为 com.alibaba.open.util、类名为 MessageUtils（此规则参考<br>spring 的框架结构）</p><h2 id="【强制】杜绝完全不规范的缩写，避免望文不知义。"><a href="#【强制】杜绝完全不规范的缩写，避免望文不知义。" class="headerlink" title="【强制】杜绝完全不规范的缩写，避免望文不知义。"></a>【强制】杜绝完全不规范的缩写，避免望文不知义。</h2><p>反例： AbstractClass“缩写”命名成 AbsClass；condition“缩写”命名成 condi，此类<br>随意缩写严重降低了代码的可阅读性。</p><h2 id="【推荐】如果使用到了设计模式，建议在类名中体现出具体模式。"><a href="#【推荐】如果使用到了设计模式，建议在类名中体现出具体模式。" class="headerlink" title="【推荐】如果使用到了设计模式，建议在类名中体现出具体模式。"></a>【推荐】如果使用到了设计模式，建议在类名中体现出具体模式。</h2><p>说明：将设计模式体现在名字中，有利于阅读者快速理解架构设计思想。<br>正例：public class OrderFactory;<br>public class LoginProxy;<br>public class ResourceObserver;</p><h2 id="【推荐】接口类中的方法和属性不要加任何修饰符号（public-也不要加），保持代码的简洁性，并加上有效的-Javadoc-注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。"><a href="#【推荐】接口类中的方法和属性不要加任何修饰符号（public-也不要加），保持代码的简洁性，并加上有效的-Javadoc-注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。" class="headerlink" title="【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。"></a>【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。</h2><p>正例：接口方法签名：void f();<br>接口基础常量表示：String COMPANY = “alibaba”;<br>反例：接口方法定义：public abstract void f();<br>说明：JDK8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默<br>认实现。</p><h2 id="接口和实现类的命名有两套规则："><a href="#接口和实现类的命名有两套规则：" class="headerlink" title="接口和实现类的命名有两套规则："></a>接口和实现类的命名有两套规则：</h2><h3 id="【强制】对于-Service-和-DAO-类，基于-SOA-的理念，暴露出来的服务一定是接口，内部的实现类用-Impl-的后缀与接口区别。"><a href="#【强制】对于-Service-和-DAO-类，基于-SOA-的理念，暴露出来的服务一定是接口，内部的实现类用-Impl-的后缀与接口区别。" class="headerlink" title="【强制】对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部的实现类用 Impl 的后缀与接口区别。"></a>【强制】对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部的实现类用 Impl 的后缀与接口区别。</h3><p>正例：CacheServiceImpl 实现 CacheService 接口。</p><h3 id="【推荐】如果是形容能力的接口名称，取对应的形容词做接口名（通常是–able-的形式）。"><a href="#【推荐】如果是形容能力的接口名称，取对应的形容词做接口名（通常是–able-的形式）。" class="headerlink" title="【推荐】如果是形容能力的接口名称，取对应的形容词做接口名（通常是–able 的形式）。"></a>【推荐】如果是形容能力的接口名称，取对应的形容词做接口名（通常是–able 的形式）。</h3><p>正例：AbstractTranslator 实现 Translatable。</p><h2 id="【参考】枚举类名建议带上-Enum-后缀，枚举成员名称需要全大写，单词间用下划线隔开。"><a href="#【参考】枚举类名建议带上-Enum-后缀，枚举成员名称需要全大写，单词间用下划线隔开。" class="headerlink" title="【参考】枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。"></a>【参考】枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。</h2><p>说明：枚举其实就是特殊的常量类，且构造方法被默认强制是私有。<br>正例：枚举名字：DealStatusEnum，成员名称：SUCCESS / UNKOWN_REASON。</p><p>##【参考】各层命名规约：</p><h3 id="Service-DAO-层方法命名规约"><a href="#Service-DAO-层方法命名规约" class="headerlink" title="Service/DAO 层方法命名规约"></a>Service/DAO 层方法命名规约</h3><p>1） 获取单个对象的方法用 get 做前缀。<br>2） 获取多个对象的方法用 list 做前缀。<br>3） 获取统计值的方法用 count 做前缀。<br>4） 插入的方法用 save（推荐）或 insert 做前缀。<br>5） 删除的方法用 remove（推荐）或 delete 做前缀。<br>6） 修改的方法用 update 做前缀。</p><h3 id="领域模型命名规约"><a href="#领域模型命名规约" class="headerlink" title="领域模型命名规约"></a>领域模型命名规约</h3><p>1） 数据对象：xxxDO，xxx 即为数据表名。<br>2） 数据传输对象：xxxDTO，xxx 为业务领域相关的名称。<br>3） 展示对象：xxxVO，xxx 一般为网页名称。<br>4） POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO</p><h1 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h1><h2 id="【强制】不允许出现任何魔法值（即未经定义的常量）直接出现在代码中。"><a href="#【强制】不允许出现任何魔法值（即未经定义的常量）直接出现在代码中。" class="headerlink" title="【强制】不允许出现任何魔法值（即未经定义的常量）直接出现在代码中。"></a>【强制】不允许出现任何魔法值（即未经定义的常量）直接出现在代码中。</h2><p>反例： String key=”Id#taobao_”+tradeId；<br>cache.put(key, value);</p><h2 id="【强制】long-或者-Long-初始赋值时，必须使用大写的-L，不能是小写的-l，小写容易跟数字1-混淆，造成误解。"><a href="#【强制】long-或者-Long-初始赋值时，必须使用大写的-L，不能是小写的-l，小写容易跟数字1-混淆，造成误解。" class="headerlink" title="【强制】long 或者 Long 初始赋值时，必须使用大写的 L，不能是小写的 l，小写容易跟数字1 混淆，造成误解。"></a>【强制】long 或者 Long 初始赋值时，必须使用大写的 L，不能是小写的 l，小写容易跟数字1 混淆，造成误解。</h2><p>说明：Long a = 2l; 写的是数字的 21，还是 Long 型的 2?</p><h2 id="【推荐】不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。"><a href="#【推荐】不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。" class="headerlink" title="【推荐】不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。"></a>【推荐】不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。</h2><p>如：缓存相关的常量放在类：CacheConsts 下；系统配置相关的常量放在类：ConfigConsts 下。<br>说明：大而全的常量类，非得使用查找功能才能定位到修改的常量，不利于理解和维护。</p><h2 id="【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。"><a href="#【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。" class="headerlink" title="【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。"></a>【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。</h2><p>1） 跨应用共享常量：放置在二方库中，通常是 client.jar 中的 constant 目录下。<br>2） 应用内共享常量：放置在一方库的 modules 中的 constant 目录下。<br>反例：易懂变量也要统一定义成应用内共享常量，两位攻城师在两个类中分别定义了表示“是”的变量：<br>类 A 中：public static final String YES = “yes”; 类 B 中：public static final String YES = “y”; A.YES.equals(B.YES)，预期是 true，但实际返回为 false，导致产生线上问题。<br>3） 子工程内部共享常量：即在当前子工程的 constant 目录下。<br>4） 包内共享常量：即在当前包下单独的 constant 目录下。<br>5） 类内共享常量：直接在类内部 private static final 定义。</p><h2 id="【推荐】如果变量值仅在一个范围内变化用-Enum-类。如果还带有名称之外的延伸属性，必须使用-Enum-类"><a href="#【推荐】如果变量值仅在一个范围内变化用-Enum-类。如果还带有名称之外的延伸属性，必须使用-Enum-类" class="headerlink" title="【推荐】如果变量值仅在一个范围内变化用 Enum 类。如果还带有名称之外的延伸属性，必须使用 Enum 类"></a>【推荐】如果变量值仅在一个范围内变化用 Enum 类。如果还带有名称之外的延伸属性，必须使用 Enum 类</h2><p>下面正例中的数字就是延伸信息，表示星期几。<br>正例：</p><pre><code>public Enum{  MONDAY(1), TUESDAY(2), WEDNESDAY(3), THURSDAY(4), FRIDAY(5),SATURDAY(6),SUNDAY(7);}</code></pre><h1 id="格式规约"><a href="#格式规约" class="headerlink" title="格式规约"></a>格式规约</h1><h2 id="【强制】大括号的使用约定。"><a href="#【强制】大括号的使用约定。" class="headerlink" title="【强制】大括号的使用约定。"></a>【强制】大括号的使用约定。</h2><p>如果是大括号内为空，则简洁地写成{}即可，不需要换行；<br>如果是非空代码块则：<br>1） 左大括号前不换行。<br>2） 左大括号后换行。<br>3） 右大括号前换行。<br>4） 右大括号后还有 else 等代码则不换行；表示终止右大括号后必须换行。</p><h2 id="【强制】-左括号和后一个字符之间不出现空格；同样，右括号和前一个字符之间也不出现空"><a href="#【强制】-左括号和后一个字符之间不出现空格；同样，右括号和前一个字符之间也不出现空" class="headerlink" title="【强制】 左括号和后一个字符之间不出现空格；同样，右括号和前一个字符之间也不出现空"></a>【强制】 左括号和后一个字符之间不出现空格；同样，右括号和前一个字符之间也不出现空</h2><p>格。详见第 5 条下方正例ᨀ示。</p><h2 id="【强制】if-for-while-switch-do-等保留字与左右括号之间都必须加空格。"><a href="#【强制】if-for-while-switch-do-等保留字与左右括号之间都必须加空格。" class="headerlink" title="【强制】if/for/while/switch/do 等保留字与左右括号之间都必须加空格。"></a>【强制】if/for/while/switch/do 等保留字与左右括号之间都必须加空格。</h2><h2 id="【强制】任何运算符左右必须加一个空格。"><a href="#【强制】任何运算符左右必须加一个空格。" class="headerlink" title="【强制】任何运算符左右必须加一个空格。"></a>【强制】任何运算符左右必须加一个空格。</h2><p>说明：运算符包括赋值运算符=、逻辑运算符&amp;&amp;、加减乘除符号、三目运行符等。</p><h2 id="【强制】缩进采用-4-个空格，禁止使用-tab-字符。"><a href="#【强制】缩进采用-4-个空格，禁止使用-tab-字符。" class="headerlink" title="【强制】缩进采用 4 个空格，禁止使用 tab 字符。"></a>【强制】缩进采用 4 个空格，禁止使用 tab 字符。</h2><p>说明：如果使用 tab 缩进，必须设置 1 个 tab 为 4 个空格。IDEA 设置 tab 为 4 个空格时，<br>请勿勾选 Use tab character；而在 eclipse 中，必须勾选 insert spaces for tabs。<br>正例： （涉及 1-5 点）<br>    public static void main(String args[]) {<br>        // 缩进 4 个空格<br>        String say = “hello”;<br>        // 运算符的左右必须有一个空格<br>        int flag = 0;<br>        // 关键词 if 与括号之间必须有一个空格，括号内的 f 与左括号，0 与右括号不需要空格<br>        if (flag == 0) {<br>        System.out.println(say);<br>        }<br>        // 左大括号前加空格且不换行；左大括号后换行<br>        if (flag == 1) {<br>        System.out.println(“world”);<br>        // 右大括号前换行，右大括号后有 else，不用换行<br>        } else {<br>        System.out.println(“ok”);<br>        // 在右大括号后直接结束，则必须换行<br>        }<br>    }</p><h2 id="【强制】单行字符数限制不超过-120-个，超出需要换行，换行时遵循如下原则："><a href="#【强制】单行字符数限制不超过-120-个，超出需要换行，换行时遵循如下原则：" class="headerlink" title="【强制】单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则："></a>【强制】单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则：</h2><p>1） 第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。<br>2） 运算符与下文一起换行。<br>3） 方法调用的点符号与下文一起换行。<br>4） 在多个参数超长，逗号后进行换行。<br>5） 在括号前不要换行，见反例。<br>正例：<br>    StringBuffer sb = new StringBuffer();<br>    //超过 120 个字符的情况下，换行缩进 4 个空格，并且方法前的点符号一起换行<br>    sb.append(“zi”).append(“xin”)…<br>    .append(“huang”)…<br>    .append(“huang”)…<br>    .append(“huang”);<br>反例：<br>    StringBuffer sb = new StringBuffer();<br>    //超过 120 个字符的情况下，不要在括号前换行<br>    sb.append(“zi”).append(“xin”)…append<br>    (“huang”);<br>    //参数很多的方法调用可能超过 120 个字符，不要在逗号前换行<br>    method(args1, args2, args3, …<br>    , argsX);</p><h2 id="【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。"><a href="#【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。" class="headerlink" title="【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。"></a>【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。</h2><p>正例：下例中实参的”a”,后边必须要有一个空格。<br>method(“a”, “b”, “c”);</p><h2 id="【强制】IDE-的-text-file-encoding-设置为-UTF-8-IDE-中文件的换行符使用-Unix-格式，不要使用-windows-格式。"><a href="#【强制】IDE-的-text-file-encoding-设置为-UTF-8-IDE-中文件的换行符使用-Unix-格式，不要使用-windows-格式。" class="headerlink" title="【强制】IDE 的 text file encoding 设置为 UTF-8; IDE 中文件的换行符使用 Unix 格式，不要使用 windows 格式。"></a>【强制】IDE 的 text file encoding 设置为 UTF-8; IDE 中文件的换行符使用 Unix 格式，不要使用 windows 格式。</h2><h2 id="【推荐】没有必要增加若干空格来使某一行的字符与上一行的相应字符对齐。"><a href="#【推荐】没有必要增加若干空格来使某一行的字符与上一行的相应字符对齐。" class="headerlink" title="【推荐】没有必要增加若干空格来使某一行的字符与上一行的相应字符对齐。"></a>【推荐】没有必要增加若干空格来使某一行的字符与上一行的相应字符对齐。</h2><p>正例：<br>    int a = 3;<br>    long b = 4L;<br>    float c = 5F;<br>    StringBuffer sb = new StringBuffer();<br>说明：增加 sb 这个变量，如果需要对齐，则给 a、b、c 都要增加几个空格，在变量比较多的<br>情况下，是一种累赘的事情。</p><h2 id="【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义"><a href="#【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义" class="headerlink" title="【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义"></a>【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义</h2><p>之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。<br>说明：没有必要插入多行空格进行隔开。</p><h1 id="OOP-规约"><a href="#OOP-规约" class="headerlink" title="OOP 规约"></a>OOP 规约</h1><h2 id="【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。"><a href="#【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。" class="headerlink" title="【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。"></a>【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。</h2><h2 id="【强制】所有的覆写方法，必须加-Override-注解。"><a href="#【强制】所有的覆写方法，必须加-Override-注解。" class="headerlink" title="【强制】所有的覆写方法，必须加@Override 注解。"></a>【强制】所有的覆写方法，必须加@Override 注解。</h2><p>反例：getObject()与 get0bject()的问题。一个是字母的 O，一个是数字的 0，加@Override<br>可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错。</p><h2 id="【强制】相同参数类型，相同业务含义，才可以使用-Java-的可变参数，避免使用-Object。"><a href="#【强制】相同参数类型，相同业务含义，才可以使用-Java-的可变参数，避免使用-Object。" class="headerlink" title="【强制】相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object。"></a>【强制】相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object。</h2><p>说明：可变参数必须放置在参数列表的最后。（提倡同学们尽量不用可变参数编程）<br>正例：public User getUsers(String type, Integer… ids)</p><h2 id="【强制】对外暴露的接口签名，原则上不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加-Deprecated-注解，并清晰地说明采用的新接口或者新服务是什么。"><a href="#【强制】对外暴露的接口签名，原则上不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加-Deprecated-注解，并清晰地说明采用的新接口或者新服务是什么。" class="headerlink" title="【强制】对外暴露的接口签名，原则上不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加@Deprecated 注解，并清晰地说明采用的新接口或者新服务是什么。"></a>【强制】对外暴露的接口签名，原则上不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加@Deprecated 注解，并清晰地说明采用的新接口或者新服务是什么。</h2><h2 id="【强制】不能使用过时的类或方法。"><a href="#【强制】不能使用过时的类或方法。" class="headerlink" title="【强制】不能使用过时的类或方法。"></a>【强制】不能使用过时的类或方法。</h2><p>说明：java.net.URLDecoder 中的方法 decode(String encodeStr) 这个方法已经过时，应该使用双参数 decode(String source, String encode)。接口提供方既然明确是过时接口，<br>那么有义务同时ᨀ供新的接口；作为调用方来说，有义务去考证过时方法的新实现是什么。</p><h2 id="【强制】Object-的-equals-方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。"><a href="#【强制】Object-的-equals-方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。" class="headerlink" title="【强制】Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。"></a>【强制】Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。</h2><p>正例： “test”.equals(object);<br>反例： object.equals(“test”);<br>说明：推荐使用 java.util.Objects#equals （JDK7 引入的工具类）</p><h2 id="【强制】所有的相同类型的包装类对象之间值的比较，全部使用-equals-方法比较。"><a href="#【强制】所有的相同类型的包装类对象之间值的比较，全部使用-equals-方法比较。" class="headerlink" title="【强制】所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较。"></a>【强制】所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较。</h2><p><strong><em>说明：对于 Integer var=?在-128 至 127 之间的赋值，Integer 对象是在IntegerCache.cache 产生，会复用已有对象，这个区间内的 Integer 值可以直接使用==进行<br>判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，<br>推荐使用 equals 方法进行判断。</em></strong></p><h2 id="【强制】关于基本数据类型与包装数据类型的使用标准如下："><a href="#【强制】关于基本数据类型与包装数据类型的使用标准如下：" class="headerlink" title="【强制】关于基本数据类型与包装数据类型的使用标准如下："></a>【强制】关于基本数据类型与包装数据类型的使用标准如下：</h2><p>1） 所有的 POJO 类属性必须使用包装数据类型。<br>2） RPC 方法的返回值和参数必须使用包装数据类型。<br>3） 所有的局部变量【推荐】使用基本数据类型。<br>说明：POJO 类属性没有初值是ᨀ醒使用者在需要使用时，必须自己显式地进行赋值，任何<br>NPE 问题，或者入库检查，都由使用者来保证。<br>正例：数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。<br>反例：比如显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 RPC 服务，调用<br>不成功时，返回的是默认值，页面显示：0%，这是不合理的，应该显示成中划线-。所以包装<br>数据类型的 null 值，能够表示额外的信息，如：远程调用失败，异常退出。</p><h2 id="【强制】定义-DO-DTO-VO-等-POJO-类时，不要设定任何属性默认值。"><a href="#【强制】定义-DO-DTO-VO-等-POJO-类时，不要设定任何属性默认值。" class="headerlink" title="【强制】定义 DO/DTO/VO 等 POJO 类时，不要设定任何属性默认值。"></a>【强制】定义 DO/DTO/VO 等 POJO 类时，不要设定任何属性默认值。</h2><p>反例：POJO 类的 gmtCreate 默认值为 new Date();但是这个属性在数据ᨀ取时并没有置入具<br>体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。</p><h2 id="【强制】序列化类新增属性时，请不要修改-serialVersionUID-字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改-serialVersionUID-值。"><a href="#【强制】序列化类新增属性时，请不要修改-serialVersionUID-字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改-serialVersionUID-值。" class="headerlink" title="【强制】序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值。"></a>【强制】序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值。</h2><p>说明：注意 serialVersionUID 不一致会抛出序列化运行时异常。</p><h2 id="【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在-init-方法中。"><a href="#【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在-init-方法中。" class="headerlink" title="【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。"></a>【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。</h2><h2 id="【强制】POJO-类必须写-toString-方法。"><a href="#【强制】POJO-类必须写-toString-方法。" class="headerlink" title="【强制】POJO 类必须写 toString 方法。"></a>【强制】POJO 类必须写 toString 方法。</h2><p>使用 IDE 的中工具：source&gt; generate toString时，如果继承了另一个 POJO 类，注意在前面加一下 super.toString。<br>说明：在方法执行抛出异常时，可以直接调用 POJO 的 toString()方法打印其属性值，便于排<br>查问题。</p><h2 id="【推荐】使用索引访问用-String-的-split-方法得到的数组时，需做最后一个分隔符后有无-内容的检查，否则会有抛-IndexOutOfBoundsException-的风险。"><a href="#【推荐】使用索引访问用-String-的-split-方法得到的数组时，需做最后一个分隔符后有无-内容的检查，否则会有抛-IndexOutOfBoundsException-的风险。" class="headerlink" title="【推荐】使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无 内容的检查，否则会有抛 IndexOutOfBoundsException 的风险。"></a>【推荐】使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无 内容的检查，否则会有抛 IndexOutOfBoundsException 的风险。</h2><p>说明：<br>    String str = “a,b,c,,”;<br>    String[] ary = str.split(“,”);<br>    //预期大于 3，结果是 3<br>    System.out.println(ary.length);</p><h2 id="【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读。"><a href="#【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读。" class="headerlink" title="【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读。"></a>【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读。</h2><h2 id="【推荐】-类内方法定义顺序依次是：公有方法或保护方法-gt-私有方法-gt-getter-setter"><a href="#【推荐】-类内方法定义顺序依次是：公有方法或保护方法-gt-私有方法-gt-getter-setter" class="headerlink" title="【推荐】 类内方法定义顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter/setter"></a>【推荐】 类内方法定义顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter/setter</h2><p>方法。<br>说明：公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类<br>关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个<br>黑盒实现；因为方法信息价值较低，所有 Service 和 DAO 的 getter/setter 方法放在类体最<br>后。</p><h2 id="【推荐】setter-方法中，参数名称与类成员变量名称一致，this-成员名-参数名。在getter-setter-方法中，尽量不要增加业务逻辑，增加排查问题的难度。"><a href="#【推荐】setter-方法中，参数名称与类成员变量名称一致，this-成员名-参数名。在getter-setter-方法中，尽量不要增加业务逻辑，增加排查问题的难度。" class="headerlink" title="【推荐】setter 方法中，参数名称与类成员变量名称一致，this.成员名=参数名。在getter/setter 方法中，尽量不要增加业务逻辑，增加排查问题的难度。"></a>【推荐】setter 方法中，参数名称与类成员变量名称一致，this.成员名=参数名。在getter/setter 方法中，尽量不要增加业务逻辑，增加排查问题的难度。</h2><p>反例：<br>  public Integer getData(){<br>    if(true) {<br>    return data + 100;<br>    } else {<br>    return data - 100;<br>    }<br>  }</p><h2 id="【推荐】循环体内，字符串的联接方式，使用-StringBuilder-的-append-方法进行扩展。"><a href="#【推荐】循环体内，字符串的联接方式，使用-StringBuilder-的-append-方法进行扩展。" class="headerlink" title="【推荐】循环体内，字符串的联接方式，使用 StringBuilder 的 append 方法进行扩展。"></a>【推荐】循环体内，字符串的联接方式，使用 StringBuilder 的 append 方法进行扩展。</h2><p>反例：<br>  String str = “start”;<br>    for(int i=0; i&lt;100; i++){<br>      str = str + “hello”;<br>  }<br>说明：反编译出的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象，然后进行<br>append 操作，最后通过 toString 方法返回 String 对象，造成内存资源浪费。</p><h2 id="【推荐】final-可提高程序响应效率，声明成-final-的情况："><a href="#【推荐】final-可提高程序响应效率，声明成-final-的情况：" class="headerlink" title="【推荐】final 可提高程序响应效率，声明成 final 的情况："></a>【推荐】final 可提高程序响应效率，声明成 final 的情况：</h2><p>1） 不需要重新赋值的变量，包括类属性、局部变量。<br>2） 对象参数前加 final，表示不允许修改引用的指向。<br>3） 类方法确定不允许被重写。</p><h2 id="【推荐】慎用-Object-的-clone-方法来拷贝对象。"><a href="#【推荐】慎用-Object-的-clone-方法来拷贝对象。" class="headerlink" title="【推荐】慎用 Object 的 clone 方法来拷贝对象。"></a>【推荐】慎用 Object 的 clone 方法来拷贝对象。</h2><p>说明：对象的 clone 方法默认是浅拷贝，若想实现深拷贝需要重写 clone 方法实现属性对象的拷贝。</p><h2 id="【推荐】类成员与方法访问控制从严："><a href="#【推荐】类成员与方法访问控制从严：" class="headerlink" title="【推荐】类成员与方法访问控制从严："></a>【推荐】类成员与方法访问控制从严：</h2><p>1） 如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 private。<br>2） 工具类不允许有 public 或 default 构造方法。<br>3） 类非 static 成员变量并且与子类共享，必须是 protected。<br>4） 类非 static 成员变量并且仅在本类使用，必须是 private。<br>5） 类 static 成员变量如果仅在本类使用，必须是 private。<br>6） 若是 static 成员变量，必须考虑是否为 final。<br>7） 类成员方法只供类内部调用，必须是 private。<br>8） 类成员方法只对继承类公开，那么限制为 protected。<br>说明：任何类、方法、参数、变量，严控访问范围。过宽泛的访问范围，不利于模块解耦。思考：如果是一个 private 的方法，想删除就删除，可是一个 public 的 Service 方法，或者一<br>个 public 的成员变量，删除一下，不得手心冒点汗吗？变量像自己的小孩，尽量在自己的视线内，变量作用域太大，如果无限制的到处跑，那么你会担心的。</p><h1 id="集合处理"><a href="#集合处理" class="headerlink" title="集合处理"></a>集合处理</h1><h2 id="【强制】关于-hashCode-和-equals-的处理，遵循如下规则："><a href="#【强制】关于-hashCode-和-equals-的处理，遵循如下规则：" class="headerlink" title="【强制】关于 hashCode 和 equals 的处理，遵循如下规则："></a>【强制】关于 hashCode 和 equals 的处理，遵循如下规则：</h2><p>1） 只要重写 equals，就必须重写 hashCode。<br>2） 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的<br>对象必须重写这两个方法。<br>3） 如果自定义对象做为 Map 的键，那么必须重写 hashCode 和 equals。<br>正例：String 重写了 hashCode 和 equals 方法，所以我们可以非常愉快地使用 String 对象<br>作为 key 来使用。</p><h2 id="【强制】ArrayList的subList结果不可强转成ArrayList，否则会抛出ClassCastException"><a href="#【强制】ArrayList的subList结果不可强转成ArrayList，否则会抛出ClassCastException" class="headerlink" title="【强制】ArrayList的subList结果不可强转成ArrayList，否则会抛出ClassCastException"></a>【强制】ArrayList的subList结果不可强转成ArrayList，否则会抛出ClassCastException</h2><p>异常：java.util.RandomAccessSubList cannot be cast to java.util.ArrayList ;<br>说明：subList 返回的是 ArrayList 的内部类 SubList，并不是 ArrayList ，而是<br>ArrayList 的一个视图，对于 SubList 子列表的所有操作最终会反映到原列表上。</p><h2 id="【强制】-在-subList-场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增"><a href="#【强制】-在-subList-场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增" class="headerlink" title="【强制】 在 subList 场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增"></a>【强制】 在 subList 场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增</h2><p>加、删除均产生 ConcurrentModificationException 异常。<br>##【强制】使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全<br>一样的数组，大小就是 list.size()。<br>反例：直接使用 toArray 无参方法存在问题，此方法返回值只能是 Object[]类，若强转其它<br>类型数组将出现 ClassCastException 错误。<br>正例：<br>    List<string> list = new ArrayList<string>(2);<br>    list.add(“guan”);<br>    list.add(“bao”);<br>    String[] array = new String[list.size()];<br>    array = list.toArray(array);<br>说明：使用 toArray 带参方法，入参分配的数组空间不够大时，toArray 方法内部将重新分配<br>内存空间，并返回新数组地址；如果数组元素大于实际所需，下标为[ list.size() ]的数组<br>元素将被置为 null，其它数组元素保持原值，因此最好将方法入参数组大小定义与集合元素<br>个数一致。</string></string></p><h2 id="【强制】使用工具类-Arrays-asList-把数组转换成集合时，不能使用其修改集合相关的方法，它的-add-remove-clear-方法会抛出-UnsupportedOperationException-异常。"><a href="#【强制】使用工具类-Arrays-asList-把数组转换成集合时，不能使用其修改集合相关的方法，它的-add-remove-clear-方法会抛出-UnsupportedOperationException-异常。" class="headerlink" title="【强制】使用工具类 Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。"></a>【强制】使用工具类 Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。</h2><p>说明：asList 的返回对象是一个 Arrays 内部类，并没有实现集合的修改方法。Arrays.asList<br>体现的是适配器模式，只是转换接口，后台的数据仍是数组。<br>    String[] str = new String[] { “a”, “b” };<br>    List list = Arrays.asList(str);<br>第一种情况：list.add(“c”); 运行时异常。<br>第二种情况：str[0]= “gujin”; 那么 list.get(0)也会随之修改。</p><h2 id="【强制】泛型通配符-lt-extends-T-gt-来接收返回的数据，此写法的泛型集合不能使用-add-方法。"><a href="#【强制】泛型通配符-lt-extends-T-gt-来接收返回的数据，此写法的泛型集合不能使用-add-方法。" class="headerlink" title="【强制】泛型通配符&lt;? extends T&gt;来接收返回的数据，此写法的泛型集合不能使用 add 方法。"></a>【强制】泛型通配符&lt;? extends T&gt;来接收返回的数据，此写法的泛型集合不能使用 add 方法。</h2><p>说明：苹果装箱后返回一个&lt;? extends Fruits&gt;对象，此对象就不能往里加任何水果，包括苹果。</p><h2 id="【强制】不要在-foreach-循环里进行元素的-remove-add-操作。remove-元素请使用-Iterator"><a href="#【强制】不要在-foreach-循环里进行元素的-remove-add-操作。remove-元素请使用-Iterator" class="headerlink" title="【强制】不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator"></a>【强制】不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator</h2><p>方式，如果并发操作，需要对 Iterator 对象加锁。<br>反例：<br>    List<string> a = new ArrayList<string>();<br>        a.add(“1”);<br>        a.add(“2”);<br>        for (String temp : a) {<br>        if(“1”.equals(temp)){<br>        a.remove(temp);<br>        }<br>    }<br>说明：以上代码的执行结果肯定会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的<br>结果吗？<br>正例：<br>    Iterator<string> it = a.iterator();<br>        while(it.hasNext()){<br>        String temp = it.next();<br>        if(删除元素的条件){<br>        it.remove();<br>        }<br>    }<br>##【强制】在 JDK7 版本以上，Comparator 要满足自反性，传递性，对称性，不然 Arrays.sort，Collections.sort 会报 IllegalArgumentException 异常。<br>说明：<br>1） 自反性：x，y 的比较结果和 y，x 的比较结果相反。<br>2） 传递性：x&gt;y,y&gt;z,则 x&gt;z。 3） 对称性：x=y,则 x,z 比较结果和 y，z 比较结果相同。<br>反例：下例中没有处理相等的情况，实际使用中可能会出现异常：<br>    new Comparator<student>() {<br>        @Override<br>        public int compare(Student o1, Student o2) {<br>        return o1.getId() &gt; o2.getId() ? 1 : -1;<br>        }<br>    }</student></string></string></string></p><h2 id="【推荐】集合初始化时，尽量指定集合初始值大小。"><a href="#【推荐】集合初始化时，尽量指定集合初始值大小。" class="headerlink" title="【推荐】集合初始化时，尽量指定集合初始值大小。"></a>【推荐】集合初始化时，尽量指定集合初始值大小。</h2><p>说明：ArrayList 尽量使用 ArrayList(int initialCapacity) 初始化。</p><h2 id="【推荐】使用-entrySet-遍历-Map-类集合-KV，而不是-keySet-方式进行遍历。"><a href="#【推荐】使用-entrySet-遍历-Map-类集合-KV，而不是-keySet-方式进行遍历。" class="headerlink" title="【推荐】使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。"></a>【推荐】使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。</h2><p>说明：keySet 其实是遍历了 2 次，一次是转为 Iterator 对象，另一次是从 hashMap 中取出<br>key 所对应的 value。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中，效<br>率更高。如果是 JDK8，使用 Map.foreach 方法。<br>正例：values()返回的是 V 值集合，是一个 list 集合对象；keySet()返回的是 K 值集合，是<br>一个 Set 集合对象；entrySet()返回的是 K-V 值组合集合。<br>##【推荐】高度注意 Map 类集合 K/V 能不能存储 null 值的情况，如下表格：<br>集合类     Key           Value        Super      说明<br>Hashtable 不允许为 null 不允许为 null Dictionary 线程安全<br>ConcurrentHashMap 不允许为 null 不允许为 null AbstractMap 分段锁技术<br>TreeMap 不允许为 null 允许为 null AbstractMap 线程不安全<br>HashMap 允许为 null 允许为 null AbstractMap 线程不安全<br>反例： 由于 HashMap 的干扰，很多人认为 ConcurrentHashMap 是可以置入 null 值，注意存储<br>null 值时会抛出 NPE 异常。</p><h2 id="【参考】合理利用好集合的有序性-sort-和稳定性-order-，避免集合的无序性-unsort-和不稳定性-unorder-带来的负面影响。"><a href="#【参考】合理利用好集合的有序性-sort-和稳定性-order-，避免集合的无序性-unsort-和不稳定性-unorder-带来的负面影响。" class="headerlink" title="【参考】合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳定性(unorder)带来的负面影响。"></a>【参考】合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳定性(unorder)带来的负面影响。</h2><p>说明：稳定性指集合每次遍历的元素次序是一定的。有序性是指遍历的结果是按某种比较规则<br>依次排列的。如：ArrayList 是 order/unsort；HashMap 是 unorder/unsort；TreeSet 是<br>order/sort。</p><h2 id="【参考】利用-Set-元素唯一的特性，可以快速对一个集合进行去重操作，避免使用-List-的contains-方法进行遍历、对比、去重操作。"><a href="#【参考】利用-Set-元素唯一的特性，可以快速对一个集合进行去重操作，避免使用-List-的contains-方法进行遍历、对比、去重操作。" class="headerlink" title="【参考】利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的contains 方法进行遍历、对比、去重操作。"></a>【参考】利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的contains 方法进行遍历、对比、去重操作。</h2><h1 id="并发处理"><a href="#并发处理" class="headerlink" title="并发处理"></a>并发处理</h1><h2 id="【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。"><a href="#【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。" class="headerlink" title="【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。"></a>【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。</h2><p>说明：资源驱动类、工具类、单例工厂类都需要注意。</p><h2 id="【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。"><a href="#【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。" class="headerlink" title="【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。"></a>【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。</h2><p>正例：<br>    public class TimerTaskThread extends Thread {<br>        public TimerTaskThread(){<br>        super.setName(“TimerTaskThread”); …<br>    }</p><h2 id="【强制】线程资源必须通过线程池ᨀ供，不允许在应用中自行显式创建线程。"><a href="#【强制】线程资源必须通过线程池ᨀ供，不允许在应用中自行显式创建线程。" class="headerlink" title="【强制】线程资源必须通过线程池ᨀ供，不允许在应用中自行显式创建线程。"></a>【强制】线程资源必须通过线程池ᨀ供，不允许在应用中自行显式创建线程。</h2><p>说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资<br>源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者<br>“过度切换”的问题。</p><h2 id="【强制】线程池不允许使用-Executors-去创建，而是通过-ThreadPoolExecutor-的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。"><a href="#【强制】线程池不允许使用-Executors-去创建，而是通过-ThreadPoolExecutor-的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。" class="headerlink" title="【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。"></a>【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</h2><p>说明：Executors 返回的线程池对象的弊端如下： 1）FixedThreadPool 和 SingleThreadPool:<br>允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。 2）CachedThreadPool 和 ScheduledThreadPool:<br>允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</p><h2 id="【强制】SimpleDateFormat-是线程不安全的类，一般不要定义为-static-变量，如果定义为static，必须加锁，或者使用-DateUtils-工具类。"><a href="#【强制】SimpleDateFormat-是线程不安全的类，一般不要定义为-static-变量，如果定义为static，必须加锁，或者使用-DateUtils-工具类。" class="headerlink" title="【强制】SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为static，必须加锁，或者使用 DateUtils 工具类。"></a>【强制】SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为static，必须加锁，或者使用 DateUtils 工具类。</h2><p>正例：注意线程安全，使用 DateUtils。亦推荐如下处理：<br>    private static final ThreadLocal<dateformat> df = new ThreadLocal<dateformat>() {<br>        @Override<br>        protected DateFormat initialValue() {<br>        return new SimpleDateFormat(“yyyy-MM-dd”);<br>        }<br>    };<br>说明：如果是 JDK8 的应用，可以使用 Instant 代替 Date，LocalDateTime 代替 Calendar，<br>DateTimeFormatter代替Simpledateformatter，官方给出的解释：simple beautiful strong<br>immutable thread-safe。</dateformat></dateformat></p><h2 id="【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。"><a href="#【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。" class="headerlink" title="【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。"></a>【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。</h2><h2 id="【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。"><a href="#【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。" class="headerlink" title="【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。"></a>【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。</h2><p>说明：线程一需要对表 A、B、C 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序<br>也必须是 A、B、C，否则可能出现死锁。</p><h2 id="【强制】并发修改同一记录时，避免更新丢失，要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用-version-作为更新依据。"><a href="#【强制】并发修改同一记录时，避免更新丢失，要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用-version-作为更新依据。" class="headerlink" title="【强制】并发修改同一记录时，避免更新丢失，要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。"></a>【强制】并发修改同一记录时，避免更新丢失，要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。</h2><p>说明：如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次<br>数不得小于 3 次。</p><h2 id="【强制】多线程并行处理定时任务时，Timer-运行多个-TimeTask-时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用-ScheduledExecutorService-则没有这个问题。"><a href="#【强制】多线程并行处理定时任务时，Timer-运行多个-TimeTask-时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用-ScheduledExecutorService-则没有这个问题。" class="headerlink" title="【强制】多线程并行处理定时任务时，Timer 运行多个 TimeTask 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题。"></a>【强制】多线程并行处理定时任务时，Timer 运行多个 TimeTask 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题。</h2><h2 id="【推荐】使用-CountDownLatch-进行异步转同步操作，每个线程退出前必须调用-countDown方法，线程执行代码注意-catch-异常，确保-countDown-方法可以执行，避免主线程无法执行至-countDown-方法，直到超时才返回结果。"><a href="#【推荐】使用-CountDownLatch-进行异步转同步操作，每个线程退出前必须调用-countDown方法，线程执行代码注意-catch-异常，确保-countDown-方法可以执行，避免主线程无法执行至-countDown-方法，直到超时才返回结果。" class="headerlink" title="【推荐】使用 CountDownLatch 进行异步转同步操作，每个线程退出前必须调用 countDown方法，线程执行代码注意 catch 异常，确保 countDown 方法可以执行，避免主线程无法执行至 countDown 方法，直到超时才返回结果。"></a>【推荐】使用 CountDownLatch 进行异步转同步操作，每个线程退出前必须调用 countDown方法，线程执行代码注意 catch 异常，确保 countDown 方法可以执行，避免主线程无法执行至 countDown 方法，直到超时才返回结果。</h2><p>说明：注意，子线程抛出异常堆栈，不能在主线程 try-catch 到。</p><h2 id="【推荐】避免-Random-实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed-导致的性能下降。"><a href="#【推荐】避免-Random-实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed-导致的性能下降。" class="headerlink" title="【推荐】避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed 导致的性能下降。"></a>【推荐】避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed 导致的性能下降。</h2><p>说明：Random 实例包括 java.util.Random 的实例或者 Math.random()实例。<br>正例：在 JDK7 之后，可以直接使用 API ThreadLocalRandom，在 JDK7 之前，可以做到每个<br>线程一个实例。</p><h2 id="【推荐】通过双重检查锁（double-checked-locking）（在并发场景）实现延迟初始化的优化问题隐患-可参考-The-“Double-Checked-Locking-is-Broken”-Declaration-推荐问题解决方案中较为简单一种（适用于-JDK5-及以上版本），将目标属性声明为-volatile-型。"><a href="#【推荐】通过双重检查锁（double-checked-locking）（在并发场景）实现延迟初始化的优化问题隐患-可参考-The-“Double-Checked-Locking-is-Broken”-Declaration-推荐问题解决方案中较为简单一种（适用于-JDK5-及以上版本），将目标属性声明为-volatile-型。" class="headerlink" title="【推荐】通过双重检查锁（double-checked locking）（在并发场景）实现延迟初始化的优化问题隐患(可参考 The “Double-Checked Locking is Broken” Declaration),推荐问题解决方案中较为简单一种（适用于 JDK5 及以上版本），将目标属性声明为 volatile 型。"></a>【推荐】通过双重检查锁（double-checked locking）（在并发场景）实现延迟初始化的优化问题隐患(可参考 The “Double-Checked Locking is Broken” Declaration),推荐问题解决方案中较为简单一种（适用于 JDK5 及以上版本），将目标属性声明为 volatile 型。</h2><p>反例：<br>    class Foo {<br>        private Helper helper = null;<br>        public Helper getHelper() {<br>            if (helper == null) synchronized(this) {<br>            if (helper == null)<br>            helper = new Helper();<br>            }<br>            return helper;<br>        }<br>        // other functions and members…<br>    }</p><h2 id="【参考】volatile-解决多线程内存不可见问题。"><a href="#【参考】volatile-解决多线程内存不可见问题。" class="headerlink" title="【参考】volatile 解决多线程内存不可见问题。"></a>【参考】volatile 解决多线程内存不可见问题。</h2><p>对于一写多读，是可以解决变量同步问题，<br>但是如果多写，同样无法解决线程安全问题。如果是 count++操作，使用如下类实现：<br>AtomicInteger count = new AtomicInteger(); count.addAndGet(1); 如果是 JDK8，推<br>荐使用 LongAdder 对象，比 AtomicLong 性能更好（减少乐观锁的重试次数）。</p><h2 id="【参考】-HashMap-在容量不够进行-resize-时由于高并发可能出现死链，导致-CPU-飙升，在开发过程中注意规避此风险。"><a href="#【参考】-HashMap-在容量不够进行-resize-时由于高并发可能出现死链，导致-CPU-飙升，在开发过程中注意规避此风险。" class="headerlink" title="【参考】 HashMap 在容量不够进行 resize 时由于高并发可能出现死链，导致 CPU 飙升，在开发过程中注意规避此风险。"></a>【参考】 HashMap 在容量不够进行 resize 时由于高并发可能出现死链，导致 CPU 飙升，在开发过程中注意规避此风险。</h2><h2 id="【参考】ThreadLocal-无法解决共享对象的更新问题，ThreadLocal-对象建议使用-static修饰。"><a href="#【参考】ThreadLocal-无法解决共享对象的更新问题，ThreadLocal-对象建议使用-static修饰。" class="headerlink" title="【参考】ThreadLocal 无法解决共享对象的更新问题，ThreadLocal 对象建议使用 static修饰。"></a>【参考】ThreadLocal 无法解决共享对象的更新问题，ThreadLocal 对象建议使用 static修饰。</h2><p>这个变量是针对一个线程内所有操作共有的，所以设置为静态变量，所有此类实例共享<br>此静态变量 ，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只<br>要是这个线程内定义的)都可以操控这个变量。</p><h1 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h1><h2 id="【强制】在一个-switch-块内，每个-case-要么通过-break-return-等来终止，要么注释说明程序将继续执行到哪一个-case-为止；"><a href="#【强制】在一个-switch-块内，每个-case-要么通过-break-return-等来终止，要么注释说明程序将继续执行到哪一个-case-为止；" class="headerlink" title="【强制】在一个 switch 块内，每个 case 要么通过 break/return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止；"></a>【强制】在一个 switch 块内，每个 case 要么通过 break/return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止；</h2><p>在一个 switch 块内，都必须包含一个 default 语句并且<br>放在最后，即使它什么代码也没有。</p><h2 id="【强制】在-if-else-for-while-do-语句中必须使用大括号，即使只有一行代码，"><a href="#【强制】在-if-else-for-while-do-语句中必须使用大括号，即使只有一行代码，" class="headerlink" title="【强制】在 if/else/for/while/do 语句中必须使用大括号，即使只有一行代码，"></a>【强制】在 if/else/for/while/do 语句中必须使用大括号，即使只有一行代码，</h2><p>避免使用下面的形式：if (condition) statements;</p><h2 id="【推荐】推荐尽量少用-else，-if-else-的方式可以改写成："><a href="#【推荐】推荐尽量少用-else，-if-else-的方式可以改写成：" class="headerlink" title="【推荐】推荐尽量少用 else， if-else 的方式可以改写成："></a>【推荐】推荐尽量少用 else， if-else 的方式可以改写成：</h2><pre><code>if(condition){    ...    return obj;}// 接着写 else 的业务逻辑代码;</code></pre><p>说明：如果非得使用 if()…else if()…else…方式表达逻辑，<strong><em>【强制】请勿超过 3 层，<br>超过请使用状态设计模式。</em></strong><br>正例：逻辑上超过 3 层的 if-else 代码可以使用卫语句，或者状态模式来实现。</p><h2 id="【推荐】除常用方法（如-getXxx-isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。"><a href="#【推荐】除常用方法（如-getXxx-isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。" class="headerlink" title="【推荐】除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。"></a>【推荐】除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。</h2><p>说明：很多 if 语句内的逻辑相当复杂，阅读者需要分析条件表达式的最终结果，才能明确什么<br>样的条件执行什么样的语句，那么，如果阅读者分析逻辑表达式错误呢？<br>正例：<br>    //伪代码如下<br>    boolean existed = (file.open(fileName, “w”) != null) &amp;&amp; (…) || (…);<br>        if (existed) {<br>        …<br>    }<br>反例：<br>    if ((file.open(fileName, “w”) != null) &amp;&amp; (…) || (…)) {<br>    …<br>    }</p><h2 id="【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理"><a href="#【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理" class="headerlink" title="【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理"></a>【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理</h2><p>如定义对象、变量、获取数据库连接，进行不必要的 try-catch 操作（这个 try-catch 是否可以移至循环体外）。</p><h2 id="【推荐】接口入参保护，这种场景常见的是用于做批量操作的接口。"><a href="#【推荐】接口入参保护，这种场景常见的是用于做批量操作的接口。" class="headerlink" title="【推荐】接口入参保护，这种场景常见的是用于做批量操作的接口。"></a>【推荐】接口入参保护，这种场景常见的是用于做批量操作的接口。</h2><h2 id="【参考】方法中需要进行参数校验的场景："><a href="#【参考】方法中需要进行参数校验的场景：" class="headerlink" title="【参考】方法中需要进行参数校验的场景："></a>【参考】方法中需要进行参数校验的场景：</h2><p>1） 调用频次低的方法。<br>2） 执行时间开销很大的方法，参数校验时间几乎可以忽略不计，但如果因为参数错误导致<br>中间执行回退，或者错误，那得不偿失。<br>3） 需要极高稳定性和可用性的方法。<br>4） 对外提供的开放接口，不管是 RPC/API/HTTP 接口。<br>5） 敏感权限入口。</p><h2 id="【参考】方法中不需要参数校验的场景："><a href="#【参考】方法中不需要参数校验的场景：" class="headerlink" title="【参考】方法中不需要参数校验的场景："></a>【参考】方法中不需要参数校验的场景：</h2><p>1） 极有可能被循环调用的方法，不建议对参数进行校验。但在方法说明里必须注明外部参<br>数检查。<br>2） 底层的方法调用频度都比较高，一般不校验。毕竟是像纯净水过滤的最后一道，参数错<br>误不太可能到底层才会暴露问题。一般 DAO 层与 Service 层都在同一个应用中，部署在同一<br>台服务器中，所以 DAO 的参数校验，可以省略。<br>3） 被声明成 private 只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参<br>数已经做过检查或者肯定不会有问题，此时可以不校验参数。</p><h1 id="注释规约"><a href="#注释规约" class="headerlink" title="注释规约"></a>注释规约</h1><h2 id="【强制】类、类属性、类方法的注释必须使用-Javadoc-规范，使用-内容-格式，不得使用-xxx-方式。"><a href="#【强制】类、类属性、类方法的注释必须使用-Javadoc-规范，使用-内容-格式，不得使用-xxx-方式。" class="headerlink" title="【强制】类、类属性、类方法的注释必须使用 Javadoc 规范，使用 /** 内容 * / 格式，不得使用//xxx 方式。"></a>【强制】类、类属性、类方法的注释必须使用 Javadoc 规范，使用 /** 内容 * / 格式，不得使用//xxx 方式。</h2><p>说明：在 IDE 编辑窗口中，Javadoc 方式会提示相关注释，生成 Javadoc 可以正确输出相应注<br>释；在 IDE 中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高<br>阅读效率。</p><h2 id="【强制】所有的抽象方法（包括接口中的方法）必须要用-Javadoc-注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。"><a href="#【强制】所有的抽象方法（包括接口中的方法）必须要用-Javadoc-注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。" class="headerlink" title="【强制】所有的抽象方法（包括接口中的方法）必须要用 Javadoc 注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。"></a>【强制】所有的抽象方法（包括接口中的方法）必须要用 Javadoc 注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。</h2><p>说明：对子类的实现要求，或者调用注意事项，请一并说明。</p><h2 id="【强制】所有的类都必须添加创建者信息。"><a href="#【强制】所有的类都必须添加创建者信息。" class="headerlink" title="【强制】所有的类都必须添加创建者信息。"></a>【强制】所有的类都必须添加创建者信息。</h2><h2 id="【强制】方法内部单行注释，在被注释语句上方另起一行，使用-注释。方法内部多行注释"><a href="#【强制】方法内部单行注释，在被注释语句上方另起一行，使用-注释。方法内部多行注释" class="headerlink" title="【强制】方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释"></a>【强制】方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释</h2><p>使用/* */注释，注意与代码对齐。</p><h2 id="【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。"><a href="#【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。" class="headerlink" title="【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。"></a>【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。</h2><h2 id="【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。"><a href="#【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。" class="headerlink" title="【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。"></a>【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。</h2><p>反例：“TCP 连接超时”解释成“传输控制协议连接超时”，理解反而费脑筋。</p><h2 id="【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。"><a href="#【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。" class="headerlink" title="【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。"></a>【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。</h2><p>说明：代码与注释更新不同步，就像路网与导航软件更新不同步一样，如果导航软件严重滞后，<br>就失去了导航的意义。</p><h2 id="【参考】注释掉的代码尽量要配合说明，而不是简单的注释掉。"><a href="#【参考】注释掉的代码尽量要配合说明，而不是简单的注释掉。" class="headerlink" title="【参考】注释掉的代码尽量要配合说明，而不是简单的注释掉。"></a>【参考】注释掉的代码尽量要配合说明，而不是简单的注释掉。</h2><p>说明：代码被注释掉有两种可能性：1）后续会恢复此段代码逻辑。2）永久不用。前者如果没<br>有备注信息，难以知晓注释动机。后者建议直接删掉（代码仓库保存了历史代码）。</p><h2 id="【参考】对于注释的要求："><a href="#【参考】对于注释的要求：" class="headerlink" title="【参考】对于注释的要求："></a>【参考】对于注释的要求：</h2><p>第一、能够准确反应设计思想和代码逻辑；<br>第二、能够阐述业务含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同<br>天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看<br>的，使其能够快速接替自己的工作。</p><h2 id="【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。"><a href="#【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。" class="headerlink" title="【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。"></a>【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。</h2><p>（这条对我来说要注意，因为我总倾向于把注释写的很详细，有时出现过度注释）<br>避免出现注释的一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。<br>反例：<br>    // put elephant into fridge<br>    put(elephant, fridge);</p><p>方法名 put，加上两个有意义的变量名 elephant 和 fridge，已经说明了这是在干什么，语<br>义清晰的代码不需要额外的注释。</p><h2 id="【参考】特殊注释标记，请注明标记人与标记时间。"><a href="#【参考】特殊注释标记，请注明标记人与标记时间。" class="headerlink" title="【参考】特殊注释标记，请注明标记人与标记时间。"></a>【参考】特殊注释标记，请注明标记人与标记时间。</h2><p>注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。<br>1） 待办事宜（TODO）:（ 标记人，标记时间，[预计处理时间]）<br>表示需要实现，但目前还未实现的功能。这实际上是一个 Javadoc 的标签，目前的 Javadoc<br>还没有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个 Javadoc 标签）。<br>2） 错误，不能工作（FIXME）:（标记人，标记时间，[预计处理时间]）<br>在注释中用 FIXME 标记某代码是错误的，而且不能工作，需要及时纠正的情况。</p><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><h2 id="【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。"><a href="#【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。" class="headerlink" title="【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。"></a>【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。</h2><p>说明：不要在方法体内定义：Pattern pattern = Pattern.compile(规则);</p><h2 id="【强制】velocity-调用-POJO-类的属性时，建议直接使用属性名取值即可，"><a href="#【强制】velocity-调用-POJO-类的属性时，建议直接使用属性名取值即可，" class="headerlink" title="【强制】velocity 调用 POJO 类的属性时，建议直接使用属性名取值即可，"></a>【强制】velocity 调用 POJO 类的属性时，建议直接使用属性名取值即可，</h2><p>模板引擎会自动按规范调用 POJO 的 getXxx()，如果是 boolean 基本数据类型变量（boolean 命名不需要加 is前缀），会自动调用 isXxx()方法。<br>说明：注意如果是 Boolean 包装类对象，优先调用 getXxx()的方法。</p><h2 id="【强制】后台输送给页面的变量必须加-var-——中间的感叹号。"><a href="#【强制】后台输送给页面的变量必须加-var-——中间的感叹号。" class="headerlink" title="【强制】后台输送给页面的变量必须加$!{var}——中间的感叹号。"></a>【强制】后台输送给页面的变量必须加$!{var}——中间的感叹号。</h2><p>说明：如果 var=null 或者不存在，那么${var}会直接显示在页面上。</p><h2 id="【强制】注意-Math-random-这个方法返回是-double-类型，"><a href="#【强制】注意-Math-random-这个方法返回是-double-类型，" class="headerlink" title="【强制】注意 Math.random() 这个方法返回是 double 类型，"></a>【强制】注意 Math.random() 这个方法返回是 double 类型，</h2><p>注意取值的范围 0≤x&lt;1（能够取到零值，注意除零异常），如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后<br>取整，直接使用 Random 对象的 nextInt 或者 nextLong 方法。</p><h2 id="【强制】获取当前毫秒数-System-currentTimeMillis-而不是-new-Date-getTime"><a href="#【强制】获取当前毫秒数-System-currentTimeMillis-而不是-new-Date-getTime" class="headerlink" title="【强制】获取当前毫秒数 System.currentTimeMillis(); 而不是 new Date().getTime();"></a>【强制】获取当前毫秒数 System.currentTimeMillis(); 而不是 new Date().getTime();</h2><p>说明：如果想获取更加精确的纳秒级时间值，用 System.nanoTime()。在 JDK8 中，针对统计时间等场景，推荐使用 Instant 类。</p><h2 id="【推荐】尽量不要在-vm-中加入变量声明、逻辑运算符，更不要在-vm-模板中加入任何复杂的逻辑。"><a href="#【推荐】尽量不要在-vm-中加入变量声明、逻辑运算符，更不要在-vm-模板中加入任何复杂的逻辑。" class="headerlink" title="【推荐】尽量不要在 vm 中加入变量声明、逻辑运算符，更不要在 vm 模板中加入任何复杂的逻辑。"></a>【推荐】尽量不要在 vm 中加入变量声明、逻辑运算符，更不要在 vm 模板中加入任何复杂的逻辑。</h2><h2 id="【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。"><a href="#【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。" class="headerlink" title="【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。"></a>【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。</h2><h2 id="【推荐】对于“明确停止使用的代码和配置”，如方法、变量、类、配置文件、动态配置属性等要坚决从程序中清理出去，避免造成过多垃圾。"><a href="#【推荐】对于“明确停止使用的代码和配置”，如方法、变量、类、配置文件、动态配置属性等要坚决从程序中清理出去，避免造成过多垃圾。" class="headerlink" title="【推荐】对于“明确停止使用的代码和配置”，如方法、变量、类、配置文件、动态配置属性等要坚决从程序中清理出去，避免造成过多垃圾。"></a>【推荐】对于“明确停止使用的代码和配置”，如方法、变量、类、配置文件、动态配置属性等要坚决从程序中清理出去，避免造成过多垃圾。</h2><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://kangroo.gitee.io/ajcg/#/?id=%e5%89%8d%e8%a8%80" target="_blank" rel="noopener">https://kangroo.gitee.io/ajcg/#/?id=%e5%89%8d%e8%a8%80</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常见的开发规范&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Effctive-Java阅读笔记III</title>
    <link href="http://yoursite.com/2019/12/31/Effctive-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0III/"/>
    <id>http://yoursite.com/2019/12/31/Effctive-Java阅读笔记III/</id>
    <published>2019-12-31T07:06:12.000Z</published>
    <updated>2020-01-03T06:44:27.745Z</updated>
    
    <content type="html"><![CDATA[<p>第二章阅读：创建和销毁对象<br>05.依赖注入优于硬连接资源（hardwiring resources）<br>06.避免创建不必要的对象</p><a id="more"></a><h1 id="依赖注入优于硬连接资源（hardwiring-resources）"><a href="#依赖注入优于硬连接资源（hardwiring-resources）" class="headerlink" title="依赖注入优于硬连接资源（hardwiring resources）"></a>依赖注入优于硬连接资源（hardwiring resources）</h1><p>　许多类依赖于一个或多个底层资源。例如，拼写检查器依赖于字典。将此类类实现为静态工具类并不少见 （详见第 4 条）:</p><pre><code>// Inappropriate use of static utility - inflexible &amp; untestable!public class SpellChecker {    private static final Lexicon dictionary = ...;    private SpellChecker() {} // Noninstantiable    public static boolean isValid(String word) { ... }    public static List&lt;String&gt; suggestions(String typo) { ... }}</code></pre><p>同样地，将它们实现为单例的做法也并不少见（详见第 3 条）：</p><pre><code>// Inappropriate use of singleton - inflexible &amp; untestable!public class SpellChecker {    private final Lexicon dictionary = ...;    private SpellChecker(...) {}    public static INSTANCE = new SpellChecker(...);    public boolean isValid(String word) { ... }    public List&lt;String&gt; suggestions(String typo) { ... }}</code></pre><p>这两种方法都不令人满意，因为他们都是假设只有一本字典可用。实际上，每种语言都有自己的字典，特殊的字典被用于特殊的词汇表。另外，可能还需要用特殊的词典进行测试。想当然地认为一本字典就足够了，这是一厢情愿的想法。</p><p>　　可以通过使 dictionary 属性设置为非final，final关键字修饰的成员变量是常量，修饰的类不能被继承。修饰的成员方法是不能被子类重写的。并添加一个方法来更改现有拼写检查器中的字典，从而让SpellChecker 支持多个字典，但是这样的设置显得非常笨拙、容易出错、并且无法并行工作。静态工具类和单例类不适合与需要引用底层资源的类。</p><p>　　这里所需要的是能够支持类的多个实例 （在我们的示例中是指 SpellChecker），每个实例都使用客户端所期望的资源（在我们的例子中是 dictionary）。满足这一需求的简单模式是，在创建新实例时将资源传递到构造器中。 这是依赖项注入（dependency injection）的一种形式：字典是拼写检查器的一个依赖项，当它创建时被注入到拼写检查器中。</p><pre><code>// Dependency injection provides flexibility and testabilitypublic class SpellChecker {    private final Lexicon dictionary;    public SpellChecker(Lexicon dictionary) {        this.dictionary = Objects.requireNonNull(dictionary);    }    public boolean isValid(String word) { ... }    public List&lt;String&gt; suggestions(String typo) { ... }}</code></pre><p>　　依赖注入模式非常简单，许多程序员使用它多年而不知道它有一个名字。 虽然我们的拼写检查器的例子只有一个资源（字典），但是依赖项注入可以使用任意数量的资源和任意依赖图。 它保持了不变性（详见第 17 条），因此多个客户端可以共享依赖对象（假设客户需要相同的底层资源）。 依赖注入同样适用于构造器、静态工厂（详见第 1 条）和 builder 模式（详见第 2 条）。</p><p>　　该模式的一个有用的变体是将资源工厂传递给构造器。 工厂是可以重复调用以创建类型实例的对象。 这种工厂体现了工厂方法模式（Factory Method pattern）[Gamma95]。 Java 8 中引入的 Supplier<t> 接口非常适合代表工厂。 在输入上采用 Supplier<t> 的方法通常应该使用有界的通配符类型（bounded wildcard type）（详见第 31 条）约束工厂的类型参数，以便客户端能够传入一个工厂，来创建指定类型的任意子类型。例如，下面是一个生产马赛克的方法，它利用客户端提供的工厂来生产每一片马赛克：</t></t></p><pre><code>Mosaic create(Supplier&lt;? extends Tile&gt; tileFactory) { ... }</code></pre><p>　　尽管依赖注入极大地提高了灵活性和可测试性，但它可能使大型项目变得混乱，这些项目通常包含数千个依赖项。使用依赖注入框架（如 Dagger [Dagger]、Guice [Guice] 或 Spring [Spring]）可以消除这些混乱。这些框架的使用超出了本书的范围，但是请注意，为手动依赖注入而设计的 API 非常适合这些框架的使用。</p><p>　　总而言之，不要用单例和静态工具类来实现依赖一个或多个底层资源的类，且该资源的行为会影响到该类的行为；也不要直接用这个类来创建这些资源。而应该将这些资源或者工厂传给构造器（或者静态工厂，或者构建器），通过它们来创建类。这个实践就被称作依赖注人，它极大地提升了类的灵活性、可重用性和可测试性。</p><h1 id="避免创建不必要的对象"><a href="#避免创建不必要的对象" class="headerlink" title="避免创建不必要的对象"></a>避免创建不必要的对象</h1><p>　通过使用静态工厂方法（详见第 1 条）和构造器，可以避免创建不需要的对象。例如，工厂方法 Boolean.valueOf(String) 比构造方法 Boolean(String) 更可取，后者在 Java 9 中被弃用。构造方法每次调用时都必须创建一个新对象，而工厂方法永远不需要这样做，在实践中也不需要。除了重用不可变对象，如果知道它们不会被修改，还可以重用可变对象。<br>一些对象的创建比其他对象的创建要昂贵得多。 如果要重复使用这样一个「昂贵的对象」，建议将其缓存起来以便重复使用。 不幸的是，当创建这样一个对象时并不总是很直观明显的。 假设你想写一个方法来确定一个字符串是否是一个有效的罗马数字。 以下是使用正则表达式完成此操作时最简单方法：</p><pre><code>// Performance can be greatly improved!static boolean isRomanNumeral(String s) {    return s.matches(&quot;^(?=.)M*(C[MD]|D?C{0,3})&quot;            + &quot;(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$&quot;);}</code></pre><p>这个实现的问题在于它依赖于 String.matches 方法。 虽然 String.matches 是检查字符串是否与正则表达式匹配的最简单方法，但它不适合在性能临界的情况下重复使用。 问题是它在内部为正则表达式创建一个 Pattern 实例，并且只使用它一次，之后它就有资格进行垃圾收集。 创建 Pattern 实例是昂贵的，因为它需要将正则表达式编译成有限状态机（finite state machine）。</p><p>　　为了提高性能，作为类初始化的一部分，将正则表达式显式编译为一个 Pattern 实例（不可变），缓存它，并在 isRomanNumeral 方法的每个调用中重复使用相同的实例：</p><pre><code>// Reusing expensive object for improved performancepublic class RomanNumerals {    private static final Pattern ROMAN = Pattern.compile(            &quot;^(?=.)M*(C[MD]|D?C{0,3})&quot;            + &quot;(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$&quot;);    static boolean isRomanNumeral(String s) {        return ROMAN.matcher(s).matches();    }}</code></pre><p>如果经常调用，isRomanNumeral 的改进版本的性能会显著提升。</p><p>　　如果包含 isRomanNumeral 方法的改进版本的类被初始化，但该方法从未被调用，则 ROMAN 属性则没必要初始化。 在第一次调用 isRomanNumeral 方法时，可以通过延迟初始化（ lazily initializing）属性（详见第 83 条）来排除初始化，但一般不建议这样做。 延迟初始化常常会导致实现复杂化，而性能没有可衡量的改进（详见第 67 条）。</p><p>　　当一个对象是不可变的时，很明显它可以被安全地重用，但是在其他情况下，它远没有那么明显，甚至是违反直觉的。考虑适配器（adapters）的情况[Gamma95]，也称为视图（views）。一个适配器是一个对象，它委托一个支持对象（backing object），提供一个可替代的接口。由于适配器没有超出其支持对象的状态，因此不需要为给定对象创建多个给定适配器的实例。</p><p>例如，Map 接口的 keySet 方法返回 Map 对象的 Set 视图，包含 Map 中的所有 key。 天真地说，似乎每次调用 keySet 都必须创建一个新的 Set 实例，但是对给定 Map 对象的 keySet 的每次调用都返回相同的 Set 实例。 尽管返回的 Set 实例通常是可变的，但是所有返回的对象在功能上都是相同的：当其中一个返回的对象发生变化时，所有其他对象也都变化，因为它们全部由相同的 Map 实例支持。 虽然创建 keySet 视图对象的多个实例基本上是无害的，但这是没有必要的，也没有任何好处。</p><p>　　另一种创建不必要的对象的方法是自动装箱（auto boxing），它允许程序员混用基本类型和包装的基本类型，根据需要自动装箱和拆箱。 自动装箱模糊不清，但不会消除基本类型和装箱基本类型之间的区别。 有微妙的语义区别和不那么细微的性能差异（详见第 61 条）。 考虑下面的方法，它计算所有正整数的总和。 要做到这一点，程序必须使用 long 类型，因为 int 类型不足以保存所有正整数的总和：</p><pre><code>// Hideously slow! Can you spot the object creation?private static long sum() {    Long sum = 0L;    for (long i = 0; i &lt;= Integer.MAX_VALUE; i++)        sum += i;    return sum;}</code></pre><p>这个程序的结果是正确的，但由于写错了一个字符，运行的结果要比实际慢很多。变量 sum 被声明成了 Long 而不是 long，这意味着程序构造了大约 231 不必要的 Long 实例（大约每次往 Long 类型的 sum 变量中增加一个 long 类型构造的实例），把 sum 变量的类型由 Long 改为 long。这个教训很明显：优先使用基本类型而不是装箱的基本类型，也要注意无意识的自动装箱。</p><p>　　这个条目不应该被误解为暗示对象创建是昂贵的，应该避免创建对象。 相反，使用构造方法创建和回收小的对象是非常廉价，构造方法只会做很少的显示工作，尤其是在现代 JVM 实现上。 创建额外的对象以增强程序的清晰度，简单性或功能性通常是件好事。</p><p>　　相反，除非池中的对象非常重量级，否则通过维护自己的对象池来避免对象创建是一个坏主意。对象池的典型例子就是数据库连接。建立连接的成本非常高，因此重用这些对象是有意义的。但是，一般来说，维护自己的对象池会使代码混乱，增加内存占用，并损害性能。现代 JVM 实现具有高度优化的垃圾收集器，它们在轻量级对象上轻松胜过此类对象池。</p><p>　　这个条目的对应点是针对条目 50 的防御性复制（defensive copying）。 目前的条目说：「当你应该重用一个现有的对象时，不要创建一个新的对象」，而条目 50 说：「不要重复使用现有的对象，当你应该创建一个新的对象时。」请注意，重用防御性复制所要求的对象所付出的代价，要远远大于不必要地创建重复的对象。 未能在需要的情况下防御性复制会导致潜在的错误和安全漏洞；而不必要地创建对象只会影响程序的风格和性能。</p><p>#参考资料<br>[1] <a href="https://sjsdfg.github.io/effective-java-3rd-chinese/#/notes/05.%20%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E4%BC%98%E4%BA%8E%E7%A1%AC%E8%BF%9E%E6%8E%A5%E8%B5%84%E6%BA%90(hardwiring%20resources)" target="_blank" rel="noopener">https://sjsdfg.github.io/effective-java-3rd-chinese/#/notes/05.%20%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E4%BC%98%E4%BA%8E%E7%A1%AC%E8%BF%9E%E6%8E%A5%E8%B5%84%E6%BA%90(hardwiring%20resources)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二章阅读：创建和销毁对象&lt;br&gt;05.依赖注入优于硬连接资源（hardwiring resources）&lt;br&gt;06.避免创建不必要的对象&lt;/p&gt;
    
    </summary>
    
      <category term="2019年12月" scheme="http://yoursite.com/categories/2019%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Effctive-Java阅读笔记IV</title>
    <link href="http://yoursite.com/2019/12/31/Effctive-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0IV/"/>
    <id>http://yoursite.com/2019/12/31/Effctive-Java阅读笔记IV/</id>
    <published>2019-12-31T07:06:12.000Z</published>
    <updated>2020-01-06T01:44:52.445Z</updated>
    
    <content type="html"><![CDATA[<p>第二章阅读：创建和销毁对象<br>07.消除过期的对象引用<br>08.避免使用 Finalizer 和 Cleaner 机制</p><a id="more"></a><h1 id="消除过期的对象引用"><a href="#消除过期的对象引用" class="headerlink" title="消除过期的对象引用"></a>消除过期的对象引用</h1><p>如果你从使用手动内存管理的语言（如 C 或 C++）切换到像 Java 这样的带有垃圾收集机制的语言，那么作为程序员的工作就会变得容易多了，因为你的对象在使用完毕以后就自动回收了。当你第一次体验它的时候，它就像魔法一样。这很容易让人觉得你不需要考虑内存管理，但这并不完全正确。</p><pre><code>// Can you spot the &quot;memory leak&quot;?public class Stack {    private Object[] elements;    private int size = 0;    private static final int DEFAULT_INITIAL_CAPACITY = 16;    public Stack() {        elements = new Object[DEFAULT_INITIAL_CAPACITY];    }    public void push(Object e) {        ensureCapacity();        elements[size++] = e;    }    public Object pop() {        if (size == 0)            throw new EmptyStackException();        return elements[--size];    }    /**     * Ensure space for at least one more element, roughly     * doubling the capacity each time the array needs to grow.     ** /    private void ensureCapacity() {        if (elements.length == size)            elements = Arrays.copyOf(elements, 2 * size + 1);    }}</code></pre><p>这个程序没有什么明显的错误（但是对于泛型版本，请参阅条目 29）。 你可以对它进行详尽的测试，它都会成功地通过每一项测试，但有一个潜在的问题。 笼统地说，程序有一个「内存泄漏」，由于垃圾回收器的活动的增加，或内存占用的增加，静默地表现为性能下降。 在极端的情况下，这样的内存泄漏可能会导致磁盘分页（disk paging），甚至导致内存溢出（OutOfMemoryError）的失败，但是这样的故障相对较少。</p><p>　　那么哪里发生了内存泄漏？ 如果一个栈增长后收缩，那么从栈弹出的对象不会被垃圾收集，即使使用栈的程序不再引用这些对象。 这是因为栈维护对这些对象的过期引用（obsolete references）。 过期引用简单来说就是永远不会解除的引用。 在这种情况下，元素数组「活动部分（active portion）」之外的任何引用都是过期的。 活动部分是由索引下标小于 size 的元素组成。</p><p>　　垃圾收集语言中的内存泄漏（更适当地称为无意的对象保留 unintentional object retentions）是隐蔽的。 如果无意中保留了对象引用，那么不仅这个对象排除在垃圾回收之外，而且该对象引用的任何对象也是如此。 即使只有少数对象引用被无意地保留下来，也可以阻止垃圾回收机制对许多对象的回收，这对性能产生很大的影响。</p><p>　　这类问题的解决方法很简单：一旦对象引用过期，将它们设置为 null。 在我们的 Stack 类的情景下，只要从栈中弹出，元素的引用就设置为过期。 pop 方法的修正版本如下所示：</p><pre><code>public Object pop() {    if (size == 0)        throw new EmptyStackException();    Object result = elements[--size];    elements[size] = null; // Eliminate obsolete reference    return result;}</code></pre><p>取消过期引用的另一个好处是，如果它们随后被错误地引用，程序立即抛出 NullPointerException 异常，而不是悄悄地做继续做错误的事情。尽可能快地发现程序中的错误是有好处的。</p><p>　　当程序员第一次被这个问题困扰时，他们可能会在程序结束后立即清空所有对象引用。这既不是必要的，也不是可取的；它不必要地搞乱了程序。清空对象引用应该是例外而不是规范。消除过期引用的最好方法是让包含引用的变量超出范围。如果在最近的作用域范围内定义每个变量 （详见第 57 条），这种自然就会出现这种情况。</p><p>　　那么什么时候应该清空一个引用呢？Stack 类的哪个方面使它容易受到内存泄漏的影响？简单地说，它管理自己的内存。存储池（storage pool）由 elements 数组的元素组成（对象引用单元，而不是对象本身）。数组中活动部分的元素 (如前面定义的) 被分配，其余的元素都是空闲的。垃圾收集器没有办法知道这些；对于垃圾收集器来说，elements 数组中的所有对象引用都同样有效。只有程序员知道数组的非活动部分不重要。程序员可以向垃圾收集器传达这样一个事实，一旦数组中的元素变成非活动的一部分，就可以手动清空这些元素的引用。</p><p>　　一般来说，当一个类自己管理内存时，程序员应该警惕内存泄漏问题。 每当一个元素被释放时，元素中包含的任何对象引用都应该被清除。</p><p>　　另一个常见的内存泄漏来源是缓存。 一旦将对象引用放入缓存中，很容易忘记它的存在，并且在它变得无关紧要之后，仍然保留在缓存中。对于这个问题有几种解决方案。如果你正好想实现了一个缓存：只要在缓存之外存在对某个项（entry）的键（key）引用，那么这项就是明确有关联的，就可以用 WeakHashMap 来表示缓存；这些项在过期之后自动删除。记住，只有当缓存中某个项的生命周期是由外部引用到键（key）而不是值（value）决定时，WeakHashMap 才有用。</p><p>　　更常见的情况是，缓存项有用的生命周期不太明确，随着时间的推移一些项变得越来越没有价值。在这种情况下，缓存应该偶尔清理掉已经废弃的项。这可以通过一个后台线程 (也许是 ScheduledThreadPoolExecutor) 或将新的项添加到缓存时顺便清理。LinkedHashMap 类使用它的 removeEldestEntry 方法实现了后一种方案。对于更复杂的缓存，可能直接需要使用 java.lang.ref。</p><p>　　第三个常见的内存泄漏来源是监听器和其他回调。如果你实现了一个 API，其客户端注册回调，但是没有显式地撤销注册回调，除非采取一些操作，否则它们将会累积。确保回调是垃圾收集的一种方法是只存储弱引用（weak references），例如，仅将它们保存在 WeakHashMap 的键（key）中。</p><p>　　因为内存泄漏通常不会表现为明显的故障，所以它们可能会在系统中保持多年。 通常仅在仔细的代码检查或借助堆分析器（heap profiler）的调试工具才会被发现。 因此，学习如何预见这些问题，并防止这些问题发生，是非常值得的。</p><h1 id="避免使用-Finalizer-和-Cleaner-机制"><a href="#避免使用-Finalizer-和-Cleaner-机制" class="headerlink" title="避免使用 Finalizer 和 Cleaner 机制"></a>避免使用 Finalizer 和 Cleaner 机制</h1><p>Finalizer 机制是不可预知的，往往是危险的，而且通常是不必要的。 它们的使用会导致不稳定的行为，糟糕的性能和移植性问题。 Finalizer 机制有一些特殊的用途，我们稍后会在这个条目中介绍，但是通常应该避免它们。 从 Java 9 开始，Finalizer 机制已被弃用，但仍被 Java 类库所使用。 Java 9 中 Cleaner 机制代替了 Finalizer 机制。 Cleaner 机制不如 Finalizer 机制那样危险，但仍然是不可预测，运行缓慢并且通常是不必要的。</p><p>　　提醒 C++程序员不要把 Java 中的 Finalizer 或 Cleaner 机制当成的 C++ 析构函数的等价物。 在 C++ 中，析构函数是回收对象相关资源的正常方式，是与构造方法相对应的。 在 Java 中，当一个对象变得不可达时，垃圾收集器回收与对象相关联的存储空间，不需要开发人员做额外的工作。 C++ 析构函数也被用来回收其他非内存资源。 在 Java 中，try-with-resources 或 try-finally 块用于此目的（详见第 9 条）。</p><p>　　Finalizer 和 Cleaner 机制的一个缺点是不能保证他们能够及时执行[JLS，12.6]。 在一个对象变得无法访问时，到 Finalizer 和 Cleaner 机制开始运行时，这期间的时间是任意长的。 这意味着你永远不应该 Finalizer 和 Cleaner 机制做任何时间敏感（time-critical）的事情。 例如，依赖于 Finalizer 和 Cleaner 机制来关闭文件是严重的错误，因为打开的文件描述符是有限的资源。 如果由于系统迟迟没有运行 Finalizer 和 Cleaner 机制而导致许多文件被打开，程序可能会失败，因为它不能再打开文件了。</p><p>　　及时执行 Finalizer 和 Cleaner 机制是垃圾收集算法的一个功能，这种算法在不同的实现中有很大的不同。程序的行为依赖于 Finalizer 和 Cleaner 机制的及时执行，其行为也可能大不不同。 这样的程序完全可以在你测试的 JVM 上完美运行，然而在你最重要的客户的机器上可能运行就会失败。</p><p>　　延迟终结（finalization）不只是一个理论问题。为一个类提供一个 Finalizer 机制可以任意拖延它的实例的回收。一位同事调试了一个长时间运行的 GUI 应用程序，这个应用程序正在被一个 OutOfMemoryError 错误神秘地死掉。分析显示，在它死亡的时候，应用程序的 Finalizer 机制队列上有成千上万的图形对象正在等待被终结和回收。不幸的是，Finalizer 机制线程的运行优先级低于其他应用程序线程，所以对象被回收的速度低于进入队列的速度。语言规范并不保证哪个线程执行 Finalizer 机制，因此除了避免使用 Finalizer 机制之外，没有轻便的方法来防止这类问题。在这方面， Cleaner 机制比 Finalizer 机制要好一些，因为 Java 类的创建者可以控制自己 cleaner 机制的线程，但 cleaner 机制仍然在后台运行，在垃圾回收器的控制下运行，但不能保证及时清理。</p><p>　　Java 规范不能保证 Finalizer 和 Cleaner 机制能及时运行；它甚至不能能保证它们是否会运行。当一个程序结束后，一些不可达对象上的 Finalizer 和 Cleaner 机制仍然没有运行。因此，不应该依赖于 Finalizer 和 Cleaner 机制来更新持久化状态。例如，依赖于 Finalizer 和 Cleaner 机制来释放对共享资源（如数据库）的持久锁，这是一个使整个分布式系统陷入停滞的好方法。</p><p>　　不要相信 System.gc 和 System.runFinalization 方法。 他们可能会增加 Finalizer 和 Cleaner 机制被执行的几率，但不能保证一定会执行。 曾经声称做出这种保证的两个方法：System.runFinalizersOnExit 和它的孪生兄弟 Runtime.runFinalizersOnExit，包含致命的缺陷，并已被弃用了几十年[ThreadStop]。</p><p>　　Finalizer 机制的另一个问题是在执行 Finalizer 机制过程中，未捕获的异常会被忽略，并且该对象的 Finalizer 机制也会终止 [JLS, 12.6]。未捕获的异常会使其他对象陷入一种损坏的状态（corrupt state）。如果另一个线程试图使用这样一个损坏的对象，可能会导致任意不确定的行为。通常情况下，未捕获的异常将终止线程并打印堆栈跟踪（ stacktrace），但如果发生在 Finalizer 机制中，则不会发出警告。Cleaner 机制没有这个问题，因为使用 Cleaner 机制的类库可以控制其线程。</p><p>　　使用 finalizer 和 cleaner 机制会导致严重的性能损失。 在我的机器上，创建一个简单的 AutoCloseable 对象，使用 try-with-resources 关闭它，并让垃圾回收器回收它的时间大约是 12 纳秒。 使用 finalizer 机制，而时间增加到 550 纳秒。 换句话说，使用 finalizer 机制创建和销毁对象的速度要慢 50 倍。 这主要是因为 finalizer 机制会阻碍有效的垃圾收集。 如果使用它们来清理类的所有实例（在我的机器上的每个实例大约是 500 纳秒），那么 cleaner 机制的速度与 finalizer 机制的速度相当，但是如果仅将它们用作安全网（safety net），则 cleaner 机制要快得多，如下所述。 在这种环境下，创建，清理和销毁一个对象在我的机器上需要大约 66 纳秒，这意味着如果你不使用安全网的话，需要支付 5 倍（而不是 50 倍）的保险。</p><p>　　finalizer 机制有一个严重的安全问题：它们会打开你的类来进行 finalizer 机制攻击。finalizer 机制攻击的想法很简单：如果一个异常是从构造方法或它的序列化中抛出的——readObject 和 readResolve 方法 （第 12 章）——恶意子类的 finalizer 机制可以运行在本应该「中途夭折（died on the vine）」的部分构造对象上。finalizer 机制可以在静态字属性记录对对象的引用，防止其被垃圾收集。一旦记录了有缺陷的对象，就可以简单地调用该对象上的任意方法，而这些方法本来就不应该允许存在。从构造方法中抛出异常应该足以防止对象出现；而在 finalizer 机制存在下，则不是。这样的攻击会带来可怕的后果。Final 类不受 finalizer 机制攻击的影响，因为没有人可以编写一个 final 类的恶意子类。为了保护非 final 类不受 finalizer 机制攻击，编写一个 final 的 finalize 方法，它什么都不做。</p><p>　　那么，你应该怎样做呢？为对象封装需要结束的资源（如文件或线程），而不是为该类编写 Finalizer 和 Cleaner 机制？让你的类实现 AutoCloseable 接口即可，并要求客户在在不再需要时调用每个实例 close 方法，通常使用 try-with-resources 确保终止，即使面对有异常抛出情况（详见第 9 条）。一个值得一提的细节是实例必须跟踪是否已经关闭：close 方法必须记录在对象里不再有效的属性，其他方法必须检查该属性，如果在对象关闭后调用它们，则抛出 IllegalStateException 异常。</p><p>　　那么，Finalizer 和 Cleaner 机制有什么好处呢？它们可能有两个合法用途。一个是作为一个安全网（safety net），以防资源的拥有者忽略了它的 close 方法。虽然不能保证 Finalizer 和 Cleaner 机制会迅速运行 (或者根本就没有运行)，最好是把资源释放晚点出来，也要好过客户端没有这样做。如果你正在考虑编写这样的安全网 Finalizer 机制，请仔细考虑一下这样保护是否值得付出对应的代价。一些 Java 库类，如 FileInputStream、FileOutputStream、ThreadPoolExecutor 和 java.sql.Connection，都有作为安全网的 Finalizer 机制。</p><p>　　第二种合理使用 Cleaner 机制的方法与本地对等类（native peers）有关。本地对等类是一个由普通对象委托的本地 (非 Java) 对象。由于本地对等类不是普通的 Java 对象，所以垃圾收集器并不知道它，当它的 Java 对等对象被回收时，本地对等类也不会回收。假设性能是可以接受的，并且本地对等类没有关键的资源，那么 Finalizer 和 Cleaner 机制可能是这项任务的合适的工具。但如果性能是不可接受的，或者本地对等类持有必须迅速回收的资源，那么类应该有一个 close 方法，正如前面所述。</p><p>　　Cleaner 机制使用起来有点棘手。下面是演示该功能的一个简单的 Room 类。假设 Room 对象必须在被回收前清理干净。Room 类实现 AutoCloseable 接口；它的自动清理安全网使用的是一个 Cleaner 机制，这仅仅是一个实现细节。与 Finalizer 机制不同，Cleaner 机制不污染一个类的公共 API：</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://sjsdfg.github.io/effective-java-3rd-chinese/#/notes/08.%20%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8Finalizer%E5%92%8CCleaner%E6%9C%BA%E5%88%B6" target="_blank" rel="noopener">https://sjsdfg.github.io/effective-java-3rd-chinese/#/notes/08.%20%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8Finalizer%E5%92%8CCleaner%E6%9C%BA%E5%88%B6</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二章阅读：创建和销毁对象&lt;br&gt;07.消除过期的对象引用&lt;br&gt;08.避免使用 Finalizer 和 Cleaner 机制&lt;/p&gt;
    
    </summary>
    
      <category term="2019年12月" scheme="http://yoursite.com/categories/2019%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Effctive-Java阅读笔记II</title>
    <link href="http://yoursite.com/2019/12/31/Effctive-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0II/"/>
    <id>http://yoursite.com/2019/12/31/Effctive-Java阅读笔记II/</id>
    <published>2019-12-31T03:30:12.000Z</published>
    <updated>2020-01-03T06:44:32.400Z</updated>
    
    <content type="html"><![CDATA[<p>第二章阅读：创建和销毁对象<br>03.使用私有构造方法或枚类实现 Singleton 属性<br>04.使用私有构造器执行非实例化<br>（这两部分理解有困难，需要再查阅相关资料）</p><a id="more"></a><h1 id="使用私有构造方法或枚类实现-Singleton-属性"><a href="#使用私有构造方法或枚类实现-Singleton-属性" class="headerlink" title="使用私有构造方法或枚类实现 Singleton 属性"></a>使用私有构造方法或枚类实现 Singleton 属性</h1><p>单例是一个仅实例化一次的类，详细描述参见笔记：《设计模式面试高频题》。单例对象通常表示无状态对象，如函数 (条目 24) 或一个本质上唯一的系统组件。让一个类成为单例会使测试它的客户变得困难，因为除非实现一个作为它类型的接口，否则不可能用一个模拟实现替代单例。</p><p>　有两种常见的方法来实现单例。两者都基于保持构造方法私有和导出公共静态成员以提供对唯一实例的访问。在第一种方法中，成员是 final 修饰的属性：</p><pre><code>// Singleton with public final fieldpublic class Elvis {    public static final Elvis INSTANCE = new Elvis();    private Elvis() { ... }    public void leaveTheBuilding() { ... }}</code></pre><p>私有构造方法只调用一次，来初始化公共静态 final Elvis.INSTANCE 属性。缺少一个公共的或受保护的构造方法，保证了全局的唯一性：一旦 Elvis 类被初始化，一个 Elvis 的实例就会存在——不多也不少。客户端所做的任何事情都不能改变这一点，但需要注意的是：特权客户端可以使用 AccessibleObject.setAccessible 方法，以反射方式调用私有构造方法（详见第 65 条）。如果需要防御此攻击，请修改构造函数，使其在请求创建第二个实例时抛出异常。<br>　在第二个实现单例的方法中，公共成员是一个静态的工厂方法：</p><pre><code>// Singleton with static factorypublic class Elvis {    private static final Elvis INSTANCE = new Elvis();    private Elvis() { ... }    public static Elvis getInstance() { return INSTANCE; }    public void leaveTheBuilding() { ... }}</code></pre><p>所有对 Elvis.getInstance 的调用都返回相同的对象引用，并且不会创建其他的 Elvis 实例（与前面提到的警告相同）。</p><p>　　公共属性方法的主要优点是 API 明确表示该类是一个单例：公共静态属性是 final 的，所以它总是包含相同的对象引用。 第二个好处是它更简单。</p><p>　　静态工厂方法的优势之一在于，它提供了灵活性：在不改变其 API 的前提下，我们可以改变该类是否应该为单例的想法。工厂方法返回该类的唯一实例，但是，它很容易被修改，比如，改为每个调用该方法的线程返回一个唯一的实例。 第二个好处是，如果你的应用程序需要它，可以编写一个泛型单例工厂（generic singleton factory ）（详见第30 条）。 使用静态工厂的最后一个优点是，可以通过方法引用（method reference）作为提供者，例如 Elvis::instance 等同于 Supplier<elvis>。 除非满足以上任意一种优势，否则还是优先考虑公有域（public-field）的方法。</elvis></p><p>　　为了将上述方法中实现的单例类变成是可序列化的 （第 12 章），仅仅将 implements Serializable 添加到声明中是不够的。为了保证单例模式不被破坏，必须声明所有的实例字段为 transient，并提供一个 readResolve 方法（详见第 89 条）。否则，每当序列化的实例被反序列化时，就会创建一个新的实例，在我们的例子中，导致出现新的 Elvis 实例。为了防止这种情况发生，将如下的 readResolve 方法添加到 Elvis 类：</p><pre><code>// readResolve method to preserve singleton propertyprivate Object readResolve() {     // Return the one true Elvis and let the garbage collector     // take care of the Elvis impersonator.    return INSTANCE;}</code></pre><p>实现一个单例的第三种方法是声明单一元素的枚举类：</p><pre><code>// Enum singleton - the preferred approachpublic enum Elvis {    INSTANCE;    public void leaveTheBuilding() { ... }}</code></pre><p>　这种方式类似于公共属性方法，但更简洁，无偿地提供了序列化机制，并提供了防止多个实例化的坚固保证，即使是在复杂的序列化或反射攻击的情况下。这种方法可能感觉有点不自然，但是 单一元素枚举类通常是实现单例的最佳方式。注意，如果单例必须继承 Enum 以外的父类 (尽管可以声明一个 Enum 来实现接口)，那么就不能使用这种方法。</p><h1 id="使用私有构造器执行非实例化"><a href="#使用私有构造器执行非实例化" class="headerlink" title="使用私有构造器执行非实例化"></a>使用私有构造器执行非实例化</h1><p>试图通过创建抽象类来强制执行非实例化是行不通的。 该类可以被子类化，并且子类可以被实例化。此外，它误导用户认为该类是为继承而设计的（详见第 19 条）。不过，有一个简单的方法来确保非实例化。只有当类不包含显式构造器时，才会生成一个默认构造器，因此可以通过包含一个私有构造器来实现类的非实例化：</p><pre><code>// Noninstantiable utility classpublic class UtilityClass {    // Suppress default constructor for noninstantiability    private UtilityClass() {        throw new AssertionError();    }    ... // Remainder omitted}</code></pre><p>因为显式构造器是私有的，所以不可以在类的外部访问它。AssertionError 异常不是严格要求的，但是它可以避免不小心在类的内部调用构造器。它保证类在任何情况下都不会被实例化。这个习惯用法有点违反直觉，好像构造器就是设计成不能调用的一样。因此，如前面所示，添加注释是种明智的做法。</p><p>　　这种习惯有一个副作用，就是使得一个类不能子类化。所有的构造器都必须显式或隐式地调用父类构造器，而在这群情况下子类则没有可访问的父类构造器来调用。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二章阅读：创建和销毁对象&lt;br&gt;03.使用私有构造方法或枚类实现 Singleton 属性&lt;br&gt;04.使用私有构造器执行非实例化&lt;br&gt;（这两部分理解有困难，需要再查阅相关资料）&lt;/p&gt;
    
    </summary>
    
      <category term="2019年12月" scheme="http://yoursite.com/categories/2019%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>设计模式学习笔记III</title>
    <link href="http://yoursite.com/2019/12/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0III/"/>
    <id>http://yoursite.com/2019/12/30/设计模式学习笔记III/</id>
    <published>2019-12-30T08:55:12.000Z</published>
    <updated>2019-12-30T10:12:54.670Z</updated>
    
    <content type="html"><![CDATA[<p>静态静态工厂方法</p><a id="more"></a><h1 id="序：什么是静态工厂方法"><a href="#序：什么是静态工厂方法" class="headerlink" title="序：什么是静态工厂方法"></a>序：什么是静态工厂方法</h1><p>在 Java 中，获得一个类实例最简单的方法就是使用 new 关键字，通过构造函数来实现对象的创建。<br>就像这样：</p><pre><code>Fragment fragment = new MyFragment();// orDate date = new Date();</code></pre><p>不过在实际的开发中，我们经常还会见到另外一种获取类实例的方法：</p><pre><code>Fragment fragment = MyFragment.newIntance();// orCalendar calendar = Calendar.getInstance();// orInteger number = Integer.valueOf(&quot;3&quot;);</code></pre><p> <strong><em>像这样的：不通过 new，而是用一个静态方法来对外提供自身实例的方法，即为我们所说的静态工厂方法(Static factory method)。</em></strong></p><h2 id="知识点：new-究竟做了什么"><a href="#知识点：new-究竟做了什么" class="headerlink" title="知识点：new 究竟做了什么?"></a>知识点：new 究竟做了什么?</h2><p>简单来说：当我们使用 new 来构造一个新的类实例时，其实是告诉了 JVM 我需要一个新的实例。JVM 就会自动在内存中开辟一片空间，然后调用构造函数来初始化成员变量，最终把引用返回给调用方。</p><h1 id="Effective-Java"><a href="#Effective-Java" class="headerlink" title="Effective Java"></a>Effective Java</h1><p>在关于 Java 中书籍中，《Effective Java》绝对是最负盛名几本的之一，在此书中，作者总结了几十条改善 Java 程序设计的金玉良言。其中开篇第一条就是『考虑使用静态工厂方法代替构造器』，关于其原因，作者总结了几条，我们先来逐个看一下。</p><h2 id="静态工厂方法与构造器不同的第一优势在于，它们有名字"><a href="#静态工厂方法与构造器不同的第一优势在于，它们有名字" class="headerlink" title="静态工厂方法与构造器不同的第一优势在于，它们有名字"></a>静态工厂方法与构造器不同的第一优势在于，它们有名字</h2><p>由于语言的特性，Java 的构造函数都是跟类名一样的。这导致的一个问题是构造函数的名称不够灵活，经常不能准确地描述返回值，在有多个重载的构造函数时尤甚，如果参数类型、数目又比较相似的话，那更是很容易出错。</p><p>比如，如下的一段代码 ：</p><pre><code>Date date0 = new Date();Date date1 = new Date(0L);Date date2 = new Date(&quot;0&quot;);Date date3 = new Date(1,2,1);Date date4 = new Date(1,2,1,1,1);Date date5 = new Date(1,2,1,1,1,1);</code></pre><p>Date 类有很多重载函数，对于开发者来说，假如不是特别熟悉的话，恐怕是需要犹豫一下，才能找到合适的构造函数的。而对于其他的代码阅读者来说，估计更是需要查看文档，才能明白每个参数的含义了。</p><p>（当然，Date 类在目前的 Java 版本中，只保留了一个无参和一个有参的构造函数，其他的都已经标记为 @Deprecated 了）</p><p>而如果使用静态工厂方法，就可以给方法起更多有意义的名字，比如前面的 valueOf、newInstance、getInstance 等，对于代码的编写和阅读都能够更清晰。</p><h2 id="第二个优势，不用每次被调用时都创建新对象"><a href="#第二个优势，不用每次被调用时都创建新对象" class="headerlink" title="第二个优势，不用每次被调用时都创建新对象"></a>第二个优势，不用每次被调用时都创建新对象</h2><p>这个很容易理解了，有时候外部调用者只需要拿到一个实例，而不关心是否是新的实例；又或者我们想对外提供一个单例时如果使用工厂方法，就可以很容易的在内部控制，防止创建不必要的对象，减少开销。</p><p>在实际的场景中，单例的写法也大都是用静态工厂方法来实现的。</p><p>如果你想对单例有更多了解，可以看一下这里：☞《Hi，我们再来聊一聊Java的单例吧》[2]</p><h2 id="第三个优势，可以返回原返回类型的子类"><a href="#第三个优势，可以返回原返回类型的子类" class="headerlink" title="第三个优势，可以返回原返回类型的子类"></a>第三个优势，可以返回原返回类型的子类</h2><p>这条不用多说，设计模式中的基本的原则之一——『里氏替换』原则，就是说子类应该能替换父类。<br>显然，构造方法只能返回确切的自身类型，而静态工厂方法则能够更加灵活，可以根据需要方便地返回任何它的子类型的实例。</p><pre><code>Class Person {    public static Person getInstance(){        return new Person();        // 这里可以改为 return new Player() / Cooker()    }}Class Player extends Person{}Class Cooker extends Person{}</code></pre><p>比如上面这段代码，Person 类的静态工厂方法可以返回 Person 的实例，也可以根据需要返回它的子类 Player 或者 Cooker。（当然，这只是为了演示，在实际的项目中，一个类是不应该依赖于它的子类的。但如果这里的 getInstance () 方法位于其他的类中，就更具有的实际操作意义了）</p><h2 id="静态工厂的第四个优点是返回对象的类可以根据输入参数的不同而不同"><a href="#静态工厂的第四个优点是返回对象的类可以根据输入参数的不同而不同" class="headerlink" title="静态工厂的第四个优点是返回对象的类可以根据输入参数的不同而不同"></a>静态工厂的第四个优点是返回对象的类可以根据输入参数的不同而不同</h2><p>EnumSet 类（详见第 36 条）没有公共构造方法，只有静态工厂。 在 OpenJDK 实现中，它们根据底层枚举类型的大小返回两个子类中的一个的实例：大多数枚举类型具有 64 个或更少的元素，静态工厂将返回一个 RegularEnumSet 实例， 底层是long 类型；如果枚举类型具有六十五个或更多元素，则工厂将返回一个 JumboEnumSet 实例，底层是long 类型的数组。</p><pre><code>/**     * Creates an empty enum set with the specified element type.     *     * @param &lt;E&gt; The class of the elements in the set     * @param elementType the class object of the element type for this enum     *     set     * @return An empty enum set of the specified type.     * @throws NullPointerException if &lt;tt&gt;elementType&lt;/tt&gt; is null     ** /    public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; noneOf(Class&lt;E&gt; elementType) {        Enum&lt;?&gt;[] universe = getUniverse(elementType);        if (universe == null)            throw new ClassCastException(elementType + &quot; not an enum&quot;);        if (universe.length &lt;= 64)            return new RegularEnumSet&lt;&gt;(elementType, universe);        else            return new JumboEnumSet&lt;&gt;(elementType, universe);    }</code></pre><p>　　这两个实现类的存在对于客户端而言是不可见的。 如果 RegularEnumSet 对于小的枚举类型不再具有性能优势，则可以在未来版本中将其淘汰，且不会产生任何不良影响。 同样，如果可以证明添加 EnumSet 的更多的实现可以提高性能，那么在未来的版本可能就会这样做。 客户既不知道也不关心他们从工厂返回的对象的类别; 他们只需要知道它是 EnumSet 的子类。</p><h2 id="第五个优势是，在编写包含该方法的类时，返回的对象的类不需要存在。"><a href="#第五个优势是，在编写包含该方法的类时，返回的对象的类不需要存在。" class="headerlink" title="第五个优势是，在编写包含该方法的类时，返回的对象的类不需要存在。"></a>第五个优势是，在编写包含该方法的类时，返回的对象的类不需要存在。</h2><p>这种灵活的静态工厂方法构成了服务提供者框架的基础，比如 Java 数据库连接 AP（JDBC）。服务提供者框架是提供者实现服务的系统，并且系统使得实现对客户端可用，从而将客户端从实现中分离出来。</p><p>书中这段读起来比较晦涩，对服务提供者框架在参考资料[3]中有解释，<br>　　<br><img src="assets/markdown-img-paste-20191230175836971.png" alt></p><p>服务提供者框架中有三个基本组：服务接口，它表示实现；提供者注册 API，提供者用来注册实现；以及服务访问 API，客户端使用该 API 获取服务的实例。服务访问 API 允许客户指定选择实现的标准。在缺少这样的标准的情况下，API 返回一个默认实现的实例，或者允许客户通过所有可用的实现进行遍历。服务访问 API 是灵活的静态工厂，它构成了服务提供者框架的基础。</p><p>  Class.forName(“com.mysql.jdbc.Driver”);</p><p>这样一个语句会实例化一个Driver类（提供服务者实现类），并将这个类的实例注册到DriverManager（服务提供者注册类）。</p><p>  DriverManager.getConnection(“jdbc:mysql://…”,”…”,”…”);<br>这里通过建立连接的URL等信息来获取数据库连接。DriverManager通过传进来的url信息判断出你是要获取那个服务提供者提供的服务。因为前面已经将提供服务者实现类注册到DriverManager了，DriverManager获取到这个服务提供者实现类对象之后，通过调用它的getService（mysql里面是connect方法）方法获取到服务具体实现类对象，返回的却是java.sql.Connection接口对象（因为服务具体实现类实现了Connection接口），这样把服务具体实现类对象隐藏了。提供了很好的扩展性。</p><p>　　服务提供者框架的一个可选的第四个组件是一个服务提供者接口，它描述了一个生成服务接口实例的工厂对象。在没有服务提供者接口的情况下，必须对实现进行反射实例化（详见第 65 条）。在 JDBC 的情况下，Connection 扮演服务接口的一部分，DriverManager.registerDriver 提供程序注册 API、DriverManager.getConnection 是服务访问 API，Driver 是服务提供者接口。</p><p>服务提供者框架模式有许多变种。 例如，服务访问 API 可以向客户端返回比提供者提供的更丰富的服务接口。 这是桥接模式。 依赖注入框架（详见第 5 条）可以被看作是强大的服务提供者。 从 Java 6 开始，平台包含一个通用的服务提供者框架 java.util.ServiceLoader，所以你不需要，一般也不应该自己编写（详见第 59 条）。 JDBC 不使用 ServiceLoader，因为前者早于后者。</p><h2 id="另一个优势，在创建带泛型的实例时，能使代码变得简洁"><a href="#另一个优势，在创建带泛型的实例时，能使代码变得简洁" class="headerlink" title="另一个优势，在创建带泛型的实例时，能使代码变得简洁"></a>另一个优势，在创建带泛型的实例时，能使代码变得简洁</h2><p>这条主要是针对带泛型类的繁琐声明而说的，需要重复书写两次泛型参数：</p><p>Map&lt;String,Date&gt; map = new HashMap&lt;String,Date&gt;();<br>不过自从 java7 开始，这种方式已经被优化过了 —— 对于一个已知类型的变量进行赋值时，由于泛型参数是可以被推导出，所以可以在创建实例时省略掉泛型参数。</p><p>Map&lt;String,Date&gt; map = new HashMap&lt;&gt;();</p><h1 id="除此之外"><a href="#除此之外" class="headerlink" title="除此之外"></a>除此之外</h1><p>以上是《Effective Java》中总结的几条应该使用静态工厂方法代替构造器的原因，除了上面总结的几条之外，静态工厂方法实际上还有更多的优势。</p><h2 id="可以有多个参数相同但名称不同的工厂方法"><a href="#可以有多个参数相同但名称不同的工厂方法" class="headerlink" title="可以有多个参数相同但名称不同的工厂方法"></a>可以有多个参数相同但名称不同的工厂方法</h2><p>构造函数虽然也可以有多个，但是由于函数名已经被固定，所以就要求参数必须有差异时（类型、数量或者顺序）才能够重载了。<br>举例来说：</p><pre><code>class Child{    int age = 10;    int weight = 30;    public Child(int age, int weight) {        this.age = age;        this.weight = weight;    }    public Child(int age) {        this.age = age;    }}</code></pre><p>Child 类有 age 和 weight 两个属性，如代码所示，它已经有了两个构造函数：Child(int age, int weight) 和 Child(int age)，这时候如果我们想再添加一个指定 wegiht 但不关心 age 的构造函数，一般是这样：</p><pre><code>public Child( int weight) {    this.weight = weight;}</code></pre><p>但要把这个构造函数添加到 Child 类中，我们都知道是行不通的，因为 java 的函数签名是忽略参数名称的，所以 Child(int age) 跟 Child(int weight) 会冲突。</p><p>这时候，静态工厂方法就可以登场了。</p><pre><code>class Child{    int age = 10;    int weight = 30;    public static Child newChild(int age, int weight) {        Child child = new Child();        child.weight = weight;        child.age = age;        return child;    }    public static Child newChildWithWeight(int weight) {        Child child = new Child();        child.weight = weight;        return child;    }    public static Child newChildWithAge(int age) {        Child child = new Child();        child.age = age;        return child;    }}</code></pre><p>其中的 newChildWithWeight 和 newChildWithAge，就是两个参数类型相同的的方法，但是作用不同，如此，就能够满足上面所说的类似Child(int age) 跟 Child(int weight)同时存在的需求。<br>（另外，这两个函数名字也是自描述的，相对于一成不变的构造函数更能表达自身的含义，这也是上面所说的第一条优势 —— 『它们有名字』）</p><h2 id="可以减少对外暴露的属性"><a href="#可以减少对外暴露的属性" class="headerlink" title="可以减少对外暴露的属性"></a>可以减少对外暴露的属性</h2><p>软件开发中有一条很重要的经验：对外暴露的属性越多，调用者就越容易出错。所以对于类的提供者，一般来说，应该努力减少对外暴露属性，从而降低调用者出错的机会。</p><p>考虑一下有如下一个 Player 类：</p><pre><code>// Player : Version 1class Player {    public static final int TYPE_RUNNER = 1;    public static final int TYPE_SWIMMER = 2;    public static final int TYPE_RACER = 3;    protected int type;    public Player(int type) {        this.type = type;    }}</code></pre><p>Player 对外提供了一个构造方法，让使用者传入一个 type 来表示类型。那么这个类期望的调用方式就是这样的：</p><pre><code>Player player1 = new Player(Player.TYPE_RUNNER);Player player2 = new Player(Player.TYPE_SWEIMMER);</code></pre><p>但是，我们知道，提供者是无法控制调用方的行为的，实际中调用方式可能是这样的：</p><pre><code>Player player3 = new Player(0);Player player4 = new Player(-1);Player player5 = new Player(10086);</code></pre><p>提供者期望的构造函数传入的值是事先定义好的几个常量之一，但如果不是，就很容易导致程序错误。</p><p>—— 要避免这种错误，使用枚举来代替常量值是常见的方法之一，当然如果不想用枚举的话，使用我们今天所说的主角静态工厂方法也是一个很好的办法。</p><p>插一句：<br>实际上，使用枚举也有一些缺点，比如增大了调用方的成本；如果枚举类成员增加，会导致一些需要完备覆盖所有枚举的调用场景出错等。<br>如果把以上需求用静态工厂方法来实现，代码大致是这样的：</p><pre><code>// Player : Version 2class Player {    public static final int TYPE_RUNNER = 1;    public static final int TYPE_SWIMMER = 2;    public static final int TYPE_RACER = 3;    int type;    private Player(int type) {        this.type = type;    }    public static Player newRunner() {        return new Player(TYPE_RUNNER);    }    public static Player newSwimmer() {        return new Player(TYPE_SWIMMER);    }    public static Player newRacer() {        return new Player(TYPE_RACER);    }}</code></pre><p>注意其中的构造方法被声明为了 private，这样可以防止它被外部调用，于是调用方在使用 Player 实例的时候，基本上就必须通过 newRunner、newSwimmer、newRacer 这几个静态工厂方法来创建，调用方无须知道也无须指定 type 值 —— 这样就能把 type 的赋值的范围控制住，防止前面所说的异常值的情况。</p><p>插一句：<br>严谨一些的话，通过反射仍能够绕过静态工厂方法直接调用构造函数，甚至直接修改一个已创建的 Player 实例的 type 值，但本文暂时不讨论这种非常规情况。</p><h2 id="多了一层控制，方便统一修改"><a href="#多了一层控制，方便统一修改" class="headerlink" title="多了一层控制，方便统一修改"></a>多了一层控制，方便统一修改</h2><p>我们在开发中一定遇到过很多次这样的场景：在写一个界面时，服务端的数据还没准备好，这时候我们经常就需要自己在客户端编写一个测试的数据，来进行界面的测试，像这样：</p><pre><code>// 创建一个测试数据User tester = new User();tester.setName(&quot;隔壁老王&quot;);tester.setAge(25);tester.setDescription(&quot;我住隔壁我姓王！&quot;);// use testerbindUI(tester);……</code></pre><p>要写一连串的测试代码，如果需要测试的界面有多个，那么这一连串的代码可能还会被复制多次到项目的多个位置。</p><p>这种写法的缺点呢，首先是代码臃肿、混乱；其次是万一上线的时候漏掉了某一处，忘记修改，那就可以说是灾难了……</p><p>但是如果你像我一样，习惯了用静态工厂方法代替构造器的话，则会很自然地这么写，先在 User 中定义一个 newTestInstance 方法：</p><pre><code>static class User{    String name ;    int age ;    String description;    public static User newTestInstance() {        User tester = new User();        tester.setName(&quot;隔壁老王&quot;);        tester.setAge(25);        tester.setDescription(&quot;我住隔壁我姓王！&quot;);        return tester;    }}</code></pre><p>然后调用的地方就可以这样写了：</p><pre><code>// 创建一个测试数据User tester = User.newTestInstance();// use testerbindUI(tester);</code></pre><p>是不是瞬间就觉得优雅了很多？！</p><p>而且不只是代码简洁优雅，由于所有测试实例的创建都是在这一个地方，所以在需要正式数据的时候，也只需把这个方法随意删除或者修改一下，所有调用者都会编译不通过，彻底杜绝了由于疏忽导致线上还有测试代码的情况。</p><h1 id="缺点：没有公共或受保护构造方法的类不能被子类化"><a href="#缺点：没有公共或受保护构造方法的类不能被子类化" class="headerlink" title="缺点：没有公共或受保护构造方法的类不能被子类化"></a>缺点：没有公共或受保护构造方法的类不能被子类化</h1><p>例如，要想将 Collections 框架中任何遍历的实现类进行子类化，是不可能的。但是这样也会因祸得福，因为它鼓励程序员使用组合（composition）而不是继承（详见第 18 条），并且是不可变类型锁需要的（详见第 17 条）。</p><h1 id="静态工厂方法的第二个缺点是，程序员很难找到它们"><a href="#静态工厂方法的第二个缺点是，程序员很难找到它们" class="headerlink" title="静态工厂方法的第二个缺点是，程序员很难找到它们"></a>静态工厂方法的第二个缺点是，程序员很难找到它们</h1><p>它们不像构造方法那样在 API 文档中明确的标注出来。因此，对于提供了静态方法而不是构造器的类来说，想要查明如何实例化一个类是十分困难的。</p><p>通过关注类或者接口的文档中静态方法，并且遵守标准的命名习惯，也可以弥补这一劣势。下面是一些静态工厂方法的常用名称。以下清单这是列出了其中的一小部分：</p><p>from —— 类型转换方法，它接受单个参数并返回此类型的相应实例，例如：</p><pre><code>Date d = Date.from(instant);</code></pre><p>of —— 聚合方法，接受多个参数并返回该类型的实例，并把他们合并在一起，例如：</p><pre><code>Set faceCards = EnumSet.of(JACK, QUEEN, KING);</code></pre><p>valueOf —— from 和 to 更为详细的替代 方式，例如：</p><pre><code>BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);</code></pre><p>instance 或 getinstance —— 返回一个由其参数 (如果有的话) 描述的实例，但不能说它具有相同的值，例如：</p><pre><code>StackWalker luke = StackWalker.getInstance(options);</code></pre><p>create 或 newInstance —— 与 instance 或 getInstance 类似，除此之外该方法保证每次调用返回一个新的实例，例如：</p><pre><code>Object newArray = Array.newInstance(classObject, arrayLen);</code></pre><p>getType —— 与 getInstance 类似，但是在工厂方法处于不同的类中的时候使用。getType 中的 Type 是工厂方法返回的对象类型，例如：</p><pre><code>FileStore fs = Files.getFileStore(path);</code></pre><p>newType —— 与 newInstance 类似，但是在工厂方法处于不同的类中的时候使用。newType中的 Type 是工厂方法返回的对象类型，例如：</p><pre><code>BufferedReader br = Files.newBufferedReader(path);</code></pre><p>type —— getType 和 newType 简洁的替代方式，例如：</p><pre><code>List litany = Collections.list(legacyLitany);</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>静态工厂方法和公共构造方法都有它们的用途，并且了解它们的相对优点是值得的。通常，静态工厂更可取，因此避免在没有考虑静态工厂的情况下直接选择使用公共构造方法</p><p>总体来说，『考虑使用静态工厂方法代替构造器』这点，除了有名字、可以用子类等这些语法层面上的优势之外，更多的是在工程学上的意义，它实质上的最主要作用是：能够增大类的提供者对自己所提供的类的控制力。</p><p>作为一个开发者，当我们作为调用方，使用别人提供的类时，如果要使用 new 关键字来为其创建一个类实例，如果对类不是特别熟悉，那么一定是要特别慎重的 —— new 实在是太好用了，以致于它经常被滥用，随时随地的 new 是有很大风险的，除了可能导致性能、内存方面的问题外，也经常会使得代码结构变得混乱。</p><p>而当我们在作为类的提供方时，无法控制调用者的具体行为，但是我们可以尝试使用一些方法来增大自己对类的控制力，减少调用方犯错误的机会，这也是对代码更负责的具体体现。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】 <a href="https://www.diycode.cc/topics/1027" target="_blank" rel="noopener">https://www.diycode.cc/topics/1027</a><br>【2】 <a href="https://www.jianshu.com/p/eb30a388c5fc" target="_blank" rel="noopener">https://www.jianshu.com/p/eb30a388c5fc</a><br>【3】 <a href="https://juejin.im/post/5d6a0652f265da03df5f285d" target="_blank" rel="noopener">https://juejin.im/post/5d6a0652f265da03df5f285d</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;静态静态工厂方法&lt;/p&gt;
    
    </summary>
    
      <category term="2019年12月" scheme="http://yoursite.com/categories/2019%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Design Pattern，Java" scheme="http://yoursite.com/tags/Design-Pattern%EF%BC%8CJava/"/>
    
  </entry>
  
  <entry>
    <title>Effctive-Java阅读笔记I</title>
    <link href="http://yoursite.com/2019/12/30/Effctive-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0I/"/>
    <id>http://yoursite.com/2019/12/30/Effctive-Java阅读笔记I/</id>
    <published>2019-12-30T08:30:12.000Z</published>
    <updated>2020-01-16T08:48:02.082Z</updated>
    
    <content type="html"><![CDATA[<p>第二章阅读：创建和销毁对象：<br>01.考虑使用静态工厂方法替代构造方法<br>02.当构造方法参数过多时使用 builder 模式</p><a id="more"></a><p>写在开始的话，读了几章回过头来看，Effective-Java中文版翻译的诘屈聱牙，对于新手来说读起来很是吃力，建议先看标题和总结明白本章主旨，遇到晦涩之处直接看代码，动手写一遍。有耐心时可以和英文版做对照阅读。</p><h1 id="考虑使用静态工厂方法替代构造方法"><a href="#考虑使用静态工厂方法替代构造方法" class="headerlink" title="考虑使用静态工厂方法替代构造方法"></a>考虑使用静态工厂方法替代构造方法</h1><p>此处详见设计模式学习笔记III-静态工厂方法。</p><h1 id="当构造方法参数过多时使用-builder-模式"><a href="#当构造方法参数过多时使用-builder-模式" class="headerlink" title="当构造方法参数过多时使用 builder 模式"></a>当构造方法参数过多时使用 builder 模式</h1><p>静态工厂和构造方法都有一个限制：它们不能很好地扩展到很多可选参数的情景。传统上，程序员使用了可伸缩（telescoping constructor）构造方法模式。<br>在这种模式中，首先提供一个只有必需参数的构造方法，接着提供增加了一个可选参数的构造函数，然后提供增加了两个可选参数的构造函数，等等，最终在构造函数中包含所有必需和可选参数。以下就是它在实践中的样子。为了简便起见，只显示了四个可选属性：</p><pre><code>// Telescoping constructor pattern - does not scale well!public class NutritionFacts {    private final int servingSize;  // (mL)            required    private final int servings;     // (per container) required    private final int calories;     // (per serving)   optional    private final int fat;          // (g/serving)     optional    private final int sodium;       // (mg/serving)    optional    private final int carbohydrate; // (g/serving)     optional    public NutritionFacts(int servingSize, int servings) {        this(servingSize, servings, 0);    }    public NutritionFacts(int servingSize, int servings,            int calories) {        this(servingSize, servings, calories, 0);    }    public NutritionFacts(int servingSize, int servings,            int calories, int fat) {        this(servingSize, servings, calories, fat, 0);    }    public NutritionFacts(int servingSize, int servings,            int calories, int fat, int sodium) {        this(servingSize, servings, calories, fat, sodium, 0);    }    public NutritionFacts(int servingSize, int servings,           int calories, int fat, int sodium, int carbohydrate) {        this.servingSize  = servingSize;        this.servings     = servings;        this.calories     = calories;        this.fat          = fat;        this.sodium       = sodium;        this.carbohydrate = carbohydrate;    }}</code></pre><p>当想要创建一个实例时，可以使用包含所有要设置的参数的最短参数列表的构造方法：</p><pre><code>NutritionFacts cocaCola = new NutritionFacts(240, 8, 100, 0, 35, 27);</code></pre><p>通常情况下，这个构造方法的调用需要许多你不想设置的参数，但是你不得不为它们传递一个值。 在这种情况下，我们为 fat 属性传递了 0 值。「只有」六个参数可能看起来并不那么糟糕，但随着参数数量的增加，它很快就会失控。</p><p>　　简而言之，可伸缩构造方法模式是有效的，但是当有很多参数时，很难编写客户端代码，而且很难读懂它。</p><p>当在构造方法中遇到许多可选参数时，另一种选择是 JavaBeans 模式，在这种模式中，调用一个无参的构造方法来创建对象，然后调用 setter 方法来设置每个必需的参数和可选参数：</p><pre><code>// JavaBeans Pattern - allows inconsistency, mandates mutabilitypublic class NutritionFacts {// Parameters initialized to default values (if any)private int servingSize  = -1; // Required; no default valueprivate int servings     = -1; // Required; no default valueprivate int calories     = 0;private int fat          = 0;private int sodium       = 0;private int carbohydrate = 0;public NutritionFacts() { }// Setterspublic void setServingSize(int val)  { servingSize = val; }public void setServings(int val)    { servings = val; }public void setCalories(int val)    { calories = val; }public void setFat(int val)         { fat = val; }public void setSodium(int val)      { sodium = val; }public void setCarbohydrate(int val) { carbohydrate = val; }}</code></pre><p>这种模式没有伸缩构造方法模式的缺点。有点冗长，但创建实例很容易，并且易于阅读所生成的代码:</p><pre><code>NutritionFacts cocaCola = new NutritionFacts();cocaCola.setServingSize(240);cocaCola.setServings(8);cocaCola.setCalories(100);cocaCola.setSodium(35);cocaCola.setCarbohydrate(27);</code></pre><p>JavaBeans 模式本身有严重的缺陷。由于构造方法被分割成了多次调用，所以在构造过程中 JavaBean 可能处于不一致的状态。该类没有通过检查构造参数参数的有效性来强制一致性的选项。在不一致的状态下尝试使用对象可能会导致一些错误，这些错误与平常代码的BUG很是不同，因此很难调试。一个相关的缺点是，JavaBeans 模式排除了让类不可变的可能性（详见第 17 条），并且需要程序员增加工作以确保线程安全。</p><p>　　通过在对象构建完成时手动「冻结」对象，并且不允许它在解冻之前使用，可以减少这些缺点，但是这种变体在实践中很难使用并且很少使用。 而且，在运行时会导致错误，因为编译器无法确保程序员会在使用对象之前调用 freeze 方法。</p><p>　　幸运的是，还有第三种选择，它结合了可伸缩构造方法模式的安全性和 JavaBean 模式的可读性。 它是 Builder 模式（建造者模式）的一种形式。客户端不直接构造所需的对象，而是调用一个包含所有必需参数的构造方法 (或静态工厂)得到获得一个 builder 对象。以下是它在实践中的示例：</p><pre><code>// Builder Patternpublic class NutritionFacts {    private final int servingSize;    private final int servings;    private final int calories;    private final int fat;    private final int sodium;    private final int carbohydrate;    public static class Builder {        // Required parameters        private final int servingSize;        private final int servings;        // Optional parameters - initialized to default values        private int calories      = 0;        private int fat           = 0;        private int sodium        = 0;        private int carbohydrate  = 0;        public Builder(int servingSize, int servings) {            this.servingSize = servingSize;            this.servings    = servings;        }        public Builder calories(int val) {            calories = val;                  return this;        }        public Builder fat(int val) {           fat = val;                      return this;        }        public Builder sodium(int val) {           sodium = val;                   return this;        }        public Builder carbohydrate(int val) {           carbohydrate = val;             return this;        }        public NutritionFacts build() {            return new NutritionFacts(this);        }    }    private NutritionFacts(Builder builder) {        servingSize  = builder.servingSize;        servings     = builder.servings;        calories     = builder.calories;        fat          = builder.fat;        sodium       = builder.sodium;        carbohydrate = builder.carbohydrate;    }}</code></pre><p>然后，客户端调用 builder 对象的与 setter 相似方法来设置你想设置的可选参数。最后，客户端调用builder对象的一个无参的 build 方法来生成对象，该对象通常是不可变的。Builder 通常是它所构建的类的一个静态成员类（详见第 24 条）。<br>　　NutritionFacts 类是不可变的，所有的参数默认值都在一个地方。builder 的 setter 方法返回 builder 本身，这样就可以进行链式调用，从而生成一个流畅的 API。下面是客户端代码的示例：</p><pre><code>NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8).calories(100).sodium(35).carbohydrate(27).build();</code></pre><p>为了简洁起见，省略了有效性检查。 要尽快检测无效参数，检查 builder 的构造方法和方法中的参数有效性。 在 build 方法调用的构造方法中检查包含多个参数的不变性。为了确保这些不变性不受攻击，在从 builder 复制参数后对对象属性进行检查（详见第 50 条）。 如果检查失败，则抛出 IllegalArgumentException 异常（详见第 72 条），其详细消息指示哪些参数无效（详见第 75 条）。</p><p>Builder 模式非常适合类层次结构。 使用平行层次的 builder，每个builder嵌套在相应的类中。 抽象类有抽象的 builder；具体的类有具体的 builder。 例如，考虑代表各种比萨饼的根层次结构的抽象类：</p><pre><code>// Builder pattern for class hierarchiesimport java.util.EnumSet;import java.util.Objects;import java.util.Set;public abstract class Pizza {  //配料枚举：火腿，蘑菇，洋葱，辣椒，香肠    public enum Topping {HAM, MUSHROOM, ONION, PEPPER, SAUSAGE}    final Set&lt;Topping&gt; toppings;    abstract static class Builder&lt;T extends Builder&lt;T&gt;&gt; {        EnumSet&lt;Topping&gt; toppings = EnumSet.noneOf(Topping.class);        public T addTopping(Topping topping) {            toppings.add(Objects.requireNonNull(topping));            return self();        }        abstract Pizza build();        // Subclasses must override this method to return &quot;this&quot;        protected abstract T self();    }    Pizza(Builder&lt;?&gt; builder) {        toppings = builder.toppings.clone(); // See Item 50    }}</code></pre><p>请注意，Pizza.Builder 是一个带有递归类型参数（ recursive type parameter）（详见第 30 条）的泛型类型。 这与抽象的 self 方法一起，允许方法链在子类中正常工作，而不需要强制转换。 Java 缺乏自我类型的这种变通解决方法被称为模拟自我类型（simulated self-type）。</p><p>　　这里有两个具体的 Pizza 的子类，其中一个代表标准的纽约风格的披萨，另一个是半圆形烤乳酪馅饼。前者有一个所需的尺寸参数，而后者则允许指定酱汁是否应该在里面或在外面：</p><pre><code>import java.util.Objects;public class NyPizza extends Pizza {    public enum Size { SMALL, MEDIUM, LARGE }    private final Size size;    public static class Builder extends Pizza.Builder&lt;Builder&gt; {        private final Size size;        public Builder(Size size) {            this.size = Objects.requireNonNull(size);        }        @Override public NyPizza build() {            return new NyPizza(this);        }        @Override protected Builder self() {            return this;        }    }    private NyPizza(Builder builder) {        super(builder);        size = builder.size;    }}public class Calzone extends Pizza {    private final boolean sauceInside; //内部的酱料    public static class Builder extends Pizza.Builder&lt;Builder&gt; {        private boolean sauceInside = false; // Default        public Builder sauceInside() {            sauceInside = true;            return this;        }        @Override public Calzone build() {            return new Calzone(this);        }        @Override protected Builder self() {            return this;        }    }    private Calzone(Builder builder) {        super(builder);        sauceInside = builder.sauceInside;    }}</code></pre><p>请注意，每个子类 builder 中的 build 方法被声明为返回正确的子类：NyPizza.Builder 的 build 方法返回 NyPizza，而 Calzone.Builder 中的 build 方法返回 Calzone。 这种技术，其一个子类的方法被声明为返回在超类中声明的返回类型的子类型，称为协变返回类型（covariant return typing）。 它允许客户端使用这些 builder，而不需要强制转换。</p><p>　　这些「分层 builder（hierarchical builders）」的客户端代码基本上与简单的 NutritionFacts builder 的代码相同。为了简洁起见，下面显示的示例客户端代码假设枚举常量的静态导入：</p><pre><code>NyPizza pizza = new NyPizza.Builder(SMALL)        .addTopping(SAUSAGE).addTopping(ONION).build();Calzone calzone = new Calzone.Builder()        .addTopping(HAM).sauceInside().build();</code></pre><p>builder 对构造方法的一个微小的优势是，builder 可以有多个可变参数，因为每个参数都是在它自己的方法中指定的。或者，builder 可以将传递给多个调用的参数聚合到单个属性中，如前面的 addTopping 方法所演示的那样。</p><p>　　Builder 模式非常灵活。 单个 builder 可以重复使用来构建多个对象。 builder 的参数可以在构建方法的调用之间进行调整，以改变创建的对象。 builder 可以在创建对象时自动填充一些属性，例如每次创建对象时增加的序列号。</p><p>　　Builder 模式也有缺点。为了创建对象，首先必须创建它的 builder。虽然创建这个 builder 的成本在实践中不太可能被注意到，但在看中性能的场合下这可能就是一个问题。而且，builder 模式比伸缩构造方法模式更冗长，因此只有在有足够的参数时才值得使用它，比如四个或更多。但是请记住，你可能在以后会想要添加更多的参数。但是，如果你一开始是使用的构造方法或静态工厂，当类演化到参数数量失控的时候再转到Builder模式，过时的构造方法或静态工厂就会面临尴尬的处境。因此，通常最好从一开始就创建一个 builder。</p><p>　　总而言之，当设计类的构造方法或静态工厂的参数超过几个时，Builder 模式是一个不错的选择，特别是如果许多参数是可选的或相同类型的。builder模式客户端代码比使用伸缩构造方法（telescoping constructors）更容易读写，并且builder模式比 JavaBeans 更安全。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="https://sjsdfg.github.io/effective-java-3rd-chinese/#/" target="_blank" rel="noopener">https://sjsdfg.github.io/effective-java-3rd-chinese/#/</a><br>【2】<a href="https://lingcoder.github.io/OnJava8/#/" target="_blank" rel="noopener">https://lingcoder.github.io/OnJava8/#/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二章阅读：创建和销毁对象：&lt;br&gt;01.考虑使用静态工厂方法替代构造方法&lt;br&gt;02.当构造方法参数过多时使用 builder 模式&lt;/p&gt;
    
    </summary>
    
      <category term="2019年12月" scheme="http://yoursite.com/categories/2019%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
</feed>
