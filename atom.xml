<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-24T14:31:09.699Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>1116. 打印零与奇偶数</title>
    <link href="http://yoursite.com/2020/05/24/1116.%20%E6%89%93%E5%8D%B0%E9%9B%B6%E4%B8%8E%E5%A5%87%E5%81%B6%E6%95%B0/"/>
    <id>http://yoursite.com/2020/05/24/1116. 打印零与奇偶数/</id>
    <published>2020-05-24T14:01:12.000Z</published>
    <updated>2020-05-24T14:31:09.699Z</updated>
    
    <content type="html"><![CDATA[<p>按顺序交替调用三个线程</p><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>假设有这么一个类：</p><pre><code>class ZeroEvenOdd {  public ZeroEvenOdd(int n) { ... }      // 构造函数  public void zero(printNumber) { ... }  // 仅打印出 0  public void even(printNumber) { ... }  // 仅打印出 偶数  public void odd(printNumber) { ... }   // 仅打印出 奇数}</code></pre><p>相同的一个 ZeroEvenOdd 类实例将会传递给三个不同的线程：</p><pre><code>线程 A 将调用 zero()，它只输出 0 。线程 B 将调用 even()，它只输出偶数。线程 C 将调用 odd()，它只输出奇数。</code></pre><p>每个线程都有一个 printNumber 方法来输出一个整数。请修改给出的代码以输出整数序列 010203040506… ，其中序列的长度必须为 2n。</p><p>示例 1：</p><pre><code>输入：n = 2输出：&quot;0102&quot;说明：三条线程异步执行，其中一个调用 zero()，另一个线程调用 even()，最后一个线程调用odd()。正确的输出为 &quot;0102&quot;。</code></pre><p>示例 2：</p><pre><code>输入：n = 5输出：&quot;0102030405&quot;</code></pre><h1 id="方法一：信号量"><a href="#方法一：信号量" class="headerlink" title="方法一：信号量"></a>方法一：信号量</h1><p>由1115. 交替打印FooBar中的方法很容易想到<br>通过三个信号量来控制。</p><p>zero方法中的for表示要输出的0个次数，同时用来控制要唤醒偶数还是奇数方法</p><p>even方法用来输出偶数同时唤醒zero方法。</p><p>odd方法用来输出奇数同时唤醒zero方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.function.IntConsumer;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZeroEvenOdd</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    Semaphore zero = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">    Semaphore even = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    Semaphore odd = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZeroEvenOdd</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printNumber.accept(x) outputs "x", where x is an integer.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zero</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            zero.acquire();</span><br><span class="line">            printNumber.accept(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                odd.release();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                even.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">even</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i=i+<span class="number">2</span>) &#123;</span><br><span class="line">            even.acquire();</span><br><span class="line">            printNumber.accept(i);</span><br><span class="line">            zero.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">odd</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n ; i=i+<span class="number">2</span>) &#123;</span><br><span class="line">            odd.acquire();</span><br><span class="line">            printNumber.accept(i);</span><br><span class="line">            zero.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ZeroEvenOdd zeroEvenOdd = <span class="keyword">new</span> ZeroEvenOdd(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zeroEvenOdd.zero(System.out::print);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zeroEvenOdd.even(System.out::print);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zeroEvenOdd.odd(System.out::print);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法二：Lock"><a href="#方法二：Lock" class="headerlink" title="方法二：Lock"></a>方法二：Lock</h1><p>“凡是可以用信号量解决的问题，都可以用管程模型来解决”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZeroEvenOdd</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZeroEvenOdd</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Condition z = lock.newCondition();</span><br><span class="line">    Condition num = lock.newCondition();</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> zTurn = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> zIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zero</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;zIndex&lt;n;) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(!zTurn) &#123;</span><br><span class="line">        z.await();</span><br><span class="line">        &#125;</span><br><span class="line">        printNumber.accept(<span class="number">0</span>);</span><br><span class="line">        zTurn = <span class="keyword">false</span>;</span><br><span class="line">        num.signalAll();</span><br><span class="line">                zIndex++;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">even</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i+=<span class="number">2</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(zTurn || (zIndex&amp;<span class="number">1</span>)==<span class="number">1</span>) &#123;</span><br><span class="line">        num.await();</span><br><span class="line">        &#125;</span><br><span class="line">        printNumber.accept(i);</span><br><span class="line">        zTurn = <span class="keyword">true</span>;</span><br><span class="line">        z.signal();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">odd</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i+=<span class="number">2</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(zTurn || (zIndex&amp;<span class="number">1</span>)==<span class="number">0</span>) &#123;</span><br><span class="line">        num.await();</span><br><span class="line">        &#125;</span><br><span class="line">        printNumber.accept(i);</span><br><span class="line">        zTurn = <span class="keyword">true</span>;</span><br><span class="line">        z.signal();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法三：无锁"><a href="#方法三：无锁" class="headerlink" title="方法三：无锁"></a>方法三：无锁</h1><p>凡是用了锁的，都来试试可否变成无锁的（本机测试是可行的，但测评平台报超时）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZeroEvenOdd</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZeroEvenOdd</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> stage = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zero</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(stage&gt;<span class="number">0</span>);</span><br><span class="line">    printNumber.accept(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>((i&amp;<span class="number">1</span>)==<span class="number">0</span>) &#123;</span><br><span class="line">    stage = <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    stage = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">even</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i+=<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(stage!=<span class="number">2</span>);</span><br><span class="line">    printNumber.accept(i);</span><br><span class="line">    stage = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">odd</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i+=<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(stage!=<span class="number">1</span>);</span><br><span class="line">    printNumber.accept(i);</span><br><span class="line">    stage = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://leetcode-cn.com/problems/print-zero-even-odd/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/print-zero-even-odd/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;按顺序交替调用三个线程&lt;/p&gt;
    
    </summary>
    
      <category term="2020年5月" scheme="http://yoursite.com/categories/2020%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Concurrency" scheme="http://yoursite.com/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>1115. 交替打印FooBar</title>
    <link href="http://yoursite.com/2020/05/22/1115.%20%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0FooBar/"/>
    <id>http://yoursite.com/2020/05/22/1115. 交替打印FooBar/</id>
    <published>2020-05-22T14:32:12.000Z</published>
    <updated>2020-05-23T04:30:31.185Z</updated>
    
    <content type="html"><![CDATA[<p>两个不同的线程将会共用一个 FooBar 实例。其中一个线程将会调用 foo() 方法，另一个线程将会调用 bar() 方法.设计修改程序交替调用这两个方法。</p><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>我们提供一个类：</p><pre><code>class FooBar {  public void foo() {    for (int i = 0; i &lt; n; i++) {      print(&quot;foo&quot;);    }  }  public void bar() {    for (int i = 0; i &lt; n; i++) {      print(&quot;bar&quot;);    }  }}</code></pre><p>两个不同的线程将会共用一个 FooBar 实例。其中一个线程将会调用 foo() 方法，另一个线程将会调用 bar() 方法。</p><p>请设计修改程序，以确保 “foobar” 被输出 n 次。</p><p>示例 1:</p><pre><code>输入: n = 1输出: &quot;foobar&quot;解释: 这里有两个线程被异步启动。其中一个调用 foo() 方法, 另一个调用 bar() 方法，&quot;foobar&quot; 将被输出一次。</code></pre><p>示例 2:</p><pre><code>输入: n = 2输出: &quot;foobarfoobar&quot;解释: &quot;foobar&quot; 将被输出两次。</code></pre><h1 id="方案一：Semaphore"><a href="#方案一：Semaphore" class="headerlink" title="方案一：Semaphore"></a>方案一：Semaphore</h1><p>很容易想到这种类似红绿灯交替变换的情境，一开始尝试用两个AtomicBoolean值来控制两个方法轮流调用，但发现难以在循环情况下运行，因此考虑使用信号量：</p><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>为了防止出现因多个程序同时访问一个共享资源而引发的一系列问题，我们需要一种方法，它可以通过生成并使用令牌来授权，在任一时刻只能有一个执行线程访问代码的临界区域。临界区域是指执行数据更新的代码需要独占式地执行。而信号量就可以提供这样的一种访问机制，让一个临界区同一时间只有一个线程在访问它，也就是说信号量是用来调协进程对共享资源的访问的。</p><p>信号量是一个特殊的变量，程序对其访问都是原子操作，且只允许对它进行等待（即P(信号变量))和发送（即V(信号变量))信息操作。</p><p>最简单的信号量是只能取0和1的变量，这也是信号量最常见的一种形式，叫做二进制信号量。而可以取多个正整数的信号量被称为通用信号量。这里主要讨论二进制信号量。</p><h2 id="信号量的工作原理"><a href="#信号量的工作原理" class="headerlink" title="信号量的工作原理"></a>信号量的工作原理</h2><p>由于信号量只能进行两种操作等待和发送信号，即P(sv)和V(sv),他们的行为是这样的：</p><p>P(sv)：如果sv的值大于零，就给它减1；如果它的值为零，就挂起该进程的执行</p><p>V(sv)：如果有其他进程因等待sv而被挂起，就让它恢复运行，如果没有进程因等待sv而挂起，就给它加1.</p><p>举个例子，就是两个进程共享信号量sv，一旦其中一个进程执行了P(sv)操作，它将得到信号量，并可以进入临界区，使sv减1。</p><p>而第二个进程将被阻止进入临界区，因为当它试图执行P(sv)时，sv为0，它会被挂起以等待第一个进程离开临界区域并执行V(sv)释放信号量，这时第二个进程就可以恢复执行。</p><h2 id="Semaphore使用初探："><a href="#Semaphore使用初探：" class="headerlink" title="Semaphore使用初探："></a>Semaphore使用初探：</h2><p>Semaphore是用来保护一个或者多个共享资源的访问，Semaphore内部维护了一个计数器，其值为可以访问的共享资源的个数。一个线程要访问共享资源，先获得信号量，如果信号量的计数器值大于1，意味着有共享资源可以访问，则使其计数器值减去1，再访问共享资源。</p><p>如果计数器值为0,线程进入休眠。当某个线程使用完共享资源后，释放信号量，并将信号量内部的计数器加1，之前进入休眠的线程将被唤醒并再次试图获得信号量。</p><p>就好比一个图书馆管理员，站在门口，只有图书馆有空位，就开门允许与空位数量等量的人进入图书馆。多个人进入图书馆后，相当于N个人来分配使用N个空位。为避免多个人来同时竞争同一个空位，在内部仍然使用锁来控制资源的同步访问。</p><h3 id="Semaphore的使用："><a href="#Semaphore的使用：" class="headerlink" title="Semaphore的使用："></a>Semaphore的使用：</h3><p>Semaphore使用时需要先构建一个参数来指定共享资源的数量，Semaphore构造完成后即是获取Semaphore、共享资源使用完毕后释放Semaphore。</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooBar</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Semaphore foo = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);<span class="comment">//foo方法可以访问的共享资源为1</span></span><br><span class="line">    Semaphore bar = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);<span class="comment">//bar方法可以访问的共享资源为0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            foo.acquire();<span class="comment">//foo方法获得信号量，并将信号量内部的计数器减1，计数器值为0后,线程进入休眠。</span></span><br><span class="line">            printFoo.run();</span><br><span class="line">            bar.release();<span class="comment">//bar方法释放信号量，并将信号量内部的计数器加1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            bar.acquire();<span class="comment">//bar方法获得信号量，并将信号量内部的计数器减1，计数器值为0后,线程进入休眠。</span></span><br><span class="line">            printBar.run();</span><br><span class="line">            foo.release();<span class="comment">//foo方法释放信号量，并将信号量内部的计数器加1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方案二：Lock（公平锁）"><a href="#方案二：Lock（公平锁）" class="headerlink" title="方案二：Lock（公平锁）"></a>方案二：Lock（公平锁）</h1><h2 id="公平锁："><a href="#公平锁：" class="headerlink" title="公平锁："></a>公平锁：</h2><p>每个线程抢占锁的顺序为先后调用lock方法的顺序依次获取锁，类似于排队吃饭。</p><h2 id="非公平锁："><a href="#非公平锁：" class="headerlink" title="非公平锁："></a>非公平锁：</h2><p>每个线程抢占锁的顺序不定，谁运气好，谁就获取到锁，和调用lock方法的先后顺序无关</p><h2 id="ReentrantLock（可重入锁）及其优点"><a href="#ReentrantLock（可重入锁）及其优点" class="headerlink" title="ReentrantLock（可重入锁）及其优点"></a>ReentrantLock（可重入锁）及其优点</h2><p>java中已经有了内置锁：synchronized,synchronized的特点是使用简单，一切交给JVM去处理,不需要显示释放。</p><p>从用法上可以看出，与synchronized相比， ReentrantLock就稍微复杂一点。因为必须在finally中进行解锁操作，<br>如果不在 finally解锁，有可能代码出现异常锁没被释放，那么为什么要引入ReentrantLock呢？</p><p>在jdk1.5里面，ReentrantLock的性能是明显优于synchronized的，但是在jdk1.6里面，synchronized做了优化，他们之间的性能差别已经不明显了。</p><p>ReentrantLock并不是一种替代内置加锁的方法，而是作为一种可选择的高级功能。<br>相比于synchronized，ReentrantLock在功能上更加丰富，它具有可重入、可中断、可限时、公平锁等特点。</p><h3 id="可重入（其实synchronized-也是可重入的）"><a href="#可重入（其实synchronized-也是可重入的）" class="headerlink" title="可重入（其实synchronized 也是可重入的）"></a>可重入（其实synchronized 也是可重入的）</h3><pre><code>lock.lock();lock.lock();try{    i++;}           finally{    lock.unlock();    lock.unlock();}</code></pre><p>由于ReentrantLock是重入锁，所以可以反复得到相同的一把锁，它有一个与锁相关的获取计数器，如果拥有锁的某个线程再次得到锁，那么获取计数器就加1，然后锁需要被释放两次才能获得真正释放(重入锁)。</p><h3 id="可中断"><a href="#可中断" class="headerlink" title="可中断"></a>可中断</h3><p>与synchronized不同的是，ReentrantLock对中断是有响应的.synchronized一旦尝试获取锁就会一直等待直到获取到锁。<br>构造一个死锁的例子，然后用中断来处理死锁</p><p>此处示例见<a href="https://www.jianshu.com/p/155260c8af6c" target="_blank" rel="noopener">ReentrantLock的使用</a></p><h3 id="可限时"><a href="#可限时" class="headerlink" title="可限时"></a>可限时</h3><p>超时不能获得锁，就返回false，不会永久等待构成死锁</p><p>使用lock.tryLock(long timeout, TimeUnit unit)来实现可限时锁，参数为时间和单位。</p><h3 id="公平锁的使用方法"><a href="#公平锁的使用方法" class="headerlink" title="公平锁的使用方法"></a>公平锁的使用方法</h3><p>一般意义上的锁是不公平的，不一定先来的线程能先得到锁，后来的线程就后得到锁。不公平的锁可能会产生饥饿现象。</p><p>公平锁的意思就是，这个锁能保证线程是先来的先得到锁。虽然公平锁不会产生饥饿现象，但是公平锁的性能会比非公平锁差很多。</p><pre><code>public ReentrantLock(boolean fair) public static ReentrantLock fairLock = new ReentrantLock(true);</code></pre><h2 id="Volatile关键字"><a href="#Volatile关键字" class="headerlink" title="Volatile关键字"></a>Volatile关键字</h2><p>Java的volatile关键字用于标记一个变量“应当存储在主存”。更确切地说，每次读取volatile变量，都应该从主存读取，而不是从CPU缓存读取。每次写入一个volatile变量，应该写到主存中，而不是仅仅写到CPU缓存。</p><p>Java的volatile关键字能保证变量修改后，对各个线程是可见的。更多详细内容参见<a href="http://ifeve.com/java-volatile%e5%85%b3%e9%94%ae%e5%ad%97/" target="_blank" rel="noopener">Java Volatile关键字</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooBar</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> permitFoo = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(permitFoo) &#123;</span><br><span class="line">                printFoo.run();</span><br><span class="line">                    i++;</span><br><span class="line">                    permitFoo = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(!permitFoo) &#123;</span><br><span class="line">                printBar.run();</span><br><span class="line">                i++;</span><br><span class="line">                permitFoo = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此种方法可以跑通但是超时了。</p><h1 id="方案三：无锁"><a href="#方案三：无锁" class="headerlink" title="方案三：无锁"></a>方案三：无锁</h1><p>以上的公平锁方案完全可以改造成无锁方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooBar</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> permitFoo = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;     </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(permitFoo) &#123;</span><br><span class="line">        printFoo.run();</span><br><span class="line">            i++;</span><br><span class="line">            permitFoo = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;       </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!permitFoo) &#123;</span><br><span class="line">        printBar.run();</span><br><span class="line">        i++;</span><br><span class="line">        permitFoo = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此种方法可以跑通但是也超时了。</p><h1 id="方案四：CyclicBarrier"><a href="#方案四：CyclicBarrier" class="headerlink" title="方案四：CyclicBarrier"></a>方案四：CyclicBarrier</h1><p>字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用。我们暂且把这个状态就叫做barrier，当调用await()方法之后，线程就处于barrier了。</p><p>CyclicBarrier更适合用在循环场景中，那么我们来试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    CyclicBarrier cyclicBarrier= <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> fin = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooBar</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!fin);</span><br><span class="line">            <span class="comment">// printFoo.run() outputs "foo". Do not change or remove this line.</span></span><br><span class="line">            printFoo.run();</span><br><span class="line">            fin = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (BrokenBarrierException e)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (BrokenBarrierException e)&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// printBar.run() outputs "bar". Do not change or remove this line.</span></span><br><span class="line">                printBar.run();</span><br><span class="line">                fin = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法可以提交成功。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://leetcode-cn.com/problems/print-foobar-alternately/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/print-foobar-alternately/</a></p><p>【2】<a href="https://zhuanlan.zhihu.com/p/81626432" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/81626432</a></p><p>【3】<a href="https://blog.csdn.net/ljianhui/java/article/details/10243617" target="_blank" rel="noopener">https://blog.csdn.net/ljianhui/java/article/details/10243617</a></p><p>【4】<a href="https://blog.csdn.net/zbc1090549839/java/article/details/53389602" target="_blank" rel="noopener">https://blog.csdn.net/zbc1090549839/java/article/details/53389602</a></p><p>【5】<a href="https://www.jianshu.com/p/155260c8af6c" target="_blank" rel="noopener">https://www.jianshu.com/p/155260c8af6c</a></p><p>【6】<a href="http://ifeve.com/java-volatile%e5%85%b3%e9%94%ae%e5%ad%97/" target="_blank" rel="noopener">http://ifeve.com/java-volatile%e5%85%b3%e9%94%ae%e5%ad%97/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;两个不同的线程将会共用一个 FooBar 实例。其中一个线程将会调用 foo() 方法，另一个线程将会调用 bar() 方法.设计修改程序交替调用这两个方法。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年5月" scheme="http://yoursite.com/categories/2020%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Concurrency" scheme="http://yoursite.com/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程</title>
    <link href="http://yoursite.com/2020/05/21/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/05/21/Java并发编程/</id>
    <published>2020-05-21T14:20:12.000Z</published>
    <updated>2020-05-23T04:30:25.861Z</updated>
    
    <content type="html"><![CDATA[<p>介绍Java并发编程中的常用方法，如AtomicInteger，信号量Semaphore，这些方法的实现原理和源码值得深究。</p><a id="more"></a><h1 id="Java原子操作AtomicInteger"><a href="#Java原子操作AtomicInteger" class="headerlink" title="Java原子操作AtomicInteger"></a>Java原子操作AtomicInteger</h1><p>JDK1.5之后的java.util.concurrent.atomic包里，多了一批原子处理类。AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference。主要用于在高并发环境下的高效程序处理,来帮助我们简化同步处理.</p><p>AtomicInteger，一个提供原子操作的Integer的类。在Java语言中，++i和i++操作并不是线程安全的，在使用的时候，不可避免的会用到synchronized关键字。而AtomicInteger则通过一种线程安全的加减操作接口。</p><p>我们先来看看AtomicInteger给我们提供了什么接口:</p><pre><code>    public final int get() //获取当前的值public final int getAndSet(int newValue)//获取当前的值，并设置新的值public final int getAndIncrement()//获取当前的值，并自增public final int getAndDecrement() //获取当前的值，并自减public final int getAndAdd(int delta) //获取当前的值，并加上预期的值</code></pre><p>下面通过两个简单的例子来看一下 AtomicInteger 的优势在哪:</p><p>普通线程同步:</p><pre><code>class Test2 {        private volatile int count = 0;        public synchronized void increment() {                  count++; //若要线程安全执行执行count++，需要加锁        }        public int getCount() {                  return count;        }}</code></pre><p>使用AtomicInteger:</p><pre><code>class Test2 {        private AtomicInteger count = new AtomicInteger();        public void increment() {                  count.incrementAndGet();        }   //使用AtomicInteger之后，不需要加锁，也可以实现线程安全。       public int getCount() {                return count.get();        }}</code></pre><p>使用AtomicInteger是非常的安全的.而且因为AtomicInteger由硬件提供原子操作指令实现的。在非激烈竞争的情况下，开销更小，速度更快。</p><p>我们来看看AtomicInteger是如何使用非阻塞算法来实现并发控制的:<br>AtomicInteger的关键域只有一下3个：</p><pre><code>// setup to use Unsafe.compareAndSwapInt for updatesprivate static final Unsafe unsafe = Unsafe.getUnsafe();private static final long valueOffset;static {             try {                        valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField(&quot;value&quot;));           } catch (Exception ex) {                throw new Error(ex);         }    }private volatile int value;</code></pre><p>这里， unsafe是java提供的获得对对象内存地址访问的类，注释已经清楚的写出了，它的作用就是在更新操作时提供“比较并替换”的作用。实际上就是AtomicInteger中的一个工具。<br>valueOffset是用来记录value本身在内存的便宜地址的，这个记录，也主要是为了在更新操作在内存中找到value的位置，方便比较。<br>注意：value是用来存储整数的时间变量，这里被声明为volatile，就是为了保证在更新操作时，当前线程可以拿到value最新的值（并发环境下，value可能已经被其他线程更新了）。<br>这里，我们以自增的代码为例，可以看到这个并发控制的核心算法：</p><pre><code>/***Atomicallyincrementsbyonethecurrentvalue.**@returntheupdatedvalue*/publicfinalintincrementAndGet(){for(;;){    //这里可以拿到value的最新值    intcurrent=get();    intnext=current+1;if(compareAndSet(current,next))    returnnext;    }}publicfinalbooleancompareAndSet(intexpect,intupdate){//使用unsafe的native方法，实现高效的硬件级别CAS        returnunsafe.compareAndSwapInt(this,valueOffset,expect,update);}</code></pre><p>优点总结:<br>最大的好处就是可以避免多线程的优先级倒置和死锁情况的发生，提升在高并发处理下的性能。</p><h1 id="信号量Semaphore"><a href="#信号量Semaphore" class="headerlink" title="信号量Semaphore"></a>信号量Semaphore</h1><p>Semaphore也叫信号量，在JDK1.5被引入，可以用来控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用资源。</p><p>Semaphore内部维护了一组虚拟的许可，许可的数量可以通过构造函数的参数指定。</p><p>访问特定资源前，必须使用acquire方法获得许可，如果许可数量为0，该线程则一直阻塞，直到有可用许可。</p><p>访问资源后，使用release释放许可。</p><p>Semaphore和ReentrantLock类似，获取许可有公平策略和非公平许可策略，默认情况下使用非公平策略。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>Semaphore可以用来做流量分流，特别是对公共资源有限的场景，比如数据库连接。</p><p>假设有这个的需求，读取几万个文件的数据到数据库中，由于文件读取是IO密集型任务，可以启动几十个线程并发读取，但是数据库连接数只有10个，这时就必须控制最多只有10个线程能够拿到数据库连接进行操作。这个时候，就可以使用Semaphore做流量控制。</p><pre><code>public class SemaphoreTest {    private static final int COUNT = 40;    private static Executor executor = Executors.newFixedThreadPool(COUNT);    private static Semaphore semaphore = new Semaphore(10);    public static void main(String[] args) {        for (int i=0; i&lt; COUNT; i++) {            executor.execute(new ThreadTest.Task());        }    }    static class Task implements Runnable {        @Override        public void run() {            try {                //读取文件操作                semaphore.acquire();                // 存数据过程                semaphore.release();            } catch (InterruptedException e) {                e.printStackTrace();            } finally {            }        }    }}</code></pre><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>代码源于JDK1.8<br>Semaphore实现主要基于java同步器AQS，不熟悉的可以移步 <a href="https://www.jianshu.com/p/d8eeb31bee5c" target="_blank" rel="noopener">深入浅出java同步器</a>。</p><p>内部使用state表示许可数量。</p><h3 id="非公平策略"><a href="#非公平策略" class="headerlink" title="非公平策略"></a>非公平策略</h3><p>acquire实现，核心代码如下：</p><pre><code>final int nonfairTryAcquireShared(int acquires) {    for (;;) {        int available = getState();        int remaining = available - acquires;        if (remaining &lt; 0 ||            compareAndSetState(available, remaining))            return remaining;    }}</code></pre><p>acquires值默认为1，表示尝试获取1个许可，remaining代表剩余的许可数。</p><p>如果remaining &lt; 0，表示目前没有剩余的许可。</p><p>当前线程进入AQS中的doAcquireSharedInterruptibly方法等待可用许可并挂起，直到被唤醒。</p><p>release实现，核心代码如下：</p><pre><code>protected final boolean tryReleaseShared(int releases) {    for (;;) {        int current = getState();        int next = current + releases;        if (next &lt; current) // overflow            throw new Error(&quot;Maximum permit count exceeded&quot;);        if (compareAndSetState(current, next))            return true;    }}</code></pre><p>releases值默认为1，表示尝试释放1个许可，next代表如果许可释放成功，可用许可的数量。</p><p>通过unsafe.compareAndSwapInt修改state的值，确保同一时刻只有一个线程可以释放成功。</p><p>许可释放成功，当前线程进入到AQS的doReleaseShared方法，唤醒队列中等待许可的线程。</p><p>也许有人会有疑问，非公平性体现在哪里？</p><p>当一个线程A执行acquire方法时，会直接尝试获取许可，而不管同一时刻阻塞队列中是否有线程也在等待许可，如果恰好有线程C执行release释放许可，并唤醒阻塞队列中第一个等待的线程B，这个时候，线程A和线程B是共同竞争可用许可，不公平性就是这么体现出来的，线程A一点时间都没等待就和线程B同等对待。</p><h3 id="公平策略"><a href="#公平策略" class="headerlink" title="公平策略"></a>公平策略</h3><p>acquire实现，核心代码如下：</p><pre><code>protected int tryAcquireShared(int acquires) {    for (;;) {        if (hasQueuedPredecessors())            return -1;        int available = getState();        int remaining = available - acquires;        if (remaining &lt; 0 ||            compareAndSetState(available, remaining))            return remaining;    }}</code></pre><p>acquires值默认为1，表示尝试获取1个许可，remaining代表剩余的许可数。<br>可以看到和非公平策略相比，就多了一个对阻塞队列的检查。</p><p>如果阻塞队列没有等待的线程，则参与许可的竞争。<br>否则直接插入到阻塞队列尾节点并挂起，等待被唤醒。</p><p>release实现，和非公平策略一样。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="https://www.jianshu.com/p/509aca840f6d" target="_blank" rel="noopener">https://www.jianshu.com/p/509aca840f6d</a></p><p>【2】<a href="https://www.ibm.com/developerworks/cn/java/j-jtp11234/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-jtp11234/</a></p><p>【3】<a href="https://www.jianshu.com/p/0090341c6b80" target="_blank" rel="noopener">https://www.jianshu.com/p/0090341c6b80</a></p><p>【4】<a href="https://www.jianshu.com/p/d8eeb31bee5c" target="_blank" rel="noopener">https://www.jianshu.com/p/d8eeb31bee5c</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍Java并发编程中的常用方法，如AtomicInteger，信号量Semaphore，这些方法的实现原理和源码值得深究。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年5月" scheme="http://yoursite.com/categories/2020%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="Concurrency" scheme="http://yoursite.com/tags/Concurrency/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>1114.按序打印</title>
    <link href="http://yoursite.com/2020/05/21/1114.%E6%8C%89%E5%BA%8F%E6%89%93%E5%8D%B0/"/>
    <id>http://yoursite.com/2020/05/21/1114.按序打印/</id>
    <published>2020-05-21T12:56:12.000Z</published>
    <updated>2020-05-23T04:30:38.629Z</updated>
    
    <content type="html"><![CDATA[<p>请设计修改程序，以确保三个线程中的 two() 方法在 one() 方法之后被执行，three() 方法在 two() 方法之后被执行。</p><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>我们提供了一个类：</p><pre><code>public class Foo {  public void one() { print(&quot;one&quot;); }  public void two() { print(&quot;two&quot;); }  public void three() { print(&quot;three&quot;); }}</code></pre><p>三个不同的线程将会共用一个 Foo 实例。</p><pre><code>线程 A 将会调用 one() 方法线程 B 将会调用 two() 方法线程 C 将会调用 three() 方法</code></pre><p>请设计修改程序，以确保 two() 方法在 one() 方法之后被执行，three() 方法在 two() 方法之后被执行。</p><p>示例 1:</p><pre><code>输入: [1,2,3]输出: &quot;onetwothree&quot;</code></pre><p>解释: </p><p>有三个线程会被异步启动。<br>输入 [1,2,3] 表示线程 A 将会调用 one() 方法，线程 B 将会调用 two() 方法，线程 C 将会调用 three() 方法。<br>正确的输出是 “onetwothree”。<br>示例 2:</p><pre><code>输入: [1,3,2]输出: &quot;onetwothree&quot;</code></pre><p>解释: </p><p>输入 [1,3,2] 表示线程 A 将会调用 one() 方法，线程 B 将会调用 three() 方法，线程 C 将会调用 two() 方法。<br>正确的输出是 “onetwothree”。</p><p>注意:</p><p>尽管输入中的数字似乎暗示了顺序，但是我们并不保证线程在操作系统中的调度顺序。</p><p>你看到的输入格式主要是为了确保测试的全面性。</p><h1 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h1><p>来自<a href="https://baike.baidu.com/item/%E5%B9%B6%E5%8F%91%E8%AE%A1%E7%AE%97/9939802?fr=aladdin" target="_blank" rel="noopener">并发计算</a>的场景，该场景下，程序在多线程（或多进程）中 <em>同时</em> 执行。</p><p>同时进行并不是完全指进程或线程在不同的物理 CPU 上独立运行，更多情况下，是在一个物理 CPU 上交替执行多个线程或进程。<em>并发既可在线程中，也可在进程中。</em></p><p>并发主要为多任务情况设计。但如果应用不当，可能会引发一些漏洞。按照情况不同，可以分为三种：</p><ul><li><p><strong>竞态条件</strong>：由于多进程之间的竞争执行，导致程序未按照期望的顺序输出。</p></li><li><p><strong>死锁</strong>：并发程序等待一些必要资源，导致没有程序可以执行。</p></li><li><p><strong>资源不足</strong>：进程被永久剥夺了运行所需的资源。</p></li></ul><p>此题中存在竞态条件。下面展示一个竞态条件的例子。</p><p>假设有一个方法 <code>withdraw(amount)</code>，如果请求量小于当前余额，则从当前余额中减去请求量，然后返回余额。方法定义如下：</p><figure class="highlight python"><figcaption><span>[snippet1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">balance = <span class="number">500</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">withdraw</span><span class="params">(amount)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> (amount &lt; balance):</span><br><span class="line">        balance -= amount</span><br><span class="line">    <span class="keyword">return</span> balance</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[snippet1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> balance = <span class="number">500</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (amount &lt; balance) &#123;</span><br><span class="line">    balance -= amount;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> balance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们 <em>期望</em> 该方法执行后余额永远不会为负。</p><p>但是有可能出现竞态条件，使得余额变为负数。假设两个线程同时使用不同的参数执行该方法。例如：线程 1 执行 <code>withdraw(amount=400)</code>，线程 2 执行 <code>withdraw(amount=200)</code>。这两个线程的执行顺序如下图所示。在每个时刻只执行一条语句。</p><p><img src="https://pic.leetcode-cn.com/Figures/1114/1114_race_condition.png" alt="image"></p><p>上述流程执行结束后，余额变成负数，这并不是期望的输出。</p><h1 id="无竞争并发"><a href="#无竞争并发" class="headerlink" title="无竞争并发"></a>无竞争并发</h1><p>并发问题有一个共同特征：多个线程/进程之间共享一些资源（例如：余额）。由于无法消除资源共享的约束，防止并发问题就变成了 <strong>资源共享的协调</strong> 问题。</p><p>根据这个思路，如果可以确保程序中 <strong>关键部分代码的独占性</strong>（例如：检查和减少余额），就可以防止程序进入不一致的状态。</p><blockquote><p>竞争条件的解决方案为：需要某些关键部分代码具有排他性，即在给定的时间内，只有一个线程可以进入关键部分代码。</p></blockquote><p>可以将这种机制看做限制关键部分代码访问的锁。在前面示例的关键部分代码加锁，即检查余额和减少余额的语句。然后重新运行两个线程，会有下图的执行顺序：</p><p><img src="https://pic.leetcode-cn.com/Figures/1114/1114_lock.png" alt="image"></p><p>在该机制下，一旦一个线程进入关键部分，它就可以阻止其他线程进入该关键部分。例如，在时间点 3，<code>线程 2</code> 进入关键部分，那么在时间点 4，如果没有锁保护，<code>线程 1</code> 就可能进入关键部分。最后两个线程同时运行，保证系统的一致性，并确保余额正确。</p><p>如果该线程未被授权进入关键代码，可以认为该线程被阻塞或进入睡眠状态。例如，<code>线程 1</code> 在时间点 4 被阻塞，之后关键部分被释放，可以通知其他等待线程。<code>线程 2</code> 在时间点 5 释放了关键部分，就可以通知 <code>线程 1</code> 进入。</p><blockquote><p>这种机制还具有唤醒其他等待线程的功能。</p></blockquote><p>总之，为了防止出现并发竞争状态，需要一种具有两种功能的机制：1）关键部分的访问控制；2）通知阻塞线程。</p><h1 id="方法一：使用-synchronization"><a href="#方法一：使用-synchronization" class="headerlink" title="方法一：使用 synchronization"></a>方法一：使用 synchronization</h1><p><strong>思路</strong></p><p>题目要求按顺序依次执行三个方法，且每个方法都在单独的线程中运行。为了保证线程的执行顺序，可以在方法之间创建一些依赖关系，即第二个方法必须在第一个方法之后执行，第三个方法必须在第二个方法之后执行。</p><blockquote><p>方法对之间的依赖关系形成了所有方法的特定的执行顺序。例如 <code>A &lt; B</code>, <code>B &lt; C</code>，则所有方法的执行顺序为 <code>A &lt; B &lt; C</code>。</p></blockquote><p><img src="https://pic.leetcode-cn.com/Figures/1114/1114_partial_order.png" alt="image"></p><p>依赖关系可以通过并发机制实现。使用一个共享变量 <code>firstJobDone</code> 协调第一个方法与第二个方法的执行顺序，使用另一个共享变量 <code>secondJobDone</code> 协调第二个方法与第三个方法的执行顺序。</p><p><strong>算法</strong></p><ul><li><p>首先初始化共享变量 <code>firstJobDone</code> 和 <code>secondJobDone</code>，初始值表示所有方法未执行。</p></li><li><p>方法 <code>first()</code> 没有依赖关系，可以直接执行。在方法最后更新变量 <code>firstJobDone</code> 表示该方法执行完成。</p></li><li><p>方法 <code>second()</code> 中，检查 <code>firstJobDone</code> 的状态。如果未更新则进入等待状态，否则执行方法 <code>second()</code>。在方法末尾，更新变量 <code>secondJobDone</code> 表示方法 <code>second()</code> 执行完成。</p></li><li><p>方法 <code>third()</code> 中，检查 <code>secondJobDone</code> 的状态。与方法 <code>second()</code> 类似，执行 <code>third()</code> 之前，需要先等待 <code>secondJobDone</code> 的状态。</p></li></ul><p><img src="https://pic.leetcode-cn.com/Figures/1114/1114_flow.png" alt="image"></p><p><strong>实现</strong></p><p>上述算法的实现在很大程度上取决于选择的编程语言。尽管在 Java，C++ 和 Python 中都存在<a href="https://baike.baidu.com/item/%E4%BA%92%E6%96%A5%E4%BA%8B%E4%BB%B6/9980508?fr=aladdin" target="_blank" rel="noopener">互斥</a>与<a href="https://baike.baidu.com/item/%E4%BF%A1%E5%8F%B7%E9%87%8F/9807501?fr=aladdin" target="_blank" rel="noopener">信号量</a>，但不同语言对并发机制有不同实现。</p><figure class="highlight python"><figcaption><span>[solution1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.firstJobDone = Lock()</span><br><span class="line">        self.secondJobDone = Lock()</span><br><span class="line">        self.firstJobDone.acquire()</span><br><span class="line">        self.secondJobDone.acquire()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">first</span><span class="params">(self, printFirst: <span class="string">'Callable[[], None]'</span>)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="comment"># printFirst() outputs "first".</span></span><br><span class="line">        printFirst()</span><br><span class="line">        <span class="comment"># Notify the thread that is waiting for the first job to be done.</span></span><br><span class="line">        self.firstJobDone.release()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">second</span><span class="params">(self, printSecond: <span class="string">'Callable[[], None]'</span>)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="comment"># Wait for the first job to be done</span></span><br><span class="line">        <span class="keyword">with</span> self.firstJobDone:</span><br><span class="line">            <span class="comment"># printSecond() outputs "second".</span></span><br><span class="line">            printSecond()</span><br><span class="line">            <span class="comment"># Notify the thread that is waiting for the second job to be done.</span></span><br><span class="line">            self.secondJobDone.release()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">third</span><span class="params">(self, printThird: <span class="string">'Callable[[], None]'</span>)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Wait for the second job to be done.</span></span><br><span class="line">        <span class="keyword">with</span> self.secondJobDone:</span><br><span class="line">            <span class="comment"># printThird() outputs "third".</span></span><br><span class="line">            printThird()</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption><span>[solution1-Cpp]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">sem_t</span> firstJobDone;</span><br><span class="line">    <span class="keyword">sem_t</span> secondJobDone;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    Foo() &#123;</span><br><span class="line">        sem_init(&amp;firstJobDone, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        sem_init(&amp;secondJobDone, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void first(function&lt;void()&gt; printFirst) &#123;</span><br><span class="line">        <span class="comment">// printFirst() outputs "first".</span></span><br><span class="line">        printFirst();</span><br><span class="line">        sem_post(&amp;firstJobDone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void second(function&lt;void()&gt; printSecond) &#123;</span><br><span class="line">        sem_wait(&amp;firstJobDone);</span><br><span class="line">        <span class="comment">// printSecond() outputs "second".</span></span><br><span class="line">        printSecond();</span><br><span class="line">        sem_post(&amp;secondJobDone);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void third(function&lt;void()&gt; printThird) &#123;</span><br><span class="line">        sem_wait(&amp;secondJobDone);</span><br><span class="line">        <span class="comment">// printThird() outputs "third".</span></span><br><span class="line">        printThird();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> AtomicInteger firstJobDone = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">private</span> AtomicInteger secondJobDone = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">(Runnable printFirst)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// printFirst.run() outputs "first".</span></span><br><span class="line">    printFirst.run();</span><br><span class="line">    <span class="comment">// mark the first job as done, by increasing its count.</span></span><br><span class="line">    firstJobDone.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(Runnable printSecond)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (firstJobDone.get() != <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// waiting for the first job to be done.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printSecond.run() outputs "second".</span></span><br><span class="line">    printSecond.run();</span><br><span class="line">    <span class="comment">// mark the second as done, by increasing its count.</span></span><br><span class="line">    secondJobDone.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">third</span><span class="params">(Runnable printThird)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (secondJobDone.get() != <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// waiting for the second job to be done.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printThird.run() outputs "third".</span></span><br><span class="line">    printThird.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="扩展思考"><a href="#扩展思考" class="headerlink" title="扩展思考"></a>扩展思考</h1><p>按序打印中只使用一个AtomicInteger做共享变量会增加耗时，可以深入探究其中的原因。</p><h1 id="方法二：通过synchronized构造屏障"><a href="#方法二：通过synchronized构造屏障" class="headerlink" title="方法二：通过synchronized构造屏障"></a>方法二：通过synchronized构造屏障</h1><p>这是一个典型的执行屏障的问题，可以通过构造屏障来实现。</p><p>如下图，我们需要构造 <em>2</em> 道屏障，<code>second</code> 线程等待 <code>first</code> 屏障，<code>third</code> 线程等待 <code>second</code> 屏障。：</p><p><img src="https://pic.leetcode-cn.com/879c5abd22c2dbc2618a1433dfbeb02a34b9586a10425986fafdc90eef978cc1-image.png" alt="image"></p><p><code>first</code> 线程会释放 <code>first</code> 屏障，而 <code>second</code> 线程会释放 <code>second</code> 屏障。</p><p>Java 中，我们使用线程等待的方式实现执行屏障，使用释放线程等待的方式实现屏障消除。具体代码如下：</p><figure class="highlight java"><figcaption><span>[-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> firstFinished;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> secondFinished;</span><br><span class="line">    <span class="keyword">private</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">(Runnable printFirst)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// printFirst.run() outputs "first". Do not change or remove this line.</span></span><br><span class="line">            printFirst.run();</span><br><span class="line">            firstFinished = <span class="keyword">true</span>;</span><br><span class="line">            lock.notifyAll(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(Runnable printSecond)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!firstFinished) &#123;</span><br><span class="line">                lock.wait();</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// printSecond.run() outputs "second". Do not change or remove this line.</span></span><br><span class="line">            printSecond.run();</span><br><span class="line">            secondFinished = <span class="keyword">true</span>;</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">third</span><span class="params">(Runnable printThird)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">           <span class="keyword">while</span> (!secondFinished) &#123;</span><br><span class="line">                lock.wait();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printThird.run() outputs "third". Do not change or remove this line.</span></span><br><span class="line">            printThird.run();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="https://leetcode-cn.com/problems/print-in-order/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/print-in-order/</a></p><p>【2】<a href="https://baike.baidu.com/item/%E5%B9%B6%E5%8F%91%E8%AE%A1%E7%AE%97/9939802?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/%E5%B9%B6%E5%8F%91%E8%AE%A1%E7%AE%97/9939802?fr=aladdin</a></p><p>【3】<a href="https://leetcode-cn.com/problems/print-in-order/solution/an-xu-da-yin-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/print-in-order/solution/an-xu-da-yin-by-leetcode/</a></p><p>【4】<a href="https://www.jianshu.com/p/509aca840f6d" target="_blank" rel="noopener">https://www.jianshu.com/p/509aca840f6d</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;请设计修改程序，以确保三个线程中的 two() 方法在 one() 方法之后被执行，three() 方法在 two() 方法之后被执行。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年5月" scheme="http://yoursite.com/categories/2020%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Concurrency" scheme="http://yoursite.com/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>684.冗余链接</title>
    <link href="http://yoursite.com/2020/05/19/684.%E5%86%97%E4%BD%99%E9%93%BE%E6%8E%A5/"/>
    <id>http://yoursite.com/2020/05/19/684.冗余链接/</id>
    <published>2020-05-19T02:26:12.000Z</published>
    <updated>2020-05-19T15:51:25.460Z</updated>
    
    <content type="html"><![CDATA[<p>使用并查集找到一条可以删去的边。</p><a id="more"></a><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>在计算机科学中，并查集是一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题。有一个联合-查找算法（Union-find Algorithm）定义了两个用于此数据结构的操作：</p><p>Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。<br>Union：将两个子集合并成同一个集合。</p><p>由于支持这两种操作，一个不相交集也常被称为联合-查找数据结构（Union-find Data Structure）或合并-查找集合（Merge-find Set）。<br>为了更加精确的定义这些方法，需要定义如何表示集合。一种常用的策略是为每个集合选定一个固定的元素，称为代表，以表示整个集合。接着，Find(x) 返回 x 所属集合的代表，而 Union 使用两个集合的代表作为参数。</p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>本问题中, 树指的是一个连通且无环的无向图。</p><p>输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。</p><p>结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u &lt; v，表示连接顶点u 和v的无向图的边。</p><p>返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u &lt; v。</p><p>示例 1：</p><p>输入: [[1,2], [1,3], [2,3]]<br>输出: [2,3]<br>解释: 给定的无向图为:<br>  1<br> / <br>2 - 3<br>示例 2：</p><p>输入: [[1,2], [2,3], [3,4], [1,4], [1,5]]<br>输出: [1,4]<br>解释: 给定的无向图为:<br>5 - 1 - 2<br>    |   |<br>    4 - 3</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="方法一：DFS"><a href="#方法一：DFS" class="headerlink" title="方法一：DFS"></a>方法一：DFS</h2><p><strong>算法：</strong><br>对于每个边 <code>(u, v)</code>，用深度优先搜索遍历图，以查看是否可以将 <code>u</code> 连接到 <code>v</code>。如果可以，则它是重复边。</p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(N^2)*。其中 *N</em> 是图中的结点数（以及边数）。在最坏的情况下，对于我们包含的每一条边，我们必须搜索图中出现的每一条边。</li><li>空间复杂度：<em>O(N)*，图的当前构造最多有 *N</em> 个结点。</li></ul><h2 id="方法二：并查集"><a href="#方法二：并查集" class="headerlink" title="方法二：并查集"></a>方法二：并查集</h2><p><strong>算法：</strong><br>如果我们熟悉并查集（DSU）数据结构，我们可以直接使用它来解决这个问题：我们只需找到已经连接的图中出现的第一条边。本解释的其余部分将重点介绍实现 DSU 的细节。</p><p>一个 DSU 数据结构可以用来维护图形连接组件的数据，并快速查询它们。有两种操作：</p><ul><li><code>dsu.find(node x)</code>，找到元素 <code>x</code> 所在的集合的代表，该操作也可以用于判断两个元素是否位于同一个集合。</li><li><code>dsu.union(node x, node y)</code>，把元素 <code>x</code> 和元素 <code>y</code> 所在的集合合并，要求 <code>x</code>和 <code>y</code> 所在的集合不相交，如果相交则不合并。</li></ul><p>为了实现这一点，我们跟踪父结点，它会记录同一连接节点中较小结点的所在的集合。如果结点是它自己的父结点，我们将其称为连接结点的领导者。</p><p>DSU 结构的简单实现如下所示：<br>伪代码 ：<br>我们使用两种技术来提高运行时的复杂性：路径压缩和按秩合并。</p><ul><li>路径压缩涉及将 <code>find</code> 函数中的 <code>x=parent[x]</code> 更改为<code>parent[x]=find(parent[x])</code>。</li><li>按秩合并涉及到将发现的工作量平均分配给领导者。每当 <code>dsu.union(x, y)</code> 时，我们都有两个领导者 <code>xr，yr</code>，并且我们要选择是要 <code>parent[x]=yr</code> 还是 <code>parent[y]=xr</code>。我们选择有更多子节点的领导者作为领导者。</li><li>具体地说，<code>rank</code> 的含义是 <code>x</code> 的跟随者少于 <code>2 ^ rank[x]</code>，这个策略可以作为 <code>dsu.find</code> 中的递归循环可中的界限。</li></ul><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<img src="./p__O_Nalpha_N___approx_O_N__.png" alt="O(N\alpha(N))\approxO(N) "> 。其中， <em>N</em> 是图中顶点的数目（以及边的数目），<img src="./p__alpha_.png" alt="\alpha ">  是 <code>Inverse-Ackermann</code> 函数。我们对 <code>dsu.union</code> 进行了多达 <em>N</em> 次查询，这需要花费 <img src="./p__O_alpha_N___.png" alt="O(\alpha(N)) ">  时间。可以去查阅资料为什么 <code>dsu.union</code> 具有 <img src="./p__O_alpha_N___.png" alt="O(\alpha(N)) ">  复杂性、<code>Inverse-Ackermann</code> 函数是什么以及为什么 <img src="./p__O_alpha_N___.png" alt="O(\alpha(N)) ">  大约是 <em>O(1)</em> 的原因。</li><li>空间复杂度：<em>O(N)*，图的当前构造（嵌入在我们的 DSU 结构中）最多有 *N</em> 个结点。</li></ul><h1 id="并查集的实现"><a href="#并查集的实现" class="headerlink" title="并查集的实现"></a>并查集的实现</h1><h2 id="集合树："><a href="#集合树：" class="headerlink" title="集合树："></a>集合树：</h2><p>所有节点以代表节点为父节点构成的多叉树</p><h2 id="节点的代表节点："><a href="#节点的代表节点：" class="headerlink" title="节点的代表节点："></a>节点的代表节点：</h2><p>可以理解为节点的父节点，从当前节点出发，可以向上找到的第一个节点</p><h2 id="集合的代表节点："><a href="#集合的代表节点：" class="headerlink" title="集合的代表节点："></a>集合的代表节点：</h2><p>可以理解为根节点，意味着该集合内所有节点向上走，最终都能到达的节点</p><p>体到这个题上：<br>我们以这个边集合为例子[[1,2], [3,4], [3,2], [1,4], [1,5]]</p><p>一、首先，对于边集合edges的每个元素，我们将其看作两个节点集合</p><p>比如边[2, 3],我们将其看作节点集合2，和节点集合3</p><p>二、在没有添加边的时候，各个节点集合独立，我们需要初始化各个节点集合的代表节点为其自身</p><p>所以，我们先初始化一个容器vector，使得vector[i]=i。</p><p>这里两个i意思不同，作为索引的i是指当前节点，作为值的i是指当前节点所在集合的代表节点。</p><p>比如vector[2] = 2，意味着2这个节点所在集合的代表节点就是2，没有添加边的情况下，所有节点单独成集合，自身就是代表节点</p><p>三、然后我们开始遍历边集合，将边转化为集合的关系</p><p>这里有一点很重要：边[a,b]意味着a所在集合可以和b所在集合合并。</p><p>合并方法很多，这里我们简单地将a集合的代表节点戳到b集合的代表节点上。<br>这意味着，将b集合代表节点作为合并后大集合的代表节点。</p><p>对于一个集合的代表节点s，一定有s-&gt;s，意思是s如果是代表节点，那么它本身不存在代表节点</p><p>假设我们的读取顺序为[[1,2], [3,4], [3,2], [1,4], [1,5]]</p><p>初始化vector[0, 1, 2, 3, 4, 5]</p><p>对应的index [0, 1, 2, 3, 4, 5]</p><p>##########################################################################</p><p>1.读取[1,2]：</p><p>读取顺序为[[1,2], [3,4], [3,2], [1,4], [1,5]]</p><p>当前vector[0, 1, 2, 3, 4, 5]</p><p>当前index [0, 1, 2, 3, 4, 5]</p><p>原本1-&gt;1，2-&gt;2，</p><p>由1节点出发，vector[1]=1, 找到1所在集合的代表节点1</p><p>由2节点出发，vector[2]=2, 找到2所在集合的代表节点2</p><p>于是，将1的代表置为2，vector[1]=2, vector[2]=2</p><p>对应的vector[0, 2, 2, 3, 4, 5]</p><p>对应的index [0, 1, 2, 3, 4, 5]</p><p>##########################################################################</p><p>2.读取[3, 4]</p><p>读取顺序为[[1,2], [3,4], [3,2], [1,4], [1,5]]</p><p>当前vector[0, 2, 2, 3, 4, 5]</p><p>当前index [0, 1, 2, 3, 4, 5]</p><p>同理，将3所在集合的的代表节点3的代表节点置为4</p><p>对应的vector[0, 2, 2, 4, 4, 5]</p><p>对应的index [0, 1, 2, 3, 4, 5]</p><p>##########################################################################<br>3.读取[3, 2]</p><p>读取顺序为[[1,2], [3,4], [3,2], [1,4], [1,5]]</p><p>当前vector[0, 1, 2, 4, 4, 5]</p><p>当前index [0, 1, 2, 3, 4, 5]</p><p>从节点3出发，vector[3]=4, vector[4]=4,于是找到节点3所在集合的代表节点为4</p><p>从节点2出发，vector[2]=2, 找到节点2所在集合的代表节点为2</p><p>于是，将4的代表置为2，vector[4]=2, vector[2]=2</p><p>对应的vector[0, 2, 2, 4, 2, 5]</p><p>对应的index [0, 1, 2, 3, 4, 5]</p><p>##########################################################################<br>4.读取[1, 4]</p><p>读取顺序为[[1,2], [3,4], [3,2], [1,4], [1,5]]</p><p>当前vector[0, 2, 2, 4, 2, 5]</p><p>当前index [0, 1, 2, 3, 4, 5]</p><p>从节点1出发，vector[1]=2, vector[2]=2, 找到节点1所在集合代表节点为2</p><p>从节点4出发，vector[4]=2, vector[2]=2, 找到节点4所在集合代表节点为2</p><p>由于1和4的代表节点相同，说明这两个节点本身就在同一个集合中</p><p>由于原图是无向图，路径是双向可达的，1能够到达2,而且2能够到达4，再加上1能够到达4</p><p>说明1能通过两条路径到达4，,这也意味着这条边出现的时候，原图中一定出现了环</p><p>至于题中要求的，返回最后一条边，其实这就是返回添加过后会构成环的那一条边<br>直白解释就是，在这条边出现之前，图中没有环</p><p>这条边出现，图中也出现环。包括这条边在内，构成环的边都是满足破圈条件的边<br>然而谁是最后一条出现在边集合里的？当然，就是这条构成环的最后一条边<br>##########################################################################</p><pre><code>class Solution {public:    vector&lt;int&gt; findRedundantConnection(vector&lt;vector&lt;int&gt;&gt;&amp; edges) {        vector&lt;int&gt; rp(1001);        int sz = edges.size();        // 初始化各元素为单独的集合，代表节点就是其本身        for(int i=0;i&lt;sz;i++)            rp[i] = i;        for(int j=0;j&lt;sz;j++){            // 找到边上两个节点所在集合的代表节点            int set1 = find(edges[j][0], rp);            int set2 = find(edges[j][1], rp);            if(set1 == set2)  // 两个集合代表节点相同，说明出现环，返回答案                return edges[j];            else    // 两个集合独立，合并集合。将前一个集合代表节点戳到后一个集合代表节点上                rp[set1] = set2;        }        return {0, 0};    }    // 查找路径并返回代表节点，实际上就是给定当前节点，返回该节点所在集合的代表节点    // 之前这里写的压缩路径，引起歧义，因为结果没更新到vector里，所以这里改成路径查找比较合适    int find(int n, vector&lt;int&gt; &amp;rp){        int num = n;        while(rp[num] != num)            num = rp[num];        return num;    }};</code></pre><h1 id="Java实现并查集"><a href="#Java实现并查集" class="headerlink" title="Java实现并查集"></a>Java实现并查集</h1><p>对于同一棵树的所有节点来说，都拥有共同的祖先节点。</p><p>因此，判断冗余连接的条件即为，判断新加入的边，两个节点是否有共同的祖先。</p><p>（1）如果有共同的祖先，则说明这条边是冗余的边；</p><p>（2）如果没有共同的祖先，则说明这两条边并未加入树中，因此进行合并操作。<br>循环边的记录，获取最后出现的冗余边，就是答案。</p><pre><code>public static class UnionFind {    int[] parent;    int[] rank;    public UnionFind(int total) {        parent = new int[total];        rank = new int[total];        for (int i = 0; i &lt; total; i++) {            parent[i] = i;            rank[i] = 1;        }    }    public int find(int x) {        while (x != parent[x]) {            parent[x] = parent[parent[x]];            x = parent[x];        }        return x;    }    public void unionElements(int p, int q) {        int pRoot = find(p);        int qRoot = find(q);        if (pRoot == qRoot) {            return;        }        if (rank[pRoot] &lt; rank[qRoot]) {            parent[pRoot] = qRoot;        } else if (rank[pRoot] &gt; rank[qRoot]) {            parent[qRoot] = pRoot;        } else {            parent[pRoot] = qRoot;            rank[qRoot] += 1;        }    }}public int[] findRedundantConnection(int[][] edges) {    int[] res = new int[2];    UnionFind unionFind = new UnionFind(edges.length);    // 第一条边肯定未记录至树中，可直接合并节点    unionFind.unionElements(edges[0][0] - 1, edges[0][1] - 1);    for (int i = 1; i &lt; edges.length; i++) {        if (unionFind.find(edges[i][0] - 1) == unionFind.find(edges[i][1] - 1)) {            res[0] = edges[i][0];            res[1] = edges[i][1];        } else {            unionFind.unionElements(edges[i][0] - 1, edges[i][1] - 1);        }    }    return res;}</code></pre><h1 id="Map实现并查集（Java）"><a href="#Map实现并查集（Java）" class="headerlink" title="Map实现并查集（Java）"></a>Map实现并查集（Java）</h1><p>逻辑很简单，对每一条边：<br>1、如果两个顶点在不同的树上，则合并两个树<br>2、如果两个顶点在相同的树上，那么他们一定构成了闭环</p><p>为了提升效率，getRoot(并查集中的find)方法中对树进行了压缩</p><pre><code>class Solution {public int[] findRedundantConnection(int[][] edges) {    Map&lt;Integer, Integer&gt; cMap = new HashMap&lt;&gt;();    for (int i = 0; i &lt; edges.length; i++) {        int pi0 = getRoot(cMap, edges[i][0]);        int pi1 = getRoot(cMap, edges[i][1]);        if(pi0 != pi1){            cMap.put(pi0,pi1);        } else {            return edges[i];        }    }    return null;}private int getRoot(Map&lt;Integer, Integer&gt; parents, int i){    if(parents.get(i) == null){        parents.put(i, i);        return i;    }    if(parents.get(i) == i){        return i;    }    return getRoot(parents,parents.get(i));}}</code></pre><h1 id="证明-：给定一条新的边，两头节点在同一个集合，就意味着出现了环"><a href="#证明-：给定一条新的边，两头节点在同一个集合，就意味着出现了环" class="headerlink" title="证明    ：给定一条新的边，两头节点在同一个集合，就意味着出现了环"></a>证明    ：给定一条新的边，两头节点在同一个集合，就意味着出现了环</h1><p>#####################################################################<br>下面是增加的一部分证明，</p><p>证明一下为什么给定一条新的边，两头节点在同一个集合，就意味着出现了环</p><p>这里有个大前提，因为是无向图，集合里不会同时出现[1,2]和[2,1]这种重合边</p><p>上面的代码遇到集合里有重合边的情况是会出现误判的</p><p>就拿这个[1,2]和[2,1]来举例</p><p>给定[1,2]后，再读取[2,1]，两个节点在同一个集合，然而并没有出现环。</p><p>所以，这里代码工作的前提是不出现重合边<br>#####################################################################</p><p>下面回到最初的问题，为什么给定新边的两个节点在同一集合就意味着出现了环</p><p>假设给定新边的两个节点分别为5,6，新边为[5,6]</p><p>对于一条新出现的边，总共有两种情况，两个节点之一单独成集合，两个节点均不单独成集合</p><p>第一种情况，两个节点之一单独成集合</p><p>假设5单独成集合。这种情况下，两个节点不可能在一个集合里</p><p>因为有一个独立集合（只有节点5），6所在的集合和这个集合必然没有交集</p><p>之后这两个集合进行合并操作</p><p>直观点理解就是，5单独成集合，意味着5第一次出现在图里</p><p>这里只有新边和5相关，所以当前只给定一条和5相关的边，对5而言，就像只举起了一只手</p><p>要形成环，环上每个节点都必须是举起两只手的</p><p>所以这种情况下是不可能出现环的，程序中也是这样判定的</p><p>第二种情况，两个节点均不单独成集合</p><p>这里也可以细分为5和6是否作为该集合的代表节点</p><p>假设5所在集合代表节点为a</p><p>6所在集合代表节点也为a</p><p>2.1第一个分支，如果a不为5和6本身，那么就有5-&gt;…-&gt;a，6-&gt;…-&gt;a，路径双向可达</p><p>可以得到5-&gt;…-&gt;a-&gt;…-&gt;6,对于给定边[5,6]可得5-&gt;6</p><p>所以5到达6有两条路径，出现了环。</p><p>2.2第二个分支，a为5和6之一</p><p>假设，a为5</p><p>2.2.1 首先考虑，6直接指向5这种情况</p><p>出现这种情况，只能是在已经存在集合x-&gt;…-&gt;6时，出现[…,5]这样的边</p><p>其中，…为x-&gt;…-&gt;6路径上除6以外任意节点</p><p>此时…的代表节点为6，5的代表节点为5，合并，6戳到5上，于是出现了6直接指向5</p><p>这种情况下，已经存在6-&gt;…-&gt;5一条路径，再读取到[5,6]，环出现了</p><p>2.2.2 再考虑6不直接指向5的情况，就简单很多了，6-&gt;x-&gt;5</p><p>再读取到[5,6]，6可以通过两条路径到达5，出现环</p><p>综上，在边集合没有重合边的情况下，如果给定新边的两个节点在同一集合中，说明图中出现了环</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://leetcode-cn.com/problems/redundant-connection/solution/tong-su-jiang-jie-bing-cha-ji-bang-zhu-xiao-bai-ku/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/redundant-connection/solution/tong-su-jiang-jie-bing-cha-ji-bang-zhu-xiao-bai-ku/</a></p><p>【2】<a href="https://leetcode-cn.com/problems/redundant-connection/solution/bing-cha-ji-jie-jue-rong-yu-lian-jie-i-by-jxd134/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/redundant-connection/solution/bing-cha-ji-jie-jue-rong-yu-lian-jie-i-by-jxd134/</a></p><p>【3】<a href="https://leetcode-cn.com/problems/redundant-connection/solution/bing-cha-ji-mapshi-xian-de-ling-lei-bing-cha-ji-by/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/redundant-connection/solution/bing-cha-ji-mapshi-xian-de-ling-lei-bing-cha-ji-by/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用并查集找到一条可以删去的边。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年5月" scheme="http://yoursite.com/categories/2020%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Union Find" scheme="http://yoursite.com/tags/Union-Find/"/>
    
      <category term="Graph" scheme="http://yoursite.com/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>Lombok的基本注解使用</title>
    <link href="http://yoursite.com/2020/05/18/Lombok%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/05/18/Lombok的基本注解使用/</id>
    <published>2020-05-18T14:05:12.000Z</published>
    <updated>2020-05-18T16:13:03.842Z</updated>
    
    <content type="html"><![CDATA[<p>学习使用Lombok的基本注解：@Data，@AllArgsConstructor，@NoArgsConstructor，@Builder</p><a id="more"></a><p>Lombok 是一种 Java™ 实用工具，可用来帮助开发人员消除 Java 的冗长，尤其是对于简单的 Java 对象（POJO）。它通过注解实现这一目的。</p><h1 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h1><p>在 pom.xml 文件中添加相关依赖：</p><pre><code>&lt;lombok.version&gt;1.16.20&lt;/lombok.version&gt;&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;version&gt;${lombok.version}&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;</code></pre><h1 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h1><p>由于 Lombok 采取的注解形式的，在编译后，自动生成相应的方法，需要下载插件来支持它。<br>以 IDEA 为例：查找插件 lombok plugin 安装即可。</p><p>以 User 实体类为例（set,get,toString 方法），</p><p>拿lombok官网的一个例子来说:</p><pre><code>public class Mountain{    private String name;    private double longitude;    private String country;}</code></pre><p>要使用这个对象,必须还要写一些getter和setter方法,可能还要写一个构造器、equals方法、或者hash方法.这些方法很冗长而且没有技术含量,我们叫它样板式代码.<br>lombok的主要作用是通过一些注解，消除样板式代码，像这样：</p><pre><code>@Datapublic class Mountain{    private String name;    private double longitude;    private String country;}</code></pre><p>然后这个类自动生成了这些方法.</p><h1 id="Data-生成getter-setter等函数"><a href="#Data-生成getter-setter等函数" class="headerlink" title="@Data 生成getter,setter等函数"></a>@Data 生成getter,setter等函数</h1><p>使用这个注解，就不用再去手写Getter,Setter,equals,canEqual,hasCode,toString等方法了，注解后在编译时会自动加进去。@Data 包含了 @ToString、@EqualsAndHashCode、@Getter / @Setter和@RequiredArgsConstructor的功能.</p><h1 id="AllArgsConstructor-生成全参数构造函数"><a href="#AllArgsConstructor-生成全参数构造函数" class="headerlink" title="@AllArgsConstructor 生成全参数构造函数"></a>@AllArgsConstructor 生成全参数构造函数</h1><p>使用后添加一个构造函数，该构造函数含有所有已声明字段属性参数</p><h1 id="NoArgsConstructor-生成全参数构造函数"><a href="#NoArgsConstructor-生成全参数构造函数" class="headerlink" title="@NoArgsConstructor 生成全参数构造函数"></a>@NoArgsConstructor 生成全参数构造函数</h1><p>使用后创建一个无参构造函数,即没有参数的构造函数。</p><h1 id="Builder"><a href="#Builder" class="headerlink" title="@Builder"></a>@Builder</h1><p>关于Builder较为复杂一些，Builder的作用之一是为了解决在某个类有很多构造函数的情况，也省去写很多构造函数的麻烦，在设计模式中的思想是：用一个内部类去实例化一个对象，避免一个类出现过多构造函数，</p><p>举一个例子：</p><pre><code>import lombok.*;@Data //生成getter,setter等函数@AllArgsConstructor //生成全参数构造函数@NoArgsConstructor//生成无参构造函数@Builderpublic class User {    private String name;    private String age;    private String sex;}</code></pre><p>我们来为User类赋值并打印一下结果：</p><pre><code>public static void main(String[] args) {      User userAllArgs = new User(&quot;27&quot;, &quot;yiye&quot;, &quot;male&quot;);//有全参数构造函数可如此赋值      User userNoArgs = new User();//有无参构造函数时可以如此使用      userNoArgs = User.builder().age(&quot;26&quot;).name(&quot;yezi&quot;).sex(&quot;male&quot;).build();//有      System.out.println(&quot;userAllArgs:&quot; + userAllArgs);      System.out.println(&quot;userNoArgs:&quot; + userNoArgs);  }</code></pre><p>打印结果是：</p><pre><code>userAllArgs:User(name=27, age=yiye, sex=male)userNoArgs:User(name=yezi, age=26, sex=male)</code></pre><h1 id="无参构造函数失效的情况"><a href="#无参构造函数失效的情况" class="headerlink" title="无参构造函数失效的情况"></a>无参构造函数失效的情况</h1><p><strong><em>注意的是，同时使用@Data 和 @AllArgsConstructor 后 ，默认的无参构造函数失效，如果需要它，要重新设置 @NoArgsConstructor</em></strong><br>这里我们要回顾一下Java中无参构造函数的相关知识：</p><ol><li><p>如果一个类没有定义任何构造函数，那么该类会自动生成1个默认的构造函数。默认构造函数没有参数。</p></li><li><p>如果一个类定义了构造函数，但这些构造函数都有参数，那么不会生成默认构造函数，也就是说此时类没有无参的构造函数。</p></li></ol><p>这种错误会出现在一些场合，例如我们定义一个DTO</p><pre><code>@Data@AllArgsConstructorpublic class TemplateInfoResponseDTO {    private String code;    private String msg;    private Boolean success;    private String data;}</code></pre><p>然后通过向某个已提供的接口发送post请求，然后将接收到的结果解析为TemplateInfoResponseDTO，</p><pre><code>String response = httpRequestHelper.sendPostWithLongWaitTime(BaseUrl + GETTEMPLATEINFO_URL, JSON.toJSONString(templateInfo));        TemplateInfoResponseDTO templateInfoResponseDTO = JSON.parseObject(response, TemplateInfoResponseDTO.class);</code></pre><p>但是返回的了错误信息是</p><pre><code>set property error, TemplateInfoResultVO#data，</code></pre><p>查看该接口平台的日志可以看到，</p><pre><code>com.alibaba.fastjson.JSONException:default constructor not found. class ...... TemplateInfoResponseDTO</code></pre><p>说明TemplateInfoResponseDTO 没有默认的无参构造函数，所以string 转 object 失败了，因为同时使用@Data 和 @AllArgsConstructor 后 ，默认的无参构造函数失效，要么再加上@NoArgsConstructor注解，要么删除@AllArgsConstructor。</p><h1 id="Builder支持默认值"><a href="#Builder支持默认值" class="headerlink" title="@Builder支持默认值"></a>@Builder支持默认值</h1><p>Lombok 使用 Builder 的时候，需要在默认值的部分加上 @Default 注解，否则默认值是无效的<br>例如我们给User的属性赋予默认值</p><pre><code>@Data //生成getter,setter等函数@AllArgsConstructor //生成全参数构造函数@NoArgsConstructor//生成无参构造函数@Builderpublic class User {    private String name = &quot;yiye&quot;;    private String age = &quot;18&quot;;    private String sex = &quot;male&quot;;}</code></pre><p>然后打印出来：</p><pre><code>public static void main(String[] args) {      User userAllArgs = User.builder().build();      System.out.println(&quot;userAllArgs:&quot; + userAllArgs);      User userNoArgs = new User();      System.out.println(&quot;userNoArgs:&quot; + userNoArgs);  }</code></pre><p>打印结果：</p><pre><code>userAllArgs:User(name=null, age=null, sex=null)userNoArgs:User(name=yiye, age=18, sex=male)</code></pre><p>可见@Builder默认是不支持默认值设置，或者说，自动忽略了User里面设置的默认值。<br>在有默认值的属性上使用这个注解：@Builder.Default</p><pre><code>@Data //生成getter,setter等函数@AllArgsConstructor //生成全参数构造函数@NoArgsConstructor//生成无参构造函数@Builderpublic class User {    @Builder.Default    private String name = &quot;yiye&quot;;    @Builder.Default    private String age = &quot;18&quot;;    @Builder.Default    private String sex = &quot;male&quot;;}</code></pre><p>再看打印的结果：</p><pre><code>userAllArgs:User(name=yiye, age=18, sex=male)userNoArgs:User(name=null, age=null, sex=null)</code></pre><p>发现此时@Builder支持了默认值的设置，但是直接用无参构造的方法new User()出来的对象没有了默认值，这是需要注意的一点。</p><p>Lombok更多的注解使用方法参见参考资料【1】，另外可以在IDEA的target/classes文件夹中查看编译后的class文件，看加了注解后的实体编译后自动生成了哪些方法。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://www.jianshu.com/p/365ea41b3573" target="_blank" rel="noopener">https://www.jianshu.com/p/365ea41b3573</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习使用Lombok的基本注解：@Data，@AllArgsConstructor，@NoArgsConstructor，@Builder&lt;/p&gt;
    
    </summary>
    
      <category term="2020年5月" scheme="http://yoursite.com/categories/2020%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>后端开发常用调试技巧集锦</title>
    <link href="http://yoursite.com/2020/05/18/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7%E9%9B%86%E9%94%A6/"/>
    <id>http://yoursite.com/2020/05/18/后端开发常用调试技巧集锦/</id>
    <published>2020-05-18T09:24:12.000Z</published>
    <updated>2020-05-23T04:30:19.348Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下容易被忽略的后端开发中常用的调试技巧，主要包括IDEA中的常用快捷键和调试方法，<br>使用Charles，Postman，浏览器，命令行调试的常见技巧。</p><a id="more"></a><h1 id="IntelliJ-IDEA的常用调试技巧："><a href="#IntelliJ-IDEA的常用调试技巧：" class="headerlink" title="IntelliJ IDEA的常用调试技巧："></a>IntelliJ IDEA的常用调试技巧：</h1><h2 id="Mac中的常用快捷键"><a href="#Mac中的常用快捷键" class="headerlink" title="Mac中的常用快捷键"></a>Mac中的常用快捷键</h2><pre><code>Ctrl+A：到行首（达到Home键的效果）Ctrl+E：到行尾（达到End键的效果）Ctrl+N：到下一行Ctrl+P：到上一行Ctrl+K：从光标处开始删除，直到行尾</code></pre><p>更多的参见<a href="https://www.jianshu.com/p/87581b2c570c" target="_blank" rel="noopener">Mac终端快捷键</a></p><h2 id="IDEA中的常用快捷键"><a href="#IDEA中的常用快捷键" class="headerlink" title="IDEA中的常用快捷键"></a>IDEA中的常用快捷键</h2><p>这里仅记录一些易被忽略的常用快捷键，更多的快捷键参见<a href="https://www.jianshu.com/p/b8c13ca3154a" target="_blank" rel="noopener">IDEA Mac 快捷键</a>：<br>Mac键盘符号和修饰键说明</p><pre><code>⌘ Command⇧ Shift⌥ Option⌃ Control↩︎ Return/Enter⌫ Delete⌦ 向前删除键（Fn+Delete）↑ 上箭头↓ 下箭头← 左箭头→ 右箭头⇞ Page Up（Fn+↑）⇟ Page Down（Fn+↓）Home Fn + ←</code></pre><h3 id="Editing（编辑"><a href="#Editing（编辑" class="headerlink" title="Editing（编辑)"></a>Editing（编辑)</h3><pre><code>⌘N, ⌃↩, ⌃N 生成代码（getter、setter、构造函数、hashCode/equals,toString）⌘⌥T 包围代码（使用if..else, try..catch, for, synchronized等包围选中的代码）⌘⌥L 格式化代码⌃⌥O 优化import⌃⇧J 智能的将代码拼接成一行⌘↩ 智能的拆分拼接的行⇧↩ 开始新的一行⌘⇧+ 展开所以代码块⌘⇧- 折叠所有代码块⌘ + Y/X    删除行⌘ + D    复制行</code></pre><h3 id="Navigation（导航）"><a href="#Navigation（导航）" class="headerlink" title="Navigation（导航）"></a>Navigation（导航）</h3><pre><code>双击shift或⌘O  查找类文件⌘⌥← / ⌘⌥→ 退回 / 前进到上一个操作的地方⌘⇧⌫ 跳转到最后一个编辑的地方</code></pre><h2 id="函数重构抽取函数"><a href="#函数重构抽取函数" class="headerlink" title="函数重构抽取函数"></a>函数重构抽取函数</h2><pre><code>右键-》refactor-》Extract-》Method</code></pre><h2 id="抛异常快捷键"><a href="#抛异常快捷键" class="headerlink" title="抛异常快捷键"></a>抛异常快捷键</h2><pre><code>Code-&gt;Surround With</code></pre><h2 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h2><pre><code>fori    生成循环sout    System.out.println();⌘ + J    可以查看所有代码模板⌘ + ⌥ + J    用动态模板环绕⌘ + ⇧ + Enter    自动补全末尾的字符（括号，分号），例如敲完if/for时也可以自动补上{}花括号。⌥ + Enter    导入包，快速修复</code></pre><p>在项目中写好的接口下输入psvm按Tab即可自动展示出</p><pre><code>public static void main(String[] args) {}</code></pre><p>可以实时在项目中插入一个能运行的入口。psvm 也就是public static void main的首字母</p><p>System.out.println() (sout 按tab)，for循环（fori按tab）main(psvm按tab)，更多的提示可以CTRL + j 可以查看，mac系统下是command＋j，</p><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><pre><code>⌘ + ⇧ +T 创建单元测试用例</code></pre><p>要多学会使用在项目中编写单元测试的方法进行测试，不要总是重新运行整个项目<br>在maven项目的pom.xml文件中添加依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;junit&lt;/groupId&gt;    &lt;artifactId&gt;junit&lt;/artifactId&gt;    &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>选择一个类 比如xxxServiceImpl， xxDaoImpl<br>然后右键，选择goto – test</p><h1 id="Charles调试技巧"><a href="#Charles调试技巧" class="headerlink" title="Charles调试技巧"></a>Charles调试技巧</h1><p>charles也叫青花瓷，一个很文艺的名字，是在 Mac 下常用的网络封包截取工具，我主要使用charles的场景：<br>一是做移动开发时将其设置成系统的网络访问代理服务器，二是调试一些纯接口的项目时可以使用charles做网页代理将浏览器里的请求代理发送到本地实时调试。</p><h2 id="使用Map-Remote功能"><a href="#使用Map-Remote功能" class="headerlink" title="使用Map Remote功能"></a>使用Map Remote功能</h2><p>对于纯接口系统可以使用charles做网页代理将浏览器里的请求代理发送到本地实时调试，比之前简便了太多。<br><strong><em>Charles 的Map 功能分Map Remote 和Map Local 两种，Map Remote 是将指定的网络请求重定向到另一个网址，Map Local 是将指定的网络请求重定向到本地文件。</em></strong><br>Map Remote 使用场景，app或者PC&amp;M站某个需求刚提测阶段，新接口A在测试环境有，<br>还有一种极端情况，接口只在开发本地机器提供（无线底层很多接口不维护测试环境），线上环境A接口还未上线，此时可以使用charles的map remote功能。<br>选择</p><pre><code>charles-&gt;Tools-&gt;Map Remote-&gt;Enable Map Remote</code></pre><p>将Map From填写为测试环境的网址和端口，<br>Map to填写为本机的端口，注意填写Path<br>协议选择http</p><p><strong><em>Map From：</em></strong></p><pre><code>Protocol：httpHost：test.cn（前端的测试网址）PORT：80（http默认端口80，https默认端口是403）Path：/api/milp2p/module/currentModuleDataQuery：currentModuleStep=COMPLIANCE&amp;_=*</code></pre><p><strong><em>Map to：</em></strong></p><pre><code>Protocol：httpHost：192.168.0.1（指定主机的ip地址，可以使用ifconfig查询指定主机的ip地址，在eth0一项，本机可以用localhost）PORT：8900（本地项目使用的端口）Path：/module/currentModuleDataQuery：currentModuleStep=COMPLIANCE&amp;_=*</code></pre><p>对于submitCurrentModuleStep的代理更为简单：<br><strong><em>Map From：</em></strong></p><pre><code>Protocol：httpHost：test.cn（前端的测试网址）PORT：80（http默认端口80，https默认端口是403）Path：/api/milp2p/module/submitCurrentModuleStepQuery：=*</code></pre><p><strong><em>Map to：</em></strong></p><pre><code>Protocol：httpHost：192.168.0.1（指定主机的ip地址，可以使用ifconfig查询指定主机的ip地址，在eth0一项，本机可以用localhost）PORT：8900（本地项目使用的端口）Path：/module/submitCurrentModuleStepQuery：_=*</code></pre><p>关于Map Local和Rewrite功能的使用参见文章《Charles使用Map Local和Rewrite提高开发效率》</p><p>另外要选择菜单中的 “Proxy” –&gt; “Mac OS X Proxy”，才能将 Charles 设置成系统代理</p><h1 id="PostMan调试技巧"><a href="#PostMan调试技巧" class="headerlink" title="PostMan调试技巧"></a>PostMan调试技巧</h1><p>PostMan软件可用于调试HTTP接口，具体使用方法不再赘述<br>只说需要注意的几点：</p><h2 id="RequestParam注解"><a href="#RequestParam注解" class="headerlink" title="@RequestParam注解"></a>@RequestParam注解</h2><p>当controller中当方法参数为@RequestParam形式时</p><pre><code>//4。从外部能够查询商户(根据ID查询商户)//http://localhost:8080//Shop/ShopQuery Postman中Get内容，其余内容可以在Params中的KEY和VALUE填写@GetMapping(&quot;/ShopQuery&quot;)public ShopResponseDTO ShopQuery(@RequestParam(&quot;shopName&quot;) String shopName,                                    @RequestParam(&quot;contactName&quot;) String contactName,                                    @RequestParam(&quot;contactPhone&quot;)  String contactPhone,                                    @RequestParam(&quot;platformKey&quot;) String platformKey,                                    @RequestParam(&quot;shortName&quot;) String shortName){    ShopResponseDTO shopResponseDTO=new ShopResponseDTO();    shopResponseDTO=userService.MybatisSpringQuery(40L);    return shopResponseDTO;}</code></pre><p>Postman中选择POST格式发送，<a href="http://localhost:8080/Shop/ShopQuery" target="_blank" rel="noopener">http://localhost:8080/Shop/ShopQuery</a><br>然后在Params中填入KEY和VALUE，即可发送对应当POST请求。</p><h2 id="RequestBody注解"><a href="#RequestBody注解" class="headerlink" title="@RequestBody注解"></a>@RequestBody注解</h2><p>如果controller中的方法参数为@RequestBody形式时:</p><pre><code>/**商户接口* 4。从外部能够查询商户(根据ID查询商户)* http://localhost:8080//Shop/ShopQuery Postman中Get内容，其余内容可以在Params中的KEY和VALUE填写* @param ShopRequestDTO* @return*/@GetMapping(&quot;/ShopQuery&quot;)public ShopResponseDTO ShopQuery(@RequestBody SelectByIDShopRequestDTO selectByIDShopRequestDTO){  TblShopEntity tblShopEntity=new TblShopEntity();  tblShopEntity.setId(selectByIDShopRequestDTO.getId());  ShopResponseDTO shopResponseDTO;  shopResponseDTO=userService.MybatisSpringQuery(tblShopEntity);  return shopResponseDTO;}</code></pre><p>则选择Body-》raw形式，然后在右侧的栏中选择JSON(application/json)<br>以JSON格式填写POST中的Body：</p><pre><code>{    &quot;ID&quot;: &quot;47943&quot;}</code></pre><h2 id="使用postman发送请求可以使用Chrome插件"><a href="#使用postman发送请求可以使用Chrome插件" class="headerlink" title="使用postman发送请求可以使用Chrome插件"></a>使用postman发送请求可以使用Chrome插件</h2><p>postman interceptor<br>来抓取真实的请求，然后保存起来，根据情况替换请求地址</p><h1 id="浏览器测试技巧"><a href="#浏览器测试技巧" class="headerlink" title="浏览器测试技巧"></a>浏览器测试技巧</h1><p>除了用Postman进行测试外，也可以直接在浏览器中输入GET请求进行测试，在网址栏输入<a href="http://localhost:8080//Shop/ShopQuery发送即可" target="_blank" rel="noopener">http://localhost:8080//Shop/ShopQuery发送即可</a></p><h2 id="浏览器清空cookies缓存"><a href="#浏览器清空cookies缓存" class="headerlink" title="浏览器清空cookies缓存"></a>浏览器清空cookies缓存</h2><p>chrome右键打开检查页面，在和NETWORK平级的APPLICATION里可以找到cookies，右键clear</p><h1 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h1><h2 id="在日志中搜索匹配文本"><a href="#在日志中搜索匹配文本" class="headerlink" title="在日志中搜索匹配文本"></a>在日志中搜索匹配文本</h2><p>在vim中打开然后搜索，输入/，<br>然后输入要搜索的文本“target search text”<br>按enter后可定位到，如果要匹配下一个按小写n键。<br>跳转到上一个匹配呢？按下N（大写N）</p><p>也可以使用grep命令来过滤</p><pre><code>grep &quot;target search text&quot; debug.log --color</code></pre><h2 id="使用curl命令测试"><a href="#使用curl命令测试" class="headerlink" title="使用curl命令测试"></a>使用curl命令测试</h2><p>curl 是常用的命令行工具，用来请求 Web 服务器。它的名字就是客户端（client）的 URL 工具的意思。</p><p>它的功能非常强大，命令行参数多达几十种。如果熟练的话，完全可以取代 Postman 这一类的图形界面工具。</p><p>不带有任何参数时，curl 就是发出 GET 请求。</p><pre><code>$ curl https://www.google.com</code></pre><h3 id="d"><a href="#d" class="headerlink" title="-d"></a>-d</h3><p>-d参数用于发送 POST 请求的数据体。</p><pre><code>$ curl -d&apos;login=emma＆password=123&apos;-X POST https://google.com/login</code></pre><p>或者</p><pre><code>$ curl -d &apos;login=emma&apos; -d &apos;password=123&apos; -X POST  https://google.com/login</code></pre><p>使用-d参数以后，HTTP 请求会自动加上标头Content-Type : application/x-www-form-urlencoded。并且会自动将请求转为 POST 方法，因此可以省略-X POST。</p><p>-d参数可以读取本地文本文件的数据，向服务器发送。</p><pre><code>$ curl -d &apos;@data.txt&apos; https://google.com/login</code></pre><p>上面命令读取data.txt文件的内容，作为数据体向服务器发送。</p><h3 id="发送json格式请求"><a href="#发送json格式请求" class="headerlink" title="发送json格式请求"></a>发送json格式请求</h3><pre><code>curl -d &apos;{&quot;applyId&quot;:&quot;123&quot;}&apos;  -H &quot;Content-Type:application/json&quot; -X POST &quot;http://text.idc/TestController/getInfo&quot;curl --location --request POST &apos;http://text.idc/TestController/getInfo&apos;  --header &apos;Content-Type: application/json&apos; --data-raw &apos;{&quot;applyId&quot;:&quot;123&quot;}&apos;</code></pre><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://www.jianshu.com/p/6f81e86c8a61" target="_blank" rel="noopener">https://www.jianshu.com/p/6f81e86c8a61</a></p><p>【2】<a href="https://www.jianshu.com/p/dffca69070fc" target="_blank" rel="noopener">https://www.jianshu.com/p/dffca69070fc</a></p><p>【3】<a href="https://www.cnblogs.com/nzg-noway/articles/6524952.html" target="_blank" rel="noopener">https://www.cnblogs.com/nzg-noway/articles/6524952.html</a></p><p>【4】<a href="http://www.ruanyifeng.com/blog/2019/09/curl-reference.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/09/curl-reference.html</a></p><p>【5】<a href="https://www.jianshu.com/p/b8c13ca3154a" target="_blank" rel="noopener">https://www.jianshu.com/p/b8c13ca3154a</a></p><p>【6】<a href="https://www.jianshu.com/p/87581b2c570c" target="_blank" rel="noopener">https://www.jianshu.com/p/87581b2c570c</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下容易被忽略的后端开发中常用的调试技巧，主要包括IDEA中的常用快捷键和调试方法，&lt;br&gt;使用Charles，Postman，浏览器，命令行调试的常见技巧。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年5月" scheme="http://yoursite.com/categories/2020%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>405. 数字转化为十六进制数</title>
    <link href="http://yoursite.com/2020/04/29/405.%20%E6%95%B0%E5%AD%97%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0/"/>
    <id>http://yoursite.com/2020/04/29/405. 数字转化为十六进制数/</id>
    <published>2020-04-29T08:12:12.000Z</published>
    <updated>2020-04-29T09:38:47.665Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。</p><a id="more"></a><p>这道题看似简单但想符合所有情况还是很伤脑筋。<br>用了无符号右移和位运算后简化了很多。<br>首先要知道16进制数在计算机中是怎么表示的，<br>由于对于16进制一个有16个数（0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f）<br>所以我们只需要使用4位 2^4=16刚好可以表示16个数，<br>所以计算机在内部是用4位来表示16进制的0000表示0,0001表示1…..1111表示f.<br>所有题目给我们一个int型的数字num,一个int= 4字节 = 32位，<br>所以，这个32位数字可以被分隔成8个4位数，<br>所以我们只需要从头到尾每4位每4的的遍历，每遍历一个4位就将其转化为16进制的数即可<br>，有人可能会问为什么这样可以，其实这样我们是做了两个步骤，<br>先转化为2进制（由于计算机中所有东西本身就是2进制存储的，所以我们可以直接得到该数字的2进制），<br>再转化为16进制，比如对于26 -&gt;二进制为‭00011010‬（前面省略了24个0）<br>所以每4位遍历就变成了0001,1010对于0001 对应16进制中的1,1010对应16进制中的a所以结果就是为1a.<br>所以对于此题我们只需要从尾部开始用位运算取出每一个4位，<br>再转化为16进制即可只需要注意前面为0的16进制应该删除即可。<br>我们首先需要设一个数字calc = 0xf也就是右边4位为1其余均为0<br>，此时我们把数字num与之进行与运算就可以取出，num右边4位的值，<br>然后再把calc向左边移动4位就变成了11110000(前面省略24个0)此时在与之相与就可以得到num中右边8位的值，<br>此时还需要把这个值向右移动4位，因为这样是的到了第2个4位值，然后再次重复此步骤即可。</p><h1 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h1><p>java里面有 Integer.toHexString() 但是题目要求自己写 位运算，以4位为粒度进行取数,转化为16进制字符串</p><pre><code> /** * 如：35 == 0010 0011 = 23 * * 注意：java中 *      hex to int Integer.valueOf(&quot;12ff&quot;,16) *      int to hex Integer.toHexString(35) */```    public String toHex(int num) {        char[] hex = &quot;0123456789abcdef&quot;.toCharArray();        String s = new String();        while(num != 0){            int end = num&amp;15;            s = hex[end] + s;            //无符号右移            num &gt;&gt;&gt;=4;        }        if(s.length() == 0){            s = &quot;0&quot;;        }        return s;    }</code></pre><h1 id="无符号右移运算符-gt-gt-gt"><a href="#无符号右移运算符-gt-gt-gt" class="headerlink" title="无符号右移运算符&gt;&gt;&gt;"></a>无符号右移运算符&gt;&gt;&gt;</h1><p>它的通用格式如下所示：</p><p>　　value &gt;&gt;&gt; num</p><p>num 指定要移位值value 移动的位数。</p><p>无符号右移的规则只记住一点：忽略了符号位扩展，0补最高位</p><p>无符号右移规则和右移运算是一样的，只是填充时不管左边的数字是正是负都用0来填充，无符号右移运算只针对负数计算，因为对于正数来说这种运算没有意义<br>无符号右移运算符&gt;&gt;&gt; 只是对32位和64位的值有意义</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年4月" scheme="http://yoursite.com/categories/2020%E5%B9%B44%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot学习笔记VIII-MybatisPlus教程</title>
    <link href="http://yoursite.com/2020/04/17/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0VIII-MybatisPlus%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/04/17/SpringBoot学习笔记VIII-MybatisPlus教程/</id>
    <published>2020-04-17T02:12:12.000Z</published>
    <updated>2020-04-17T03:11:43.354Z</updated>
    
    <content type="html"><![CDATA[<p>MybatisPlus教程</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>官网地址：<a href="https://mybatis.plus/" target="_blank" rel="noopener">https://mybatis.plus/</a></p><p>官网简介：MyBatis-Plus 是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p><p>下面介绍如何快速上手 mybatis-plus，给出了 mapper 和 service CRUD 的基本示例。</p><p>建议在后续开发中，时时翻看官方文档（<a href="https://mybatis.plus/guide）。" target="_blank" rel="noopener">https://mybatis.plus/guide）。</a></p><h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><pre><code>&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><h2 id="MapperScan-配置"><a href="#MapperScan-配置" class="headerlink" title="MapperScan 配置"></a>MapperScan 配置</h2><pre><code>@SpringBootApplication@MapperScan(&quot;com.xx.xx.xx.mapper&quot;)public class Application {    public static void main(String[] args) {        SpringApplication.run(Application.class, args);    }}</code></pre><h1 id="Mapper-基本使用"><a href="#Mapper-基本使用" class="headerlink" title="Mapper 基本使用"></a>Mapper 基本使用</h1><h2 id="Entity-定义"><a href="#Entity-定义" class="headerlink" title="Entity 定义"></a>Entity 定义</h2><pre><code>@Data@Accessors(chain = true)@TableName(&quot;t_user&quot;) // 表名，默认是类名转下划线public class User {    // 指定主键，IdType.AUTO 表示自增主键    @TableId(type= IdType.AUTO)    private Long id;    private String name;    private Integer age;    private String email;    private Integer address;    // 不在数据库里的字段    @TableField(exist = false)    private Integer count;}</code></pre><h2 id="Mapper-定义：继承-BaseMapper"><a href="#Mapper-定义：继承-BaseMapper" class="headerlink" title="Mapper 定义：继承 BaseMapper"></a>Mapper 定义：继承 BaseMapper</h2><pre><code>public interface UserMapper extends BaseMapper&lt;User&gt; {}</code></pre><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><pre><code>@RunWith(SpringRunner.class)@SpringBootTestpublic class MapperTest {    @Autowired    private UserMapper mapper;    @Test    public void insertTest() {        // 1. insert        User user = new User();        user.setName(&quot;小羊&quot;);        user.setAge(3);        user.setEmail(&quot;abc@mp.com&quot;);        assertThat(mapper.insert(user)).isGreaterThan(0);        // 成功直接拿 ID        assertThat(user.getId()).isNotNull();    }    @Test    public void deleteTest() {        // 1. deleteById        assertThat(mapper.deleteById(3L)).isGreaterThan(0);        // 2. delete with queryWrapper        assertThat(mapper.delete(new QueryWrapper&lt;User&gt;()            .lambda().eq(User::getName, &quot;Sandy&quot;))).isGreaterThan(0);    }    @Test    public void updateTest() {        // 1. updateById        assertThat(mapper.updateById(new User().setId(1L).setEmail(&quot;ab@c.c&quot;))).isGreaterThan(0);        // 2. update with entity and updateWrapper        assertThat(            mapper.update(                new User().setName(&quot;mp&quot;),                Wrappers.&lt;User&gt;lambdaUpdate()                    .set(User::getAge, 3)                    .eq(User::getId, 2)            )        ).isGreaterThan(0);        User user = mapper.selectById(2);        assertThat(user.getAge()).isEqualTo(3);        assertThat(user.getName()).isEqualTo(&quot;mp&quot;);        // 3. update with entity and queryWrapper        mapper.update(            new User().setEmail(&quot;miemie@baomidou.com&quot;),            new QueryWrapper&lt;User&gt;()                .lambda().eq(User::getId, 2)        );        user = mapper.selectById(2);        assertThat(user.getEmail()).isEqualTo(&quot;miemie@baomidou.com&quot;);        // 4. update with UpdateWrapper        mapper.update(null, new UpdateWrapper&lt;User&gt;()            .lambda().eq(User::getId, 2).set(User::getAge, 1));        // mapper.update(null, new UpdateWrapper&lt;User&gt;()        //   .eq(&quot;id&quot;, 2).set(&quot;age&quot;, 1));        user = mapper.selectById(2);        assertThat(user.getAge()).isEqualTo(1);    }    @Test    public void selectTest() {        // 1. selectById        assertThat(mapper.selectById(1L)).isNotNull();        // 2. selectOne with QueryWrapper        User user = mapper.selectOne(new QueryWrapper&lt;User&gt;().lambda().eq(User::getId, 1L));        assertThat(user.getAge()).isEqualTo(3);        // 3. selectList with lambdaQuery        mapper.selectList(Wrappers.&lt;User&gt;lambdaQuery().select(User::getId))            .forEach(x -&gt; {                assertThat(x.getId()).isNotNull();            });        // 4. selectList with QueryWrapper        mapper.selectList(new QueryWrapper&lt;User&gt;().select(&quot;id&quot;, &quot;name&quot;))            .forEach(x -&gt; {                assertThat(x.getId()).isNotNull();            });        // 5. selectMaps        List&lt;Map&lt;String, Object&gt;&gt; mapList = mapper.selectMaps(Wrappers.&lt;User&gt;query().orderByAsc(&quot;age&quot;));        assertThat(mapList).isNotEmpty();        assertThat(mapList.get(0)).isNotEmpty();        System.out.println(mapList.get(0));        // 6. selectPage        IPage&lt;User&gt; page = mapper.selectPage(new Page&lt;&gt;(1, 5),            Wrappers.&lt;User&gt;query().orderByAsc(&quot;age&quot;));        assertThat(page).isNotNull();        assertThat(page.getRecords()).isNotEmpty();        System.out.println(page.getRecords().get(0));        // 7. selectMaxId        QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();        wrapper.select(&quot;max(id) as id&quot;);        User userMaxId = mapper.selectOne(wrapper);        System.out.println(&quot;maxId=&quot; + userMaxId.getId());        List&lt;User&gt; users = mapper.selectList(Wrappers.&lt;User&gt;lambdaQuery().orderByDesc(User::getId));        Assert.assertEquals(userMaxId.getId().longValue(), users.get(0).getId().longValue());    }    @Test    public void orderByTest() {        List&lt;User&gt; users = mapper.selectList(Wrappers.&lt;User&gt;query().orderByAsc(&quot;age&quot;));        assertThat(users).isNotEmpty();        List&lt;User&gt; usersLambda = mapper.selectList(Wrappers.&lt;User&gt;lambdaQuery().orderByAsc(User::getAge));        assertThat(usersLambda).isNotEmpty();    }    @Test    public void groupTest() {        QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();        wrapper.select(&quot;age, count(*)&quot;)            .groupBy(&quot;age&quot;);        List&lt;Map&lt;String, Object&gt;&gt; maplist = mapper.selectMaps(wrapper);        for (Map&lt;String, Object&gt; mp : maplist) {            System.out.println(mp);        }        mapper.selectList( new QueryWrapper&lt;User&gt;().lambda()            .select(User::getAge)            .groupBy(User::getAge)            .orderByAsc(User::getAge))            .forEach(System.out::println);    }    // Mybatis-Plus 没有为 join 操作提供增强接口    // 在 userMapper 中定义函数，与 Mybatis 的使用一致    // @Select(&quot;select a.id as addressId, t.id as userId, t.name as userName, a.address as address &quot;    //  + &quot;from t_user t\n&quot;    //  + &quot;join address a on t.address = a.id\n&quot;    //  + &quot;where t.id = #{userId}&quot;)    // UserAddress selectUserAddress(Long userId);    @Test    public void joinTest() {        UserAddress userAddress = mapper.selectUserAddress(7L);        System.out.println(userAddress);    }    // UserAddress 定义    // @Data    // public class UserAddress {    //   Integer addressId;    //   Integer userId;    //   String address;    //   String userName;    // }}</code></pre><h1 id="Service-基本使用"><a href="#Service-基本使用" class="headerlink" title="Service 基本使用"></a>Service 基本使用</h1><h2 id="Service-定义"><a href="#Service-定义" class="headerlink" title="Service 定义"></a>Service 定义</h2><pre><code>public interface UserService extends IService&lt;User&gt; {}@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService {}</code></pre><h2 id="测试用例-1"><a href="#测试用例-1" class="headerlink" title="测试用例"></a>测试用例</h2><pre><code>@RunWith(SpringRunner.class)@SpringBootTestpublic class ServiceTest {    @Autowired    private UserService userService;    @Test    public void saveTest() {        User user = new User();        user.setId(10L);        user.setName(&quot;小羊&quot;);        user.setAge(3);        user.setEmail(&quot;abc@mp.com&quot;);        // 1. save: 相当于 mapper.insert        assertThat(userService.save(user)).isTrue();        // 2. saveOrUpdate: 先根据 id 进行 select，如果存在则 update，否则 insert        assertThat(userService.saveOrUpdate(user)).isTrue();        System.out.println(user);    }    @Test    public void removeTest() {        User user = new User();        user.setName(&quot;miemie&quot;);        // 1. removeById        userService.save(user);        assertTrue(userService.removeById(user.getId()));        // 2. remove with QueryWrapper        userService.save(user);        assertTrue(userService.remove(new QueryWrapper&lt;User&gt;().lambda().eq(User::getId, user.getId())));        // 3. removeByMap        userService.save(user);        Map&lt;String, Object&gt; columnMap = new HashMap&lt;&gt;();        columnMap.put(&quot;id&quot;, user.getId().toString());        assertTrue(userService.removeByMap(columnMap));        // 4. lambdaUpdate        userService.save(user);        assertTrue(userService.lambdaUpdate().eq(User::getId, user.getId()).remove());    }    @Test    public void updateTest(){        // 1. updateById        User user = new User();        user.setId(1L);        user.setName(&quot;mm&quot;);        assertTrue(userService.updateById(user));        // 2. update with updateWrapper        UpdateWrapper&lt;User&gt; updateWrapper = new UpdateWrapper&lt;User&gt;().eq(&quot;id&quot;, 1L).set(&quot;name&quot;, &quot;mm&quot;);        System.out.println(updateWrapper.getCustomSqlSegment());        assertTrue(userService.update(updateWrapper));        // 3. lambdaUpdate        boolean update = userService.lambdaUpdate().eq(User::getAge, 18).set(User::getAge, 31).update();        System.out.println(update);    }    @Test    public void getTest(){        Long userId = 1L;        // 1. getById        User u1 = userService.getById(userId);        assertThat(u1).isNotNull();        // 2. getOne        User u2 = userService.getOne(new QueryWrapper&lt;User&gt;().lambda().eq(User::getId, userId));        assertThat(u2).isNotNull();        assertSame(u1.getId(), u2.getId());        // 3. getList        List&lt;User&gt; list1 = userService.list(new QueryWrapper&lt;User&gt;().lambda().eq(User::getId, userId));        assertThat(list1.isEmpty()).isFalse();        // 4. lambdaQuery        List&lt;User&gt; list = userService.lambdaQuery().eq(User::getId, userId).list();        list.forEach(System.out::println);    }}</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MybatisPlus教程&lt;/p&gt;
    
    </summary>
    
      <category term="2020年4月" scheme="http://yoursite.com/categories/2020%E5%B9%B44%E6%9C%88/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>设计模式学习笔记V-策略模式</title>
    <link href="http://yoursite.com/2020/04/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0V-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/04/13/设计模式学习笔记V-策略模式/</id>
    <published>2020-04-13T09:30:12.000Z</published>
    <updated>2020-04-23T02:04:37.538Z</updated>
    
    <content type="html"><![CDATA[<p>策略模式（Strategy Pattern）</p><a id="more"></a><h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。</p><p>在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。</p><p>主要解决：在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。</p><p>何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。</p><p>如何解决：将这些算法封装成一个一个的类，任意地替换。</p><p>关键代码：实现同一个接口。</p><p>应用实例： 1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 3、JAVA AWT 中的 LayoutManager。</p><p>优点： 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。</p><p>缺点： 1、策略类会增多。 2、所有策略类都需要对外暴露。</p><p>使用场景： 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</p><p>注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>我们将创建一个定义活动的 Strategy 接口和实现了 Strategy 接口的实体策略类。Context 是一个使用了某种策略的类。</p><p>StrategyPatternDemo，我们的演示类使用 Context 和策略对象来演示 Context 在它所配置或使用的策略改变时的行为变化。</p><h2 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h2><p>创建一个接口。</p><pre><code>Strategy.javapublic interface Strategy {   public int doOperation(int num1, int num2);}</code></pre><h2 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h2><p>创建实现接口的实体类。</p><pre><code>OperationAdd.javapublic class OperationAdd implements Strategy{   @Override   public int doOperation(int num1, int num2) {      return num1 + num2;   }}OperationSubstract.javapublic class OperationSubstract implements Strategy{   @Override   public int doOperation(int num1, int num2) {      return num1 - num2;   }}OperationMultiply.javapublic class OperationMultiply implements Strategy{   @Override   public int doOperation(int num1, int num2) {      return num1 * num2;   }}</code></pre><h2 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a>步骤 3</h2><p>创建 Context 类。</p><pre><code>Context.javapublic class Context {   private Strategy strategy;   public Context(Strategy strategy){      this.strategy = strategy;   }   public int executeStrategy(int num1, int num2){      return strategy.doOperation(num1, num2);   }}</code></pre><h2 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤 4"></a>步骤 4</h2><p>使用 Context 来查看当它改变策略 Strategy 时的行为变化。</p><pre><code>StrategyPatternDemo.javapublic class StrategyPatternDemo {   public static void main(String[] args) {      Context context = new Context(new OperationAdd());          System.out.println(&quot;10 + 5 = &quot; + context.executeStrategy(10, 5));      context = new Context(new OperationSubstract());            System.out.println(&quot;10 - 5 = &quot; + context.executeStrategy(10, 5));      context = new Context(new OperationMultiply());          System.out.println(&quot;10 * 5 = &quot; + context.executeStrategy(10, 5));   }}</code></pre><h2 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤 5"></a>步骤 5</h2><p>执行程序，输出结果：</p><pre><code>10 + 5 = 1510 - 5 = 510 * 5 = 50</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="https://www.runoob.com/design-pattern/strategy-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/strategy-pattern.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;策略模式（Strategy Pattern）&lt;/p&gt;
    
    </summary>
    
      <category term="2020年4月" scheme="http://yoursite.com/categories/2020%E5%B9%B44%E6%9C%88/"/>
    
    
      <category term="Design Pattern，Java" scheme="http://yoursite.com/tags/Design-Pattern%EF%BC%8CJava/"/>
    
  </entry>
  
  <entry>
    <title>1046. 最后一块石头的重量</title>
    <link href="http://yoursite.com/2020/02/16/1046.%20%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F/"/>
    <id>http://yoursite.com/2020/02/16/1046. 最后一块石头的重量/</id>
    <published>2020-02-16T09:51:12.000Z</published>
    <updated>2020-02-16T09:55:55.982Z</updated>
    
    <content type="html"><![CDATA[<p>过完年后在家办公已经两周，好久没更新博客了，最近做的大多是easy难度的题聊以消遣，这道easy主要练习了下队列和比较函数，也可以用堆来解决。</p><a id="more"></a><p>有一堆石头，每块石头的重量都是正整数。</p><p>每一回合，从中选出两块最重的石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下：</p><p>如果 x == y，那么两块石头都会被完全粉碎；<br>如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。<br>最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。</p><p>提示：</p><p>1 &lt;= stones.length &lt;= 30<br>1 &lt;= stones[i] &lt;= 1000</p><pre><code>class Solution {    public int lastStoneWeight(int[] stones) {        /* 使用优先对列保证每次能拿到最大的数 */        Queue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(new Comparator&lt;Integer&gt;() {            @Override            public int compare(Integer o1, Integer o2) {                return (o2 - o1);            }        });        for (int i = 0; i &lt; stones.length; i++) {            queue.offer(stones[i]);        }        while(queue.size() &gt; 1) {            int x = queue.poll();            int y = queue.poll();            int diff = Math.abs(x - y);            if (diff != 0) {                queue.offer(diff);            }        }        if (queue.isEmpty()) return 0;        return queue.peek();    }}</code></pre><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】：<a href="https://leetcode-cn.com/problems/last-stone-weight/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/last-stone-weight/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;过完年后在家办公已经两周，好久没更新博客了，最近做的大多是easy难度的题聊以消遣，这道easy主要练习了下队列和比较函数，也可以用堆来解决。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年2月" scheme="http://yoursite.com/categories/2020%E5%B9%B42%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="heap" scheme="http://yoursite.com/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记XIV</title>
    <link href="http://yoursite.com/2020/01/24/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0XIV/"/>
    <id>http://yoursite.com/2020/01/24/Java学习笔记XIV/</id>
    <published>2020-01-24T09:34:12.000Z</published>
    <updated>2020-01-24T11:37:52.768Z</updated>
    
    <content type="html"><![CDATA[<p>Java的值传递和引用传递</p><a id="more"></a><p>java中数据类型分为基本数据类型和引用数据类型。</p><p>基本数据类型</p><pre><code>整型：byte，short，int，long浮点型：float，double字符型：char布尔型：boolean</code></pre><p>引用数据类型</p><pre><code>数组类接口</code></pre><p>方法的参数分为实际参数，和形式参数。</p><pre><code>形式参数：定义方法时写的参数。实际参数：调用方法时写的具体数值。</code></pre><p>一般情况下，在数据做为参数传递的时候，<strong><em>基本数据类型是值传递，引用数据类型是引用传递（地址传递）。</em></strong></p><h1 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h1><pre><code>public static void main(String[] args) {    int num1 = 10;    int num2 = 20;    swap(num1, num2);    System.out.println(&quot;num1 = &quot; + num1);    System.out.println(&quot;num2 = &quot; + num2);}public static void swap(int a, int b) {    int temp = a;    a = b;    b = temp;    System.out.println(&quot;a = &quot; + a);    System.out.println(&quot;b = &quot; + b);}</code></pre><p>运行结果：</p><pre><code>a = 20b = 10num1 = 10num2 = 20</code></pre><h2 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h2><p>主函数进栈，num1、num2初始化。<br>调用swap方法，swap( )进栈，将num1和num2的值，复制一份给a和b。<br>swap方法中对a、b的值进行交换。<br>swap方法运行完毕，a、b的值已经交换。<br>swap方法弹栈。<br>主函数弹栈。</p><h2 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h2><p>在swap方法中，a、b的值进行交换，并不会影响到num1、num2。因为，a、b中的值，只是从num1、num2的复制过来的。<br>也就是说，a、b相当于num1、num2的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p><h1 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h1><pre><code>public static void main(String[] args) {    int[] arr = {1,2,3,4,5};    change(arr);    System.out.println(arr[0]);}//将数组的第一个元素变为0public static void change(int[] array) {    int len = array.length;    array[0] = 0;}</code></pre><p>运行结果是：<br>    0</p><h1 id="流程：-1"><a href="#流程：-1" class="headerlink" title="流程："></a>流程：</h1><p>主函数进栈，int[] arr初始化。<br>调用change方法，change( )进栈，将arr的地址值，复制一份给array。<br>change方法中，根据地址值，找到堆中的数组，并将第一个元素的值改为0。<br>change方法运行完毕，数组中第一个元素的值已经改变。<br>change方法弹栈。<br>主函数弹栈。</p><h1 id="解析：-1"><a href="#解析：-1" class="headerlink" title="解析："></a>解析：</h1><p>调用change()的时候，形参array接收的是arr地址值的副本。并在change方法中，通过地址值，对数组进行操作。change方法弹栈以后，数组中的值已经改变。main方法中，打印出来的arr[0]也就从原来的1变成了0.</p><p>无论是主函数，还是change方法，操作的都是同一个地址值对应的数组。<br>就像你把自己家的钥匙给了另一个人，这个人拿着钥匙在你家一顿瞎折腾，然后走了。等你拿着钥匙回到家以后，家里已经变成了被折腾过后，惨不忍睹的样子。。<br>这里的钥匙就相当于地址值，家就相当于数组本身。</p><h1 id="String类型传递"><a href="#String类型传递" class="headerlink" title="String类型传递"></a>String类型传递</h1><pre><code>public static void main(String[] args) {    String str = &quot;AAA&quot;;    change(str);    System.out.println(str);}   public static void change(String s) {    s = &quot;abc&quot;;}</code></pre><p>运行的结果是：</p><pre><code>AAA</code></pre><p>String是一个类，类是引用数据类型，做为参数传递的时候，应该是引用传递。但是从结果看起来却是值传递。</p><h2 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h2><p>String的API中有这么一句话：“their values cannot be changed after they are created”，<br>意思是：String的值在创建之后不能被更改。<br>API中还有一段：<br>String str = “abc”;<br>等效于：</p><pre><code>char data[] = {&apos;a&apos;, &apos;b&apos;, &apos;c&apos;};String str = new String(data);</code></pre><p>也就是说：对String对象str的任何修改 等同于 重新创建一个对象，并将新的地址值赋值给str。</p><p>这样的话，上面的代码就可以写成：</p><pre><code>public static void main(String[] args) {    String str1 = &quot;AAA&quot;;    change(str1);    System.out.println(str1);}   public static void change(String s) {    char data[] = {&apos;a&apos;, &apos;b&apos;, &apos;c&apos;}    String str = new String(data);    s = str;}</code></pre><h2 id="流程：-2"><a href="#流程：-2" class="headerlink" title="流程："></a>流程：</h2><p>主函数进栈，str1初始化。<br>调用change方法，change( )进栈，将str1的地址值，复制一份给s。<br>change方法中，重现创建了一个String对象”abc”，并将s指向了新的地址值。<br>change方法运行完毕，s所指向的地址值已经改变。<br>change方法弹栈。<br>主函数弹栈。</p><h2 id="解析：-2"><a href="#解析：-2" class="headerlink" title="解析："></a>解析：</h2><p>String对象做为参数传递时，走的依然是引用传递，只不过String这个类比较特殊。<br>String对象一旦创建，内容不可更改。每一次内容的更改都是重现创建出来的新对象。<br>当change方法执行完毕时，s所指向的地址值已经改变。而s本来的地址值就是copy过来的副本，所以并不能改变str1的值。</p><h1 id="String类型类似情况："><a href="#String类型类似情况：" class="headerlink" title="String类型类似情况："></a>String类型类似情况：</h1><pre><code>class Person {    String name;    public Person(String name) {        this.name = name;    }}public class Test {    public static void main(String[] args) {        Person p = new Person(&quot;张三&quot;);        change(p);        System.out.println(p.name);    }    public static void change(Person p) {        Person person = new Person(&quot;李四&quot;);        p = person;    }}</code></pre><p>运行的结果是：</p><pre><code>张三</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>值传递的时候，将实参的值，copy一份给形参。<br>引用传递的时候，将实参的地址值，copy一份给形参。<br>也就是说，不管是值传递还是引用传递，形参拿到的仅仅是实参的副本，而不是实参本身。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://blog.csdn.net/zhzhao999/article/details/53449504" target="_blank" rel="noopener">https://blog.csdn.net/zhzhao999/article/details/53449504</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java的值传递和引用传递&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>257.二叉树的所有路径</title>
    <link href="http://yoursite.com/2020/01/24/257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2020/01/24/257.二叉树的所有路径/</id>
    <published>2020-01-24T09:31:12.000Z</published>
    <updated>2020-05-19T16:02:56.681Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p><a id="more"></a><p>此题主要有递归和迭代两种方式进行深度优先遍历，主要让我感兴趣的是在Java中可以使用List&lt;&gt;进行引用传递，参见笔记《Java学习笔记XIV》或参考资料【2】</p><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>比较容易想到的是递归遍历的解法：<br>在递归遍历二叉树时，需要考虑当前的节点和它的孩子节点。如果当前的节点不是叶子节点，则在当前的路径末尾添加该节点，并递归遍历该节点的每一个孩子节点。如果当前的节点是叶子节点，则在当前的路径末尾添加该节点后，就得到了一条从根节点到叶子节点的路径，可以把该路径加入到答案中。</p><p>最开始写出的答案：</p><pre><code>class Solution {    public List&lt;String&gt; binaryTreePaths(TreeNode root) {        List&lt;String&gt; res=new LinkedList&lt;&gt;();        deepSearch(root,&quot;&quot;,res);        return res;    }    public void deepSearch(TreeNode root,String path,List&lt;String&gt; res) {        if(root.left==null &amp;&amp; root.right==null) {            path=path+Integer.toString(root.val);            res.add(path);            return;        }        if(root.left!=null){            path=path+Integer.toString(root.val)+&quot;-&gt;&quot;;            deepSearch(root.left,path,res);        }        if(root.right!=null){            path=path+Integer.toString(root.val)+&quot;-&gt;&quot;;            deepSearch(root.right,path,res);        }    }}</code></pre><p>但遍历了树[“1-&gt;2-&gt;5”, “1-&gt;3”]发现结果是[“1-&gt;2-&gt;5”, “1-&gt;1-&gt;3”]<br>原因是遍历了左子树后回到根节点发现右子树进入时就已经有上次遗留的path=”1-&gt;”了，因此改为：</p><pre><code>class Solution {    public List&lt;String&gt; binaryTreePaths(TreeNode root) {        List&lt;String&gt; res=new LinkedList&lt;&gt;();        deepSearch(root,&quot;&quot;,res);        return res;    }    public void deepSearch(TreeNode root,String path,List&lt;String&gt; res) {        if(root.left==null &amp;&amp; root.right==null) {            path=path+Integer.toString(root.val);            res.add(path);            return;        }        path=path+Integer.toString(root.val)+&quot;-&gt;&quot;;        if(root.left!=null){            deepSearch(root.left,path,res);        }        if(root.right!=null){            deepSearch(root.right,path,res);        }    }}</code></pre><p>又发现出现了典型的空指针问题，因此加入对空指针的判断就可以通过了，官方题解如下：</p><pre><code>class Solution {    public void construct_paths(TreeNode root, String path, LinkedList&lt;String&gt; paths) {        if (root != null) {            path += Integer.toString(root.val);            if ((root.left == null) &amp;&amp; (root.right == null))  // 当前节点是叶子节点                paths.add(path);  // 把路径加入到答案中            else {                path += &quot;-&gt;&quot;;  // 当前节点不是叶子节点，继续递归遍历                construct_paths(root.left, path, paths);                construct_paths(root.right, path, paths);            }        }    }    public List&lt;String&gt; binaryTreePaths(TreeNode root) {        LinkedList&lt;String&gt; paths = new LinkedList();        construct_paths(root, &quot;&quot;, paths);        return paths;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：每个节点只会被访问一次，因此时间复杂度为 O(N)，其中 N 表示节点数目。<br>空间复杂度：O(N)。这里不考虑存储答案 paths 使用的空间，仅考虑额外的空间复杂度。额外的空间复杂度为递归时使用的栈空间，在最坏情况下，当二叉树中每个节点只有一个孩子节点时，递归的层数为 N，此时空间复杂度为 O(N)。在最好情况下，当二叉树为平衡二叉树时，它的高度为 log(N)，此时空间复杂度为O(log(N))。</p><h1 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h1><p>上面的算法也可以使用迭代（宽度优先搜索）的方法实现。我们维护一个队列，存储节点以及根到该节点的路径。一开始这个队列里只有根节点。在每一步迭代中，我们取出队列中的首节点，如果它是一个叶子节点，则将它对应的路径加入到答案中。如果它不是一个叶子节点，则将它的所有孩子节点加入到队列的末尾。当队列为空时，迭代结束。</p><pre><code>class Solution {    public List&lt;String&gt; binaryTreePaths(TreeNode root) {        LinkedList&lt;String&gt; paths = new LinkedList();        if (root == null)            return paths;        LinkedList&lt;TreeNode&gt; node_stack = new LinkedList();        LinkedList&lt;String&gt; path_stack = new LinkedList();        node_stack.add(root);        path_stack.add(Integer.toString(root.val));        TreeNode node;        String path;        while (!node_stack.isEmpty()) {            node = node_stack.pollLast();            path = path_stack.pollLast();            if ((node.left == null) &amp;&amp; (node.right == null))                paths.add(path);            if (node.left != null) {                node_stack.add(node.left);                path_stack.add(path + &quot;-&gt;&quot; + Integer.toString(node.left.val));            }            if (node.right != null) {                node_stack.add(node.right);                path_stack.add(path + &quot;-&gt;&quot; + Integer.toString(node.right.val));            }        }        return paths;    }}</code></pre><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(N)，每个节点只会被访问一次。<br>空间复杂度：O(N)，在最坏情况下，队列中有 N 个节点。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://leetcode-cn.com/problems/binary-tree-paths/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-paths/</a><br>【2】<a href="https://blog.csdn.net/zhzhao999/article/details/53449504" target="_blank" rel="noopener">https://blog.csdn.net/zhzhao999/article/details/53449504</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个二叉树，返回所有从根节点到叶子节点的路径。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="BinaryTree" scheme="http://yoursite.com/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>24.两两交换链表中的节点</title>
    <link href="http://yoursite.com/2020/01/22/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>http://yoursite.com/2020/01/22/24.两两交换链表中的节点/</id>
    <published>2020-01-22T06:32:12.000Z</published>
    <updated>2020-01-22T06:38:13.500Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表</p><a id="more"></a><p>此题有递归和迭代两种方法，我在做的时候首先想到的是用迭代的方法。但是在返回哪个结点时出了问题。调试了很久。看官方题解<br><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/liang-liang-jiao-huan-lian-biao-zhong-de-jie-di-19/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/liang-liang-jiao-huan-lian-biao-zhong-de-jie-di-19/</a><br>也没有弄清楚dummy结点下个结点为什么会准确的指向交换后的链表头而不是跟着交换移动。<br>看了<br><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/bi-jiao-zhi-jie-gao-xiao-de-zuo-fa-han-tu-jie-by-w/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/bi-jiao-zhi-jie-gao-xiao-de-zuo-fa-han-tu-jie-by-w/</a><br>这个题解中的图解才算搞清楚了，建议再做的时候还是在不看题解的情况下写一次。</p><p>顺便推荐IDEA中的leetcode-editor插件，这个插件现在已经可以在中文版leetcode上无缝对接使用了。适合在一些场景下做leetcode。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个链表，两两交换其中相邻的节点，并返回交换后的链表&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="LinkList" scheme="http://yoursite.com/tags/LinkList/"/>
    
  </entry>
  
  <entry>
    <title>微信公众平台开发学习笔记I</title>
    <link href="http://yoursite.com/2020/01/20/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0I/"/>
    <id>http://yoursite.com/2020/01/20/微信公众平台开发学习笔记I/</id>
    <published>2020-01-20T07:18:12.000Z</published>
    <updated>2020-01-20T07:26:49.762Z</updated>
    
    <content type="html"><![CDATA[<p>在测试号中配置接口URL和Token遇到的问题及解决方法</p><a id="more"></a><h1 id="在测试号中配置接口URL和Token"><a href="#在测试号中配置接口URL和Token" class="headerlink" title="在测试号中配置接口URL和Token"></a>在测试号中配置接口URL和Token</h1><p>使用ngrok穿透工具为本地生成对外的网址：<br><a href="https://dashboard.ngrok.com/get-started" target="_blank" rel="noopener">https://dashboard.ngrok.com/get-started</a><br>注册后得到与本账户绑定的authtoken</p><pre><code>./ngrok authtoken 1WNVahHoiVcDG9Hr6c4E86yQpbA_eX526mPNsmsXBkMnLLs6</code></pre><p>启动HTTP隧道</p><pre><code>./ngrok http 80</code></pre><p>这条命令的意思是将本地80端口对应的服务暴露到外网中。<br>显示界面：</p><pre><code>Session Status   online                                       Account          Yiye Li (Plan: Free)                                 Version          2.3.35                             Region            United States(us)                                   Web Interface     http://127.0.0.1:4040                                             Forwarding   http://e5d20d55.ngrok.io -&gt; http://localhost:80                 Forwarding   https://e5d20d55.ngrok.io -&gt; http://localhost:80    Connections  ttl   opn   rt1   rt5   p50   p90                                      0       0       0.00    0.00    0.00    0.00  </code></pre><p>第一个是http协议对应的外网地址，第二个是https协议对应的外网地址。这样，凡是访问<a href="http://e5d20d55.ngrok.io的请求都将发送到localhost:80。不付费的话每次启动ngrok都会分配一个新的外网域名，所以需要每次更换配置或者更换访问地址。" target="_blank" rel="noopener">http://e5d20d55.ngrok.io的请求都将发送到localhost:80。不付费的话每次启动ngrok都会分配一个新的外网域名，所以需要每次更换配置或者更换访问地址。</a></p><p>然后在<a href="https://mp.weixin.qq.com/debug/cgi-bin/sandboxinfo?action=showinfo&amp;t=sandbox/index中输入https://e5d20d55.ngrok.io和token，token从本地项目的applicaiton.yml中获取。" target="_blank" rel="noopener">https://mp.weixin.qq.com/debug/cgi-bin/sandboxinfo?action=showinfo&amp;t=sandbox/index中输入https://e5d20d55.ngrok.io和token，token从本地项目的applicaiton.yml中获取。</a><br>但这时提交会发现配置失败，而且查看本地运行日志没有记录，原因是本地项目的端口号为9006，而URL是本地80端口对应的服务暴露到外网中，因此重新运行</p><pre><code>./ngrok http 9006</code></pre><p>然后提交改正后的本地映射地址,结果发现又失败了，原来是本地响应微信发送的token验证接口有url后缀，所以重新生成时要加上对应接口的后缀,例如新生成的是<a href="http://c6e2a3bf.ngrok.io，则填http://c6e2a3bf.ngrok.io/wechat,另外本地同时要启动项目才能校验。至此就可以成功提交。" target="_blank" rel="noopener">http://c6e2a3bf.ngrok.io，则填http://c6e2a3bf.ngrok.io/wechat,另外本地同时要启动项目才能校验。至此就可以成功提交。</a></p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login" target="_blank" rel="noopener">https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login</a><br>【2】<a href="https://mp.weixin.qq.com/debug/" target="_blank" rel="noopener">https://mp.weixin.qq.com/debug/</a><br>【3】<a href="https://developers.weixin.qq.com/doc/offiaccount/Getting_Started/Overview.html" target="_blank" rel="noopener">https://developers.weixin.qq.com/doc/offiaccount/Getting_Started/Overview.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在测试号中配置接口URL和Token遇到的问题及解决方法&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Wechat" scheme="http://yoursite.com/tags/Wechat/"/>
    
  </entry>
  
  <entry>
    <title>601.Human Traffic of Stadium体育馆的人流量</title>
    <link href="http://yoursite.com/2020/01/20/601.Human%20Traffic%20of%20Stadium%E4%BD%93%E8%82%B2%E9%A6%86%E7%9A%84%E4%BA%BA%E6%B5%81%E9%87%8F/"/>
    <id>http://yoursite.com/2020/01/20/601.Human Traffic of Stadium体育馆的人流量/</id>
    <published>2020-01-20T06:10:12.000Z</published>
    <updated>2020-01-20T06:44:43.836Z</updated>
    
    <content type="html"><![CDATA[<p>查询连续递增的序列</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h1><p>在表 stadium 中查询人流量超过 100 的记录，将查询结果与其自身的临时表连接，再使用 WHERE 子句获得满足条件的记录。</p><p>第一步：查询人流量超过 100 的记录，然后将结果与其自身的临时表连接。<br>MySQL</p><pre><code>select distinct t1.*from stadium t1, stadium t2, stadium t3where t1.people &gt;= 100 and t2.people &gt;= 100 and t3.people &gt;= 100;</code></pre><p>共有 6 天人流量超过 100 人，笛卡尔积 后有 216（666） 条记录。</p><p>前 3 列来自表 t1，中间 3 列来自表 t2，最后 3 列来自表 t3。</p><p>表 t1，t2 和 t3 相同，需要考虑添加哪些条件能够得到想要的结果。以 t1 为例，它有可能是高峰期的第 1 天，第 2 天，或第 3 天。</p><p>t1 是高峰期第 1 天：</p><pre><code>(t1.id - t2.id = -1 and t1.id - t3.id = -2 and t2.id - t3.id =-1) -- t1, t2, t3</code></pre><p>t1 是高峰期第 2 天：</p><pre><code>(t2.id - t1.id = -1 and t2.id - t3.id = -2 and t1.id - t3.id =-1) -- t2, t1, t3</code></pre><p>t1 是高峰期第 3 天：</p><pre><code>(t3.id - t2.id = -1 and t2.id - t1.id =-1 and t3.id - t1.id = -2) -- t3, t2, t1</code></pre><p>因此：</p><pre><code>select t1.*from stadium t1, stadium t2, stadium t3where t1.people &gt;= 100 and t2.people &gt;= 100 and t3.people &gt;= 100and(  (t1.id - t2.id = -1 and t1.id - t3.id = -2 and t2.id - t3.id =-1)  -- t1, t2, t3  or  (t2.id - t1.id = -1 and t2.id - t3.id = -2 and t1.id - t3.id =-1) -- t2, t1, t3  or  (t3.id - t2.id = -1 and t2.id - t1.id =-1 and t3.id - t1.id = -2) -- t3, t2, t1);| id | date       | people ||----|------------|--------|| 7  | 2017-01-07 | 199    || 6  | 2017-01-06 | 1455   || 8  | 2017-01-08 | 188    || 7  | 2017-01-07 | 199    || 5  | 2017-01-05 | 145    || 6  | 2017-01-06 | 1455   |</code></pre><p>可以看到查询结果中存在重复的记录，再使用 DISTINCT 去重。</p><pre><code>select distinct t1.*from stadium t1, stadium t2, stadium t3where t1.people &gt;= 100 and t2.people &gt;= 100 and t3.people &gt;= 100and(      (t1.id - t2.id = -1 and t1.id - t3.id = -2 and t2.id - t3.id =-1)  -- t1, t2, t3    or    (t2.id - t1.id = -1 and t2.id - t3.id = -2 and t1.id - t3.id =-1) -- t2, t1, t3    or    (t3.id - t2.id = -1 and t2.id - t1.id =-1 and t3.id - t1.id = -2) -- t3, t2, t1)order by t1.id;</code></pre><p>此题官方题解貌似把t1,t2,t3的id前后顺序搞反了，不过也不影响执行结果。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://leetcode.com/problems/human-traffic-of-stadium/" target="_blank" rel="noopener">https://leetcode.com/problems/human-traffic-of-stadium/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;查询连续递增的序列&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Database" scheme="http://yoursite.com/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>185.Department Top Three Salaries</title>
    <link href="http://yoursite.com/2020/01/20/185.Department%20Top%20Three%20Salaries/"/>
    <id>http://yoursite.com/2020/01/20/185.Department Top Three Salaries/</id>
    <published>2020-01-20T03:00:12.000Z</published>
    <updated>2020-01-20T06:11:12.950Z</updated>
    
    <content type="html"><![CDATA[<p>查询部门的薪酬前三高员工</p><a id="more"></a><h1 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h1><p>同184，只是本次查询的是薪酬前三高的员工，允许并列</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>首先参考之前的思路，先来查询中公司中占前三高的薪酬是多少,前三高意味着不超过三个比它的薪酬高：</p><pre><code>select e1.Name as &apos;Employee&apos;, e1.Salaryfrom Employee e1where 3 &gt;(    select count(distinct e2.Salary)    from Employee e2    where e2.Salary &gt; e1.Salary);</code></pre><p>查询结果：</p><pre><code>| Employee | Salary ||----------|--------|| Henry    | 80000  || Max      | 90000  || Randy    | 85000  |</code></pre><p>现在我们需要把员工和部门两张表连接起来：</p><p>MySQL：</p><pre><code>SELECT    d.Name AS &apos;Department&apos;, e1.Name AS &apos;Employee&apos;, e1.SalaryFROM    Employee e1        JOIN    Department d ON e1.DepartmentId = d.IdWHERE    3 &gt; (SELECT            COUNT(DISTINCT e2.Salary)        FROM            Employee e2        WHERE            e2.Salary &gt; e1.Salary                AND e1.DepartmentId = e2.DepartmentId        );</code></pre><p>即可查询到部门的薪酬前三高员工</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://leetcode.com/problems/department-top-three-salaries/" target="_blank" rel="noopener">https://leetcode.com/problems/department-top-three-salaries/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;查询部门的薪酬前三高员工&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Database" scheme="http://yoursite.com/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>数据库学习笔记IX</title>
    <link href="http://yoursite.com/2020/01/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0IX/"/>
    <id>http://yoursite.com/2020/01/19/数据库学习笔记IX/</id>
    <published>2020-01-19T09:51:12.000Z</published>
    <updated>2020-01-20T02:48:34.345Z</updated>
    
    <content type="html"><![CDATA[<p>rank，row_number，dense_rank，ntile函数的用法  </p><a id="more"></a><h1 id="rank函数"><a href="#rank函数" class="headerlink" title="rank函数"></a>rank函数</h1><p>　　rank函数用于返回结果集的分区内每行的排名， 行的排名是相关行之前的排名数加一。简单来说rank函数就是对查询出来的记录进行排名，与row_number函数不同的是，rank函数考虑到了over子句中排序字段值相同的情况，如果使用rank函数来生成序号，over子句中排序字段值相同的序号是一样的，后面字段值不相同的序号将跳过相同的排名号排下一个，也就是相关行之前的排名数加一，可以理解为根据当前的记录数生成序号，后面的记录依此类推。</p><pre><code>select * ,RANK() OVER(order by column_name) as rankfrom table_name</code></pre><p>练习题目：<a href="https://leetcode.com/problems/rank-scores/" target="_blank" rel="noopener">https://leetcode.com/problems/rank-scores/</a></p><h2 id="rank函数进行分组"><a href="#rank函数进行分组" class="headerlink" title="rank函数进行分组"></a>rank函数进行分组</h2><pre><code>a           b           c----------- ----------- ----1           3           E2           4           A3           2           D3           5           B4           2           C2           4           B</code></pre><p>以a,b进行分组，在每个组内以b进行排名。分了5个组，第2行跟第3行是一个组，其他的每行是一个组。在第2行与第3行的组内以b排名，并列为1</p><pre><code>SELECT * ,rank () OVER (PARTITION BY a,b ORDER BY b) rank FROM table_namea           b           c    rank----------- ----------- ---- --------------------1           3           E    12           4           A    12           4           B    13           2           D    13           5           B    14           2           C    1</code></pre><p>以a,b进行分组，在每个组内以c进行排名。分了5个组，第2行跟第3行是一个组，其他的每行是一个组。在第2行与第3行的组内以c排名，由于c列一个是A，一个是B，所以Rank分别为1、2。</p><pre><code>SELECT * ,rank () OVER (PARTITION BY a,b ORDER BY c) rank FROM table_namea           b           c    rank----------- ----------- ---- --------------------1           3           E    12           4           A    12           4           B    23           2           D    13           5           B    14           2           C    1</code></pre><p>总结：<br>1、partition  by用于给结果集分组，如果没有指定那么它把整个结果集作为一个分组。</p><p>2、Rank 是在每个分组内部进行排名的。</p><h2 id="在MySQL中实现Rank函数"><a href="#在MySQL中实现Rank函数" class="headerlink" title="在MySQL中实现Rank函数"></a>在MySQL中实现Rank函数</h2><p>在MySQL中没有rank函数，所以我们要自己用普通的查询语句来实现排序功能。这部分可以参见参考资料【2】：《在MySQL中实现Rank高级排名函数》</p><h1 id="row-number函数"><a href="#row-number函数" class="headerlink" title="row_number函数"></a>row_number函数</h1><p>　　row_number的用途的非常广泛，一般可以用来实现web程序的分页，为查询出来的每一行记录生成一个序号，依次排序且不会重复，注意使用row_number函数时必须要用over子句选择对某一列进行排序才能生成序号。row_number用法实例:</p><pre><code>select ROW_NUMBER()OVER(order by column_name desc) as row_num,* from table_name</code></pre><h1 id="dense-rank函数"><a href="#dense-rank函数" class="headerlink" title="dense_rank函数"></a>dense_rank函数</h1><p>　　dense_rank函数的功能与rank函数类似，dense_rank函数在生成序号时是连续的，而rank函数生成的序号有可能不连续。dense_rank函数出现相同排名时，将不跳过相同排名号，rank值紧接上一次的rank值。在各个分组内，rank()是跳跃排序，有两个第一名时接下来就是第四名，dense_rank()是连续排序，有两个第一名时仍然跟着第二名。将上面的Sql语句改由dense_rank函数来实现。</p><pre><code>select * ,DENSE_RANK() OVER(order by column_name) as den_rankfrom table_name</code></pre><h1 id="ntile函数"><a href="#ntile函数" class="headerlink" title="ntile函数"></a>ntile函数</h1><p>　　ntile函数可以对序号进行分组处理，将有序分区中的行分发到指定数目的组中。 各个组有编号，编号从一开始。 对于每一个行，ntile 将返回此行所属的组的编号。这就相当于将查询出来的记录集放到指定长度的数组中，每一个数组元素存放一定数量的记录。ntile函数为每条记录生成的序号就是这条记录所有的数组元素的索引（从1开始）。也可以将每一个分配记录的数组元素称为“桶”。ntile函数有一个参数，用来指定桶数。下面的SQL语句使用ntile函数对Order表进行了装桶处理：</p><pre><code>select * ,NTILE(4) OVER(order by column_name) as ntilefrom table_name</code></pre><p>　　如果表的总记录数是6条，而上面的Sql语句ntile函数指定的组数是4，那么Sql Server2005是怎么来决定每一组应该分多少条记录呢？这里我们就需要了解ntile函数的分组依据（约定）。</p><p>　　ntile函数的分组依据（约定）：</p><p>　　1、每组的记录数不能大于它上一组的记录数，即编号小的桶放的记录数不能小于编号大的桶。也就是说，第1组中的记录数只能大于等于第2组及以后各组中的记录数。</p><p>　　2、所有组中的记录数要么都相同，要么从某一个记录较少的组（命名为X）开始后面所有组的记录数都与该组（X组）的记录数相同。也就是说，如果有个组，前三组的记录数都是9，而第四组的记录数是8，那么第五组和第六组的记录数也必须是8。</p><p>　　这里对约定2进行详细说明一下，以便于更好的理解。</p><p>　　首先系统会去检查能不能对所有满足条件的记录进行平均分组，若能则直接平均分配就完成分组了；若不能，则会先分出一个组，这个组分多少条记录呢？就是 （总记录数/总组数）+1 条，之所以分配 （总记录数/总组数）+1 条是因为当不能进行平均分组时，总记录数%总组数肯定是有余的，又因为分组约定1，所以先分出去的组需要+1条。</p><p>　　分完之后系统会继续去比较余下的记录数和未分配的组数能不能进行平均分配，若能，则平均分配余下的记录；若不能，则再分出去一组，这个组的记录数也是（总记录数/总组数）+1条。</p><p>　　然后系统继续去比较余下的记录数和未分配的组数能不能进行平均分配，若能，则平均分配余下的记录；若还是不能，则再分配出去一组，继续比较余下的……这样一直进行下去，直至分组完成。</p><p>　　举个例子，将51条记录分配成5组，51%5==1不能平均分配，则先分出去一组（51/5）+1=11条记录，然后比较余下的 51-11=40 条记录能否平均分配给未分配的4组，能平均分配，则剩下的4组，每组各40/4=10 条记录，分配完成，分配结果为：11，10，10，10，10</p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>   在使用排名函数的时候需要注意以下三点：</p><p>　　1、排名函数必须有 OVER 子句。</p><p>　　2、排名函数必须有包含 ORDER BY 的 OVER 子句。</p><p>　　3、分组内从1开始排序。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】 <a href="https://www.cnblogs.com/52XF/p/4209211.html" target="_blank" rel="noopener">https://www.cnblogs.com/52XF/p/4209211.html</a><br>【2】 <a href="https://www.jianshu.com/p/bb1b72a1623e" target="_blank" rel="noopener">https://www.jianshu.com/p/bb1b72a1623e</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;rank，row_number，dense_rank，ntile函数的用法  &lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Database，MySQL" scheme="http://yoursite.com/tags/Database%EF%BC%8CMySQL/"/>
    
  </entry>
  
  <entry>
    <title>184.Department Highest Salary</title>
    <link href="http://yoursite.com/2020/01/19/184.Department%20Highest%20Salary/"/>
    <id>http://yoursite.com/2020/01/19/184.Department Highest Salary/</id>
    <published>2020-01-19T07:52:12.000Z</published>
    <updated>2020-01-20T03:02:49.176Z</updated>
    
    <content type="html"><![CDATA[<p>查询部门的最高薪水，MAX，IN和GROUP BY语句的使用</p><a id="more"></a><h1 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h1><p>The Employee table holds all employees. Every employee has an Id, a salary, and there is also a column for the department Id.</p><pre><code>+----+-------+--------+--------------+| Id | Name  | Salary | DepartmentId |+----+-------+--------+--------------+| 1  | Joe   | 70000  | 1            || 2  | Jim   | 90000  | 1            || 3  | Henry | 80000  | 2            || 4  | Sam   | 60000  | 2            || 5  | Max   | 90000  | 1            |+----+-------+--------+--------------+</code></pre><p>The Department table holds all departments of the company.</p><pre><code>+----+----------+| Id | Name     |+----+----------+| 1  | IT       || 2  | Sales    |+----+----------+</code></pre><p>Write a SQL query to find employees who have the highest salary in each of the departments. For the above tables, your SQL query should return the following rows (order of rows does not matter).</p><pre><code>+------------+----------+--------+| Department | Employee | Salary |+------------+----------+--------+| IT         | Max      | 90000  || IT         | Jim      | 90000  || Sales      | Henry    | 80000  |+------------+----------+--------+</code></pre><p>Explanation:</p><p>Max and Jim both have the highest salary in the IT department and Henry has the highest salary in the Sales department.</p><h1 id="最开始想到的解法（错误）："><a href="#最开始想到的解法（错误）：" class="headerlink" title="最开始想到的解法（错误）："></a>最开始想到的解法（错误）：</h1><pre><code>select Department.Name as Department,Employee.Name as Employee ,MAX(Employee.Salary) as Salaryfrom Employeejoin Departmenton Employee.DepartmentId=Department.idgroup by Employee.DepartmentId</code></pre><p>换成</p><pre><code>select *from Employeejoin Departmenton Employee.DepartmentId=Department.idgroup by Employee.DepartmentId</code></pre><p>看了一下实际查询到的结果如下。</p><pre><code>{&quot;headers&quot;:[&quot;Id&quot;, &quot;Name&quot;, &quot;Salary&quot;, &quot;DepartmentId&quot;, &quot;Id&quot;, &quot;Name&quot;],&quot;values&quot;:[[1, &quot;Joe&quot;, 70000, 1, 1, &quot;IT&quot;],[3, &quot;Henry&quot;, 80000, 2, 2, &quot;Sales&quot;]]}</code></pre><p>发现是group by语句用错了，group by是用来根据一个或多个列对结果集进行分组</p><h1 id="正确解法："><a href="#正确解法：" class="headerlink" title="正确解法："></a>正确解法：</h1><p>可以换个思路，我们先来查询每个部门的最高薪水：</p><pre><code>SELECT    DepartmentId, MAX(Salary)FROM    EmployeeGROUP BY DepartmentId;</code></pre><p>查到的结果：</p><pre><code>| DepartmentId | MAX(Salary) ||--------------|-------------|| 1            | 90000       || 2            | 80000       |</code></pre><p>现在连接两张表，然后使用in语句把所有满足上面情况的雇员信息筛选出来：</p><pre><code>SELECT    Department.name AS &apos;Department&apos;,    Employee.name AS &apos;Employee&apos;,    SalaryFROM    Employee        JOIN    Department ON Employee.DepartmentId = Department.IdWHERE    (Employee.DepartmentId , Salary) IN    (   SELECT            DepartmentId, MAX(Salary)        FROM            Employee        GROUP BY DepartmentId    );</code></pre><p>查询结果：</p><pre><code>| Department | Employee | Salary ||------------|----------|--------|| Sales      | Henry    | 80000  || IT         | Max      | 90000  |   </code></pre><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://leetcode.com/problems/department-highest-salary/" target="_blank" rel="noopener">https://leetcode.com/problems/department-highest-salary/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;查询部门的最高薪水，MAX，IN和GROUP BY语句的使用&lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Database" scheme="http://yoursite.com/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>数据库学习笔记VIII</title>
    <link href="http://yoursite.com/2020/01/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0VIII/"/>
    <id>http://yoursite.com/2020/01/17/数据库学习笔记VIII/</id>
    <published>2020-01-17T09:51:12.000Z</published>
    <updated>2020-01-19T09:04:25.389Z</updated>
    
    <content type="html"><![CDATA[<p>MS SQL Server和MySQL区别  </p><a id="more"></a><h1 id="MS-SQL-Server和MySQL区别"><a href="#MS-SQL-Server和MySQL区别" class="headerlink" title="MS SQL Server和MySQL区别"></a>MS SQL Server和MySQL区别</h1><p>MySQL支持enum,和set类型，SQL Server不支持</p><p>MySQL不支持nchar,nvarchar,ntext类型</p><p>MySQL的递增语句是AUTO_INCREMENT，而MS SQL是identity(1,1)</p><p>MS SQL不支持replace into 语句，但是在最新的sql20008里面，也支持merge语法</p><p>MySQL支持insert into table1 set t1 = “”, t2 = “”,但是MSSQL不支持这样写</p><p>MySQL支持insert into tabl1 values (1,1), (1,1), (1,1),(1,1),(1,1), (1,1), (1,1)</p><p>MS SQL不支持limit语句，是非常遗憾的，只能用top 取代limt0,N，row_number()over()函数取代limit N,M</p><p>MySQL在创建表时要为每个表指定一个存储引擎类型，而MS SQL只支持一种存储引擎</p><p>PHP连接MySQL和MS SQL的方式都差不多，只需要将函数的MySQL替换成MS SQL即可。</p><p>MySQL的管理工具有几个比较好的，MySQL_front,和官方那个套件，不过都没有SSMS的使用方便，这是MySQL很大的一个缺点。</p><p>MySQL需要为表指定存储类型</p><p>MS SQL识别符是,[type]表示他区别于关键字，但是MySQL却是 `，也就是按键1左边的那个符号</p><p>MSSQL支持getdate()方法获取当前时间日期，但是MySQL里面可以分日期类型和时间类型，获取当前日期是cur_date()，当前完整时间是now()函数</p><p>MySQL不支持默认值为当前时间的datetime类型（MSSQL很容易做到），在MySQL里面是用timestamp类型</p><p>MS SQL里面检查是否有这个表再删除，需要这样：<br>    　　if exists (select * from dbo.systs<br>    where id = t_id(N”uc_newpm”)andTPROPERTY(id,N”IsUserTable”)=1)<br>　　但是在MySQL里面只需要 DROP TABLE IF EXISTS cdb_forums;</p><p>MySQL text字段类型不允许有默认值</p><p>MySQL的一个表的总共字段长度不超过65XXX。</p><p>MS SQL默认到处表创建语句的默认值表示是((0)),而在MySQL里面是不允许带两括号的</p><p>同样的负载压力，MySQL要消耗更少的CPU和内存，MS SQL的确是很耗资源。</p><p>MySQL支持无符号型的整数，那么比不支持无符号型的MS SQL就能多出一倍的最大数存储</p><p>MySQL不支持在MSSQL里面使用非常方便的varchar(max)类型，这个类型在MSSQL里面既可做一般数据存储，也可以做blob数据存储</p><p>MySQL创建非聚集索引只需要在创建表的时候指定为key就行，比如：KEYdisplayorder(fid,displayorder) 在MS SQL里面必须要：</p><p>  　　create unique nonclustered index<br>  　　index_uc_protectedmrs_username_appid on dbo.uc_protectedmrs<br>  　　(username asc,appid asc)<br>一个很表面的区别就是MySQL的安装特别简单，而且文件大小才110M（非安装版）</p><p>MySQL的存储过程只是出现在最新的版本中，稳定性和性能可能不如MS SQL。</p><p>MySQL支持date,time,year类型，MS SQL到2008才支持date和time。</p><p>#参考资料<br>【1】 <a href="https://blog.csdn.net/xc_zhou/article/details/89002519" target="_blank" rel="noopener">https://blog.csdn.net/xc_zhou/article/details/89002519</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MS SQL Server和MySQL区别  &lt;/p&gt;
    
    </summary>
    
      <category term="2020年1月" scheme="http://yoursite.com/categories/2020%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Database，MySQL" scheme="http://yoursite.com/tags/Database%EF%BC%8CMySQL/"/>
    
  </entry>
  
</feed>
