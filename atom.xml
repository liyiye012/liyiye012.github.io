<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-07T09:35:40.395Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>215. 数组中的第K个最大元素</title>
    <link href="http://yoursite.com/2020/07/06/215.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2020/07/06/215. 数组中的第K个最大元素/</id>
    <published>2020-07-06T01:36:12.000Z</published>
    <updated>2020-07-07T09:35:40.395Z</updated>
    
    <content type="html"><![CDATA[<p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。此题比较经典，对于两种解法我还有些没吃透，需要再次认真温习。</p><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>示例 1:</p><pre><code>输入: [3,2,1,5,6,4] 和 k = 2输出: 5</code></pre><p>示例 2:</p><pre><code>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4</code></pre><p>说明:</p><pre><code>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</code></pre><h1 id="📖文字题解"><a href="#📖文字题解" class="headerlink" title="📖文字题解"></a>📖文字题解</h1><ul><li><p>约定：假设这里数组的长度为 <em>n</em>。</p></li><li><p>题目分析：本题希望我们返回数组排序之后的倒数第 <em>k</em> 个位置。</p></li></ul><h4 id="方法一：基于快速排序的选择方法"><a href="#方法一：基于快速排序的选择方法" class="headerlink" title="方法一：基于快速排序的选择方法"></a>方法一：基于快速排序的选择方法</h4><p><strong>思路和算法</strong></p><p>我们可以用快速排序来解决这个问题，先对原数组排序，再返回倒数第 <em>k</em> 个位置，这样平均时间复杂度是 O(nlogn)  ，但其实我们可以做的更快。</p><p>首先我们来回顾一下快速排序，这是一个典型的分治算法。我们对数组 a[l…r]做快速排序的过程是（参考《算法导论》）：</p><ul><li><strong>分解：</strong> 将数组 a[l…r] 「划分」成两个子数组 a[l…q-1]<br>、a[q+1…r]，使得 a[l…q-1]中的每个元素小于等于 <em>a[q]*，且 *a[q]</em> 小于等于a[q+1…r]中的每个元素。其中，计算下标 <em>q</em> 也是「划分」过程的一部分。</li><li><strong>解决：</strong> 通过递归调用快速排序，对子数组 a[l…q-1]<br>、a[q+1…r] 进行排序。</li><li><strong>合并：</strong> 因为子数组都是原址排序的，所以不需要进行合并操作，a[l…r]  已经有序。</li><li>上文中提到的 <strong>「划分」</strong> 过程是：从子数组 a[l…r]   中选择任意一个元素 <em>x</em> 作为主元，<strong>调整子数组的元素使得左边的元素都小于等于它，右边的元素都大于等于它，</strong> <em>x</em> 的最终位置就是 <em>q</em>。</li></ul><p>由此可以发现每次经过「划分」操作后，我们一定可以确定一个元素的最终位置，即 <em>x</em> 的最终位置为 <em>q</em>，并且保证 a[l…q-1] 中的每个元素小于等于 <em>a[q]*，且 *a[q]</em> 小于等于 a[q+1…r]中的每个元素。<strong>所以只要某次划分的 <em>q</em> 为倒数第 <em>k</em> 个下标的时候，我们就已经找到了答案。</strong> 我们只关心这一点，至于 a[l…q-1] 和a[q+1…r]  是否是有序的，我们不关心。</p><p>因此我们可以改进快速排序算法来解决这个问题：在分解的过程当中，我们会对子数组进行划分，如果划分得到的 <em>q</em> 正好就是我们需要的下标，就直接返回 <em>a[q]*；否则，如果 *q</em> 比目标下标小，就递归右子区间，否则递归左子区间。这样就可以把原来递归两个区间变成只递归一个区间，提高了时间效率。这就是「快速选择」算法。</p><p>我们知道快速排序的性能和「划分」出的子数组的长度密切相关。直观地理解如果每次规模为 <em>n</em> 的问题我们都划分成 <em>1</em> 和 <em>n - 1*，每次递归的时候又向 *n - 1</em> 的集合中递归，这种情况是最坏的，时间代价是 <em>O(n ^ 2)</em>。我们可以引入随机化来加速这个过程，它的时间代价的期望是 <em>O(n)</em>，证明过程可以参考「《算法导论》9.2：期望为线性的选择算法」。</p><p>我试了一下<code>Arrays.sort(nums);</code>居然也过了，因为题目并没有要求不能用库函数所以其实两行代码就能解决问题</p><p><strong>代码</strong></p><figure class="highlight cpp"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">quickSelect</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> q = randomPartition(a, l, r);</span><br><span class="line">        <span class="keyword">if</span> (q == index) &#123;</span><br><span class="line">            <span class="keyword">return</span> a[q];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> q &lt; index ? quickSelect(a, q + <span class="number">1</span>, r, index) : quickSelect(a, l, q - <span class="number">1</span>, index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">randomPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = rand() % (r - l + <span class="number">1</span>) + l;</span><br><span class="line">        swap(a[i], a[r]);</span><br><span class="line">        <span class="keyword">return</span> partition(a, l, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = a[r], i = l - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = l; j &lt; r; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt;= x) &#123;</span><br><span class="line">                swap(a[++i], a[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a[i + <span class="number">1</span>], a[r]);</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        srand(time(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span> quickSelect(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>, nums.size() - k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> quickSelect(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, nums.length - k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">quickSelect</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> q = randomPartition(a, l, r);</span><br><span class="line">        <span class="keyword">if</span> (q == index) &#123;</span><br><span class="line">            <span class="keyword">return</span> a[q];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> q &lt; index ? quickSelect(a, q + <span class="number">1</span>, r, index) : quickSelect(a, l, q - <span class="number">1</span>, index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">randomPartition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = random.nextInt(r - l + <span class="number">1</span>) + l;</span><br><span class="line">        swap(a, i, r);</span><br><span class="line">        <span class="keyword">return</span> partition(a, l, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = a[r], i = l - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = l; j &lt; r; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt;= x) &#123;</span><br><span class="line">                swap(a, ++i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a, i + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = a[r], i = l - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = l; j &lt; r; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[j] &lt;= x) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = a[++i];</span><br><span class="line">            a[i] = a[j], a[j] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t = a[i + <span class="number">1</span>];</span><br><span class="line">    a[i + <span class="number">1</span>] = a[r], a[r] = t;</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">randomPartition</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = rand() % (r - l + <span class="number">1</span>) + l;</span><br><span class="line">    <span class="keyword">int</span> t = a[i];</span><br><span class="line">    a[i] = a[r], a[r] = t;</span><br><span class="line">    <span class="keyword">return</span> partition(a, l, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quickSelect</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q = randomPartition(a, l, r);</span><br><span class="line">    <span class="keyword">if</span> (q == index) &#123;</span><br><span class="line">        <span class="keyword">return</span> a[q];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> q &lt; index ? quickSelect(a, q + <span class="number">1</span>, r, index)</span><br><span class="line">                         : quickSelect(a, l, q - <span class="number">1</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> quickSelect(nums, <span class="number">0</span>, numsSize - <span class="number">1</span>, numsSize - k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findKthLargest</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    <span class="keyword">return</span> quickSelect(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>, <span class="built_in">len</span>(nums)-k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSelect</span><span class="params">(a []<span class="keyword">int</span>, l, r, index <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    q := randomPartition(a, l, r)</span><br><span class="line">    <span class="keyword">if</span> q == index &#123;</span><br><span class="line">        <span class="keyword">return</span> a[q]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> q &lt; index &#123;</span><br><span class="line">        <span class="keyword">return</span> quickSelect(a, q + <span class="number">1</span>, r, index)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> quickSelect(a, l, q - <span class="number">1</span>, index)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomPartition</span><span class="params">(a []<span class="keyword">int</span>, l, r <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    i := rand.Int() % (r - l + <span class="number">1</span>) + l</span><br><span class="line">    a[i], a[r] = a[r], a[i]</span><br><span class="line">    <span class="keyword">return</span> partition(a, l, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(a []<span class="keyword">int</span>, l, r <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    x := a[r]</span><br><span class="line">    i := l - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j := l; j &lt; r; j++ &#123;</span><br><span class="line">        <span class="keyword">if</span> a[j] &lt;= x &#123;</span><br><span class="line">            i++</span><br><span class="line">            a[i], a[j] = a[j], a[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[i+<span class="number">1</span>], a[r] = a[r], a[i+<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(n)</em>，如上文所述，证明过程可以参考「《算法导论》9.2：期望为线性的选择算法」。</li><li>空间复杂度：O(logn)，递归使用栈空间的空间代价的期望为O(logn)。</li></ul><h4 id="方法二：基于堆排序的选择方法"><a href="#方法二：基于堆排序的选择方法" class="headerlink" title="方法二：基于堆排序的选择方法"></a>方法二：基于堆排序的选择方法</h4><p><strong>思路和算法</strong></p><p>我们也可以使用堆排序来解决这个问题——建立一个大根堆，做 <em>k - 1</em> 次删除操作后堆顶元素就是我们要找的答案。在很多语言中，都有优先队列或者堆的的容器可以直接使用，但是在面试中，面试官更倾向于让更面试者自己实现一个堆。所以建议读者掌握这里大根堆的实现方法，在这道题中尤其要搞懂「建堆」、「调整」和「删除」的过程。</p><p><strong>友情提醒：「堆排」在很多大公司的面试中都很常见，不了解的同学建议参考《算法导论》或者大家的数据结构教材，一定要学会这个知识点哦! ^_^</strong></p><p>  <a href="https://assets.leetcode-cn.com/solution-static/215/1.png" target="_blank" rel="noopener">fig1</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/2.png" target="_blank" rel="noopener">fig2</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/3.png" target="_blank" rel="noopener">fig3</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/4.png" target="_blank" rel="noopener">fig4</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/5.png" target="_blank" rel="noopener">fig5</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/6.png" target="_blank" rel="noopener">fig6</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/7.png" target="_blank" rel="noopener">fig7</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/8.png" target="_blank" rel="noopener">fig8</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/9.png" target="_blank" rel="noopener">fig9</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/10.png" target="_blank" rel="noopener">fig10</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/11.png" target="_blank" rel="noopener">fig11</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/12.png" target="_blank" rel="noopener">fig12</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/13.png" target="_blank" rel="noopener">fig13</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/14.png" target="_blank" rel="noopener">fig14</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/15.png" target="_blank" rel="noopener">fig15</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/16.png" target="_blank" rel="noopener">fig16</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/17.png" target="_blank" rel="noopener">fig17</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/18.png" target="_blank" rel="noopener">fig18</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/19.png" target="_blank" rel="noopener">fig19</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/20.png" target="_blank" rel="noopener">fig20</a> </p><p><strong>代码</strong></p><figure class="highlight cpp"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> i, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = i * <span class="number">2</span> + <span class="number">1</span>, r = i * <span class="number">2</span> + <span class="number">2</span>, largest = i;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; heapSize &amp;&amp; a[l] &gt; a[largest]) &#123;</span><br><span class="line">            largest = l;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (r &lt; heapSize &amp;&amp; a[r] &gt; a[largest]) &#123;</span><br><span class="line">            largest = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            swap(a[i], a[largest]);</span><br><span class="line">            maxHeapify(a, largest, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = heapSize / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            maxHeapify(a, i, heapSize);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> heapSize = nums.size();</span><br><span class="line">        buildMaxHeap(nums, heapSize);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt;= nums.size() - k + <span class="number">1</span>; --i) &#123;</span><br><span class="line">            swap(nums[<span class="number">0</span>], nums[i]);</span><br><span class="line">            --heapSize;</span><br><span class="line">            maxHeapify(nums, <span class="number">0</span>, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> heapSize = nums.length;</span><br><span class="line">        buildMaxHeap(nums, heapSize);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= nums.length - k + <span class="number">1</span>; --i) &#123;</span><br><span class="line">            swap(nums, <span class="number">0</span>, i);</span><br><span class="line">            --heapSize;</span><br><span class="line">            maxHeapify(nums, <span class="number">0</span>, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = heapSize / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            maxHeapify(a, i, heapSize);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = i * <span class="number">2</span> + <span class="number">1</span>, r = i * <span class="number">2</span> + <span class="number">2</span>, largest = i;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; heapSize &amp;&amp; a[l] &gt; a[largest]) &#123;</span><br><span class="line">            largest = l;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (r &lt; heapSize &amp;&amp; a[r] &gt; a[largest]) &#123;</span><br><span class="line">            largest = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            swap(a, i, largest);</span><br><span class="line">            maxHeapify(a, largest, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> i, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = i * <span class="number">2</span> + <span class="number">1</span>, r = i * <span class="number">2</span> + <span class="number">2</span>, largest = i;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; heapSize &amp;&amp; a[l] &gt; a[largest]) &#123;</span><br><span class="line">        largest = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; heapSize &amp;&amp; a[r] &gt; a[largest]) &#123;</span><br><span class="line">        largest = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = a[i];</span><br><span class="line">        a[i] = a[largest], a[largest] = t;</span><br><span class="line">        maxHeapify(a, largest, heapSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = heapSize / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        maxHeapify(a, i, heapSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> heapSize = numsSize;</span><br><span class="line">    buildMaxHeap(nums, heapSize);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = numsSize - <span class="number">1</span>; i &gt;= numsSize - k + <span class="number">1</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = nums[<span class="number">0</span>];</span><br><span class="line">        nums[<span class="number">0</span>] = nums[i], nums[i] = t;</span><br><span class="line">        --heapSize;</span><br><span class="line">        maxHeapify(nums, <span class="number">0</span>, heapSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findKthLargest</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    heapSize := <span class="built_in">len</span>(nums)</span><br><span class="line">    buildMaxHeap(nums, heapSize)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(nums) - <span class="number">1</span>; i &gt;= <span class="built_in">len</span>(nums) - k + <span class="number">1</span>; i-- &#123;</span><br><span class="line">        nums[<span class="number">0</span>], nums[i] = nums[i], nums[<span class="number">0</span>]</span><br><span class="line">        heapSize--</span><br><span class="line">        maxHeapify(nums, <span class="number">0</span>, heapSize)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildMaxHeap</span><span class="params">(a []<span class="keyword">int</span>, heapSize <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := heapSize/<span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        maxHeapify(a, i, heapSize)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxHeapify</span><span class="params">(a []<span class="keyword">int</span>, i, heapSize <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    l, r, largest := i * <span class="number">2</span> + <span class="number">1</span>, i * <span class="number">2</span> + <span class="number">2</span>, i</span><br><span class="line">    <span class="keyword">if</span> l &lt; heapSize &amp;&amp; a[l] &gt; a[largest] &#123;</span><br><span class="line">        largest = l</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> r &lt; heapSize &amp;&amp; a[r] &gt; a[largest] &#123;</span><br><span class="line">        largest = r</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> largest != i &#123;</span><br><span class="line">        a[i], a[largest] = a[largest], a[i]</span><br><span class="line">        maxHeapify(a, largest, heapSize)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(nlogn) ，建堆的时间代价是 <em>O(n)</em>，删除的总代价是 O(klogn) ，因为 <em>k &lt; n</em>，故渐进时间复杂为 O(n+klogn) 。</li><li>空间复杂度：O(nlogn)，即递归使用栈空间的空间代价。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。此题比较经典，对于两种解法我还有些没吃透，需要再次认真温习。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年7月" scheme="http://yoursite.com/categories/2020%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Heap" scheme="http://yoursite.com/tags/Heap/"/>
    
      <category term="Divide and Conquer" scheme="http://yoursite.com/tags/Divide-and-Conquer/"/>
    
  </entry>
  
  <entry>
    <title>238. 除自身以外数组的乘积</title>
    <link href="http://yoursite.com/2020/07/02/238.%20%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF/"/>
    <id>http://yoursite.com/2020/07/02/238. 除自身以外数组的乘积/</id>
    <published>2020-07-02T14:52:12.000Z</published>
    <updated>2020-07-02T14:38:21.897Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。</p><a id="more"></a><p>示例:</p><pre><code>输入: [1,2,3,4]输出: [24,12,8,6]提示：题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。</code></pre><p>进阶：</p><p>你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）</p><h3 id="📺视频题解"><a href="#📺视频题解" class="headerlink" title="📺视频题解"></a>📺视频题解</h3><p> <a href="5f8f385b-1288-4c91-8a65-e7490a96764c">238.除自身以外数组的乘积.mp4</a></p><h3 id="📖文字题解"><a href="#📖文字题解" class="headerlink" title="📖文字题解"></a>📖文字题解</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>这似乎是一个简单的问题，可以在线性时间和空间内解决。先计算给定数组所有元素的乘积，然后对数组中的每个元素 <em>x</em>，将总的乘积除以 <em>x</em> 来求得除自身值的以外数组的乘积。</p><p>然而这样的解决方法有一个问题，就是如果输入数组中出现 0，那么这个方法就失效了。而且在问题中说明了不允许使用除法运算。这增加了这个问题的难度。</p><h4 id="方法一：左右乘积列表"><a href="#方法一：左右乘积列表" class="headerlink" title="方法一：左右乘积列表"></a>方法一：左右乘积列表</h4><p><strong>思路</strong></p><p>我们不必将所有数字的乘积除以给定索引处的数字得到相应的答案，而是利用索引左侧所有数字的乘积和右侧所有数字的乘积（即前缀与后缀）相乘得到答案。</p><p>对于给定索引 <em>i</em>，我们将使用它左边所有数字的乘积乘以右边所有数字的乘积。下面让我们更加具体的描述这个算法。</p><p><strong>算法</strong></p><ol><li>初始化两个空数组 <code>L</code> 和 <code>R</code>。对于给定索引 <code>i</code>，<code>L[i]</code> 代表的是 <code>i</code> 左侧所有数字的乘积，<code>R[i]</code> 代表的是 <code>i</code> 右侧所有数字的乘积。</li><li>我们需要用两个循环来填充 <code>L</code> 和 <code>R</code> 数组的值。对于数组 <code>L</code>，<code>L[0]</code> 应该是 <code>1</code>，因为第一个元素的左边没有元素。对于其他元素：<code>L[i] = L[i-1] * nums[i-1]</code>。</li><li>同理，对于数组 <code>R</code>，<code>R[length-1]</code> 应为 <code>1</code>。<code>length</code> 指的是输入数组的大小。其他元素：<code>R[i] = R[i+1] * nums[i+1]</code>。</li><li>当 <code>R</code> 和 <code>L</code> 数组填充完成，我们只需要在输入数组上迭代，且索引 <code>i</code> 处的值为：<code>L[i] * R[i]</code>。</li></ol><p>让我们用以下图片看看算法是如何工作的：</p><p>  <a href="https://assets.leetcode-cn.com/solution-static/238/1.PNG" target="_blank" rel="noopener">fig1</a>  <a href="https://assets.leetcode-cn.com/solution-static/238/2.PNG" target="_blank" rel="noopener">fig2</a>  <a href="https://assets.leetcode-cn.com/solution-static/238/3.PNG" target="_blank" rel="noopener">fig3</a>  <a href="https://assets.leetcode-cn.com/solution-static/238/4.PNG" target="_blank" rel="noopener">fig4</a>  <a href="https://assets.leetcode-cn.com/solution-static/238/5.PNG" target="_blank" rel="noopener">fig5</a>  <a href="https://assets.leetcode-cn.com/solution-static/238/6.PNG" target="_blank" rel="noopener">fig6</a>  <a href="https://assets.leetcode-cn.com/solution-static/238/7.PNG" target="_blank" rel="noopener">fig7</a>  <a href="https://assets.leetcode-cn.com/solution-static/238/8.PNG" target="_blank" rel="noopener">fig8</a>  <a href="https://assets.leetcode-cn.com/solution-static/238/9.PNG" target="_blank" rel="noopener">fig9</a>  <a href="https://assets.leetcode-cn.com/solution-static/238/10.PNG" target="_blank" rel="noopener">fig10</a> </p><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; productExceptSelf(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// L 和 R 分别表示左右两侧的乘积列表</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; L(length, <span class="number">0</span>), R(length, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; answer(length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// L[i] 为索引 i 左侧所有元素的乘积</span></span><br><span class="line">        <span class="comment">// 对于索引为 '0' 的元素，因为左侧没有元素，所以 L[0] = 1</span></span><br><span class="line">        L[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            L[i] = nums[i - <span class="number">1</span>] * L[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// R[i] 为索引 i 右侧所有元素的乘积</span></span><br><span class="line">        <span class="comment">// 对于索引为 'length-1' 的元素，因为右侧没有元素，所以 R[length-1] = 1</span></span><br><span class="line">        R[length - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            R[i] = nums[i + <span class="number">1</span>] * R[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于索引 i，除 nums[i] 之外其余各元素的乘积就是左侧所有元素的乘积乘以右侧所有元素的乘积</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            answer[i] = L[i] * R[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        length = len(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># L 和 R 分别表示左右两侧的乘积列表</span></span><br><span class="line">        L, R, answer = [<span class="number">0</span>]*length, [<span class="number">0</span>]*length, [<span class="number">0</span>]*length</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># L[i] 为索引 i 左侧所有元素的乘积</span></span><br><span class="line">        <span class="comment"># 对于索引为 '0' 的元素，因为左侧没有元素，所以 L[0] = 1</span></span><br><span class="line">        L[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, length):</span><br><span class="line">            L[i] = nums[i - <span class="number">1</span>] * L[i - <span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># R[i] 为索引 i 右侧所有元素的乘积</span></span><br><span class="line">        <span class="comment"># 对于索引为 'length-1' 的元素，因为右侧没有元素，所以 R[length-1] = 1</span></span><br><span class="line">        R[length - <span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(length - <span class="number">1</span>)):</span><br><span class="line">            R[i] = nums[i + <span class="number">1</span>] * R[i + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对于索引 i，除 nums[i] 之外其余各元素的乘积就是左侧所有元素的乘积乘以右侧所有元素的乘积</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">            answer[i] = L[i] * R[i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// L 和 R 分别表示左右两侧的乘积列表</span></span><br><span class="line">        <span class="keyword">int</span>[] L = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">int</span>[] R = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// L[i] 为索引 i 左侧所有元素的乘积</span></span><br><span class="line">        <span class="comment">// 对于索引为 '0' 的元素，因为左侧没有元素，所以 L[0] = 1</span></span><br><span class="line">        L[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            L[i] = nums[i - <span class="number">1</span>] * L[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// R[i] 为索引 i 右侧所有元素的乘积</span></span><br><span class="line">        <span class="comment">// 对于索引为 'length-1' 的元素，因为右侧没有元素，所以 R[length-1] = 1</span></span><br><span class="line">        R[length - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            R[i] = nums[i + <span class="number">1</span>] * R[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于索引 i，除 nums[i] 之外其余各元素的乘积就是左侧所有元素的乘积乘以右侧所有元素的乘积</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            answer[i] = L[i] * R[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">productExceptSelf</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    length := <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// L 和 R 分别表示左右两侧的乘积列表</span></span><br><span class="line">    L, R, answer := <span class="built_in">make</span>([]<span class="keyword">int</span>, length), <span class="built_in">make</span>([]<span class="keyword">int</span>, length), <span class="built_in">make</span>([]<span class="keyword">int</span>, length)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// L[i] 为索引 i 左侧所有元素的乘积</span></span><br><span class="line">    <span class="comment">// 对于索引为 '0' 的元素，因为左侧没有元素，所以 L[0] = 1</span></span><br><span class="line">    L[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; length; i++ &#123;</span><br><span class="line">        L[i] = nums[i<span class="number">-1</span>] * L[i<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R[i] 为索引 i 右侧所有元素的乘积</span></span><br><span class="line">    <span class="comment">// 对于索引为 'length-1' 的元素，因为右侧没有元素，所以 R[length-1] = 1</span></span><br><span class="line">    R[length<span class="number">-1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        R[i] = nums[i+<span class="number">1</span>] * R[i+<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对于索引 i，除 nums[i] 之外其余各元素的乘积就是左侧所有元素的乘积乘以右侧所有元素的乘积</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line">        answer[i] = L[i] * R[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><figcaption><span>[sol1-TypeScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> productExceptSelf = <span class="function"><span class="keyword">function</span>(<span class="params">nums: <span class="built_in">number</span>[]</span>): <span class="title">number</span>[] </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> length = nums.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// L 和 R 分别表示左右两侧的乘积列表</span></span><br><span class="line">    <span class="keyword">const</span> L = <span class="keyword">new</span> <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt;(length);</span><br><span class="line">    <span class="keyword">const</span> R = <span class="keyword">new</span> <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt;(length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> answer = <span class="keyword">new</span> <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt;(length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// L[i] 为索引 i 左侧所有元素的乘积</span></span><br><span class="line">    <span class="comment">// 对于索引为 '0' 的元素，因为左侧没有元素，所以 L[0] = 1</span></span><br><span class="line">    L[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">        L[i] = nums[i - <span class="number">1</span>] * L[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R[i] 为索引 i 右侧所有元素的乘积</span></span><br><span class="line">    <span class="comment">// 对于索引为 'length-1' 的元素，因为右侧没有元素，所以 R[length-1] = 1</span></span><br><span class="line">    R[length - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        R[i] = nums[i + <span class="number">1</span>] * R[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于索引 i，除 nums[i] 之外其余各元素的乘积就是左侧所有元素的乘积乘以右侧所有元素的乘积</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        answer[i] = L[i] * R[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(N)*，其中 *N</em> 指的是数组 <code>nums</code> 的大小。预处理 <code>L</code> 和 <code>R</code> 数组以及最后的遍历计算都是 <em>O(N)</em> 的时间复杂度。</li><li>空间复杂度：<em>O(N)*，其中 *N</em> 指的是数组 <code>nums</code> 的大小。使用了 <code>L</code> 和 <code>R</code> 数组去构造答案，<code>L</code> 和 <code>R</code> 数组的长度为数组 <code>nums</code> 的大小。</li></ul><h4 id="方法二：空间复杂度-O-1-的方法"><a href="#方法二：空间复杂度-O-1-的方法" class="headerlink" title="方法二：空间复杂度 O(1) 的方法"></a>方法二：空间复杂度 <em>O(1)</em> 的方法</h4><p><strong>思路</strong></p><p>尽管上面的方法已经能够很好的解决这个问题，但是空间复杂度并不为常数。</p><p>由于输出数组不算在空间复杂度内，那么我们可以将 <code>L</code> 或 <code>R</code> 数组用输出数组来计算。先把输出数组当作 <code>L</code> 数组来计算，然后再动态构造 <code>R</code> 数组得到结果。让我们来看看基于这个思想的算法。</p><p><strong>算法</strong></p><ol><li>初始化 <code>answer</code> 数组，对于给定索引 <code>i</code>，<code>answer[i]</code> 代表的是 <code>i</code> 左侧所有数字的乘积。</li><li>构造方式与之前相同，只是我们试图节省空间，先把 <code>answer</code> 作为方法一的 <code>L</code> 数组。</li><li>这种方法的唯一变化就是我们没有构造 <code>R</code> 数组。而是用一个遍历来跟踪右边元素的乘积。并更新数组 <em>answer[i]=answer[i]<em>R</em>。然后 *R</em> 更新为 <em>R=R<em>nums[i]</em>，其中变量 *R</em> 表示的就是索引右侧数字的乘积。</li></ol><figure class="highlight cpp"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; productExceptSelf(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; answer(length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// answer[i] 表示索引 i 左侧所有元素的乘积</span></span><br><span class="line">        <span class="comment">// 因为索引为 '0' 的元素左侧没有元素， 所以 answer[0] = 1</span></span><br><span class="line">        answer[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            answer[i] = nums[i - <span class="number">1</span>] * answer[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// R 为右侧所有元素的乘积</span></span><br><span class="line">        <span class="comment">// 刚开始右边没有元素，所以 R = 1</span></span><br><span class="line">        <span class="keyword">int</span> R = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R</span></span><br><span class="line">            answer[i] = answer[i] * R;</span><br><span class="line">            <span class="comment">// R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上</span></span><br><span class="line">            R *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        length = len(nums)</span><br><span class="line">        answer = [<span class="number">0</span>]*length</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># answer[i] 表示索引 i 左侧所有元素的乘积</span></span><br><span class="line">        <span class="comment"># 因为索引为 '0' 的元素左侧没有元素， 所以 answer[0] = 1</span></span><br><span class="line">        answer[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, length):</span><br><span class="line">            answer[i] = nums[i - <span class="number">1</span>] * answer[i - <span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># R 为右侧所有元素的乘积</span></span><br><span class="line">        <span class="comment"># 刚开始右边没有元素，所以 R = 1</span></span><br><span class="line">        R = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(length)):</span><br><span class="line">            <span class="comment"># 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R</span></span><br><span class="line">            answer[i] = answer[i] * R</span><br><span class="line">            <span class="comment"># R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上</span></span><br><span class="line">            R *= nums[i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// answer[i] 表示索引 i 左侧所有元素的乘积</span></span><br><span class="line">        <span class="comment">// 因为索引为 '0' 的元素左侧没有元素， 所以 answer[0] = 1</span></span><br><span class="line">        answer[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            answer[i] = nums[i - <span class="number">1</span>] * answer[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// R 为右侧所有元素的乘积</span></span><br><span class="line">        <span class="comment">// 刚开始右边没有元素，所以 R = 1</span></span><br><span class="line">        <span class="keyword">int</span> R = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R</span></span><br><span class="line">            answer[i] = answer[i] * R;</span><br><span class="line">            <span class="comment">// R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上</span></span><br><span class="line">            R *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">productExceptSelf</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    length := <span class="built_in">len</span>(nums)</span><br><span class="line">    answer := <span class="built_in">make</span>([]<span class="keyword">int</span>, length)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// answer[i] 表示索引 i 左侧所有元素的乘积</span></span><br><span class="line">    <span class="comment">// 因为索引为 '0' 的元素左侧没有元素， 所以 answer[0] = 1</span></span><br><span class="line">    answer[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; length; i++ &#123;</span><br><span class="line">        answer[i] = nums[i<span class="number">-1</span>] * answer[i<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R 为右侧所有元素的乘积</span></span><br><span class="line">    <span class="comment">// 刚开始右边没有元素，所以 R = 1</span></span><br><span class="line">    R := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="comment">// 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R</span></span><br><span class="line">        answer[i] = answer[i] * R</span><br><span class="line">        <span class="comment">// R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上</span></span><br><span class="line">        R *= nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><figcaption><span>[sol2-TypeScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> productExceptSelf = <span class="function"><span class="keyword">function</span>(<span class="params">nums: <span class="built_in">number</span>[]</span>): <span class="title">number</span>[] </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> length = nums.length;</span><br><span class="line">    <span class="keyword">const</span> answer = <span class="keyword">new</span> <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt;(length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// answer[i] 表示索引 i 左侧所有元素的乘积</span></span><br><span class="line">    <span class="comment">// 因为索引为 '0' 的元素左侧没有元素， 所以 answer[0] = 1</span></span><br><span class="line">    answer[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">        answer[i] = nums[i - <span class="number">1</span>] * answer[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R 为右侧所有元素的乘积</span></span><br><span class="line">    <span class="comment">// 刚开始右边没有元素，所以 R = 1</span></span><br><span class="line">    <span class="keyword">let</span> R = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R</span></span><br><span class="line">        answer[i] = answer[i] * R;</span><br><span class="line">        <span class="comment">// R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上</span></span><br><span class="line">        R *= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(N)*，其中 *N</em> 指的是数组 <code>nums</code> 的大小。分析与方法一相同。</li><li>空间复杂度：<em>O(1)</em>，输出数组不算进空间复杂度中，因此我们只需要常数的空间存放变量。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你一个长度为 n 的整数数组 nums，其中 n &amp;gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年7月" scheme="http://yoursite.com/categories/2020%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>155. 最小栈</title>
    <link href="http://yoursite.com/2020/07/02/155.%20%20%E6%9C%80%E5%B0%8F%E6%A0%88/"/>
    <id>http://yoursite.com/2020/07/02/155.  最小栈/</id>
    <published>2020-07-02T14:36:12.000Z</published>
    <updated>2020-07-06T01:04:42.706Z</updated>
    
    <content type="html"><![CDATA[<p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p><a id="more"></a><h1 id="题目描述（简单难度）"><a href="#题目描述（简单难度）" class="headerlink" title="题目描述（简单难度）"></a>题目描述（简单难度）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push(x) —— 将元素 x 推入栈中。</span><br><span class="line">pop() —— 删除栈顶的元素。</span><br><span class="line">top() —— 获取栈顶元素。</span><br><span class="line">getMin() —— 检索栈中的最小元素。</span><br></pre></td></tr></table></figure><p>示例:</p><pre><code>输入：[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;][[],[-2],[0],[-3],[],[],[],[]]输出：[null,null,null,null,-3,null,0,-2]解释：MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin();   --&gt; 返回 -3.minStack.pop();minStack.top();      --&gt; 返回 0.minStack.getMin();   --&gt; 返回 -2.</code></pre><p>提示：</p><p>pop、top 和 getMin 操作总是在 非空栈 上调用。</p><p>最初的想法是用两个栈来实现，pop,push和top可用stack自带的pop,push和peek函数来实现，然后每次找最小值时都将一个栈中元素倒豆子一样倒进另一个栈中，此过程中获得最小值，之后再倒回去，但这种方法超时了。</p><h1 id="解法一-1"><a href="#解法一-1" class="headerlink" title="解法一^1"></a>解法一<a href="https://leetcode.wang" target="_blank" rel="noopener">^1</a></h1><p>要实现一个 <code>stack</code>，那么我们还能用 <code>java</code> 自带的 <code>stack</code> 吗？也不用纠结，这道题的关键其实是实现「得到最小值这个功能」，所以为了代码简洁些，我们就直接使用系统自带的 <code>stack</code> 了。</p><p>这道题最直接的解法就是我们可以用两个栈，一个栈去保存正常的入栈出栈的值，另一个栈去存最小值，也就是用栈顶保存当前所有元素的最小值。存最小值的栈的具体操作流程如下：</p><p>将第一个元素入栈。</p><p>新加入的元素如果大于栈顶元素，那么新加入的元素就不处理。</p><p>新加入的元素如果小于等于栈顶元素，那么就将新元素入栈。</p><p>出栈元素不等于栈顶元素，不操作。</p><p>出栈元素等于栈顶元素，那么就将栈顶元素出栈。</p><p>举个例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">入栈 <span class="number">3</span> </span><br><span class="line">|   |    |   |</span><br><span class="line">|   |    |   |</span><br><span class="line">|_3_|    |_3_|</span><br><span class="line">stack  minStack</span><br><span class="line"></span><br><span class="line">入栈 <span class="number">5</span> ， <span class="number">5</span> 大于 minStack 栈顶，不处理</span><br><span class="line">|   |    |   |</span><br><span class="line">| <span class="number">5</span> |    |   |</span><br><span class="line">|_3_|    |_3_|</span><br><span class="line">stack  minStack</span><br><span class="line"></span><br><span class="line">入栈 <span class="number">2</span> ，此时右边的 minStack 栈顶就保存了当前最小值 <span class="number">2</span> </span><br><span class="line">| <span class="number">2</span> |    |   |</span><br><span class="line">| <span class="number">5</span> |    | <span class="number">2</span> |</span><br><span class="line">|_3_|    |_3_|</span><br><span class="line">stack  minStack</span><br><span class="line"></span><br><span class="line">出栈 <span class="number">2</span>，此时右边的 minStack 栈顶就保存了当前最小值 <span class="number">3</span></span><br><span class="line">|   |    |   |</span><br><span class="line">| <span class="number">5</span> |    |   |</span><br><span class="line">|_3_|    |_3_|</span><br><span class="line">stack  minStack</span><br><span class="line"></span><br><span class="line">出栈 <span class="number">5</span>，右边 minStack 不处理</span><br><span class="line">|   |    |   |</span><br><span class="line">|   |    |   |</span><br><span class="line">|_3_|    |_3_|</span><br><span class="line">stack  minStack</span><br><span class="line"></span><br><span class="line">出栈 <span class="number">3</span></span><br><span class="line">|   |    |   |</span><br><span class="line">|   |    |   |</span><br><span class="line">|_ _|    |_ _|</span><br><span class="line">stack  minStack</span><br></pre></td></tr></table></figure><p>代码的话就很好写了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minStack;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line">        <span class="keyword">if</span> (!minStack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> top = minStack.peek();</span><br><span class="line">            <span class="comment">//小于的时候才入栈</span></span><br><span class="line">            <span class="keyword">if</span> (x &lt;= top) &#123;</span><br><span class="line">                minStack.push(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            minStack.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pop = stack.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> top = minStack.peek();</span><br><span class="line">        <span class="comment">//等于的时候再出栈</span></span><br><span class="line">        <span class="comment">//此处不能写作if(minStack.peek() == stack.peek())否则判断不生效</span></span><br><span class="line">        <span class="comment">//因为包装类型间的相等判断应该用equals而非==</span></span><br><span class="line">        <span class="keyword">if</span> (pop == top) &#123;</span><br><span class="line">            minStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我犯了一个错误 </p><p>出栈操作判断时不能写作<code>if(minStack.peek() == stack.peek())</code>否则判断不生效,因为包装类型间的相等判断应该用equals而非==</p><h1 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h1><p>解法一中用了两个栈去实现，那么我们能不能用一个栈去实现呢？</p><p>参考了  <a href="https://leetcode.com/problems/min-stack/discuss/49014/Java-accepted-solution-using-one-stack" target="_blank" rel="noopener">这里</a>。</p><p>解法一中单独用了一个栈去保存所有最小值，那么我们能不能只用一个变量去保存最小值呢？</p><p>再看一下上边的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">入栈 <span class="number">3</span> </span><br><span class="line">|   |   min = <span class="number">3</span></span><br><span class="line">|   |     </span><br><span class="line">|_3_|    </span><br><span class="line">stack   </span><br><span class="line"></span><br><span class="line">入栈 <span class="number">5</span> </span><br><span class="line">|   |   min = <span class="number">3</span></span><br><span class="line">| <span class="number">5</span> |     </span><br><span class="line">|_3_|    </span><br><span class="line">stack  </span><br><span class="line"></span><br><span class="line">入栈 <span class="number">2</span> </span><br><span class="line">| <span class="number">2</span> |   min = <span class="number">2</span>?</span><br><span class="line">| <span class="number">5</span> |     </span><br><span class="line">|_3_|    </span><br><span class="line">stack</span><br></pre></td></tr></table></figure><p>如果只用一个变量就会遇到一个问题，如果把 <code>min</code> 更新为 <code>2</code>，那么之前的最小值 <code>3</code> 就丢失了。</p><p>怎么把 <code>3</code> 保存起来呢？把它在 <code>2</code> 之前压入栈中即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">入栈 <span class="number">2</span> ，同时将之前的 min 值 <span class="number">3</span> 入栈，再把 <span class="number">2</span> 入栈，同时更新 min = <span class="number">2</span></span><br><span class="line">| <span class="number">2</span> |   min = <span class="number">2</span></span><br><span class="line">| <span class="number">3</span> |  </span><br><span class="line">| <span class="number">5</span> |     </span><br><span class="line">|_3_|    </span><br><span class="line">stack  </span><br><span class="line"></span><br><span class="line">入栈 <span class="number">6</span> </span><br><span class="line">| <span class="number">6</span> |  min = <span class="number">2</span></span><br><span class="line">| <span class="number">2</span> |   </span><br><span class="line">| <span class="number">3</span> |  </span><br><span class="line">| <span class="number">5</span> |     </span><br><span class="line">|_3_|    </span><br><span class="line">stack  </span><br><span class="line"></span><br><span class="line">出栈 <span class="number">6</span>     </span><br><span class="line">| <span class="number">2</span> |   min = <span class="number">2</span></span><br><span class="line">| <span class="number">3</span> |  </span><br><span class="line">| <span class="number">5</span> |     </span><br><span class="line">|_3_|    </span><br><span class="line">stack  </span><br><span class="line"></span><br><span class="line">出栈 <span class="number">2</span>     </span><br><span class="line">| <span class="number">2</span> |   min = <span class="number">2</span></span><br><span class="line">| <span class="number">3</span> |  </span><br><span class="line">| <span class="number">5</span> |     </span><br><span class="line">|_3_|    </span><br><span class="line">stack</span><br></pre></td></tr></table></figure><p>上边的最后一个状态，当出栈元素是最小元素我们该如何处理呢？</p><p>我们只需要把 <code>2</code> 出栈，然后再出栈一次，把 <code>3</code> 赋值给 <code>min</code> 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">出栈 <span class="number">2</span>     </span><br><span class="line">|   |  min = <span class="number">3</span>   </span><br><span class="line">| <span class="number">5</span> |   </span><br><span class="line">|_3_|    </span><br><span class="line">stack</span><br></pre></td></tr></table></figure><p>通过上边的方式，我们就只需要一个栈了。当有更小的值来的时候，我们只需要把之前的最小值入栈，当前更小的值再入栈即可。当这个最小值要出栈的时候，下一个值便是之前的最小值了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当前值更小</span></span><br><span class="line">        <span class="keyword">if</span>(x &lt;= min)&#123;   </span><br><span class="line">            <span class="comment">//将之前的最小值保存</span></span><br><span class="line">            stack.push(min);</span><br><span class="line">            <span class="comment">//更新最小值</span></span><br><span class="line">            min=x;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果弹出的值是最小值，那么将下一个元素更新为最小值</span></span><br><span class="line">        <span class="keyword">if</span>(stack.pop() == min) &#123;</span><br><span class="line">            min=stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h1><p>参考 <a href="https://leetcode.com/problems/min-stack/discuss/49031/Share-my-Java-solution-with-ONLY-ONE-stack" target="_blank" rel="noopener">这里</a>，再分享利用一个栈的另一种思路。</p><p>通过解法二的分析，我们关键要解决的问题就是当有新的更小值的时候，之前的最小值该怎么办？</p><p>解法二中通过把之前的最小值入栈解决问题。</p><p>这里的话，用了另一种思路。同样是用一个 <code>min</code> 变量保存最小值。只不过栈里边我们不去保存原来的值，而是去存储入栈的值和最小值的差值。然后得到之前的最小值的话，我们就可以通过 <code>min</code> 值和栈顶元素得到，举个例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">入栈 <span class="number">3</span>，存入 <span class="number">3</span> - <span class="number">3</span> = <span class="number">0</span></span><br><span class="line">|   |   min = <span class="number">3</span></span><br><span class="line">|   |     </span><br><span class="line">|_0_|    </span><br><span class="line">stack   </span><br><span class="line"></span><br><span class="line">入栈 <span class="number">5</span>，存入 <span class="number">5</span> - <span class="number">3</span> = <span class="number">2</span></span><br><span class="line">|   |   min = <span class="number">3</span></span><br><span class="line">| <span class="number">2</span> |     </span><br><span class="line">|_0_|    </span><br><span class="line">stack  </span><br><span class="line"></span><br><span class="line">入栈 <span class="number">2</span>，因为出现了更小的数，所以我们会存入一个负数，这里很关键</span><br><span class="line">也就是存入  <span class="number">2</span> - <span class="number">3</span> = -<span class="number">1</span>, 并且更新 min = <span class="number">2</span> </span><br><span class="line">对于之前的 min 值 <span class="number">3</span>, 我们只需要用更新后的 min - 栈顶元素 -<span class="number">1</span> 就可以得到    </span><br><span class="line">| -<span class="number">1</span>|   min = <span class="number">2</span></span><br><span class="line">| <span class="number">5</span> |     </span><br><span class="line">|_3_|    </span><br><span class="line">stack  </span><br><span class="line"></span><br><span class="line">入栈 <span class="number">6</span>，存入  <span class="number">6</span> - <span class="number">2</span> = <span class="number">4</span></span><br><span class="line">| <span class="number">4</span> |   min = <span class="number">2</span></span><br><span class="line">| -<span class="number">1</span>| </span><br><span class="line">| <span class="number">5</span> |     </span><br><span class="line">|_3_|    </span><br><span class="line">stack  </span><br><span class="line"></span><br><span class="line">出栈，返回的值就是栈顶元素 <span class="number">4</span> 加上 min，就是 <span class="number">6</span></span><br><span class="line">|   |   min = <span class="number">2</span></span><br><span class="line">| -<span class="number">1</span>| </span><br><span class="line">| <span class="number">5</span> |     </span><br><span class="line">|_3_|    </span><br><span class="line">stack  </span><br><span class="line"></span><br><span class="line">出栈，此时栈顶元素是负数，说明之前对 min 值进行了更新。</span><br><span class="line">入栈元素 - min = 栈顶元素，入栈元素其实就是当前的 min 值 <span class="number">2</span></span><br><span class="line">所以更新前的 min 就等于入栈元素 <span class="number">2</span> - 栈顶元素(-<span class="number">1</span>) = <span class="number">3</span></span><br><span class="line">|   | min = <span class="number">3</span></span><br><span class="line">| <span class="number">5</span> |     </span><br><span class="line">|_3_|    </span><br><span class="line">stack</span><br></pre></td></tr></table></figure><p>再理一下上边的思路，我们每次存入的是 <code>原来值 - 当前最小值</code>。</p><p>当原来值大于等于当前最小值的时候，我们存入的肯定就是非负数，所以出栈的时候就是 <code>栈中的值 + 当前最小值</code> 。</p><p>当原来值小于当前最小值的时候，我们存入的肯定就是负值，此时的值我们不入栈，用 <code>min</code> 保存起来，同时将差值入栈。</p><p>当后续如果出栈元素是负数的时候，那么要出栈的元素其实就是 <code>min</code>。此外之前的 <code>min</code> 值，我们可以通过栈顶的值和当前 <code>min</code> 值进行还原，就是用 <code>min</code> 减去栈顶元素即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> min;</span><br><span class="line">Stack&lt;Long&gt; stack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">min = x;</span><br><span class="line">stack.push(x - min);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">stack.push(x - min);</span><br><span class="line"><span class="keyword">if</span> (x &lt; min)&#123;</span><br><span class="line">min = x; <span class="comment">// 更新最小值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (stack.isEmpty())</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> pop = stack.pop();</span><br><span class="line"></span><br><span class="line"><span class="comment">//弹出的是负值，要更新 min</span></span><br><span class="line"><span class="keyword">if</span> (pop &lt; <span class="number">0</span>) &#123;</span><br><span class="line">min = min - pop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> top = stack.peek();</span><br><span class="line"><span class="comment">//负数的话，出栈的值保存在 min 中</span></span><br><span class="line"><span class="keyword">if</span> (top &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>) (min);</span><br><span class="line">        <span class="comment">//出栈元素加上最小值即可</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>) (top + min);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>) min;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上边的解法的一个缺点就是由于我们保存的是差值，所以可能造成溢出，所以我们用了数据范围更大的 <code>long</code> 类型。</p><p>此外相对于解法二，最小值需要更新的时候，我们并没有将之前的最小值存起来，我们每次都是通过当前最小值和栈顶元素推出了之前的最小值，所以会省一些空间。</p><h1 id="解法四"><a href="#解法四" class="headerlink" title="解法四"></a>解法四</h1><p>再分享一个有趣的解法，参考 <a href="https://leetcode.com/problems/min-stack/discuss/49217/6ms-Java-Solution-using-Linked-List.-Clean-self-explanatory-and-efficient." target="_blank" rel="noopener">这里</a> 。</p><p>回到最初的疑虑，我们要不要用 <code>java</code> 提供的 <code>stack</code> 。如果不用的话，可以怎么做的？</p><p>直接用一个链表即可实现栈的基本功能，那么最小值该怎么得到呢？我们可以在 <code>Node</code> 节点中增加一个 <code>min</code> 字段，这样的话每次加入一个节点的时候，我们同时只要确定它的 <code>min</code> 值即可。</p><p>代码很简洁，我直接把代码贴过来吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">int</span> min;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> x, <span class="keyword">int</span> min)&#123;</span><br><span class="line">            <span class="keyword">this</span>.value=x;</span><br><span class="line">            <span class="keyword">this</span>.min=min;</span><br><span class="line">            next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Node head;</span><br><span class="line">    <span class="comment">//每次加入的节点放到头部</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span>==head)&#123;</span><br><span class="line">            head = <span class="keyword">new</span> Node(x,x);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//当前值和之前头结点的最小值较小的做为当前的 min</span></span><br><span class="line">            Node n = <span class="keyword">new</span> Node(x, Math.min(x,head.min));</span><br><span class="line">            n.next=head;</span><br><span class="line">            head=n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head!=<span class="keyword">null</span>)</span><br><span class="line">            head =head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head!=<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head.value;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span>!=head)</span><br><span class="line">            <span class="keyword">return</span> head.min;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然题目比较简单，但解法二和解法三真的让人耳目一新，一个通过存储，一个通过差值解决了「保存之前值」的问题，思路很值得借鉴。解法四更像降维打击一样，回到改底层数据结构，从而更加简洁的解决了问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年7月" scheme="http://yoursite.com/categories/2020%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
      <category term="Design" scheme="http://yoursite.com/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>240. 搜索二维矩阵II</title>
    <link href="http://yoursite.com/2020/06/30/240.%20%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5II/"/>
    <id>http://yoursite.com/2020/06/30/240. 搜索二维矩阵II/</id>
    <published>2020-06-30T14:52:12.000Z</published>
    <updated>2020-06-30T16:10:49.197Z</updated>
    
    <content type="html"><![CDATA[<p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。</p><a id="more"></a><p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：</p><p>每行的元素从左到右升序排列。<br>每列的元素从上到下升序排列。<br>示例:</p><pre><code>现有矩阵 matrix 如下：[  [1,   4,  7, 11, 15],  [2,   5,  8, 12, 19],  [3,   6,  9, 16, 22],  [10, 13, 14, 17, 24],  [18, 21, 23, 26, 30]]给定 target = 5，返回 true。给定 target = 20，返回 false。</code></pre><p>这道题出的不好，因为可以用74.搜索二维矩阵题一样的方法从左下角搜索来解决。</p><h1 id="从左下角开始搜索"><a href="#从左下角开始搜索" class="headerlink" title="从左下角开始搜索"></a>从左下角开始搜索</h1><p>因为矩阵的行和列是排序的（分别从左到右和从上到下），所以在查看任何特定值时，我们可以修剪O(m)或O(n)元素。</p><p>算法：</p><p>首先，我们初始化一个指向矩阵左下角的 (row，col) 指针。然后，直到找到目标并返回 true（或者指针指向矩阵维度之外的 (row，col) 为止，我们执行以下操作：</p><p>如果当前指向的值大于目标值，则可以 “向上” 移动一行。 </p><p>否则，如果当前指向的值小于目标值，则可以移动一列。不难理解为什么这样做永远不会删减正确的答案；因为行是从左到右排序的，所以我们知道当前值右侧的每个值都较大。 </p><p>因此，如果当前值已经大于目标值，我们知道它右边的每个值会比较大。也可以对列进行非常类似的论证，因此这种搜索方式将始终在矩阵中找到目标（如果存在）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean searchMatrix(int[][] matrix, int target) &#123;</span><br><span class="line">//        二维数组为空，要检查三个部分:</span><br><span class="line">//        一是数组首地址是否为空</span><br><span class="line">//        二是是否为&#123;&#125;，也就是array.length==0的情况</span><br><span class="line">//        三是&#123;&#123;&#125;&#125;，这时array.length=1，但是array[0].length==0。满足任意一个条件就可以返回false了。</span><br><span class="line">        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return false;</span><br><span class="line">        int row = matrix.length;</span><br><span class="line">        int col = matrix[0].length;</span><br><span class="line">        int rowindex = row - 1;</span><br><span class="line">        int colindex = 0;</span><br><span class="line"></span><br><span class="line">        while (colindex &lt; col &amp;&amp; rowindex &gt;= 0) &#123;</span><br><span class="line">            if (target == matrix[rowindex][colindex]) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else if (target &gt; matrix[rowindex][colindex]) &#123;</span><br><span class="line">                colindex++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                rowindex--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其它方法见<a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/solution/sou-suo-er-wei-ju-zhen-ii-by-leetcode-2/" target="_blank" rel="noopener">^1</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Divide and Conquer" scheme="http://yoursite.com/tags/Divide-and-Conquer/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>74. 搜索二维矩阵</title>
    <link href="http://yoursite.com/2020/06/30/74.%20%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/"/>
    <id>http://yoursite.com/2020/06/30/74. 搜索二维矩阵/</id>
    <published>2020-06-30T14:52:12.000Z</published>
    <updated>2020-06-30T16:11:22.253Z</updated>
    
    <content type="html"><![CDATA[<p>编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。</p><a id="more"></a><p>该矩阵具有如下特性：</p><p>每行中的整数从左到右按升序排列。<br>每行的第一个整数大于前一行的最后一个整数。<br>示例 1:</p><pre><code>输入:matrix = [  [1,   3,  5,  7],  [10, 11, 16, 20],  [23, 30, 34, 50]]</code></pre><p>target = 3<br>输出: true<br>示例 2:</p><pre><code>输入:matrix = [  [1,   3,  5,  7],  [10, 11, 16, 20],  [23, 30, 34, 50]]target = 13输出: false</code></pre><h1 id="从左下角开始搜索"><a href="#从左下角开始搜索" class="headerlink" title="从左下角开始搜索"></a>从左下角开始搜索</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean searchMatrix(int[][] matrix, int target) &#123;</span><br><span class="line">//        二维数组为空，要检查三个部分:</span><br><span class="line">//        一是数组首地址是否为空</span><br><span class="line">//        二是是否为&#123;&#125;，也就是array.length==0的情况</span><br><span class="line">//        三是&#123;&#123;&#125;&#125;，这时array.length=1，但是array[0].length==0。满足任意一个条件就可以返回false了。</span><br><span class="line">        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return false;</span><br><span class="line">        int row = matrix.length;</span><br><span class="line">        int col = matrix[0].length;</span><br><span class="line">        int rowindex = row - 1;</span><br><span class="line">        int colindex = 0;</span><br><span class="line"></span><br><span class="line">        while (colindex &lt; col &amp;&amp; rowindex &gt;= 0) &#123;</span><br><span class="line">            if (target == matrix[rowindex][colindex]) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else if (target &gt; matrix[rowindex][colindex]) &#123;</span><br><span class="line">                colindex++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                rowindex--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法：二分查找"><a href="#方法：二分查找" class="headerlink" title="方法：二分查找"></a>方法：二分查找</h1><p><strong>直觉</strong></p><p>注意到输入的 <code>m x n</code> 矩阵可以视为长度为 <code>m x n</code>的有序数组。</p><p> <a href="https://pic.leetcode-cn.com/d9b47b40a4de17b0c56446b0a4935a5042490ea1d92a6f4c529c2aaa0095c189-287711dcb87bd4d4681fa117f792d1baaaa7ce3e2c65d6a4f6439c0cbbb0345e-image.png" target="_blank" rel="noopener">二分查找</a></p><p>由于该 <em>虚</em> 数组的序号可以由下式方便地转化为原矩阵中的行和列 (<em>我们当然不会真的创建一个新数组</em>) ，该有序数组非常适合二分查找。</p><blockquote><p><code>row = idx // n</code> ， <code>col = idx % n</code>。</p></blockquote><p><strong>算法</strong></p><p>这是一个标准二分查找算法 : </p><ul><li><p>初始化左右序号<br><code>left = 0</code> 和 <code>right = m x n - 1</code>。</p></li><li><p>While <code>left &lt; right</code> :</p><ul><li><p>选取虚数组最中间的序号作为中间序号: <code>pivot_idx = (left + right) / 2</code>。</p></li><li><p>该序号对应于原矩阵中的 <code>row = pivot_idx // n</code>行 <code>col = pivot_idx % n</code> 列, 由此可以拿到中间元素<code>pivot_element</code>。该元素将虚数组分为两部分。</p></li><li><p>比较 <code>pivot_element</code> 与 <code>target</code> 以确定在哪一部分进行进一步查找。</p></li></ul></li></ul><p><strong>实现</strong></p><figure class="highlight java"><figcaption><span>[solution1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分查找</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = m * n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> pivotIdx, pivotElement;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">      pivotIdx = (left + right) / <span class="number">2</span>;</span><br><span class="line">      pivotElement = matrix[pivotIdx / n][pivotIdx % n];</span><br><span class="line">      <span class="keyword">if</span> (target == pivotElement) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; pivotElement) right = pivotIdx - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> left = pivotIdx + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[solution1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span><span class="params">(self, matrix: List[List[int]], target: int)</span> -&gt; bool:</span></span><br><span class="line">        m = len(matrix)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        n = len(matrix[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#二分查找</span></span><br><span class="line">        left, right = <span class="number">0</span>, m * n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">                pivot_idx = (left + right) // <span class="number">2</span></span><br><span class="line">                pivot_element = matrix[pivot_idx // n][pivot_idx % n]</span><br><span class="line">                <span class="keyword">if</span> target == pivot_element:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> target &lt; pivot_element:</span><br><span class="line">                        right = pivot_idx - <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        left = pivot_idx + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>[solution1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分查找</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = m * n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> pivotIdx, pivotElement;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">      pivotIdx = (left + right) / <span class="number">2</span>;</span><br><span class="line">      pivotElement = matrix[pivotIdx / n][pivotIdx % n];</span><br><span class="line">      <span class="keyword">if</span> (target == pivotElement) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; pivotElement) right = pivotIdx - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> left = pivotIdx + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 : 由于是标准的二分查找，时间复杂度为O(log(mn)) 。</li><li>空间复杂度 : <em>O(1)</em>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>334. 递增的三元子序列</title>
    <link href="http://yoursite.com/2020/06/30/334.%E9%80%92%E5%A2%9E%E7%9A%84%E4%B8%89%E5%85%83%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2020/06/30/334.递增的三元子序列/</id>
    <published>2020-06-30T12:52:12.000Z</published>
    <updated>2020-06-30T13:09:57.486Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个未排序的数组，判断这个数组中是否存在长度为 3 的递增子序列。</p><a id="more"></a><p>数学表达式如下:</p><p>如果存在这样的 i, j, k,  且满足 0 ≤ i &lt; j &lt; k ≤ n-1，<br>使得 arr[i] &lt; arr[j] &lt; arr[k] ，返回 true ; 否则返回 false 。<br>说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1) 。</p><p>示例 1:</p><pre><code>输入: [1,2,3,4,5]输出: true</code></pre><p>示例 2:</p><pre><code>输入: [5,4,3,2,1]输出: false</code></pre><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ol><li>第一种方法采用了双指针的思想，针对这个题的三元子序列，如果是四元或更高元则不通用。主要思路是维护当前访问数组的最小值和最小值右侧大于最小值的最小的一个。具体步骤顺序遍历数组，首先确定当前已访问的数组的最小值，即如果小于等于min值的话更新min值，如果大于min，判断是否小于等于max值，如果是，更新max值。如果大于max值，则说明有三元子序列。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">increasingTriplet</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE, max = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num &lt;= min)&#123;</span><br><span class="line">                min = num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num &lt;= max)&#123;</span><br><span class="line">                max = num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>第二种方法是动态规划的思想，主要思路是维护和更新以i为结尾的三元子序列的最长递增长度。转移方程为dp[i] = max{dp[i], dp[j] + 1} (0&lt;=j&lt;i).</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">increasingTriplet</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个未排序的数组，判断这个数组中是否存在长度为 3 的递增子序列。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>350. 两个数组的交集II</title>
    <link href="http://yoursite.com/2020/06/29/350.%20%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86II/"/>
    <id>http://yoursite.com/2020/06/29/350. 两个数组的交集II/</id>
    <published>2020-06-29T15:52:12.000Z</published>
    <updated>2020-06-30T13:09:41.642Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个数组，编写一个函数来计算它们的交集。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: nums1 = [1,2,2,1], nums2 = [2,2]输出: [2,2]</code></pre><p>示例 2:</p><pre><code>输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [4,9]</code></pre><p>说明：</p><pre><code>输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。我们可以不考虑输出结果的顺序。</code></pre><p>进阶:</p><pre><code>如果给定的数组已经排好序呢？你将如何优化你的算法？如果 nums1 的大小比 nums2 小很多，哪种方法更优？如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？</code></pre><h1 id="方法一：哈希映射"><a href="#方法一：哈希映射" class="headerlink" title="方法一：哈希映射"></a>方法一：哈希映射</h1><p>前面的问题 <a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/" target="_blank" rel="noopener">349. 两个数组的交集</a>，我们使用 <code>set</code> 来实现线性时间复杂度。在这里，我们需要使用 <code>HashMap</code> 来跟踪每个数字出现的次数。</p><p>我们先在 <code>HashMap</code> 记录一个数组中的存在的数字和对应出现的次数。然后，我们遍历第二个数组，检查数字在 <code>HashMap</code> 中是否存在，如果存在且计数为正，则将该数字添加到答案并减少 <code>HashMap</code> 中的计数。<br> <a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMzUwLzM1MF9hcHByb2FjaDEtdjIucG5n?x-oss-process=image/format,png" target="_blank" rel="noopener">哈希映射</a><br>检查数组的大小并对较小的数组进行哈希映射是一个小细节，当其中一个数组较大时，会减少内存的使用。</p><p><strong>算法：</strong></p><ul><li>如果 <code>nums1</code> 元素个数大于 <code>nums2</code>，则交换数组元素。</li><li>对于 <code>nums1</code> 的每个元素，添加到 <code>HashMap m</code> 中，如果元素已经存在则增加对应的计数。</li><li>初始化 <code>k = 0</code>，记录当前交集元素个数。</li><li>遍历数组 <code>nums2</code>：<ul><li>检查元素在 <code>m</code> 是否存在，若存在且计数为正：<ul><li>将元素拷贝到 <code>nums1[k]</code>，且 <code>k++</code>。</li><li>减少 <code>m</code> 中对应元素的计数。</li></ul></li></ul></li><li>返回 <code>nums1</code> 前 <code>k</code> 个元素。</li></ul><figure class="highlight c++"><figcaption><span>[solution1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersect(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums1.size() &gt; nums2.size()) &#123;</span><br><span class="line">        <span class="keyword">return</span> intersect(nums2, nums1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n : nums1) &#123;</span><br><span class="line">        ++m[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n : nums2) &#123;</span><br><span class="line">        <span class="keyword">auto</span> it = m.find(n);</span><br><span class="line">        <span class="keyword">if</span> (it != end(m) &amp;&amp; --it-&gt;second &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[k++] = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vector</span>(begin(nums1), begin(nums1) + k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums1.length &gt; nums2.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> intersect(nums2, nums1);</span><br><span class="line">    &#125;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : nums1) &#123;</span><br><span class="line">        m.put(n, m.getOrDefault(n, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : nums2) &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = m.getOrDefault(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[k++] = n;</span><br><span class="line">            m.put(n, cnt - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOfRange(nums1, <span class="number">0</span>, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n+m) 。其中 <em>n</em>，<em>m</em> 分别代表了数组的大小。</li><li>空间复杂度：O(min(n,m)) ，我们对较小的数组进行哈希映射使用的空间。</li></ul><h1 id="方法二：排序"><a href="#方法二：排序" class="headerlink" title="方法二：排序"></a>方法二：排序</h1><p>当输入数据是有序的，推荐使用此方法。在这里，我们对两个数组进行排序，并且使用两个指针在一次扫面找出公共的数字。<br> <a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMzUwLzM1MF9hcHByb2FjaDItdjIucG5n?x-oss-process=image/format,png" target="_blank" rel="noopener">排序</a></p><p><strong>算法：</strong></p><ul><li>对数组 <code>nums1</code> 和 <code>nums2</code> 排序。</li><li>初始化指针 <code>i</code>，<code>j</code> 和 <code>k</code> 为 <code>0</code>。</li><li>指针 <code>i</code> 指向 <code>nums1</code>，指针 <code>j</code> 指向 <code>nums2</code>：<ul><li>如果 <code>nums1[i] &lt; nums2[j]</code>，则 <code>i++</code>。 </li><li>如果 <code>nums1[i] &gt; nums2[j]</code>，则 <code>j++</code>。 </li><li>如果 <code>nums1[i] == nums2[j]</code>，将元素拷贝到 <code>nums1[k]</code>，且 <code>i++</code>，<code>j++</code>，<code>k++</code>。</li></ul></li><li>返回数组 <code>nums1</code> 前 <code>k</code> 个元素。</li></ul><figure class="highlight c++"><figcaption><span>[solution2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersect(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">    sort(begin(nums1), end(nums1));</span><br><span class="line">    sort(begin(nums2), end(nums2));</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; nums1.size() &amp;&amp; j &lt; nums2.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[i] &lt; nums2[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums1[k++] = nums1[i++];</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(begin(nums1), begin(nums1) + k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[solution2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    Arrays.sort(nums1);</span><br><span class="line">    Arrays.sort(nums2);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; nums1.length &amp;&amp; j &lt; nums2.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[i] &lt; nums2[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums1[k++] = nums1[i++];</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOfRange(nums1, <span class="number">0</span>, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="public-static-int-copyOfRange-int-original-int-from-int-to"><a href="#public-static-int-copyOfRange-int-original-int-from-int-to" class="headerlink" title="public static int[] copyOfRange(int[] original, int from, int to)"></a>public static int[] copyOfRange(int[] original, int from, int to)</h2><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(nlogn+mlogm 。其中 <em>n</em>，<em>m</em> 分别代表了数组的大小。我们对数组进行了排序然后进行了线性扫描。</li><li>空间复杂度：<em>O(1)</em>，我们忽略存储答案所使用的空间，因为它对算法本身并不重要。</li></ul><h1 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h1><p><strong>算法：</strong></p><p>这类似于方法 2。我们不使用两个指针进行迭代，而是使用内置函数来查找公共元素。在 C++ 中，我们可以使用 <code>set_intersection</code> 来排序数组（或 <code>multisets</code>）。</p><p>在 Java 中的 <code>retainAll</code> 方法并不关心一个元素在另一个集合中出现的次数。这就有点尴尬了，我一开始想到的就是用内置函数但遇到用例<code>[1,2]，[1,2]</code>就错了，怎么写也没弄出来，所以Java此法暂不可行。</p><figure class="highlight c++"><figcaption><span>[solution3-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersect(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">    sort(begin(nums1), end(nums1));</span><br><span class="line">    sort(begin(nums2), end(nums2));</span><br><span class="line">    nums1.erase(set_intersection(begin(nums1), end(nums1), </span><br><span class="line">        begin(nums2), end(nums2), begin(nums1)), end(nums1));</span><br><span class="line">    <span class="keyword">return</span> nums1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时空复杂度：与方法二相同。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个数组，编写一个函数来计算它们的交集。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>349. 两个数组的交集</title>
    <link href="http://yoursite.com/2020/06/29/349.%20%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/"/>
    <id>http://yoursite.com/2020/06/29/349. 两个数组的交集/</id>
    <published>2020-06-29T12:42:12.000Z</published>
    <updated>2020-06-29T15:51:47.249Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个数组，编写一个函数来计算它们的交集。</p><a id="more"></a><p>示例 1：</p><pre><code>输入：nums1 = [1,2,2,1], nums2 = [2,2]输出：[2]</code></pre><p>示例 2：</p><pre><code>输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出：[9,4]</code></pre><p>说明：</p><pre><code>输出结果中的每个元素一定是唯一的。我们可以不考虑输出结果的顺序。</code></pre><h4 id="方法一：两个set"><a href="#方法一：两个set" class="headerlink" title="方法一：两个set"></a>方法一：两个set</h4><p>最直观的方法是迭代并检查第一个数组 <code>nums1</code> 中的每个值是否也存在于 <code>nums2</code> 中。如果存在，则将值添加到输出。这种方法的时间复杂度为 O(n*m)  ，其中 <code>n</code> 和 <code>m</code> 分别为数组 <code>nums1</code> 和 <code>nums2</code> 的长度。 </p><p>为了在线性时间内解决这个问题，我们使用集合 <code>set</code> 这一数据结构，该结构可以提供平均时间复杂度为 <em>O(1)</em> 的 <code>in/contains</code> 操作（用于测试某一元素是否为该集合的成员）。</p><p>本解法先将两个数组都转换为集合，然后迭代较小的集合，检查其中的每个元素是否同样存在于较大的集合中。平均情况下，这种方法的时间复杂度为 <em>O(n+m)</em> 。 </p><p><strong>实现：</strong></p><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_intersection</span><span class="params">(self, set1, set2)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> [x <span class="keyword">for</span> x <span class="keyword">in</span> set1 <span class="keyword">if</span> x <span class="keyword">in</span> set2]</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersection</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span>  </span><br><span class="line">        set1 = set(nums1)</span><br><span class="line">        set2 = set(nums2)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> len(set1) &lt; len(set2):</span><br><span class="line">            <span class="keyword">return</span> self.set_intersection(set1, set2)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.set_intersection(set2, set1)</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] set_intersection(HashSet&lt;Integer&gt; set1, HashSet&lt;Integer&gt; set2) &#123;</span><br><span class="line">    <span class="keyword">int</span> [] output = <span class="keyword">new</span> <span class="keyword">int</span>[set1.size()];</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Integer s : set1)</span><br><span class="line">      <span class="keyword">if</span> (set2.contains(s)) output[idx++] = s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(output, idx);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    HashSet&lt;Integer&gt; set1 = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Integer n : nums1) set1.add(n);</span><br><span class="line">    HashSet&lt;Integer&gt; set2 = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Integer n : nums2) set2.add(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (set1.size() &lt; set2.size()) <span class="keyword">return</span> set_intersection(set1, set2);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> set_intersection(set2, set1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(m+n)*，其中 <code>n</code> 和 <code>m</code> 是数组的长度。将 <code>nums1</code> 转换为集合需要 *O(n)</em> 的时间，类似地，将 <code>nums2</code> 转换为集合需要 <em>O(m)</em> 的时间。而在平均情况下，集合的 <code>in/contains</code> 操作只需要 <em>O(1)</em> 的时间。 </li><li>空间复杂度：<em>O(m+n)</em>，最坏的情况是数组中的所有元素都不同。 </li></ul><h3 id="Arrays-copyOf"><a href="#Arrays-copyOf" class="headerlink" title="Arrays.copyOf()"></a>Arrays.copyOf()</h3><p>original - 要复制的数组 </p><p>newLength - 要返回的副本的长度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*original - 要复制的数组 </span><br><span class="line">*newLength - 要返回的副本的长度</span><br><span class="line">*/</span><br><span class="line">public static int[] copyOf(int[] original, int newLength) &#123;</span><br><span class="line">        int[] copy = new int[newLength];</span><br><span class="line">        System.arraycopy(original, 0, copy, 0,</span><br><span class="line">                         Math.min(original.length, newLength));</span><br><span class="line">        return copy;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="方法二：内置函数"><a href="#方法二：内置函数" class="headerlink" title="方法二：内置函数"></a>方法二：内置函数</h4><p>如果使用内置函数：那么平均情况下，时间复杂度为 <em>O(n+m)</em> ；而最坏的情况下，时间复杂度是O(n*m)  。</p><p>Python 提供了可用于求交集的 <code>&amp;</code> 运算符，而 Java 提供了 <code>retainAll()</code>  函数。</p><p><strong>实现:</strong></p><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersection</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span>  </span><br><span class="line">        set1 = set(nums1)</span><br><span class="line">        set2 = set(nums2)</span><br><span class="line">        <span class="keyword">return</span> list(set2 &amp; set1)</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    HashSet&lt;Integer&gt; set1 = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Integer n : nums1) set1.add(n);</span><br><span class="line">    HashSet&lt;Integer&gt; set2 = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Integer n : nums2) set2.add(n);</span><br><span class="line"></span><br><span class="line">    set1.retainAll(set2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> [] output = <span class="keyword">new</span> <span class="keyword">int</span>[set1.size()];</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s : set1) output[idx++] = s;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：一般情况下是 <em>O(m+n)</em>，最坏情况下是 O(m*n)</li><li>空间复杂度：最坏的情况是 <em>O(m+n)</em>，数组中的所有元素都不同。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个数组，编写一个函数来计算它们的交集。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>384. 打乱数组</title>
    <link href="http://yoursite.com/2020/06/29/384.%20%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2020/06/29/384. 打乱数组/</id>
    <published>2020-06-29T10:02:12.000Z</published>
    <updated>2020-06-29T12:41:22.009Z</updated>
    
    <content type="html"><![CDATA[<p>打乱一个没有重复元素的数组。</p><a id="more"></a><p>示例:</p><pre><code>// 以数字集合 1, 2 和 3 初始化数组。int[] nums = {1,2,3};Solution solution = new Solution(nums);// 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。solution.shuffle();// 重设数组到它的初始状态[1,2,3]。solution.reset();// 随机返回数组[1,2,3]打乱后的结果。solution.shuffle();</code></pre><h1 id="绪章-1"><a href="#绪章-1" class="headerlink" title="绪章^1"></a>绪章<a href="https://leetcode-cn.com/problems/shuffle-an-array/solution/da-luan-shu-zu-by-leetcode/" target="_blank" rel="noopener">^1</a></h1><p>对于洗牌问题，Fisher-Yates 洗牌算法即是通俗解法，同时也是渐进最优的解法。</p><p>在我们开始之前需要了解一些关于随机化的知识 - 下面介绍的两个方法都假设编程语言中提供的伪随机数生成器是足够随机的。我们给出的示例代码也都采用了最简单的方法来得到伪随机数，但为了让数组的每个排列出现的可能性尽可能相等，还是有一些其他东西需要注意的。例如，一个长度为 <em>n</em> 的数组有 <em>n!</em> 个不同的排列组合。因此，为了能将所有的排列在整数空间编码，我们需要lg(n!) 比特，这是默认的伪随机数不能保证的。</p><h1 id="方法一：-暴力-【通过】"><a href="#方法一：-暴力-【通过】" class="headerlink" title="方法一： 暴力 【通过】"></a>方法一： 暴力 【通过】</h1><p><strong>思路</strong></p><p>假设我们把每个数都放在一个 ”帽子“ 里面，然后我们从帽子里面把它们一个个摸出来，摸出来的数按顺序放入数组，这个数组正好就是我们要的洗牌后的数组。</p><p><strong>算法</strong></p><p>暴力算法简单的来说就是把每个数放在一个 ”帽子“ 里面，每次从 ”帽子“ 里面随机摸一个数出来，直到 “帽子” 为空。下面是具体操作，首先我们把数组 <code>array</code> 复制一份给数组 <code>aux</code>，之后每次随机从 <code>aux</code> 中取一个数，为了防止数被重复取出，每次取完就把这个数从 <code>aux</code> 中移除。<code>重置</code> 的实现方式很简单，只需把 <code>array</code> 恢复称最开始的状态就可以了。 </p><p>这个算法的正确性在于，每次 <code>for</code> 循环中，任何一个元素都会以等可能的概率被选中。为了证明这一点，我们可以算出来，一个特定的元素 <em>e</em> 在第 <em>k</em> 轮被选中的概率为</p><p><em>P</em>(<em>e</em> 在第 <em>k</em> 轮被选中) ·  <em>P</em>(<em>e</em> 在前 <em>k</em> 轮不被选中)。</p><p>假设洗牌的数组有 <em>n</em> 个元素，这个概率公式见<a href="https://leetcode-cn.com/problems/shuffle-an-array/solution/da-luan-shu-zu-by-leetcode/" target="_blank" rel="noopener">^1</a></p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] original;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">getArrayCopy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; asList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            asList.add(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> asList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        array = nums;</span><br><span class="line">        original = nums.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reset() &#123;</span><br><span class="line">        array = original;</span><br><span class="line">        original = original.clone();</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] shuffle() &#123;</span><br><span class="line">        List&lt;Integer&gt; aux = getArrayCopy();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> removeIdx = rand.nextInt(aux.size());</span><br><span class="line">            array[i] = aux.get(removeIdx);</span><br><span class="line">            aux.remove(removeIdx);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度： <em>O(n^2)</em><br>乘方时间复杂度来自于 <code>list.remove</code>（<code>list.pop</code>）。每次操作都是线性时间的，总共发生 <em>n</em> 次。</p></li><li><p>空间复杂度： <em>O(n)</em><br>因为需要实现 <code>重置</code> 方法，需要额外的空间把原始数组另存一份，在重置的时候用来恢复原始状态。</p></li></ul><h4 id="方法二：-Fisher-Yates-洗牌算法-【通过】"><a href="#方法二：-Fisher-Yates-洗牌算法-【通过】" class="headerlink" title="方法二： Fisher-Yates 洗牌算法 【通过】"></a>方法二： Fisher-Yates 洗牌算法 【通过】</h4><p><strong>思路</strong></p><p>我们可以用一个简单的技巧来降低之前算法的时间复杂度和空间复杂度，那就是让数组中的元素互相交换，这样就可以避免掉每次迭代中用于修改列表的时间了。</p><p><strong>算法</strong></p><p>Fisher-Yates 洗牌算法跟暴力算法很像。在每次迭代中，生成一个范围在当前下标到数组末尾元素下标之间的随机整数。接下来，将当前元素和随机选出的下标所指的元素互相交换 - 这一步模拟了每次从 “帽子” 里面摸一个元素的过程，其中选取下标范围的依据在于每个被摸出的元素都不可能再被摸出来了。此外还有一个需要注意的细节，当前元素是可以和它本身互相交换的 - 否则生成最后的排列组合的概率就不对了。为了更清楚地理解这一过程，可以看下面这些动画：</p><p>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates1.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates2.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates3.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates4.png" target="_blank" rel="noopener">1000</a></p><p>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates5.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates6.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates7.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates8.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates9.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates10.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates11.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates12.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates13.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates14.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates15.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates16.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates17.png" target="_blank" rel="noopener">1000</a><br>  <a href="https://pic.leetcode-cn.com/Figures/384/384_fisher_yates18.png" target="_blank" rel="noopener">1000</a> </p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] original;</span><br><span class="line"></span><br><span class="line">    Random rand = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">randRange</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rand.nextInt(max - min) + min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swapAt</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        array = nums;</span><br><span class="line">        original = nums.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reset() &#123;</span><br><span class="line">        array = original;</span><br><span class="line">        original = original.clone();</span><br><span class="line">        <span class="keyword">return</span> original;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] shuffle() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            swapAt(i, randRange(i, array.length));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度 ： <em>O(n)</em><br>Fisher-Yates 洗牌算法时间复杂度是线性的，因为算法中生成随机序列，交换两个元素这两种操作都是常数时间复杂度的。</p></li><li><p>空间复杂度： <em>O(n)</em><br>因为要实现 <code>重置</code> 功能，原始数组必须得保存一份，因此空间复杂度并没有优化。</p></li></ul><h2 id="Random-nextInt-方法，随机产生某个范围内的整数"><a href="#Random-nextInt-方法，随机产生某个范围内的整数" class="headerlink" title="Random.nextInt()方法，随机产生某个范围内的整数"></a>Random.nextInt()方法，随机产生某个范围内的整数</h2><pre><code>int nextInt()            //随机返回一个int型整数int nextInt(int num)         //随机返回一个值在[0,num)的int类型的整数,包括0不包括num</code></pre><p>nextInt能接受一个整数作为它所产生的随机整数的上限,下限为零，若要达到非零下限的效果，必须把上限减去下限的结果传给 nextInt( )，然后把下限加入 nextInt( ) 返回的整数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;打乱一个没有重复元素的数组。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>283. 移动零</title>
    <link href="http://yoursite.com/2020/06/29/283.%20%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
    <id>http://yoursite.com/2020/06/29/283. 移动零/</id>
    <published>2020-06-29T09:49:12.000Z</published>
    <updated>2020-06-29T10:00:39.219Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><a id="more"></a><p>示例:</p><pre><code>输入: [0,1,0,3,12]输出: [1,3,12,0,0]</code></pre><p>说明:</p><p>必须在原数组上操作，不能拷贝额外的数组。<br>尽量减少操作次数。</p><p>我首先想到的解法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void moveZeroes(int[] nums) &#123;</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (nums[i] == 0) &#123;</span><br><span class="line">                swap(nums,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void swap(int[] nums, int zeroindex) &#123;</span><br><span class="line">        int i=zeroindex;</span><br><span class="line">        while (i &lt; nums.length) &#123;</span><br><span class="line">            if (nums[i] == 0) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                nums[zeroindex] = nums[i];</span><br><span class="line">                nums[i]=0;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">解答成功:</span><br><span class="line">执行耗时:5 ms,击败了12.67% 的Java用户</span><br><span class="line">内存消耗:40.4 MB,击败了5.62% 的Java用户</span><br></pre></td></tr></table></figure><p>这种方法效率较低，有没有更高效的方法呢？</p><h1 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h1><ol><li>定义一个非零的指针 <code>j=0</code>，循环遍历数组用指针<code>j</code>记录非零值<code>nums[j] = num[i]</code>;</li><li>判断两个指针<code>i</code>与<code>j</code>是否相等，这里两个指针初始值都为0，<code>j</code>指针只有在非零的情况下会<code>j++</code>；</li><li>因此可以判断<code>j</code>指针对应的值都为非零的数据，且保存原有顺序；</li><li>所以，原有数组继续遍历情况下，<code>nums[i]</code>都为0。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void moveZeroes(int[] nums) &#123;</span><br><span class="line">        int j = 0;</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (nums[i] != 0) &#123;</span><br><span class="line">                nums[j] = nums[i];</span><br><span class="line">                if( i != j)&#123;</span><br><span class="line">                    nums[i] = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">            解答成功:</span><br><span class="line">执行耗时:0 ms,击败了100.00% 的Java用户</span><br><span class="line">内存消耗:39.6 MB,击败了5.62% 的Java用户</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>Java之TreeSet类</title>
    <link href="http://yoursite.com/2020/06/29/Java%E4%B9%8BTreeSet%E7%B1%BB/"/>
    <id>http://yoursite.com/2020/06/29/Java之TreeSet类/</id>
    <published>2020-06-29T08:21:12.000Z</published>
    <updated>2020-06-29T09:09:17.746Z</updated>
    
    <content type="html"><![CDATA[<p>java.util.TreeSet 类实现Set接口。</p><a id="more"></a><p>以下是关于TreeSet的要点<a href="http://gitbook.net/java/util/java_util_treeset.html" target="_blank" rel="noopener">^1</a>：</p><ul><li>TreeSet类保证该映射将在升序键顺序，由TreeMap支持。</li><li>该映射是按照自然排序方法该键类，或在集创建时提供的比较器，这将取决于其构造函数中使用排序。</li><li>顺序必须是总为了使树到功能属性。</li></ul><p>这里仅列出几个常用的方法，更多详见<a href="http://gitbook.net/java/util/java_util_treeset.html" target="_blank" rel="noopener">^1</a></p><h1 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h1><h2 id="E-ceiling-E-e-方法"><a href="#E-ceiling-E-e-方法" class="headerlink" title="E ceiling(E e) 方法"></a>E ceiling(E e) 方法</h2><p>用来返回大于或等于给定的元素的最小元素，如果不存在这样的元素返回null。</p><h2 id="E-floor-E-e-方法"><a href="#E-floor-E-e-方法" class="headerlink" title="E floor(E e) 方法"></a>E floor(E e) 方法</h2><p>此方法返回小于或等于给定的元素的最大元素，如果不存在这样的元素返回null。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java.util.TreeSet 类实现Set接口。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="TreeSet" scheme="http://yoursite.com/tags/TreeSet/"/>
    
  </entry>
  
  <entry>
    <title>220. 存在重复元素III</title>
    <link href="http://yoursite.com/2020/06/29/220.%20%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0III/"/>
    <id>http://yoursite.com/2020/06/29/220. 存在重复元素III/</id>
    <published>2020-06-29T06:59:12.000Z</published>
    <updated>2020-06-29T09:31:29.444Z</updated>
    
    <content type="html"><![CDATA[<p>在整数数组 nums 中，是否存在两个下标 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值小于等于 t ，且满足 i 和 j 的差的绝对值也小于等于 ķ 。</p><a id="more"></a><p>如果存在则返回 true，不存在返回 false。</p><p>示例 1:</p><pre><code>输入: nums = [1,2,3,1], k = 3, t = 0输出: true</code></pre><p>示例 2:</p><pre><code>输入: nums = [1,0,1,1], k = 1, t = 2输出: true</code></pre><p>示例 3:</p><pre><code>输入: nums = [1,5,9,1,5,9], k = 2, t = 3输出: false</code></pre><h1 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h1><p>首先想到用HashSet来解决但超时了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            for (int j = nums[i] - t; j &lt;= nums[i] + t; j++) &#123;</span><br><span class="line">                if (set.contains(j)) &#123;</span><br><span class="line">//                    System.out.println(&quot;i=&quot;+i+&quot;, j=&quot;+j);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">            if (set.size() &gt; k) &#123;</span><br><span class="line">                set.remove(nums[i - k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看一下官方题解<a href="https://leetcode-cn.com/problems/contains-duplicate-iii/solution/cun-zai-zhong-fu-yuan-su-iii-by-leetcode/" target="_blank" rel="noopener">^1</a></p><h1 id="二叉搜索树-【通过】"><a href="#二叉搜索树-【通过】" class="headerlink" title="二叉搜索树 【通过】"></a>二叉搜索树 【通过】</h1><p>总结一下该方法引入自平衡二叉搜索树，来保证能在O(logn) 时间内完成 插入，搜索，删除 操作。减少对滑动窗口中符合条件的元素操作所需的时间。</p><p>下面给出整个算法的伪代码：</p><pre><code>初始化一颗空的二叉搜索树 set对于每个元素xx，遍历整个数组    在 set 上查找大于等于xx的最小的数，如果s - x \leq ts−x≤t则返回 true    在 set 上查找小于等于xx的最大的数，如果x - g \leq tx−g≤t则返回 true    在 set 中插入xx    如果树的大小超过了kk, 则移除最早加入树的那个数。返回 false</code></pre><p>我们把大于等于 <em>x</em> 的最小的数 <em>s</em> 当做 <em>x</em> 在 BST 中的后继节点。同样的，我们能把小于等于 <em>x</em> 最大的数 <em>g</em> 当做 <em>x</em> 在 BST 中的前继节点。<em>s</em> 和 <em>g</em> 这两个数是距离 <em>x</em> 最近的数。因此只需要检查它们和 <em>x</em> 的距离就能知道条件二是否满足了。</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="comment">// Find the successor of current element</span></span><br><span class="line">        Integer s = set.ceiling(nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span> &amp;&amp; s &lt;= nums[i] + t) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find the predecessor of current element</span></span><br><span class="line">        Integer g = set.floor(nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (g != <span class="keyword">null</span> &amp;&amp; nums[i] &lt;= g + t) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        set.add(nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (set.size() &gt; k) &#123;</span><br><span class="line">            set.remove(nums[i - k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-ceiling-E-e-方法-2"><a href="#E-ceiling-E-e-方法-2" class="headerlink" title="E ceiling(E e) 方法^2"></a>E ceiling(E e) 方法<a href="http://gitbook.net/java/util/java_util_treeset.html" target="_blank" rel="noopener">^2</a></h2><p>用来返回大于或等于给定的元素的最小元素，如果不存在这样的元素返回null。</p><h2 id="E-floor-E-e-方法"><a href="#E-floor-E-e-方法" class="headerlink" title="E floor(E e) 方法"></a>E floor(E e) 方法</h2><p>此方法返回小于或等于给定的元素的最大元素，如果不存在这样的元素返回null。</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(n log (min(n,k)))<br>我们需要遍历这个 n 长度的数组。对于每次遍历，在 BST 中 搜索，插入 或者 删除 都需要花费 O(logmin(k, n))的时间。</p><p>空间复杂度：O(min(n,k))<br>空间复杂度由 BST 的大小决定，其大小的上限由 k 和 n 共同决定。</p><h2 id="溢出错误"><a href="#溢出错误" class="headerlink" title="溢出错误"></a>溢出错误</h2><p>当数组中的元素非常大的时候，进行数学运算可能造成溢出。所以可以考虑使用支持大数的数据类型，例如 long。</p><p>C++ 中的 std::set，std::set::upper_bound 和 std::set::lower_bound 分别等价于 Java 中的 TreeSet，TreeSet::ceiling 和 TreeSet::floor。Python 标准库不提供自平衡 BST。</p><p>当测试用例为</p><pre><code>[-2147483648,-2147483647]33</code></pre><p>时会溢出，为了解决这个问题，使用long类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) &#123;</span><br><span class="line">        TreeSet&lt;Long&gt; set = new TreeSet&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            // Find the successor of current element</span><br><span class="line">            Long s = set.ceiling((long) nums[i]);</span><br><span class="line">            if (s != null &amp;&amp; s &lt;= (long) nums[i] + t) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Find the predecessor of current element</span><br><span class="line">            Long g = set.floor((long) nums[i]);</span><br><span class="line">            if (g != null &amp;&amp; g &gt;= (long) nums[i] - t) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            set.add((long) nums[i]);</span><br><span class="line">            if (set.size() &gt; k) &#123;</span><br><span class="line">                set.remove((long) nums[i - k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法三-（桶）-【通过】"><a href="#方法三-（桶）-【通过】" class="headerlink" title="方法三 （桶） 【通过】"></a>方法三 （桶） 【通过】</h1><p><strong>思路</strong></p><p>受 <code>桶排序</code> 的启发，我们可以把 <em>桶</em> 当做窗口来实现一个线性复杂度的解法。</p><p><strong>算法</strong></p><p>桶排序是一种把元素分散到不同桶中的排序算法。接着把每个桶再独立地用不同的排序算法进行排序。桶排序的概览如下所示：</p><p>在上面的例子中，我们有 8 个未排序的整数。我们首先来创建五个桶，这五个桶分别包含 <em>[0,9], [10,19], [20, 29], [30, 39], [40, 49]</em> 这几个区间。这 8 个元素中的任何一个元素都在一个桶里面。对于值为 <em>x</em> 的元素来说，它所属桶的标签为 <em>x/w</em>，在这里我们让 <em>w = 10</em>。对于每个桶我们单独用其他排序算法进行排序，最后按照桶的顺序收集所有的元素就可以得到一个有序的数组了。</p><p>回到这个问题，我们尝试去解决的最大的问题在于：</p><blockquote><ol><li>对于给定的元素 <em>x</em>, 在窗口中是否有存在区间 <em>[x-t, x+t]</em> 内的元素？  </li><li>我们能在常量时间内完成以上判断嘛？</li></ol></blockquote><p>我们不妨把把每个元素当做一个人的生日来考虑一下吧。假设你是班上新来的一位学生，你的生日在 <em>三月</em> 的某一天，你想知道班上是否有人生日跟你生日在 <em>t=30</em> 天以内。在这里我们先假设每个月都是<em>30<em>天，很明显，我们只需要检查所有生日在 *二月</em>，<em>三月</em>，*四月</em> 的同学就可以了。</p><p>之所以能这么做的原因在于，我们知道每个人的生日都属于一个桶，我们把这个桶称作月份！每个桶所包含的区间范围都是 <em>t</em>，这能极大的简化我们的问题。很显然，任何不在同一个桶或相邻桶的两个元素之间的距离一定是大于 <em>t</em> 的。</p><p>我们把上面提到的桶的思想应用到这个问题里面来，我们设计一些桶，让他们分别包含区间 <em>…, [0,t], [t+1, 2t+1], …*。我们把桶来当做窗口，于是每次我们只需要检查 *x</em> 所属的那个桶和相邻桶中的元素就可以了。终于，我们可以在常量时间解决在窗口中搜索的问题了。</p><p>还有一件值得注意的事！</p><p>这个问题和桶排序的不同之处在于每次我们的桶里只需要包含最多一个元素就可以了，因为如果任意一个桶中包含了两个元素，那么这也就是意味着这两个元素是 <em>足够接近的</em> 了，这时候我们就直接得到答案了。因此，我们只需使用一个标签为桶序号的散列表就可以了。 </p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Get the ID of the bucket from element value x and bucket width w</span></span><br><span class="line">    <span class="comment">// In Java, `-3 / 5 = 0` and but we need `-3 / 5 = -1`.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getID</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; <span class="number">0</span> ? (x + <span class="number">1</span>) / w - <span class="number">1</span> : x / w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// Key: ID of the bucket   Value: bucket  value</span></span><br><span class="line">        Map&lt;Long, Long&gt; d = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">long</span> w = (<span class="keyword">long</span>)t + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">long</span> m = getID(nums[i], w);</span><br><span class="line">            <span class="comment">// check if bucket m is empty, each bucket may contain at most one element</span></span><br><span class="line">            <span class="keyword">if</span> (d.containsKey(m))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// check the neighbor buckets for almost duplicate</span></span><br><span class="line">            <span class="keyword">if</span> (d.containsKey(m - <span class="number">1</span>) &amp;&amp; Math.abs(nums[i] - d.get(m - <span class="number">1</span>)) &lt; w)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (d.containsKey(m + <span class="number">1</span>) &amp;&amp; Math.abs(nums[i] - d.get(m + <span class="number">1</span>)) &lt; w)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// now bucket m is empty and no almost duplicate in nei***or buckets</span></span><br><span class="line">            d.put(m, (<span class="keyword">long</span>)nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k) d.remove(getID(nums[i - k], w));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(n)</em></li></ul><p>对于这 <em>n</em> 个元素中的任意一个元素来说，我们最多只需要在散列表中做三次 <code>搜索</code>，一次 <code>插入</code> 和一次 <code>删除</code>。这些操作是常量时间复杂度的。因此，整个算法的时间复杂度为 <em>O(n)</em>。</p><ul><li>空间复杂度：O(min(n,k))<br>需要开辟的额外空间取决了散列表的大小，其大小跟它所包含的元素数量成线性关系。散列表的大小的上限同时由 <em>n</em> 和 <em>k</em> 决定。因此，空间复杂度为O(min(n,k))  。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在整数数组 nums 中，是否存在两个下标 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值小于等于 t ，且满足 i 和 j 的差的绝对值也小于等于 ķ 。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Sort" scheme="http://yoursite.com/tags/Sort/"/>
    
      <category term="Ordered Map" scheme="http://yoursite.com/tags/Ordered-Map/"/>
    
  </entry>
  
  <entry>
    <title>217. 存在重复元素</title>
    <link href="http://yoursite.com/2020/06/29/217.%20%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2020/06/29/217. 存在重复元素/</id>
    <published>2020-06-29T06:33:12.000Z</published>
    <updated>2020-06-29T06:41:10.110Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数数组，判断是否存在重复元素。如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。</p><a id="more"></a><h1 id="哈希表解决"><a href="#哈希表解决" class="headerlink" title="哈希表解决"></a>哈希表解决</h1><p>可以用Set或HashMap来解决</p><figure class="highlight java"><figcaption><span>[solution 3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(nums.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x: nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(x)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        set.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多详细分析见<a href="https://leetcode-cn.com/problems/contains-duplicate/solution/cun-zai-zhong-fu-yuan-su-by-leetcode/" target="_blank" rel="noopener">^1</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://leetcode-cn.com/problems/contains-duplicate-ii/" target="_blank" rel="noopener">219 存在重复元素 II</a></li><li><a href="https://leetcode-cn.com/problems/contains-duplicate-iii/" target="_blank" rel="noopener">220 存在重复元素 III</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数数组，判断是否存在重复元素。如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>219. 存在重复元素II</title>
    <link href="http://yoursite.com/2020/06/29/219.%20%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II/"/>
    <id>http://yoursite.com/2020/06/29/219. 存在重复元素II/</id>
    <published>2020-06-29T06:33:12.000Z</published>
    <updated>2020-06-29T06:55:28.045Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: nums = [1,2,3,1], k = 3输出: true</code></pre><p>示例 2:</p><pre><code>输入: nums = [1,0,1,1], k = 1输出: true</code></pre><p>示例 3:</p><pre><code>输入: nums = [1,2,3,1,2,3], k = 2输出: false</code></pre><h1 id="解法一：HashMap"><a href="#解法一：HashMap" class="headerlink" title="解法一：HashMap"></a>解法一：HashMap</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean containsNearbyDuplicate(int[] nums, int k) &#123;</span><br><span class="line">        //Key-&gt;nums[i] , Value-&gt;i</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; hashMap=new HashMap&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (hashMap.containsKey(nums[i])) &#123;</span><br><span class="line">                if (Math.abs(i - hashMap.get(nums[i])) &lt;= k) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            hashMap.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法二-（散列表）"><a href="#方法二-（散列表）" class="headerlink" title="方法二 （散列表）"></a>方法二 （散列表）</h1><p><strong>思路</strong></p><p>用散列表来维护这个<em>k</em>大小的滑动窗口。<a href="https://leetcode-cn.com/problems/contains-duplicate-ii/solution/cun-zai-zhong-fu-yuan-su-ii-by-leetcode/" target="_blank" rel="noopener">^1</a></p><p><strong>算法</strong></p><p>在之前的方法中，我们知道了对数时间复杂度的 <code>搜索</code> 操作是不够的。在这个方法里面，我们需要一个支持在常量时间内完成 <code>搜索</code>，<code>删除</code>，<code>插入</code> 操作的数据结构，那就是散列表。这个算法的实现跟方法二几乎是一样的。</p><ul><li>遍历数组，对于每个元素做以下操作：<ul><li>在散列表中搜索当前元素，如果找到了就返回 <code>true</code>。</li><li>在散列表中插入当前元素。</li><li>如果当前散列表的大小超过了 <em>k</em>， 删除散列表中最旧的元素。</li></ul></li><li>返回 <code>false</code>。</li></ul><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(nums[i])) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        set.add(nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (set.size() &gt; k) &#123;</span><br><span class="line">            set.remove(nums[i - k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)</em><br>我们会做 <em>n</em> 次 <code>搜索</code>，<code>删除</code>，<code>插入</code> 操作，每次操作都耗费常数时间。</p></li><li><p>空间复杂度：O(min(n,k)) </p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>152. 乘积最大子数组</title>
    <link href="http://yoursite.com/2020/06/29/152.%20%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2020/06/29/152. 乘积最大子数组/</id>
    <published>2020-06-29T06:06:12.000Z</published>
    <updated>2020-06-29T06:23:19.793Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。</code></pre><p>示例 2:</p><pre><code>输入: [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</code></pre><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这道题比较经典，官方解法可以见<a href="https://leetcode-cn.com/problems/maximum-product-subarray/solution/cheng-ji-zui-da-zi-shu-zu-by-leetcode-solution/" target="_blank" rel="noopener">^1</a>,我首先想到用全局变量和局部变量的方法来解决，但是要注意两个测试样例[-2]和[0,2]，需要对全局和局部最大变量做相应处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProduct(int[] nums) &#123;</span><br><span class="line">        int maxpro=nums[0];</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            int localpro=nums[i];</span><br><span class="line">            maxpro = Math.max(maxpro, localpro);</span><br><span class="line">            for (int j = i+1; j &lt; nums.length; j++) &#123;</span><br><span class="line">                localpro *= nums[j];</span><br><span class="line">                maxpro = Math.max(maxpro, localpro);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxpro;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>189. 旋转数组</title>
    <link href="http://yoursite.com/2020/06/29/189.%20%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2020/06/29/189. 旋转数组/</id>
    <published>2020-06-29T06:06:12.000Z</published>
    <updated>2020-06-29T06:23:14.982Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4]</code></pre><p>示例 2:</p><pre><code>输入: [-1,-100,3,99] 和 k = 2输出: [3,99,-1,-100]解释: 向右旋转 1 步: [99,-1,-100,3]向右旋转 2 步: [3,99,-1,-100]</code></pre><p>说明:</p><pre><code>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。要求使用空间复杂度为 O(1) 的 原地 算法。</code></pre><h2 id="方法-1：暴力"><a href="#方法-1：暴力" class="headerlink" title="方法 1：暴力"></a>方法 1：暴力</h2><p>最简单的方法是旋转 k 次，每次将数组旋转 1 个元素。</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp, previous;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            previous = nums[nums.length - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                temp = nums[j];</span><br><span class="line">                nums[j] = previous;</span><br><span class="line">                previous = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(n*k)</em> 。每个元素都被移动 1 步（<em>O(n)</em>） k次（<em>O(k)</em>） 。</li><li>空间复杂度：<em>O(1)</em> 。没有额外空间被使用。</li></ul><h2 id="方法-2：使用额外的数组"><a href="#方法-2：使用额外的数组" class="headerlink" title="方法 2：使用额外的数组"></a>方法 2：使用额外的数组</h2><p><strong>算法</strong></p><p>我们可以用一个额外的数组来将每个元素放到正确的位置上，也就是原本数组里下标为 <em>i</em> 的我们把它放到 <img src="./p___i+k_%%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6_.png" alt="(i+k)\%数组长度 ">  的位置。然后把新的数组拷贝到原数组中。</p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            a[(i + k) % nums.length] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度： <em>O(n)</em> 。将数字放到新的数组中需要一遍遍历，另一边来把新数组的元素拷贝回原数组。</li><li>空间复杂度： <em>O(n)</em>。另一个数组需要原数组长度的空间。</li></ul><h2 id="方法-3：使用环状替换"><a href="#方法-3：使用环状替换" class="headerlink" title="方法 3：使用环状替换"></a>方法 3：使用环状替换</h2><p><strong>算法</strong></p><p>如果我们直接把每一个数字放到它最后的位置，但这样的后果是遗失原来的元素。因此，我们需要把被替换的数字保存在变量 <em>temp</em> 里面。然后，我们将被替换数字（<em>temp*）放到它正确的位置，并继续这个过程 *n</em> 次， <em>n</em> 是数组的长度。这是因为我们需要将数组里所有的元素都移动。但是，这种方法可能会有个问题，如果 <img src="./p__n%k==0_.png" alt="n\%k==0 "> ，其中 <img src="./p__k=k%n_.png" alt="k=k\%n ">  （因为如果 <em>k</em> 大于 <em>n</em> ，移动 <em>k</em> 次实际上相当于移动 <img src="./p__k%n_.png" alt="k\%n ">  次）。这种情况下，我们会发现在没有遍历所有数字的情况下回到出发数字。此时，我们应该从下一个数字开始再重复相同的过程。</p><p>现在，我们看看上面方法的证明。假设，数组里我们有 <em>n</em> 个元素并且 <em>k</em> 是要求移动的次数。更进一步，假设 <img src="./p__n%k=0_.png" alt="n\%k=0 ">  。第一轮中，所有移动数字的下标 <em>i</em> 满足 <img src="./p__i%k==0_.png" alt="i\%k==0 ">  。这是因为我们每跳 <em>k</em> 步，我们只会到达相距为 <em>k</em> 个位置下标的数。每一轮，我们都会移动 <img src="./p__frac%7Bn%7D%7Bk%7D_.png" alt="\frac{n}{k} ">  个元素。下一轮中，我们会移动满足 <img src="./p__i%k==1_.png" alt="i\%k==1 ">  的位置的数。这样的轮次会一直持续到我们再次遇到 <img src="./p__i%k==0_.png" alt="i\%k==0 ">  的地方为止，此时 <em>i=k</em> 。此时在正确位置上的数字共有 <img src="./p__k_times_frac%7Bn%7D%7Bk%7D=n_.png" alt="k\times\frac{n}{k}=n ">  个。因此所有数字都在正确位置上。</p><p>让我们看一下接下来的例子，以更好地说明这个过程：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums: [1, 2, 3, 4, 5, 6]</span><br><span class="line">k: 2</span><br></pre></td></tr></table></figure></p><p> <a href="https://pic.leetcode-cn.com/f0493a97cdb7bc46b37306ca14e555451496f9f9c21effcad8517a81a26f30d6-image.png" target="_blank" rel="noopener">例子</a></p><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k = k % nums.length;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; count &lt; nums.length; start++) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = start;</span><br><span class="line">            <span class="keyword">int</span> prev = nums[start];</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> next = (current + k) % nums.length;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[next];</span><br><span class="line">                nums[next] = prev;</span><br><span class="line">                prev = temp;</span><br><span class="line">                current = next;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">while</span> (start != current);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(n)</em> 。只遍历了每个元素一次。</li><li>空间复杂度：<em>O(1)</em> 。使用了常数个额外空间。</li></ul><h2 id="方法-4：使用反转"><a href="#方法-4：使用反转" class="headerlink" title="方法 4：使用反转"></a>方法 4：使用反转</h2><p><strong>算法</strong></p><p>这个方法基于这个事实：当我们旋转数组 k 次， <img src="./p__k%n_.png" alt="k\%n ">  个尾部元素会被移动到头部，剩下的元素会被向后移动。</p><p>在这个方法中，我们首先将所有元素反转。然后反转前 k 个元素，再反转后面 <em>n-k</em> 个元素，就能得到想要的结果。</p><p>我用这种方法来解决时遇到数组越界错误，是因为没有把k取模，因为有些情况下k可能大于数组长度。这个易错点需要注意。</p><p>假设 <em>n=7</em> 且 <em>k=3</em> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原始数组                  : 1 2 3 4 5 6 7</span><br><span class="line">反转所有数字后             : 7 6 5 4 3 2 1</span><br><span class="line">反转前 k 个数字后          : 5 6 7 4 3 2 1</span><br><span class="line">反转后 n-k 个数字后        : 5 6 7 1 2 3 4 --&gt; 结果</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k %= nums.length;</span><br><span class="line">        reverse(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, k, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[start];</span><br><span class="line">            nums[start] = nums[end];</span><br><span class="line">            nums[end] = temp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(n)</em> 。 <em>n</em> 个元素被反转了总共 3 次。</li><li>空间复杂度：<em>O(1)</em> 。 没有使用额外的空间。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>63. 不同路径II</title>
    <link href="http://yoursite.com/2020/06/28/63.%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II/"/>
    <id>http://yoursite.com/2020/06/28/63. 不同路径II/</id>
    <published>2020-06-28T12:50:12.000Z</published>
    <updated>2020-06-29T06:22:31.214Z</updated>
    
    <content type="html"><![CDATA[<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><a id="more"></a><p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p><p>说明：m 和 n 的值均不超过 100。</p><p>示例1:</p><pre><code>输入:[  [0,0,0],  [0,1,0],  [0,0,0]]输出: 2解释:3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</code></pre><h2 id="方法-1：动态规划-1"><a href="#方法-1：动态规划-1" class="headerlink" title="方法 1：动态规划^1"></a>方法 1：动态规划<a href="https://leetcode-cn.com/problems/unique-paths-ii/solution/bu-tong-lu-jing-ii-by-leetcode/" target="_blank" rel="noopener">^1</a></h2><p><strong>直觉</strong></p><p>机器人只可以向下和向右移动，因此第一行的格子只能从左边的格子移动到，第一列的格子只能从上方的格子移动到。</p><p>如果格子上有障碍，那么我们不考虑包含这个格子的任何路径。我们从左至右、从上至下的遍历整个数组，那么在到达某个顶点之前我们就已经获得了到达前驱节点的方案数，这就变成了一个<code>动态规划</code>问题。我们只需要一个 <code>obstacleGrid</code> 数组作为 DP 数组。</p><p><code>注意：</code> 根据题目描述，包含障碍物的格点有权值 <code>1</code>，我们依此来判断是否包含在路径中，然后我们可以用这个空间来存储到达这个格点的方案数。</p><p><strong>算法</strong></p><ol><li>如果第一个格点 <code>obstacleGrid[0,0]</code> 是 <code>1</code>，说明有障碍物，那么机器人不能做任何移动，我们返回结果 <code>0</code>。</li><li>否则，如果 <code>obstacleGrid[0,0]</code> 是 <code>0</code>，我们初始化这个值为 <code>1</code> 然后继续算法。</li><li>遍历第一行，如果有一个格点初始值为 <code>1</code> ，说明当前节点有障碍物，没有路径可以通过，设值为 <code>0</code> ；否则设这个值是前一个节点的值 <code>obstacleGrid[i,j] = obstacleGrid[i,j-1]</code>。</li><li>遍历第一列，如果有一个格点初始值为 <code>1</code> ，说明当前节点有障碍物，没有路径可以通过，设值为 <code>0</code> ；否则设这个值是前一个节点的值 <code>obstacleGrid[i,j] = obstacleGrid[i-1,j]</code>。</li><li>现在，从 <code>obstacleGrid[1,1]</code> 开始遍历整个数组，如果某个格点初始不包含任何障碍物，就把值赋为上方和左侧两个格点方案数之和 <code>obstacleGrid[i,j] = obstacleGrid[i-1,j] + obstacleGrid[i,j-1]</code>。</li><li>如果这个点有障碍物，设值为 <code>0</code> ，这可以保证不会对后面的路径产生贡献。</li></ol><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> R = obstacleGrid.length;</span><br><span class="line">        <span class="keyword">int</span> C = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the starting cell has an obstacle, then simply return as there would be</span></span><br><span class="line">        <span class="comment">// no paths to the destination.</span></span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Number of ways of reaching the starting cell = 1.</span></span><br><span class="line">        obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Filling the values for the first column</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; R; i++) &#123;</span><br><span class="line">            obstacleGrid[i][<span class="number">0</span>] = (obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; obstacleGrid[i - <span class="number">1</span>][<span class="number">0</span>] == <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Filling the values for the first row</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; C; i++) &#123;</span><br><span class="line">            obstacleGrid[<span class="number">0</span>][i] = (obstacleGrid[<span class="number">0</span>][i] == <span class="number">0</span> &amp;&amp; obstacleGrid[<span class="number">0</span>][i - <span class="number">1</span>] == <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Starting from cell(1,1) fill up the values</span></span><br><span class="line">        <span class="comment">// No. of ways of reaching cell[i][j] = cell[i - 1][j] + cell[i][j - 1]</span></span><br><span class="line">        <span class="comment">// i.e. From above and left.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; R; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; C; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    obstacleGrid[i][j] = obstacleGrid[i - <span class="number">1</span>][j] + obstacleGrid[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    obstacleGrid[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return value stored in rightmost bottommost cell. That is the destination.</span></span><br><span class="line">        <span class="keyword">return</span> obstacleGrid[R - <span class="number">1</span>][C - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 ： O(M\timesN)   。长方形网格的大小是 M\timesN ，而访问每个格点恰好一次。</li><li>空间复杂度 ： <em>O(1)</em>。我们利用 <code>obstacleGrid</code> 作为 DP 数组，因此不需要额外的空间。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>980. 不同路径 III</title>
    <link href="http://yoursite.com/2020/06/28/980.%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%20III/"/>
    <id>http://yoursite.com/2020/06/28/980. 不同路径 III/</id>
    <published>2020-06-28T12:50:12.000Z</published>
    <updated>2020-06-29T10:06:02.298Z</updated>
    
    <content type="html"><![CDATA[<p>返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目，每一个无障碍方格都要通过一次。</p><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在二维网格 grid 上，有 4 种类型的方格：</p><pre><code>1 表示起始方格。且只有一个起始方格。2 表示结束方格，且只有一个结束方格。0 表示我们可以走过的空方格。-1 表示我们无法跨越的障碍。</code></pre><p>返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目，每一个无障碍方格都要通过一次。</p><p>示例 1：</p><pre><code>输入：[[1,0,0,0],[0,0,0,0],[0,0,2,-1]]输出：2解释：我们有以下两条路径：1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)</code></pre><p>示例 2：</p><pre><code>输入：[[1,0,0,0],[0,0,0,0],[0,0,0,2]]输出：4解释：我们有以下四条路径： 1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)</code></pre><p>示例 3：</p><pre><code>输入：[[0,1],[2,0]]输出：0解释：没有一条路能完全穿过每一个空的方格一次。请注意，起始和结束方格可以位于网格中的任意位置。</code></pre><p>提示：</p><p>1 &lt;= grid.length * grid[0].length &lt;= 20</p><h4 id="方法一：回溯深度优先搜索"><a href="#方法一：回溯深度优先搜索" class="headerlink" title="方法一：回溯深度优先搜索"></a>方法一：回溯深度优先搜索</h4><p><strong>思路与算法</strong><a href="https://leetcode-cn.com/problems/unique-paths-iii/solution/bu-tong-lu-jing-iii-by-leetcode/" target="_blank" rel="noopener">^1</a></p><p>让我们尝试遍历每一个 <code>0</code> 方格，并在走过的方格里留下一个障碍。回溯的时候，我们要删除那些自己留下的障碍。</p><p>介于输入数据的限制，这个方法是可以通过的，因为一个不好的路径很快就会因没有无障碍的方格可以走而被卡住。 </p><figure class="highlight java"><figcaption><span>[2RULHstn-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="keyword">int</span>[][] grid;</span><br><span class="line">    <span class="keyword">int</span> targetR, targetC;</span><br><span class="line">    <span class="keyword">int</span> R, C;</span><br><span class="line">    <span class="keyword">int</span>[] dr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] dc = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsIII</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.grid = grid;</span><br><span class="line">        R = grid.length;</span><br><span class="line">        C = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> todo = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sourceR = <span class="number">0</span>, sourceC = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//获取无障碍方格数量和出发终止位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; c++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] != -<span class="number">1</span>) &#123;</span><br><span class="line">                    todo++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="number">1</span>) &#123;</span><br><span class="line">                    sourceR = r;</span><br><span class="line">                    sourceC = c;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[r][c] == <span class="number">2</span>) &#123;</span><br><span class="line">                    targetR = r;</span><br><span class="line">                    targetC = c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        dfs(sourceR, sourceC, todo);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> todo)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每一个无障碍方格都要通过一次</span></span><br><span class="line">        todo--;</span><br><span class="line">        <span class="keyword">if</span> (todo &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//到达终点</span></span><br><span class="line">        <span class="keyword">if</span> (r == targetR &amp;&amp; c == targetC) &#123;</span><br><span class="line">            <span class="keyword">if</span> (todo == <span class="number">0</span>) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在走过的方格里留下一个障碍</span></span><br><span class="line">        grid[r][c] = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">int</span> nr = r + dr[k];</span><br><span class="line">            <span class="keyword">int</span> nc = c + dc[k];</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> &lt;= nr &amp;&amp; nr &lt; R &amp;&amp; <span class="number">0</span> &lt;= nc &amp;&amp; nc &lt; C) &#123;</span><br><span class="line">                <span class="comment">//尝试遍历每一个 `0` 方格</span></span><br><span class="line">                <span class="keyword">if</span> (grid[nr][nc] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    dfs(nr, nc, todo);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//回溯的时候，我们要删除那些自己留下的障碍。</span></span><br><span class="line">        grid[r][c] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[2RULHstn-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsIII</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        R, C = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">nei</span>***<span class="title">ors</span><span class="params">(r, c)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> nr, nc <span class="keyword">in</span> ((r<span class="number">-1</span>, c), (r, c<span class="number">-1</span>), (r+<span class="number">1</span>, c), (r, c+<span class="number">1</span>)):</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= nr &lt; R <span class="keyword">and</span> <span class="number">0</span> &lt;= nc &lt; C <span class="keyword">and</span> grid[nr][nc] % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">yield</span> nr, nc</span><br><span class="line"></span><br><span class="line">        todo = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> r, row <span class="keyword">in</span> enumerate(grid):</span><br><span class="line">            <span class="keyword">for</span> c, val <span class="keyword">in</span> enumerate(row):</span><br><span class="line">                <span class="keyword">if</span> val != <span class="number">-1</span>: todo += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> val == <span class="number">1</span>: sr, sc = r, c</span><br><span class="line">                <span class="keyword">if</span> val == <span class="number">2</span>: tr, tc = r, c</span><br><span class="line"></span><br><span class="line">        self.ans = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(r, c, todo)</span>:</span></span><br><span class="line">            todo -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> todo &lt; <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> r == tr <span class="keyword">and</span> c == tc:</span><br><span class="line">                <span class="keyword">if</span> todo == <span class="number">0</span>:</span><br><span class="line">                    self.ans += <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            grid[r][c] = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">for</span> nr, nc <span class="keyword">in</span> nei***ors(r, c):</span><br><span class="line">                dfs(nr, nc, todo)</span><br><span class="line">            grid[r][c] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        dfs(sr, sc, todo)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(4^{R<em>C})</em>，其中 *R, C</em> 是这个二维网格行与列的大小。（我们可以找到一个更加精确的界限，但是这个界限已经超越了本文的范围）</p></li><li><p>空间复杂度：<em>O(R</em>C)*。</p></li></ul><hr><h4 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h4><p><strong>思路与算法</strong></p><p>让我们定义 <code>dp(r, c, todo)</code> 为从  <code>(r, c)</code> 开始行走，还没有遍历的无障碍方格集合为 <code>todo</code> 的好路径的数量。</p><p>我们可以使用一个与 <em>方法一</em> 类似的方法，并通过记忆化状态 <code>(r, c, todo)</code> 的答案来避免重复搜索。</p><figure class="highlight java"><figcaption><span>[pRtnUqNa-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="keyword">int</span>[][] grid;</span><br><span class="line">    <span class="keyword">int</span> R, C;</span><br><span class="line">    <span class="keyword">int</span> tr, tc, target;</span><br><span class="line">    <span class="keyword">int</span>[] dr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] dc = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    Integer[][][] memo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsIII</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.grid = grid;</span><br><span class="line">        R = grid.length;</span><br><span class="line">        C = grid[<span class="number">0</span>].length;</span><br><span class="line">        target = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sr = <span class="number">0</span>, sc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; ++r)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                    target |= code(r, c);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="number">1</span>) &#123;</span><br><span class="line">                    sr = r;</span><br><span class="line">                    sc = c;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[r][c] == <span class="number">2</span>) &#123;</span><br><span class="line">                    tr = r;</span><br><span class="line">                    tc = c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        memo = <span class="keyword">new</span> Integer[R][C][<span class="number">1</span> &lt;&lt; R*C];</span><br><span class="line">        <span class="keyword">return</span> dp(sr, sc, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">code</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; (r * C + c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">dp</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> todo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (memo[r][c][todo] != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> memo[r][c][todo];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r == tr &amp;&amp; c == tc) &#123;</span><br><span class="line">            <span class="keyword">return</span> todo == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">            <span class="keyword">int</span> nr = r + dr[k];</span><br><span class="line">            <span class="keyword">int</span> nc = c + dc[k];</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> &lt;= nr &amp;&amp; nr &lt; R &amp;&amp; <span class="number">0</span> &lt;= nc &amp;&amp; nc &lt; C) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((todo &amp; code(nr, nc)) != <span class="number">0</span>)</span><br><span class="line">                    ans += dp(nr, nc, todo ^ code(nr, nc));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memo[r][c][todo] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[pRtnUqNa-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsIII</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        R, C = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">code</span><span class="params">(r, c)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; (r * C + c)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">nei</span>***<span class="title">ors</span><span class="params">(r, c)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> nr, nc <span class="keyword">in</span> ((r<span class="number">-1</span>, c), (r, c<span class="number">-1</span>), (r+<span class="number">1</span>, c), (r, c+<span class="number">1</span>)):</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= nr &lt; R <span class="keyword">and</span> <span class="number">0</span> &lt;= nc &lt; C <span class="keyword">and</span> grid[nr][nc] % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">yield</span> nr, nc</span><br><span class="line"></span><br><span class="line">        target = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> r, row <span class="keyword">in</span> enumerate(grid):</span><br><span class="line">            <span class="keyword">for</span> c, val <span class="keyword">in</span> enumerate(row):</span><br><span class="line">                <span class="keyword">if</span> val % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    target |= code(r, c)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> val == <span class="number">1</span>:</span><br><span class="line">                    sr, sc = r, c</span><br><span class="line">                <span class="keyword">if</span> val == <span class="number">2</span>:</span><br><span class="line">                    tr, tc = r, c</span><br><span class="line"></span><br><span class="line"><span class="meta">        @lru_cache(None)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(r, c, todo)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> r == tr <span class="keyword">and</span> c == tc:</span><br><span class="line">                <span class="keyword">return</span> +(todo == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            ans = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> nr, nc <span class="keyword">in</span> nei***ors(r, c):</span><br><span class="line">                <span class="keyword">if</span> todo &amp; code(nr, nc):</span><br><span class="line">                    ans += dp(nr, nc, todo ^ code(nr, nc))</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp(sr, sc, target)</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(R * C * 2^{R<em>C})</em>，其中 *R, C</em> 是给定二维网格行与列的大小。</li><li>空间复杂度：<em>O(R * C * 2^{R</em>C})*。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目，每一个无障碍方格都要通过一次。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>62. 不同路径</title>
    <link href="http://yoursite.com/2020/06/28/62.%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2020/06/28/62. 不同路径/</id>
    <published>2020-06-28T12:12:12.000Z</published>
    <updated>2020-06-28T14:32:49.381Z</updated>
    
    <content type="html"><![CDATA[<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。问总共有多少条不同的路径？</p><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p><p>示例 1:</p><pre><code>输入: m = 3, n = 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向右 -&gt; 向下2. 向右 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向右</code></pre><p>示例 2:</p><pre><code>输入: m = 7, n = 3输出: 28</code></pre><p>提示：</p><pre><code>1 &lt;= m, n &lt;= 100</code></pre><p>题目数据保证答案小于等于 2 * 10 ^ 9</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="思路一：排列组合"><a href="#思路一：排列组合" class="headerlink" title="思路一：排列组合"></a><strong>思路一：排列组合</strong></h2><p>因为机器到底右下角，向下几步，向右几步都是固定的，</p><p>比如，<code>m=3, n=2</code>，我们只要向下 1 步，向右 2 步就一定能到达终点。</p><p>所以有 <em>C_{m+n-2}^{m-1}</em></p><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> int(math.factorial(m+n<span class="number">-2</span>)/math.factorial(m<span class="number">-1</span>)/math.factorial(n<span class="number">-1</span>))</span><br></pre></td></tr></table></figure><h2 id="思路二：动态规划"><a href="#思路二：动态规划" class="headerlink" title="思路二：动态规划"></a><strong>思路二：动态规划</strong></h2><p>我们令 <code>dp[i][j]</code> 是到达 <code>i, j</code> 最多路径</p><p>动态方程：<code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code></p><p>注意，对于第一行 <code>dp[0][j]</code>，或者第一列 <code>dp[i][0]</code>，由于都是在边界，所以只能为 <code>1</code></p><p>时间复杂度：<em>O(m*n)</em></p><p>空间复杂度：<em>O(m * n)</em></p><h2 id="优化：因为我们每次只需要-dp-i-1-j-dp-i-j-1"><a href="#优化：因为我们每次只需要-dp-i-1-j-dp-i-j-1" class="headerlink" title="优化：因为我们每次只需要 dp[i-1][j],dp[i][j-1]"></a>优化：因为我们每次只需要 <code>dp[i-1][j],dp[i][j-1]</code></h2><p>所以我们只要记录这两个数，直接看代码吧！</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>思路二：</p><figure class="highlight java"><figcaption><span>[1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化1：空间复杂度 <em>O(2n)</em></p><figure class="highlight java"><figcaption><span>[2]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] pre = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] cur = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(pre, <span class="number">1</span>);</span><br><span class="line">        Arrays.fill(cur,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                cur[j] = cur[j-<span class="number">1</span>] + pre[j];</span><br><span class="line">            &#125;</span><br><span class="line">            pre = cur.clone();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre[n-<span class="number">1</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化2：空间复杂度 <em>O(n)</em></p><figure class="highlight java"><figcaption><span>[3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] cur = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(cur,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                cur[j] += cur[j-<span class="number">1</span>] ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。问总共有多少条不同的路径？&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>212. 单词搜索II</title>
    <link href="http://yoursite.com/2020/06/28/212.%20%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2II/"/>
    <id>http://yoursite.com/2020/06/28/212. 单词搜索II/</id>
    <published>2020-06-28T10:12:12.000Z</published>
    <updated>2020-06-28T12:02:17.704Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二维网格board和一个字典中的单词列表 words，找出所有同时在二维网格和字典中出现的单词。</p><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。</p><p>示例:</p><p>输入: </p><pre><code>words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;] and board =[  [&apos;o&apos;,&apos;a&apos;,&apos;a&apos;,&apos;n&apos;],  [&apos;e&apos;,&apos;t&apos;,&apos;a&apos;,&apos;e&apos;],  [&apos;i&apos;,&apos;h&apos;,&apos;k&apos;,&apos;r&apos;],  [&apos;i&apos;,&apos;f&apos;,&apos;l&apos;,&apos;v&apos;]]</code></pre><p>输出:</p><pre><code>[&quot;eat&quot;,&quot;oath&quot;]</code></pre><p>说明:</p><p>你可以假设所有输入都由小写字母 a-z 组成。</p><p>提示:</p><ul><li><p>你需要优化回溯算法以通过更大数据量的测试。你能否早点停止回溯？</p></li><li><p>如果当前单词不存在于所有单词的前缀中，则可以立即停止回溯。什么样的数据结构可以有效地执行这样的操作？散列表是否可行？为什么？ 前缀树如何？如果你想学习如何实现一个基本的前缀树，请先查看这个问题： 实现Trie（前缀树）。</p></li></ul><h4 id="方法一：使用前缀树的回溯"><a href="#方法一：使用前缀树的回溯" class="headerlink" title="方法一：使用前缀树的回溯"></a>方法一：使用前缀树的回溯</h4><p>这个问题实际上是一个简化的纵横填字游戏，在这个游戏中，单词的解已经被嵌入了一些无关字母。我们要做的就是把它们划掉。</p><p>直观地说，为了划掉所有潜在的单词，总体策略是一个接一个地迭代单元格，然后从每个单元格沿着它的四个潜在方向的走，找到匹配的单词。</p><p>当我们在黑板上徘徊时，若我们知道这不会发现新单词时，我们会停止探索。</p><p>有人可能已经猜到了我们用来解决这个问题的方法。是的，它是回溯，这将是解决方案的主干。构造一个回溯的解决方案是相当简单的。</p><p>解决这个问题的关键在于我们如何从字典中找到单词的匹配项。直观地说，可以使用 hashset 数据结构（例如Python 中的 <code>set()</code>）。</p><p>然而，在回溯过程中，人们会更经常地遇到这样的问题：是否存在任何包含特定前缀的单词，而不是是否有一个字符串作为单词存在于字典中。因为如果我们知道给定前缀的字典中不存在任何单词匹配，那么我们就不需要进一步探索某个方向。而这，将大大减少探测空间，从而提高回溯算法的性能。</p><p>能够查找前缀的数据结构叫 Trie，于 hashset 比较。Trie 不仅可以检查一个单词，还可以立即找到共享给定前缀的单词。事实证明，数据结构的选择（Trie 与 hashset）可能以排名前 5% 或后 5% 的解决方案结束。</p><p>这里我们展示了一个由单词列表构建的 Trie 示例。如下图所示，在所表示的节点处，我们将知道字典中至少有两个前缀为 <code>d</code> 的单词。</p><p> <a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl90cmllX2V4YW1wbGUucG5n?x-oss-process=image/format,png" target="_blank" rel="noopener">一个由单词列表构建的 Trie 示例</a></p><p>我们在实现 Trie 数据结构时遇到麻烦。我们可以从<a href="https://leetcode.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">Trie 问题</a>开始作为热身，然后再回来这个问题。</p><p><strong>算法：</strong></p><p>该算法的整个工作流程是直观的，包括在二维网格中的每个单元上循环和从单元开始的递归函数调用。这是算法的框架。</p><ul><li>我们根据字典中的单词构建一个 Trie，稍后将用于匹配过程。</li><li>从每个单元格开始，如果字典中存在以单元格中的字母开头的单词,则我们开始回溯探索（即 <code>backtracking(cell)</code>）。</li><li>在递归函数 <code>backtracking(cell)</code> 调用过程中，我们探索当前单元格周围的相邻单元格（即 <code>neighborCell</code>）以进行下一个递归调用 <code>backtracking(neighborCell)</code>。在每次调用时，我们都会检查到目前为止遍历的字母序列是否与字典中的任何单词匹配，这需要借助于我们在开始时构建的 Trie 数据结构。</li></ul><p>下面是算法的工作原理的。基于上述思想，我们给出了一些示例实现。之后，我们详细介绍了一些可以进一步应用于该算法的优化。</p><p> <a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl90cmllX2FsZ28ucG5n?x-oss-process=image/format,png" target="_blank" rel="noopener">算法的工作原理</a></p><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">  HashMap&lt;Character, TrieNode&gt; children = <span class="keyword">new</span> HashMap&lt;Character, TrieNode&gt;();</span><br><span class="line">  String word = <span class="keyword">null</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span>[][] _board = <span class="keyword">null</span>;</span><br><span class="line">  ArrayList&lt;String&gt; _result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findWords</span><span class="params">(<span class="keyword">char</span>[][] board, String[] words)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 1). Construct the Trie</span></span><br><span class="line">    TrieNode root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">      TrieNode node = root;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (Character letter : word.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.children.containsKey(letter)) &#123;</span><br><span class="line">          node = node.children.get(letter);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          TrieNode newNode = <span class="keyword">new</span> TrieNode();</span><br><span class="line">          node.children.put(letter, newNode);</span><br><span class="line">          node = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      node.word = word;  <span class="comment">// store words in Trie</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._board = board;</span><br><span class="line">    <span class="comment">// Step 2). Backtracking starting for each cell in the board</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; board.length; ++row) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; board[row].length; ++col) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.children.containsKey(board[row][col])) &#123;</span><br><span class="line">          backtracking(row, col, root);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._result;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, TrieNode parent)</span> </span>&#123;</span><br><span class="line">    Character letter = <span class="keyword">this</span>._board[row][col];</span><br><span class="line">    TrieNode currNode = parent.children.get(letter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check if there is any match</span></span><br><span class="line">    <span class="keyword">if</span> (currNode.word != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>._result.add(currNode.word);</span><br><span class="line">      currNode.word = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mark the current letter before the EXPLORATION</span></span><br><span class="line">    <span class="keyword">this</span>._board[row][col] = <span class="string">'#'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// explore neighbor cells in around-clock directions: up, right, down, left</span></span><br><span class="line">    <span class="keyword">int</span>[] rowOffset = &#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] colOffset = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">      <span class="keyword">int</span> newRow = row + rowOffset[i];</span><br><span class="line">      <span class="keyword">int</span> newCol = col + colOffset[i];</span><br><span class="line">      <span class="keyword">if</span> (newRow &lt; <span class="number">0</span> || newRow &gt;= <span class="keyword">this</span>._board.length || newCol &lt; <span class="number">0</span></span><br><span class="line">          || newCol &gt;= <span class="keyword">this</span>._board[<span class="number">0</span>].length) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (currNode.children.containsKey(<span class="keyword">this</span>._board[newRow][newCol])) &#123;</span><br><span class="line">        backtracking(newRow, newCol, currNode);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// End of EXPLORATION, restore the original letter in the board.</span></span><br><span class="line">    <span class="keyword">this</span>._board[row][col] = letter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optimization: incrementally remove the leaf nodes</span></span><br><span class="line">    <span class="keyword">if</span> (currNode.children.isEmpty()) &#123;</span><br><span class="line">      parent.children.remove(letter);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了更好地理解回溯过程，我们将在下面的动画中演示如何在 Trie 中找到 <code>dog</code>。</p><p>  [1](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV8xLnBuZw?x-oss-process=image/format" target="_blank" rel="noopener">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV8xLnBuZw?x-oss-process=image/format</a> png) </p><p>  [2](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV8yLnBuZw?x-oss-process=image/format" target="_blank" rel="noopener">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV8yLnBuZw?x-oss-process=image/format</a> png)  </p><p>  [3](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV8zLnBuZw?x-oss-process=image/format" target="_blank" rel="noopener">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV8zLnBuZw?x-oss-process=image/format</a> png)  </p><p>  [4](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV80LnBuZw?x-oss-process=image/format" target="_blank" rel="noopener">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV80LnBuZw?x-oss-process=image/format</a> png)  </p><p>  [5](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV81LnBuZw?x-oss-process=image/format" target="_blank" rel="noopener">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV81LnBuZw?x-oss-process=image/format</a> png)  </p><p>  [6](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV82LnBuZw?x-oss-process=image/format" target="_blank" rel="noopener">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9zbGlkZV82LnBuZw?x-oss-process=image/format</a> png) </p><h2 id="优化："><a href="#优化：" class="headerlink" title="优化："></a><strong>优化</strong>：</h2><p>在上述实现中，除了应用 Trie 数据结构外，我们还应用了一些技巧来进一步加快运行时间。特别是，Python 实现的运行速度可以超过 98% 的提交。我们按其重要性将这些技巧详述如下。</p><ul><li>沿着 Trie 的节点回溯。</li></ul><p>人们可以简单地使用 Trie 作为字典来快速找到单词和前缀的匹配，即在回溯的每一步，我们都从Trie 的根开始。</p><p>然而，更有效的方法是将 Trie 与回溯过程一起遍历，即每一步 <code>backtracking(TrieNode)</code>，<code>TrieNode</code> 的深度对应于我们到目前为止匹配的前缀的长度。这项措施可以将您的解决方案从提交的最低 <em>5%</em> 中脱颖出来。</p><ul><li>在回溯过程中逐渐剪除 Trie 中的节点（剪枝）。</li></ul><p>这个想法的动机是整个算法的时间复杂度取决于 Trie 的大小。对于 Trie 中的叶节点，一旦遍历它（即找到匹配的单词），就不需要再遍历它了。结果，我们可以把它从树上剪下来。</p><p>逐渐地，这些非叶节点可以成为叶节点以后，因为我们修剪他们的孩子叶节点。在极端情况下，一旦我们找到字典中所有单词的匹配项，Trie 就会变成空的。这个剪枝措施可以减少在线测试用例 50% 的运行时间。</p><p> <a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl90cmllX3BydW5lLnBuZw?x-oss-process=image/format,png" target="_blank" rel="noopener">剪枝</a></p><ul><li>从 Trie 中删除匹配的单词。</li></ul><p>在这个问题中，我们被要求返回所有匹配的单词，而不是潜在匹配的数量。因此，一旦到达包含单词匹配的特定 Trie 节点，我们就可以从 Trie 中删除匹配单词。</p><p>作为附带好处，我们不需要检查结果集中是否有任何重复项。因此，我们可以简单地使用一个列表而不是集合来保存结果，这样可以加快解决方案的速度。</p><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>\mathcal{O}(M(4\cdot3^{L-1}))<em>，其中</em>M</em> 是二维网格中的单元格数，<em>L</em> 是单词的最大长度。</p><ul><li>计算回溯算法将执行的确切步数是一个棘手的问题。我们为这个问题的最坏情况提供了该步骤的上限。该算法循环遍历二维网格中的所有单元，因此在复杂度公式中我们有 <em>M</em> 作为因子。然后将其归结为每个启动单元所需的最大步骤数（即 <em>4\cdot3^{L-1}</em>）。</li><li>假设单词的最大长度是 <em>L</em>，从一个单元格开始，最初我们最多可以探索 4 个方向。假设每个方向都是有效的（即最坏情况），在接下来的探索中，我们最多有 3 个相邻的单元（不包括我们来的单元）要探索。因此，在回溯探索期间，我们最多遍历 <em>4\cdot3^{L-1}</em> 个单元格。</li><li>你可能会想最坏的情况是什么样子。这里有一个例子。想象一下，二维网格中的每个单元都包含字母 <code>a</code>，单词词典包含一个单词 <code>[&#39;aaaa&#39;]</code>。这是算法将遇到的最坏的情况之一。</li></ul><p><a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjEyLzIxMl9jb21wbGV4aXR5X2V4YW1wbGUucG5n?x-oss-process=image/format,png" target="_blank" rel="noopener">最坏的情况</a></p></li></ul><p>注意，上述时间复杂性是在 Trie 数据结构一旦构建就不会改变的假设下估计的。如果采用优化策略逐步删除 Trie 中的节点，则可以大大提高时间复杂度，因为一旦匹配词典中的所有单词，即 Trie 变为空，回溯的成本就会降低到零。 </p><ul><li>空间复杂度：<em>\mathcal{O}(N)*，其中 *N</em> 是字典中的字母总数。<ul><li>算法消耗的主要空间是我们构建的 Trie 数据结构。在最坏的情况下，如果单词之间没有前缀重叠，则 Trie 将拥有与所有单词的字母一样多的节点。也可以选择在 Trie 中保留单词的副本。因此，我们可能需要 *2N$ 的空间用于 Trie。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个二维网格board和一个字典中的单词列表 words，找出所有同时在二维网格和字典中出现的单词。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年6月" scheme="http://yoursite.com/categories/2020%E5%B9%B46%E6%9C%88/"/>
    
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Trie" scheme="http://yoursite.com/tags/Trie/"/>
    
  </entry>
  
</feed>
