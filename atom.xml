<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-05T07:37:21.245Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java学习笔记VI</title>
    <link href="http://yoursite.com/2019/09/05/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0VI/"/>
    <id>http://yoursite.com/2019/09/05/Java学习笔记VI/</id>
    <published>2019-09-05T07:12:12.000Z</published>
    <updated>2019-09-05T07:37:21.245Z</updated>
    
    <content type="html"><![CDATA[<p>Java基本数据类型和包装类的区别,不同类型为空的异常判断，集合操作</p><a id="more"></a><p>在实际的工程项目开发中，常遇到对于传入参数的异常处理，对于不同类型的参数需要进行不同的判断，例如有时int，long类型的参数需要判断是否为0，而Integer和Long类型的参数需要判断是否为空。String类型的需要使用StringUtils.isEmpty()</p><h1 id="StringUtils类中isEmpty与isBlank的区别"><a href="#StringUtils类中isEmpty与isBlank的区别" class="headerlink" title="StringUtils类中isEmpty与isBlank的区别"></a>StringUtils类中isEmpty与isBlank的区别</h1><p>org.apache.commons.lang.StringUtils类提供了String的常用操作,最为常用的判空有如下两种isEmpty(String str)和isBlank(String str)。</p><p>StringUtils.isEmpty(String str) 判断某字符串是否为空，为空的标准是 str==null 或 str.length()==0</p><pre><code>System.out.println(StringUtils.isEmpty(null));        //trueSystem.out.println(StringUtils.isEmpty(&quot;&quot;));          //trueSystem.out.println(StringUtils.isEmpty(&quot;   &quot;));       //falseSystem.out.println(StringUtils.isEmpty(&quot;dd&quot;));        //falseStringUtils.isNotEmpty(String str) 等价于 !isEmpty(String str)</code></pre><p>StringUtils.isBlank(String str) 判断某字符串是否为空或长度为0或由空白符(whitespace) 构成</p><pre><code>System.out.println(StringUtils.isBlank(null));        //trueSystem.out.println(StringUtils.isBlank(&quot;&quot;));          //trueSystem.out.println(StringUtils.isBlank(&quot;   &quot;));       //trueSystem.out.println(StringUtils.isBlank(&quot;dd&quot;));        //false    </code></pre><p>StringUtils.isBlank(String str) 等价于 !isBlank(String str)</p><h1 id="集合操作-CollectionUtils"><a href="#集合操作-CollectionUtils" class="headerlink" title="集合操作 CollectionUtils"></a>集合操作 CollectionUtils</h1><p>对于查询到的集合例如：</p><pre><code>List&lt;TblJobsEntity&gt; tblJobsEntityList = tblJobsEntityMapper.selectByExample(tblJobsEntityExample);</code></pre><p>进行判断时，不能使用</p><pre><code>if(tblJobsEntityList.isEmpty())</code></pre><p>因为若查询到的tblJobsEntityList为null，则null.isEmpty()会出现空指针异常，如</p><pre><code>Exception in thread &quot;main&quot; java.lang.NullPointerException</code></pre><p>需要使用CollectionUtils.isEmpty(tblJobsEntityList)来进行判断</p><h2 id="集合判断："><a href="#集合判断：" class="headerlink" title="集合判断："></a>集合判断：</h2><h3 id="判断集合是否为空"><a href="#判断集合是否为空" class="headerlink" title="判断集合是否为空:"></a>判断集合是否为空:</h3><pre><code>CollectionUtils.isEmpty(null): trueCollectionUtils.isEmpty(new ArrayList()): trueCollectionUtils.isEmpty({a,b}): false</code></pre><h3 id="判断集合是否不为空"><a href="#判断集合是否不为空" class="headerlink" title="判断集合是否不为空:"></a>判断集合是否不为空:</h3><pre><code>CollectionUtils.isNotEmpty(null): falseCollectionUtils.isNotEmpty(new ArrayList()): falseCollectionUtils.isNotEmpty({a,b}): true</code></pre><h3 id="2个集合间的操作："><a href="#2个集合间的操作：" class="headerlink" title="2个集合间的操作："></a>2个集合间的操作：</h3><pre><code>集合a: {1,2,3,3,4,5}集合b: {3,4,4,5,6,7}CollectionUtils.union(a, b)(并集): {1,2,3,3,4,4,5,6,7}CollectionUtils.intersection(a, b)(交集): {3,4,5}CollectionUtils.disjunction(a, b)(交集的补集): {1,2,3,4,6,7}CollectionUtils.disjunction(b, a)(交集的补集): {1,2,3,4,6,7}CollectionUtils.subtract(a, b)(A与B的差): {1,2,3}CollectionUtils.subtract(b, a)(B与A的差): {4,6,7}</code></pre><h1 id="Java基本数据类型和包装类的区别"><a href="#Java基本数据类型和包装类的区别" class="headerlink" title="Java基本数据类型和包装类的区别"></a>Java基本数据类型和包装类的区别</h1><p>Java的数据类型分两种：</p><p>基本类型：byte，short，int，long，boolean，float，double，char</p><p>引用类型：所有class和interface类型</p><p>引用类型可以赋值为null，表示空，但基本类型不能赋值为null：</p><pre><code>String s = null;int n = null; // compile error!</code></pre><p>如何把一个基本类型视为对象（引用类型）？</p><h2 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h2><p>比如，想要把int基本类型变成一个引用类型，我们可以定义一个Integer类，它只包含一个实例字段int，这样，Integer类就可以视为int的包装类（Wrapper Class）：</p><pre><code>public class Integer {    private int value;    public Integer(int value) {        this.value = value;    }    public int intValue() {        return this.value;    }}</code></pre><p>定义好了Integer类，我们就可以把int和Integer互相转换：</p><pre><code>Integer n = null;Integer n2 = new Integer(99);int n3 = n2.intValue();</code></pre><p>实际上，因为包装类型非常有用，Java核心库为每种基本类型都提供了对应的包装类型：</p><pre><code>基本类型      对应的引用类型boolean       java.lang.Booleanbyte         java.lang.Byteshort         java.lang.Shortint           java.lang.Integerlong         java.lang.Longfloat         java.lang.Floatdouble       java.lang.Doublechar         java.lang.Character</code></pre><p>我们可以直接使用，并不需要自己去定义：</p><pre><code>// Integer:public class Main {    public static void main(String[] args) {        int i = 100;        // 通过new操作符创建Integer实例(不推荐使用,会有编译警告):        Integer n1 = new Integer(i);        // 通过静态方法valueOf(int)创建Integer实例:        Integer n2 = Integer.valueOf(i);        // 通过静态方法valueOf(String)创建Integer实例:        Integer n3 = Integer.valueOf(&quot;100&quot;);        System.out.println(n3.intValue());    }}</code></pre><h2 id="Auto-Boxing"><a href="#Auto-Boxing" class="headerlink" title="Auto Boxing"></a>Auto Boxing</h2><p>因为int和Integer可以互相转换：</p><pre><code>int i = 100;Integer n = Integer.valueOf(i);int x = n.intValue();</code></pre><p>所以，Java编译器可以帮助我们自动在int和Integer之间转型：</p><pre><code>Integer n = 100; // 编译器自动使用Integer.valueOf(int)int x = n; // 编译器自动使用Integer.intValue()</code></pre><p>这种直接把int变为Integer的赋值写法，称为自动装箱（Auto Boxing），反过来，把Integer变为int的赋值写法，称为自动拆箱（Auto Unboxing）。</p><p>注意：自动装箱和自动拆箱只发生在编译阶段，目的是为了少写代码。</p><p>装箱和拆箱会影响代码的执行效率，因为编译后的class代码是严格区分基本类型和引用类型的。并且，自动拆箱执行时可能会报NullPointerException：</p><pre><code>// NullPointerExceptionpublic class Main {    public static void main(String[] args) {        Integer n = null;        int i = n;    }}</code></pre><h2 id="不变类"><a href="#不变类" class="headerlink" title="不变类"></a>不变类</h2><p>所有的包装类型都是不变类。我们查看Integer的源码可知，它的核心代码如下：</p><pre><code>public final class Integer {    private final int value;}</code></pre><p>因此，一旦创建了Integer对象，该对象就是不变的。</p><p>对两个Integer实例进行比较要特别注意：绝对不能用==比较，因为Integer是引用类型，必须使用equals()比较：</p><pre><code>// == or equals?public class Main {    public static void main(String[] args) {        Integer x = 127;        Integer y = 127;        Integer m = 99999;        Integer n = 99999;        System.out.println(&quot;x == y: &quot; + (x==y)); // true        System.out.println(&quot;m == n: &quot; + (m==n)); // false        System.out.println(&quot;x.equals(y): &quot; + x.equals(y)); // true        System.out.println(&quot;m.equals(n): &quot; + m.equals(n)); // true    }}</code></pre><p>仔细观察结果的童鞋可以发现，==比较，较小的两个相同的Integer返回true，较大的两个相同的Integer返回false，这是因为Integer是不变类，编译器把Integer x = 127;自动变为Integer x = Integer.valueOf(127);</p><p>为了节省内存，Integer.valueOf()对于较小的数，始终返回相同的实例，因此，==比较“恰好”为true，但我们绝不能因为Java标准库的Integer内部有缓存优化就用==比较，必须用equals()方法比较两个Integer。</p><p>按照语义编程，而不是针对特定的底层实现去“优化”。</p><p>因为Integer.valueOf()可能始终返回同一个Integer实例，因此，在我们自己创建Integer的时候，以下两种方法：</p><pre><code>方法1：Integer n = new Integer(100);方法2：Integer n = Integer.valueOf(100);</code></pre><p>方法2更好，因为方法1总是创建新的Integer实例，方法2把内部优化留给Integer的实现者去做，即使在当前版本没有优化，也有可能在下一个版本进行优化。</p><p>我们把能创建“新”对象的静态方法称为静态工厂方法。Integer.valueOf()就是静态工厂方法，它尽可能地返回缓存的实例以节省内存。</p><p> 创建新对象时，优先选用静态工厂方法而不是new操作符。</p><p>如果我们考察Byte.valueOf()方法的源码，可以看到，标准库返回的Byte实例全部是缓存实例，但调用者并不关心静态工厂方法以何种方式创建新实例还是直接返回缓存的实例。</p><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><p>Integer类本身还提供了大量方法，例如，最常用的静态方法parseInt()可以把字符串解析成一个整数：</p><pre><code>int x1 = Integer.parseInt(&quot;100&quot;); // 100int x2 = Integer.parseInt(&quot;100&quot;, 16); // 256,因为按16进制解析</code></pre><p>Integer还可以把整数格式化为指定进制的字符串：</p><pre><code>// Integer:public class Main {    public static void main(String[] args) {        System.out.println(Integer.toString(100)); // &quot;100&quot;,表示为10进制        System.out.println(Integer.toString(100, 36)); // &quot;2s&quot;,表示为36进制        System.out.println(Integer.toHexString(100)); // &quot;64&quot;,表示为16进制        System.out.println(Integer.toOctalString(100)); // &quot;144&quot;,表示为8进制        System.out.println(Integer.toBinaryString(100)); // &quot;1100100&quot;,表示为2进制    }}</code></pre><p>注意：上述方法的输出都是String，在计算机内存中，只用二进制表示，不存在十进制或十六进制的表示方法。int n = 100在内存中总是以4字节的二进制表示：</p><pre><code>┌────────┬────────┬────────┬────────┐│00000000│00000000│00000000│01100100│└────────┴────────┴────────┴────────┘</code></pre><p>我们经常使用的System.out.println(n);是依靠核心库自动把整数格式化为10进制输出并显示在屏幕上，使用Integer.toHexString(n)则通过核心库自动把整数格式化为16进制。</p><p>这里我们注意到程序设计的一个重要原则：数据的存储和显示要分离。</p><p>Java的包装类型还定义了一些有用的静态变量</p><pre><code>// boolean只有两个值true/false，其包装类型只需要引用Boolean提供的静态字段:Boolean t = Boolean.TRUE;Boolean f = Boolean.FALSE;// int可表示的最大/最小值:int max = Integer.MAX_VALUE; // 2147483647int min = Integer.MIN_VALUE; // -2147483648// long类型占用的bit和byte数量:int sizeOfLong = Long.SIZE; // 64 (bits)int bytesOfLong = Long.BYTES; // 8 (bytes)</code></pre><p>最后，所有的整数和浮点数的包装类型都继承自Number，因此，可以非常方便地直接通过包装类型获取各种基本类型：</p><pre><code>// 向上转型为Number:Number num = new Integer(999);// 获取byte, int, long, float, double:byte b = num.byteValue();int n = num.intValue();long ln = num.longValue();float f = num.floatValue();double d = num.doubleValue();</code></pre><h2 id="处理无符号整型"><a href="#处理无符号整型" class="headerlink" title="处理无符号整型"></a>处理无符号整型</h2><p>在Java中，并没有无符号整型（Unsigned）的基本数据类型。byte、short、int和long都是带符号整型，最高位是符号位。而C语言则提供了CPU支持的全部数据类型，包括无符号整型。无符号整型和有符号整型的转换在Java中就需要借助包装类型的静态方法完成。</p><p>例如，byte是有符号整型，范围是-128~+127，但如果把byte看作无符号整型，它的范围就是0~255。我们把一个负的byte按无符号整型转换为int：</p><pre><code>// Bytepublic class Main {    public static void main(String[] args) {        byte x = -1;        byte y = 127;        System.out.println(Byte.toUnsignedInt(x)); // 255        System.out.println(Byte.toUnsignedInt(y)); // 127    }}</code></pre><p>因为byte的-1的二进制表示是11111111，以无符号整型转换后的int就是255。</p><p>类似的，可以把一个short按unsigned转换为int，把一个int按unsigned转换为long。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Java核心库提供的包装类型可以把基本类型包装为class；</p><p>自动装箱和自动拆箱都是在编译期完成的（JDK&gt;=1.5）；</p><p>装箱和拆箱会影响执行效率，且拆箱时可能发生NullPointerException；</p><p>包装类型的比较必须使用equals()；</p><p>整数和浮点数的包装类型都继承自Number；</p><p>包装类型提供了大量实用方法。</p><h2 id="思考：Java中基本数据类型和包装类型有什么区别"><a href="#思考：Java中基本数据类型和包装类型有什么区别" class="headerlink" title="思考：Java中基本数据类型和包装类型有什么区别"></a>思考：Java中基本数据类型和包装类型有什么区别</h2><p>1、包装类是对象，拥有方法和字段，对象的调用都是通过引用对象的地址，基本类型不是</p><p>2、包装类型是引用的传递，基本类型是值的传递</p><p>3、声明方式不同，基本数据类型不需要new关键字，而包装类型需要new在堆内存中进行new来分配内存空间</p><p>4、存储位置不同，基本数据类型直接将值保存在值栈中，而包装类型是把对象放在堆中，然后通过对象的引用来调用他们</p><p>5、<strong><em>初始值不同，eg： int的初始值为 0 、 boolean的初始值为false 而包装类型的初始值为null</em></strong></p><p>6、使用方式不同，基本数据类型直接赋值使用就好 ，而包装类型是在集合如 collection Map时会使用</p><p>7.当需要往ArrayList，HashMap中放东西时，像int，double这种基本类型是放不进去的，因为容器都是装object的，这是就需要这些基本类型的外覆类了，比如</p><pre><code>List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="https://blog.csdn.net/shb_derek1/article/details/9624897" target="_blank" rel="noopener">https://blog.csdn.net/shb_derek1/article/details/9624897</a></p><p>【2】<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260473794166400" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1252599548343744/1260473794166400</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java基本数据类型和包装类的区别,不同类型为空的异常判断，集合操作&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Git学习笔记II</title>
    <link href="http://yoursite.com/2019/09/05/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0II/"/>
    <id>http://yoursite.com/2019/09/05/Git学习笔记II/</id>
    <published>2019-09-05T06:51:12.000Z</published>
    <updated>2019-09-05T07:01:26.944Z</updated>
    
    <content type="html"><![CDATA[<p>Git版本回滚</p><a id="more"></a><p>在当前branch上多次commit代码并且push后，发现不符合要求，需要回滚到特定的版本。步骤如下：</p><p>1、查找commitId</p><p>首先用命令行打开git项目路径，输入git log命令查看commit记录，如下：</p><pre><code>$ git log</code></pre><p>找到commitId是9a0d02d1578ea064479296ad7efa70c5cb1a3717记录，这是执行上面命令后打印出来的信息：</p><pre><code>commit 9a0d02d1578ea064479296ad7efa70c5cb1a3717</code></pre><p>2、找到需要回滚的commit，输入git reset –hard {commitId}，将本地文件回滚：</p><pre><code>$ git reset --hard c503cffa099332911d4fce2fc1399cb4bc3ba9d6HEAD is now at c503cffa0 add a constellation test case</code></pre><p>3、此时本地文件已经回滚到刚刚commit 9a0d02d1578ea064479296ad7efa70c5cb1a3717之后的状态，但是服务器仍然没有改变，需要继续远程回滚：</p><pre><code>$ git push -f</code></pre><p>执行，最终提示一系列内容，远程回滚成功</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】 <a href="https://blog.csdn.net/weixin_38569499/article/details/83017699" target="_blank" rel="noopener">https://blog.csdn.net/weixin_38569499/article/details/83017699</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git版本回滚&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git学习笔记I</title>
    <link href="http://yoursite.com/2019/09/04/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0I/"/>
    <id>http://yoursite.com/2019/09/04/Git学习笔记I/</id>
    <published>2019-09-04T09:08:12.000Z</published>
    <updated>2019-09-05T06:51:17.117Z</updated>
    
    <content type="html"><![CDATA[<p>Git切换新分支，git fetch与git pull的区别，及常用命令集锦</p><a id="more"></a><h1 id="查看本地已有的分支"><a href="#查看本地已有的分支" class="headerlink" title="查看本地已有的分支"></a>查看本地已有的分支</h1><pre><code>git branch</code></pre><h1 id="本地建立新分支并推送到远程仓库"><a href="#本地建立新分支并推送到远程仓库" class="headerlink" title="本地建立新分支并推送到远程仓库"></a>本地建立新分支并推送到远程仓库</h1><h2 id="创建本地分支"><a href="#创建本地分支" class="headerlink" title="创建本地分支"></a>创建本地分支</h2><p>  git checkout -b 新分支名字</p><p>执行该指令后，会在本地创建一个新分支，该分支是从当前分支上建出的，所以所有文件内容都和当前分支一模一样，这是正常的。创建成功后，将自动切换至新分支上。</p><h2 id="推送本地分支到远程仓库"><a href="#推送本地分支到远程仓库" class="headerlink" title="推送本地分支到远程仓库"></a>推送本地分支到远程仓库</h2><p>  git push –sest-upstream origin 分支名字</p><h1 id="将远程git仓库里的指定分支拉取到本地（本地不存在的分支）"><a href="#将远程git仓库里的指定分支拉取到本地（本地不存在的分支）" class="headerlink" title="将远程git仓库里的指定分支拉取到本地（本地不存在的分支）"></a>将远程git仓库里的指定分支拉取到本地（本地不存在的分支）</h1><p>首先更新远程分支列表</p><pre><code>git remote update origin --prune或者git remote update origin -p</code></pre><p>然后将指定分支拉取到本地</p><pre><code>git checkout -b 本地分支名 origin/远程分支名</code></pre><p>这个将会自动创建一个新的本地分支，并与指定的远程分支关联起来。</p><p>如果出现提示：</p><pre><code>fatal: Cannot update paths and switch to branch &apos;dev2&apos; at the same time.Did you intend to checkout &apos;origin/dev2&apos; which can not be resolved as commit?</code></pre><p>表示拉取不成功。我们需要先执行</p><pre><code>git fetch</code></pre><p>然后再执行</p><pre><code>git checkout -b 本地分支名 origin/远程分支名</code></pre><p>即可。</p><h1 id="git-fetch与git-pull的区别"><a href="#git-fetch与git-pull的区别" class="headerlink" title="git fetch与git pull的区别"></a>git fetch与git pull的区别</h1><p>FETCH_HEAD： 是一个版本链接，记录在本地的一个文件中，指向着目前已经从远程仓库取下来的分支的末端版本。</p><p>commit-id：在每次本地工作完成后，都会做一个git commit 操作来保存当前工作到本地的repo， 此时会产生一个commit-id，这是一个能唯一标识一个版本的序列号。 在使用git push后，这个序列号还会同步到远程仓库。</p><p>有了以上的概念再来说说git fetch</p><p>git fetch：这将更新git remote 中所有的远程仓库所包含分支的最新commit-id, 将其记录到.git/FETCH_HEAD文件中</p><p>git fetch更新远程仓库的方式如下：</p><pre><code>git fetch origin master:tmp//在本地新建一个temp分支，并将远程origin仓库的master分支代码下载到本地temp分支git diff tmp//来比较本地代码与刚刚从远程下载下来的代码的区别git merge tmp//合并temp分支到本地的master分支git branch -d temp//如果不想保留temp分支 可以用这步删除</code></pre><h2 id="如果直接使用git-fetch，则步骤如下："><a href="#如果直接使用git-fetch，则步骤如下：" class="headerlink" title="如果直接使用git fetch，则步骤如下："></a>如果直接使用git fetch，则步骤如下：</h2><p>创建并更新本地远程分支。即创建并更新origin/xxx 分支，拉取代码到origin/xxx分支上。</p><p>在FETCH_HEAD中设定当前分支-origin/当前分支对应，如直接到时候git merge就可以将origin/abc合并到abc分支上。</p><h2 id="git-fetch-origin"><a href="#git-fetch-origin" class="headerlink" title="git fetch origin"></a>git fetch origin</h2><p>只是手动指定了要fetch的remote。在不指定分支时通常默认为master</p><h2 id="git-fetch-origin-dev"><a href="#git-fetch-origin-dev" class="headerlink" title="git fetch origin dev"></a>git fetch origin dev</h2><p>指定远程remote和FETCH_HEAD，并且只拉取该分支的提交。</p><h2 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull :"></a>git pull :</h2><p>首先，基于本地的FETCH_HEAD记录，比对本地的FETCH_HEAD记录与远程仓库的版本号，然后git fetch 获得当前指向的远程分支的后续版本的数据，然后再利用git merge将其与本地的当前分支合并。所以可以认为git pull是git fetch和git merge两个步骤的结合。</p><p>git pull的用法如下：</p><pre><code>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;//取回远程主机某个分支的更新，再与本地的指定分支合并。</code></pre><p>因此，与git pull相比git fetch相当于是从远程获取最新版本到本地，但不会自动merge。如果需要有选择的合并git fetch是更好的选择。效果相同时git pull将更为快捷。</p><h1 id="git-命令集锦"><a href="#git-命令集锦" class="headerlink" title="git 命令集锦"></a>git 命令集锦</h1><h2 id="git-设定"><a href="#git-设定" class="headerlink" title="git 设定"></a>git 设定</h2><pre><code>git config --global user.namegit config --global user.emailgit config --global color.ui truegit config --global alias. &lt;命令名称&gt;比如：git config —global alias.st status</code></pre><h2 id="git常用"><a href="#git常用" class="headerlink" title="git常用"></a>git常用</h2><pre><code>git init其反操作：rm -rf .gitgit clonegit statusgit status -s：仅显示已修改的文档名称git status -s -b：显示分支名称git diffgit add .git add -Agit commit -m &quot;message&quot;git commit --amend &quot;message&quot; 修改上一次 commit 內容git pushgit pullgit loggit log --graph 查看分支合并图git log --pretty=onelinegit reflog 查看命令历史rm 删除本地filegit rm 删除版本库file</code></pre><h2 id="git分支操作"><a href="#git分支操作" class="headerlink" title="git分支操作"></a>git分支操作</h2><pre><code>git branchgit branch -r 显示远端分支git branch -a 显示所有分支git branch &lt;分支名称&gt; 建立分支git branch -m &lt;旧分支名称&gt; &lt;新分支名称&gt; 修改分支名字git branch -d &lt;分支名称&gt;git checkoutgit checkout -b &lt;分支名称&gt;：表示 建立並切換 至该分支git merge &lt;分支名称&gt;git reset --merge 放弃merge</code></pre><h2 id="远端操作"><a href="#远端操作" class="headerlink" title="远端操作"></a>远端操作</h2><pre><code>git remote 显示远端数据库列表git remote add &lt;名称&gt; 添加远端数据库git checkout &lt;本地分支名称&gt; origin/&lt;远端分支名称&gt;</code></pre><h2 id="取远端分支建立本地端分支"><a href="#取远端分支建立本地端分支" class="headerlink" title="取远端分支建立本地端分支"></a>取远端分支建立本地端分支</h2><pre><code>git push &lt;分支名称&gt;</code></pre><h2 id="在远端建立分支-上传-或更新-內容至远端分支"><a href="#在远端建立分支-上传-或更新-內容至远端分支" class="headerlink" title="在远端建立分支 / 上传(或更新)內容至远端分支"></a>在远端建立分支 / 上传(或更新)內容至远端分支</h2><pre><code>git fetch &lt;分支名称&gt;</code></pre><h2 id="查看远端数据库分支的修改內容"><a href="#查看远端数据库分支的修改內容" class="headerlink" title="查看远端数据库分支的修改內容"></a>查看远端数据库分支的修改內容</h2><pre><code>git pull &lt;分支名称&gt; 合并(或更新)远端至本地端分支注：pull = fetch + mergegit push :&lt;分支名称&gt; 刪除远端分支git remote set-url &lt;名称&gt; &lt;新连接位址&gt;</code></pre><h2 id="修改远端数据库地址"><a href="#修改远端数据库地址" class="headerlink" title="修改远端数据库地址"></a>修改远端数据库地址</h2><pre><code>git remote rename &lt;旧名称&gt; &lt;新名称&gt;</code></pre><h2 id="修改远端数据库名称"><a href="#修改远端数据库名称" class="headerlink" title="修改远端数据库名称"></a>修改远端数据库名称</h2><h2 id="暂存"><a href="#暂存" class="headerlink" title="暂存"></a>暂存</h2><pre><code>git stash 暂存现在的修改狀況git stash list 列出暂存清单git stash apply 取出上一次暂存git stash pop 取出上一次暂存(该暂存会被移除)git stash@{id} 指定特定暂存git stash clear 清空所有暂存</code></pre><h2 id="操作提交记录"><a href="#操作提交记录" class="headerlink" title="操作提交记录"></a>操作提交记录</h2><pre><code>git commit --amend 修改上一次的commitgit reset HEAD 放弃该修改记录 (reset)git reset --soft HEAD^ 取消上一次 commit，並 保留 修改纪录git reset --hard HEAD^ 取消上一次 commit，並 刪除 修改纪录</code></pre><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】 <a href="https://blog.csdn.net/riddle1981/article/details/74938111" target="_blank" rel="noopener">https://blog.csdn.net/riddle1981/article/details/74938111</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git切换新分支，git fetch与git pull的区别，及常用命令集锦&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>数据库学习笔记III</title>
    <link href="http://yoursite.com/2019/09/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0IV/"/>
    <id>http://yoursite.com/2019/09/04/数据库学习笔记IV/</id>
    <published>2019-09-04T02:00:12.000Z</published>
    <updated>2019-09-04T03:34:31.396Z</updated>
    
    <content type="html"><![CDATA[<p>SQL插入，多表查询</p><a id="more"></a><h1 id="权限配置"><a href="#权限配置" class="headerlink" title="权限配置"></a>权限配置</h1><p>在reporting数据库中找到auth_users 表，代表的是用户信息，auth_roles代表的是不同的角色信息</p><p>auth_users_roles_rela代表的是不同用户所具有的角色，auth_resources代表资源，其中要添加之前写的inner和core里controller所具有的方法，type为FUNCTION，url就是执行的url，例如/notes/updateNote，level设置为1<br>auth_role_resources_rela是不同角色所具有的资源信息，<br>现在要使用SQL语句添加新的资源，将用户yang.kai</p><h1 id="INSERT语句"><a href="#INSERT语句" class="headerlink" title="INSERT语句"></a>INSERT语句</h1><p>基本语法是：</p><pre><code>INSERT INTO &lt;表名&gt; (字段1, 字段2, ...) VALUES (值1, 值2, ...);</code></pre><p>例如：<br>    INSERT INTO auth_resources<br>    (resource_name, external_id,resource_type,application_name,resource_url,status,parent_id,level,sort)<br>    VALUES<br>    (‘根据ID删除笔记’,-1,’FUNCTION’,’reporting’,’/notes/deleteNote’,’ACTIVE’,0,1,0)</p><p>还可以同时添加多条数据：</p><pre><code>INSERT INTO &lt;表名&gt; (字段1, 字段2, ...)VALUES (值1, 值2, ...),(值3, 值4, ...),(值5, 值6, ...);</code></pre><p>例如在auth_role_resources_rela中添加不同角色所拥有的资源信息：<br>    INSERT INTO auth_role_resources_rela<br>    (role_id,resource_id,status,created,updated)<br>    VALUES<br>    (3,43,’ACTIVE’,NOW(),NOW()),<br>    (3,44,’ACTIVE’,NOW(),NOW()),<br>    (3,45,’ACTIVE’,NOW(),NOW()),<br>    (3,46,’ACTIVE’,NOW(),NOW()),<br>    (3,47,’ACTIVE’,NOW(),NOW()),<br>    (3,48,’ACTIVE’,NOW(),NOW()),<br>    (3,49,’ACTIVE’,NOW(),NOW()),<br>    (3,50,’ACTIVE’,NOW(),NOW()),<br>    (3,51,’ACTIVE’,NOW(),NOW()),<br>    (3,52,’ACTIVE’,NOW(),NOW()),<br>    (3,53,’ACTIVE’,NOW(),NOW());</p><h1 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h1><p>auth_users表，代表的是用户信息，auth_roles代表的是不同的角色信息，</p><p>auth_users_roles_rela代表的是不同用户所具有的角色，</p><p>现在要根据用户账号查询某个用户所具有的所有角色id</p><pre><code>SELECT role_idFROM auth_usersINNER JOIN auth_user_roles_relaON auth_users.id=auth_user_roles_rela.user_idWHERE auth_users.account=&apos;kai.yang&apos;</code></pre><p>再根据角色id到auth_role_resources_rela中找到该角色所拥有的资源resource_id<br>    SELECT resource_id<br>    FROM auth_role_resources_rela<br>    WHERE role_id=(<br>      SELECT role_id<br>      FROM auth_users<br>      INNER JOIN auth_user_roles_rela<br>      ON auth_users.id=auth_user_roles_rela.user_id<br>      WHERE auth_users.account=’kai.yang’<br>      )</p><p>根据资源id连接查询auth_resources中的资源名称</p><pre><code>SELECT resource_nameFROM auth_resourcesINNER JOIN auth_role_resources_relaON auth_resources.id=auth_role_resources_rela(  SELECT resource_id  FROM auth_role_resources_rela  WHERE role_id=(    SELECT role_id    FROM auth_users    INNER JOIN auth_user_roles_rela    ON auth_users.id=auth_user_roles_rela.user_id    WHERE auth_users.account=&apos;kai.yang&apos;    )  )  auth_role_resources_rela</code></pre><h2 id="注意INNER-JOIN查询的写法"><a href="#注意INNER-JOIN查询的写法" class="headerlink" title="注意INNER JOIN查询的写法"></a>注意INNER JOIN查询的写法</h2><pre><code>先确定主表，仍然使用FROM &lt;表1&gt;的语法；再确定需要连接的表，使用INNER JOIN &lt;表2&gt;的语法；然后确定连接条件，使用ON &lt;条件...&gt;，这里的条件是auth_users.id=auth_user_roles_rela.user_id，表示auth_users表的id列与auth_user_roles_rela表的user_id列相同的行需要连接；可选：加上WHERE子句、ORDER BY等子句。使用别名不是必须的，但可以更好地简化查询语句。</code></pre><h2 id="内连接和外连接的区别："><a href="#内连接和外连接的区别：" class="headerlink" title="内连接和外连接的区别："></a>内连接和外连接的区别：</h2><p>假设查询语句是：</p><pre><code>SELECT ... FROM tableA ??? JOIN tableB ON tableA.column1 = tableB.column2;</code></pre><p>我们把tableA看作左表，把tableB看成右表，那么</p><p><strong><em>INNER JOIN是选出两张表都存在的记录</em></strong></p><p><strong><em>LEFT OUTER JOIN是选出左表存在的记录</em></strong></p><p><strong><em>RIGHT OUTER JOIN是选出右表存在的记录</em></strong></p><p><strong><em>FULL OUTER JOIN则是选出左右表都存在的记录</em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SQL插入，多表查询&lt;/p&gt;
    
    </summary>
    
      <category term="2019年9月" scheme="http://yoursite.com/categories/2019%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot学习笔记X</title>
    <link href="http://yoursite.com/2019/08/28/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0X/"/>
    <id>http://yoursite.com/2019/08/28/SpringBoot学习笔记X/</id>
    <published>2019-08-28T09:18:12.000Z</published>
    <updated>2019-09-04T08:14:02.287Z</updated>
    
    <content type="html"><![CDATA[<p>SpringBoot系统学习。</p><a id="more"></a><h1 id="使用lain在测试环境部署"><a href="#使用lain在测试环境部署" class="headerlink" title="使用lain在测试环境部署"></a>使用lain在测试环境部署</h1><p>测试环境网址<br><a href="http://console.laincloud.xyz/" target="_blank" rel="noopener">http://console.laincloud.xyz/</a><br>登陆后选择kael-query-test<br>先点击详情-》构建，然后在镜像选项中点击部署，进行项目的部署，<br>部署后选择SHELL，在/lain/logs/kael.log中查看日志</p><pre><code>tail -f</code></pre><h1 id="配置文件application-yml解读"><a href="#配置文件application-yml解读" class="headerlink" title="配置文件application.yml解读"></a>配置文件application.yml解读</h1><p>有必要解读一下SpringBoot项目中关于application.yml配置的一些问题：</p><p>首先看kael-starter中的pom.xml</p><pre><code>&lt;profiles&gt;    &lt;profile&gt;        &lt;id&gt;prod&lt;/id&gt;        &lt;properties&gt;            &lt;env&gt;prod&lt;/env&gt;        &lt;/properties&gt;    &lt;/profile&gt;    &lt;profile&gt;        &lt;id&gt;local&lt;/id&gt;        &lt;activation&gt;            &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;        &lt;/activation&gt;        &lt;properties&gt;            &lt;env&gt;local&lt;/env&gt;        &lt;/properties&gt;    &lt;/profile&gt;    &lt;profile&gt;        &lt;id&gt;staging&lt;/id&gt;        &lt;properties&gt;            &lt;env&gt;staging&lt;/env&gt;        &lt;/properties&gt;    &lt;/profile&gt;&lt;/profiles&gt;</code></pre><p>三个环境分别是生产环境，本地环境和测试环境，其中</p><pre><code>&lt;activation&gt;    &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;&lt;/activation&gt;  </code></pre><p>代表使用的是本地环境。</p><p>在这个pom.xml中还有：</p><pre><code>&lt;resources&gt;     &lt;resource&gt;         &lt;directory&gt;src/main/resources&lt;/directory&gt;         &lt;includes&gt;             &lt;include&gt;**/*.*&lt;/include&gt; &lt;!-- 此配置不可缺，否则mybatis的Mapper.xml将会丢失 --&gt;         &lt;/includes&gt;         &lt;filtering&gt;false&lt;/filtering&gt;     &lt;/resource&gt;     &lt;resource&gt;         &lt;directory&gt;src/main/resources.${env}&lt;/directory&gt;     &lt;/resource&gt; &lt;/resources&gt;</code></pre><p>在进行加载时首先加载resources文件夹中的application.yml<br>其中的内容是：</p><pre><code>spring:  profiles.active: env</code></pre><p>而在resources.local文件夹中的application-env.yml中</p><pre><code>application.mode: localspring:  zipkin:    base-url: http://std-zipkin.laincloud.xyz/  datasource:    url: jdbc:mysql://10.143.248.78:3306/kael_query?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;failOverReadOnly=false    driver-class-name: com.mysql.jdbc.Driver    username: root    password: 123456kael:  datasource:    druidDataSourceList:      #  前期通过yml配置，后期有需要可以迁移出去配置      - name: kael_query        type: com.alibaba.druid.pool.DruidDataSource        driver-class-name: com.mysql.jdbc.Driver        url: jdbc:mysql://10.143.248.78:3306/kael_query?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;failOverReadOnly=false        username: root        password: mojiti        #      filters: stat,wall,log4j,config        max-active: 20        initial-size: 10        max-wait: 1000        min-idle: 1        max-idle: 10        time-between-eviction-runs-millis: 60000        min-evictable-idle-time-millis: 300000        validation-query: select &apos;x&apos;        test-while-idle: true        test-on-borrow: false        test-on-return: false        pool-prepared-statements: true        max-open-prepared-statements: 50        max-pool-prepared-statement-per-connection-size: 20      - name: shangtongdai        type: com.alibaba.druid.pool.DruidDataSource        driver-class-name: com.mysql.jdbc.Driver        url: jdbc:mysql://10.143.248.78:3306/shangtongdai?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;failOverReadOnly=false        username: root        password: mojiti          #      filters: stat,wall,log4j,config        max-active: 20        initial-size: 10        max-wait: 1000        min-idle: 1        max-idle: 10        time-between-eviction-runs-millis: 60000        min-evictable-idle-time-millis: 300000        validation-query: select &apos;x&apos;        test-while-idle: true        test-on-borrow: false        test-on-return: false        pool-prepared-statements: true        max-open-prepared-statements: 50        max-pool-prepared-statement-per-connection-size: 20      #  前期通过yml配置，后期有需要可以迁移出去配置# Actuator 配置management.endpoints.web:  exposure.include: &quot;*&quot;  exposure.exclude: env,beanseureka:  client:    register-with-eureka: true    fetch-registry: true    serviceUrl:      defaultZone: http://std-eureka.laincloud.xyz/eureka/swagger:  enable: true</code></pre><p>其中指明了application.mode: local所以在加载的时候也要加载它，而</p><pre><code>spring:  profiles.active: env</code></pre><p>则说明在加载时读取的application-env.yml文件名中可以加上-env</p><h1 id="多条件模糊分页查询遇到的问题"><a href="#多条件模糊分页查询遇到的问题" class="headerlink" title="多条件模糊分页查询遇到的问题"></a>多条件模糊分页查询遇到的问题</h1><p>当一些查询条件为NULL或空字符串“”</p><pre><code>/**  * 分页查询  * 分页参数pageNo(页码） ，pageSize(每页查询数目）  */ @Override public PageInfo&lt;TblJobsEntity&gt; queryTblJobByPage(int pageNo, int pageSize, TblJobsEntity tblJobsEntity,     Date createTimeBegin, Date createTimeEnd, Date updateTimeBegin, Date updateTimeEnd) {     //查询     String tag = tblJobsEntity.getTag();     String receiver = tblJobsEntity.getReceiver();     PageHelper.startPage(pageNo, pageSize);     TblJobsEntityExample tblJobsEntityExample = new TblJobsEntityExample();     TblJobsEntityExample.Criteria criteria = tblJobsEntityExample.createCriteria();     //使用StringUtil.isEmpty()而不是==来判断，因为==判断的是地址     if (!StringUtils.isEmpty(tag)) {         //模糊匹配的通配符         tag = &quot;%&quot; + tag + &quot;%&quot;;         criteria.andTagLike(tag);     }     //如果存在该属性为NULL或空字符串&quot;&quot;的时候，需要进行判断，之前出现的错误是只判断该属性是否为NULL而未判断是否为&quot;&quot;空字符串     if (!StringUtils.isEmpty(receiver)) {         receiver = &quot;%&quot; + receiver + &quot;%&quot;;         criteria.andReceiverLike(receiver);     }     if (createTimeBegin != null &amp;&amp; createTimeEnd != null) {         criteria.andCreateTimeBetween(createTimeBegin, createTimeEnd);     }     if (updateTimeBegin != null &amp;&amp; updateTimeEnd != null) {         criteria.andUpdateTimeBetween(updateTimeBegin, updateTimeEnd);     }     List&lt;TblJobsEntity&gt; tblJobsEntityList = tblJobsEntityMapper.selectByExample(tblJobsEntityExample);     //用PageInfo对结果进行包装     PageInfo&lt;TblJobsEntity&gt; pageInfo = new PageInfo&lt;TblJobsEntity&gt;(tblJobsEntityList);     return pageInfo; }</code></pre><h1 id="通过日志调试定时任务执行情况"><a href="#通过日志调试定时任务执行情况" class="headerlink" title="通过日志调试定时任务执行情况"></a>通过日志调试定时任务执行情况</h1><p>在resources.local中添加logback.xml文件，改动 <logger name="cn.kael.query.inner.dao" level="DEBUG">中的level</logger></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt;    &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;        &lt;encoder&gt;            &lt;pattern&gt;%d{yyyy.MM.dd HH:mm:ss.SSS}|%X{TRACE_ID}|%thread|%p|%c:%line|%m%n&lt;/pattern&gt;        &lt;/encoder&gt;    &lt;/appender&gt;    &lt;root level=&quot;INFO&quot;&gt;        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;    &lt;/root&gt;    &lt;!--&lt;logger name=&quot;org.springframework.amqp&quot; level=&quot;info&quot; additivity=&quot;false&quot;&gt;--&gt;    &lt;!--&lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;--&gt;    &lt;!--&lt;/logger&gt;--&gt;    &lt;!--&lt;logger name=&quot;org.mybatis&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;--&gt;    &lt;!--&lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;--&gt;    &lt;!--&lt;/logger&gt;--&gt;    &lt;!--&lt;logger name=&quot;org.apache.zookeeper&quot; level=&quot;ERROR&quot; additivity=&quot;false&quot;&gt;--&gt;    &lt;!--&lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;--&gt;    &lt;!--&lt;/logger&gt;--&gt;    &lt;!--&lt;logger name=&quot;java.sql.Connection&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;--&gt;    &lt;!--&lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;--&gt;    &lt;!--&lt;/logger&gt;--&gt;    &lt;!--&lt;logger name=&quot;java.sql.Statement&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;--&gt;    &lt;!--&lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;--&gt;    &lt;!--&lt;/logger&gt;--&gt;    &lt;!--&lt;logger name=&quot;java.sql.PreparedStatement&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;--&gt;    &lt;!--&lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;--&gt;    &lt;!--&lt;/logger&gt;--&gt;    &lt;logger name=&quot;org.springframework.data.redis&quot; level=&quot;INFO&quot; additivity=&quot;false&quot;&gt;        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;    &lt;/logger&gt;    &lt;logger name=&quot;redis.clients&quot; level=&quot;INFO&quot; additivity=&quot;false&quot;&gt;        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;    &lt;/logger&gt;    &lt;logger name=&quot;cn.kael.query.inner.dao&quot; level=&quot;DEBUG&quot; /&gt;&lt;/configuration&gt;</code></pre><h1 id="Mybatis中自动生成主键"><a href="#Mybatis中自动生成主键" class="headerlink" title="Mybatis中自动生成主键"></a>Mybatis中自动生成主键</h1><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>在使用例如</p><pre><code>tblJobsEntityMapper.insertSelective(tblJobsEntity);</code></pre><p>进行数据插入时，由于数据库的ID为自动插入：</p><pre><code>`id` bigint(20) NOT NULL AUTO_INCREMENT,</code></pre><p>所以RequestDTO里往往没有传入id，这时会导致后面的在Quartz中添加定时任务时获取到的id为null</p><pre><code>//在Quartz中添加定时任务taskManager.addJob(tblJobsEntity.getId(), tblJobsEntity.getCron(), tblJobsEntity.getMemo());</code></pre><h2 id="解决的方法"><a href="#解决的方法" class="headerlink" title="解决的方法"></a>解决的方法</h2><p>可以在数据库中查询再获取id，但为了减小数据库查询的压力，所以要使用Mybatis的自带配置来进行自动插入id，</p><p>在TblJobsEntityMapper.xml中添加配置，在INSERT语句中，我们为可以自动生成（auto-generated）主键的列 id 插入值。</p><p>我们可以使用useGeneratedKeys和keyProperty属性让数据库生成auto_increment列的值，并将生成的值设置到其中一个输入对象属性内，如下所示：     </p><pre><code>&lt;/insert&gt;  &lt;insert id=&quot;insertSelective&quot; parameterType=&quot;cn.kael.query.inner.entity.TblJobsEntity&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;  ......&lt;/insert&gt;</code></pre><p> 这里id列值将会被数据库自动生成(如mysql)，并且生成的值会被设置到tblJobsEntity对象的id属性上</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://blog.csdn.net/suwu150/article/details/52895855" target="_blank" rel="noopener">https://blog.csdn.net/suwu150/article/details/52895855</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SpringBoot系统学习。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年8月" scheme="http://yoursite.com/categories/2019%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="SpringBoot，Java" scheme="http://yoursite.com/tags/SpringBoot%EF%BC%8CJava/"/>
    
  </entry>
  
  <entry>
    <title>数据库学习笔记III</title>
    <link href="http://yoursite.com/2019/08/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0III/"/>
    <id>http://yoursite.com/2019/08/27/数据库学习笔记III/</id>
    <published>2019-08-27T03:52:12.000Z</published>
    <updated>2019-08-27T07:24:35.636Z</updated>
    
    <content type="html"><![CDATA[<p>重新温习SQL语句中的模糊匹配</p><a id="more"></a><h1 id="模糊匹配"><a href="#模糊匹配" class="headerlink" title="模糊匹配"></a>模糊匹配</h1><p>在进行数据库查询的时候，有完整查询和模糊查询之分。<br>一般模糊查询语句如下：</p><p>  SELECT 字段 FROM 表 WHERE 某字段 Like 条件<br>其中的条件，SQL有四种匹配模式：</p><h2 id=""><a href="#" class="headerlink" title="%"></a>%</h2><p>表示任意0个或多个字符，可匹配任意类型和长度的字符，有些情况下若是中文，请使用两个百分号（%%）表示。</p><p>例如</p><pre><code>SELECT * FROM user WHERE name LIKE &apos;%一%&apos;</code></pre><p>将会把name为“一野”，”李一野”，“一休和尚”等等有”一”的记录都找出来。</p><p>另外如果需要找出name中既有“一”又有”野”的记录，请使用and条件</p><pre><code>SELECT *   FROM user  WHERE name  LIKE &apos;%一%&apos;  AND  name LIKE &apos;%野%&apos;</code></pre><p>而如果使用</p><pre><code>SELECT *  FROM user  WHERE name  LIKE &apos;%一%野%&apos;</code></pre><p>虽然能够搜索出“李一野”，但不能搜索出符合条件的”野一李”。</p><h2 id="-1"><a href="#-1" class="headerlink" title="_"></a>_</h2><p>表示任意单个字符，匹配单个任意字符，它常用来限制表达式的字符长度语句：</p><p>比如</p><pre><code>SELECT *  FROM user  WHERE name  LIKE &apos;_三_&apos;</code></pre><p>只能找出“唐三藏”这样name为三个字且中间一个字是”三”的；</p><p>例如</p><pre><code>SELECT *  FROM user  WHERE name  LIKE &apos;三__&apos;</code></pre><p>只能找出“三国杀”这样name为三个字且第一字为”三”的；</p><h2 id="-2"><a href="#-2" class="headerlink" title="[]"></a>[]</h2><p>表示括号内所列字符中的一个（类似正则表达式）。制定一个字符、字符串或范围，要求所匹配对象为它们中的人一个。</p><p>比如</p><pre><code>SELECT *  FROM user  WHERE name  LIKE &apos;[张王李]三&apos;</code></pre><p>搜索出的是“张三”，“王三”，”李三”，而不是“张王李三”；</p><p>如果[]内有一系列字符（01234，abcd之类)，则可以简写为“0-4”、“a-d”</p><pre><code>SELECT *  FROM user  WHERE name  LIKE &apos;大[a-d]&apos;</code></pre><p>将搜索出“大a”、……、“大d”；</p><h2 id="-3"><a href="#-3" class="headerlink" title="[^]"></a>[^]</h2><p>表示不在括号所列之内的单个字符。其取值和[]相同，但它要求所匹配对象为指定字符以外的任一个字符。</p><p>比如</p><pre><code>SELECT *  FROM user  WHERE name  LIKE &apos;[^张王李]三&apos;</code></pre><p>将找出不姓“张”，“王”，”李”的“赵三”，”孙三”等。</p><pre><code>SELECT *  FROM user  WHERE name  LIKE &apos;大[^a-d]&apos;</code></pre><p>将排除“大a”到“大d”，搜索“大e”、”大f”、……</p><h2 id="查询内容包含通配符时"><a href="#查询内容包含通配符时" class="headerlink" title="查询内容包含通配符时"></a>查询内容包含通配符时</h2><p>由于通配符会使得我们查询特殊字符“%”、”_”、“[”的语句无法正常实现，而把特殊字符用“[]”括起来便可以正常查询。</p><h2 id="多条件模糊查询"><a href="#多条件模糊查询" class="headerlink" title="多条件模糊查询"></a>多条件模糊查询</h2><p>看上去我们可以使用AND连接进行多条件模糊查询</p><pre><code>SELECT * FROM user WHERE name LIKE &apos;%三%&apos; AND phone LIKE ‘%1234%’</code></pre><p>但在实际使用时会发现如果数据库的查询字段不是都有值的情况下无法搜索到，</p><p>例如某记录name为“三国杀” ，phone没有值也不是null，因为电话没有值素以经过and运算后结果为false，没有输出。显然数据库中的对应字段必须有值，否则会漏掉正确的输出结果。</p><p>正确的输入应该为name为“三国杀”，phone为null，这样经过and运算后结果为true，可以输出正确结果</p><p>如何解决数据库中查询字段没有值时的多条件模糊匹配在网上搜了一些解决方法但暂未找到比较易懂但方法，留待后面解决</p><h2 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h2><p>sql语句</p><pre><code>sql=“select * from user where name like ...”</code></pre><p>必须在一行内输入完，而不能用回车符分段，因为vbs多行被认为是多个语句，这是许多初写者常犯的错误。如果你想分多段写，可以用上面的方法在现有变量基础上逐步增加查询语句的各个组成部分并把它存在同一变量内实现。在封闭引号之前或者在打开引号之后你需要增加空格，这样才能保证字符串连接起来的时候没有把几个词凑到了一块。</p><p>最后注意以上查询的LIKE后要加单引号。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="https://www.cnblogs.com/GT_Andy/archive/2009/12/25/1921914.html" target="_blank" rel="noopener">https://www.cnblogs.com/GT_Andy/archive/2009/12/25/1921914.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重新温习SQL语句中的模糊匹配&lt;/p&gt;
    
    </summary>
    
      <category term="2019年8月" scheme="http://yoursite.com/categories/2019%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记IV</title>
    <link href="http://yoursite.com/2019/08/12/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0IV/"/>
    <id>http://yoursite.com/2019/08/12/Java学习笔记IV/</id>
    <published>2019-08-12T06:48:12.000Z</published>
    <updated>2019-08-13T06:12:56.686Z</updated>
    
    <content type="html"><![CDATA[<p>MapReduce思想学习,对Java8中对新特性stream，map和reduce进行学习，Stream API部分主要来自于IBM Developer官网，原文写的非常详尽清晰。</p><a id="more"></a><h1 id="MapReduce思想及Java中的实现"><a href="#MapReduce思想及Java中的实现" class="headerlink" title="MapReduce思想及Java中的实现"></a>MapReduce思想及Java中的实现</h1><p>MapReduce源于Google一篇论文，它充分借鉴了分而治之的思想，将一个数据处理过程拆分为主要的Map(映射)与Reduce(化简)两步。用户不懂分布式计算框架的内部运行机制，只要能用Map和Reduce的思想描述清楚要处理的问题，即编写map()和reduce( )函数，就能轻松地使问题的计算实现分布式，并在Hadoop上运行。MapReduce的编程具有以下特点。</p><h2 id="开发简单"><a href="#开发简单" class="headerlink" title="开发简单:"></a>开发简单:</h2><p>得益于MapReduce的编程模型，用户可以不用考虑进程间通信、套接字编程，无需非常高深的技巧，只需要实现一些非常简单的逻辑，其他的交由MapReduce计算框架去完成，大大简化了分布式程序的编写难度。</p><h2 id="可扩展性强"><a href="#可扩展性强" class="headerlink" title="可扩展性强:"></a>可扩展性强:</h2><p>同HDFS一样，当集群资源不能满足计算需求时，可以通过增加节点的方式达到线性扩展集群的目的。</p><h2 id="容错性强"><a href="#容错性强" class="headerlink" title="容错性强:"></a>容错性强:</h2><p>对于节点故障导致的作业失败，MapReduce计算框架会自动将作业安排到健康节点重新执行，直到任务完成，而这些，对于用户来说都是透明的。</p><h2 id="MapReduce的编程思想"><a href="#MapReduce的编程思想" class="headerlink" title="MapReduce的编程思想"></a>MapReduce的编程思想</h2><p>Map(映射)与Reduce(化简)来源于LISP和其他函数式编程语言中的古老的映射和化简操作，MapReduce操作数据的最小单位是一个键值对。用户在使用MapReduce编程模型的时候，第一步就需要将数据抽象为键值对的形式，接着<strong><em>map函数</em></strong> 会以键值对作为输入，经过map函数的处理，产生一系类新的键值对作为中间结果输出到本地。MapReduce计算框架会自动将这些中间结果数据按照键做聚合处理，并将键相同的数据分发给reduce函数处理(用户可以设置分发规则)。<strong><em>reduce函数</em></strong> 以键和对应的值的集合作为输入，经过reduce函数的处理后，产生了另外一系列键值对作为最终输出。</p><p>如果用表达式表示，其过程如下式所示 :</p><pre><code>{Keyl，Value1}~{Key2, List&lt;Value2&gt;}~{Key3, Value3}</code></pre><p>读者可能觉得上面的描述和表达式非常抽象，那么让我们先来看一个例子。有一篮苹果，一些是红苹果，一些是青苹果，每个苹果有一个唯一编号，要解决的问题是统计该篮苹果的数目、红苹果(深色)的个数和青苹果(浅色)的个数。</p><p><img src="assets/markdown-img-paste-20190806142009358.png" alt="https://img-blog.csdn.net/20170502224501777?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDgwMTQzOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p><p>  假设有A, B, C三个人，A获得第一排苹果，B获得第二排苹果，这时，A和B分别统计自己手上的苹果的个数，然后将结果告知C, C将A, B的结果做一次汇总，得到最后结果。对于这个过程，其实用到了MapReduce的思想。我们可以从下一幅图看出端倪。</p><p><img src="assets/markdown-img-paste-20190806142045676.png" alt="https://img-blog.csdn.net/20170502224831447?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDgwMTQzOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p><p>A的map函数的输入的格式为键值对appleId-count，比女fl “ 11-1”表示appleId为11的苹果个数为1，经过map函数的累和，即将所有appleId的count相加，输出为新的键值对AppleCount-6，此时B也进行同样的操作，由于A和B的map函数输出的键值对的键相同，都为“AppleCount”，所以MapReduce框架会将其都分发到C作为reduce函数的输入，并在reduce函数中完成对键相同的值的累和，并输出最后结果AppleCount-12。如果用表达式表示，即为:</p><pre><code>(appleId, count}一&gt;(AppleCount，List&lt;count&gt;}一&gt;{AppleCount，count}</code></pre><p>在这个例子中，就是用MapReduce的思想来完成苹果计数的问题，细心的读者可能发现，这个例子中reduce函数只执行了一次，是否可以执行多次呢，答案是肯定的，下面来看用MapReduce思想解决对红苹果和青苹果分别计数的问题。</p><p>假设有A, B. C, D四个人，A获得第一排苹果，B获得第二排苹果，A将手上的红苹果给C、青苹果给D、B将手上的红苹果给C、青苹果给D。C, D再统计各自手上的结果，得到最后结果，如下图所示。</p><p><img src="assets/markdown-img-paste-20190806142148349.png" alt="https://img-blog.csdn.net/20170502225302823?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDgwMTQzOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p><p>A的map函数的输入同上次一样，在map函数中，用color和appleId作为新的键值对重新输出，B也做同样的操作。而A, B的map函数的输出的键值对会因为不同的键被分别分发到C和D执行:reduce函数，而真正的计数是由reduce函数完成，并输出最后结果。这里:reduce函数一共执行了两次，第一次是处理键为Red的数据.第二次是处理键为Green的数据。如果用表达式表示，即为:</p><pre><code>{appleId, count}~{color, List&lt;appleId&gt;}~{color, count}</code></pre><p>要理解MapReduce的编程思想，其核心的一点就是将数据用键值对表示。在现实生活中，很多数据要么本身就为键值对的形式，要么可以用键值对这种方式来表示，例如电话号码和通话记录，文件名和文件存储的数据等，键值对并不是高端数据挖掘独有的数据模型，而是存在于我们身边非常普通的模型。</p><p>利用分而治之的思想，可以将很多复杂的数据分析问题转变为一系列MapReduce作业，利用Hadoop的提供MapReduce计算框架，实现分布式计算，这样就能对海量数据进行复杂的数据分析，这也是MapReduce的意义所在。</p><h1 id="Java8-中的Stream"><a href="#Java8-中的Stream" class="headerlink" title="Java8 中的Stream"></a>Java8 中的Stream</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。所以说，Java 8 中首次出现的 java.util.stream 是一个函数式语言+多核时代综合影响的产物。</p><h2 id="什么是聚合操作"><a href="#什么是聚合操作" class="headerlink" title="什么是聚合操作"></a>什么是聚合操作</h2><p>在传统的 J2EE 应用中，Java 代码经常不得不依赖于关系型数据库的聚合操作来完成诸如：</p><p>客户每月平均消费金额</p><p>最昂贵的在售商品</p><p>本周完成的有效订单（排除了无效的）</p><p>取十个数据样本作为首页推荐</p><p>这类的操作。</p><p>但在当今这个数据大爆炸的时代，在数据来源多样化、数据海量化的今天，很多时候不得不脱离 RDBMS，或者以底层返回的数据为基础进行更上层的数据统计。而 Java 的集合 API 中，仅仅有极少量的辅助型方法，更多的时候是程序员需要用 Iterator 来遍历集合，完成相关的聚合应用逻辑。这是一种远不够高效、笨拙的方法。在 Java 7 中，如果要发现 type 为 grocery 的所有交易，然后返回以交易值降序排序好的交易 ID 集合，我们需要这样写：</p><h3 id="Java-7-的排序、取值实现"><a href="#Java-7-的排序、取值实现" class="headerlink" title="Java 7 的排序、取值实现"></a>Java 7 的排序、取值实现</h3><pre><code>List&lt;Transaction&gt; groceryTransactions = new Arraylist&lt;&gt;();for(Transaction t: transactions){ if(t.getType() == Transaction.GROCERY){ groceryTransactions.add(t); }}Collections.sort(groceryTransactions, new Comparator(){ public int compare(Transaction t1, Transaction t2){ return t2.getValue().compareTo(t1.getValue()); }});List&lt;Integer&gt; transactionIds = new ArrayList&lt;&gt;();for(Transaction t: groceryTransactions){ transactionsIds.add(t.getId());}</code></pre><p>而在 Java 8 使用 Stream，代码更加简洁易读；而且使用并发模式，程序执行速度更快。</p><h3 id="Java-8-的排序、取值实现"><a href="#Java-8-的排序、取值实现" class="headerlink" title="Java 8 的排序、取值实现"></a>Java 8 的排序、取值实现</h3><pre><code>List&lt;Integer&gt; transactionsIds = transactions.parallelStream(). filter(t -&gt; t.getType() == Transaction.GROCERY). sorted(comparing(Transaction::getValue).reversed()). map(Transaction::getId). collect(toList());</code></pre><h2 id="Stream总览"><a href="#Stream总览" class="headerlink" title="Stream总览"></a>Stream总览</h2><h3 id="什么是流"><a href="#什么是流" class="headerlink" title="什么是流"></a>什么是流</h3><p>Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。</p><p>Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。</p><p>而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。</p><p>而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。</p><p>Stream 的并行操作依赖于 Java7 中引入的 Fork/Join 框架（JSR166y）来拆分任务和加速处理过程。Java 的并行 API 演变历程基本如下：</p><p>1.0-1.4 中的 java.lang.Thread</p><p>5.0 中的 java.util.concurrent</p><p>6.0 中的 Phasers 等</p><p>7.0 中的 Fork/Join 框架</p><p>8.0 中的 Lambda</p><p>Stream 的另外一大特点是，数据源本身可以是无限的。</p><h3 id="流的构成"><a href="#流的构成" class="headerlink" title="流的构成"></a>流的构成</h3><p>当我们使用一个流的时候，通常包括三个基本步骤：</p><p>获取一个数据源（source）→ 数据转换→执行操作获取想要的结果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道，如下图所示。</p><p><img src="assets/markdown-img-paste-20190806173551210.png" alt="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/img001.png"></p><p>图1:流管道 (Stream Pipeline) 的构成</p><p>有多种方式生成 Stream Source：</p><h4 id="从-Collection-和数组"><a href="#从-Collection-和数组" class="headerlink" title="从 Collection 和数组"></a>从 Collection 和数组</h4><p>Collection.stream()</p><p>Collection.parallelStream()</p><p>Arrays.stream(T array) or Stream.of()</p><h4 id="从-BufferedReader"><a href="#从-BufferedReader" class="headerlink" title="从 BufferedReader"></a>从 BufferedReader</h4><p>java.io.BufferedReader.lines()</p><h4 id="静态工厂"><a href="#静态工厂" class="headerlink" title="静态工厂"></a>静态工厂</h4><p>java.util.stream.IntStream.range()<br>java.nio.file.Files.walk()</p><h4 id="自己构建"><a href="#自己构建" class="headerlink" title="自己构建"></a>自己构建</h4><p>java.util.Spliterator</p><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>Random.ints()</p><p>BitSet.stream()</p><p>Pattern.splitAsStream(java.lang.CharSequence)</p><p>JarFile.stream()</p><h3 id="流的操作类型分为两种："><a href="#流的操作类型分为两种：" class="headerlink" title="流的操作类型分为两种："></a>流的操作类型分为两种：</h3><h4 id="Intermediate："><a href="#Intermediate：" class="headerlink" title="Intermediate："></a>Intermediate：</h4><p>一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。</p><h4 id="Terminal："><a href="#Terminal：" class="headerlink" title="Terminal："></a>Terminal：</h4><p>一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。</p><p>在对于一个 Stream 进行多次转换操作 (Intermediate 操作)，每次都对 Stream 的每个元素进行转换，而且是执行多次，这样时间复杂度就是 N（转换次数）个 for 循环里把所有操作都做掉的总和吗？其实不是这样的，转换操作都是 lazy 的，多个转换操作只会在 Terminal 操作的时候融合起来，一次循环完成。</p><p>我们可以这样简单的理解，Stream 里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在 Terminal 操作的时候循环 Stream 对应的集合，然后对每个元素执行所有的函数。</p><p>还有一种操作被称为 <strong><em>short-circuiting</em></strong>。用以指：</p><p>对于一个 intermediate 操作，如果它接受的是一个无限大（infinite/unbounded）的 Stream，但返回一个有限的新 Stream。</p><p>对于一个 terminal 操作，如果它接受的是一个无限大的 Stream，但能在有限的时间计算出结果。</p><p>当操作一个无限大的 Stream，而又希望在有限时间内完成操作，则在管道内拥有一个 short-circuiting 操作是必要非充分条件。</p><h3 id="一个流操作的示例"><a href="#一个流操作的示例" class="headerlink" title="一个流操作的示例"></a>一个流操作的示例</h3><pre><code>int sum = widgets.stream().filter(w -&gt; w.getColor() == RED) .mapToInt(w -&gt; w.getWeight()) .sum();</code></pre><p>stream() 获取当前小物件的 source，filter 和 mapToInt 为 intermediate 操作，进行数据筛选和转换，最后一个 sum() 为 terminal 操作，对符合条件的全部小物件作重量求和。</p><h2 id="流的使用详解"><a href="#流的使用详解" class="headerlink" title="流的使用详解"></a>流的使用详解</h2><p>简单说，对 Stream 的使用就是实现一个 filter-map-reduce 过程，产生一个最终结果，或者导致一个副作用（side effect）。</p><p>流的构造与转换</p><p>下面提供最常见的几种构造 Stream 的样例。</p><h3 id="构造流的几种常见方法"><a href="#构造流的几种常见方法" class="headerlink" title="构造流的几种常见方法"></a>构造流的几种常见方法</h3><pre><code>// 1. Individual valuesStream stream = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);// 2. ArraysString [] strArray = new String[] {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;};stream = Stream.of(strArray);stream = Arrays.stream(strArray);// 3. CollectionsList&lt;String&gt; list = Arrays.asList(strArray);stream = list.stream();</code></pre><p>需要注意的是，对于基本数值型，目前有三种对应的包装类型 Stream：</p><p>IntStream、LongStream、DoubleStream。</p><p>当然我们也可以用 Stream<integer>、Stream<long> &gt;、Stream<double>，但是 boxing 和 unboxing 会很耗时，所以特别为这三种基本数值型提供了对应的 Stream。</double></long></integer></p><p>Java 8 中还没有提供其它数值型 Stream，因为这将导致扩增的内容较多。而常规的数值型聚合运算可以通过上面三种 Stream 进行。</p><h3 id="数值流的构造"><a href="#数值流的构造" class="headerlink" title="数值流的构造"></a>数值流的构造</h3><pre><code>IntStream.of(new int[]{1, 2, 3}).forEach(System.out::println);IntStream.range(1, 3).forEach(System.out::println);IntStream.rangeClosed(1, 3).forEach(System.out::println);</code></pre><h3 id="流转换为其它数据结构"><a href="#流转换为其它数据结构" class="headerlink" title="流转换为其它数据结构"></a>流转换为其它数据结构</h3><pre><code>// 1. ArrayString[] strArray1 = stream.toArray(String[]::new);// 2. CollectionList&lt;String&gt; list1 = stream.collect(Collectors.toList());List&lt;String&gt; list2 = stream.collect(Collectors.toCollection(ArrayList::new));Set set1 = stream.collect(Collectors.toSet());Stack stack1 = stream.collect(Collectors.toCollection(Stack::new));// 3. StringString str = stream.collect(Collectors.joining()).toString();</code></pre><p>一个 Stream 只可以使用一次，上面的代码为了简洁而重复使用了数次。</p><h2 id="流的操作"><a href="#流的操作" class="headerlink" title="流的操作"></a>流的操作</h2><p>接下来，当把一个数据结构包装成 Stream 后，就要开始对里面的元素进行各类操作了。常见的操作可以归类如下。</p><h3 id="Intermediate：-1"><a href="#Intermediate：-1" class="headerlink" title="Intermediate："></a>Intermediate：</h3><p>map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered</p><h3 id="Terminal：-1"><a href="#Terminal：-1" class="headerlink" title="Terminal："></a>Terminal：</h3><p>forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator</p><h3 id="Short-circuiting："><a href="#Short-circuiting：" class="headerlink" title="Short-circuiting："></a>Short-circuiting：</h3><p>anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit</p><p>我们下面看一下 Stream 的比较典型用法。</p><h2 id="map-flatMap"><a href="#map-flatMap" class="headerlink" title="map/flatMap"></a>map/flatMap</h2><p>我们先来看 map。如果你熟悉 scala 这类函数式语言，对这个方法应该很了解，它的作用就是把 input Stream 的每一个元素，映射成 output Stream 的另外一个元素。</p><h3 id="转换大写"><a href="#转换大写" class="headerlink" title="转换大写"></a>转换大写</h3><pre><code>List&lt;String&gt; output = wordList.stream().map(String::toUpperCase).collect(Collectors.toList());</code></pre><p>这段代码把所有的单词转换为大写。</p><h3 id="平方数"><a href="#平方数" class="headerlink" title="平方数"></a>平方数</h3><pre><code>List&lt;Integer&gt; nums = Arrays.asList(1, 2, 3, 4);List&lt;Integer&gt; squareNums = nums.stream().map(n -&gt; n * n).collect(Collectors.toList());</code></pre><p>  这段代码生成一个整数 list 的平方数 {1, 4, 9, 16}。</p><p>  从上面例子可以看出，map 生成的是个 1:1 映射，每个输入元素，都按照规则转换成为另外一个元素。还有一些场景，是一对多映射关系的，这时需要 flatMap。</p><h3 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h3><pre><code>Stream&lt;List&lt;Integer&gt;&gt; inputStream = Stream.of( Arrays.asList(1), Arrays.asList(2, 3), Arrays.asList(4, 5, 6) );Stream&lt;Integer&gt; outputStream = inputStream.flatMap((childList) -&gt; childList.stream());</code></pre><p>flatMap 把 input Stream 中的层级结构扁平化，就是将最底层元素抽出来放到一起，最终 output 的新 Stream 里面已经没有 List 了，都是直接的数字。</p><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>filter 对原始 Stream 进行某项测试，通过测试的元素被留下来生成一个新 Stream。</p><h3 id="留下偶数"><a href="#留下偶数" class="headerlink" title="留下偶数"></a>留下偶数</h3><pre><code>Integer[] sixNums = {1, 2, 3, 4, 5, 6};Integer[] evens =Stream.of(sixNums).filter(n -&gt; n%2 == 0).toArray(Integer[]::new);</code></pre><p>经过条件“被 2 整除”的 filter，剩下的数字为 {2, 4, 6}。</p><h3 id="把单词挑出来"><a href="#把单词挑出来" class="headerlink" title="把单词挑出来"></a>把单词挑出来</h3><pre><code>List&lt;String&gt; output = reader.lines(). flatMap(line -&gt; Stream.of(line.split(REGEXP))). filter(word -&gt; word.length() &gt; 0). collect(Collectors.toList());</code></pre><p>这段代码首先把每行的单词用 flatMap 整理到新的 Stream，然后保留长度不为 0 的，就是整篇文章中的全部单词了。</p><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><p>forEach 方法接收一个 Lambda 表达式，然后在 Stream 的每一个元素上执行该表达式。</p><h3 id="打印姓名（forEach-和-pre-java8-的对比）"><a href="#打印姓名（forEach-和-pre-java8-的对比）" class="headerlink" title="打印姓名（forEach 和 pre-java8 的对比）"></a>打印姓名（forEach 和 pre-java8 的对比）</h3><pre><code>// Java 8roster.stream() .filter(p -&gt; p.getGender() == Person.Sex.MALE) .forEach(p -&gt; System.out.println(p.getName()));// Pre-Java 8for (Person p : roster) { if (p.getGender() == Person.Sex.MALE) { System.out.println(p.getName()); }}</code></pre><p>对一个人员集合遍历，找出男性并打印姓名。可以看出来，forEach 是为 Lambda 而设计的，保持了最紧凑的风格。而且 Lambda 表达式本身是可以重用的，非常方便。当需要为多核系统优化时，可以 parallelStream().forEach()，只是此时原有元素的次序没法保证，并行的情况下将改变串行时操作的行为，此时 forEach 本身的实现不需要调整，而 Java8 以前的 for 循环 code 可能需要加入额外的多线程逻辑。</p><p>但一般认为，forEach 和常规 for 循环的差异不涉及到性能，它们仅仅是函数式风格与传统 Java 风格的差别。</p><p>另外一点需要注意，forEach 是 terminal 操作，因此它执行后，Stream 的元素就被“消费”掉了，你无法对一个 Stream 进行两次 terminal 运算。下面的代码是错误的：</p><pre><code>stream.forEach(element -&gt; doOneThing(element));stream.forEach(element -&gt; doAnotherThing(element));</code></pre><p>相反，具有相似功能的 intermediate 操作 peek 可以达到上述目的。如下是出现在该 api javadoc 上的一个示例。</p><h3 id="peek-对每个元素执行操作并返回一个新的-Stream"><a href="#peek-对每个元素执行操作并返回一个新的-Stream" class="headerlink" title="peek 对每个元素执行操作并返回一个新的 Stream"></a>peek 对每个元素执行操作并返回一个新的 Stream</h3><pre><code>Stream.of(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;) .filter(e -&gt; e.length() &gt; 3) .peek(e -&gt; System.out.println(&quot;Filtered value: &quot; + e)) .map(String::toUpperCase) .peek(e -&gt; System.out.println(&quot;Mapped value: &quot; + e)) .collect(Collectors.toList());</code></pre><p>forEach 不能修改自己包含的本地变量值，也不能用 break/return 之类的关键字提前结束循环。</p><h2 id="findFirst"><a href="#findFirst" class="headerlink" title="findFirst"></a>findFirst</h2><p>这是一个 termimal 兼 short-circuiting 操作，它总是返回 Stream 的第一个元素，或者空。<br>这里比较重点的是它的返回值类型：Optional。这也是一个模仿 Scala 语言中的概念，作为一个容器，它可能含有某值，或者不包含。使用它的目的是尽可能避免 NullPointerException。</p><h3 id="Optional-的两个用例"><a href="#Optional-的两个用例" class="headerlink" title="Optional 的两个用例"></a>Optional 的两个用例</h3><pre><code>String strA = &quot; abcd &quot;, strB = null;print(strA);print(&quot;&quot;);print(strB);getLength(strA);getLength(&quot;&quot;);getLength(strB);public static void print(String text) { // Java 8 Optional.ofNullable(text).ifPresent(System.out::println); // Pre-Java 8 if (text != null) {   System.out.println(text);  } }public static int getLength(String text) { // Java 8return Optional.ofNullable(text).map(String::length).orElse(-1); // Pre-Java 8// return if (text != null) ? text.length() : -1; };</code></pre><p>在更复杂的 if (xx != null) 的情况中，使用 Optional 代码的可读性更好，而且它提供的是编译时检查，能极大的降低 NPE 这种 Runtime Exception 对程序的影响，或者迫使程序员更早的在编码阶段处理空值问题，而不是留到运行时再发现和调试。</p><p>Stream 中的 findAny、max/min、reduce 等方法等返回 Optional 值。还有例如 IntStream.average() 返回 OptionalDouble 等等。</p><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><p>这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。例如 Stream 的 sum 就相当于</p><pre><code>Integer sum = integers.reduce(0, (a, b) -&gt; a+b);</code></pre><p>或</p><pre><code>Integer sum = integers.reduce(0, Integer::sum);</code></pre><p>也有没有起始值的情况，这时会把 Stream 的前面两个元素组合起来，返回的是 Optional。</p><h3 id="reduce-的用例"><a href="#reduce-的用例" class="headerlink" title="reduce 的用例"></a>reduce 的用例</h3><pre><code>// 字符串连接，concat = &quot;ABCD&quot;String concat = Stream.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;).reduce(&quot;&quot;, String::concat);// 求最小值，minValue = -3.0double minValue = Stream.of(-1.5, 1.0, -3.0, -2.0).reduce(Double.MAX_VALUE, Double::min);// 求和，sumValue = 10, 有起始值int sumValue = Stream.of(1, 2, 3, 4).reduce(0, Integer::sum);// 求和，sumValue = 10, 无起始值sumValue = Stream.of(1, 2, 3, 4).reduce(Integer::sum).get();// 过滤，字符串连接，concat = &quot;ace&quot;concat = Stream.of(&quot;a&quot;, &quot;B&quot;, &quot;c&quot;, &quot;D&quot;, &quot;e&quot;, &quot;F&quot;). filter(x -&gt; x.compareTo(&quot;Z&quot;) &gt; 0). reduce(&quot;&quot;, String::concat);</code></pre><p>上面代码例如第一个示例的 reduce()，第一个参数（空白字符）即为起始值，第二个参数（String::concat）为 BinaryOperator。这类有起始值的 reduce() 都返回具体的对象。而对于第四个示例没有起始值的 reduce()，由于可能没有足够的元素，返回的是 Optional，请留意这个区别。</p><h2 id="limit-skip"><a href="#limit-skip" class="headerlink" title="limit/skip"></a>limit/skip</h2><p>limit 返回 Stream 的前面 n 个元素；skip 则是扔掉前 n 个元素（它是由一个叫 subStream 的方法改名而来）。</p><h3 id="limit-和-skip-对运行次数的影响"><a href="#limit-和-skip-对运行次数的影响" class="headerlink" title="limit 和 skip 对运行次数的影响"></a>limit 和 skip 对运行次数的影响</h3><pre><code>public void testLimitAndSkip() { List&lt;Person&gt; persons = new ArrayList(); for (int i = 1; i &lt;= 10000; i++) { Person person = new Person(i, &quot;name&quot; + i); persons.add(person); }List&lt;String&gt; personList2 = persons.stream().map(Person::getName).limit(10).skip(3).collect(Collectors.toList()); System.out.println(personList2);}private class Person { public int no; private String name; public Person (int no, String name) { this.no = no; this.name = name; } public String getName() { System.out.println(name); return name; }}</code></pre><p>输出结果为：</p><pre><code>name1name2name3name4name5name6name7name8name9name10[name4, name5, name6, name7, name8, name9, name10]</code></pre><p>这是一个有 10，000 个元素的 Stream，但在 short-circuiting 操作 limit 和 skip 的作用下，管道中 map 操作指定的 getName() 方法的执行次数为 limit 所限定的 10 次，而最终返回结果在跳过前 3 个元素后只有后面 7 个返回。</p><p>有一种情况是 limit/skip 无法达到 short-circuiting 目的的，就是把它们放在 Stream 的排序操作后，原因跟 sorted 这个 intermediate 操作有关：此时系统并不知道 Stream 排序后的次序如何，所以 sorted 中的操作看上去就像完全没有被 limit 或者 skip 一样。</p><h3 id="limit-和-skip-对-sorted-后的运行次数无影响"><a href="#limit-和-skip-对-sorted-后的运行次数无影响" class="headerlink" title="limit 和 skip 对 sorted 后的运行次数无影响"></a>limit 和 skip 对 sorted 后的运行次数无影响</h3><pre><code>List&lt;Person&gt; persons = new ArrayList(); for (int i = 1; i &lt;= 5; i++) { Person person = new Person(i, &quot;name&quot; + i); persons.add(person); }List&lt;Person&gt; personList2 = persons.stream().sorted((p1, p2) -&gt;p1.getName().compareTo(p2.getName())).limit(2).collect(Collectors.toList());System.out.println(personList2);</code></pre><p>上面的示例对“peek 对每个元素执行操作并返回一个新的 Stream”做了微调，首先对 5 个元素的 Stream 排序，然后进行 limit 操作。输出结果为：</p><pre><code>name2name1name3name2name4name3name5name4[stream.StreamDW$Person@816f27d, stream.StreamDW$Person@87aac27]</code></pre><p>即虽然最后的返回元素数量是 2，但整个管道中的 sorted 表达式执行次数没有像前面例子相应减少。</p><p>最后有一点需要注意的是，对一个 parallel 的 Steam 管道来说，如果其元素是有序的，那么 limit 操作的成本会比较大，因为它的返回对象必须是前 n 个也有一样次序的元素。取而代之的策略是取消元素间的次序，或者不要用 parallel Stream。</p><h2 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h2><p>对 Stream 的排序通过 sorted 进行，它比数组的排序更强之处在于你可以首先对 Stream 进行各类 map、filter、limit、skip 甚至 distinct 来减少元素数量后，再排序，这能帮助程序明显缩短执行时间。我们对“Optional 的两个用例” 进行优化：</p><h3 id="优化：排序前进行-limit-和-skip"><a href="#优化：排序前进行-limit-和-skip" class="headerlink" title="优化：排序前进行 limit 和 skip"></a>优化：排序前进行 limit 和 skip</h3><pre><code>List&lt;Person&gt; persons = new ArrayList(); for (int i = 1; i &lt;= 5; i++) { Person person = new Person(i, &quot;name&quot; + i); persons.add(person); }List&lt;Person&gt; personList2 = persons.stream().limit(2).sorted((p1, p2) -&gt; p1.getName().compareTo(p2.getName())).collect(Collectors.toList());System.out.println(personList2);</code></pre><p>结果会简单很多：</p><pre><code>name2name1[stream.StreamDW$Person@6ce253f1, stream.StreamDW$Person@53d8d10a]</code></pre><p>当然，这种优化是有 business logic 上的局限性的：即不要求排序后再取值。<br>min/max/distinct</p><p>min 和 max 的功能也可以通过对 Stream 元素先排序，再 findFirst 来实现，但前者的性能会更好，为 O(n)，而 sorted 的成本是 O(n log n)。同时它们作为特殊的 reduce 方法被独立出来也是因为求最大最小值是很常见的操作。</p><h3 id="找出最长一行的长度"><a href="#找出最长一行的长度" class="headerlink" title="找出最长一行的长度"></a>找出最长一行的长度</h3><pre><code>BufferedReader br = new BufferedReader(new FileReader(&quot;c:\\SUService.log&quot;));int longest = br.lines(). mapToInt(String::length). max(). getAsInt();br.close();System.out.println(longest);</code></pre><p>下面的例子则使用 distinct 来找出不重复的单词。</p><h3 id="找出全文的单词，转小写，并排序"><a href="#找出全文的单词，转小写，并排序" class="headerlink" title="找出全文的单词，转小写，并排序"></a>找出全文的单词，转小写，并排序</h3><pre><code>List&lt;String&gt; words = br.lines(). flatMap(line -&gt; Stream.of(line.split(&quot; &quot;))). filter(word -&gt; word.length() &gt; 0). map(String::toLowerCase). distinct(). sorted(). collect(Collectors.toList());br.close();System.out.println(words);</code></pre><h2 id="Match"><a href="#Match" class="headerlink" title="Match"></a>Match</h2><p>Stream 有三个 match 方法，从语义上说：<br>allMatch：Stream 中全部元素符合传入的 predicate，返回 true<br>anyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 true<br>noneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true<br>它们都不是要遍历全部元素才能返回结果。例如 allMatch 只要一个元素不满足条件，就 skip 剩下的所有元素，返回 false。对清单 13 中的 Person 类稍做修改，加入一个 age 属性和 getAge 方法。</p><h3 id="使用-Match"><a href="#使用-Match" class="headerlink" title="使用 Match"></a>使用 Match</h3><pre><code>List&lt;Person&gt; persons = new ArrayList();persons.add(new Person(1, &quot;name&quot; + 1, 10));persons.add(new Person(2, &quot;name&quot; + 2, 21));persons.add(new Person(3, &quot;name&quot; + 3, 34));persons.add(new Person(4, &quot;name&quot; + 4, 6));persons.add(new Person(5, &quot;name&quot; + 5, 55));boolean isAllAdult = persons.stream(). allMatch(p -&gt; p.getAge() &gt; 18);System.out.println(&quot;All are adult? &quot; + isAllAdult);boolean isThereAnyChild = persons.stream(). anyMatch(p -&gt; p.getAge() &lt; 12);System.out.println(&quot;Any child? &quot; + isThereAnyChild);</code></pre><p>输出结果：<br>    1<br>    2<br>    All are adult? false<br>    Any child? true</p><h2 id="进阶：自己生成流"><a href="#进阶：自己生成流" class="headerlink" title="进阶：自己生成流"></a>进阶：自己生成流</h2><h2 id="Stream-generate"><a href="#Stream-generate" class="headerlink" title="Stream.generate"></a>Stream.generate</h2><p>通过实现 Supplier 接口，你可以自己来控制流的生成。这种情形通常用于随机数、常量的 Stream，或者需要前后元素间维持着某种状态信息的 Stream。把 Supplier 实例传递给 Stream.generate() 生成的 Stream，默认是串行（相对 parallel 而言）但无序的（相对 ordered 而言）。由于它是无限的，在管道中，必须利用 limit 之类的操作限制 Stream 大小。</p><h3 id="生成-10-个随机整数"><a href="#生成-10-个随机整数" class="headerlink" title="生成 10 个随机整数"></a>生成 10 个随机整数</h3><pre><code>Random seed = new Random();Supplier&lt;Integer&gt; random = seed::nextInt;Stream.generate(random).limit(10).forEach(System.out::println);//Another wayIntStream.generate(() -&gt; (int) (System.nanoTime() % 100)).limit(10).forEach(System.out::println);</code></pre><p>Stream.generate() 还接受自己实现的 Supplier。例如在构造海量测试数据的时候，用某种自动的规则给每一个变量赋值；或者依据公式计算 Stream 的每个元素值。这些都是维持状态信息的情形。</p><h3 id="自实现-Supplier"><a href="#自实现-Supplier" class="headerlink" title="自实现 Supplier"></a>自实现 Supplier</h3><pre><code>Stream.generate(new PersonSupplier()).limit(10).forEach(p -&gt; System.out.println(p.getName() + &quot;, &quot; + p.getAge()));private class PersonSupplier implements Supplier&lt;Person&gt; { private int index = 0; private Random random = new Random(); @Override public Person get() { return new Person(index++, &quot;StormTestUser&quot; + index, random.nextInt(100)); }}</code></pre><p>输出结果：</p><pre><code>StormTestUser1, 9StormTestUser2, 12StormTestUser3, 88StormTestUser4, 51StormTestUser5, 22StormTestUser6, 28StormTestUser7, 81StormTestUser8, 51StormTestUser9, 4StormTestUser10, 76</code></pre><h2 id="Stream-iterate"><a href="#Stream-iterate" class="headerlink" title="Stream.iterate"></a>Stream.iterate</h2><p>iterate 跟 reduce 操作很像，接受一个种子值，和一个 UnaryOperator（例如 f）。然后种子值成为 Stream 的第一个元素，f(seed) 为第二个，f(f(seed)) 第三个，以此类推。</p><h3 id="生成一个等差数列"><a href="#生成一个等差数列" class="headerlink" title="生成一个等差数列"></a>生成一个等差数列</h3><pre><code>Stream.iterate(0, n -&gt; n + 3).limit(10). forEach(x -&gt; System.out.print(x + &quot; &quot;));.</code></pre><p>输出结果：</p><pre><code>0 3 6 9 12 15 18 21 24 27</code></pre><p>与 Stream.generate 相仿，在 iterate 时候管道必须有 limit 这样的操作来限制 Stream 大小。</p><h2 id="进阶：用-Collectors-来进行-reduction-操作"><a href="#进阶：用-Collectors-来进行-reduction-操作" class="headerlink" title="进阶：用 Collectors 来进行 reduction 操作"></a>进阶：用 Collectors 来进行 reduction 操作</h2><p>java.util.stream.Collectors 类的主要作用就是辅助进行各类有用的 reduction 操作，例如转变输出为 Collection，把 Stream 元素进行归组。<br>groupingBy/partitioningBy</p><h3 id="按照年龄归组"><a href="#按照年龄归组" class="headerlink" title="按照年龄归组"></a>按照年龄归组</h3><pre><code>Map&lt;Integer, List&lt;Person&gt;&gt; personGroups = Stream.generate(new PersonSupplier()). limit(100). collect(Collectors.groupingBy(Person::getAge));Iterator it = personGroups.entrySet().iterator();while (it.hasNext()) { Map.Entry&lt;Integer, List&lt;Person&gt;&gt; persons = (Map.Entry) it.next(); System.out.println(&quot;Age &quot; + persons.getKey() + &quot; = &quot; + persons.getValue().size());}</code></pre><p>上面的 code，首先生成 100 人的信息，然后按照年龄归组，相同年龄的人放到同一个 list 中，可以看到如下的输出：</p><pre><code>Age 0 = 2Age 1 = 2Age 5 = 2Age 8 = 1Age 9 = 1Age 11 = 2……</code></pre><h3 id="按照未成年人和成年人归组"><a href="#按照未成年人和成年人归组" class="headerlink" title="按照未成年人和成年人归组"></a>按照未成年人和成年人归组</h3><pre><code>Map&lt;Boolean, List&lt;Person&gt;&gt; children = Stream.generate(new PersonSupplier()). limit(100). collect(Collectors.partitioningBy(p -&gt; p.getAge() &lt; 18));System.out.println(&quot;Children number: &quot; + children.get(true).size());System.out.println(&quot;Adult number: &quot; + children.get(false).size());</code></pre><p>输出结果：</p><pre><code>Children number: 23Adult number: 77</code></pre><p>在使用条件“年龄小于 18”进行分组后可以看到，不到 18 岁的未成年人是一组，成年人是另外一组。</p><p>partitioningBy 其实是一种特殊的 groupingBy，它依照条件测试的是否两种结果来构造返回的数据结构，get(true) 和 get(false) 能即为全部的元素对象。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>总之，Stream 的特性可以归纳为：</p><p>不是数据结构</p><p>它没有内部存储，它只是用操作管道从 source（数据结构、数组、generator function、IO channel）抓取数据。</p><p>它也绝不修改自己所封装的底层数据结构的数据。例如 Stream 的 filter 操作会产生一个不包含被过滤元素的新 Stream，而不是从 source 删除那些元素。</p><p>所有 Stream 的操作必须以 lambda 表达式为参数</p><p>不支持索引访问</p><p>你可以请求第一个元素，但无法请求第二个，第三个，或最后一个。不过请参阅下一项。</p><p>很容易生成数组或者 List</p><p>惰性化</p><p>很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。<br>Intermediate 操作永远是惰性化的。</p><p>并行能力</p><p>当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的。</p><p>可以是无限的</p><p>集合有固定大小，Stream 则不必。limit(n) 和 findFirst() 这类的 short-circuiting 操作可以对无限的 Stream 进行运算并很快完成。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/index.html</a></p><p>【2】<a href="https://www.ibm.com/developerworks/cn/java/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/</a></p><p>【3】<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html</a></p><p>【4】<a href="https://javarevisited.blogspot.com/2018/07/java-8-tutorials-resources-and-examples-lambda-expression-stream-api-functional-interfaces.html" target="_blank" rel="noopener">https://javarevisited.blogspot.com/2018/07/java-8-tutorials-resources-and-examples-lambda-expression-stream-api-functional-interfaces.html</a></p><p>【5】<a href="http://www.drdobbs.com/jvm/lambdas-and-streams-in-java-8-libraries/240166818" target="_blank" rel="noopener">http://www.drdobbs.com/jvm/lambdas-and-streams-in-java-8-libraries/240166818</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MapReduce思想学习,对Java8中对新特性stream，map和reduce进行学习，Stream API部分主要来自于IBM Developer官网，原文写的非常详尽清晰。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年8月" scheme="http://yoursite.com/categories/2019%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记V</title>
    <link href="http://yoursite.com/2019/08/12/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0V/"/>
    <id>http://yoursite.com/2019/08/12/Java学习笔记V/</id>
    <published>2019-08-12T06:48:12.000Z</published>
    <updated>2019-08-13T06:44:00.146Z</updated>
    
    <content type="html"><![CDATA[<p>学习Guaa中的字符串处理函数Joiner类的用法。</p><a id="more"></a><h1 id="Guava"><a href="#Guava" class="headerlink" title="Guava"></a>Guava</h1><p>Guava 是一个 Google 的基于java1.6的类库集合的扩展项目，Guava工程包含了若干被Google的 Java项目广泛依赖 的核心库，例如：集合 [collections] 、缓存 [caching] 、原生类型支持 [primitives support] 、并发库 [concurrency libraries] 、通用注解 [common annotations] 、字符串处理 [string processing] 、I/O 等等。</p><h1 id="连接器Joiner"><a href="#连接器Joiner" class="headerlink" title="连接器Joiner"></a>连接器Joiner</h1><p>用分隔符把字符串序列连接起来也可能会遇上不必要的麻烦。如果字符串序列中含有null，那连接操作会更难。Fluent风格的Joiner让连接字符串更简单。</p><p>  Joiner joiner = Joiner.on(“; “).skipNulls();<br>  return joiner.join(“Harry”, null, “Ron”, “Hermione”);</p><p>上述代码返回”Harry; Ron; Hermione”。另外，useForNull(String)方法可以给定某个字符串来替换null，而不像skipNulls()方法是直接忽略null。<br> Joiner也可以用来连接对象类型，在这种情况下，它会把对象的toString()值连接起来。</p><pre><code>Joiner.on(&quot;,&quot;).join(Arrays.asList(1, 5, 7)); // returns &quot;1,5,7&quot;</code></pre><p>警告：joiner实例总是不可变的。用来定义joiner目标语义的配置方法总会返回一个新的joiner实例。<br>这使得joiner实例都是线程安全的，你可以将其定义为static final常量。</p><h1 id="传统连接方法"><a href="#传统连接方法" class="headerlink" title="传统连接方法"></a>传统连接方法</h1><p>相比之下传统的以某个分隔符来进行拼接的代码如下：</p><pre><code>public static String concatString(List&lt;String&gt; lists,String delimiter){    StringBuilder builder=new StringBuilder();    for(String s:lists){        if(s!=null){            builder.append(s).append(delimiter);        }    }    builder.setLength(builder.length()-delimiter.length());    return builder.toString();}public  static  void  main(String[] args) {  List&lt;String&gt; list=new ArrayList();  list.add(&quot;Traditional&quot;);  list.add(&quot;delimiter&quot;);  list.add(&quot;codingstyle&quot;);  System.out.println(concatString(list,&quot;-&quot;));}</code></pre><h1 id="MapJoiner"><a href="#MapJoiner" class="headerlink" title="MapJoiner"></a>MapJoiner</h1><p>MapJoiner的用法和Joiner类似,不过MapJoiner主要针对map的字符串拼接例：</p><pre><code>Map&lt;String,String&gt; maps=Maps.newHashMap();maps.put(&quot;MapJoiner&quot;,&quot;1&quot;);maps.put(&quot;String&quot;,&quot;delimiter&quot;);String ss=Joiner.on(&quot;$&quot;).withKeyValueSeparator(&quot;=&quot;).join(maps);System.out.println(ss);</code></pre><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://wizardforcel.gitbooks.io/guava-tutorial/content/1.html" target="_blank" rel="noopener">https://wizardforcel.gitbooks.io/guava-tutorial/content/1.html</a></p><p>【2】<a href="https://blog.csdn.net/u012415194/article/details/84880258" target="_blank" rel="noopener">https://blog.csdn.net/u012415194/article/details/84880258</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习Guaa中的字符串处理函数Joiner类的用法。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年8月" scheme="http://yoursite.com/categories/2019%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记III</title>
    <link href="http://yoursite.com/2019/08/12/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0III/"/>
    <id>http://yoursite.com/2019/08/12/Java学习笔记III/</id>
    <published>2019-08-12T06:45:12.000Z</published>
    <updated>2019-08-13T06:13:13.593Z</updated>
    
    <content type="html"><![CDATA[<p>总结Java8 Lambda表达式，对涉及到到final关键字做了回顾</p><a id="more"></a><h1 id="Java8-Lambda表达式"><a href="#Java8-Lambda表达式" class="headerlink" title="Java8 Lambda表达式"></a>Java8 Lambda表达式</h1><p>Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。<br>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。<br>使用 Lambda 表达式可以使代码变的更加简洁紧凑。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>lambda 表达式的语法格式如下：</p><pre><code>(parameters) -&gt; expression或(parameters) -&gt;{ statements; }</code></pre><p>以下是lambda表达式的重要特征:</p><p>可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。</p><p>可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。</p><p>可选的大括号：如果主体包含了一个语句，就不需要使用大括号。</p><p>可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</p><h2 id="Lambda-表达式实例"><a href="#Lambda-表达式实例" class="headerlink" title="Lambda 表达式实例"></a>Lambda 表达式实例</h2><p>Lambda 表达式的简单例子:</p><pre><code>// 1. 不需要参数,返回值为 5  () -&gt; 5  // 2. 接收一个参数(数字类型),返回其2倍的值  x -&gt; 2 * x  // 3. 接受2个参数(数字),并返回他们的差值  (x, y) -&gt; x – y  // 4. 接收2个int型整数,返回他们的和  (int x, int y) -&gt; x + y  // 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  (String s) -&gt; System.out.print(s)</code></pre><p>在 Java8Tester.java 文件输入以下代码：</p><pre><code>public class Java8Tester {   public static void main(String args[]){      Java8Tester tester = new Java8Tester();      // 类型声明      MathOperation addition = (int a, int b) -&gt; a + b;      // 不用类型声明      MathOperation subtraction = (a, b) -&gt; a - b;      // 大括号中的返回语句      MathOperation multiplication = (int a, int b) -&gt; { return a * b; };      // 没有大括号及返回语句      MathOperation division = (int a, int b) -&gt; a / b;      System.out.println(&quot;10 + 5 = &quot; + tester.operate(10, 5, addition));      System.out.println(&quot;10 - 5 = &quot; + tester.operate(10, 5, subtraction));      System.out.println(&quot;10 x 5 = &quot; + tester.operate(10, 5, multiplication));      System.out.println(&quot;10 / 5 = &quot; + tester.operate(10, 5, division));      // 不用括号      GreetingService greetService1 = message -&gt;      System.out.println(&quot;Hello &quot; + message);      // 用括号      GreetingService greetService2 = (message) -&gt;      System.out.println(&quot;Hello &quot; + message);      greetService1.sayMessage(&quot;Runoob&quot;);      greetService2.sayMessage(&quot;Google&quot;);   }   interface MathOperation {      int operation(int a, int b);   }   interface GreetingService {      void sayMessage(String message);   }   private int operate(int a, int b, MathOperation mathOperation){      return mathOperation.operation(a, b);   }}</code></pre><p>执行以上脚本，输出结果为：</p><pre><code>$ javac Java8Tester.java$ java Java8Tester10 + 5 = 1510 - 5 = 510 x 5 = 5010 / 5 = 2Hello RunoobHello Google</code></pre><p>使用 Lambda 表达式需要注意以下两点：</p><p>Lambda 表达式主要用来定义行内执行的方法类型接口，例如，一个简单方法接口。在上面例子中，我们使用各种类型的Lambda表达式来定义MathOperation接口的方法。然后我们定义了sayMessage的执行。</p><p>Lambda 表达式免去了使用匿名方法的麻烦，并且给予Java简单但是强大的函数化的编程能力。</p><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>lambda 表达式只能引用标记了 final 的外层局部变量，这就是说不能在 lambda 内部修改定义在域外的局部变量，否则会编译错误。<br>在 Java8Tester.java 文件输入以下代码：</p><pre><code>public class Java8Tester {final static String salutation = &quot;Hello! &quot;;public static void main(String args[]){  GreetingService greetService1 = message -&gt;  System.out.println(salutation + message);  greetService1.sayMessage(&quot;Runoob&quot;);}interface GreetingService {  void sayMessage(String message);}}</code></pre><p>执行以上脚本，输出结果为：</p><pre><code>$ javac Java8Tester.java$ java Java8TesterHello! Runoob</code></pre><p>我们也可以直接在 lambda 表达式中访问外层的局部变量：</p><pre><code>public class Java8Tester {    public static void main(String args[]) {        final int num = 1;        Converter&lt;Integer, String&gt; s = (param) -&gt; System.out.println(String.valueOf(param + num));        s.convert(2);  // 输出结果为 3    }    public interface Converter&lt;T1, T2&gt; {        void convert(int i);    }}</code></pre><p>lambda 表达式的局部变量可以不用声明为 final，但是必须不可被后面的代码修改（即隐性的具有 final 的语义）</p><pre><code>int num = 1;  Converter&lt;Integer, String&gt; s = (param) -&gt; System.out.println(String.valueOf(param + num));s.convert(2);num = 5;  //报错信息：Local variable num defined in an enclosing scope must be final or effectively final</code></pre><p>在 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量。</p><pre><code>String first = &quot;&quot;;  Comparator&lt;String&gt; comparator = (first, second) -&gt; Integer.compare(first.length(), second.length());  //编译会出错</code></pre><h1 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h1><p>final是一个关键字，可以用于修饰类，成员变量，成员方法。</p><h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><p>它修饰的类不能被继承。</p><p>它修饰的成员变量是一个常量。</p><p>它修饰的成员方法是不能被子类重写的。</p><p>final修饰的常量定义一般都有书写规范,被final修饰的常量名称,所有字母都大写。</p><p>final修饰成员变量,必须初始化,初始化有两种</p><p>显示初始化；</p><p>构造方法初始化。</p><p>但是不能两个一起初始化</p><h2 id="final和private的区别："><a href="#final和private的区别：" class="headerlink" title="final和private的区别："></a>final和private的区别：</h2><p>final修饰的类可以访问；</p><p>private不可以修饰外部类，但可以修饰内部类（其实把外部类私有化是没有意义的）。</p><p>final修饰的方法不可以被子类重写；</p><p>private修饰的方法表面上看是可以被子类重写的，其实不可以，子类是看不到父类的私有方法的。</p><p>final修饰的变量只能在显示初始化或者构造函数初始化的时候赋值一次，以后不允许更改；</p><p>private修饰的变量，也不允许直接被子类或一个包中的其它类访问或修改，但是他可以通过set和get方法对其改值和取值。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://www.runoob.com/java/java8-lambda-expressions.html" target="_blank" rel="noopener">https://www.runoob.com/java/java8-lambda-expressions.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结Java8 Lambda表达式，对涉及到到final关键字做了回顾&lt;/p&gt;
    
    </summary>
    
      <category term="2019年8月" scheme="http://yoursite.com/categories/2019%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>数据库学习笔记II</title>
    <link href="http://yoursite.com/2019/08/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0II/"/>
    <id>http://yoursite.com/2019/08/09/数据库学习笔记II/</id>
    <published>2019-08-09T07:12:12.000Z</published>
    <updated>2019-08-13T07:20:00.734Z</updated>
    
    <content type="html"><![CDATA[<p>重新温习Mysqlkey 、primary key 、unique key 与index的区别</p><a id="more"></a><h1 id="key与primary-key区别"><a href="#key与primary-key区别" class="headerlink" title="key与primary key区别"></a>key与primary key区别</h1><pre><code>CREATE TABLE wh_logrecord (  logrecord_id int(11) NOT NULL auto_increment,  user_name varchar(100) default NULL,  operation_time datetime default NULL,  logrecord_operation varchar(100) default NULL,  PRIMARY KEY (logrecord_id),  KEY wh_logrecord_user_name (user_name)  )</code></pre><h2 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h2><p>  KEY wh_logrecord_user_name (user_name)</p><p>  本表的user_name字段与wh_logrecord_user_name表user_name字段建立外键</p><p>  括号外是建立外键的对应表，括号内是对应字段</p><p>  类似还有 KEY user(userid)</p><p>  当然，key未必都是外键</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>  Key是索引约束，对表中字段进行约束索引的，都是通过primary foreign unique等创建的。<br>  常见有foreign key，外键关联用的。</p><p>  KEY forum (status,type,displayorder)  # 是多列索引（键）</p><p>  KEY tid (tid)                         # 是单列索引（键）。</p><p>  如建表时： KEY forum (status,type,displayorder)</p><p>  select * from table group by status,type,displayorder 是否就自动用上了此索引，</p><p>  而当 select * from table group by status 此索引有用吗？</p><p>  key的用途：主要是用来加快查询速度的。</p><h1 id="KEY与INDEX区别"><a href="#KEY与INDEX区别" class="headerlink" title="KEY与INDEX区别"></a>KEY与INDEX区别</h1><p>KEY通常是INDEX同义词。</p><p>如果关键字属性PRIMARY KEY在列定义中已给定，则PRIMARY KEY也可以只指定为KEY。这么做的目的是与其它数据库系统兼容。</p><p>PRIMARY KEY是一个唯一KEY，此时，所有的关键字列必须定义为NOT NULL。</p><p>如果这些列没有被明确地定义为NOT NULL，MySQL应隐含地定义这些列。</p><p>一个表只有一个PRIMARY KEY。</p><h2 id="MySQL-中Index-与Key-的区别"><a href="#MySQL-中Index-与Key-的区别" class="headerlink" title="MySQL 中Index 与Key 的区别"></a>MySQL 中Index 与Key 的区别</h2><p>Key即键值，是关系模型理论中的一部份，比如有主键（Primary Key)，外键（Foreign Key）等，用于数据完整性检否与唯一性约束等。</p><p>而Index则处于实现层面，比如可以对表个的任意列建立索引，那么当建立索引的列处于SQL语句中的Where条件中时，就可以得到快速的数据定位，从而快速检索。</p><p>至于Unique Index，则只是属于Index中的一种而已，建立了Unique Index表示此列数据不可重复，猜想MySQL对Unique Index类型的索引可以做进一步特殊优化吧。</p><p>于是乎，在设计表的时候，Key只是要处于模型层面的，而当需要进行查询优化，则对相关列建立索引即可。</p><p>另外，在MySQL中，对于一个Primary Key的列，MySQL已经自动对其建立了Unique Index，无需重复再在上面建立索引了。</p><p>搜索到的一段解释：</p><p>Note that “primary” is called PRIMARY KEY not INDEX.</p><p>KEY is something on the logical level, describes your table and database design (i.e. enforces referential integrity …)</p><p>INDEX is something on the physical level, helps improve access time for table operations.</p><p>Behind every PK there is (usually) unique index created (automatically).</p><h1 id="mysql中UNIQUE-KEY和PRIMARY-KEY有什么区别"><a href="#mysql中UNIQUE-KEY和PRIMARY-KEY有什么区别" class="headerlink" title="mysql中UNIQUE KEY和PRIMARY KEY有什么区别"></a>mysql中UNIQUE KEY和PRIMARY KEY有什么区别</h1><p>1，Primary key的1个或多个列必须为NOT NULL，如果列为NULL，在增加PRIMARY KEY时，列自动更改为NOT NULL。而UNIQUE KEY 对列没有此要求</p><p>2，一个表只能有一个PRIMARY KEY，但可以有多个UNIQUE KEY</p><p>3，主键和唯一键约束是通过参考索引实施的，如果插入的值均为NULL，则根据索引的原理，全NULL值不被记录在索引上，所以插入全NULL值时，可以有重复的，而其他的则不能插入重复值。</p><pre><code>alter table t add constraint uk_t_1 unique (a,b);insert into t (a ,b ) values (null,1);    # 不能重复insert into t (a ,b ) values (null,null); # 可以重复</code></pre><h1 id="使用UNIQUE-KEY"><a href="#使用UNIQUE-KEY" class="headerlink" title="使用UNIQUE KEY"></a>使用UNIQUE KEY</h1><pre><code>CREATE TABLE `secure_vulnerability_warning` (  `id` int(10) NOT NULL auto_increment,  `date` date NOT NULL,  `type` varchar(100) NOT NULL,  `sub_type` varchar(100) NOT NULL,  `domain_name` varchar(128) NOT NULL,  `url` text NOT NULL,  `parameters` text NOT NULL,  `hash` varchar(100) NOT NULL,  `deal` int(1) NOT NULL,  `deal_date` date default NULL,  `remark` text,  `last_push_time` datetime default NULL,  `push_times` int(11) default &apos;1&apos;,  `first_set_ok_time` datetime default NULL,  `last_set_ok_time` datetime default NULL,  PRIMARY KEY  (`id`),  UNIQUE KEY `date` (`date`,`hash`)  ) ENGINE=InnoDB  DEFAULT CHARSET=utf8</code></pre><p>UNIQUE KEY的用途：主要是用来防止数据插入的时候重复的。</p><p>1，创建表时</p><pre><code>CREATE TABLE Persons(  Id_P int NOT NULL,  LastName varchar(255) NOT NULL,  FirstName varchar(255),  Address varchar(255),  City varchar(255),  UNIQUE (Id_P))</code></pre><p>如果需要命名 UNIQUE 约束，以及为多个列定义 UNIQUE 约束，请使用下面的 SQL 语法：</p><pre><code>CREATE TABLE Persons(  Id_P int NOT NULL,  LastName varchar(255) NOT NULL,  FirstName varchar(255),  Address varchar(255),  City varchar(255),  CONSTRAINT uc_PersonID UNIQUE (Id_P,LastName))</code></pre><p>2，当表已被创建时，如需在 “Id_P” 列创建 UNIQUE 约束，请使用下列 SQL：</p><p>ALTER TABLE PersonsADD UNIQUE (Id_P)<br>如需命名 UNIQUE 约束，并定义多个列的 UNIQUE 约束，请使用下面的 SQL 语法：</p><p>ALTER TABLE PersonsADD CONSTRAINT uc_PersonID UNIQUE (Id_P,LastName)</p><p>3，撤销 UNIQUE 约束如需撤销 UNIQUE 约束，请使用下面的 SQL：</p><p>MySQL:ALTER TABLE PersonsDROP INDEX uc_PersonID</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://www.jianshu.com/p/336170f4d649" target="_blank" rel="noopener">https://www.jianshu.com/p/336170f4d649</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重新温习Mysqlkey 、primary key 、unique key 与index的区别&lt;/p&gt;
    
    </summary>
    
      <category term="2019年8月" scheme="http://yoursite.com/categories/2019%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记II</title>
    <link href="http://yoursite.com/2019/08/07/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0II/"/>
    <id>http://yoursite.com/2019/08/07/Java学习笔记II/</id>
    <published>2019-08-07T07:37:12.000Z</published>
    <updated>2019-08-12T06:37:34.791Z</updated>
    
    <content type="html"><![CDATA[<p>重新温习Java中的异常处理</p><a id="more"></a><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>异常是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。</p><p>比如说，你的代码少了一个分号，那么运行出来结果是提示是错误 java.lang.Error；如果你用System.out.println(11/0)，那么你是因为你用0做了除数，会抛出 java.lang.ArithmeticException 的异常。</p><p>异常发生的原因有很多，通常包含以下几大类：</p><p>用户输入了非法数据。</p><p>要打开的文件不存在。</p><p>网络通信时连接中断，或者JVM内存溢出。</p><p>这些异常有的是因为用户错误引起，有的是程序错误引起的，还有其它一些是因为物理错误引起的。</p><p>要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常：</p><p>检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</p><p>运行时异常： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</p><p>错误： 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</p><h2 id="Exception-类的层次"><a href="#Exception-类的层次" class="headerlink" title="Exception 类的层次"></a>Exception 类的层次</h2><p>所有的异常类是从 java.lang.Exception 类继承的子类。</p><p>Exception 类是 Throwable 类的子类。除了Exception类外，Throwable还有一个子类Error 。</p><p>Java 程序通常不捕获错误。错误一般发生在严重故障时，它们在Java程序处理的范畴之外。</p><p>Error 用来指示运行时环境发生的错误。</p><p>例如，JVM 内存溢出。一般地，程序不会从错误中恢复。</p><p>异常类有两个主要的子类：IOException 类和 RuntimeException 类。</p><p><img src="assets/markdown-img-paste-20190807155403573.png" alt="https://www.runoob.com/wp-content/uploads/2013/12/12-130Q1234I6223.jpg"></p><h2 id="Java-内置异常类"><a href="#Java-内置异常类" class="headerlink" title="Java 内置异常类"></a>Java 内置异常类</h2><p>Java 语言定义了一些异常类在 java.lang 标准包中。</p><p>标准运行时异常类的子类是最常见的异常类。由于 java.lang 包是默认加载到所有的 Java 程序的，所以大部分从运行时异常类继承而来的异常都可以直接使用。</p><p>Java 根据各个类库也定义了一些其他的异常，下面的表中列出了 Java 的非检查性异常</p><table><thead><tr><th>异常</th><th>描述</th></tr></thead><tbody><tr><td>ArithmeticException</td><td>当出现异常的运算条件时，抛出此异常。例如，一个整数”除以零”时，抛出此类的一个实例。</td></tr><tr><td>ArrayIndexOutOfBoundsException</td><td>用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。</td></tr><tr><td>ArrayStoreException</td><td>试图将错误类型的对象存储到一个对象数组时抛出的异常。</td></tr><tr><td>ClassCastException</td><td>当试图将对象强制转换为不是实例的子类时，抛出该异常。</td></tr><tr><td>IllegalArgumentException</td><td>抛出的异常表明向方法传递了一个不合法或不正确的参数。</td></tr><tr><td>IllegalMonitorStateException</td><td>抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。</td></tr><tr><td>IllegalStateException</td><td>在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下。</td></tr><tr><td>IllegalThreadStateException</td><td>线程没有处于请求操作所要求的适当状态时抛出的异常。</td></tr><tr><td>IndexOutOfBoundsException</td><td>指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。</td></tr><tr><td>NegativeArraySizeException</td><td>如果应用程序试图创建大小为负的数组，则抛出该异常。</td></tr><tr><td>NullPointerException</td><td>当应用程序试图在需要对象的地方使用 null 时，抛出该异常</td></tr><tr><td>NumberFormatException</td><td>当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</td></tr><tr><td>SecurityException</td><td>由安全管理器抛出的异常，指示存在安全侵犯。</td></tr><tr><td>StringIndexOutOfBoundsException</td><td>此异常由 String 方法抛出，指示索引或者为负，或者超出字符串的大小。</td></tr><tr><td>UnsupportedOperationException</td><td>当不支持请求的操作时，抛出该异常。</td></tr></tbody></table><p>下面的表中列出了 Java 定义在 java.lang 包中的检查性异常类。</p><table><thead><tr><th>异常</th><th>描述</th></tr></thead><tbody><tr><td>ClassNotFoundException</td><td>应用程序试图加载类时，找不到相应的类，抛出该异常。</td></tr><tr><td>CloneNotSupportedException</td><td>当调用 Object 类中的 clone 方法克隆对象，但该对象的类无法实现 Cloneable 接口时，抛出该异常。</td></tr><tr><td>IllegalAccessException</td><td>拒绝访问一个类的时候，抛出该异常。</td></tr><tr><td>InstantiationException</td><td>当试图使用 Class 类中的 newInstance 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常。</td></tr><tr><td>InterruptedException</td><td>一个线程被另一个线程中断，抛出该异常。</td></tr><tr><td>NoSuchFieldException</td><td>请求的变量不存在</td></tr><tr><td>NoSuchMethodException</td><td>请求的方法不存在</td></tr></tbody></table><h2 id="异常方法"><a href="#异常方法" class="headerlink" title="异常方法"></a>异常方法</h2><p>下面的列表是 Throwable 类的主要方法:</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public String getMessage()</td><td>返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。</td></tr><tr><td>public Throwable getCause()</td><td>返回一个Throwable 对象代表异常原因。</td></tr><tr><td>public String toString()</td><td>使用getMessage()的结果返回类的串级名字。</td></tr><tr><td>public void printStackTrace()</td><td>打印toString()结果和栈层次到System.err，即错误输出流。</td></tr><tr><td>public StackTraceElement [] getStackTrace()</td><td>返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。</td></tr><tr><td>public Throwable fillInStackTrace()</td><td>用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中。</td></tr></tbody></table><h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><p>使用 try 和 catch 关键字可以捕获异常。try/catch 代码块放在异常可能发生的地方。</p><p>try/catch代码块中的代码称为保护代码，使用 try/catch 的语法如下：</p><pre><code>try{   // 程序代码}catch(ExceptionName e1){   //Catch 块}</code></pre><p>Catch 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。</p><p>如果发生的异常包含在 catch 块中，异常会被传递到该 catch 块，这和传递一个参数到方法是一样。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>下面的例子中声明有两个元素的一个数组，当代码试图访问数组的第三个元素的时候就会抛出一个异常。</p><p>ExcepTest.java 文件代码：</p><pre><code>// 文件名 : ExcepTest.javaimport java.io.*;public class ExcepTest{   public static void main(String args[]){      try{         int a[] = new int[2];         System.out.println(&quot;Access element three :&quot; + a[3]);      }catch(ArrayIndexOutOfBoundsException e){         System.out.println(&quot;Exception thrown  :&quot; + e);      }      System.out.println(&quot;Out of the block&quot;);   }}</code></pre><p>以上代码编译运行输出结果如下：</p><pre><code>Exception thrown  :java.lang.ArrayIndexOutOfBoundsException: 3Out of the block</code></pre><h3 id="多重捕获块"><a href="#多重捕获块" class="headerlink" title="多重捕获块"></a>多重捕获块</h3><p>一个 try 代码块后面跟随多个 catch 代码块的情况就叫多重捕获。</p><p>多重捕获块的语法如下所示：</p><pre><code>try{   // 程序代码}catch(异常类型1 异常的变量名1){  // 程序代码}catch(异常类型2 异常的变量名2){  // 程序代码}catch(异常类型2 异常的变量名2){  // 程序代码}</code></pre><p>上面的代码段包含了 3 个 catch块。</p><p>可以在 try 语句后面添加任意数量的 catch 块。</p><p>如果保护代码中发生异常，异常被抛给第一个 catch 块。</p><p>如果抛出异常的数据类型与 ExceptionType1 匹配，它在这里就会被捕获。</p><p>如果不匹配，它会被传递给第二个 catch 块。</p><p>如此，直到异常被捕获或者通过所有的 catch 块。</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>该实例展示了怎么使用多重 try/catch。</p><pre><code>try {    file = new FileInputStream(fileName);    x = (byte) file.read();} catch(FileNotFoundException f) { // Not valid!    f.printStackTrace();    return -1;} catch(IOException i) {    i.printStackTrace();    return -1;}</code></pre><h2 id="throws-throw-关键字："><a href="#throws-throw-关键字：" class="headerlink" title="throws/throw 关键字："></a>throws/throw 关键字：</h2><p>如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明。</p><p>throws 关键字放在方法签名的尾部。</p><p>也可以使用 throw 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的。</p><p>下面方法的声明抛出一个 RemoteException 异常：</p><pre><code>import java.io.*;public class className{  public void deposit(double amount) throws RemoteException  {    // Method implementation    throw new RemoteException();  }  //Remainder of class definition}</code></pre><p>一个方法可以声明抛出多个异常，多个异常之间用逗号隔开。</p><p>例如，下面的方法声明抛出 RemoteException 和 InsufficientFundsException：</p><pre><code>import java.io.*;public class className{   public void withdraw(double amount) throws RemoteException,                              InsufficientFundsException   {       // Method implementation   }   //Remainder of class definition}</code></pre><h2 id="finally关键字"><a href="#finally关键字" class="headerlink" title="finally关键字"></a>finally关键字</h2><p>finally 关键字用来创建在 try 代码块后面执行的代码块。</p><p>无论是否发生异常，finally 代码块中的代码总会被执行。</p><p>在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。</p><p>finally 代码块出现在 catch 代码块最后，语法如下：</p><pre><code>try{  // 程序代码}catch(异常类型1 异常的变量名1){  // 程序代码}catch(异常类型2 异常的变量名2){  // 程序代码}finally{  // 程序代码}</code></pre><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>ExcepTest.java 文件代码：</p><pre><code>public class ExcepTest{  public static void main(String args[]){    int a[] = new int[2];    try{       System.out.println(&quot;Access element three :&quot; + a[3]);    }catch(ArrayIndexOutOfBoundsException e){       System.out.println(&quot;Exception thrown  :&quot; + e);    }    finally{       a[0] = 6;       System.out.println(&quot;First element value: &quot; +a[0]);       System.out.println(&quot;The finally statement is executed&quot;);    }  }}</code></pre><p>以上实例编译运行结果如下：</p><pre><code>Exception thrown  :java.lang.ArrayIndexOutOfBoundsException: 3First element value: 6The finally statement is executed</code></pre><p>注意下面事项：</p><p>catch 不能独立于 try 存在。</p><p>在 try/catch 后面添加 finally 块并非强制性要求的。</p><p>try 代码后不能既没 catch 块也没 finally 块。</p><p>try, catch, finally 块之间不能添加任何代码。</p><h2 id="声明自定义异常"><a href="#声明自定义异常" class="headerlink" title="声明自定义异常"></a>声明自定义异常</h2><p>在 Java 中你可以自定义异常。编写自己的异常类时需要记住下面的几点。</p><p>所有异常都必须是 Throwable 的子类。</p><p>如果希望写一个检查性异常类，则需要继承 Exception 类。</p><p>如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。</p><p>可以像下面这样定义自己的异常类：</p><pre><code>class MyException extends Exception{}</code></pre><p>只继承Exception 类来创建的异常类是检查性异常类。</p><p>下面的 InsufficientFundsException 类是用户定义的异常类，它继承自 Exception。</p><p>一个异常类和其它任何类一样，包含有变量和方法。</p><h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><p>以下实例是一个银行账户的模拟，通过银行卡的号码完成识别，可以进行存钱和取钱的操作。</p><p>InsufficientFundsException.java 文件代码：</p><pre><code>// 文件名InsufficientFundsException.javaimport java.io.*;//自定义异常类，继承Exception类public class InsufficientFundsException extends Exception{  //此处的amount用来储存当出现异常（取出钱多于余额时）所缺乏的钱  private double amount;  public InsufficientFundsException(double amount)  {    this.amount = amount;  }  public double getAmount()  {    return amount;  }}</code></pre><p>为了展示如何使用我们自定义的异常类，</p><p>在下面的 CheckingAccount 类中包含一个 withdraw() 方法抛出一个 InsufficientFundsException 异常。</p><p>CheckingAccount.java 文件代码：</p><pre><code>// 文件名称 CheckingAccount.javaimport java.io.*;//此类模拟银行账户public class CheckingAccount{  //balance为余额，number为卡号   private double balance;   private int number;   public CheckingAccount(int number)   {      this.number = number;   }  //方法：存钱   public void deposit(double amount)   {      balance += amount;   }  //方法：取钱   public void withdraw(double amount) throws                              InsufficientFundsException   {      if(amount &lt;= balance)      {         balance -= amount;      }      else      {         double needs = amount - balance;         throw new InsufficientFundsException(needs);      }   }  //方法：返回余额   public double getBalance()   {      return balance;   }  //方法：返回卡号   public int getNumber()   {      return number;   }}</code></pre><p>下面的 BankDemo 程序示范了如何调用 CheckingAccount 类的 deposit() 和 withdraw() 方法。</p><p>BankDemo.java 文件代码：</p><pre><code>//文件名称 BankDemo.javapublic class BankDemo{   public static void main(String [] args)   {      CheckingAccount c = new CheckingAccount(101);      System.out.println(&quot;Depositing $500...&quot;);      c.deposit(500.00);      try      {         System.out.println(&quot;\nWithdrawing $100...&quot;);         c.withdraw(100.00);         System.out.println(&quot;\nWithdrawing $600...&quot;);         c.withdraw(600.00);      }catch(InsufficientFundsException e)      {         System.out.println(&quot;Sorry, but you are short $&quot;                                  + e.getAmount());         e.printStackTrace();      }    }}</code></pre><p>编译上面三个文件，并运行程序 BankDemo，得到结果如下所示：</p><pre><code>Depositing $500...Withdrawing $100...Withdrawing $600...Sorry, but you are short $200.0InsufficientFundsException        at CheckingAccount.withdraw(CheckingAccount.java:25)        at BankDemo.main(BankDemo.java:13)</code></pre><h2 id="通用异常"><a href="#通用异常" class="headerlink" title="通用异常"></a>通用异常</h2><p>在Java中定义了两种类型的异常和错误。</p><h3 id="JVM-Java虚拟机-异常："><a href="#JVM-Java虚拟机-异常：" class="headerlink" title="JVM(Java虚拟机) 异常："></a>JVM(Java虚拟机) 异常：</h3><p>由 JVM 抛出的异常或错误。例如：NullPointerException 类，ArrayIndexOutOfBoundsException 类，ClassCastException 类。</p><h3 id="程序级异常："><a href="#程序级异常：" class="headerlink" title="程序级异常："></a>程序级异常：</h3><p>由程序或者API程序抛出的异常。例如 IllegalArgumentException 类，IllegalStateException 类。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<br><a href="https://www.runoob.com/java/java-exceptions.html" target="_blank" rel="noopener">https://www.runoob.com/java/java-exceptions.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重新温习Java中的异常处理&lt;/p&gt;
    
    </summary>
    
      <category term="2019年8月" scheme="http://yoursite.com/categories/2019%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记I</title>
    <link href="http://yoursite.com/2019/08/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0I/"/>
    <id>http://yoursite.com/2019/08/06/Java学习笔记I/</id>
    <published>2019-08-06T07:12:12.000Z</published>
    <updated>2019-08-12T06:36:51.043Z</updated>
    
    <content type="html"><![CDATA[<p>重新温习Java中的抽象类和接口</p><a id="more"></a><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。</p><p>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。</p><p>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。</p><p>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。</p><p>在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p><p>在Java语言中使用abstract class来定义抽象类。如下实例：</p><p>Employee.java 文件代码：</p><pre><code>/* 文件名 : Employee.java */public abstract class Employee{   private String name;   private String address;   private int number;   public Employee(String name, String address, int number)   {      System.out.println(&quot;Constructing an Employee&quot;);      this.name = name;      this.address = address;      this.number = number;   }   public double computePay()   {     System.out.println(&quot;Inside Employee computePay&quot;);     return 0.0;   }   public void mailCheck()   {      System.out.println(&quot;Mailing a check to &quot; + this.name       + &quot; &quot; + this.address);   }   public String toString()   {      return name + &quot; &quot; + address + &quot; &quot; + number;   }   public String getName()   {      return name;   }   public String getAddress()   {      return address;   }   public void setAddress(String newAddress)   {      address = newAddress;   }   public int getNumber()   {     return number;   }}</code></pre><p>注意到该 Employee 类没有什么不同，尽管该类是抽象类，但是它仍然有 3 个成员变量，7 个成员方法和 1 个构造方法。 现在如果你尝试如下的例子：</p><p>AbstractDemo.java 文件代码：</p><pre><code>/* 文件名 : AbstractDemo.java */public class AbstractDemo{   public static void main(String [] args)   {      /* 以下是不允许的，会引发错误 */      Employee e = new Employee(&quot;George W.&quot;, &quot;Houston, TX&quot;, 43);      System.out.println(&quot;\n Call mailCheck using Employee reference--&quot;);      e.mailCheck();    }}</code></pre><p>当你尝试编译AbstractDemo类时，会产生如下错误：</p><pre><code>Employee.java:46: Employee is abstract; cannot be instantiated      Employee e = new Employee(&quot;George W.&quot;, &quot;Houston, TX&quot;, 43);                   ^1 error</code></pre><h2 id="继承抽象类"><a href="#继承抽象类" class="headerlink" title="继承抽象类"></a>继承抽象类</h2><p>我们能通过一般的方法继承Employee类：</p><p>Salary.java 文件代码：</p><pre><code>/* 文件名 : Salary.java */public class Salary extends Employee{   private double salary; //Annual salary   public Salary(String name, String address, int number, double      salary)   {       super(name, address, number);       setSalary(salary);   }   public void mailCheck()   {       System.out.println(&quot;Within mailCheck of Salary class &quot;);       System.out.println(&quot;Mailing check to &quot; + getName()       + &quot; with salary &quot; + salary);   }   public double getSalary()   {       return salary;   }   public void setSalary(double newSalary)   {       if(newSalary &gt;= 0.0)       {          salary = newSalary;       }   }   public double computePay()   {      System.out.println(&quot;Computing salary pay for &quot; + getName());      return salary/52;   }}</code></pre><p>尽管我们不能实例化一个 Employee 类的对象，但是如果我们实例化一个 Salary 类对象，该对象将从 Employee 类继承 7 个成员方法，且通过该方法可以设置或获取三个成员变量。</p><p>AbstractDemo.java 文件代码：</p><pre><code>/* 文件名 : AbstractDemo.java */public class AbstractDemo{   public static void main(String [] args)   {      Salary s = new Salary(&quot;Mohd Mohtashim&quot;, &quot;Ambehta, UP&quot;, 3, 3600.00);      Employee e = new Salary(&quot;John Adams&quot;, &quot;Boston, MA&quot;, 2, 2400.00);      System.out.println(&quot;Call mailCheck using Salary reference --&quot;);      s.mailCheck();      System.out.println(&quot;\n Call mailCheck using Employee reference--&quot;);      e.mailCheck();    }}</code></pre><p>以上程序编译运行结果如下：</p><pre><code>Constructing an EmployeeConstructing an EmployeeCall mailCheck using  Salary reference --Within mailCheck of Salary classMailing check to Mohd Mohtashim with salary 3600.0Call mailCheck using Employee reference--Within mailCheck of Salary classMailing check to John Adams with salary 2400.</code></pre><h2 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h2><p>如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。</p><p>Abstract 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。</p><p>抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。</p><pre><code>public abstract class Employee{   private String name;   private String address;   private int number;   public abstract double computePay();   //其余代码}</code></pre><p>声明抽象方法会造成以下两个结果：</p><p>如果一个类包含抽象方法，那么该类必须是抽象类。</p><p>任何子类必须重写父类的抽象方法，或者声明自身为抽象类。</p><p>继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。</p><p>如果Salary类继承了Employee类，那么它必须实现computePay()方法：</p><p>Salary.java 文件代码：</p><pre><code>/* 文件名 : Salary.java */public class Salary extends Employee{   private double salary; // Annual salary   public double computePay()   {      System.out.println(&quot;Computing salary pay for &quot; + getName());      return salary/52;   }   //其余代码}</code></pre><p>抽象类总结规定</p><ol><li><p>抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。</p></li><li><p>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p></li><li><p>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</p></li><li><p>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。</p></li><li><p>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</p></li></ol><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p><p>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。</p><p>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</p><p>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p><h2 id="接口与类相似点："><a href="#接口与类相似点：" class="headerlink" title="接口与类相似点："></a>接口与类相似点：</h2><p>一个接口可以有多个方法。</p><p>接口文件保存在 .java 结尾的文件中，文件名使用接口名。</p><p>接口的字节码文件保存在 .class 结尾的文件中。</p><p>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</p><h2 id="接口与类的区别："><a href="#接口与类的区别：" class="headerlink" title="接口与类的区别："></a>接口与类的区别：</h2><p>接口不能用于实例化对象。</p><p>接口没有构造方法。</p><p>接口中所有的方法必须是抽象方法。</p><p>接口不能包含成员变量，除了 static 和 final 变量。</p><p>接口不是被类继承了，而是要被类实现。</p><p>接口支持多继承。</p><h2 id="接口特性"><a href="#接口特性" class="headerlink" title="接口特性"></a>接口特性</h2><p>接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。</p><p>接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。</p><p>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。</p><h2 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h2><ol><li><p>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</p></li><li><p>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。</p></li><li><p>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</p></li><li><p>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p></li></ol><p>注：JDK 1.8 以后，接口里可以有静态方法和方法体了。</p><h2 id="接口的声明"><a href="#接口的声明" class="headerlink" title="接口的声明"></a>接口的声明</h2><p>接口的声明语法格式如下：</p><pre><code>[可见度] interface 接口名称 [extends 其他的接口名] {        // 声明变量        // 抽象方法}</code></pre><p>Interface关键字用来声明一个接口。下面是接口声明的一个简单例子。<br>NameOfInterface.java 文件代码：</p><pre><code>/* 文件名 : NameOfInterface.java */import java.lang.*;//引入包public interface NameOfInterface{   //任何类型 final, static 字段   //抽象方法}</code></pre><p>接口有以下特性：</p><p>接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。</p><p>接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键字。</p><p>接口中的方法都是公有的。</p><p>实例</p><pre><code>Animal.java 文件代码：/* 文件名 : Animal.java * /interface Animal {   public void eat();   public void travel();}</code></pre><h2 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h2><p>当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。</p><p>类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。</p><p>实现一个接口的语法，可以使用这个公式：</p><p>Animal.java 文件代码：</p><pre><code>...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ...</code></pre><p>实例<br>MammalInt.java 文件代码：</p><pre><code>/* 文件名 : MammalInt.java * /public class MammalInt implements Animal{   public void eat(){      System.out.println(&quot;Mammal eats&quot;);   }   public void travel(){      System.out.println(&quot;Mammal travels&quot;);   }   public int noOfLegs(){      return 0;   }   public static void main(String args[]){      MammalInt m = new MammalInt();      m.eat();      m.travel();   }}</code></pre><p>以上实例编译运行结果如下:</p><pre><code>Mammal eatsMammal travels</code></pre><p>重写接口中声明的方法时，需要注意以下规则：</p><p>类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。</p><p>类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。</p><p>如果实现接口的类是抽象类，那么就没必要实现该接口的方法。</p><p>在实现接口的时候，也要注意一些规则：</p><p>一个类可以同时实现多个接口。</p><p>一个类只能继承一个类，但是能实现多个接口。</p><p>一个接口能继承另一个接口，这和类之间的继承比较相似。</p><h2 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h2><p>一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。</p><p>下面的Sports接口被Hockey和Football接口继承：</p><pre><code>// 文件名: Sports.javapublic interface Sports{   public void setHomeTeam(String name);   public void setVisitingTeam(String name);}// 文件名: Football.javapublic interface Football extends Sports{   public void homeTeamScored(int points);   public void visitingTeamScored(int points);   public void endOfQuarter(int quarter);}// 文件名: Hockey.javapublic interface Hockey extends Sports{   public void homeGoalScored();   public void visitingGoalScored();   public void endOfPeriod(int period);   public void overtimePeriod(int ot);}</code></pre><p>Hockey接口自己声明了四个方法，从Sports接口继承了两个方法，这样，实现Hockey接口的类需要实现六个方法。</p><p>相似的，实现Football接口的类需要实现五个方法，其中两个来自于Sports接口。<br>接口的多继承</p><p>在Java中，类的多继承是不合法，但接口允许多继承。</p><p>在接口的多继承中extends关键字只需要使用一次，在其后跟着继承接口。 如下所示：</p><pre><code>public interface Hockey extends Sports, Event</code></pre><p>以上的程序片段是合法定义的子接口，与类不同的是，接口允许多继承，而 Sports及 Event 可能定义或是继承相同的方法</p><h2 id="标记接口"><a href="#标记接口" class="headerlink" title="标记接口"></a>标记接口</h2><p>最常用的继承接口是没有包含任何方法的接口。</p><p>标记接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。</p><p>标记接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。</p><p>例如：java.awt.event 包中的 MouseListener 接口继承的 java.util.EventListener 接口定义如下：</p><pre><code>package java.util;public interface EventListener{}</code></pre><p>没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的：</p><p>建立一个公共的父接口：</p><p>正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。</p><p>向一个类添加数据类型：</p><p>这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://www.runoob.com/java/java-abstraction.html" target="_blank" rel="noopener">https://www.runoob.com/java/java-abstraction.html</a></p><p>【2】<a href="https://www.runoob.com/java/java-interfaces.html" target="_blank" rel="noopener">https://www.runoob.com/java/java-interfaces.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重新温习Java中的抽象类和接口&lt;/p&gt;
    
    </summary>
    
      <category term="2019年8月" scheme="http://yoursite.com/categories/2019%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot学习笔记IX</title>
    <link href="http://yoursite.com/2019/08/05/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0IX/"/>
    <id>http://yoursite.com/2019/08/05/SpringBoot学习笔记IX/</id>
    <published>2019-08-05T03:22:12.000Z</published>
    <updated>2019-08-28T09:17:37.143Z</updated>
    
    <content type="html"><![CDATA[<p>CMS系统学习。</p><a id="more"></a><h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h1><p>cn.kael.query.inner中逻辑写在biz中，config/InnerDbConfig是内部数据库配置，<br>controller接口，dao数据库自动生成，</p><p>kael_query表中的tbl_jobs是定时任务相关的表,其中tag是标签名字，暂时是唯一索引，入参，不能改动，sql_note是sql语句内容，operator_no是操作者编号，cron是定时表达式，receiver是收件人，memo是备注内容，task_status是定时任务状态，datasoure_name要执行任务sql的数据源，out_type是输出类型（正文和附件）</p><p>增加定时任务的分页查询，包括附加条件的分页查询，比如模糊匹配名字，接收者的分页查询，固定时间范围内的分页查询,把分页查询都写到一个接口里，根据传进来的参数进行不同的查询。</p><p>增删改查完本地库，去Quartz 完成增删改查定时任务。用@Autowired注解注入</p><p>cn.creditease.std.query.kael.core.task.TaskManager</p><p>kaelContext.setEmailMode(tblJobsEntity.getOutType());</p><p>根据枚举的邮件输出类型设置emailMode为0或1</p><p>tbl_notes是笔记相关的表，tag是笔记名字，暂时不能改动，后面可以置为能改动的列，根据id来查，两张表都是tag和operator_no不能改动，其它可以改动</p><p>tbl_sql_warning 是SQL语句对应的表，</p><p>完成两张表到增删改查功能，在DatasourceInfoController中查询并返回可用的数据源列表。</p><p>中秋节前，9.12：<br>CMS业务分享PPT：<br>常用页面操作分享，<br>核心流程分享：进件流程，状态机修改流程，有哪些限制，<br>CMS常用表例如transport，history分享</p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p>出现找不到主类的错误首先将porm文件右键选择Add to the maven project添加到右侧到maven库中，然后再将工程文件右键Mark Directory as-&gt;Sources Root</p><p>java:程序包XXXX不存在</p><p>可以先删去导入的该包然后用快捷键Alt+Enter选择add to library搜索导入该包</p><p>不能全写到一个UserService里，要有相应的区分</p><p>ServiceImpl参数不能直接传实体，不利于可读性和可维护性，用哪些传哪些，里面只写数据库相关操作，涉及EntityMapper的，逻辑内容写到biz文件夹中,Service里返回Entity而不是DTO，biz中返回DTO</p><p>mybatis-config不用加到resources.local里面，在resources里面就行</p><p>config文件夹内还要有相应的数据库自动化配置和Mybatis配置文件</p><p>如果出现循环依赖的问题，例如query.inner和query.core相互依赖，则在两个子项目的porm.xml中去掉彼此的依赖项目</p><p>Maven执行clean和install在生命周期Lifecycle中选择相应的命令执行即可</p><p>pom.xml中的自动生成mapper.xml的依赖后期要注释掉，否则每次install maven都会覆盖掉原先的。</p><pre><code>CharacterEncoding=UTF-8&amp;autoReconnect=true&amp;failOverReadOnly=falsecom.mysql.jdbc.exceptions.jdbc4.MySQLNonTransientConnectionException: Could not create connection to database server. Attempted reconnect 3 times. Giving up.    at sun.reflect.GeneratedConstructorAccessor64.newInstance(Unknown Source)    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)    at java.lang.reflect.Constructor.newInstance(Constructor.java:423)</code></pre><h2 id="驼峰命名法"><a href="#驼峰命名法" class="headerlink" title="驼峰命名法"></a>驼峰命名法</h2><p>方法名开头字母要小写</p><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>之前处理异常的方法</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CMS系统学习。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年8月" scheme="http://yoursite.com/categories/2019%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="SpringBoot，Java" scheme="http://yoursite.com/tags/SpringBoot%EF%BC%8CJava/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot学习笔记VIII</title>
    <link href="http://yoursite.com/2019/08/05/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0VIII/"/>
    <id>http://yoursite.com/2019/08/05/SpringBoot学习笔记VIII/</id>
    <published>2019-08-05T03:22:12.000Z</published>
    <updated>2019-08-20T09:19:10.912Z</updated>
    
    <content type="html"><![CDATA[<p>CMS系统学习。</p><a id="more"></a><h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h1><p>先阅读cn.creditease.bdp.newcms.notice源码，定时相关，其中impl/CmsTaskNoticeHelperImpl/sendMsgByBatch函数是模块入口</p><h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><p>cn.creditease.bdp.newcms.cmswrapper.controller.PaymentScheduleController的源码，涉及到customer表，里面是借贷用户的信息</p><h2 id="阅读-1"><a href="#阅读-1" class="headerlink" title="阅读"></a>阅读</h2><p>cn.creditease.bdp.newcms.controller.creditreview.TransportController中的public Object create(@RequestBody(required = false) Transport transport)方法重点看FULL_FLOW，cn.creditease.bdp.newcms.service.creditreview.fullFlowfullFlow中的评级部分代码</p><pre><code>CMSResponseCode cmsResponseCode = rateBoth(transport);</code></pre><p>和最后一段代码</p><pre><code>dataPrepareCheckAndCheckSuijieRule(transport);</code></pre><h2 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h2><p>cn.creditease.bdp.newcms.cmswrapper.controller.TransportQueryController中的getAll对应<a href="http://std-cms-fe.laincloud.xyz/#/incoming进件查询中的查询按钮，现在需要在标记一栏的返回值中加入新的返回信息。" target="_blank" rel="noopener">http://std-cms-fe.laincloud.xyz/#/incoming进件查询中的查询按钮，现在需要在标记一栏的返回值中加入新的返回信息。</a></p><p>cn.creditease.bdp.newcms.cmswrapper.service.cms.TransportQueryServiceTest中写测试样例</p><p>参见<a href="http://wiki.yxapp.in/pages/viewpage.action?pageId=68764493" target="_blank" rel="noopener">http://wiki.yxapp.in/pages/viewpage.action?pageId=68764493</a></p><p>/api/2.0/application/isDataloan/{transportId} 根据进件号查询是否为数据贷进件<br>在shangtongdai中site.conf.routes<br>controllers.api2.InternalApiController.isDataloan</p><p>/internal/api/v1/submitDebt 提交负债信息<br>在shangtongdai中site.conf.api2.routes<br>controllers.api.InternalApiController.submitDebt</p><p>先写submitDebt接口，即siteHelper.submitDebtInfo部分把商通贷中的逻辑写在cms中，scala-》Java</p><p>系统调用：Controller-&gt;Service-&gt;DAO-&gt;database<br>所以逻辑写在Service中，数据库操作写在DAO，一个方法做一件事，增强可读性。he</p><p>两个接口原先在shangtongdai中，用scala写成</p><p>现在需要迁移到cms中重构为Java</p><p>运行项目<br>sbt “project site” run</p><h1 id="系统介绍"><a href="#系统介绍" class="headerlink" title="系统介绍"></a>系统介绍</h1><p>最早的site系统，scala语言，编译运行比较慢，一小时左右，包括了application，postloan等所有系统</p><p>测试官网网址：<a href="http://shangtongdai.yxapp.xyz/newsite/?code=YANGKAI34#/loginReg/login" target="_blank" rel="noopener">http://shangtongdai.yxapp.xyz/newsite/?code=YANGKAI34#/loginReg/login</a></p><p>查询语句：</p><pre><code>select * from shangtongdai.users    where id in (      select user_id from shangtongdai.applications          where id in (                select application_id from shangtongdai.loans                      where loan_status_id=12 ))</code></pre><p>application系统：进件系统</p><p>巨星系统：数据中转</p><p>爬虫系统：爬取商户数据</p><p>miner系统：评级系统</p><p>postloan系统（贷后系统）</p><p>User系统：管理用户</p><p>User-refer系统：返还佣金</p><p>Report系统：做报表</p><p>Report-tool系统：基础查询</p><p>综合信贷系统：管理合同签约</p><p>新核心系统：管理还款计划表</p><p>结算系统：管理还款逻辑</p><p>添加店户会触发爬虫系统，爬取商户的数据，使用miner系统进行评级，巨星系统进行数据中转筛除。</p><p>评级通过之后，进件将由CMS系统进行审核，审核通过后，所有审核逻辑都在CMS系统中。</p><p>审核通过后，由postloan系统（贷后系统）处理，包括了：</p><p>1.合同管理：签约，管理状态,综合信贷系统管理合同签约</p><p>2.还款：还款计划表,新核心系统管理还款计划表</p><p>3.放款：结算系统管理还款逻辑</p><p>团队主要负责CMS，postloan和report，report-tool等系统。</p><p>application进件系统，爬虫系统，巨星系统，miner评级系统由进件团队负责。</p><p>CMS系统里有初审，复审，分发等36个状态。</p><p><strong><em>shangtongdai数据库表信息：</em></strong></p><p>transport表：进件表，维护进件状态，</p><p>transportlabel拒绝或接受打下标签</p><p>transportext 进件附加信息，以json格式存储（最重要）</p><p>transport_decisions:重大决策信息放款或其它</p><p>transport_assigned_history：客服分单给客户历史的信息</p><p>loan :合同</p><p>repayment：业务订单，用户还款会生成业务订单</p><p>loanrepayment：合同和业务订单的关系，一笔合同会有多笔订单</p><p>repayment_type字段，还款类型</p><p>repayment_order字段：</p><p>repaymenttags:业务订单信息</p><p>权限信息的相关表<br>privilege<br>role<br>role_privilege<br>user_role</p><p>任务相关的表<br>tb_cron_ini<br>cms_task</p><h1 id="CMS系统分析"><a href="#CMS系统分析" class="headerlink" title="CMS系统分析"></a>CMS系统分析</h1><h2 id="进件流程"><a href="#进件流程" class="headerlink" title="进件流程"></a>进件流程</h2><p>入口create接口</p><h2 id="状态机流程"><a href="#状态机流程" class="headerlink" title="状态机流程"></a>状态机流程</h2><p>很多外界模块都会调用 NewtransportOpmachineServiceimpl/operateTransport<br>举例审核操作信审3.0系统 ，审核进件，批钱，批产品，校验身份，审核是否符合规定，可能也需要用户补充信息，例如电话核实信息，如果拒绝则调用信审系统，调用cms系统中cn.creditease.bdp.newcms.controller.creditreview.operate接口</p><p>目的是变换当前状态到下一个状态，其次是通知操作,label标定，记录备注都会调用状态机，状态不会改变。</p><h2 id="展示流程"><a href="#展示流程" class="headerlink" title="展示流程"></a>展示流程</h2><p>cms有页面，会串联很多系统有交互，会处理很多中间的进件流程。<br>比如applicatoin进件系统，当application将进件推给cms时，进件信息里很多存在transport_exts表中，CmsDetailController<br>chrome 右键检查可以看见请求，根据请求找代码</p><p>进件流程 ：画流程图<br>重点是create和fullflow两个</p><p>进件分为store检查是否有新进件，没有的话insert，待初审分配，<br>第二是重新进件</p><p>cn.creditease.bdp.newcms.service.creditreview.fullFlow<br>1.rateBoth full预估和partial预估<br>2.dataPrepareCheckAndCheckSuijieRule 随借 检查数据完整性是否能够推送到信审3.0，如果不够完整则创建redis任务，</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】<br><a href="https://blog.csdn.net/weixin_34112900/article/details/93630203" target="_blank" rel="noopener">https://blog.csdn.net/weixin_34112900/article/details/93630203</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CMS系统学习。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年8月" scheme="http://yoursite.com/categories/2019%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="SpringBoot，Java" scheme="http://yoursite.com/tags/SpringBoot%EF%BC%8CJava/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot学习笔记VII</title>
    <link href="http://yoursite.com/2019/08/01/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0VII/"/>
    <id>http://yoursite.com/2019/08/01/SpringBoot学习笔记VII/</id>
    <published>2019-08-01T09:12:12.000Z</published>
    <updated>2019-08-12T06:47:27.067Z</updated>
    
    <content type="html"><![CDATA[<p>CMS系统学习，对常用到的注解做详解</p><a id="more"></a><h1 id="CMS系统简介"><a href="#CMS系统简介" class="headerlink" title="CMS系统简介"></a>CMS系统简介</h1><p>内容管理系统（英语：content management system，缩写为 CMS）是指在一个合作模式下，用于管理工作流程的一套制度。该系统可应用于手工操作中，也可以应用到计算机或网络里。作为一种中央储存器（central repository），内容管理系统可将相关内容集中储存并具有群组管理、版本控制等功能。版本控制是内容管理系统的一个主要优势。<br>内容管理系统在物品或文案或数据的存储、掌管、修订（盘存）、语用充实、文档发布等方面有着广泛的应用。现在流行的开源CMS系统有WordPress、Joomla!、Drupal、Xoops、CmsTop等。</p><h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><p>进件 Transport 业务上增加贷款或商户的操作。</p><h1 id="任务描述"><a href="#任务描述" class="headerlink" title="任务描述"></a>任务描述</h1><h2 id="实现查询接口"><a href="#实现查询接口" class="headerlink" title="实现查询接口"></a>实现查询接口</h2><p>saas-cms 的Respository中建立自己的分支，在controller/creditreview/TransportController中画出getAllProcessHistory函数的流程图，自己重新实现一个查询接口<br>数据库配置文件在resources.local/application.yml中<br>使用的数据库是：jdbc:mysql://10.143.248.78:3306/creditreview?</p><p>其中该函数根据GET请求/{transportId}/{attr}中的attr参数（花括号内为参数值）查询相应的数据库transportLabel、transportExt、transportProcessHistory、transportDecision四个数据库</p><h2 id="画出putExts函数流程图（周一上午提交）"><a href="#画出putExts函数流程图（周一上午提交）" class="headerlink" title="画出putExts函数流程图（周一上午提交）"></a>画出putExts函数流程图（周一上午提交）</h2><h2 id="CMS排查问题记录"><a href="#CMS排查问题记录" class="headerlink" title="CMS排查问题记录"></a>CMS排查问题记录</h2><p>入手学习CMS系统</p><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>handler method 参数绑定常用的注解,根据处理的Request的不同内容部分分为四类：（主要讲解常用类型）</p><p>A、处理request uri 部分（这里指uri template中variable，不含queryString部分）的注解：@PathVariable;</p><p>B、处理request header部分的注解：   @RequestHeader, @CookieValue;</p><p>C、处理request body部分的注解：@RequestParam,  @RequestBody;</p><p>D、处理attribute类型是注解： @SessionAttributes, @ModelAttribute;</p><h2 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h2><p>当使用@RequestMapping URI template 样式映射时， 即 someUrl/{paramId}, 这时的paramId可通过 @Pathvariable注解绑定它传过来的值到方法的参数上。</p><p>示例代码：</p><pre><code>@Controller@RequestMapping(&quot;/owners/{ownerId}&quot;)public class RelativePathUriTemplateController {  @RequestMapping(&quot;/pets/{petId}&quot;)  public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) {        // implementation omitted  }}</code></pre><p>上面代码把URI template 中变量 ownerId的值和petId的值，绑定到方法的参数上。若方法参数名称和需要绑定的uri template中变量名称不一致，需要在@PathVariable(“name”)指定uri template中的名称。</p><h2 id="RequestHeader、-CookieValue"><a href="#RequestHeader、-CookieValue" class="headerlink" title="@RequestHeader、@CookieValue"></a>@RequestHeader、@CookieValue</h2><p><strong><em>@RequestHeader注解，可以把Request请求header部分的值绑定到方法的参数上。</em></strong></p><p>示例代码：</p><p>这是一个Request 的header部分：</p><pre><code>Host                    localhost:8080Accept                  text/html,application/xhtml+xml,application/xml;q=0.9Accept-Language         fr,en-gb;q=0.7,en;q=0.3Accept-Encoding         gzip,deflateAccept-Charset          ISO-8859-1,utf-8;q=0.7,*;q=0.7Keep-Alive              300</code></pre><p>下面的代码，把request header部分的 Accept-Encoding的值，绑定到参数encoding上了， Keep-Alive header的值绑定到参数keepAlive上。</p><pre><code>@RequestMapping(&quot;/displayHeaderInfo.do&quot;)public void displayHeaderInfo(@RequestHeader(&quot;Accept-Encoding&quot;) String encoding,                              @RequestHeader(&quot;Keep-Alive&quot;) long keepAlive)  {  //...}</code></pre><p><strong><em>@CookieValue 可以把Request header中关于cookie的值绑定到方法的参数上。</em></strong></p><p>例如有如下Cookie值：</p><pre><code>JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84</code></pre><p>参数绑定的代码：</p><pre><code>@RequestMapping(&quot;/displayHeaderInfo.do&quot;)public void displayHeaderInfo(@CookieValue(&quot;JSESSIONID&quot;) String cookie)  {  //...}</code></pre><p>即把JSESSIONID的值绑定到参数cookie上。</p><h2 id="RequestParam-RequestBody"><a href="#RequestParam-RequestBody" class="headerlink" title="@RequestParam, @RequestBody"></a>@RequestParam, @RequestBody</h2><h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h3><p>A） 常用来处理简单类型的绑定，通过Request.getParameter() 获取的String可直接转换为简单类型的情况（ String–&gt; 简单类型的转换操作由ConversionService配置的转换器来完成）；因为使用request.getParameter()方式获取参数，所以可以处理get 方式中queryString的值，也可以处理post方式中 body data的值；</p><p>B）用来处理Content-Type: 为 application/x-www-form-urlencoded编码的内容，提交方式GET、POST；</p><p>C) 该注解有两个属性： value、required； value用来指定要传入值的id名称，required用来指示参数是否必须绑定；</p><p>示例代码：</p><pre><code>@Controller@RequestMapping(&quot;/pets&quot;)@SessionAttributes(&quot;pet&quot;)public class EditPetForm {    // ...    @RequestMapping(method = RequestMethod.GET)    public String setupForm(@RequestParam(&quot;petId&quot;) int petId, ModelMap model) {        Pet pet = this.clinic.loadPet(petId);        model.addAttribute(&quot;pet&quot;, pet);        return &quot;petForm&quot;;    }    // ...</code></pre><h3 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h3><p>该注解常用来处理Content-Type: 不是application/x-www-form-urlencoded编码的内容，例如application/json, application/xml等；</p><p>它是通过使用HandlerAdapter 配置的HttpMessageConverters来解析post data body，然后绑定到相应的bean上的。</p><p>因为配置有FormHttpMessageConverter，所以也可以用来处理 application/x-www-form-urlencoded的内容，处理完的结果放在一个MultiValueMap&lt;String, String&gt;里，这种情况在某些特殊需求下使用，详情查看FormHttpMessageConverter api;</p><p>示例代码：</p><pre><code>@RequestMapping(value = &quot;/something&quot;, method = RequestMethod.PUT)public void handle(@RequestBody String body, Writer writer) throws IOException {  writer.write(body);</code></pre><h2 id="SessionAttributes-ModelAttribute"><a href="#SessionAttributes-ModelAttribute" class="headerlink" title="@SessionAttributes, @ModelAttribute"></a>@SessionAttributes, @ModelAttribute</h2><h3 id="SessionAttributes"><a href="#SessionAttributes" class="headerlink" title="@SessionAttributes:"></a>@SessionAttributes:</h3><p>该注解用来绑定HttpSession中的attribute对象的值，便于在方法中的参数里使用。</p><p>该注解有value、types两个属性，可以通过名字和类型指定要使用的attribute 对象；</p><p>示例代码：</p><pre><code>@Controller@RequestMapping(&quot;/editPet.do&quot;)@SessionAttributes(&quot;pet&quot;)public class EditPetForm {    // ...}</code></pre><h3 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a>@ModelAttribute</h3><p>该注解有两个用法，一个是用于方法上，一个是用于参数上；</p><p>用于方法上时：  通常用来在处理@RequestMapping之前，为请求绑定需要从后台查询的model；</p><p>用于参数上时： 用来通过名称对应，把相应名称的值绑定到注解的参数bean上；要绑定的值来源于：</p><p>A） @SessionAttributes 启用的attribute 对象上；</p><p>B） @ModelAttribute 用于方法上时指定的model对象；</p><p>C） 上述两种情况都没有时，new一个需要绑定的bean对象，然后把request中按名称对应的方式把值绑定到bean中。</p><p>用到方法上@ModelAttribute的示例代码：</p><pre><code>// Add one attribute// The return value of the method is added to the model under the name &quot;account&quot;// You can customize the name via @ModelAttribute(&quot;myAccount&quot;)@ModelAttributepublic Account addAccount(@RequestParam String number) {    return accountManager.findAccount(number);}</code></pre><p>这种方式实际的效果就是在调用@RequestMapping的方法之前，为request对象的model里put（“account”， Account）；</p><p>用在参数上的@ModelAttribute示例代码：</p><pre><code>@RequestMapping(value=&quot;/owners/{ownerId}/pets/{petId}/edit&quot;, method = RequestMethod.POST)public String processSubmit(@ModelAttribute Pet pet) {}</code></pre><p>首先查询 @SessionAttributes有无绑定的Pet对象，若没有则查询@ModelAttribute方法层面上是否绑定了Pet对象，若没有则将URI template中的值按对应的名称绑定到Pet对象的各属性上。</p><h2 id="在不给定注解的情况下，参数是怎样绑定的？"><a href="#在不给定注解的情况下，参数是怎样绑定的？" class="headerlink" title="在不给定注解的情况下，参数是怎样绑定的？"></a>在不给定注解的情况下，参数是怎样绑定的？</h2><p>通过分析AnnotationMethodHandlerAdapter和RequestMappingHandlerAdapter的源代码发现，方法的参数在不给定参数的情况下：</p><p>若要绑定的对象时简单类型：  调用@RequestParam来处理的。 </p><p>若要绑定的对象时复杂类型：  调用@ModelAttribute来处理的。</p><p>这里的简单类型指java的原始类型(boolean, int 等)、原始类型对象（Boolean, Int等）、String、Date等ConversionService里可以直接String转换成目标对象的类型；</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://blog.csdn.net/walkerJong/article/details/7946109" target="_blank" rel="noopener">https://blog.csdn.net/walkerJong/article/details/7946109</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CMS系统学习，对常用到的注解做详解&lt;/p&gt;
    
    </summary>
    
      <category term="2019年8月" scheme="http://yoursite.com/categories/2019%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>数据库学习笔记I</title>
    <link href="http://yoursite.com/2019/07/31/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0I/"/>
    <id>http://yoursite.com/2019/07/31/数据库学习笔记I/</id>
    <published>2019-07-31T03:12:12.000Z</published>
    <updated>2019-08-12T06:42:14.877Z</updated>
    
    <content type="html"><![CDATA[<p>SQL分页查询</p><a id="more"></a><h1 id="SQL分页查询"><a href="#SQL分页查询" class="headerlink" title="SQL分页查询"></a>SQL分页查询</h1><p>使用SELECT查询时，如果结果集数据量很大，比如几万行数据，放在一个页面显示的话数据量太大，不如分页显示，每次显示100条。</p><p>要实现分页功能，实际上就是从结果集中显示第1 ~ 100条记录作为第1页，显示第101~200条记录作为第2页，以此类推。</p><p>因此，分页实际上就是从结果集中“截取”出第M~N条记录。这个查询可以通过LIMIT <m> OFFSET <n>子句实现。</n></m></p><p>例如基本查询语句：</p><pre><code>SELECT id,name,gender,scoreFROM studentsORDER BY score DESC;</code></pre><p>现在将结果集分页，每页3条记录。要获取第一页的记录，可以使用 LIMIT 3 OFFSET 0:</p><pre><code>SELECT id,name,gender,scoreFROM studentsORDER BY score DESCLIMIT 3 OFFSET 0;</code></pre><p>上述查询LIMIT 3 OFFSET 0表示：<br>对结果集从0号记录开始，最多取3条（注意SQL记录集对索引从0开始）。<br>若要查询第2页，那么我们只需要跳过前3条记录，即对结果集从3号记录开始查询，把OFFSET设定为3:</p><pre><code>SELECT id,name,gender,scoreFROM studentsORDER BY score DESCLIMIT 3 OFFSET 3;</code></pre><p>类似的，查询第3页的时候，OFFSET应该设为6，查询第4页的时候，OFFSET应该设为9.如果查询的表第4页只有1条记录，则最终结果按照实际数量1显示，LIMIT 3表示的意思是“最多3条记录”。</p><p>可见分页查询的关键在于，首先要确定每页需要显示的结果数量pageSize，然后根据当前页的索引pageIndex（从1开始），确定LIMIT和OFFSET应该设定的值：</p><p>LIMIT总是设定为pageSize；<br>OFFSET计算公式为pageSize*（pageIndex-1）。</p><h2 id="扩展思考"><a href="#扩展思考" class="headerlink" title="扩展思考"></a>扩展思考</h2><p>如果原本记录集只有10条记录，但我们将OFFSET设置为20，结果会怎样呢？<br>答案是OFFSET超过查询的最大数量并不会报错，而是会得到一个空的结果集</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>OFFSET是可选的，OFFSET缺省值为0.即LIMIT 3 相当于LIMIT 3 OFFSET 0<br>在MySQL中，LIMIT 3 OFFSET 0也可简写为LIMIT 3，0<br>使用LIMIT M OFFSET N进行分页查询时，N越大查询效率越低。</p><h1 id="SQL连接查询"><a href="#SQL连接查询" class="headerlink" title="SQL连接查询"></a>SQL连接查询</h1><p>连接查询是将两个或两个以上的表按某些条件连接起来，从中选取需要的数据。可以分为内连接查询(通过where实现)和外连接查询（join）。</p><h2 id="内连接查询"><a href="#内连接查询" class="headerlink" title="内连接查询"></a>内连接查询</h2><p>只有不同表中有相同意义的字段时才能进行连接，而且内连接查询只查询出指定字段取值相同的记录。<br><img src="assets/markdown-img-paste-20190801165654826.png" alt="https://img-blog.csdn.net/20171209135846780?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcGxnMTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p><pre><code>一般语法:select a.* , b.*from table_a as a, table_b as bwhere a.id = b.id;</code></pre><h2 id="外连接查询"><a href="#外连接查询" class="headerlink" title="外连接查询"></a>外连接查询</h2><p>需要通过指定字段来进行连接。当该字段取值相等时，可以查询出该记录；而且当该字段不等时，也可以查询出来。包括左连接，右连接查询。</p><pre><code>一般语法：select 属性名列表from 表1left | right join 表2on 表1.属性名 = 表2.属性名;</code></pre><h3 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h3><p>left join 是left outer join的简写，它的全称是左外连接，是外连接中的一种。<br>左(外)连接，左表(a_table)的记录将会全部表示出来，而右表(b_table)只会显示符合搜索条件的记录。右表记录不足的地方均为NULL。<br><img src="assets/markdown-img-paste-2019080116575036.png" alt="https://img-blog.csdn.net/20171209142610819?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcGxnMTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p><h3 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h3><p>右外连接与左外连接相对称，<br>right join是right outer join的简写，它的全称是右外连接，是外连接中的一种。<br>与左(外)连接相反，右(外)连接，左表(a_table)只会显示符合搜索条件的记录，而右表(b_table)的记录将会全部表示出来。左表记录不足的地方均为NULL。<br><img src="assets/markdown-img-paste-20190801175330121.png" alt="https://img-blog.csdn.net/20171209144056668?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcGxnMTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p><h3 id="外连接查询加条件语句"><a href="#外连接查询加条件语句" class="headerlink" title="外连接查询加条件语句"></a>外连接查询加条件语句</h3><p>使用外连接查询时，可以加上各种条件进行筛选。</p><pre><code>select table1.column1, table2.column1from table1join table2on table1.column2 = table2.column3;select table1.column1, table2.column1from table1,table2where table1.column2 = table2.column3;</code></pre><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>子查询时将一个查询语句嵌套在另一个查询语句中，内层查询语句的查询结果，可以为外层查询语句提供查询条件。在特定情况下：一个查询语句的条件需要另一个查询语句来获取。<br>子查询，又叫内部查询，相对于内部查询，包含内部查询的就称为外部查询。</p><p>子查询可以包含普通select可以包括的任何子句，比如：distinct、 group by、order by、limit、join和union等；但是对应的外部查询必须是以下语句之一：select、insert、update、delete、set或 者do。</p><p>注：一个查询语句只能有一个order by ，在子查询中只能位于外部查询后面.</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>子查询分为如下几类：<br>1）. 标量子查询：返回单一值的标量，最简单的形式。<br>2）. 列子查询：返回的结果集是 N 行一列。<br>3）. 行子查询：返回的结果集是一行 N 列。<br>4）. 表子查询：返回的结果集是 N 行 N 列。<br>可以使用的操作符：= &gt; &lt; &gt;= &lt;= &lt;&gt; ANY IN SOME ALL EXISTS</p><p>释义：一个子查询会返回一个标量（就一个值）、一个行、一个列或一个表，这些子查询称之为标量、行、列和表子查询。</p><h3 id="带有any关键字的子查询"><a href="#带有any关键字的子查询" class="headerlink" title="带有any关键字的子查询"></a>带有any关键字的子查询</h3><p>any关键字表示满足其中任一条件，使用any关键字时，只要满足内层查询语句返回的结果中的任何一个，就可以通过该条件来执行外层查询语句。</p><p>从computer表中查询哪些人分数高于任何一个奖学金的最低分。</p><pre><code>select * from computer_stuwhere score &gt;= ANY                  (select score From  scholarship);</code></pre><h3 id="带有all关键字的子查询"><a href="#带有all关键字的子查询" class="headerlink" title="带有all关键字的子查询"></a>带有all关键字的子查询</h3><p>表示需要满足所有的条件。只有满足内层查询语句返回的所有结果，才可以执行外层查询语句。</p><h3 id="带有exists关键字的子查询"><a href="#带有exists关键字的子查询" class="headerlink" title="带有exists关键字的子查询"></a>带有exists关键字的子查询</h3><p>exists关键字表示存在，内层查询语句不返回查询的记录，而是返回一个真假值，如果内层查询语句查询到满足条件的记录，就返回一个true，外层查询语句将进行查询。</p><pre><code>select * from employeewhere exists (select d_name from department where d_id = 1003);//如果department存在d_id为1003，则查询employee表。</code></pre><p>还可以分为相关子查询，独立子查询。以上子查询与外层查询没有关联，称为独立子查询，如果子查询有用到外层查询的字段，则称相关子查询，相关子查询容易产生性能问题。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://www.liaoxuefeng.com/wiki/1177760294764384/1217864791925600" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1177760294764384/1217864791925600</a><br>【2】<a href="https://blog.csdn.net/plg17/article/details/78758593" target="_blank" rel="noopener">https://blog.csdn.net/plg17/article/details/78758593</a><br>【3】<a href="https://cloud.tencent.com/developer/article/1333120" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1333120</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SQL分页查询&lt;/p&gt;
    
    </summary>
    
      <category term="2019年7月" scheme="http://yoursite.com/categories/2019%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="Database，SQL" scheme="http://yoursite.com/tags/Database%EF%BC%8CSQL/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot学习笔记VI</title>
    <link href="http://yoursite.com/2019/07/31/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0VI/"/>
    <id>http://yoursite.com/2019/07/31/SpringBoot学习笔记VI/</id>
    <published>2019-07-31T02:12:12.000Z</published>
    <updated>2019-08-01T08:36:08.203Z</updated>
    
    <content type="html"><![CDATA[<p>简单总结SpringMVC整合Mybatis，从Get/Request请求中实现对数据库的增删改查，对应着SpringBoot学习笔记II中的Mybatis任务中的第二项。</p><a id="more"></a><h1 id="建立项目步骤"><a href="#建立项目步骤" class="headerlink" title="建立项目步骤"></a>建立项目步骤</h1><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>在主目录下（com.example.std.java.demo）下建立Controller包，在controller下建立与表对应的controller</p><pre><code>package com.example.std.java.demo.controller;import com.example.std.java.demo.dto.request.*;import com.example.std.java.demo.dto.response.MerchantResponseDTO;import com.example.std.java.demo.entity.TblMerchantEntity;import com.example.std.java.demo.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;/** @Description: 商户接口* @Author:yiye.li* @Date:2019-07-28*/@RestController@RequestMapping(&quot;/Merchant&quot;)public class MerchantController extends BaseController{@AutowiredUserService userService;/* *商户接口 * 1。注册商户 * http://localhost:8080//Merchant/CreateMerchant Postman中Get内容，其余内容可以在Params中填写 * 使用@RequestBody格式则需在GET中的Body-》raw中以JSON串格式填写(注意在最右面的一栏中选择JSON(application/json)) * @param MerchantRequestDTO * @return */@GetMapping(&quot;/CreateMerchant&quot;)public MerchantResponseDTO CreateMerchant(@RequestBody CreateMerchantRequestDTO createMerchantRequestDTO){    TblMerchantEntity tblMerchantEntity=new TblMerchantEntity();    tblMerchantEntity.setMerchantName(createMerchantRequestDTO.getMerchantName());    tblMerchantEntity.setContactName(createMerchantRequestDTO.getContactName());    tblMerchantEntity.setPlatformKey(createMerchantRequestDTO.getPlatformKey());    tblMerchantEntity.setShortName(createMerchantRequestDTO.getShortName());    MerchantResponseDTO merchantResponseDTO;    merchantResponseDTO=userService.MybatisCreateMerchant(tblMerchantEntity);    return merchantResponseDTO;}/* *商户接口 * 2。根据商编查询商户 * http://localhost:8080//Merchant/SelectByMerchantNo Postman中Get内容，其余内容可以在Params中填写 * @param MerchantRequestDTO * @return */@GetMapping(&quot;/SelectByMerchantNo&quot;)public MerchantResponseDTO SelectByMerchantNo(@RequestBody SelectByMerchantNoRequestDTO selectByMerchantNoRequestDTO){    TblMerchantEntity tblMerchantEntity=new TblMerchantEntity();    tblMerchantEntity.setMerchantNo(selectByMerchantNoRequestDTO.getMerchantNo());    MerchantResponseDTO merchantResponseDTO;    merchantResponseDTO=userService.MybatisSelectByMerchantNo(tblMerchantEntity);    return merchantResponseDTO;}/* *商户接口 * 3。修改商户状态 * http://localhost:8080//Merchant/UpdateMerchantStatus Postman中Get内容，其余内容可以在Params中填写 * @param MerchantRequestDTO * @return */@GetMapping(&quot;/UpdateMerchantStatus&quot;)public MerchantResponseDTO UpdateMerchantStatus(@RequestBody UpdateMerchantRequestDTO updateMerchantRequestDTO){    TblMerchantEntity tblMerchantEntity=new TblMerchantEntity();    tblMerchantEntity.setId(updateMerchantRequestDTO.getId());    MerchantResponseDTO merchantResponseDTO;    merchantResponseDTO=userService.MybatisUpdateMerchantStatus(tblMerchantEntity);    return merchantResponseDTO;}/* *商户接口 * 4。从外部能够查询商户(根据ID查询商户) * http://localhost:8080//Merchant/MerchantQuery Postman中Get内容，其余内容可以在Params中的KEY和VALUE填写 * @param MerchantRequestDTO * @return */@GetMapping(&quot;/MerchantQuery&quot;)public MerchantResponseDTO MerchantQuery(@RequestBody SelectByIDMerchantRequestDTO selectByIDMerchantRequestDTO){    TblMerchantEntity tblMerchantEntity=new TblMerchantEntity();    tblMerchantEntity.setId(selectByIDMerchantRequestDTO.getId());    MerchantResponseDTO merchantResponseDTO;    merchantResponseDTO=userService.MybatisSpringQuery(tblMerchantEntity);    return merchantResponseDTO;}/*    //4。从外部能够查询商户(根据ID查询商户)//http://localhost:8080//Merchant/MerchantQuery Postman中Get内容，其余内容可以在Params中的KEY和VALUE填写@GetMapping(&quot;/MerchantQuery&quot;)public MerchantResponseDTO MerchantQuery(@RequestParam(&quot;merchantName&quot;) String merchantName,                                    @RequestParam(&quot;contactName&quot;) String contactName,                                    @RequestParam(&quot;contactPhone&quot;)  String contactPhone,                                    @RequestParam(&quot;platformKey&quot;) String platformKey,                                    @RequestParam(&quot;shortName&quot;) String shortName){    MerchantResponseDTO merchantResponseDTO=new MerchantResponseDTO();    merchantResponseDTO=userService.MybatisSpringQuery(40L);    return merchantResponseDTO;}*/}</code></pre><h2 id="DTO"><a href="#DTO" class="headerlink" title="DTO"></a>DTO</h2><h3 id="RequestDTO"><a href="#RequestDTO" class="headerlink" title="RequestDTO"></a>RequestDTO</h3><p>在主目录下建立dto包，再分别建立子目录request和response，request下建立相应的requestDTO文件，每个文件中对应着HTTP请求中相应的参数，而response下建立相应的responseDTO文件，其中对应着要返回的参数</p><p>如SelectByIDMerchantRequestDTO.class</p><pre><code>package com.example.std.java.demo.dto.request;import java.io.Serializable;import lombok.Data;/*** @Description: 商户dto* @Author: yiye.li* @Date: 2019-07-29 10:45*/@Datapublic class SelectByIDMerchantRequestDTO {  /**   * 商户ID   */  private Long id;}</code></pre><p>再如CreateMerchantRequestDTO.class文件</p><pre><code>package com.example.std.java.demo.dto.request;import java.io.Serializable;import lombok.Data;/** * @Description: 商户dto * @Author: yiye.li * @Date: 2019-07-29 10:45 */@Datapublic class CreateMerchantRequestDTO {    /**     * 商户名称     */    private String merchantName;    /**     * 联系人姓名     */    private String contactName;    /**     * 联系电话     */    private String contactPhone;    /**     * 平台钥匙     */    private String platformKey;    /**     * 简称     */    private String shortName;}</code></pre><h3 id="ReponseDTO"><a href="#ReponseDTO" class="headerlink" title="ReponseDTO"></a>ReponseDTO</h3><p>ReponseDTO中写相应的返回参数，例如：</p><pre><code>package com.example.std.java.demo.dto.response;import lombok.Data;import java.util.Date;/** * @Description: 商户返回dto * @Author: yiye.li * @Date: 2019-07-29 10:45 */@Datapublic class MerchantResponseDTO {    //可以自选返回什么    /**     * ID     */    private long ID;    /**     * CREATE_TIME     */    private Date createTime;    /**     * 上次更新时间     */    private Date lastUpdateTime;    /**     * 商户编号     */    private String merchantNo;    /**     * 商户名称     */    private String merchantName;    /**     * 联系人姓名     */    private String contactName;    /**     * 联系电话     */    private String contactPhone;    /**     * 平台钥匙     */    private String platformKey;    /**     * 商户状态     */    private String status;    /**     * 简称     */    private String shortName;    /**     * 组     */    private String checkGroup;}</code></pre><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>在主目录下建立Service包，其中建立Service文件中声明方法名和参数，再建立impl包，其中的ServiceImpl文件来实现对HTTP请求相应的处理方法</p><p>UserService.class文件</p><pre><code>package com.example.std.java.demo.service;import com.example.std.java.demo.dto.response.MerchantResponseDTO;import com.example.std.java.demo.entity.TblMerchantEntity;public interface UserService {    String test();    /**     * 创建商户     * @param tblMerchantEntity     * @return     */    MerchantResponseDTO MybatisCreateMerchant(TblMerchantEntity tblMerchantEntity);    /**     * 根据商编查询商户     * @param tblMerchantEntity     * @return     */    MerchantResponseDTO MybatisSelectByMerchantNo(TblMerchantEntity tblMerchantEntity);    /**     *     * @param tblMerchantEntity     * @return     */    MerchantResponseDTO MybatisUpdateMerchantStatus(TblMerchantEntity tblMerchantEntity);    /**     *     * @param tblMerchantEntity     * @return     */    MerchantResponseDTO MybatisSpringQuery(TblMerchantEntity tblMerchantEntity);}</code></pre><p>而impl文件中的UserServiceImpl.class文件如下：</p><pre><code>package com.example.std.java.demo.service.impl;import com.alibaba.fastjson.JSON;import com.example.std.java.demo.dao.TblMerchantEntityMapper;import com.example.std.java.demo.dto.response.MerchantResponseDTO;import com.example.std.java.demo.entity.TblMerchantEntity;import com.example.std.java.demo.entity.TblMerchantEntityExample;import com.example.std.java.demo.service.UserService;import lombok.extern.apachecommons.CommonsLog;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.util.CollectionUtils;import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.List;import java.util.Random;@Servicepublic class UserServiceImpl implements UserService {    private static final Logger logger= LoggerFactory.getLogger(UserServiceImpl.class);    //要加一些事务处理    //@Transcational (rollback=...    @Override    public String test() {        return null;    }    @Autowired    private TblMerchantEntityMapper tblMerchantEntityMapper;//create duplicate problem to solve    @Override    public MerchantResponseDTO MybatisCreateMerchant(TblMerchantEntity RequesttblMerchantEntity){        MerchantResponseDTO merchantResponseDTO=new MerchantResponseDTO();        TblMerchantEntity tblMerchantEntity=new TblMerchantEntity();        //生成随机数        Random random=new Random();        int nextInt=random.nextInt(100000);        long IDnum=nextInt;        if(tblMerchantEntityMapper.selectByPrimaryKey(IDnum)==null) {            tblMerchantEntity.setId(IDnum);            try{                DateFormat format=new SimpleDateFormat(&quot;yyyyMMddHHmmss&quot;);                Date date =format.parse(System.currentTimeMillis()+&quot;&quot;);                Date dateend =format.parse(System.currentTimeMillis()+24+&quot;&quot;);                tblMerchantEntity.setCreateTime(date);                tblMerchantEntity.setLastUpdateTime(dateend);            }catch(ParseException e){                e.printStackTrace();            }            tblMerchantEntity.setMerchantNo(&quot;&quot;+nextInt);            //set the new data from the requestDTO            tblMerchantEntity.setMerchantName(RequesttblMerchantEntity.getMerchantName());            tblMerchantEntity.setContactName(RequesttblMerchantEntity.getContactName());            tblMerchantEntity.setContactPhone(RequesttblMerchantEntity.getContactPhone());            tblMerchantEntity.setPlatformKey(RequesttblMerchantEntity.getPlatformKey());            tblMerchantEntity.setShortName(RequesttblMerchantEntity.getShortName());            tblMerchantEntity.setStatus(&quot;1&quot;);            tblMerchantEntity.setCheckGroup(&quot;集贸市场&quot;);            tblMerchantEntityMapper.insert(tblMerchantEntity);            merchantResponseDTO.setID(tblMerchantEntity.getId());            merchantResponseDTO.setCreateTime(tblMerchantEntity.getCreateTime());            merchantResponseDTO.setLastUpdateTime(tblMerchantEntity.getLastUpdateTime());            merchantResponseDTO.setMerchantNo(tblMerchantEntity.getMerchantNo());            merchantResponseDTO.setMerchantName(tblMerchantEntity.getMerchantName());            merchantResponseDTO.setContactName(tblMerchantEntity.getContactName());            merchantResponseDTO.setContactPhone(tblMerchantEntity.getContactPhone());            merchantResponseDTO.setPlatformKey(tblMerchantEntity.getPlatformKey());            merchantResponseDTO.setStatus(tblMerchantEntity.getStatus());            merchantResponseDTO.setShortName(tblMerchantEntity.getShortName());            merchantResponseDTO.setCheckGroup(tblMerchantEntity.getCheckGroup());            //将entity中的属性set到merchantResponseDTO中去            System.out.println(&quot;*********Create by ID=&quot;+IDnum+&quot;************&quot;);        }else{            System.out.println(&quot;*********Create The Record Failed, The record has already existed*************&quot;);            tblMerchantEntity=tblMerchantEntityMapper.selectByPrimaryKey(IDnum);            merchantResponseDTO.setID(tblMerchantEntity.getId());            merchantResponseDTO.setCreateTime(tblMerchantEntity.getCreateTime());            merchantResponseDTO.setLastUpdateTime(tblMerchantEntity.getLastUpdateTime());            merchantResponseDTO.setMerchantNo(tblMerchantEntity.getMerchantNo());            merchantResponseDTO.setMerchantName(tblMerchantEntity.getMerchantName());            merchantResponseDTO.setContactName(tblMerchantEntity.getContactName());            merchantResponseDTO.setContactPhone(tblMerchantEntity.getContactPhone());            merchantResponseDTO.setPlatformKey(tblMerchantEntity.getPlatformKey());            merchantResponseDTO.setStatus(tblMerchantEntity.getStatus());            merchantResponseDTO.setShortName(tblMerchantEntity.getShortName());            merchantResponseDTO.setCheckGroup(tblMerchantEntity.getCheckGroup());        }        return merchantResponseDTO;    }    @Override    public MerchantResponseDTO MybatisSelectByMerchantNo(TblMerchantEntity RequesttblMerchantEntity){        MerchantResponseDTO merchantResponseDTO= null;        try {            merchantResponseDTO = new MerchantResponseDTO();            if(logger.isDebugEnabled()){                //debug 级别的日志                logger.debug(&quot;&quot;);            }            logger.info(&quot;query merchant info by merchantN={}&quot;,RequesttblMerchantEntity);            //1。构建商户实体            TblMerchantEntity tblMerchantEntity=new TblMerchantEntity();            TblMerchantEntityExample tblMerchantEntityExample=new TblMerchantEntityExample();            TblMerchantEntityExample.Criteria criteria=tblMerchantEntityExample.createCriteria();            criteria.andMerchantNoEqualTo(RequesttblMerchantEntity.getMerchantNo());            // 2。从数据库查询商户信息            List&lt;TblMerchantEntity&gt; tblMerchantEntities = tblMerchantEntityMapper.selectByExample(tblMerchantEntityExample);            // 判断如果查询的商户信息为空则抛出异常            if(CollectionUtils.isEmpty(tblMerchantEntities)){                throw new RuntimeException(&quot;merchant is null&quot;);            }else{                //如果查询的商户有重复则在日志中写入warn                if(tblMerchantEntities.size()&gt;1) {                    logger.warn(&quot;query merchant size ={}&quot;, tblMerchantEntities.size());                }                //获取第一个商户的信息                tblMerchantEntity=tblMerchantEntities.get(0);            }            //3。将entity中的属性set到merchantResponseDTO中去            merchantResponseDTO.setID(tblMerchantEntity.getId());            merchantResponseDTO.setCreateTime(tblMerchantEntity.getCreateTime());            merchantResponseDTO.setLastUpdateTime(tblMerchantEntity.getLastUpdateTime());            merchantResponseDTO.setMerchantNo(tblMerchantEntity.getMerchantNo());            merchantResponseDTO.setMerchantName(tblMerchantEntity.getMerchantName());            merchantResponseDTO.setContactName(tblMerchantEntity.getContactName());            merchantResponseDTO.setContactPhone(tblMerchantEntity.getContactPhone());            merchantResponseDTO.setPlatformKey(tblMerchantEntity.getPlatformKey());            merchantResponseDTO.setStatus(tblMerchantEntity.getStatus());            merchantResponseDTO.setShortName(tblMerchantEntity.getShortName());            merchantResponseDTO.setCheckGroup(tblMerchantEntity.getCheckGroup());            System.out.println(&quot;*********Select by MerchantNo=&quot;+tblMerchantEntity.getMerchantNo()+&quot;************&quot;);            System.out.println(JSON.toJSONString(tblMerchantEntity));        } catch (RuntimeException e) {            logger.error(&quot;system error &quot;,e);            throw e;        }        return merchantResponseDTO;    }    @Override    public MerchantResponseDTO MybatisUpdateMerchantStatus(TblMerchantEntity RequesttblMerchantEntity){        //制定要更新的ID        long IDnum=RequesttblMerchantEntity.getId();        TblMerchantEntity tblMerchantEntity=tblMerchantEntityMapper.selectByPrimaryKey(IDnum);        MerchantResponseDTO merchantResponseDTO=new MerchantResponseDTO();        TblMerchantEntityExample tblMerchantEntityExample=new TblMerchantEntityExample();        TblMerchantEntityExample.Criteria criteria=tblMerchantEntityExample.createCriteria();        criteria.andIdEqualTo(tblMerchantEntity.getId());        tblMerchantEntity.setStatus(&quot;1&quot;);        //set the new data from the requestDTO        tblMerchantEntityMapper.updateByExample(tblMerchantEntity,tblMerchantEntityExample);        merchantResponseDTO.setID(tblMerchantEntity.getId());        merchantResponseDTO.setCreateTime(tblMerchantEntity.getCreateTime());        merchantResponseDTO.setLastUpdateTime(tblMerchantEntity.getLastUpdateTime());        merchantResponseDTO.setMerchantNo(tblMerchantEntity.getMerchantNo());        merchantResponseDTO.setMerchantName(tblMerchantEntity.getMerchantName());        merchantResponseDTO.setContactName(tblMerchantEntity.getContactName());        merchantResponseDTO.setContactPhone(tblMerchantEntity.getContactPhone());        merchantResponseDTO.setPlatformKey(tblMerchantEntity.getPlatformKey());        merchantResponseDTO.setStatus(tblMerchantEntity.getStatus());        merchantResponseDTO.setShortName(tblMerchantEntity.getShortName());        merchantResponseDTO.setCheckGroup(tblMerchantEntity.getCheckGroup());        System.out.println(&quot;*********Update by ID=&quot;+tblMerchantEntity.getId()+&quot;************&quot;);        System.out.println(JSON.toJSONString(tblMerchantEntity));        return merchantResponseDTO;    }    @Override    public MerchantResponseDTO MybatisSpringQuery(TblMerchantEntity RequesttblMerchantEntity){        //1。获取对应信息        long IDnum=RequesttblMerchantEntity.getId();        MerchantResponseDTO merchantResponseDTO=new MerchantResponseDTO();        //2。先从缓存中尝试获取数据        //3。缓存无，从db中获取数据        //注意是mybatis中自动生成的TblMerchantEntity而不是JPA中生成的实体TblMerchant        TblMerchantEntity tblMerchantEntity=tblMerchantEntityMapper.selectByPrimaryKey(IDnum);        //制定要更新的ID        System.out.println(&quot;*********Query by ID=&quot;+IDnum+&quot;************&quot;);        merchantResponseDTO.setID(tblMerchantEntity.getId());        merchantResponseDTO.setCreateTime(tblMerchantEntity.getCreateTime());        merchantResponseDTO.setLastUpdateTime(tblMerchantEntity.getLastUpdateTime());        merchantResponseDTO.setMerchantNo(tblMerchantEntity.getMerchantNo());        //将Get请求中的信息set到ReponseDTO中去        merchantResponseDTO.setMerchantName(tblMerchantEntity.getMerchantName());        merchantResponseDTO.setContactName(tblMerchantEntity.getContactName());        merchantResponseDTO.setContactPhone(tblMerchantEntity.getContactPhone());        merchantResponseDTO.setPlatformKey(tblMerchantEntity.getPlatformKey());        merchantResponseDTO.setStatus(tblMerchantEntity.getStatus());        //        merchantResponseDTO.setShortName(tblMerchantEntity.getShortName());        merchantResponseDTO.setCheckGroup(tblMerchantEntity.getCheckGroup());        //4。返回结果        //将entity中的属性set到merchantResponseDTO中去        return merchantResponseDTO;    }}</code></pre><p>其中的文件目录树如下：</p><p><img src="assets/markdown-img-paste-20190731101545612.png" alt=""></p><h1 id="PostMan使用"><a href="#PostMan使用" class="headerlink" title="PostMan使用"></a>PostMan使用</h1><p>PostMan软件可用于调试HTTP接口，具体使用方法不再赘述<br>只说需要注意的几点：</p><h2 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h2><p>当controller中当方法参数为@RequestParam形式时</p><pre><code>//4。从外部能够查询商户(根据ID查询商户)//http://localhost:8080//Merchant/MerchantQuery Postman中Get内容，其余内容可以在Params中的KEY和VALUE填写@GetMapping(&quot;/MerchantQuery&quot;)public MerchantResponseDTO MerchantQuery(@RequestParam(&quot;merchantName&quot;) String merchantName,                                    @RequestParam(&quot;contactName&quot;) String contactName,                                    @RequestParam(&quot;contactPhone&quot;)  String contactPhone,                                    @RequestParam(&quot;platformKey&quot;) String platformKey,                                    @RequestParam(&quot;shortName&quot;) String shortName){    MerchantResponseDTO merchantResponseDTO=new MerchantResponseDTO();    merchantResponseDTO=userService.MybatisSpringQuery(40L);    return merchantResponseDTO;}</code></pre><p>Postman中选择POST格式发送，<a href="http://localhost:8080/Merchant/MerchantQuery" target="_blank" rel="noopener">http://localhost:8080/Merchant/MerchantQuery</a><br>然后在Params中填入KEY和VALUE，即可发送对应当POST请求。</p><h2 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h2><p>如果controller中的方法参数为@RequestBody形式时:</p><pre><code>/**商户接口* 4。从外部能够查询商户(根据ID查询商户)* http://localhost:8080//Merchant/MerchantQuery Postman中Get内容，其余内容可以在Params中的KEY和VALUE填写* @param MerchantRequestDTO* @return*/@GetMapping(&quot;/MerchantQuery&quot;)public MerchantResponseDTO MerchantQuery(@RequestBody SelectByIDMerchantRequestDTO selectByIDMerchantRequestDTO){  TblMerchantEntity tblMerchantEntity=new TblMerchantEntity();  tblMerchantEntity.setId(selectByIDMerchantRequestDTO.getId());  MerchantResponseDTO merchantResponseDTO;  merchantResponseDTO=userService.MybatisSpringQuery(tblMerchantEntity);  return merchantResponseDTO;}</code></pre><p>则选择Body-》raw形式，然后在右侧的栏中选择JSON(application/json)<br>以JSON格式填写POST中的Body：</p><pre><code>{    &quot;ID&quot;: &quot;47943&quot;}</code></pre><h1 id="浏览器测试"><a href="#浏览器测试" class="headerlink" title="浏览器测试"></a>浏览器测试</h1><p>除了用Postman进行测试外，也可以直接在浏览器中输入GET请求进行测试，在网址栏输入<a href="http://localhost:8080//Merchant/MerchantQuery发送即可" target="_blank" rel="noopener">http://localhost:8080//Merchant/MerchantQuery发送即可</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单总结SpringMVC整合Mybatis，从Get/Request请求中实现对数据库的增删改查，对应着SpringBoot学习笔记II中的Mybatis任务中的第二项。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年7月" scheme="http://yoursite.com/categories/2019%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot学习笔记V</title>
    <link href="http://yoursite.com/2019/07/30/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0V/"/>
    <id>http://yoursite.com/2019/07/30/SpringBoot学习笔记V/</id>
    <published>2019-07-30T08:28:12.000Z</published>
    <updated>2019-07-31T02:40:06.154Z</updated>
    
    <content type="html"><![CDATA[<p>介绍了SpringMVC的基本概念和HTTP中Get与POST的区别。</p><a id="more"></a><h1 id="原理详解"><a href="#原理详解" class="headerlink" title="原理详解"></a>原理详解</h1><h2 id="SpringMVC是什么"><a href="#SpringMVC是什么" class="headerlink" title="SpringMVC是什么"></a>SpringMVC是什么</h2><p>早期 Java Web 的开发中，统一把显示层、控制层、数据层的操作全部交给 JSP 或者 JavaBean 来进行处理，我们称之为 Model1：<br><img src="assets/markdown-img-paste-20190730171141304.png" alt="https://upload-images.jianshu.io/upload_images/7896890-7b3f9cd59394b017.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/963"></p><p>出现的弊端：</p><p>1.JSP 和 Java Bean 之间严重耦合，Java 代码和 HTML 代码也耦合在了一起</p><p>2.要求开发者不仅要掌握 Java ，还要有高超的前端水平</p><p>3.前端和后端相互依赖，前端需要等待后端完成，后端也依赖前端完成，才能进行有效的测试</p><p>4.代码难以复用</p><p>正因为上面的种种弊端，所以很快这种方式就被 Servlet + JSP + Java Bean 所替代了，早期的 MVC 模型（Model2）就像下图这样：<br><img src="assets/markdown-img-paste-20190730171449446.png" alt="https://upload-images.jianshu.io/upload_images/7896890-403a273b08fec826.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/985"></p><p>首先用户的请求会到达 Servlet，然后根据请求调用相应的 Java Bean，并把所有的显示结果交给 JSP 去完成，这样的模式我们就称为 MVC 模式。</p><p>M 代表 模型（Model）<br>模型是什么呢？ 模型就是数据，就是 dao,bean</p><p>V 代表 视图（View）<br>视图是什么呢？ 就是网页, JSP，用来展示模型中的数据</p><p>C 代表 控制器（controller)<br>控制器是什么？ 控制器的作用就是把不同的数据(Model)，显示在不同的视图(View)上，Servlet 扮演的就是这样的角色。</p><h3 id="Spring-MVC-的架构"><a href="#Spring-MVC-的架构" class="headerlink" title="Spring MVC 的架构"></a>Spring MVC 的架构</h3><p>为解决持久层中一直未处理好的数据库事务的编程，又为了迎合 NoSQL 的强势崛起，Spring MVC 给出了方案</p><p><img src="assets/markdown-img-paste-20190730171743535.png" alt="https://upload-images.jianshu.io/upload_images/7896890-a25782fb05f315de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000"></p><p>传统的模型层被拆分为了业务层(Service)和数据访问层（DAO,Data Access Object）。 在 Service 下可以通过 Spring 的声明式事务操作数据访问层，而在业务层上还允许我们访问 NoSQL ，这样就能够满足异军突起的 NoSQL 的使用了，它可以大大提高互联网系统的性能。</p><p>特点：</p><p>1.结构松散，几乎可以在 Spring MVC 中使用各类视图</p><p>2.松耦合，各个模块分离</p><p>3.与 Spring 无缝集成</p><h2 id="HTTP中Get与POST的区别"><a href="#HTTP中Get与POST的区别" class="headerlink" title="HTTP中Get与POST的区别"></a>HTTP中Get与POST的区别</h2><p>Get和Post是两种Http请求方式：</p><p><strong><em>GET-从指定的资源请求数据</em></strong></p><p><strong><em>POST-向指定的资源提交要被处理的数据</em></strong></p><h3 id="GET方法"><a href="#GET方法" class="headerlink" title="GET方法"></a>GET方法</h3><p>查询字符串（名称/值对）是在GET请求的URL中发送的：</p><pre><code>http://localhost:8080/Merchant/SelectByMerchantNo?name1=value1&amp;name2=value2</code></pre><p>GET 请求可被缓存</p><p>GET 请求保留在浏览器历史记录中</p><p>GET 请求可被收藏为书签</p><p>GET 请求不应在处理敏感数据时使用</p><p>GET 请求有长度限制</p><p>GET 请求只应当用于取回数据</p><h3 id="POST方法"><a href="#POST方法" class="headerlink" title="POST方法"></a>POST方法</h3><p>查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的：</p><pre><code>POST /test/demo_form.asp HTTP/1.1Host: w3schools.comname1=value1&amp;name2=value2</code></pre><p>POST 请求不会被缓存</p><p>POST 请求不会保留在浏览器历史记录中</p><p>POST 不能被收藏为书签</p><p>POST 请求对数据长度没有要求</p><table><thead><tr><th></th><th>Get</th><th>POST</th></tr></thead><tbody><tr><td>后退按钮/刷新</td><td>无害</td><td>数据会被重新提交（浏览器应该告知用户数据会被重新提交</td></tr><tr><td>书签</td><td>可收藏为书签</td><td>不可收藏为书签</td></tr><tr><td>缓存</td><td>能被缓存</td><td>不能缓存</td></tr><tr><td>编码类型</td><td>application/x-www-form-urlencoded</td><td>application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。</td></tr><tr><td>历史</td><td>参数保留在浏览器历史中</td><td>参数不会保留在浏览器历史中</td></tr><tr><td>对数据长度的限制</td><td>只允许ASCII字符</td><td>没有限制，也允许二进制数据</td></tr><tr><td>安全性</td><td>较差，因为发送的数据是URL的一部分</td><td>POST比GET更安全，因为参数不会被保留在浏览器历史或WEB服务器日志中</td></tr><tr><td>可见性</td><td>数据在URL中对所有人都是可见的</td><td>数据不会显示在URL在中</td></tr></tbody></table><p>其它HTTP请求方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>HEAD</td><td>与GET相同，但只返回HTTP报头，不返回文档主体</td></tr><tr><td>PUT</td><td>上传指定但URI表示</td></tr><tr><td>DELETE</td><td>删除指定资源</td></tr><tr><td>OPTIONS</td><td>返回服务器支持但HTTP方法</td></tr><tr><td>CONNECT</td><td>把请求连接转换到透明的TCP/IP通道</td></tr></tbody></table><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>【1】<a href="https://www.jianshu.com/p/91a2d0a1e45a" target="_blank" rel="noopener">https://www.jianshu.com/p/91a2d0a1e45a</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍了SpringMVC的基本概念和HTTP中Get与POST的区别。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年7月" scheme="http://yoursite.com/categories/2019%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot学习笔记IV</title>
    <link href="http://yoursite.com/2019/07/26/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0IV/"/>
    <id>http://yoursite.com/2019/07/26/SpringBoot学习笔记IV/</id>
    <published>2019-07-26T10:30:12.000Z</published>
    <updated>2019-07-30T08:32:30.968Z</updated>
    
    <content type="html"><![CDATA[<p>简单总结Java工程师的学习路径，之后还会详细介绍，总结了最近用到的一些知识和注意事项如定时组件，注释，日志，注解等。</p><a id="more"></a><h1 id="中级Java工程师（十年学习计划）"><a href="#中级Java工程师（十年学习计划）" class="headerlink" title="中级Java工程师（十年学习计划）"></a>中级Java工程师（十年学习计划）</h1><p>JVM调优，class如何编译生成<br>分布式事务<br>分布式组件/工具zoomkeeper<br>缓存的使用（redis）<br>分库分表<br>微服务，看SpringCloud源码<br>并发编程<br>Spring源码（建议看两到三遍）</p><h1 id="最近半年学习方向（两个方向）："><a href="#最近半年学习方向（两个方向）：" class="headerlink" title="最近半年学习方向（两个方向）："></a>最近半年学习方向（两个方向）：</h1><p>1.Spring源码，例如bean初始化<br>2.AQS</p><h1 id="今日学习任务"><a href="#今日学习任务" class="headerlink" title="今日学习任务"></a>今日学习任务</h1><h2 id="定时组件学习"><a href="#定时组件学习" class="headerlink" title="定时组件学习"></a>定时组件学习</h2><h2 id="注释写法"><a href="#注释写法" class="headerlink" title="注释写法"></a>注释写法</h2><p>从Controller到DTO再到Service，每个类中的函数都要有注释，包括功能，参数，返回值，格式如下：<br>Service中的例子：</p><pre><code>/** * 创建商户 * @param tblMerchantEntity * @return */</code></pre><p>DTO中的例子：</p><pre><code>/*** @Description: 商户dto* @Author: yiye.li* @Date: 2019-07-29 10:45*/</code></pre><p><strong><em>注释写法，可以先按照步骤写出注释，然后再相应等填充代码</em></strong></p><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>（日志级别分为info，debug，warning，error等），可用于debug。<br>例程：</p><pre><code>@Overridepublic MerchantResponseDTO MybatisSelectByMerchantNo(TblMerchantEntity RequesttblMerchantEntity){    MerchantResponseDTO merchantResponseDTO= null;    try {        merchantResponseDTO = new MerchantResponseDTO();        if(logger.isDebugEnabled()){            //debug 级别的日志            logger.debug(&quot;&quot;);        }        logger.info(&quot;query merchant info by merchantN={}&quot;,RequesttblMerchantEntity);        //1。构建商户实体        TblMerchantEntity tblMerchantEntity=new TblMerchantEntity();        TblMerchantEntityExample tblMerchantEntityExample=new TblMerchantEntityExample();        TblMerchantEntityExample.Criteria criteria=tblMerchantEntityExample.createCriteria();        criteria.andMerchantNoEqualTo(RequesttblMerchantEntity.getMerchantNo());        // 2。从数据库查询商户信息        List&lt;TblMerchantEntity&gt; tblMerchantEntities = tblMerchantEntityMapper.selectByExample(tblMerchantEntityExample);        // 判断如果查询的商户信息为空则抛出异常        if(CollectionUtils.isEmpty(tblMerchantEntities)){            throw new RuntimeException(&quot;merchant is null&quot;);        }else{            //如果查询的商户有重复则在日志中写入warn            if(tblMerchantEntities.size()&gt;1) {                logger.warn(&quot;query merchant size ={}&quot;, tblMerchantEntities.size());            }            //获取第一个商户的信息            tblMerchantEntity=tblMerchantEntities.get(0);        }        //3。将entity中的属性set到merchantResponseDTO中去        merchantResponseDTO.setID(tblMerchantEntity.getId());        merchantResponseDTO.setCreateTime(tblMerchantEntity.getCreateTime());        merchantResponseDTO.setLastUpdateTime(tblMerchantEntity.getLastUpdateTime());        merchantResponseDTO.setMerchantNo(tblMerchantEntity.getMerchantNo());        merchantResponseDTO.setMerchantName(tblMerchantEntity.getMerchantName());        merchantResponseDTO.setContactName(tblMerchantEntity.getContactName());        merchantResponseDTO.setContactPhone(tblMerchantEntity.getContactPhone());        merchantResponseDTO.setPlatformKey(tblMerchantEntity.getPlatformKey());        merchantResponseDTO.setStatus(tblMerchantEntity.getStatus());        merchantResponseDTO.setShortName(tblMerchantEntity.getShortName());        merchantResponseDTO.setCheckGroup(tblMerchantEntity.getCheckGroup());        System.out.println(&quot;*********Select by MerchantNo=&quot;+tblMerchantEntity.getMerchantNo()+&quot;************&quot;);        System.out.println(JSON.toJSONString(tblMerchantEntity));    } catch (RuntimeException e) {        logger.error(&quot;system error &quot;,e);        throw e;    }    return merchantResponseDTO;}</code></pre><p>日志技巧.var</p><h2 id="实现SpringBoot热部署"><a href="#实现SpringBoot热部署" class="headerlink" title="实现SpringBoot热部署"></a>实现SpringBoot热部署</h2><h2 id="SpringBoot注解学习"><a href="#SpringBoot注解学习" class="headerlink" title="SpringBoot注解学习"></a>SpringBoot注解学习</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单总结Java工程师的学习路径，之后还会详细介绍，总结了最近用到的一些知识和注意事项如定时组件，注释，日志，注解等。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年7月" scheme="http://yoursite.com/categories/2019%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot学习笔记III</title>
    <link href="http://yoursite.com/2019/07/25/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0III/"/>
    <id>http://yoursite.com/2019/07/25/SpringBoot学习笔记III/</id>
    <published>2019-07-25T01:36:12.000Z</published>
    <updated>2019-08-23T08:29:30.134Z</updated>
    
    <content type="html"><![CDATA[<p>阐述Spring，Spring MVC，Spring Boot 三者的原理和区别。学习笔记II中涉及到对@Resource和@Autowired的区别做了解释。<br>对用命令查询网络端口占用情况，查找/杀死进程做了回顾性的复习。</p><a id="more"></a><h1 id="三省吾身："><a href="#三省吾身：" class="headerlink" title="三省吾身："></a>三省吾身：</h1><h2 id="什么是Spring？它解决了什么问题？"><a href="#什么是Spring？它解决了什么问题？" class="headerlink" title="什么是Spring？它解决了什么问题？"></a>什么是Spring？它解决了什么问题？</h2><p>Spring是一个开源的轻量级Java SE（Java 标准版本）/Java EE（Java 企业版本）开发应用框架，其目的是用于简化企业级应用程序开发。应用程序是由一组相互协作的对象组成。而在传统应用程序开发中，一个完整的应用是由一组相互协作的对象组成。所以开发一个应用除了要开发业务逻辑之外，最多的是关注如何使这些对象协作来完成所需功能，而且要低耦合、高内聚。业务逻辑开发是不可避免的，那如果有个框架出来帮我们来创建对象及管理这些对象之间的依赖关系。可能有人说了，比如“抽象工厂、工厂方法设计模式”不也可以帮我们创建对象，“生成器模式”帮我们处理对象间的依赖关系，不也能完成这些功能吗？可是这些又需要我们创建另一些工厂类、生成器类，我们又要而外管理这些类，增加了我们的负担，如果能有种通过配置方式来创建对象，管理对象之间依赖关系，我们不需要通过工厂和生成器来创建及管理对象之间的依赖关系，这样我们是不是减少了许多工作，加速了开发，能节省出很多时间来干其他事。Spring框架刚出来时主要就是来完成这个功能。</p><p>Spring框架除了帮我们<strong><em>管理对象及其依赖关系</em></strong>，还提供像通用日志记录、性能统计、安全控制、异常处理等面向切面的能力，还能帮我管理最头疼的数据库事务，本身提供了一套简单的JDBC访问实现，提供与第三方数据访问框架集成（如Hibernate、JPA），与各种Java EE技术整合（如Java Mail、任务调度等等），提供一套自己的web层框架Spring MVC、而且还能非常简单的与第三方web框架集成。从这里我们可以认为Spring是一个超级粘合平台，除了自己提供功能外，还提供粘合其他技术和框架的能力，从而使我们可以更自由的选择到底使用什么技术进行开发。而且不管是JAVA SE（C/S架构）应用程序还是JAVA EE（B/S架构）应用程序都可以使用这个平台进行开发。</p><p>Spring，一般指代的是Spring Framework，它是一个开源的应用程序框架，提供了一个简易的开发方式，通过这种开发方式，将避免那些可能致使代码变得繁杂混乱的大量的业务/工具对象，说的更通俗一点就是由框架来帮你管理这些对象，包括它的创建，销毁等，比如基于Spring的项目里经常能看到的Bean，它代表的就是由Spring管辖的对象。<br>而在被管理对象与业务逻辑之间，Spring通过IOC（控制反转）架起使用的桥梁，IOC也可以看做Spring最核心最重要的思想，通过IOC能带来什么好处呢？首先来看一个实际开发中的典型应用场景，假设我们有一个基于MVC分层结构的应用，通过controller层对外提供接口，而通过service层提供具体的实现，在service层中有一个WelcomeService服务接口，一般情况下都是通过WelcomeService service = new WelcomeServiceImpl();创建实例并进行调用：</p><pre><code>public class WelcomeController {    private WelcomeService service = new WelcomeServiceImpl();    @RequestMapping(&quot;/welcome&quot;)    public String welcome() {    return service.retrieveWelcomeMessage();    }}</code></pre><p>调用后发现一切正常，此时，功能提交，需要进行测试，而由于实际应用环境与测试环境有所区别，需要替换WelcomeServiceImpl为一个MockWelcomeServiceImpl，以方便测试，怎么办？没有其他办法，只有改代码：</p><pre><code>public class WelcomeController {    private WelcomeService service = new MockWelcomeServiceImpl();    ...}测试OK后再将代码改回去，这种方式太过于繁琐，且对代码的侵入性很强；下面看通过Spring的IOC如何实现，首先将WelcomeService交由Spring管理：&lt;bean name=&quot;WelcomeService&quot; class=&quot;XXX.XXX.XXX.service.impl.WelcomeServiceImpl&quot;/&gt;</code></pre><p>然后在业务代码处通过Spring IOC拿到具体对象：</p><pre><code>public class WelcomeController {    @Autowired    private WelcomeService service;    @RequestMapping(&quot;/welcome&quot;)    public String welcome() {        return service.retrieveWelcomeMessage();    }}</code></pre><p>测试的时候，只需要更改配置文件，将WelcomeService对应的实现改为MockWelcomeServiceImpl即可：</p><pre><code>&lt;bean name=&quot;WelcomeService&quot; class=&quot;XXX.XXX.XXX.service.impl.MockWelcomeServiceImpl&quot;/&gt;</code></pre><p>这种方式对业务代码没有任何侵入，它有效的实现松耦合，大家都知道紧耦合的代码是业务发展的噩梦；同时，Spring IOC提供的远不止这些，如通过单例减少创建无用的对象，通过延迟加载优化初始化成本等<br>当然，Spring 的核心功能远不知这些，如：</p><pre><code>Spring AOPSpring JDBCSpring MVCSpring ORMSpring JMSSpring Test</code></pre><p>其实不通过Spring框架依然可以实现这些功能特定，但是Spring 提供了更优雅的抽象接口以方便对这些功能的组装，同时又给予每个具体实现以灵活的配置；另外，基于Spring，你可以方便的与其他框架进行集成，如hibernate，ibatis等，Spring官方的原则是绝不重复造轮子，有好的解决方案只需要通过Spring进行集成即可。纵览Spring的结构，你会发现Spring Framework 本身并未提供太多具体的功能，它主要专注于让你的项目代码组织更加优雅，使其具有极好的灵活性和扩展性，同时又能通过Spring集成业界优秀的解决方案，想了解Spring的核心实现机制可参考tiny spring 项目</p><h2 id="什么是Spring-MVC？它解决了什么问题？"><a href="#什么是Spring-MVC？它解决了什么问题？" class="headerlink" title="什么是Spring MVC？它解决了什么问题？"></a>什么是Spring MVC？它解决了什么问题？</h2><p>Spring MVC是Spring的一部分，Spring 出来以后，大家觉得很好用，于是按照这种模式设计了一个 MVC框架（一些用Spring 解耦的组件），主要用于开发WEB应用和网络接口，它是Spring的一个模块，通过Dispatcher Servlet, ModelAndView 和 View Resolver，让应用开发变得很容易，一个典型的Spring MVC应用开发分为下面几步：<br>首先通过配置文件声明Dispatcher Servlet：</p><pre><code>&lt;servlet&gt;    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;    &lt;servlet-class&gt;com.qgd.oms.web.common.mvc.OmsDispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;/WEB-INF/applicationContext.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><p>通过配置文件声明servlet详情，如MVC resource，data source，bean等</p><pre><code>&lt;mvc:resources mapping=&quot;/css/**/*&quot; location=&quot;/static/css/&quot; cache-period=&quot;21600&quot;/&gt;&lt;mvc:resources mapping=&quot;/js/**/*&quot; location=&quot;/static/js/&quot; cache-period=&quot;21600&quot;/&gt;&lt;mvc:resources mapping=&quot;/views/**/*.html&quot; location=&quot;/static/views/&quot; cache-period=&quot;21600&quot;/&gt;&lt;mvc:resources mapping=&quot;/fonts/**/*&quot; location=&quot;/static/fonts/&quot;/&gt;&lt;mvc:resources mapping=&quot;/ueditor/**/*&quot; location=&quot;/static/js/lib/ueditor/&quot;/&gt;&lt;mvc:resources mapping=&quot;/img/**/*&quot; location=&quot;/static/img/&quot;/&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp2.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;    &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot;/&gt;    &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;    &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt;    &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;    &lt;property name=&quot;validationQuery&quot; value=&quot;${jdbc.validationQuery}&quot;/&gt;    &lt;property name=&quot;maxTotal&quot; value=&quot;10&quot;/&gt;    &lt;property name=&quot;minIdle&quot; value=&quot;5&quot;/&gt;    &lt;property name=&quot;maxIdle&quot; value=&quot;10&quot;/&gt;    &lt;property name=&quot;defaultAutoCommit&quot; value=&quot;true&quot;/&gt;    &lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot;/&gt;    &lt;property name=&quot;testOnBorrow&quot; value=&quot;true&quot;/&gt;    &lt;property name=&quot;poolPreparedStatements&quot; value=&quot;true&quot;/&gt;    &lt;property name=&quot;maxOpenPreparedStatements&quot; value=&quot;50&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;configService&quot; class=&quot;com.qgd.oms.web.common.service.ConfigService&quot;&gt;    &lt;property name=&quot;configStore&quot;&gt;        &lt;bean class=&quot;com.qgd.oms.web.common.service.impl.DbConfigStore&quot;&gt;            &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;                &lt;property name=&quot;taskScheduler&quot; ref=&quot;defaultScheduler&quot;/&gt;            &lt;property name=&quot;refreshInterval&quot; value=&quot;30000&quot;/&gt;        &lt;/bean&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><p>若需添加其它功能，如security，则需添加对应配置：<br>    <http pattern="/css/**/*" security="none"><br>    <http pattern="/js/**/*" security="none"><br>    <http pattern="/views/**/*.html" security="none"><br>    <http pattern="/fonts/**/*" security="none"><br>    <http pattern="/ueditor/**/*" security="none"><br>    <http pattern="/img/**/*" security="none"></http></http></http></http></http></http></p><pre><code>&lt;http use-expressions=&quot;true&quot; entry-point-ref=&quot;omsAuthenticationEntryPoint&quot;&gt;    &lt;logout logout-url=&quot;/omsmc/authentication/logout/*&quot; success-handler-ref=&quot;omsLogoutSuccessHandler&quot;&gt;&lt;/logout&gt;    &lt;intercept-url pattern=&apos;/omsmc/authentication/login*&apos; access=&quot;permitAll&quot; /&gt;    &lt;intercept-url pattern=&apos;/ms/**/*&apos; access=&quot;permitAll&quot; /&gt;    &lt;intercept-url pattern=&apos;/**&apos; access=&quot;authenticated&quot; /&gt;    &lt;!--&lt;security:form-login /&gt;--&gt;    &lt;custom-filter ref=&quot;omsUsernamePasswordAuthenticationFilter&quot; position=&quot;FORM_LOGIN_FILTER&quot; /&gt;    &lt;remember-me services-ref=&quot;omsRememberMeServices&quot; key=&quot;yfboms&quot;/&gt;    &lt;csrf disabled=&quot;true&quot;/&gt;&lt;/http&gt;</code></pre><p>增加业务代码，如controller，service，model等，最后生成war包，通过容器进行启动</p><h2 id="什么是Spring-Boot？它解决了什么问题？"><a href="#什么是Spring-Boot？它解决了什么问题？" class="headerlink" title="什么是Spring Boot？它解决了什么问题？"></a>什么是Spring Boot？它解决了什么问题？</h2><p>初期的Spring通过代码加配置的形式为项目提供了良好的灵活性和扩展性，但随着Spring越来越庞大，其配置文件也越来越繁琐，太多复杂的xml文件也一直是Spring被人诟病的地方，特别是近些年其他简洁的WEB方案层出不穷，如基于Python或Node.Js，几行代码就能实现一个WEB服务器，对比起来，大家渐渐觉得Spring那一套太过繁琐，此时，Spring社区推出了Spring Boot，它的目的在于实现自动配置，降低项目搭建的复杂度，如需要搭建一个接口服务，通过Spring Boot，几行代码即可实现，请看代码示例：</p><pre><code>//引入spring-boot-starter-web依赖&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;//声明Spring Boot应用，直接写业务逻辑即可@Controller@SpringBootApplicationpublic class MockServerApplication {    @RequestMapping(&quot;/hi&quot;)    @ResponseBody    String home() {        return &quot;how are you!&quot;;    }    public static void main(String[] args) {        SpringApplication.run(MockServerApplication.class, args);    }}</code></pre><p>你甚至都不用额外的WEB容器，直接生成jar包执行即可，因为spring-boot-starter-web模块中包含有一个内置tomcat，可以直接提供容器使用；基于Spring Boot，不是说原来的配置没有了，而是Spring Boot有一套默认配置，我们可以把它看做比较通用的约定，而Spring Boot遵循的也是约定优于配置原则，同时，如果你需要使用到Spring以往提供的各种复杂但功能强大的配置功能，Spring Boot一样支持<br>在Spring Boot中，你会发现你引入的所有包都是starter形式，如：</p><p>spring-boot-starter-web-services，针对SOAP Web Services</p><p>spring-boot-starter-web，针对Web应用与网络接口</p><p>spring-boot-starter-jdbc，针对JDBC</p><p>spring-boot-starter-data-jpa，基于hibernate的持久层框架</p><p>spring-boot-starter-cache，针对缓存支持<br>等等</p><p>Spring Boot对starter的解释如下：</p><p><strong><em>Starters are a set of convenient dependency descriptors that you can include in your application. You get a one-stop-shop for all the Spring and related technology that you need, without having to hunt through sample code and copy paste loads of dependency descriptors. For example, if you want to get started using Spring and JPA for database access, just include the spring-boot-starter-data-jpa dependency in your project, and you are good to go</em></strong></p><p>这句话的译意为：</p><p><strong><em>Starters是一系列极其方便的依赖描述，通过在你的项目中包含这些starter，你可以一站式获得你所需要的服务，而无需像以往那样copy各种示例配置及代码，然后调试，真正做到开箱即用；比如你想使用Spring JPA进行数据操作，只需要在你的项目依赖中引入spring-boot-starter-data-jpa即可</em></strong></p><h2 id="Spring，Spring-MVC，Spring-Boot-三者比较"><a href="#Spring，Spring-MVC，Spring-Boot-三者比较" class="headerlink" title="Spring，Spring MVC，Spring Boot 三者比较"></a>Spring，Spring MVC，Spring Boot 三者比较</h2><p>三者专注的领域不同，解决的问题也不一样；总的来说，Spring 就像一个大家族，有众多衍生产品例如 Boot，Security，JPA等等。但他们的基础都是Spring 的 IOC 和 AOP，IOC提供了依赖注入的容器，而AOP解决了面向切面的编程，然后在此两者的基础上实现了其他衍生产品的高级功能；Spring MVC是基于 Servlet 的一个 MVC 框架，主要解决 WEB 开发的问题，因为 Spring 的配置非常复杂，各种xml，properties处理起来比较繁琐。于是为了简化开发者的使用，Spring社区创造性地推出了Spring Boot，它遵循约定优于配置，极大降低了Spring使用门槛，但又不失Spring原本灵活强大的功能</p><p><a href="https://upload-images.jianshu.io/upload_images/4185175-a0a50bf022178e1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/667" target="_blank" rel="noopener">https://upload-images.jianshu.io/upload_images/4185175-a0a50bf022178e1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/667</a></p><h2 id="Resource和-Autowired的区别？"><a href="#Resource和-Autowired的区别？" class="headerlink" title="@Resource和@Autowired的区别？"></a>@Resource和@Autowired的区别？</h2><p>@Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。</p><h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3><p>两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。</p><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><h4 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h4><p>@Autowired为Spring提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;只按照byType注入。</p><pre><code>public class TestServiceImpl {    // 下面两种@Autowired只要使用一种即可    @Autowired    private UserDao userDao; // 用于字段上    @Autowired    public void setUserDao(UserDao userDao) { // 用于属性的方法上        this.userDao = userDao;    }}</code></pre><p>  @Autowired注解是<strong>按照类型（byType）装配</strong>依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。如下：</p><pre><code>public class TestServiceImpl {    @Autowired    @Qualifier(&quot;userDao&quot;)    private UserDao userDao;}</code></pre><h4 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h4><p>@Resource默认按照ByName自动注入，<strong><em> 是JDK1.6支持的注解，按照名称进行装配，</em></strong><br>由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。</p><pre><code>public class TestServiceImpl {    // 下面两种@Resource只要使用一种即可    @Resource(name=&quot;userDao&quot;)    private UserDao userDao; // 用于字段上    @Resource(name=&quot;userDao&quot;)    public void setUserDao(UserDao userDao) { // 用于属性的setter方法上        this.userDao = userDao;    }}</code></pre><p>  注：最好是将@Resource放在setter方法上，因为这样更符合面向对象的思想，通过set、get去操作属性，而不是直接去操作属性。</p><h5 id="Resource装配顺序："><a href="#Resource装配顺序：" class="headerlink" title="@Resource装配顺序："></a>@Resource装配顺序：</h5><p><strong><em> ①如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。</em></strong></p><p><strong><em> ②如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。</em></strong></p><p><strong><em> ③如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。</em></strong></p><p><strong><em> ④如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。</em></strong></p><pre><code>@Resource的作用相当于@Autowired，只不过@Autowired按照byType自动注入。</code></pre><h1 id="Mac-OS-Linux命令查询网络端口占用情况，查找-杀死进程"><a href="#Mac-OS-Linux命令查询网络端口占用情况，查找-杀死进程" class="headerlink" title="Mac OS/Linux命令查询网络端口占用情况，查找/杀死进程"></a>Mac OS/Linux命令查询网络端口占用情况，查找/杀死进程</h1><h2 id="netstat命令"><a href="#netstat命令" class="headerlink" title="netstat命令"></a>netstat命令</h2><pre><code>netstat -an | grep 3306</code></pre><p>3306替换成需要grep的端口号</p><h2 id="lsof命令"><a href="#lsof命令" class="headerlink" title="lsof命令"></a>lsof命令</h2><p>通过list open file命令可以查看到当前打开文件，在linux中所有事物都是以文件形式存在，包括网络连接及硬件设备。</p><pre><code>lsof -i:80</code></pre><p>-i参数表示网络链接，:80指明端口号，该命令会同时列出PID，方便kill</p><p>查看所有进程监听的端口</p><pre><code>sudo lsof -i -P | grep -i &quot;listen&quot;</code></pre><h2 id="lsof命令参数"><a href="#lsof命令参数" class="headerlink" title="lsof命令参数"></a>lsof命令参数</h2><p>-a 列出打开文件存在的进程</p><p>-c&lt;进程名&gt; 列出指定进程所打开的文件</p><p>-g  列出GID号进程详情</p><p>-d&lt;文件号&gt; 列出占用该文件号的进程</p><p>+d&lt;目录&gt;  列出目录下被打开的文件</p><p>+D&lt;目录&gt;  递归列出目录下被打开的文件</p><p>-n&lt;目录&gt;  列出使用NFS的文件</p><p>-i&lt;条件&gt;  列出符合条件的进程。（4、6、协议、:端口、 @ip ）</p><p>-p&lt;进程号&gt; 列出指定进程号所打开的文件</p><p>-u  列出UID号进程详情</p><p>-h 显示帮助信息</p><p>-v 显示版本信息</p><h2 id="ps-A-grep-进程名"><a href="#ps-A-grep-进程名" class="headerlink" title="ps -A | grep [进程名]"></a>ps -A | grep [进程名]</h2><p>找PID： ps -A | grep [进程名]</p><h2 id="kill-PID"><a href="#kill-PID" class="headerlink" title="kill [PID]"></a>kill [PID]</h2><p>杀进程：kill [PID]<br>参考资料：</p><p>【1】<a href="https://www.jianshu.com/p/42620a0a2c33" target="_blank" rel="noopener">https://www.jianshu.com/p/42620a0a2c33</a></p><p>【2】<a href="https://www.cnblogs.com/think-in-java/p/5474740.html" target="_blank" rel="noopener">https://www.cnblogs.com/think-in-java/p/5474740.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;阐述Spring，Spring MVC，Spring Boot 三者的原理和区别。学习笔记II中涉及到对@Resource和@Autowired的区别做了解释。&lt;br&gt;对用命令查询网络端口占用情况，查找/杀死进程做了回顾性的复习。&lt;/p&gt;
    
    </summary>
    
      <category term="2019年7月" scheme="http://yoursite.com/categories/2019%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
</feed>
